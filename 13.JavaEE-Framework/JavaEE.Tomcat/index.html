<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="JavaEE,Tomcat," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="为什么 Java Web 开发需要 TomcatJavaEE、Servlet、Java Web 的概念：  Java EE（Java Platform Enterprise Edition，2018 年 3 月更名为Jakarta EE）是一些列（Java 企业级开发）标准集合； Servlet 是 Java EE 众多标准下的一个 （link JavaEE.Servlet），主要定义了进行 J">
<meta name="keywords" content="JavaEE,Tomcat">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat">
<meta property="og:url" content="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="为什么 Java Web 开发需要 TomcatJavaEE、Servlet、Java Web 的概念：  Java EE（Java Platform Enterprise Edition，2018 年 3 月更名为Jakarta EE）是一些列（Java 企业级开发）标准集合； Servlet 是 Java EE 众多标准下的一个 （link JavaEE.Servlet），主要定义了进行 J">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/JavaEE.Tomcat-2023-05-04-1.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/javaee/tomcat_ajp_apache.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/javaee/tomcat_architecture.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/javaee/tomcat-nio-connector-process.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/javaee/tomcat-nioendpoint-poler-worker.png">
<meta property="og:updated_time" content="2023-05-09T05:50:51.646Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tomcat">
<meta name="twitter:description" content="为什么 Java Web 开发需要 TomcatJavaEE、Servlet、Java Web 的概念：  Java EE（Java Platform Enterprise Edition，2018 年 3 月更名为Jakarta EE）是一些列（Java 企业级开发）标准集合； Servlet 是 Java EE 众多标准下的一个 （link JavaEE.Servlet），主要定义了进行 J">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/"/>





  <title>Tomcat | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Tomcat</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/13-J2EE/" itemprop="url" rel="index">
                    <span itemprop="name">13.J2EE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,926
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png" alt="Tomcat"></p>
<h1 id="为什么-Java-Web-开发需要-Tomcat"><a href="#为什么-Java-Web-开发需要-Tomcat" class="headerlink" title="为什么 Java Web 开发需要 Tomcat"></a>为什么 Java Web 开发需要 Tomcat</h1><p>JavaEE、Servlet、Java Web 的概念：</p>
<ul>
<li><strong>Java EE</strong>（Java Platform Enterprise Edition，2018 年 3 月更名为<strong>Jakarta EE</strong>）是一些列（Java 企业级开发）标准集合；</li>
<li>Servlet 是 Java EE 众多标准下的一个 （link <a href="/13.JavaEE-Framework/JavaEE.Servlet/" title="JavaEE.Servlet">JavaEE.Servlet</a>），主要定义了进行 Java Web 开发的规范（Request、Response 对象、servlet 生命周期）</li>
</ul>
<p>一个典型的 Servlet 工作模式：</p>
<ul>
<li>创建并填充 Request 对象，包括：URI、参数、method、请求头信息、请求体信息等</li>
<li>创建 Response 对象</li>
<li>执行业务逻辑，将结果通过 Response 的输出流输出到客户端</li>
</ul>
<p>所以 Servlet 定义了众多规范：Request &amp; Response 对象、Servlet 生命周期（init &amp; service &amp; destory 方法）…<br>但 Servlet 没有 main 方法，需要在一个 Servlet 容器里面才能执行，Servlet 容器按照上述规范调用 Servlet 的方法，Tomcat 即是一个 Servlet 容器，在下面 Tomcat 源码分析可以看到 Tomcat 是如何使用 Servlet 规范处理一个 Http 请求的：</p>
<blockquote>
<ul>
<li>Tomcat 接到 Http 请求后，使用 Poller 线程来处理这个请求的 socket，在 Poller 线程没有太多的处理，只是确认收包完整，然后把请求丢给 executor（工作线程池）；</li>
<li>在工作线程，把 Socket 读取到的数据，按照 Http 协议进行解析，并生成 Request 对象（这里也是按照 Servlet Request 的标准），并最终调用了 <code>Servlet.service()</code></li>
<li>Tomcat 的一个 Context 对应一个 <strong>ServletContext</strong>，一个 Context 下有 1 个 or 多个 <strong>Servlet 实现</strong></li>
</ul>
</blockquote>
<p>回答最开是问题，为什么 Java Web 开发需要 Tomcat？<br>Java Web 一般要遵循 Servlet 规范，Tomcat 是一个 Servlet 容器的实现，所以~ Java Web 开发需要 Tomcat。<br>那么开发 Java Web 可以摆脱 Servlet 吗？也可以不用，比如使用</p>
<h1 id="Tomcat-整体架构"><a href="#Tomcat-整体架构" class="headerlink" title="Tomcat 整体架构"></a>Tomcat 整体架构</h1><p><img src="/images/JavaEE.Tomcat-2023-05-04-1.png" alt="../_images/JavaEE.Tomcat-2023-05-04-1.png"></p>
<p>Tomcat 的架构如上图，主要的组件如下：</p>
<ul>
<li><p><strong>Server</strong>: 表示服务器，它提供了一种优雅的方式来启动和停止整个系统，不必单独启停连接器和容器；它是 Tomcat 构成的顶级构成元素，所有一切均包含在 Server 中；</p>
</li>
<li><p><strong>Service</strong>: 表示服务，Server 可以运行多个服务。比如一个 Tomcat 里面可运行订单服务、支付服务、用户服务等等；Server 的实现类 StandardServer 可以包含一个到多个 Services, Service 的实现类为 StandardService 调用了容器(Container)接口，其实是调用了 Servlet Engine(引擎)，而且 StandardService 类中也指明了该 Service 归属的 Server;</p>
</li>
<li><p><strong>Container</strong>: 表示容器，可以看做 Servlet 容器；引擎(Engine)、主机(Host)、上下文(Context)和 Wraper 均继承自 Container 接口，所以它们都是容器。</p>
<ul>
<li>Engine – 引擎</li>
<li>Host – 主机</li>
<li>Context – 上下文</li>
<li>Wrapper – 包装器</li>
</ul>
</li>
<li><p><strong>Connector</strong>: 表示连接器, <strong>它将 Service 和 Container 连接起来</strong>，首先它需要注册到一个 Service，它的作用就是把来自客户端的请求转发到 Container(容器)，这就是它为什么称作连接器, 它支持的协议如下：</p>
<ul>
<li>支持 AJP 协议</li>
<li>支持 Http 协议</li>
<li>支持 Https 协议</li>
</ul>
</li>
<li><p><strong>Service 内部</strong>还有各种支撑组件，下面简单罗列一下这些组件</p>
<ul>
<li>Manager – 管理器，用于管理会话 Session</li>
<li>Logger – 日志器，用于管理日志</li>
<li>Loader – 加载器，和类加载有关，只会开放给 Context 所使用</li>
<li>Pipeline – 管道组件，配合 Valve 实现过滤器功能</li>
<li>Valve – 阀门组件，配合 Pipeline 实现过滤器功能</li>
<li>Realm – 认证授权组件</li>
</ul>
</li>
</ul>
<p>在下面讲解配置文件的时候可以看到，server.xml 里的元素，与上面的组件一一对应。</p>
<p>本节参考 @ref： <a href="https://pdai.tech/md/framework/tomcat/tomcat-x-arch.html" target="_blank" rel="noopener">https://pdai.tech/md/framework/tomcat/tomcat-x-arch.html</a></p>
<h1 id="配置文件-server-xml"><a href="#配置文件-server-xml" class="headerlink" title="配置文件 server.xml"></a>配置文件 server.xml</h1><p>一个配置文件实例:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JasperListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="server-xml-配置元素分类"><a href="#server-xml-配置元素分类" class="headerlink" title="server.xml 配置元素分类"></a>server.xml 配置元素分类</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>server.xml 的整体结构如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 现在常常使用自动部署，不推荐配Context --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Context表示一个War应用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>该结构中只给出了 Tomcat 的核心组件，除了核心组件外，Tomcat 还有一些其他组件，下面介绍一下组件的分类。</p>
<h3 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h3><p>server.xml 文件中的元素可以分为以下 4 类：</p>
<ul>
<li>（1）顶层元素：<code>&lt;Server&gt;</code> 和 <code>&lt;Service&gt;</code></li>
</ul>
<p><code>&lt;Server&gt;</code> 元素是整个配置文件的根元素，<code>&lt;Service&gt;</code> 元素则代表一个 Engine 元素以及一组与之相连的 Connector 元素。</p>
<ul>
<li>（2）连接器：<code>&lt;Connector&gt;</code></li>
</ul>
<p><code>&lt;Connector&gt;</code> 代表了外部客户端发送请求到特定 Service 的接口；同时也是外部客户端从特定 Service 接收响应的接口。</p>
<ul>
<li>（3）容器：<code>&lt;Engine&gt;</code> <code>&lt;Host&gt;</code> <code>&lt;Context&gt;</code></li>
</ul>
<p>容器的功能是处理 Connector 接收进来的请求，并产生相应的响应。Engine、Host 和 Context 都是容器，都实现了 Container 接口，但它们不是平行的关系，而是父子关系：Engine 包含 Host，Host 包含 Context。</p>
<ul>
<li>Engine 表示一个 Servlet 引擎，它可以包含一个或多个子容器，比如 Host 或者 Context 容器；</li>
<li>Host 表示一台虚拟的主机，它可以包含一系列 Context 容器；</li>
<li>Context 表示一个唯一的 ServletContext，一个 Context 对应一个 Web 工程，它可以包含一个或多个 Wrapper 容器；</li>
<li>Wrapper 表示一个独立的 Servlet 定义，即 Wrapper 本质就是对 Servlet 进行了一层包装。</li>
</ul>
<p>一个 Engine 组件可以处理 Service 中的所有请求，一个 Host 组件可以处理发向一个特定虚拟主机的所有请求，一个 Context 组件可以处理一个特定 Web 应用的所有请求。</p>
<ul>
<li>（4）内嵌组件：</li>
</ul>
<p>可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host 和 Context 是最重要的最核心的 Tomcat 组件，其他组件都可以归为内嵌组件。</p>
<p>下面将详细介绍 Tomcat 中各个核心组件的作用，以及相互之间的关系。</p>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>本部分将分别介绍各个核心组件的作用、特点以及配置方式等。</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server 元素在最顶层，代表整个 Tomcat 容器，因此它必须是 server.xml 中唯一一个最外层的元素。一个 Server 元素中可以有一个或多个 Service 元素。</p>
<p>在第一部分的例子中，在最外层有一个 <code>&lt;Server&gt;</code> 元素，shutdown 属性表示关闭 Server 的指令；port 属性表示 Server 接收 shutdown 指令的端口号，设为-1可以禁掉该端口。</p>
<p>Server 的主要任务，就是提供一个接口让客户端能够访问到这个 Service 集合，同时维护它所包含的所有的 Service 的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的 Service。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 的作用，是在 Connector 和 Engine 外面包了一层，把它们组装在一起，对外提供服务。一个 Service 可以包含多个 Connector，但是只能包含一个 Engine；其中 Connector 的作用是从客户端接收请求，Engine 的作用是处理接收进来的请求。</p>
<p>在第一部分的例子中，Server 中包含一个名称为“Catalina”的 Service。实际上，Tomcat 可以提供多个 Service，不同的 Service 监听不同的端口，后文会有介绍。</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector 的主要功能，是接收连接请求，创建 Request 和 Response 对象用于和请求端交换数据；然后分配线程让 Engine 来处理这个请求，并把产生的 Request 和 Response 对象传给 Engine。</p>
<p>通过配置 Connector，可以控制请求 Service 的协议及端口号。在第一部分的例子中，Service 包含两个 Connector：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>（1）通过配置第 1 个 Connector，客户端可以通过 8080 端口号使用 http 协议访问 Tomcat。其中，protocol 属性规定了请求的协议，port 规定了请求的端口号，redirectPort 表示当强制要求 https 而请求是 http 时，重定向至端口号为 8443 的 Connector，connectionTimeout 表示连接的超时时间。</li>
<li>（2）通过配置第 2 个 Connector，客户端可以通过 8009 端口号使用 AJP 协议访问 Tomcat。AJP 协议负责和其他的 HTTP 服务器(如 Apache)建立连接；在把 Tomcat 与其他 HTTP 服务器集成时，就需要用到这个连接器。之所以使用 Tomcat 和其他服务器集成，是因为 Tomcat 可以用作 Servlet/JSP 容器，但是对静态资源的处理速度较慢，不如 Apache 和 IIS 等 HTTP 服务器；因此常常将 Tomcat 与 Apache 等集成，前者作 Servlet 容器，后者处理静态资源，而 AJP 协议便负责 Tomcat 和 Apache 的连接。Tomcat 与 Apache 等集成的原理如下图(图片来源)：</li>
</ul>
<p><img src="/images/javaee/tomcat_ajp_apache.png" alt="tomcat_ajp_apache"></p>
<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine 组件在 Service 组件中有且只有一个；Engine 是 Service 组件中的请求处理组件。Engine 组件从一个或多个 Connector 中接收请求并处理，并将完成的响应返回给 Connector，最终传递给客户端。</p>
<p>在第一部分的例子中，Engine 的配置语句如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，name 属性用于日志和错误信息，在整个 Server 中应该唯一。defaultHost 属性指定了默认的 host 名称，当发往本机的请求指定的 host 名称不存在时，一律使用 defaultHost 指定的 host 进行处理；因此，defaultHost 的值，必须与 Engine 中的一个 Host 组件的 name 属性值匹配。</p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><h4 id="Engine-与-Host"><a href="#Engine-与-Host" class="headerlink" title="Engine 与 Host"></a>Engine 与 Host</h4><p>Host 是 Engine 的子容器。Engine 组件中可以内嵌 1 个或多个 Host 组件，每个 Host 组件代表 Engine 中的一个虚拟主机。Host 组件至少有一个，且其中一个的 name 必须与 Engine 组件的 defaultHost 属性相匹配。</p>
<h4 id="Host-的作用"><a href="#Host-的作用" class="headerlink" title="Host 的作用"></a>Host 的作用</h4><p>Host 虚拟主机的作用，是运行多个 Web 应用（一个 Context 代表一个 Web 应用），并负责安装、展开、启动和结束每个 Web 应用。</p>
<p>Host 组件代表的虚拟主机，对应了服务器中一个网络名实体(如” <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> ”，或 IP 地址”116.25.25.25”)；为了使用户可以通过网络名连接 Tomcat 服务器，这个名字应该在 DNS 服务器上注册。</p>
<h4 id="Host-的配置"><a href="#Host-的配置" class="headerlink" title="Host 的配置"></a>Host 的配置</h4><p>在第一部分的例子中，Host 的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面对其中配置的属性进行说明：</p>
<p>name 属性指定虚拟主机的主机名，一个 Engine 中有且仅有一个 Host 组件的 name 属性与 Engine 组件的 defaultHost 属性相匹配；一般情况下，主机名需要是在 DNS 服务器中注册的网络名，但是 Engine 指定的 defaultHost 不需要，原因在前面已经说明。</p>
<p>unpackWARs 指定了是否将代表 Web 应用的 WAR 文件解压；如果为 true，通过解压后的文件结构运行该 Web 应用，如果为 false，直接使用 WAR 文件运行 Web 应用。</p>
<p>Host 的 autoDeploy 和 appBase 属性，与 Host 内 Web 应用的自动部署有关；此外，本例中没有出现的 xmlBase 和 deployOnStartup 属性，也与 Web 应用的自动部署有关；将在下一节(Context)中介绍。</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="Context-的作用"><a href="#Context-的作用" class="headerlink" title="Context 的作用"></a>Context 的作用</h4><p>Context 元素代表在特定虚拟主机上运行的一个 Web 应用。每个 Web 应用基于 WAR 文件，或 WAR 文件解压后对应的目录（这里称为应用目录）。</p>
<p>Context 是 Host 的子容器，每个 Host 中可以定义任意多的 Context 元素。</p>
<p>在第一部分的例子中，可以看到 server.xml 配置文件中并没有出现 Context 元素的配置。这是因为，Tomcat 开启了自动部署，Web 应用没有在 server.xml 中配置静态部署，而是由 Tomcat 通过特定的规则自动部署。下面介绍一下 Tomcat 自动部署 Web 应用的机制。</p>
<h4 id="Web-应用自动部署"><a href="#Web-应用自动部署" class="headerlink" title="Web 应用自动部署"></a>Web 应用自动部署</h4><p>如何开启自动部署 War:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外 Context 组件还有一个 reloadable 属性, <code>&lt;Context docBase=&quot;xxx&quot; path=&quot;/xxx&quot; reloadable=&quot;true&quot;/&gt;</code><br>替换 WEB-INF/lib 目录中的 jar 文件或 WEB-INF/classes 目录中的 class 文件时，reloadable=”true”会让修改生效（但代价不小），该选项适合调试。</p>
<p>autoDeploy 和 reloadable 的区别是, 前者是 Host 的属性后者是 Context 的属性,<br>前者监控的是 webapps 目录下 War 包的改动, 后者监控的是 webapps 下面文件夹内 jar 或者 class 文件的变化;</p>
<p>一般线上环境会关闭这两个参数, 开发阶段可以通过这两个参数无需重启 tomcat 预览改变;</p>
<h5 id="自动部署的实现"><a href="#自动部署的实现" class="headerlink" title="自动部署的实现"></a>自动部署的实现</h5><blockquote>
<p>Tomcat 的 Engine 会启动一个线程，该线程每 10s 会发送一个发送一个事件，监听到该事件的部署配置类, 会自动去扫描 webapp 文件夹下的 war 包，将其加载成一个 Context，即启动一个 web 服务。</p>
</blockquote>
<p>Tomcat 的 <code>StandardEngine</code> 会在 <code>starInternal()</code> 启动一个线程，该线程运行的是 <code>ContainerBackgroundProcessor.run()</code> 方法,<br>这个 run 每隔10s 唤醒调用一次 <code>processChildren()</code>, 继续跟踪该方法，会看到调用其子容器 Engine、Host、Context、Wrapper 各容器组件及与它们相关的其它组件的 backgroundProcess 方法。<br><code>backgroundProcess()</code> 发送一个事件 <code>Lifecycle.PERIODIC_EVENT</code>,<br>StandardHost 通 server.xml 配置了 HostConfig 监听器，对该事件的响应方法是 <code>HostConfig.lifecycleEvent()</code>,<br><code>lifecycleEvent()</code> 会检查 <code>autoDeploy=&quot;true&quot;</code> 的配置, 如果开启了, 则调用 <code>deployApps()</code> 扫描 webapp 文件夹下的 war 包，将其加载成一个 Context，即启动一个 web 服务。</p>
<h2 id="核心组件的关联"><a href="#核心组件的关联" class="headerlink" title="核心组件的关联"></a>核心组件的关联</h2><h3 id="整体关系"><a href="#整体关系" class="headerlink" title="整体关系"></a>整体关系</h3><p>核心组件之间的整体关系，在上一部分有所介绍，这里总结一下：</p>
<p>Server 元素在最顶层，代表整个 Tomcat 容器；一个 Server 元素中可以有一个或多个 Service 元素。<br>Service 在 Connector 和 Engine 外面包了一层，把它们组装在一起，对外提供服务。<strong>一个 Service 可以包含多个 Connector，但是只能包含一个 Engine；</strong>  Connector 接收请求，Engine 处理请求。<br>Engine、Host 和 Context 都是容器，且 Engine 包含 Host，Host 包含 Context。每个 Host 组件代表 Engine 中的一个虚拟主机；每个 Context 组件代表在特定 Host 上运行的一个 Web 应用。</p>
<p><img src="/images/javaee/tomcat_architecture.png" alt=""></p>
<h3 id="如何确定请求由谁处理？"><a href="#如何确定请求由谁处理？" class="headerlink" title="如何确定请求由谁处理？"></a>如何确定请求由谁处理？</h3><p>当请求被发送到 Tomcat 所在的主机时，如何确定最终哪个 Web 应用来处理该请求呢？</p>
<ul>
<li>（1）根据协议和端口号选定 Service 和 Engine</li>
</ul>
<p>Service 中的 Connector 组件可以接收特定端口的请求，当请求进来时，Tomcat 便可以根据协议和端口号选定处理请求的 Service；Service 一旦选定，Engine 也就确定。</p>
<ul>
<li>（2）根据域名或 IP 地址选定 Host</li>
</ul>
<p>Service 确定后，Tomcat 在 Service 中寻找名称与域名/IP 地址匹配的 Host 处理该请求。如果没有找到，则使用 Engine 中指定的 defaultHost 来处理该请求。</p>
<ul>
<li>（3）根据 URI 选定 Context/Web 应用</li>
</ul>
<p>这一点在 Context 一节有详细的说明：Tomcat 根据应用的 path 属性与 URI 的匹配程度来选择 Web 应用处理相应请求，这里不再赘述。</p>
<ul>
<li>（4）举例</li>
</ul>
<p>以请求 <a href="http://localhost:8080/app1/index.html为例" target="_blank" rel="noopener">http://localhost:8080/app1/index.html为例</a> ，首先通过协议和端口号（http 和 8080）选定 Service；然后通过主机名（localhost）选定 Host；然后通过 uri（/app1/index.html）选定 Web 应用。</p>
<h3 id="如何部署多个-war-包项目"><a href="#如何部署多个-war-包项目" class="headerlink" title="如何部署多个 war 包项目"></a>如何部署多个 war 包项目</h3><p>@todo</p>
<h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是 Tomcat 的启动和停止。<br>监听器可以在 Server、Engine、Host 或 Context 中，本例中的监听器都是在 Server 中。实际上，本例中定义的 6 个监听器，都只能存在于 Server 组件中。监听器不允许内嵌其他组件。<br>监听器需要配置的最重要的属性是 className，该属性规定了监听器的具体实现类，该类必须实现了 <code>org.apache.catalina.LifecycleListener</code> 接口。</p>
<h3 id="GlobalNamingResources-与-Realm"><a href="#GlobalNamingResources-与-Realm" class="headerlink" title="GlobalNamingResources 与 Realm"></a>GlobalNamingResources 与 Realm</h3><p>@todo</p>
<h3 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h3><p>在第一部分的例子中，Host 元素内定义了 Valve 组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>单词 Valve 的意思是“阀门”，在 Tomcat 中代表了请求处理流水线上的一个组件；Valve 可以与 Tomcat 的容器(Engine、Host 或 Context)关联。<br>不同的 Valve 有不同的特性，下面介绍一下本例中出现的 AccessLogValve。<br>AccessLogValve 的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve 放在 Host 下，便可以记录该 Host 处理的所有请求。AccessLogValve 记录的日志就是访问日志，每天的请求会写到一个日志文件里。AccessLogValve 可以与 Engine、Host 或 Context 关联；在本例中，只有一个 Engine，Engine 下只有一个 Host，Host 下只有一个 Context，因此 AccessLogValve 放在三个容器下的作用其实是类似的。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="bin-catalina-sh"><a href="#bin-catalina-sh" class="headerlink" title="bin/catalina.sh"></a>bin/catalina.sh</h2><p>这里主要是对 JVM 参数的设置，主要修改 Xms, Xmx, PermSize 几个参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS="-Xms8g -Xmx8g -Xmn2g -server -DServer=mblog -XX:PermSize=128m -XX:MaxPermSize=128m -XX:MaxTenuringThreshold=4 -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=8 -XX:CMSInitiatingOccupancyFraction=70 -XX:+ExplicitGCInvokesConcurrent -XX:+PrintFlagsFinal -XX:+PrintCommandLineFlags -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -Xloggc:../gclogs/gc.log.$nowday"</span><br></pre></td></tr></table></figure>
<h2 id="conf-server-xml"><a href="#conf-server-xml" class="headerlink" title="conf/server.xml"></a>conf/server.xml</h2><p>这里主要是对 Connector 和线程池的设置</p>
<p>主要优化点 @tldr：</p>
<ul>
<li><strong>maxThreads</strong> = 业务线程池大小，一般几百~几 K，如果并发到来的<strong>请求数</strong>超过 maxThreads，再新来的请求不能被及时处理；</li>
<li><strong>maxConnections</strong>：意思是 Tomcat 维护的<strong>已建立连接数</strong>上限。当连接数达到 maxConnections，Tomcat 不会再 accept，而是直接 block 掉（这时候系统仍然能 accept，但 Tomcat 不会把新连接扔给 Poller 线程了，而是 block 掉新的连接），maxConnections 在 NIO 模式默认是 1W；</li>
<li><strong>acceptCount</strong>：如果所有的业务线程都在忙（ all possible request processing threads are in use），即并发处理中的<strong>请求数</strong>超过了 maxThreads。这时候新请会放入 accept 队列（区别 socket 的 accept），acceptCount 即是这个队列的长度，默认 100；</li>
</ul>
<blockquote>
<p>区分连接数 &amp; 请求数：</p>
<ul>
<li>连接数：建立并监听读写事件的 Connection 数量，大部分 Connection 都是空闲的，少数有读写</li>
<li>请求数：指客户端发 Http Request 过来，Tomcat 会把 Request 放入<strong>业务线程池</strong>处理</li>
</ul>
</blockquote>
<p>用 <a href="https://asciiflow.com/#/" target="_blank" rel="noopener">ASCIIFlow</a> 画图解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">新连接到来：</span><br><span class="line"></span><br><span class="line">[Acceptor] ────────────► [Poller] ──线程池是否满？────NO─────► [业务线程池]&lt;maxThreads limits&gt;</span><br><span class="line">      &lt;maxConnections limits&gt;            │                    ▲</span><br><span class="line">                                        Yes                   │</span><br><span class="line">                                         │                    │</span><br><span class="line">                                         ┴───►[accept queue]──┴</span><br><span class="line">                                          &lt;acceptCount limits&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图示：</span><br><span class="line">[ ] 表示对象实体</span><br><span class="line">&lt; &gt; 表示限制</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这几个参数容易混淆，如果搞清楚 Tomcat 的 NIO 线程模型，就不难理解了</p>
</blockquote>
<hr>
<p>Tomcat 采用 Request Per Thread 策略, 每个用户请求由一个线程处理, <code>&lt;Executor&gt;</code> 部分定义了该线程池, 该线程池被多个 <code>&lt;Connector&gt;</code> 共享, server.xml 里的优化主要在 <code>&lt;Connector&gt;</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.StandardThreadExecutor"</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxThreads</span>=<span class="string">"300"</span> <span class="attr">minSpareThreads</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定使用上面的线程池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">"8080"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"8000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptCount</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxThreads</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptorThreadCount</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">"utf-8"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"443"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">"on"</span> <span class="attr">compressionMinSize</span>=<span class="string">"1024"</span> <span class="attr">compressableMimeType</span>=<span class="string">"text/html,text/xml,text/javascript,text/css,text/plain,application/json,application/xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p>Executor 参数</p>
<ul>
<li><strong>maxThreads</strong>:  线程池最大线程数</li>
<li><strong>minSpareThreads</strong>: 线程池最小线程数(线程池初始化时), 默认 25</li>
</ul>
</li>
<li><p>Connector 参数:</p>
<ul>
<li><strong>executor</strong>: 指明使用哪一个 Executor, 如果指定了,那么 Connector 中所有关于线程的设定会被忽略, 如果没有指定一个线程池, Connector 将会创建一个私有的线程池.</li>
<li><strong>maxThreads</strong>: 用于处理客户端请求的最大线程数, 设置为多少视 CPU 处理能力而定, 一般单个应用不应该超过 300, 如果超过 300 应考虑多个 Tomcat 组成集群方式</li>
<li>enableLookups: 是否开启域名反查，一般设置为 false 来提高处理能力，它的取值还有 true，一般很少使用。若设为 true, 则支持域名解析，可把 ip 地址解析为主机名</li>
<li>connectionTimeout: 网络连接超时，单位：毫秒。设置为 0 表示永不超时</li>
<li><strong>acceptorThreadCount</strong>: 默认为 1，表示用于 accept 新 socket 连接的线程个数。一般跟监听端口数匹配。</li>
<li><strong>acceptCount</strong>: 当全部线程都在忙(意味着客户端并发数超过 maxThreads 个线程), 新的请求会放入 accept 队列, 该值是队列的 size, 默认 100 (如果要增加 Tomcat 并发处理能力, 需要同时增加 acceptCount 和 maxThreads)</li>
<li><strong>maxConnections</strong>: Tomcat 能 accept 并 process 的最大连接数, 超过这个数 tomcat 不再 accept 新的连接, 但不会 process， For NIO and NIO2 the default is 10000. For APR/native, the default is 8192.</li>
<li>compressionMinSize: 大于这个数值讲开启压缩, 默认为 2K</li>
<li>compressableMimeType: 压缩哪些类型</li>
<li><p><strong>protocol</strong>：协议类型，可选类型有四种，分别为 BIO（阻塞型 IO），NIO，NIO2 和 APR。</p>
<ul>
<li>BIO：BIO(Blocking I/O)，顾名思义，即阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作(即 java.io 包及其子包)。Tomcat 在默认情况下，是以 bio 模式运行的。遗憾的是，就一般而言，bio 模式是三种运行模式中性能最低的一种。BIO 配置采用默认即可。</li>
<li>NIO：NIO(New I/O)，是 Java SE 1.4及后续版本提供的一种新的 I/O 操作方式(即 java.nio 包及其子包)。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API，因此 nio 也被看成是 non-blocking I/O 的缩写。它拥有比传统 I/O 操作(bio)更好的并发运行性能。要让 Tomcat 以 nio 模式来运行也比较简单，我们只需要 protocol 类型修改为：<code>protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</code><br>对于互联网应用，我们应该在 NIO、NIO2 之间做选择，因为它能够有效的提升性能（主要是并发能力），其中 NIO2 即为 AIO，需要 JDK 1.7+、Linux 2.6+才能支持。<ul>
<li>NIO：JDK 1.6+，tomcat 6.x+</li>
<li>NIO2：JDK 1.7+，tomcat 7.x+</li>
</ul>
</li>
<li><p>APR: 通过 Native 实现的 I/O 库, Tomcat 通过 JNI 调用;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Tomcat 支持的几种protocol:</span><br><span class="line">//NIO</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">//NIO2</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;</span><br><span class="line">//ARP</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@ref: </p>
<ul>
<li><a href="https://www.cnblogs.com/zhanjindong/p/concurrent-and-tomcat-threads.html" target="_blank" rel="noopener">聊下并发和Tomcat线程数（Updated） - zhanjindong - 博客园</a></li>
<li><a href="https://www.zhihu.com/question/53498767" target="_blank" rel="noopener">tomcat 源码为啥不采用netty 处理并发？ - 知乎</a></li>
</ul>
<h3 id="附-Connector-和线程池参数解析"><a href="#附-Connector-和线程池参数解析" class="headerlink" title="附: Connector 和线程池参数解析"></a>附: Connector 和线程池参数解析</h3><ol>
<li><code>&lt;Executor&gt;</code> 部分, 参数说明: <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html</a><ul>
<li><strong>namePrefix</strong>: The name prefix for each thread created by the executor</li>
<li><strong>maxThreads</strong>: The max number of active threads in this pool, default is 200</li>
<li><strong>minSpareThreads</strong>: The minimum number of threads (idle and active) always kept alive, default is 25</li>
<li><strong>maxIdleTime</strong>: The number of milliseconds before an idle thread shutsdown, unless the number of active threads are less or equal to minSpareThreads. Default value is 60000(1 minute)</li>
<li><strong>maxQueueSize</strong>: The maximum number of runnable tasks that can queue up awaiting execution before we reject them. Default value is Integer.MAX_VALUE</li>
</ul>
</li>
<li><code>&lt;Connector&gt;</code> 部分, <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</a><ul>
<li><strong>executor</strong>: A reference to the name in an Executor element. If this attribute is set, and the named executor exists, the connector will use the executor, and all the other thread attributes will be ignored. Note that if a shared executor is not specified for a connector then the connector will use a private, internal executor to provide the thread pool.</li>
<li><strong>acceptCount</strong>: The maximum queue length for incoming connection requests when all possible request processing threads are in use. Any requests received when the queue is full will be refused. The default value is 100.</li>
<li><strong>connectionTimeout</strong>: The number of milliseconds this Connector will wait, after accepting a connection, for the request URI line to be presented. Use a value of -1 to indicate no (i.e. infinite) timeout. The default value is 60000 (i.e. 60 seconds) but note that the standard server.xml that ships with Tomcat sets this to 20000 (i.e. 20 seconds). Unless disableUploadTimeout is set to false, this timeout will also be used when reading the request body (if any).</li>
<li><strong>maxThreads</strong>: The maximum number of request processing threads to be created by this Connector, which therefore determines the maximum number of simultaneous requests that can be handled. If not specified, this attribute is set to 200. If an executor is associated with this connector, this attribute is ignored as the connector will execute tasks using the executor rather than an internal thread pool. Note that if an executor is configured any value set for this attribute will be recorded correctly but it will be reported (e.g. via JMX) as -1 to make clear that it is not used.</li>
<li><strong>acceptorThreadCount</strong>: The number of threads to be used to accept connections. Increase this value on a multi CPU machine, although you would never really need more than 2. Also, with a lot of non keep alive connections, you might want to increase this value as well. Default value is 1.</li>
<li><strong>maxConnections</strong>: The maximum number of connections that the server will accept and process at any given time. When this number has been reached, the server will accept, but not process, one further connection. This additional connection be blocked until the number of connections being processed falls below maxConnections at which point the server will start accepting and processing new connections again. Note that once the limit has been reached, the operating system may still accept connections based on the acceptCount setting. The default value varies by connector type. For NIO and NIO2 the default is 10000. For APR/native, the default is 8192.<br>Note that for APR/native on Windows, the configured value will be reduced to the highest multiple of 1024 that is less than or equal to maxConnections. This is done for performance reasons.</li>
</ul>
</li>
</ol>
<h3 id="Tomcat-在-NIO-模式下的线程模型"><a href="#Tomcat-在-NIO-模式下的线程模型" class="headerlink" title="Tomcat 在 NIO 模式下的线程模型"></a>Tomcat 在 NIO 模式下的线程模型</h3><p>Tomcat 使用 Connector 完成整个 HTTP Request 的处理流程, 包括 accept socket → NIO Selector 处理 socket 读事件 → 把可读 Socket 分发给 Work 线程 → 从 socket 读取数据并解析为 Http 请求 → Http 请求交给 CoyoteAdaper 处理, CoyoteAdaper 通过 Mapper 找到对应的 Servlet.</p>
<p><img src="/images/javaee/tomcat-nio-connector-process.png" alt="Tomcat-NIO-Connector-Process"></p>
<p>在 NIO 实现的 Connector 中，处理请求的主要实体是 NIoEndpoint 对象。NIoEndpoint 中除了包含 Acceptor 和 Worker 外，还是用了 Poller，处理流程如下图所示:</p>
<p><img src="/images/javaee/tomcat-nioendpoint-poler-worker.png" alt="Tomcat-NioEndpoint-Poler-Worker"></p>
<ul>
<li>Acceptor accept 客户端请求, 这里虽然是基于 NIO 的 connector，但是在接收 socket 方面还是传统的 <code>serverSocket.accept()</code> 方式, Acceptor 获取到客户端请求的 socket, 封装进 tomcat 的实现类 org.apache.tomcat.util.net.NioChannel 对象中, 然后将 NioChannel 对象封装在一个 PollerEvent 对象中，并将 PollerEvent 对象压入 events queue</li>
<li>Poller 读取 events queue 取出 PollerEvent,  Poller 线程中维护了一个 Selector 对象, Poller 从 Event 中取出客户端请求的 socketChannel, 把这个 channel 的 READ 事件注册到 Selector 上.</li>
<li>Poller 通过 <code>Selector.select()</code> 遍历可读的 socketChannel, 从 Worker 线程池中拿到可用的 Worker 线程,将 socket 传递给 Worker 处理</li>
<li>Worker 线程将 socket 封装在 SocketProcessor 对象中。然后从 Http11ConnectionHandler 中取出 Http11NioProcessor 对象，从 Http11NioProcessor 中调用 CoyoteAdapter 的逻辑</li>
</ul>
<p>本节参考:<br><a href="https://my.oschina.net/weiweiblog/blog/1830173" target="_blank" rel="noopener">https://my.oschina.net/weiweiblog/blog/1830173</a><br><a href="https://www.jianshu.com/p/f91f99610b9e" target="_blank" rel="noopener">https://www.jianshu.com/p/f91f99610b9e</a></p>
<h2 id="APR-支持"><a href="#APR-支持" class="headerlink" title="APR 支持"></a>APR 支持</h2><p>APR(Apache Portable Runtime)可移植运行库，它是 Apache HTTP Server 2.x 的核心。APR 有很多用途，包括访问高级 IO 功能(例如 sendfile,<br>epoll 和 OpenSSL)，OS 级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT 管道和 UNIX sockets)。<br>这些功能可以使 Tomcat 作为一个通常的前台 WEB 服务器（类似 Nginx，只转发请求，不做业务），能更好地和其它本地 web 技术集成，总体上让 Java 更有效率作为一个高性能 web 服务器平台而不是简单作为<strong>后台业务容器</strong>。</p>
<p>可以简单地理解为: Tomcat 将以 JNI 的形式调用 APR 库中的 Native Method 处理文件读取或网络传输操作，提升 Tomcat 对静态文件等等的处理性能，APR 模式下的 Tomcat 更像是 Nginx 的角色。</p>
<p>安装步骤:</p>
<ul>
<li>下载 APR, 编译 <code>make &amp;&amp; make install</code></li>
<li>安装 Tomcat Native 到 Tomcat 的安装目录下</li>
<li>修改 conf/server.xml, 修改 <code>&lt;Connector&gt;</code> 的 protocol</li>
</ul>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>参考: <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html" target="_blank" rel="noopener">日志机制 - Tomcat 8 权威指南 - 极客学院Wiki</a></p>
<p>在 Apache Tomcat 上运行的 Web 应用可以使用以下日志：</p>
<ul>
<li>任何自选的日志框架，如 <code>log4j</code>；</li>
<li>使用 JDK 提供的日志 <code>java.util.logging</code>；</li>
<li>Java Servlets 规范所提供的日志 API，如 <code>javax.servlet.ServletContext.log(...)</code>；</li>
</ul>
<blockquote>
<p>当 tomcat 启动时会为每个 app 分配了一个 WebappClassLoader ，这样来避免多个 app 会加载相同 jar 包的问题，<br>不同 Web 应用程序下使用的 Servlet 日志（或者日志框架提供的日志，如 log4j 等）是相互独立的（这与 Tomcat 的 class loader 有关，参考 <a href="http://tomcat.apache.org/tomcat-6.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Class Loader HOW-TO</a> ）。<br>如果 Web 应用程序使用的是 java.util.logging 日志，那么它们并不相互独立，这是因为 java.util.logging 是由 JAVA 系统中的 Bootstrap ClassLoader 来加载的，因此它在各 Web 应用程序之间是共享的。</p>
</blockquote>
<h2 id="JULI-vs-JUL"><a href="#JULI-vs-JUL" class="headerlink" title="JULI vs JUL"></a>JULI vs JUL</h2><p>JUL API（<code>java.util.logging</code>，日志实现，非日志门面）的默认实现功能有限，因此 tomcat 的默认配置中，新增了另一种日志实现 JULI API（<code>org.apache.juli</code>），</p>
<blockquote>
<p>可以在 Tomcat 的 logging.properties 里看到定义了两种日志:<br>java.util.logging 的 <code>java.util.logging.ConsoleHandler</code> ;<br>JULI 的 <code>org.apache.juli.FileHandler</code> ;</p>
</blockquote>
<p><strong>JULI</strong> 同样支持标准 JDK java.util.logging 的配置机制（都默认使用 logging.properties 作为配置文件），不同的是 JULI 的每一个类加载属性文件都可以被设置，并可以在其中定义处理器，这样就给了开发者更大的自由度。<br>JULI 的日志配置分为全局配置和 WebApp 项目配置。<br>全局配置位于 tomcat 的配置目录 <code>${catalina.base}/conf/logging.properties</code> 文件,<br>如果该文件未配置或不可读，那么 tomcat 将会使用 JRE 中的默认日志配置，可以在 <code>${java.home}/lib/logging.properties</code> 查看配置文件的内容；<br>项目配置则是针对不同的项目，配置文件位于 <code>WEB-INFO/classes/logging.properties</code>.</p>
<p>JUL 和 JULI 使用相同的日志级别：SEVERE (最高级别) &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST (所有内容,最低级别)</p>
<p>JULI 所使用的配置与 java.util.logging 所支持的配置基本相同，只不过使用了一些扩展，以便更灵活地配置 logger 和 handler。主要的差别在于：</p>
<ul>
<li>JULI 的 handler 名称前可以加上前缀，所以同一类可以实例化出多个 handler。前缀是一个以数字开头的字符串，并以 . 结尾。比如 22foobar. 就是个有效的前缀。</li>
<li>JULI 的 handler 支持额外的属性, 比如 <code>bufferSize</code></li>
</ul>
<h2 id="Tomcat-日志配置解析"><a href="#Tomcat-日志配置解析" class="headerlink" title="Tomcat 日志配置解析"></a>Tomcat 日志配置解析</h2><p>以下是一个 <code>$CATALINA_BASE/conf</code> 中的默认 logging.properties 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 声明所有的handlers</span></span></span><br><span class="line">handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># RootLogger使用的handlers</span></span></span><br><span class="line">.handlers = 1catalina.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 定义了4个 org.apache.juli.FileHandler : 1catalina, 2localhost, 3manager, 4host-manager</span></span></span><br><span class="line">1catalina.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">1catalina.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">1catalina.org.apache.juli.FileHandler.prefix = catalina.</span><br><span class="line">1catalina.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">2localhost.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">2localhost.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">2localhost.org.apache.juli.FileHandler.prefix = localhost.</span><br><span class="line">2localhost.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">3manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">3manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">3manager.org.apache.juli.FileHandler.prefix = manager.</span><br><span class="line">3manager.org.apache.juli.FileHandler.bufferSize = 16384</span><br><span class="line">3manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">4host-manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.prefix = host-manager.</span><br><span class="line">4host-manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 定义 ava.util.logging.ConsoleHandler :</span></span></span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br><span class="line">java.util.logging.ConsoleHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 定义handlers, 使用上面定义的 FileHandler</span></span></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers = 2localhost.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers = 3manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers = 4host-manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> For example, <span class="built_in">set</span> the org.apache.catalina.util.LifecycleBase logger to <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> each component that extends LifecycleBase changing state:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">org.apache.catalina.util.LifecycleBase.level = FINE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To see debug messages <span class="keyword">in</span> TldLocationsCache, uncomment the following line:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">org.apache.jasper.compiler.TldLocationsCache.level = FINE</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>java.util.logging.ConsoleHandler</code>:<br>When running Tomcat on unixes, the console output is usually redirected to the file named catalina.out.<br>The name is configurable using an environment variable. (See the startup scripts).<br>Whatever is written to System.err/out will be caught into that file. That may include:<ul>
<li>Uncaught exceptions printed by java.lang.ThreadGroup.uncaughtException(..)</li>
<li>Thread dumps, if you requested them via a system signal</li>
</ul>
</li>
</ul>
<blockquote>
<p>java.util.logging.ConsoleHandler 是 java 自带的日志处理系统（JUL）的控制台日志 Handler,<br>Tomcat 通过 <code>System.err.println()</code> / <code>System.out.println()</code> 打出的日志会通过 java.util.logging.ConsoleHandler 写入 Tomcat 进程的 stdout/stderr,<br>并最终输出到文件”catalina.out”中, 这个文件名是在 Tomcat 启动脚本里定义的:</p>
</blockquote>
<ul>
<li><code>org.apache.juli.FileHandler</code>:<br>org.apache.juli.FileHandler supports buffering of the logs.<br>The buffering is not enabled by default. To configure it, use the bufferSize property of a handler.<br>The value of 0 uses system default buffering (typically an 8K buffer will be used).<br>A value of &lt; 0 forces a writer flush upon each log write.<br>A value &gt; 0 uses a BufferedOutputStream with the defined value but note that the system default buffering will also be applied.</li>
</ul>
<blockquote>
<p>org.apache.支持日志缓存。日志缓存默认是没有启用的。使用 handler 的 bufferSize 属性可以配置它：<br>属性值为 0 时，代表使用系统默认的缓存（通常使用 8k 缓存）；<br>属性值小于 0 时，将在每个日志写入上强制使用 writer flush（将缓存区中的数据强制写出到系统输出）功能；<br>属性值大于 0 时，则使用带有定义值的 BufferedOutputStream 类——但要注意的是，这也将应用于系统默认的缓存。</p>
</blockquote>
<h2 id="WebApp-的日志配置解析"><a href="#WebApp-的日志配置解析" class="headerlink" title="WebApp 的日志配置解析"></a>WebApp 的日志配置解析</h2><p>下例是一个用于 servlet-examples 应用的 WEB-INF/classes 中的 logging.properties 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Handler specific properties.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describes specific configuration info <span class="keyword">for</span> Handlers.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########################################################</span></span></span><br><span class="line"></span><br><span class="line">org.apache.juli.FileHandler.level = FINE</span><br><span class="line">org.apache.juli.FileHandler.directory =  $&#123;catalina.base&#125;/logs</span><br><span class="line">org.apache.juli.FileHandler.prefix = $&#123;classloader.webappName&#125;.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tomcat 启动时报错 “SEVERE: Error listenerStart” 或者 “SEVERE: Error filterStart” 等, 但没有具体的错误日志:<br>这种一般是因为 Tomcat WebAppClassLoader 加载的<code>org.springframework</code>类的日志没有关联一个 Handler,<br>可以修改 webapps/xxx/WEB-INF/classes/logging.properties, Tomcat 就会在打印 org.springframework 类的详细的报错信息了.<br>注意, 老的应用可能还在使用 System.out 或 System.err，这种情况下还需要在 web 应用的 classes/logging.properties 里增加 java.util.logging.ConsoleHandler:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line">## JULI.FileHandler 的设置</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">## JUL.ConsoleHandler 的设置</span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于还在使用 System.out 或 System.err 的应用:<br>可以通过在 Context 元素上设置 swallowOutput 属性来调整。如该属性设为 true，那么在请求阶段对 System.out/err 的调用就会被拦截，它们的输出也会通过 <code>javax.servlet.ServletContext.log(...)</code> 调用反馈给日志系统。</p>
</blockquote>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><ul>
<li>catalina.2017-08-29.log         //Cataline 引擎的日志文件</li>
<li>localhost.2017-08-29.log        //Tomcat 下内部代码抛出的日志 jsp 页面内部错误的异常</li>
<li>manager.2017-08-29.log          //Tomcat 下默认 manager 应用日志</li>
<li>host-manager.2017-08-29.log     //Tomcat 下默认 manager 应用日志</li>
<li>localhost_access_log.2017-08-29.txt  //访问日志记录</li>
<li>catalina.out                         //控制台输出的日志,Linux 下默认重定向到 catalina.out</li>
</ul>
<p>查看 catalina.sh, 最终启动 tomcat 执行的命令行是 <code>java ${JAVA_OPTS} org.apache.catalina.startup.Bootstrap start</code></p>
<h2 id="生产环境中的日志"><a href="#生产环境中的日志" class="headerlink" title="生产环境中的日志"></a>生产环境中的日志</h2><p>可能需要注意以下方面：</p>
<ul>
<li>将 ConsoleHandler 从配置中移除。默认（ .handlers 设置）日志会使用 FileHandler 和 ConsoleHandler。<br>后者的输出经常会被捕获到一个文件中，比如 catalina.out。从而导致同一消息可能生成了两个副本。</li>
<li>对于不使用的应用(比如 host-manager)，可以考虑将 FileHandlers 移除。</li>
<li>handler 默认使用系统缺省编码来写入日志文件，通过 encoding 属性可以修改设置，详情查看相关的 javadoc 文档。</li>
<li>增加 Access 访问日志。</li>
</ul>
<h2 id="使用-log4j"><a href="#使用-log4j" class="headerlink" title="使用 log4j"></a>使用 log4j</h2><p>参考 <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html#usingLog4j" target="_blank" rel="noopener">使用 Log4j</a> @ref</p>
<ul>
<li>如果只是想在自己的 Web 应用上使用 log4j 时<ul>
<li>只需将 log4j.jar 和 log4j.properties 放到 Web 应用的 WEB-INF/lib 和 WEB-INF/classes 中即可</li>
</ul>
</li>
<li>如果想配置 Tomcat 以便利用 log4j 来进行自身日志记录时，下面的步骤都是必需的:<ul>
<li>创建一个包含下列配置的 log4j.properties 文件，将其保存到 $CATALINA_BASE/lib。<strong>Important!</strong></li>
<li>下载 log4j</li>
<li>下载或构建 tomcat-juli.jar 和 tomcat-juli-adapters.jar，以便作为 Tomcat 的额外组件使用。</li>
<li>将 log4j.jar 和 tomcat-juli-adapters.jar 从 extras 中放入 $CATALINA_HOME/lib 中。</li>
<li>用 extras 中的 tomcat-juli.jar 替换 $CATALINA_HOME/bin/tomcat-juli.jar。</li>
<li>删除 $CATALINA_BASE/conf/logging.properties，以防止 java.util.logging 生成零长度的日志文件。</li>
</ul>
</li>
</ul>
<h1 id="高级-IO"><a href="#高级-IO" class="headerlink" title="高级 IO"></a>高级 IO</h1><h2 id="推送-Comet-支持"><a href="#推送-Comet-支持" class="headerlink" title="推送: Comet 支持"></a>推送: Comet 支持</h2><p>施工中</p>
<h2 id="发送大型静态文件-sendfile"><a href="#发送大型静态文件-sendfile" class="headerlink" title="发送大型静态文件: sendfile"></a>发送大型静态文件: sendfile</h2><p>施工中</p>
<h1 id="How-to-deploy-war"><a href="#How-to-deploy-war" class="headerlink" title="How to deploy war"></a>How to deploy war</h1><p>有 3 中方式部署 war 包:</p>
<ol>
<li>在 server.xml 的<code>&lt;Host&gt;</code>标签中声明<code>&lt;Context&gt;</code>标签</li>
<li>在 server.xml 的<code>&lt;Host&gt;</code>标签中开启 autoDeploy, 将 war 包放入 webapps 中会自动部署</li>
<li>context.xml 配置方式</li>
</ol>
<h2 id="Using-the-UI-manager"><a href="#Using-the-UI-manager" class="headerlink" title="Using the UI manager"></a>Using the UI manager</h2><p>Tomcat 提供了一个网页版的 Manager App, 默认位置在 webapps/manager, 也是一个 web 项目, 使用方式参考: <a href="http://tomcat.apache.org/tomcat-6.0-doc/manager-howto.html#Configuring_Manager_Application_Access" target="_blank" rel="noopener">Apache Tomcat 6.0 (6.0.53) - Manager App HOW-TO</a> @ref</p>
<p>Go to <code>[&lt;protocol&gt;://]localhost:&lt;port&gt;/manager/html/</code> (usually <code>localhost:8080/manager/html/</code>),<br>If you get:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">403 Access Denied</span><br></pre></td></tr></table></figure></p>
<p>go to <code>%CATALINA_HOME%\conf\tomcat-users.xml</code> and check that you have enabled a line like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;tomcat,role1,manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Using-maven"><a href="#Using-maven" class="headerlink" title="Using maven"></a>Using maven</h2><p>待补充…</p>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><blockquote>
<p>@ref 参考: <a href="https://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Apache Tomcat 7 (7.0.93) - Class Loader HOW-TO</a></p>
</blockquote>
<p>与很多服务器应用一样，Tomcat 也安装了各种类加载器。借助类加载器，容器的不同部分以及运行在容器里的 Web Apps 就可以访问不同的仓库（保存着可使用的类和资源）。<br>// 这里英文原文是”different repositories of available classes and resources.” 不知道该怎么翻译这里的”repositories” ?</p>
<blockquote>
<p>在 Java 环境中，类加载器的布局结构是一种父子树的形式。通常，类加载器被请求加载一个特定的类或资源时，它会先把这一请求委托给它的父类加载器，只有（一个或多个）父类加载器无法找到请求的类或资源时，它才开始查看自身的仓库。</p>
</blockquote>
<p>注意，Web 应用的类加载器模式跟这个稍有不同，下文将详细介绍，但基本原理是一样。<br>当 Tomcat 启动后，它就会创建一组类加载器，这些类加载器被布局成如下图所示这种父子关系，父类加载器在子类加载器之上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Bootstrap</span><br><span class="line">        |</span><br><span class="line">     System</span><br><span class="line">        |</span><br><span class="line">     Common</span><br><span class="line">     /     \</span><br><span class="line">Webapp1   Webapp2 ..</span><br></pre></td></tr></table></figure>
<p>如上图所示，Tomcat 在初始化时会创建如下这些类加载器：</p>
<ul>
<li><strong>Bootstrap</strong> 这种类加载器包含 JVM 所提供的基本的运行时类，以及来自系统扩展目录（<code>$JAVA_HOME/jre/lib/ext</code>）里 JAR 文件中的类。<br>注意：在有些 JVM 的实现中，它的作用不仅仅是类加载器，或者它可能根本不可见（作为类加载器）。</li>
<li><strong>System</strong> 这种类加载器通常是根据 CLASSPATH 环境变量内容进行初始化的。所有的这些类对于 Tomcat 内部类以及 Web 应用来说都是可见的。<br>不过，标准的 Tomcat 启动脚本（<code>$CATALINA_HOME/bin/catalina.sh</code> 或 <code>%CATALINA_HOME%\bin\catalina.bat</code>）完全忽略了 CLASSPATH 环境变量自身的内容，相反从下列仓库来构建系统类加载器：<ul>
<li><code>$CATALINA_HOME/bin/bootstrap.jar</code> 包含用来初始化 Tomcat 服务器的 <code>main()</code> 方法，以及它所依赖的类加载器实现类。</li>
<li><code>$CATALINA_BASE/bin/tomcat-juli.jar</code> 或 <code>$CATALINA_HOME/bin/tomcat-juli.jar</code> 日志实现类。其中包括了对 <code>java.util.logging</code> API 的功能增强类（Tomcat JULI），以及对 Tomcat 内部使用的 Apache Commons 日志库的包重命名副本。详情参看 Tomcat 日志文档。<br>如果 <code>*$CATALINA_BASE/bin*</code> 中存在 <code>tomcat-juli.jar</code>，就不会使用 <em>$CATALINA_HOME/bin</em> 中的那一个。它有助于日志的特定配置。</li>
<li><code>$CATALINA_HOME/bin/commons-daemon.jar</code> Apache Commons Daemon 项目的类。该 JAR 文件并不存在于由 catalina.bat 或 catalina.sh 脚本所创建的 CLASSPATH 中，而是引用自 bootstrap.jar 的清单文件。</li>
</ul>
</li>
<li><strong>Common</strong> 这种类加载器包含更多的额外类，它们对于 Tomcat 内部类以及所有 Web 应用都是可见的。<br>通常，应用类不会放在这里。该类加载器所搜索的位置定义在 <code>$CATALINA_BASE/conf/catalina.properties</code> 的 common.loader 属性中。默认的设置会搜索下列位置（按照列表中的上下顺序）。<ul>
<li><code>$CATALINA_BASE/lib</code> 中的解包的类和资源。</li>
<li><code>$CATALINA_BASE/lib</code> 中的 JAR 文件。</li>
<li><code>$CATALINA_HOME/lib</code> 中的解包类和资源。</li>
<li><code>$CATALINA_HOME/lib</code> 中的 JAR 文件。<br>默认，它包含以下这些内容：</li>
<li><em>annotations-api.jar</em> JavaEE 注释类。</li>
<li><em>catalina.jar</em> Tomcat 的 Catalina servlet 容器部分的实现。</li>
<li><em>jsp-api.jar</em> JSP 2.3 API</li>
<li><em>servlet-api.jar</em> Servlet 3.1 API</li>
<li><em>tomcat-api.jar</em> Tomcat 定义的一些接口</li>
<li><em>tomcat-dbcp.jar</em> 数据库连接池实现，基于 Apache Commons Pool 的包重命名副本和 Apache Commons DBCP。</li>
<li><em>tomcat-jdbc.jar</em> 一个数据库连接池替代实现，又被称作 Tomcat JDBC 池。详情参看 JDBC 连接池文档。</li>
<li>…</li>
</ul>
</li>
<li><strong>WebappX</strong> 为每个部署在单个 Tomcat 实例中的 Web 应用创建的类加载器。你的 Web 应用的 /WEB-INF/classes 目录中所有的解包类及资源，以及 /WEB-INF/lib 目录下 JAR 文件中的所有类及资源，对于该应用而言都是可见的，但对于其他应用来说则不可见。<br>如上所述，Web 应用类加载器背离了默认的 Java 委托模式（根据 Servlet 规范 2.4 版的 9.7.2 Web Application Classloader 一节中提供的建议）。<br>当某个请求想从 Web 应用的 WebappX 类加载器中加载类时，该类加载器会先查看自己的仓库，而不是预先进行委托处理。<br>JRE 基类的部分类不能被重写。对于一些类（比如 J2SE 1.4+ 的 XML 解析器组件），可以使用 J2SE 1.4 支持的特性。<br>最后，类加载器会显式地忽略所有包含 Servlet API 类的 JAR 文件，所以不要在 Web 应用包含任何这样的 JAR 文件。Tomcat 其他的类加载器则遵循常用的委托模式。</li>
</ul>
<p>因此，从 Web 应用的角度来看，加载类或资源时，要查看的仓库及其顺序如下：</p>
<ol>
<li>JVM 的 Bootstrap 类</li>
<li>Web 应用的 /WEB-INF/classes 类</li>
<li>Web 应用的 /WEB-INF/lib/*.jar 类</li>
<li>System 类加载器的类（如上所述）</li>
<li>Common 类加载器的类（如上所述）</li>
</ol>
<p>如果 Web 应用类加载器配置有 <code>&lt;Loader delegate=&quot;true&quot;/&gt;</code> ，则顺序变为：</p>
<ol>
<li>JVM 的 Bootstrap 类</li>
<li>System 类加载器的类（如上所述）</li>
<li>Common 类加载器的类（如上所述）</li>
<li>Web 应用的 /WEB-INF/classes 类</li>
<li>Web 应用的 /WEB-INF/lib/*.jar 类</li>
</ol>
<h1 id="源码导读-Tomcat-8-5"><a href="#源码导读-Tomcat-8-5" class="headerlink" title="源码导读 (Tomcat 8.5)"></a>源码导读 (Tomcat 8.5)</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ant clean</span><br><span class="line">ant</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp ./output/classes -Dcatalina.home=./output/build org.apache.catalina.startup.Bootstrap</span><br></pre></td></tr></table></figure>
<h2 id="启动过程源码调用时序"><a href="#启动过程源码调用时序" class="headerlink" title="启动过程源码调用时序"></a>启动过程源码调用时序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Bootstrap.main // 入口方法</span><br><span class="line">  Bootstrap.init()</span><br><span class="line">    initClassLoaders()  // 初始化 commonLoader, catalinaLoader, sharedLoader</span><br><span class="line">      commonLoader = createClassLoader(<span class="string">"common"</span>, null);</span><br><span class="line">        ClassLoaderFactory.createClassLoader(repositories, parent); // 该方法通过 AccessController.doPrivileged 创建了 URLClassLoader, 并返回</span><br><span class="line">    catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>)` // 创建 Catalina 对象</span><br><span class="line">  Bootstrap.load(args)</span><br><span class="line">    Catalina.load()</span><br><span class="line">      Digester digester = createStartDigester() // 为 digester 添加 Rule</span><br><span class="line">      Digester.parse(inputSource) // 解析 server.xml !!</span><br><span class="line">        Digester.startElement()</span><br><span class="line">          Rule.begin()</span><br><span class="line">            ObjectCreateRule.begin() // 这里通过反射调用了 Server &amp; Connector &amp; Context 等类的构造方法</span><br><span class="line">              org.apache.catalina.core.StandardServer.StandardServer() // Server 构造</span><br><span class="line">              org.apache.catalina.core.StandardService.StandardService() // Service 构造</span><br><span class="line">            ConnectorCreateRule.begin</span><br><span class="line">              org.apache.catalina.connector.Connector.Connector()</span><br><span class="line">                // Connector 构造, 根据配置中的 <span class="string">"protocol"</span> 设置创建不同的创建 ProtocolHandler:</span><br><span class="line">                Http11NioProtocol() // 默认的 ProtocolHandler</span><br><span class="line">                  AbstractHttp11Protocol(new NioEndpoint())</span><br><span class="line">                    NioEndpoint()</span><br><span class="line">                        AbstractEndpoint()  // 创建 worker 线程池</span><br><span class="line">  Bootstrap.start()</span><br><span class="line">    Catalina.start()</span><br><span class="line">      StandardServer.start() =&gt; LifecycleBase.start()</span><br><span class="line">        StandardServer.startInternal()</span><br><span class="line">          StandardService.start() =&gt; LifecycleBase.start()</span><br><span class="line">            StandardService.startInternal()</span><br><span class="line">              Engine.start() =&gt; LifecycleBase.start()   // 启动 Engine</span><br><span class="line">                StandardEngine.startInternal()</span><br><span class="line">                  ContainerBase.startInternal()</span><br><span class="line">                    StartChild.call()  // 多线程启动, 线程数=Host 数量</span><br><span class="line">                      StandardHost.start() =&gt; LifecycleBase.start()</span><br><span class="line">                        StandardHost.startInternal()</span><br><span class="line">                          ContainerBase.startInternal() =&gt; LifecycleBase.setStateInternal()</span><br><span class="line">                            ContainerBase.setState(LifecycleState.STARTING)</span><br><span class="line">                              LifecycleBase.fireLifecycleEvent(lifecycleEvent, data)</span><br><span class="line">                                  HostConfig.start()</span><br><span class="line">                                    HostConfig.deployApps()</span><br><span class="line">                                      HostConfig.deployWARs() // 解析 web.xml !!</span><br><span class="line">              MapperListener.start() =&gt; LifecycleBase.start()  // 启动 MapperListener</span><br><span class="line">                MapperListener.startInternal()</span><br><span class="line">              Connector.start() =&gt; LifecycleBase.start()     // 启动(多个) Connector</span><br><span class="line">                Connector.startInternal()</span><br><span class="line">                  Http11NioProtocol.start() =&gt; AbstractProtocol.start()</span><br><span class="line">                    AbstractEndpoint.start() =&gt; NioEndpoint.startInternal()</span><br><span class="line">                      // 创建三个 cache: processorCache, eventCache, nioChannels</span><br><span class="line">                      startAcceptorThreads()</span><br><span class="line">                    new AsyncTimeout(); // Start <span class="keyword">async</span> timeout thread</span><br><span class="line">      StandardServer.<span class="keyword">await</span>() // 创建一个在 <span class="number">8005</span> 监听的 ServerSocket, 用于监听关闭</span><br><span class="line">        ServerSocket.accept // 阻塞在这里</span><br></pre></td></tr></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote>
<p>参考 <a href="https://blog.csdn.net/tjiyu/article/details/54590259" target="_blank" rel="noopener">Tomcat实现：源码分析Tomcat实现细节 </a> @Archived</p>
<pre><code>* Connect.start()—创建并发线程模型: Work 线程, Poller 线程, Acceptor 线程, AsyncTimeout 线程
* 请求处理: Acceptor 线程, Poller 线程, Selector
</code></pre></blockquote>
<h3 id="如何解析-server-xml"><a href="#如何解析-server-xml" class="headerlink" title="如何解析 server.xml"></a>如何解析 server.xml</h3><ul>
<li>在 Catalina.load() 创建 digester: <code>Digester digester = createStartDigester()</code></li>
<li><code>createStartDigester</code>方法创建了 digester 对象, 并给 digester 对象添加多种 Rule, 每种 Rule 都对应 server.xml 里的一个节点类型, 比如<code>&lt;Server&gt;</code>, <code>&lt;Connector&gt;</code>;</li>
<li>digester 对 server.xml 设置的标签动作有 5 种调用：<ul>
<li>addObjectCreate：遇到起始标签的元素，初始化一个实例对象入栈</li>
<li>addSetProperties：遇到某个属性名，使用 setter 来赋值</li>
<li>addSetNext：遇到结束标签的元素，调用相应的方法</li>
<li>addRule：调用 rule 的 begin 、body、end、finish 方法来解析 xml，入栈和出栈给对象赋值</li>
<li>addRuleSet：调用 addRuleInstances 来解析 xml 标签</li>
</ul>
</li>
<li>从这些规则和 xml 中可以看到，Calatina 的 Server 对象是 StandardServer。 StandardService 包含了多个 Connector（xml 中有 2 个 connector）和一个 StandardEngine Container。 StandardEngine 包含了一个 Host Container</li>
</ul>
<h3 id="初始化-Connector"><a href="#初始化-Connector" class="headerlink" title="初始化 Connector"></a>初始化 Connector</h3><p>根据配置文件 protocol = “HTTP/1.1”,”AJP/1.3” 创建对应 protocol, 默认是 Http11NioProtocol,<br>再由 Http11NioProtocol 创建 NioEndpoint:</p>
<p>代码流程</p>
<ul>
<li>调用<code>Connector(String protocol)</code>, 构造函数<code>Connector</code>中默认创建<code>org.apache.coyote.http11.Http11NioProtocol</code></li>
<li>以<code>Http11NioProtocol</code>为例, <code>Http11NioProtocol.init()</code>最终调用到<code>NioEndpoint.bind()</code> =&gt; <code>NioEndpoint.initServerSocket()</code>  =&gt; <code>serverSock.socket().bind(addr,getAcceptCount())</code> 完成了对端口的绑定</li>
<li>bind()的最后调用了<code>NioSelectorPool.open()</code>, 这是一个存放 Selector 的池子,</li>
</ul>
<h3 id="启动-Connector"><a href="#启动-Connector" class="headerlink" title="启动 Connector"></a>启动 Connector</h3><p>Connector 主要功能实现都是在 <strong>NioEndpoint</strong>, NioEndpoint 包括 x 个 Acceptor 线程, x 个 Poller 线程;<br>Acceptor 线程(默认一个)用于 accept 客户端请求, 并把客户端请求 socket 封装进 event, 放入 events queue;<br>Poller 线程池用于消费 events queue, 每个 Poller 都有自己的 Selector 对象, 不断取出 event, 并从中解析出 sockt, 并把 socket 的 READ 事件注册到自己的 Selector.</p>
<p>代码调用流程:</p>
<ul>
<li>Connector 的启动会调用<code>start</code>方法, =&gt; <code>Connector.startInternal</code>方法 =&gt; <code>Http11NioProtocol.start()</code> =&gt; <code>AbstractProtocol.start()</code> =&gt; <code>NioEndpoint.start()</code> =&gt; <code>NioEndpoint.startInternal()</code></li>
<li>在<code>NioEndpoint.startInternal()</code>中,<ul>
<li>如果 Worker 线程池是空, 则自己创建: 调用了父类<code>AbstractEndpoint #createExecutor ()</code>, 创建 work 线程池, 名称前缀 “-exec-“;</li>
<li>创建<code>NioEndpoint$Poller[]</code>数组, Poller 是 Runnable 的实现, 然后所有的 Poller 线程都 start 起来, 线程名前缀是 “-ClientPoller-“, 数组的大小也就是 Poller 的数量是<code>Math.min(2,Runtime.getRuntime().availableProcessors())</code>, 可见 Poller 数量是 min(2, cpu 的 process 数量)</li>
<li>调用<code>startAcceptorThreads()</code>,  创建 <code>Acceptor</code>线程, 默认一个(线程数是 server.xml 里的<code>acceptCount</code>), , 线程名前缀是”-Acceptor-“</li>
</ul>
</li>
</ul>
<h3 id="accept-请求"><a href="#accept-请求" class="headerlink" title="accept 请求"></a>accept 请求</h3><p>Acceptor 线程 accept , 并把客户端请求 socket 封装进 event, 放入 events queue, 调用流程:</p>
<ul>
<li><p><code>Acceptor.run()</code>:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (endpoint.isRunning()) &#123;</span><br><span class="line">    socket = endpoint.serverSocketAccept();</span><br><span class="line">    endpoint.setSocketOptions(socket) // 调用了 NioEndpoint.setSocketOptions()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再看 <code>NioEndpoint.setSocketOptions()</code>里做了什么:  把客户端请求的 socket 封装进 NioChannel,<br>调用 Poller.register(NioChannel): 把 NioChannel 封装进 PollerEvent,  每个 Poller 都有一个 PollerEvent 队列(events queue), 把 PollerEvent 放入这个队列 // Poller 有多个, 这里会轮询的方式选择出其中一个, <code>AtomicInteger.incrementAndGet()) % pollers.length</code></p>
</li>
</ul>
<h3 id="处理一次-Req-请求"><a href="#处理一次-Req-请求" class="headerlink" title="处理一次 Req 请求"></a>处理一次 Req 请求</h3><p>Poller 线程用于消费 events queue, 代码调用流程:</p>
<ul>
<li><code>Poller.run()</code> while 循环从 event queue 取出 PollerEvent, 然后调用 <code>PollerEvent.run()</code><ul>
<li><code>PollerEvent.run()</code> // 主要是在 Poller 自己的 Selector 上注册 READ 事件</li>
<li><code>Poller.processKey(SelectionKey , NioSocketWrapper)</code> 调用-&gt; <code>Poller.processSocket</code> // 处理 OPEN_READ/OPEN_WRITE 等事件<ul>
<li>创建一个 SocketProcessorBase 的实例, 把 socket 和 Event 封装进去, SocketProcessorBase 继承自 Runnable</li>
<li>executor.execute(SocketProcessorBase) // 用 Worker 线程池运行这个 SocketProcessorBase<ul>
<li><code>SocketProcessorBase.run()</code> -&gt; <code>SocketProcessor.doRun()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>再看 SocketProcessor 调用流程:</p>
<ul>
<li><code>SocketProcessor.doRun()</code> :  // 调用 SocketChannel.keyFor()<ul>
<li><code>AbstractProtocol$ConnectionHandler.process()</code><ul>
<li><code>NioEndpoint$SocketProcessor.doRun()</code><ul>
<li><code>Http11Processor.service()</code> : 处理 Socket IO 流, 解析为 Http Request<ul>
<li><code>ApplicationFilterChain.internalDoFilter()</code>: 调用<code>Filter.doFilter()</code> ,以及<code>Servlet.service()</code>;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何-SHUTDOWN"><a href="#如何-SHUTDOWN" class="headerlink" title="如何 SHUTDOWN"></a>如何 SHUTDOWN</h3><ul>
<li>StandardServer.await() 创建一个在 8005 监听的 ServerSocket, 是用来监听关闭 Tomcat 命令的, 当执行 shutdown.sh 关闭 tomcat 时就是连接 8005 端口执行“SHUTDOWN”命令;</li>
<li>关闭请求发给 Tomcat, 由 StandardServer.await 处理, await 方法验证关闭请求是否有效, 如果有效则退出 await 方法, 进入 Catalina.stop(), 调用<br>StandardServer.stop, StandardServer.destroy,  然后关闭 Connector, Service</li>
</ul>
<p>从日志可以看到:</p>
<ul>
<li>WebappLoader.stopInternal -&gt; WebappClassLoaderBase.stop -&gt; WebappClassLoaderBase.clearReferences<ul>
<li>WebappClassLoaderBase.clearReferencesJdbc</li>
<li>WebappClassLoaderBase.clearReferencesThreads</li>
</ul>
</li>
<li>AbstractProtocol.pause Pausing ProtocolHandler [“http-nio-8080”]</li>
<li>AbstractProtocol.pause Pausing ProtocolHandler [“ajp-nio-8009”]</li>
<li>StandardService.stopInternal</li>
</ul>
<h2 id="Useful-Java-API-usage"><a href="#Useful-Java-API-usage" class="headerlink" title="Useful Java API usage"></a>Useful Java API usage</h2><ul>
<li>AsyncChannelWrapperSecure:<ul>
<li>Executors.newFixedThreadPool , shutdownNow</li>
<li>AsynchronousSocketChannel</li>
<li>ByteBuffer, flip, hasRemaining,</li>
<li>AtomicBoolean</li>
</ul>
</li>
<li>WsWebSocketContainer<ul>
<li>AsynchronousSocketChannel</li>
</ul>
</li>
</ul>
<h3 id="并发的处理代码"><a href="#并发的处理代码" class="headerlink" title="并发的处理代码"></a>并发的处理代码</h3><ul>
<li><p>用线程池启动容器内组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // Start our child containers, if any</span><br><span class="line">Container children[] = findChildren();</span><br><span class="line">List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">    results.add(startStopExecutor.submit(new StartChild(children[i])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean fail = false;</span><br><span class="line">for (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        result.get();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Callable 封装带返回值的任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class StartChild implements Callable&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Container child;</span><br><span class="line"></span><br><span class="line">    public StartChild(Container child) &#123;</span><br><span class="line">        this.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void call() throws LifecycleException &#123;</span><br><span class="line">        child.start();</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://toutiao.io/u/176492?page=4" target="_blank" rel="noopener">Tomcat那些事儿的热门分享 - 开发者头条</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaEE/" rel="tag"># JavaEE</a>
          
            <a href="/tags/Tomcat/" rel="tag"># Tomcat</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/13.JavaEE-Framework/JavaEE.SpringMVC/" rel="next" title="Spring MVC">
                <i class="fa fa-chevron-left"></i> Spring MVC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/13.JavaEE-Framework/Tools-构建工具/" rel="prev" title="Java构建工具 - Maven and Gradle">
                Java构建工具 - Maven and Gradle <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">458</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">404</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么-Java-Web-开发需要-Tomcat"><span class="nav-text">为什么 Java Web 开发需要 Tomcat</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tomcat-整体架构"><span class="nav-text">Tomcat 整体架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置文件-server-xml"><span class="nav-text">配置文件 server.xml</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#server-xml-配置元素分类"><span class="nav-text">server.xml 配置元素分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整体结构"><span class="nav-text">整体结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素分类"><span class="nav-text">元素分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心组件"><span class="nav-text">核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Server"><span class="nav-text">Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Service"><span class="nav-text">Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Connector"><span class="nav-text">Connector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Engine"><span class="nav-text">Engine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Host"><span class="nav-text">Host</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Engine-与-Host"><span class="nav-text">Engine 与 Host</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Host-的作用"><span class="nav-text">Host 的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Host-的配置"><span class="nav-text">Host 的配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context"><span class="nav-text">Context</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Context-的作用"><span class="nav-text">Context 的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web-应用自动部署"><span class="nav-text">Web 应用自动部署</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#自动部署的实现"><span class="nav-text">自动部署的实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心组件的关联"><span class="nav-text">核心组件的关联</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整体关系"><span class="nav-text">整体关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何确定请求由谁处理？"><span class="nav-text">如何确定请求由谁处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何部署多个-war-包项目"><span class="nav-text">如何部署多个 war 包项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他组件"><span class="nav-text">其他组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listener"><span class="nav-text">Listener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GlobalNamingResources-与-Realm"><span class="nav-text">GlobalNamingResources 与 Realm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Valve"><span class="nav-text">Valve</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能优化"><span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bin-catalina-sh"><span class="nav-text">bin/catalina.sh</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conf-server-xml"><span class="nav-text">conf/server.xml</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#附-Connector-和线程池参数解析"><span class="nav-text">附: Connector 和线程池参数解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat-在-NIO-模式下的线程模型"><span class="nav-text">Tomcat 在 NIO 模式下的线程模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#APR-支持"><span class="nav-text">APR 支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#日志"><span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JULI-vs-JUL"><span class="nav-text">JULI vs JUL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat-日志配置解析"><span class="nav-text">Tomcat 日志配置解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebApp-的日志配置解析"><span class="nav-text">WebApp 的日志配置解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日志文件"><span class="nav-text">日志文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产环境中的日志"><span class="nav-text">生产环境中的日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-log4j"><span class="nav-text">使用 log4j</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高级-IO"><span class="nav-text">高级 IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#推送-Comet-支持"><span class="nav-text">推送: Comet 支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送大型静态文件-sendfile"><span class="nav-text">发送大型静态文件: sendfile</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-to-deploy-war"><span class="nav-text">How to deploy war</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-the-UI-manager"><span class="nav-text">Using the UI manager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-maven"><span class="nav-text">Using maven</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ClassLoader"><span class="nav-text">ClassLoader</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码导读-Tomcat-8-5"><span class="nav-text">源码导读 (Tomcat 8.5)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译"><span class="nav-text">编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动"><span class="nav-text">启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动过程源码调用时序"><span class="nav-text">启动过程源码调用时序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何解析-server-xml"><span class="nav-text">如何解析 server.xml</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化-Connector"><span class="nav-text">初始化 Connector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动-Connector"><span class="nav-text">启动 Connector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accept-请求"><span class="nav-text">accept 请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理一次-Req-请求"><span class="nav-text">处理一次 Req 请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何-SHUTDOWN"><span class="nav-text">如何 SHUTDOWN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Useful-Java-API-usage"><span class="nav-text">Useful Java API usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发的处理代码"><span class="nav-text">并发的处理代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/';
          this.page.identifier = '13.JavaEE-Framework/JavaEE.Tomcat/';
          this.page.title = 'Tomcat';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
