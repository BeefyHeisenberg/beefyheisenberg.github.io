<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Hello, World" />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="基本数据类型 C/C++作为一种强类型语言, 一个变量被使用前必须被定义. 在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B), long(4B), float(4B), double(8B), long long(8B); 在64位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(8B)">
<meta property="og:type" content="article">
<meta property="og:title" content="C Tutorials-01-基础">
<meta property="og:url" content="https://beefyheisenberg.github.io/11.Programming-Language/C-Tutorials.01.基础/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="基本数据类型 C/C++作为一种强类型语言, 一个变量被使用前必须被定义. 在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B), long(4B), float(4B), double(8B), long long(8B); 在64位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(8B)">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2023-05-25T11:08:57.838Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C Tutorials-01-基础">
<meta name="twitter:description" content="基本数据类型 C/C++作为一种强类型语言, 一个变量被使用前必须被定义. 在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B), long(4B), float(4B), double(8B), long long(8B); 在64位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(8B)">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/11.Programming-Language/C-Tutorials.01.基础/"/>





  <title>C Tutorials-01-基础 | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/11.Programming-Language/C-Tutorials.01.基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C Tutorials-01-基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/11-Programming-Language/" itemprop="url" rel="index">
                    <span itemprop="name">11.Programming-Language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,121
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li>C/C++作为一种强类型语言, 一个变量被使用前必须被定义.</li>
<li>在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B), long(4B), float(4B), double(8B), long long(8B);</li>
<li>在64位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(<strong>8B</strong>) long(<strong>8B</strong>), float(4B), double(8B), long long(8B);</li>
<li>long 和 int 范围是<code>[-2^31,2^31)</code>, 即-2147483648~2147483647.</li>
<li>而unsigned范围是<code>[0,2^32)</code>, 即0~4294967295. 也就是说, 常规的32位整数只能够处理40亿以下的数.</li>
<li>相比于C++98标准, C++11整型的最大改变就是多了long long<ul>
<li>long long整型有两种：long long和unsigned long long. 在C++11中, 标准要求long long整型可以在不同平台上有不同的长度, 但至少有64位. 我们在写常数字面量时, 可以使用LL后缀（或是ll）标识一个long long类型的字面量, 而ULL（或ull、Ull、uLL）表示一个unsigned long long类型的字面量. 比如：<code>unsigned long long int ulli = -9000000000000000000ULL;</code></li>
<li>对于有符号的, 下面的类型是等价的：long long、signed long long、long long int、signed long long int; 对于无符号的：unsigned long long和unsigned long long int也是等价的.</li>
<li>同其他的整型一样, 要了解平台上<code>long long</code>大小的方法就是查看<code>&lt;climits&gt;</code>（或<code>&lt;limits.h&gt;</code>中的宏）. 与long long整型相关的一共有3个：LLONG_MIN、LLONG_MAX和ULLONG_MIN, 它们分别代表了平台上最小的long long值、最大的long long值, 以及最大的unsigned long long值.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_min = LLONG_MIN;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_max = LLONG_MAX;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull_max = ULLONG_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译选项:g++ -std=c++11 2-2-1.cpp</span></span><br><span class="line">    <span class="comment">// 在代码清单中, 将以上3个宏打印了出来, 对于printf函数来说,</span></span><br><span class="line">    <span class="comment">// 输出有符号的long long类型变量可以用符号%lld,</span></span><br><span class="line">    <span class="comment">// 无符号的unsigned long long则可以采用%llu.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min of long long: %lld\n"</span>, ll_min); <span class="comment">// min of long long: -9223372036854775808</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max of long long: %lld\n"</span>, ll_max); <span class="comment">// max of long long: 9223372036854775807</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max of unsigned long long: %llu\n"</span>, ull_max);   <span class="comment">// max of unsigned long long: 18446744073709551615</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ref: <a href="https://blog.csdn.net/dos5gw/article/details/6448048" target="_blank" rel="noopener">结构体对齐, 位域, 柔性数组 - DOS5GW的专栏 - CSDN博客</a></p>
<h2 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h2><p>大端/小端存储（big endian/little endian）:</p>
<p>MSB＝高权位,LSB＝低权位,比如自然数字0x1A39,1A是MSB,39是LSB,判断大小端存储,可根据数据在内存中存储的地址是以MSB/LSB为地址,</p>
<ul>
<li>大端: LSB在高地址,MSB在低地址;</li>
<li>小端: MSB在高地址,LSB在低地址;</li>
</ul>
<p>比如一个int,其LSB作为此数据的首地址(内存中的低地址),则为小端存储;</p>
<p>比如书写顺序0x1122,11是高字节MSB,22是低字节LSB.<br>如果用大端存储:高地址22,低地址11;<br>如果用小端存储:高地址11,低地址22;</p>
<p>@ref: <a href="https://blog.csdn.net/dos5gw/article/details/6340996" target="_blank" rel="noopener">大端(Big Endian)与小端(Little Endian)详解 - DOS5GW的专栏 - CSDN博客</a></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>位与<code>&amp;</code>, 位或<code>|</code>, 异或<code>^</code>, 取反<code>~</code>, 位左移<code>&lt;&lt;</code> , 位右移<code>&gt;&gt;</code></li>
<li>sizeof是C语言的一种单目操作符, 如C语言的其他操作符++、–等. 它并不是函数. sizeof操作符以字节形式给出了其操作数的存储大小. 操作数可以是一个表达式或括在括号内的类型名. 操作数的存储大小由操作数的类型决定. 　<ul>
<li>当操作数具有数组类型时, 其结果是数组的总字节数</li>
<li>联合类型操作数的sizeof是其最大字节成员的字节数</li>
<li>sizeof的优先级为2级, 比乘除等3级运算符优先级高</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/30526656" target="_blank" rel="noopener">编程语言中, 取余和取模的区别到底是什么？ - 知乎</a><br>当除数和被除数不同符号时: 取余向0方向舍弃小数位, 取模向负无穷方向舍弃小数位, 比如4/(-3)约等于-1.3 :<br>取余: 4 rem 3 = -1;<br>取模: 4 mod 3 = -2;</p>
</blockquote>
<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p>格式化输出printf是一个变参函数, 原型为<code>int printf(char *format,...)</code> ,<br>C语言用宏来处理这些可变参数, 根据参数入栈的特点从最靠近第一个可变参数的固定参数开始, 依次获取每个可变参数的地址.  例如<code>printf (&quot;Decimals: %d %ld\n&quot;, 1977, 650000L);</code><br>需要注意的是格式要跟变量的长度对应, 比如long long要使用<code>%ll</code>, int类型不能使用<code>%c</code>格式.</p>
<h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>首先,声明与定义的区别:</p>
<ul>
<li>定义：编译器会为变量或函数分配内存  //如：int a=1;</li>
<li>声明：只是表明其存在，但没有分配内存这个过程。//如：int a; 带或带extern</li>
</ul>
<p>extern的两个作用:</p>
<p>(1) extern声明 &amp; 定义变量和函数. 例如<br> 在aaa.cpp 定义函数: <code>void func();</code><br> 在bbb.cpp 调用该函数前需要先extern声明: <code>extern void func();</code><br> 或者在aaa.h头文件里extern声明, 所有包含此头文件的*.cpp都可以是使用<code>func()</code>函数.</p>
<p>(2) C++项目中常见的 <code>extern &quot;C&quot;</code>: 这就告诉 C++编译译器,函数 foo 是个 C库的函数，那么C++编译器应该按照C编译器的编译和链接规则来进行链接，也就是说到库中找名字_foo 而不是找_foo_int_int（原因是C++支持函数的重载）</p>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>(1) 当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。如果加了 static，就会对其它源文件隐藏(其他文件无法使用)。所以static 和 extern不能同时修饰一个变量</p>
<p>(2) 全局变量和 static 变量存储在 静态存储区，程序启动时被初始化为0</p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>(1) 修饰局部 &amp; 全局常量：<code>const int num=5;</code></p>
<p>(2) 常量指针：指针指向的内容是常量，两种定义皆可：<code>const int * num;</code>  和 <code>int const * num;</code></p>
<p>(3) 指针常量：指针本身是个常量，不能再指向其他的地址 <code>int *const num;</code></p>
<p>(4) 修饰函数的形参：</p>
<ul>
<li>防止修改指针指向的内容 <code>void FUN(char *destin, const char *source);</code></li>
<li>防止修改指针指向的地址 <code>void FUN ( int * const p1 , int * const p2);</code></li>
</ul>
<p>(5) 修饰函数的返回值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char * FUN(void);</span><br><span class="line">char *str = FUN(); // err</span><br><span class="line">const char *str = FUN();</span><br></pre></td></tr></table></figure></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>什么是数组类型?</p>
<p>下面是C99中原话:</p>
<blockquote>
<p>An array type describes a contiguously allocated nonempty set of objects with a<br> particular member object type, called the element type.36) Array types are characterized by their element type and by the number of elements in the array. An array type is said to be derived from its element type, and if its element type is T , the array type is sometimes called ‘‘array of T ’’. The construction of an array type from an element type is called ‘‘array type derivation’’.  </p>
</blockquote>
<p> 很显然, 数组类型也是一种数据类型, 其本质功能和其他类型无异:定义该类型的数据所占内存空间的大小以及可以对该类型数据进行的操作(及如何操作).</p>
<h2 id="数组退化"><a href="#数组退化" class="headerlink" title="数组退化"></a>数组退化</h2><p>数组类型也是一种数据类型, 其本质功能和其他类型无异:定义该类型的数据所占内存空间的大小以及可以对该类型数据进行的操作(及如何操作).<br>数组在某些情况下, “数组类型的变量”会退化成指针类型,<br>这时候无法再获取数组长度, 会影响<code>sizeof</code>操作符的结果,</p>
<h3 id="数组什么时候会”退化”"><a href="#数组什么时候会”退化”" class="headerlink" title="数组什么时候会”退化”"></a>数组什么时候会”退化”</h3><p>数组在除了3种情况外, 其他时候都要”退化”成指向首元素的指针. 这3中例外情况是:<br>比如有数组 <code>char s[10] = &quot;hello&quot;;</code></p>
<ol>
<li><code>sizeof(s)</code></li>
<li><code>&amp;s</code></li>
<li>用<code>char s[10]</code>作为左值创建”字符串”, <code>s</code>仍然是数组类型</li>
</ol>
<h2 id="静态数组索引-C99"><a href="#静态数组索引-C99" class="headerlink" title="静态数组索引(C99)"></a>静态数组索引(C99)</h2><p>下面的代码向编译器保证, 你传递给f 的指针指向一个具有至少10个int 类型元素的数组的首个元素. 我猜这也是为了优化; 例如, 编译器将会假定a 非空. 编译器还会在你尝试要将一个可以被静态确定为null的指针传入或是一个数组太小的时候发出警告.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个不可修改的数组, 这和说明符<code>int * const a</code>.作用是一样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">const</span>])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针的值就是一个内存地址, 或者说,指针指向的内存区的开始地址, 指针的长度为<code>sizeof(int)=4</code> (32位机),</p>
<p><code>restrict</code>关键词是一个限定词, 可以被用在指针上. 它向编译器保证, 在这个指针的生命周期内, 任何通过该指针访问的内存, 都只能被这个指针改变. 比如,</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">restrict</span> x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">  (*y)++;</span><br><span class="line">  <span class="keyword">int</span> z = *x;</span><br><span class="line">  (*y)--;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针的类型-amp-指针指向的类型"><a href="#指针的类型-amp-指针指向的类型" class="headerlink" title="指针的类型 &amp; 指针指向的类型:"></a>指针的类型 &amp; 指针指向的类型:</h2><p>   例子,说明以下指针的类型/指向的类型：<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* ptr;  </span><br><span class="line">char* ptr;  </span><br><span class="line">int** ptr;  </span><br><span class="line">int (*ptr)[3];  </span><br><span class="line">int* (*ptr)[4];</span><br></pre></td></tr></table></figure></p>
<p> 将<code>*</code>号去掉, 剩下的部分即是”指针的类型”;<br> 将”指针名字”和”指针名字左边的指针声明符<code>*</code>“去掉, 剩下的部分即是”指向的类型”.</p>
<h2 id="指针的加减运算"><a href="#指针的加减运算" class="headerlink" title="指针的加减运算"></a>指针的加减运算</h2><p>加减运算包括: 自++,–, 指针±数值, 指针±指针, 这些运算时, 指针数值的变化, 指针指向的变化.</p>
<ul>
<li>自++/–: 指针±1, 指针数值±sizeof(指针类型), 指针指向下一个元素的地址;</li>
<li>指针±N: 指针数值±sizeof(指针类型)*N, 指针移动到后面第N个元素;</li>
<li>指针-指针: 两个指针相隔的元素个数, 同类型的指针才可以相减;</li>
<li>指针+指针: 无意义.</li>
</ul>
<p>阅读下面的代码, 打印结果?:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[5]=&#123;1,2,3,4,5&#125;;</span><br><span class="line">int *ptr1=(int *)(&amp;a+1);</span><br><span class="line">int *ptr2=(int *)((int )a+1);</span><br><span class="line">printf(&quot;%x,%x&quot;,ptr1[-1],*ptr2);</span><br></pre></td></tr></table></figure></p>
<p>第二行: &amp;a, 数组名取地址, 相当于一个”数组指针”, 该指针的类型是<code>int (*)[5]</code>, 指向的类型是<code>int [5]</code>, 所以这个指针+N, 指针实际移动的字节数 = <code>N * sizeof(int [5])</code>, <code>ptr1[-1]</code>会打印出: 5</p>
<h2 id="数组-amp-指针的不同"><a href="#数组-amp-指针的不同" class="headerlink" title="数组 &amp; 指针的不同"></a>数组 &amp; 指针的不同</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化的不同<br>在第一句中,以<code>&amp;s[0]</code>开始的连续6个字节内存分别被赋值为: ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘/0’<br>第二句中,p被初始化为程序data段的某个地址,该地址是字符串”hello”的首地址</li>
<li>sizeof的不同: <code>sizeof(s)</code>应为6, 而sizeof(p)应为一个”指针”的大小.</li>
<li><code>&amp;</code>取地址操作符的不同:<br><code>&amp;s</code>的类型为pointer to array of 6 chars.<br><code>&amp;p</code>的类型为pointer to pointer to char.</li>
</ol>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>   在C99之前, 你只能按顺序初始化一个结构体. 在C99中你可以这样做</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo = &#123;.z = <span class="number">3</span>, .x = <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>   这段代码首先初始化了foo.z,然后初始化了foo.x. foo.y 没有被初始化, 所以被置为0.<br>   这一语法同样可以被用在数组中. 以下三行代码是等价的：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构体字节对齐"><a href="#结构体字节对齐" class="headerlink" title="结构体字节对齐"></a>结构体字节对齐</h2><p>➤ 结构体的<code>sizeof</code>, gcc和cl编译器有所不同, 以cl为例:</p>
<ol>
<li>结构体变量的首地址能够被其对齐字节数大小所整除</li>
<li>结构体每个成员相对结构体首地址的偏移都是该成员大小的整数倍, 例如int成员相对结构体首地址的偏移是<code>sizeof(int)</code>, char成员相对结构体首地址的偏移是<code>sizeof(char)</code>. 如不满足, 会在前一个成员之后增加填充字节以满足对齐. 如果结构体成员是数组<code>TYPE arr[3]</code>, 成员arr的首地址以<code>sizeof(TYPE)</code>对齐而不是<code>sizeof(TYPE[3])</code>.</li>
<li>sizeof(struct)等于struct内最大基本元素长度的整数倍, 如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）.</li>
</ol>
<p>考虑一下, 为什么有第3条对齐准则？如果声明一个结构体<code>struct sArr[2];</code>, 这样可保证<code>sArr[1]</code>的首地址也满足第1条</p>
<p>@ref: <a href="https://cloud.tencent.com/developer/article/1631792" target="_blank" rel="noopener">字节对齐，看这篇就懂了 - 腾讯云开发者社区-腾讯云</a></p>
<p>➤ 包含结构体成员的结构体：</p>
<ul>
<li>在寻找最宽基本类型成员时, 应当包括“子结构体”的成员;</li>
<li><p>“子结构体变量”的首地址能够被其最宽基本类型成员的大小所整除;</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;; <span class="comment">//sizeof(S1) = 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c1;</span><br><span class="line">  S1 s;  <span class="comment">//8 bytes</span></span><br><span class="line">  <span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>S1或S3的最宽简单成员的类型都为int, 所以S3的最宽简单类型为int;<br>S3::s的类型是struct S1, 其起始地址是sizeof(int)的整数倍（struct S1最宽的成员是int型）;<br>S3占用内存如下：<br>S3:c1占1字, 填充3字, S1:c占一字, 填充3字, S1:i占4字, S3:c2占1字, 填充3字, 故sizeof(struct S3) = 16;</p>
</blockquote>
</li>
</ul>
<p>➤ 改变缺省的对齐条件, 即“成员相对于结构体首地址的偏移量, 是成员大小的整数倍”, 变成了“成员相对于结构体首地址的偏移量, 是对齐字节的整数倍”. VC6中使用语法如下：<br>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push) <span class="comment">// 将当前pack设置压栈保存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2) <span class="comment">//按照2字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;; <span class="comment">// 6 bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  c1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">sss</span>;</span></span><br><span class="line">    <span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>#pragma pack(n)</code>, 如果n比结构体成员的sizeof值小, 那么该成员的偏移量应该以此值为准, 结构体成员的偏移量应该取二者的最小值.<br>上面对定义中最宽的int, 和#pragma pack(2)比较, 所以对齐条件是2字节;<br>char S1::c占1字, int S1::i宽度是4, 这里不以4而是以2对齐, 所以int S1::i的起始位置是2, sizeof(S1) == 6.<br>注: 没有任何成员的“空结构体”占1byte;</p>
</blockquote>
<h2 id="含位域结构体的sizeof"><a href="#含位域结构体的sizeof" class="headerlink" title="含位域结构体的sizeof"></a>含位域结构体的sizeof</h2><p>使用位域的主要目的是压缩存储, 其大致规则为：</p>
<ul>
<li>1) 如果相邻位域字段的类型相同, 且其位宽之和小于类型的sizeof大小, 则后面的字段将紧邻前一个字段存储, 直到不能容纳为止;</li>
<li>2) 如果相邻位域字段的类型相同, 但其位宽之和大于类型的sizeof大小, 则后面的字段将从新的存储单元开始, 其偏移量为其类型大小的整数倍;</li>
<li>3) 如果相邻的位域字段的类型不同, 则各编译器的具体实现有差异, VC6采取不压缩方式, Dev-C++采取压缩方式;</li>
<li>4) 如果位域字段之间穿插着非位域字段, 则不进行压缩;</li>
<li>5) 整个结构体的总大小为最宽基本类型成员大小的整数倍.</li>
</ul>
<h2 id="柔性数组-flexible-array"><a href="#柔性数组-flexible-array" class="headerlink" title="柔性数组(flexible array)"></a>柔性数组(flexible array)</h2><ul>
<li>C99中, 结构中的最后一个元素允许是未知大小的数组, 这就叫做柔性数组成员, 但结构中的柔性数组成员前面必须至少一个其他成员.</li>
<li>柔性数组成员允许结构中包含一个大小可变的数组. sizeof返回的这种结构大小不包括柔性数组的内存.</li>
<li>包含柔性数组成员的结构用malloc函数进行内存的动态分配, 并且分配的内存应该大于结构的大小, 以适应柔性数组的预期大小.</li>
</ul>
<p>柔性数组到底如何使用呢？看下面例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> len;</span><br><span class="line">   <span class="keyword">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure>
<p>有些编译器会报错无法编译可以改成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> len;</span><br><span class="line">   <span class="keyword">char</span> data[];</span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure>
<p>通过如下表达式给结构体分配内存： <code>type_a *p = (type_a*)malloc(sizeof(type_a) + 100*sizeof(char));</code></p>
<p>这样我们为结构体指针 p 分配了一块内存(该内存块大小远大于结构的大小).<br>但是这时候我们再用 <code>sizeof（*p）</code> 或 <code>sizeof(type_a)</code> 测试结构体的大小, 发现仍然为 4, sizeof返回值不包括柔性数组部分.<br>前面说过，数组名就代表一个地址，是一个不变的地址常量。在柔性数组的结构体中，数组名仅仅是一个符号而已，只代表一个偏移量，不会占用具体的空间。</p>
<p>我们用 <code>p-&gt;data[n]</code>就能简单地访问可变长元素.</p>
<p>对于柔性数组的这个特点，很容易构造出变成结构体，如缓冲区等等， 其实柔性数组成员在实现跳跃表时有它特别的用法，在Redis的SDS数据结构中和跳跃表的实现上，也使用柔性数组成员。它的主要用途是为了 <em>满足需要变长度的结构体，为了解决使用数组时内存的冗余和数组的越界问题</em>。</p>
<p>当然, 上面既然用 malloc函数分配了内存, 肯定就需要用 free函数来释放内存：<code>free(p)</code></p>
<p>需要说明的是：C89不支持这种东西, C99把它作为一种特例加入了标准. 但是, C99 所支持的是 incomplete type, 而不是 zero array, 形同 <code>int item[0];</code>这种形式是非法的, C99支持的形式是形同 <code>int item[];</code>只不过有些编译器把 <code>int item[0];</code>作为非标准扩展来支持, 而且在C99发布之前已经有了这种非标准扩展了, C99发布之后, 有些编译器把两者合而为一了.</p>
<p>@ref:</p>
<ul>
<li>结构体对齐 <a href="http://blog.csdn.net/yinkaizhong/archive/2009/12/06/4951288.aspx" target="_blank" rel="noopener">http://blog.csdn.net/yinkaizhong/archive/2009/12/06/4951288.aspx</a></li>
<li>柔性数组 <a href="http://blog.csdn.net/yiruirui0507/archive/2010/07/22/5756328.aspx" target="_blank" rel="noopener">http://blog.csdn.net/yiruirui0507/archive/2010/07/22/5756328.aspx</a></li>
</ul>
<h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><p>➤ 用法: <code>typedef oldType newType</code>:</p>
<ul>
<li><code>typedef unsigned char BYTE;</code> // 新定义BYTE</li>
<li><code>typedef struct Language { ... } LANG;</code> // 新定义LANG</li>
<li><code>typedef void (*pf)(int, int);</code> // 函数指针</li>
</ul>
<p>➤ <code>typedef</code> vs <code>#define</code></p>
<ul>
<li>typedef仅可用于类型, define宏还可以用于数值, 例如<code>#define 1 ONE</code></li>
<li>typedef由编译器进行解释, define宏是由预编译期解释的</li>
</ul>
<p>@ref <a href="https://www.runoob.com/cprogramming/c-typedef.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-typedef.html</a></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在 C语言中，字符串实际上是使用 null 字符 <code>\0</code> 终止的一维字符数组。</p>
<p>在 string.h中提供的字符串api:</p>
<ul>
<li>strcpy(s1, s2);</li>
<li>strcat(s1, s2);</li>
<li>strlen(s1);</li>
<li>strcmp(s1, s2);</li>
<li>strchr(s1, ch);</li>
<li>strstr(s1, s2);</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<ul>
<li>传值调用：该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</li>
<li>引用调用：通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</li>
</ul>
<p><strong>默认情况下，C 使用传值调用来传递参数</strong>。这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<h2 id="可变参函数"><a href="#可变参函数" class="headerlink" title="可变参函数"></a>可变参函数</h2><p>声明方式为： <code>int func_name(int arg1, ...);</code> 其中，省略号 … 表示可变参数列表。</p>
<p>@ref: <a href="https://www.runoob.com/cprogramming/c-variable-arguments.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-variable-arguments.html</a></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>常用函数：</p>
<ul>
<li><p><code>void *malloc(int num)</code>：用于动态分配内存。它接受一个参数，即需要分配的内存大小（以字节为单位），并返回一个指向分配内存的指针。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。<br>malloc的实现 =&gt; [[C-Tutorials.02.内存管理-malloc.md]]</p>
</li>
<li><p><code>void free(void *address)</code>：用于释放先前分配的内存。它接受一个指向要释放内存的指针作为参数，并将该内存标记为未使用状态。</p>
</li>
<li><p><code>void *calloc(int num, int size)</code>：用于动态分配内存，并将其初始化为零。它接受两个参数，即需要分配的内存块数和每个内存块的大小（以字节为单位），并返回一个指向分配内存（num x size 字节）的指针。</p>
</li>
<li><p><code>void *realloc(void *address, int newsize)</code>：用于重新分配内存。它接受两个参数，即一个先前分配的指针和一个新的内存大小，然后尝试重新调整先前分配的内存块的大小。如果调整成功，它将返回一个指向重新分配内存的指针，否则返回一个空指针。</p>
</li>
</ul>
<h1 id="宏-macro"><a href="#宏-macro" class="headerlink" title="宏(macro)"></a>宏(macro)</h1><p>C/C++的宏定义将一个标识符定义为一个字符串, 源程序中的该标识符均以指定的字符串来代替. 宏的替换是在程序源代码被编译之前, 由预处理器（Preprocessor）对程序源代码进行的处理.</p>
<p>宏主要用在宏定义和条件编译.</p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h3><p><code>#define MAX 1000</code>: 在《Effective C++》中, 这种做法却并不提倡, 书中更加推荐以const常量来代替宏常量. 因为在进行词法分析时, 宏的引用已经被其实际内容替换, 因此宏名不会出现在符号表中. 所以一旦出错, 看到的将是一个无意义的数字, 比如上文中的1000, 而不是一个有意义的名称, 如上文中的MAX. 而const在符号表中会有自己的位置, 因此出错时可以看到更加有意义的错误提示.</p>
<h3 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h3><p>为什么使用宏函数？</p>
<ul>
<li>宏只是在预编译期做展开（简单替换宏代码），并不像真正的函数需要额外的一次函数调用，也就节省了函数用的开销（传参、寄存器… ）</li>
</ul>
<p>与inline函数的区别？ @todo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&lt;(b) ? (b) : (a))</span></span><br></pre></td></tr></table></figure>
<p>为什么大量的宏定义中用到了<code>do-while</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x) bar(x); baz(x)</span></span><br><span class="line"><span class="comment">// 如果这样使用宏:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    FOO(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 会被替换成:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    bar(x); baz(x); <span class="comment">// 第二句脱离了if控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进一下, 加上大括号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x)  &#123; bar(x); baz(x); &#125;</span></span><br><span class="line"><span class="comment">// 被替换成这样:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    &#123; bar(x); baz(x); &#125;; <span class="comment">// 多了个分号, 编译错误</span></span><br></pre></td></tr></table></figure>
<p>所以正确的写法:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x) do &#123; bar(x); baz(x); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样使用宏:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    FOO(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 会被替换成:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    <span class="keyword">do</span> &#123; bar(x); baz(x); &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>do{...} while(condition)</code>语句最后可以有分号也可以没有, 这两种语法上都正确</p>
<h3 id="宏定义中的”-”和”-”"><a href="#宏定义中的”-”和”-”" class="headerlink" title="宏定义中的”#”和”##”"></a>宏定义中的”#”和”##”</h3><p><code>#</code>的功能是将其后面的宏参数进行字符串化操作（Stringfication）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_RUN(func)</span></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="built_in">printf</span>(<span class="string">"entry:"</span>#func<span class="string">"\n"</span>); func(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>#func</code>替换后, 作为字符串拼接, 相当于<code>printf(&quot;entry:&quot; + funcName + &quot;\n&quot;)</code></p>
<p><code>##</code>被称为连接符（concatenator）, 用来将两个Token连接为一个Token.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> * name;</span><br><span class="line">  <span class="keyword">void</span> (*function) (<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMAND(NAME) &#123; NAME, NAME ## _command &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后你就用一些预先定义好的命令来方便的初始化一个command结构的数组了：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">command</span> <span class="title">cmds</span>[] = &#123;</span></span><br><span class="line">COMMAND(quit),</span><br><span class="line">COMMAND(help),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变参数的宏"><a href="#可变参数的宏" class="headerlink" title="可变参数的宏"></a>可变参数的宏</h3><p>@todo</p>
<h2 id="预处理器-amp-条件编译"><a href="#预处理器-amp-条件编译" class="headerlink" title="预处理器 &amp; 条件编译"></a>预处理器 &amp; 条件编译</h2><p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<ul>
<li><code>#define</code>    定义宏</li>
<li><code>#include</code> 包含一个源代码文件</li>
<li><code>#ifdef</code>    如果宏已经定义，则返回真</li>
<li><code>#ifndef</code>    如果宏没有定义，则返回真</li>
<li><code>#error</code>    当遇到标准错误时，输出错误消息</li>
<li><code>#pragma</code>    使用标准化方法，向编译器发布特殊的命令到编译器中</li>
<li>…</li>
</ul>
<p>条件编译</p>
<p><code>#define</code>常与<code>#ifdef</code>, <code>#ifndef</code>, <code>defined</code>指令配合使用, 用于条件编译.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADER_INC_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADER_INC_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>用宏控制debug日志:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Debug information\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>通过DEBUG宏, 我们可以在代码调试的过程中输出辅助调试的信息. 当DEBUG宏被删除时, 这些输出的语句就不会被编译. 更重要的是, 这个宏可以通过编译参数来定义. 因此通过改变编译参数, 就可以方便的添加和取消这个宏的定义, 从而改变代码条件编译的结果.</p>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"File :%s\n"</span>, __FILE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Date :%s\n"</span>, __DATE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Time :%s\n"</span>, __TIME__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line :%d\n"</span>, __LINE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"ANSI :%d\n"</span>, __STDC__ );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="博客旧文章"><a href="#博客旧文章" class="headerlink" title="博客旧文章"></a>博客旧文章</h1><ul>
<li><a href="https://beefyheisenberg.github.io/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91C%E8%AF%AD%E8%A8%80%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%99%B7%E9%98%B1/">C语言里面的一些陷阱 | 扔掉笔记 ᐛ</a></li>
<li><a href="https://beefyheisenberg.github.io/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/">C语言的编译与链接 - gcc,ld,ar等工具的介绍 | 扔掉笔记 ᐛ</a></li>
<li><a href="https://beefyheisenberg.github.io/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91GNU%E7%9A%84obj%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">GNU的obj分析工具的使用 - nm,objdump | 扔掉笔记 ᐛ</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/11.Programming-Language/06.ObjectiveC-Tutorials/" rel="next" title="Objective-C Tutorials">
                <i class="fa fa-chevron-left"></i> Objective-C Tutorials
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/11.Programming-Language/C-Tutorials.02.内存管理-malloc/" rel="prev" title="C Tutorials-02-内存管理（深入理解 malloc）">
                C Tutorials-02-内存管理（深入理解 malloc） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">462</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">402</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本数据类型"><span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#大小端存储"><span class="nav-text">大小端存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#格式化输出"><span class="nav-text">格式化输出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#extern"><span class="nav-text">extern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#const"><span class="nav-text">const</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组退化"><span class="nav-text">数组退化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组什么时候会”退化”"><span class="nav-text">数组什么时候会”退化”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态数组索引-C99"><span class="nav-text">静态数组索引(C99)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针"><span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针的类型-amp-指针指向的类型"><span class="nav-text">指针的类型 &amp; 指针指向的类型:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针的加减运算"><span class="nav-text">指针的加减运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-amp-指针的不同"><span class="nav-text">数组 &amp; 指针的不同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体"><span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体字节对齐"><span class="nav-text">结构体字节对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#含位域结构体的sizeof"><span class="nav-text">含位域结构体的sizeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#柔性数组-flexible-array"><span class="nav-text">柔性数组(flexible array)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#typedef"><span class="nav-text">typedef</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可变参函数"><span class="nav-text">可变参函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宏-macro"><span class="nav-text">宏(macro)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#宏定义"><span class="nav-text">宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#宏常量"><span class="nav-text">宏常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏函数"><span class="nav-text">宏函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏定义中的”-”和”-”"><span class="nav-text">宏定义中的”#”和”##”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数的宏"><span class="nav-text">可变参数的宏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理器-amp-条件编译"><span class="nav-text">预处理器 &amp; 条件编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义宏"><span class="nav-text">预定义宏</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#博客旧文章"><span class="nav-text">博客旧文章</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/11.Programming-Language/C-Tutorials.01.基础/';
          this.page.identifier = '11.Programming-Language/C-Tutorials.01.基础/';
          this.page.title = 'C Tutorials-01-基础';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
