<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Golang," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="Golang中的约定大于配置Golang遵循”约定大于配置”(convention over configuratio)的理念:  小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public) 结构体中的”小写开头的成员”, 在用 json.Marshal 序列化时会被忽略  每个文件是一个 package，声明在源文件第一行，packag">
<meta name="keywords" content="Golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang Tutorials-01基础">
<meta property="og:url" content="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="Golang中的约定大于配置Golang遵循”约定大于配置”(convention over configuratio)的理念:  小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public) 结构体中的”小写开头的成员”, 在用 json.Marshal 序列化时会被忽略  每个文件是一个 package，声明在源文件第一行，packag">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/golang-slice.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/golang-make-vs-new.png">
<meta property="og:updated_time" content="2024-01-24T01:46:51.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang Tutorials-01基础">
<meta name="twitter:description" content="Golang中的约定大于配置Golang遵循”约定大于配置”(convention over configuratio)的理念:  小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public) 结构体中的”小写开头的成员”, 在用 json.Marshal 序列化时会被忽略  每个文件是一个 package，声明在源文件第一行，packag">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/golang-slice.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/"/>





  <title>Golang Tutorials-01基础 | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Golang Tutorials-01基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/11-Programming-Language/" itemprop="url" rel="index">
                    <span itemprop="name">11.Programming-Language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,929
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Golang中的约定大于配置"><a href="#Golang中的约定大于配置" class="headerlink" title="Golang中的约定大于配置"></a>Golang中的约定大于配置</h1><p>Golang遵循”约定大于配置”(convention over configuratio)的理念:</p>
<ul>
<li>小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public)</li>
<li><p>结构体中的”小写开头的成员”, 在用 <code>json.Marshal</code> 序列化时会被忽略</p>
</li>
<li><p>每个文件是一个 package，声明在源文件第一行，<code>package main</code> 是一个特殊的包</p>
</li>
<li><p>import as <code>_</code> 和 <code>.</code> 的包:</p>
<ul>
<li><code>import . &quot;packageXXX&quot;</code> : 调用包内的函数,不需要再加 <code>packageXXX.</code></li>
<li><code>import _ &quot;packageXXX&quot;</code> : 匿名导入，并不使用包内导出的函数，而是仅仅让包的 init 得到调用</li>
</ul>
</li>
<li><p>单元测试:</p>
<ul>
<li>文件名: <code>源文件名_test.go</code></li>
<li>函数名: <code>func Test源函数名()</code></li>
</ul>
</li>
</ul>
<h1 id="Package-amp-Import"><a href="#Package-amp-Import" class="headerlink" title="Package &amp; Import"></a>Package &amp; Import</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A package clause starts every source file.</span></span><br><span class="line"><span class="comment">// main is a special name declaring an executable rather than a library.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// A package in the Go standard library.</span></span><br><span class="line">    <span class="string">"io/ioutil"</span> <span class="comment">// Implements some I/O utility functions.</span></span><br><span class="line">    <span class="string">"math"</span>    <span class="comment">// Math library with local alias m.</span></span><br><span class="line">    <span class="string">"net/http"</span>  <span class="comment">// Yes, a web server!</span></span><br><span class="line">    <span class="string">"os"</span>        <span class="comment">// OS functions like working with the file system</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>init()函数特性:</p>
<ul>
<li>在 main 之前, 由 runtime 调用</li>
<li>同一个 go 文件下, 可以有多个 init 函数, 调用顺序同定义顺序</li>
<li>同一个 package 下, 可以有多个 init 函数, 调用顺序似乎是 go 文件字典顺序, 但不要依赖此顺序做初始化</li>
<li>对于 import 导入的包，这些导入的包的 init 的调用顺序同 import 的顺序</li>
<li>用户代码无法调用 <code>init()</code>, 会报错 undefined</li>
</ul>
<p>➤ init 使用场景:</p>
<ul>
<li>做初始化；</li>
<li>实现 sync.Once 功能；</li>
<li>无法用初始化表达式初始的变量；</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li><p>变量的声明 + 初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更方便的写法</span></span><br><span class="line">j := <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>Go 支持全局变量，首字母大写的变量名表示可被外界访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">100</span> <span class="comment">// 未导出的本地变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyConst = <span class="string">"hello"</span> <span class="comment">// 导出的全局变量</span></span><br></pre></td></tr></table></figure>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p><strong>整形</strong>：</p>
<ul>
<li><code>uint8</code>/<code>int8</code>: 平台无关, 8位</li>
<li><code>uint16</code>/<code>int16</code>: ..</li>
<li><code>uint32</code>/<code>int32</code>: ..</li>
<li><code>uint64</code>/<code>int64</code>: ..</li>
<li><code>uint</code>/<code>int</code>: 平台有关，可能是32 or 64 bits(视机器平台而定)</li>
</ul>
<p><strong>浮点数</strong>：</p>
<ul>
<li><code>float32</code>：平台无关，4位</li>
<li><code>float64</code>：…</li>
</ul>
<p><strong>复数</strong>：</p>
<ul>
<li><code>complex64</code>: 复数, 由float32的实部 + float32的虚部构成</li>
</ul>
<p>@ref: <a href="https://golang.google.cn/ref/spec#Numeric_types" target="_blank" rel="noopener">The Go Programming Language Specification - The Go Programming Language</a></p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><ul>
<li><p>双引号和反引号： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">"string example"</span></span><br><span class="line">str2 := <span class="string">`another string</span></span><br><span class="line"><span class="string">example`</span></span><br><span class="line">str3 := <span class="string">`&#123;"type": "json"&#125;`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串是”只读的”, 意味着无法直接修改字符串的内存空间</p>
</li>
<li><p>字符串的实现，运行时使用 <code>reflect.StringHeader</code> 结构体表示字符串，与切片的结构体（<code>SliceHeader</code>）相比，字符串只少了一个表示容量的 <code>Cap</code> 字段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type StringHeader struct &#123;</span><br><span class="line">  Data uintptr</span><br><span class="line"> Len  int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断字符串 empty: <code>len(str) == 0</code></p>
</li>
</ul>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul>
<li><p>Golang的类型转换: <code>T(var)</code></p>
</li>
<li><p>字符串 → any 都可以用<code>strconv</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, err := strconv.ParseInt(<span class="string">"1287089"</span>, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">result := <span class="keyword">int</span>(i)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Golang 函数声明的不同之处：形参列表后面才是返回值，返回值可以有多个，变量名在前类型在后</p>
<ul>
<li><p>多个返回值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum, prod <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+y, x*y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">(params ...<span class="keyword">type</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, param := <span class="keyword">range</span> params &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Golang 是值传递还是引用传递?</p>
<ul>
<li>Golang 是值传递, 函数内得到一份形参的拷贝</li>
<li>对于 slice, map, chan,  因为其结构内包含指针, 所以仍可以在函数内改变其存储的值</li>
<li>数组也是值传递，因为数组的类型是 <code>[N]Type</code>，所以数组作为形参是有局限性的，大小 N 被固定，推荐用 slice</li>
</ul>
</li>
</ul>
<h1 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h1><p>例1:<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p>
<p>例2:<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x = x + <span class="number">1</span></span><br><span class="line">      fmt.Printf(<span class="string">"foo1 val = %d\n"</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = foo2(<span class="number">133</span>)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>什么是闭包(closure)? a <strong>closure</strong> is a record storing <strong>a function</strong> together with <strong>an environment</strong>., 那么闭包的简化定义是: 函数+依赖的外部变量（不以参数传入的变量）</li>
<li>实际上, Golang 实现闭包, 实际是把 <em>函数</em> 和<em>它依赖的外部变量</em> 都放在了一个 struct 里, 用这个 struct 保存了函数地址，和它依赖的外部变量（的引用）</li>
<li>闭包的实现依赖 Golang 的逃逸分析, 在逃逸分析时，闭包依赖的外部环境变量，被判定为逃逸，则在堆上分配；</li>
<li>闭包另一个特性是延迟绑定, 意思是, 上面的闭包(也即 struct)里保存的环境变量的值, 不是在编译期确定的, 而是在<strong>闭包的运行时才确定</strong>, 在闭包的外部寻找依赖变量的最新值, 并赋值进去 // 闭包的运行时即 <code>闭包()</code> 时；</li>
</ul>
<blockquote>
<p><a href="https://zh.wikipedia.org/zh-cn/%E9%97%AD%E5%8C%85_ (%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">闭包 - 维基百科，自由的百科全书</a>)<br>在支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" title="头等函数" target="_blank" rel="noopener">头等函数</a>的语言中，如果函数f内定义了函数g，那么如果g存在<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F" title="自由变量" target="_blank" rel="noopener">自由变量</a>，且这些自由变量没有在编译过程中被优化掉，那么将产生闭包。</p>
</blockquote>
<p>再使用一个例子说明闭包的<strong>延迟绑定</strong>，下面输出什么?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(x <span class="keyword">int</span>)</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="title">values</span> := []<span class="title">int</span></span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">		fs = <span class="built_in">append</span>(fs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"in closure, x + val = %d\n"</span>, x+val)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs := foo(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> fs &#123;</span><br><span class="line">    f() <span class="comment">// 闭包运行时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类问题的通解是：</p>
<ul>
<li>找出闭包，找出闭包依赖的外部变量</li>
<li>在闭包运行时（调用 <code>func()</code> 时），找到外部变量当前值</li>
</ul>
<p>分析:</p>
<ul>
<li>foo 返回了一个数组, 数组内是4个闭包函数, 闭包函数依赖2个外部变量: x 和 val</li>
<li>foo 返回 fs 的时候, 仅仅是返回了一个闭包的定义, struct 定义中包含有“外部变量” x 和 val，但是 struct 中的 x 和 val 只是引用，并没有绑定值</li>
<li>第一次执行 <code>f()</code> 时, 寻找 x 和 val 的最新值并绑定到闭包, 也即10 和 3</li>
<li>所以输出的%d 是 13,13,13,13</li>
</ul>
<p><strong>Goroutine 的闭包</strong>：</p>
<ul>
<li><p>没有自由变量，没有形成真正的闭包：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"foo4 val = %v\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> show(val) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">foo4() <span class="comment">// 打印 1,2,3,5 （不一定按顺序）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>go 后面的匿名函数内，使用了自由变量，形成了闭包，所以外部变量会在“运行时”绑定：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"foo5 val = %v\n"</span>, val)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">foo5() <span class="comment">// 打印 5,5,5,5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解析：</p>
<ul>
<li><code>go func() {... } ()</code> 的写法，虽然最后带 <code>()</code>，但匿名函数并没有立刻执行，只是将它加入任务队列等待调度；</li>
<li>匿名函数使用了外部变量，也即形成了闭包，Go 对闭包的实现是定义一个 struct，该 struct 的成员包括函数返回地址和引用的环境中的变量地址；</li>
<li>匿名函数被 Goroution scheduler 调度到，以闭包的方式执行</li>
</ul>
<p>@ref:</p>
<ul>
<li>闭包的实现 · 深入解析Go：<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html</a></li>
<li>Golang：“闭包（closure）”到底包了什么？ - 知乎：<a href="https://zhuanlan.zhihu.com/p/92634505" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92634505</a></li>
</ul>
<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><ul>
<li><p>if可以先赋值再判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x:=computerValue(); x&gt;y &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按次数循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环1</span></span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;<span class="number">10</span>; x++ &#123;</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历map/slice, 使用关键字<code>range</code>:  <code>index, elem : = range slice</code> or <code>k, v := range map</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环遍历 map</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;<span class="string">"one"</span>:<span class="number">1</span>, <span class="string">"two"</span>:<span class="number">2</span>&#125; &#123;</span><br><span class="line">  fmt.Println(<span class="string">"%s %d\n"</span>, k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历 slice</span></span><br><span class="line"><span class="keyword">for</span> i,s := <span class="keyword">range</span> []<span class="keyword">string</span> &#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125; &#123;</span><br><span class="line">  fmt.Println(<span class="string">"%d %s\n"</span>, i,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="comment">// 隐式break, 匹配到一个即停止</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><blockquote>
<p>@ref: <a href="https://colobu.com/2017/06/26/learn-go-type-aliases/" target="_blank" rel="noopener">https://colobu.com/2017/06/26/learn-go-type-aliases/</a></p>
</blockquote>
<p>golang中type的用法:</p>
<ul>
<li>定义新类型: <code>type newType oldType</code> // C++中的typedef用法是<code>typedef oldType newType</code> …</li>
<li>定义结构体: <code>type STypeName struct{}</code></li>
<li><p>类型别名:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> FloatType <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名2:</span></span><br><span class="line"><span class="keyword">type</span> S = <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> str S = <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数别名:</span></span><br><span class="line"><span class="keyword">type</span> F = <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">foo</span> <span class="title">F</span> = <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><ul>
<li><p>定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourFirstStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  member1 <span class="keyword">string</span></span><br><span class="line">  member2 <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// 每个成员没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := YourFirstStruct &#123;</span><br><span class="line">  member1: <span class="string">"member1"</span>,</span><br><span class="line">  member2: <span class="string">"member2"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>golang 只有值传递, struct 在函数内/外传递 or 直接 <code>=</code> 赋值给另一 struct 变量, 都会有一次拷贝；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := YourFirstStruct &#123;</span><br><span class="line">  member1: <span class="string">""</span></span><br><span class="line">  member2: <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">s2 := s1 <span class="comment">// 赋值导致一次拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免拷贝的做法:</span></span><br><span class="line">ptr1 := &amp;YourFirstStruct &#123;</span><br><span class="line">&#125;</span><br><span class="line">ptr2 := ptr1 <span class="comment">// 指针传递</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为函数传参是值传递，所以在函数内对 struct 类型的参数进行更改，所修改的只是副本，如果需要实现在函数内对 struct 的修改，应该使用 <code>*T</code> 类型作为形参；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">	Value 		<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	myT := T&#123;Value:<span class="number">666</span>&#125;</span><br><span class="line"></span><br><span class="line">	change(&amp;myT)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(myT.Value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(t *T)</span></span>&#123;</span><br><span class="line">	t.Value = <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>给Struct添加方法, 无需C++那样的头文件声明, 直接定义方法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s被叫做“接收器”，第一种是“指针接收器”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *YourFirstStruct)</span> <span class="title">foo</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “值接收器”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s YourFirstStruct)</span> <span class="title">foo2</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较 struct 的“指针接收器” &amp; “值接收器”</p>
<ul>
<li>如果 func 内改变结构体的内容，需要“指针接收器”；</li>
<li>从性能比较，“值接收器” 需要更多次拷贝；</li>
<li>如果使用“值接收器”，因为函数内使用的是拷贝，所以func线程安全</li>
</ul>
</li>
</ul>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ul>
<li><p>interface是一种类型, 包括0个或多个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">  Get() <span class="keyword">int</span></span><br><span class="line">  Set(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空interface: <code>interface{}</code> 没有方法的interface, 可以认为任何类型都实现了该interface,</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(any <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// foo可以接受任何类型的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Golang里没有extends这样的关键字来表名 某struct 实现了 某Interface, 只是在 <em>赋值</em>, <em>入参</em>, <em>返回值</em> 时被动检查</p>
</li>
</ul>
<h1 id="array"><a href="#array" class="headerlink" title="array"></a>array</h1><ul>
<li><p>数组在编译期即指定大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组在用var声明时即分配了空间并给初始值</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明, 同时赋值</span></span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>golang在创建<strong>字面量数组</strong>时, 会根据数组长度进行不同的处理</p>
<ul>
<li>数组len&lt;=4, 直接在栈上分配数组</li>
<li>数组len&gt;4, 会在静态区分配数组(编译期), 并在运行时取出来</li>
<li>上述没有考虑逃逸</li>
</ul>
</li>
<li><p>数组的类型是: <code>[N]ElemType</code>, 长度也算类型的一部分, 例如 <code>[10]int</code> 和 <code>[3]int</code> 是不同的类型</p>
</li>
<li><p>在 golang 中，数组也是值传递，所以：</p>
<ul>
<li>对于大型数组，应该使用 <em>数组指针 or slice</em> 的方式传递参数，避免拷贝；</li>
<li>如果要在函数内，修改函数外声明的数组，需要使用<em>数组指针</em>作为参数；</li>
</ul>
</li>
</ul>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><ul>
<li>slice: Golang 内置类型, 即”动态数组” // 区别：数组的长度固定，不可改变</li>
<li><p>比较 slice 和 array 的声明方式</p>
<ul>
<li><code>s2 := []int{1,2,3}</code> 字面量声明方式创建 slice</li>
<li>如果上面使用 <code>[N]</code> or <code>[...]</code> ，创建出来的就不是 slice 而是 array 了</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组: 声明即分配空间</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片: 声明时没有分配空间</span></span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="keyword">string</span></span><br><span class="line">slice0[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片1, 通过数组</span></span><br><span class="line">s1 := arr0[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片2, 创建时给初值</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片3, len=cap=0</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>切片的扩容: 向切片add元素, 如果 len 大于 cap, 将创建新数组, 大小为原切面cap的两倍, 然后所有元素复制到新数组中</p>
</li>
<li><p>切片底层实现，由两部分组成: Header + 数组实际存储空间, 其中 Header 的结构表述如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">array unsafe.Pointer // 指针, 指向连续的内存</span><br><span class="line">len   int</span><br><span class="line">cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/golang-slice.png" alt="../_images/golang-slice.png"></p>
</li>
<li><p>从数组创建切片: <code>slice := array[startIndex:endIndex]</code> , 切片将包含 <code>array[startIndex] ...array[endIdex-1]</code>, 这种方式创建的新数组, 只是新建了一个 slice 结构, data 指针指向的即是数组, 故修改 slice 的数据也会影响数组中的值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := array3[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// 此时slice包括 [2,3], len=2, 但slice指向的数组是[2,3,4,5], 故cap=4</span></span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">7</span> <span class="comment">// 对切片的修改也会影响数组, 但当切片发生一次扩容之后, 切片会指向一个新申请的数组空间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制切片：<code>slice3 :=  slice2[:]</code> 可以快速复制切片，但缺陷是 <code>slice3</code> 和 <code>slice2</code> 是同一个切片，无论改动哪个，另一个都会产生变化。内建函数 <code>copy</code> 可以用于复制 slice，并且两个 slice 各自使用独立的数组，见「内置函数」</p>
</li>
</ul>
<p>➤ 比较数组和切片:</p>
<ul>
<li>数组声明即分配空间, 且不可改变长度</li>
<li>切片声明不分配空间, 需要通过<code>make()</code> or <code>arr[start:end]</code></li>
<li>切片的类型是 <code>[]type</code>, 数组的类型是<code>[N]type</code></li>
</ul>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul>
<li><p>声明和初始化, 赋值, 访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> mmap1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">mmap1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">mmap1[<span class="string">"One"</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="keyword">if</span> v, exist := mmap1[<span class="string">"One"</span>]; exist &#123;</span><br><span class="line">  <span class="built_in">delete</span>(mmap1, <span class="string">"One"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明+定义</span></span><br><span class="line">mmap2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;<span class="string">"One"</span>:<span class="number">1</span>, <span class="string">"Two"</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>How to range map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v = <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s %s"</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h1><p>见第二部分</p>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><p>@ref: <a href="https://pkg.go.dev/builtin#pkg-functions" target="_blank" rel="noopener">https://pkg.go.dev/builtin#pkg-functions</a></p>
<h2 id="len-cap"><a href="#len-cap" class="headerlink" title="len/cap"></a>len/cap</h2><ul>
<li>len/cap: 返回数组, slice, map, string, chan ..的长度&amp;容量</li>
</ul>
<h2 id="append-copy"><a href="#append-copy" class="headerlink" title="append/copy"></a>append/copy</h2><ul>
<li>append: 切片拼接，原型: <code>func append(slice []Type, elems ...Type) []Type</code></li>
<li>copy：切片复制，原型: <code>func copy(dst, src []Type) int</code></li>
</ul>
<h2 id="print-println"><a href="#print-println" class="headerlink" title="print/println"></a>print/println</h2><ul>
<li>print：输出到 std err，原型: <code>func print(args ...Type)</code></li>
<li><p>println：输出到 std err，arg 之间有空格，且有换行，原型: <code>func println(args ...Type)</code></p>
<p>区分 <code>fmt.Print()</code>，输出到 <strong>standard output</strong></p>
</li>
</ul>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>slice:<ul>
<li>make([]T)</li>
<li>make([]T, len)</li>
<li>make([]T, len, cap)</li>
</ul>
</li>
<li>map:<ul>
<li>make(map[K]V)</li>
<li>make(map[K]V, cap)</li>
</ul>
</li>
<li>chan:<ul>
<li>make(chan T, cap)</li>
</ul>
</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ul>
<li>原型: <code>func new(Type) *Type</code></li>
<li>作用: 返回为指定类型分配的内存地址，分配的内存置零</li>
<li><p>example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  member1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建struct方式1</span></span><br><span class="line">p1 := <span class="built_in">new</span>(YourStruct)</span><br><span class="line">p1.member1 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建struct方式2</span></span><br><span class="line">p2 := &amp;YourStruct&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Golang 中 new 和 var ，一个返回指针一个返回变量，二者的实现没有本质区别，都是要通过逃逸分析判断是在栈上/堆上分配变量（如果没有逃逸，new 创建的变量也可能在栈上创建）</p>
</li>
</ul>
<h2 id="make-vs-new"><a href="#make-vs-new" class="headerlink" title="make vs new"></a>make vs new</h2><ul>
<li>new(T)：<ul>
<li>分配一块内存，内存置零，返回其指针（并未初始化）</li>
<li>根据new(T)的T创建内存，返回<code>*T</code>类型，<code>p := new(Type)</code> 等同于<code>p := &amp; Type{}</code></li>
</ul>
</li>
<li>make(T)：<ul>
<li>分配一块内存，并初始化，返回地址</li>
<li>make只能用于初始化slice/map/chan</li>
</ul>
</li>
</ul>
<p><img src="/images/golang-make-vs-new.png" alt="../_images/golang-make-vs-new.png"></p>
<p>比较： </p>
<ul>
<li><code>new([]int)</code> 只分配了一片内存（指向 <code>[]int</code> 类型，也就是 slice 的头）但是这块内存的 ptr 并未初始化；</li>
<li><code>make([]int)</code> 为 slice 的 prt 做了初始化；</li>
</ul>
<p>@ref:</p>
<ul>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#551-make" target="_blank" rel="noopener">Go 语言中的 make 和 new | Go 语言设计与实现</a></li>
</ul>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><ul>
<li>delete: 用于删除 map 里的 key, 原型: <code>func delete(m map[Type]Type1, key Type)</code></li>
</ul>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><ul>
<li>关闭 chan，原型 <code>func close(c chan&lt;- Type)</code></li>
</ul>
<p>close() 只能由 sender 调用，不可以由 receiver 调用，一旦对 chan 使用了 close，在接收完最后一个值后，该 chan 将被关闭，任何从该 chan 的 receive 都会返回 <strong>success</strong> 而不会阻塞；</p>
<h2 id="panic-amp-recovery"><a href="#panic-amp-recovery" class="headerlink" title="panic &amp; recovery"></a>panic &amp; recovery</h2><p><strong>panic</strong>： panic 会停止当前 Goroutine 的正常执行，相当于其他编程语言的抛异常</p>
<ul>
<li>原型：<code>func panic(v any)</code></li>
<li>行为：<ul>
<li>当函数 F 调用了 panic，F 的执行会被停止，在 F 中 panic 前面定义的 defer 操作都会被执行，然后 F 函数返回给调用者 G。</li>
<li>对于 G，调用 F 的行为类似于调用 panic，G 将调用 defer 函数，并返回给上一层调用者，直到程序非零值退出（除非调用了recover）</li>
</ul>
</li>
</ul>
<p><strong>recovery</strong>：让程序从 panic 中恢复，阻止 panic 继续向上层调用者传播。返回类型是 any，返回的值是传入 <code>panic(v)</code> 的参数，recovery 必须在 defer 块中调用</p>
<ul>
<li>原型：<code>func recover() any</code></li>
</ul>
<p>➤ <strong>panic</strong> &amp; <strong>recovery</strong> 使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Recovered in main"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"Returned normally from main."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Calling f."</span>)</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Panicking in f!"</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%v"</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Returned normally from f."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ref: <a href="https://pkg.go.dev/builtin#panic" target="_blank" rel="noopener">https://pkg.go.dev/builtin#panic</a></p>
<p>➤ <strong>defer</strong> 关键字 → [[#defer]]</p>
<h1 id="error"><a href="#error" class="headerlink" title="error"></a>error</h1><ul>
<li><p><code>error</code>是一个Interface:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 接口只有一个函数,返回字符串</span></span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>errors</code>创建一个错误: <code>err := errors.New(&quot;Error occured!&quot;)</code>, 返回的是一个<code>type errorString struct</code>类型的错误</p>
</li>
<li>定义自己的 error 类型: 定义错误的 Struct 类型, 然后实现 <code>Error() string</code> 方法即可</li>
</ul>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><ul>
<li>函数内定义的 defer 后的表达式，在函数退出前执行；</li>
<li>一个 func 可以有多个 defer 语句, defer 语句被压入栈中，所以函数退出时执行顺序与 defer 定义顺序相反；</li>
<li>如果 defer 之后是一个带参函数，例如 <code>defer f(i)</code>，运行至 defer 时会立刻保存 i 的值（类似于一次值拷贝）；</li>
<li>如果 defer 之后形成了<strong>闭包</strong>（匿名函数内使用了外部变量），那么对外部变量的处理与闭包类似，在闭包实际运行时读取外部变量的最新值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferEtudes3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span> <span class="comment">// 以形参传入，不是闭包的自由变量</span></span><br><span class="line">	j := <span class="number">9</span> <span class="comment">// 形成闭包的自由变量</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"in defer: i=%d, j=%d\n"</span>, i, j) <span class="comment">// 1， 10</span></span><br><span class="line">	&#125;(i)</span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line">	j = j + <span class="number">1</span></span><br><span class="line">	fmt.Printf(<span class="string">"in func: i=%d, j=%d\n"</span>, i, j) <span class="comment">// 2， 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// j是闭包的自由变量，符合“运行时”绑定值，</span></span><br><span class="line">    <span class="comment">// i以参数传入，不是闭包的自由变量，会在运行到defer时就保存当时的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ref：</p>
<ul>
<li><a href="https://go.dev/blog/defer-panic-and-recover" target="_blank" rel="noopener">Defer, Panic, and Recover - The Go Programming Language</a></li>
</ul>
<p>➤ <strong>defer</strong> 的实现：</p>
<ul>
<li>编译器将 defer 关键字转换为调用 <code>runtime.deferproc()</code> 函数，这个函数接收了参数的大小和闭包所在的地址两个参数。</li>
<li>在 <code>runtime.deferproc()</code> 中，创建一个 <code>runtime._defer</code> 结构体，并为它的成员赋值：函数指针 <code>fn</code>、程序计数器 <code>pc</code> 和栈指针 <code>sp</code> ，并将相关的参数拷贝到相邻的内存空间中，并将结构体加入 <code>_defer</code> 链表的开头；</li>
<li>在调用 defer 的函数末尾，插入 <code>runtime.deferreturn()</code> 函数的调用，该函数会从 Goroutine 的 <code>_defer</code> 链表中取出最前面的 <code>runtime._defer</code> 结构体 … </li>
<li>以上 @ref: <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer" target="_blank" rel="noopener">理解 Go 语言 defer 关键字的原理 | Go 语言设计与实现</a></li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul>
<li>小写开头的成员默认不被序列化</li>
<li>struct tag: <code>json:&quot;var_name&quot;</code> 指定序列化后的变量名</li>
<li>struct tag: <code>json:&quot;var_name,omitempty&quot;</code> 如果成员值为”zero-value”, 序列化将不包括此字段</li>
<li><p>struct tag: <code>json:&quot;-&quot;</code> 序列化时跳过此字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourFirstStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  Mem1 <span class="keyword">string</span>  <span class="string">`json:"variable1"`</span></span><br><span class="line">  Mem2 <span class="keyword">string</span>  <span class="string">`json:"variable2,omitempty"`</span></span><br><span class="line">  Mem3 <span class="keyword">string</span>  <span class="string">`json:"-"`</span></span><br><span class="line">  <span class="comment">// 每个成员没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Type(struct/map 等) → byte[]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice_of_byte, err := json.Marshal(obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p>byte[] → Type</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">obj := <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json_str := <span class="string">`&#123;"Name":"X", "Age": 101&#125;`</span></span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(json_str), &amp;obj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="时间-API"><a href="#时间-API" class="headerlink" title="时间 API"></a>时间 API</h1><ul>
<li>获取 int64时间戳: <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timestampSec <span class="keyword">int32</span> = time.Now().Unix()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><a href="https://geektutu.com/post/quick-go-test.html" target="_blank" rel="noopener">https://geektutu.com/post/quick-go-test.html</a></p>
<h1 id="命令行-amp-环境"><a href="#命令行-amp-环境" class="headerlink" title="命令行 &amp; 环境"></a>命令行 &amp; 环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">	go &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">	bug         start a bug report</span><br><span class="line">	build       compile packages and dependencies</span><br><span class="line">	clean       remove object files and cached files</span><br><span class="line">	doc         show documentation for package or symbol</span><br><span class="line">	env         print Go environment information</span><br><span class="line">	fix         update packages to use new APIs</span><br><span class="line">	fmt         gofmt (reformat) package sources</span><br><span class="line">	generate    generate Go files by processing source</span><br><span class="line">	get         add dependencies to current module and install them</span><br><span class="line">	install     compile and install packages and dependencies</span><br><span class="line">	list        list packages or modules</span><br><span class="line">	mod         module maintenance</span><br><span class="line">	run         compile and run Go program</span><br><span class="line">	test        test packages</span><br><span class="line">	tool        run specified go tool</span><br><span class="line">	version     print Go version</span><br><span class="line">	vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure>
<p>➤ 常用：</p>
<ul>
<li>获取包并安装：<code>go get golang.org/x/tools/gopls@latest</code> （源码默认下载到 $GOPATH/src）</li>
<li>开启 Go module：<code>go env -w GO111MODULE=on</code>，从 v1.13 版本开始这个选项默认开启</li>
</ul>
<blockquote>
<p>Go 1.11 引入了 Go Modules，不再使用 GOPATH 存储每个依赖包的 git checkout，而是通过项目目录下的 go.mod 记录依赖包</p>
</blockquote>
<p>➤ Golang 的环境变量可以使用 <code>go env</code> 查看：</p>
<ul>
<li><code>$GOROOT</code> 表示 Go SDK 的安装位置，它的值一般都是 $HOME/go</li>
<li><code>$GOPATH</code> 表示工作空间的路径，用来保存 Go 项目代码和第三方依赖包</li>
<li><code>$GOARCH</code> 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。</li>
<li><code>$GOOS</code> 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。</li>
<li><code>$GOARM</code> 专门针对基于 arm 架构的处理器，它的值可以是 5~7，默认为 6。</li>
</ul>
<blockquote>
<ul>
<li>GOARM=5: 使用软件浮点（software floating point）；当 CPU 没有 VFP 协同处理器时</li>
<li>GOARM=6: 仅使用 VFPv1; 使用交叉编译时的默认使用此选项，通常在 ARM11 或更高版本的内核中使用（也支持 VFPv2 或更高版本）</li>
<li>GOARM=7: 使用 VFPv3；通常在 Cortex-A 内核中使用</li>
</ul>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Golang/" rel="tag"># Golang</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/11.Programming-Language/C和CPP标准/" rel="next" title="C语言 & C++ 标准">
                <i class="fa fa-chevron-left"></i> C语言 & C++ 标准
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/11.Programming-Language/Golang-Tutorials.02.并发/" rel="prev" title="Golang Tutorials-02并发">
                Golang Tutorials-02并发 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">486</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">412</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang中的约定大于配置"><span class="nav-text">Golang中的约定大于配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Package-amp-Import"><span class="nav-text">Package &amp; Import</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#init"><span class="nav-text">init</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量"><span class="nav-text">变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全局变量"><span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本数据类型"><span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#string"><span class="nav-text">string</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型转换"><span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包（closure）"><span class="nav-text">闭包（closure）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制语句"><span class="nav-text">控制语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#type"><span class="nav-text">type</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#struct"><span class="nav-text">struct</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#interface"><span class="nav-text">interface</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#array"><span class="nav-text">array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice"><span class="nav-text">slice</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#map"><span class="nav-text">map</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chan"><span class="nav-text">chan</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内置函数"><span class="nav-text">内置函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#len-cap"><span class="nav-text">len/cap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#append-copy"><span class="nav-text">append/copy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#print-println"><span class="nav-text">print/println</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make"><span class="nav-text">make</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new"><span class="nav-text">new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make-vs-new"><span class="nav-text">make vs new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete"><span class="nav-text">delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#close"><span class="nav-text">close</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#panic-amp-recovery"><span class="nav-text">panic &amp; recovery</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#error"><span class="nav-text">error</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defer"><span class="nav-text">defer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化"><span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时间-API"><span class="nav-text">时间 API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单元测试"><span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#命令行-amp-环境"><span class="nav-text">命令行 &amp; 环境</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/';
          this.page.identifier = '11.Programming-Language/Golang-Tutorials.01.基础/';
          this.page.title = 'Golang Tutorials-01基础';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
