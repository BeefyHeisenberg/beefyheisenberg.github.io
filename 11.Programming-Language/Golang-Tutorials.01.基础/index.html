<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Golang," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="Golang中的约定大于配置Golang遵循”约定大于配置”(convention over configuratio)的理念:  小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public) 结构体中的”小写开头的成员”, 在用 json.Marshal 序列化时会被忽略  每个文件是一个 package，声明在源文件第一行，packag">
<meta name="keywords" content="Golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang Tutorials-01基础">
<meta property="og:url" content="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="Golang中的约定大于配置Golang遵循”约定大于配置”(convention over configuratio)的理念:  小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public) 结构体中的”小写开头的成员”, 在用 json.Marshal 序列化时会被忽略  每个文件是一个 package，声明在源文件第一行，packag">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/golang-slice.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/golang-make-vs-new.png">
<meta property="og:updated_time" content="2023-08-26T05:41:52.787Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang Tutorials-01基础">
<meta name="twitter:description" content="Golang中的约定大于配置Golang遵循”约定大于配置”(convention over configuratio)的理念:  小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public) 结构体中的”小写开头的成员”, 在用 json.Marshal 序列化时会被忽略  每个文件是一个 package，声明在源文件第一行，packag">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/golang-slice.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/"/>





  <title>Golang Tutorials-01基础 | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Golang Tutorials-01基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/11-Programming-Language/" itemprop="url" rel="index">
                    <span itemprop="name">11.Programming-Language</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,889
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Golang中的约定大于配置"><a href="#Golang中的约定大于配置" class="headerlink" title="Golang中的约定大于配置"></a>Golang中的约定大于配置</h1><p>Golang遵循”约定大于配置”(convention over configuratio)的理念:</p>
<ul>
<li>小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public)</li>
<li><p>结构体中的”小写开头的成员”, 在用 <code>json.Marshal</code> 序列化时会被忽略</p>
</li>
<li><p>每个文件是一个 package，声明在源文件第一行，<code>package main</code> 是一个特殊的包</p>
</li>
<li><p>import as <code>_</code> 和 <code>.</code> 的包:</p>
<ul>
<li><code>import . &quot;packageXXX&quot;</code> : 调用包内的函数,不需要再加 <code>packageXXX.</code></li>
<li><code>import _ &quot;packageXXX&quot;</code> : 匿名导入，并不使用包内导出的函数，而是仅仅让包的 init 得到调用</li>
</ul>
</li>
<li><p>单元测试:</p>
<ul>
<li>文件名: <code>源文件名_test.go</code></li>
<li>函数名: <code>func Test源函数名()</code></li>
</ul>
</li>
</ul>
<h1 id="Package-amp-Import"><a href="#Package-amp-Import" class="headerlink" title="Package &amp; Import"></a>Package &amp; Import</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A package clause starts every source file.</span></span><br><span class="line"><span class="comment">// main is a special name declaring an executable rather than a library.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// A package in the Go standard library.</span></span><br><span class="line">    <span class="string">"io/ioutil"</span> <span class="comment">// Implements some I/O utility functions.</span></span><br><span class="line">    <span class="string">"math"</span>    <span class="comment">// Math library with local alias m.</span></span><br><span class="line">    <span class="string">"net/http"</span>  <span class="comment">// Yes, a web server!</span></span><br><span class="line">    <span class="string">"os"</span>        <span class="comment">// OS functions like working with the file system</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>init()函数特性:</p>
<ul>
<li>在 main 之前, 由 runtime 调用</li>
<li>同一个 go 文件下, 可以有多个 init 函数, 调用顺序同定义顺序</li>
<li>同一个 package 下, 可以有多个 init 函数, 调用顺序似乎是 go 文件字典顺序, 但不要依赖此顺序做初始化</li>
<li>对于 import 导入的包，这些导入的包的 init 的调用顺序同 import 的顺序</li>
<li>用户无法自己调用 <code>init()</code>, 会报错 undefined</li>
</ul>
<p>使用场景:</p>
<ul>
<li>做初始化</li>
<li>实现 sync.Once 功能</li>
<li>无法用初始化表达式初始的变量</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li><p>声明 + 初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更方便的写法</span></span><br><span class="line">j := <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>Go 支持全局变量，首字母大写的变量名表示可被外界访问</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">100</span> <span class="comment">// 未导出的本地变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyConst = <span class="string">"hello"</span> <span class="comment">// 导出的全局变量</span></span><br></pre></td></tr></table></figure>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li>uint8/int8: 平台无关, 都是8位</li>
<li>uint16/int16: ..</li>
<li>uint32/int32: ..</li>
<li>uint64/int64: ..</li>
<li>float32</li>
<li>float64</li>
<li>uint/int: 与上面的不同, uint/int可能是32 or 64 bits(视机器平台而定)</li>
<li>complex64: 复数, 由float32的实部 + float32的虚部构成</li>
</ul>
<p>@ref: <a href="https://golang.google.cn/ref/spec#Numeric_types" target="_blank" rel="noopener">The Go Programming Language Specification - The Go Programming Language</a></p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><ul>
<li>判断字符串empty: <code>len(str) == 0</code></li>
<li>字符串是”只读的”, 意味着无法直接修改字符串的内存空间</li>
<li><p>字符串的实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type StringHeader struct &#123;</span><br><span class="line">  Data uintptr</span><br><span class="line"> Len  int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul>
<li><p>Golang的类型转换: <code>T(var)</code></p>
</li>
<li><p>字符串 → any 都可以用<code>strconv</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, err := strconv.ParseInt(<span class="string">"1287089"</span>,<span class="number">10</span>,<span class="number">32</span>)</span><br><span class="line">result := <span class="keyword">int</span>(i)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go 函数声明的不同之处：形参列表后面才是返回值，返回值可以有多个，变量名在前类型在后</p>
<ul>
<li><p>多个返回值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum, prod <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+y, x*y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">(params ...<span class="keyword">type</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, param := <span class="keyword">range</span> params &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Golang是值传递还是引用传递?</p>
<ul>
<li>Golang 是值传递, 函数内得到一份形参的拷贝</li>
<li>对于 slice, map, chan,  因为其结构内包含指针, 所以仍可以在函数内改变其存储的值</li>
<li>数组也是值传递，因为数组的类型是 <code>[N]Type</code>，所以数组作为形参是有局限性的，大小 N 被固定，推荐用 slice</li>
</ul>
</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包 先看几个例子:</p>
<p>例子1:<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p>
<p>例子2:<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x = x + <span class="number">1</span></span><br><span class="line">      fmt.Printf(<span class="string">"foo1 val = %d\n"</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = foo2(<span class="number">133</span>)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>什么是闭包(closure)? 一个函数, 并且此函数依赖函数外声明的变量, 那么闭包的定义是: 此函数+依赖的外部变量</li>
<li>实际上, Golang实现闭包, 实际是把 函数和它依赖的外部变量都放在了一个struct里, 用这个struct保存了函数和它依赖的外部变量</li>
<li>另外, 闭包的实现依赖Golang的逃逸分析, 对于闭包的环境变量, 是在堆上分配的, 这是闭包实现的基础</li>
<li>闭包另一个特性是延迟绑定, 意思是, 上面的闭包(也即struct)里保存的变量, 不是在编译期确定的, 而是在<strong>闭包的运行时才确定</strong>,  在闭包的外部寻找依赖变量的最新值, 并赋值进去</li>
</ul>
<p>下面输出什么?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo7</span><span class="params">(x <span class="keyword">int</span>)</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">values</span> := []<span class="title">int</span></span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">        fs = <span class="built_in">append</span>(fs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"foo7 val = %d\n"</span>, x+val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f7s := foo7(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">for</span> _, f7 := <span class="keyword">range</span> f7s &#123;</span><br><span class="line">    f7()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析:</p>
<ul>
<li>foo7返回了一个数组, 数组内是x个闭包函数, 闭包函数依赖2个外部变量: x 和 val</li>
<li>foo7返回 f7s的时候, 仅仅是返回了一个闭包的定义, 闭包内依赖的x 和 val并没有绑定值</li>
<li>第一次执行<code>f7()</code>, 寻找 x 和 val的最新值并绑定到闭包, 也即11 和 5</li>
</ul>
<p>@ref:</p>
<ul>
<li>闭包的实现 · 深入解析Go：<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html</a></li>
<li>Golang：“闭包（closure）”到底包了什么？ - 知乎：<a href="https://zhuanlan.zhihu.com/p/92634505" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92634505</a></li>
</ul>
<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><ul>
<li><p>if可以先赋值再判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x:=computerValue(); x&gt;y &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按次数循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环1</span></span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;<span class="number">10</span>; x++ &#123;</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历map/slice, 使用关键字<code>range</code>:  <code>index, elem : = range slice</code> or <code>k, v := range map</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环遍历 map</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;<span class="string">"one"</span>:<span class="number">1</span>, <span class="string">"two"</span>:<span class="number">2</span>&#125; &#123;</span><br><span class="line">  fmt.Println(<span class="string">"%s %d\n"</span>, k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历 slice</span></span><br><span class="line"><span class="keyword">for</span> i,s := <span class="keyword">range</span> []<span class="keyword">string</span> &#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125; &#123;</span><br><span class="line">  fmt.Println(<span class="string">"%d %s\n"</span>, i,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="comment">// 隐式break, 匹配到一个即停止</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><blockquote>
<p>@ref: <a href="https://colobu.com/2017/06/26/learn-go-type-aliases/" target="_blank" rel="noopener">https://colobu.com/2017/06/26/learn-go-type-aliases/</a></p>
</blockquote>
<p>golang中type的用法:</p>
<ul>
<li>定义新类型: <code>type newType oldType</code> // C++中的typedef用法是<code>typedef oldType newType</code> …</li>
<li>定义结构体: <code>type STypeName struct{}</code></li>
<li><p>类型别名:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> FloatType <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名2:</span></span><br><span class="line"><span class="keyword">type</span> S = <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> str S = <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数别名:</span></span><br><span class="line"><span class="keyword">type</span> F = <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">foo</span> <span class="title">F</span> = <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><ul>
<li><p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourFirstStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  member1 <span class="keyword">string</span></span><br><span class="line">  member2 <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// 每个成员没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := YourFirstStruct &#123;</span><br><span class="line">  member1: <span class="string">"member1"</span>,</span><br><span class="line">  member2: <span class="string">"member2"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>golang 只有值传递, struct 在函数内/外传递 or 直接 <code>=</code> 赋值给另一 struct 变量, 都会有一次拷贝；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := YourFirstStruct &#123;</span><br><span class="line">  member1: <span class="string">""</span></span><br><span class="line">  member2: <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">s2 := s1 <span class="comment">// 赋值导致一次拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免拷贝的做法:</span></span><br><span class="line">ptr1 := &amp;YourFirstStruct &#123;</span><br><span class="line">&#125;</span><br><span class="line">ptr2 := ptr1 <span class="comment">// 指针传递</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为函数传参是值传递，所以在函数内对 struct 类型的参数进行更改，所修改的只是副本，如果需要实现在函数内对 struct 的修改，应该使用 <code>*</code> 类型作为形参；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">	Value 		<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	myT := T&#123;Value:<span class="number">666</span>&#125;</span><br><span class="line"></span><br><span class="line">	change(&amp;myT)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(myT.Value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(t *T)</span></span>&#123;</span><br><span class="line">	t.Value = <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>给Struct添加方法, 无需C++那样的头文件声明, 直接定义方法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s被叫做“接收器”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *YourFirstStruct)</span> <span class="title">foo</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ul>
<li><p>interface是一种类型, 包括0个或多个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">  Get() <span class="keyword">int</span></span><br><span class="line">  Set(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空interface: <code>interface{}</code> 没有方法的interface, 可以认为任何类型都实现了该interface,</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(any <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// foo可以接受任何类型的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Golang里没有extends这样的关键字来表名 某struct 实现了 某Interface, 只是在 <em>赋值</em>, <em>入参</em>, <em>返回值</em> 时被动检查</p>
</li>
</ul>
<h1 id="array"><a href="#array" class="headerlink" title="array"></a>array</h1><ul>
<li><p>数组在编译期即指定大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组在用var声明时即分配了空间并给初始值</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明, 同时赋值</span></span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>golang在创建<strong>字面量数组</strong>时, 会根据数组长度进行不同的处理</p>
<ul>
<li>数组len&lt;=4, 直接在栈上分配数组</li>
<li>数组len&gt;4, 会在静态区分配数组(编译期), 并在运行时取出来</li>
<li>上述没有考虑逃逸</li>
</ul>
</li>
<li><p>数组的类型是: <code>[N]ElemType</code>, 长度也算类型的一部分, 例如 <code>[10]int</code> 和 <code>[3]int</code> 是不同的类型</p>
</li>
<li><p>在 golang 中，数组也是值传递，所以：</p>
<ul>
<li>对于大型数组，应该使用 <em>数组指针 or slice</em> 的方式传递参数，避免拷贝；</li>
<li>如果要在函数内，修改函数外声明的数组，需要使用<em>数组指针</em>作为参数；</li>
</ul>
</li>
</ul>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><ul>
<li>slice: Golang 内置类型, 即”动态数组” // 区别：数组的长度固定，不可改变</li>
<li><p>比较 slice 和 array 的声明方式</p>
<ul>
<li><code>s2 := []int{1,2,3}</code> 字面量声明方式创建 slice</li>
<li>如果上面使用 <code>[N]</code> or <code>[...]</code> ，创建出来的就不是 slice 而是 array 了</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组: 声明即分配空间</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片: 声明时没有分配空间</span></span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="keyword">string</span></span><br><span class="line">slice0[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片1, 通过数组</span></span><br><span class="line">s1 := arr0[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片2, 创建时给初值</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片3, len=cap=0</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>切片的扩容: 向切片add元素, 如果 len 大于 cap, 将创建新数组, 大小为原切面cap的两倍, 然后所有元素复制到新数组中</p>
</li>
<li><p>切片底层实现，由两部分组成: Header + 数组实际存储空间, 其中 Header 的结构表述如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">array unsafe.Pointer // 指针, 指向连续的内存</span><br><span class="line">len   int</span><br><span class="line">cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/golang-slice.png" alt="../_images/golang-slice.png"></p>
</li>
<li><p>从数组创建切片: <code>slice := array[startIndex:endIndex]</code> , 切片将包含 <code>array[startIndex] ...array[endIdex-1]</code>, 这种方式创建的新数组, 只是新建了一个 slice 结构, data 指针指向的即是数组, 故修改 slice 的数据也会影响数组中的值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := array3[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// 此时slice包括 [2,3], len=2, 但slice指向的数组是[2,3,4,5], 故cap=4</span></span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">7</span> <span class="comment">// 对切片的修改也会影响数组, 但当切片发生一次扩容之后, 切片会指向一个新申请的数组空间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制切片：<code>slice3 :=  slice2[:]</code> 可以快速复制切片，但缺陷是 <code>slice3</code> 和 <code>slice2</code> 是同一个切片，无论改动哪个，另一个都会产生变化。内建函数 <code>copy</code> 可以用于复制 slice，并且两个 slice 各自使用独立的数组，见「内置函数」</p>
</li>
</ul>
<p>➤ 比较数组和切片:</p>
<ul>
<li>数组声明即分配空间, 且不可改变长度</li>
<li>切片声明不分配空间, 需要通过<code>make()</code> or <code>arr[start:end]</code></li>
<li>切片的类型是 <code>[]type</code>, 数组的类型是<code>[N]type</code></li>
</ul>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul>
<li><p>声明和初始化, 赋值, 访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> mmap1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">mmap1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">mmap1[<span class="string">"One"</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="keyword">if</span> v, exist := mmap1[<span class="string">"One"</span>]; exist &#123;</span><br><span class="line">  <span class="built_in">delete</span>(mmap1, <span class="string">"One"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明+定义</span></span><br><span class="line">mmap2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;<span class="string">"One"</span>:<span class="number">1</span>, <span class="string">"Two"</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>How to range map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v = <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s %s"</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>map 的底层实现：<a href="https://golang.design/go-questions/map/principal/" target="_blank" rel="noopener">map 的实现原理 | Go 程序员面试笔试宝典</a></p>
</li>
</ul>
<h1 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h1><p>见第二部分</p>
<h1 id="内置函数-len-append-copy-panic"><a href="#内置函数-len-append-copy-panic" class="headerlink" title="内置函数(len/append/copy/panic..)"></a>内置函数(len/append/copy/panic..)</h1><p>@ref: <a href="https://pkg.go.dev/builtin#pkg-functions" target="_blank" rel="noopener">https://pkg.go.dev/builtin#pkg-functions</a></p>
<ul>
<li><p>len/cap: 返回数组, slice, map, string, chan ..的长度&amp;容量</p>
</li>
<li><p>append/copy: 切片拼接&amp;复制</p>
<ul>
<li>原型: <code>func append(slice []Type, elems ...Type) []Type</code></li>
<li>原型: <code>func copy(dst, src []Type) int</code></li>
</ul>
</li>
<li><p>print/println: 输出到std err // 区分<code>fmt.Print()</code></p>
<ul>
<li>原型: <code>func print(args ...Type)</code></li>
<li>原型: <code>func println(args ...Type)</code></li>
</ul>
</li>
<li><p>delete: 用于删除 map 里的 key, 原型: <code>func delete(m map[Type]Type1, key Type)</code></p>
</li>
<li><p>new:  → 本页 [[#new]]</p>
</li>
<li><p>make:  → 本页 [[#make]]</p>
</li>
</ul>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>slice:<ul>
<li>make([]T)</li>
<li>make([]T, len)</li>
<li>make([]T, len, cap)</li>
</ul>
</li>
<li>map:<ul>
<li>make(map[K]V)</li>
<li>make(map[K]V, cap)</li>
</ul>
</li>
<li>chan:<ul>
<li>make(chan T, cap)</li>
</ul>
</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ul>
<li>原型: <code>func new(Type) *Type</code></li>
<li>作用: 返回为指定类型分配的内存地址，分配的内存置零</li>
<li><p>example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  member1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建struct方式1</span></span><br><span class="line">p1 := <span class="built_in">new</span>(YourStruct)</span><br><span class="line">p1.member1 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建struct方式2</span></span><br><span class="line">p2 := &amp;YourStruct&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Golang 中 new 和 var ，一个返回指针一个返回变量，二者的实现没有本质区别，都是要通过逃逸分析判断是在栈上/堆上分配变量（如果没有逃逸，new 创建的变量也可能在栈上创建）</p>
</li>
</ul>
<h2 id="make-vs-new"><a href="#make-vs-new" class="headerlink" title="make vs new"></a>make vs new</h2><ul>
<li>new(T)：<ul>
<li>分配一块内存，内存置零，返回其指针（并未初始化）</li>
<li>根据new(T)的T创建内存，返回<code>*T</code>类型，<code>p := new(Type)</code> 等同于<code>p := &amp; Type{}</code></li>
</ul>
</li>
<li>make(T)：<ul>
<li>分配一块内存，并初始化，返回地址</li>
<li>make只能用于初始化slice/map/chan</li>
</ul>
</li>
</ul>
<p><img src="/images/golang-make-vs-new.png" alt="../_images/golang-make-vs-new.png"></p>
<p>比较： </p>
<ul>
<li><code>new([]int)</code> 只分配了一片内存（指向 <code>[]int</code> 类型，也就是 slice 的头）但是这块内存的 ptr 并未初始化</li>
<li><code>make([]int)</code> 为 slice 的 prt 做了初始化</li>
</ul>
<p>@ref:</p>
<ul>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#551-make" target="_blank" rel="noopener">Go 语言中的 make 和 new | Go 语言设计与实现</a></li>
</ul>
<h2 id="panic-amp-recovery"><a href="#panic-amp-recovery" class="headerlink" title="panic &amp; recovery"></a>panic &amp; recovery</h2><p>panic：</p>
<ul>
<li>panic 是内建的停止控制流的函数。相当于其他编程语言的抛异常操作。当函数 F 调用了 panic，F 的执行会被停止，在 F 中 panic 前面定义的 defer 操作都会被执行，然后 F 函数返回。</li>
</ul>
<p>recovery：</p>
<ul>
<li><p>defer：</p>
</li>
</ul>
<p>举例:</p>
<ul>
<li>G调用了F;</li>
<li>F调用panic</li>
</ul>
<p>行为:</p>
<ul>
<li>调用<code>panic</code>的函数 F被立刻停止, 不再向下执行</li>
<li>调用函数F中的defer, 然后F返回到它的Caller, G</li>
<li>G后面的代码不再执行, 执行所有的defer</li>
<li>程序以非0值退出</li>
<li>以上 @ref: <a href="https://pkg.go.dev/builtin#panic" target="_blank" rel="noopener">https://pkg.go.dev/builtin#panic</a></li>
</ul>
<p>@ref：</p>
<ul>
<li>Go 语言 panic 和 recover 的原理 | Go 语言设计与实现：<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</a></li>
<li><p><a href="https://www.cnblogs.com/makelu/p/11226974.html" target="_blank" rel="noopener">https://www.cnblogs.com/makelu/p/11226974.html</a></p>
</li>
<li><p>panic 函数调用后，会终止 “调用 panic” 的 Goroutine 的执行流程：直接去执行该 Goroutine 的 defer 链表中所有函数</p>
</li>
<li>defer 可以嵌套： <code>defer func() { defer xxx }</code></li>
<li>panic 可以嵌套： 可以在defer中再调用panic</li>
<li>recovery 只能在defer 函数中被调用， 用来终止程序的崩溃</li>
<li>编译器负责对defer关键字进行转换，在调用 defer 的函数末尾调用 runtime.deferreturn 函数 // 函数退出时一定执行defer</li>
<li>编译器把recovery关键字转换为<code>runtime.gorecover()</code>函数的调用，实现如下，当前Goroutine没有panic的时候，该函数直接返回，当有panic的时候</li>
</ul>
<p>问题：下面的输出顺序（嵌套崩溃）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"in main"</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"panic again and again"</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"panic again"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic once"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="error"><a href="#error" class="headerlink" title="error"></a>error</h1><ul>
<li><p><code>error</code>是一个Interface:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 接口只有一个函数,返回字符串</span></span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>errors</code>创建一个错误: <code>err := errors.New(&quot;Error occured!&quot;)</code>, 返回的是一个<code>type errorString struct</code>类型的错误</p>
</li>
<li>定义自己的error类型: 定义自己的错误Struct类型, 然后实现<code>Error() string</code>方法即可</li>
</ul>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><ul>
<li>defer 后面的表达式在函数退出前执行</li>
<li>一个func可以有多个 defer语句, 函数退出时执行顺序与定义顺序相反</li>
</ul>
<ul>
<li>每个Gorounite 都定义了一个defer struct链表，新增defer结构是在链表头，函数return之前会调用（从链表头到尾）链表里所有的</li>
<li>在加入链表时，就需要先计算出传入defer 函数的参数，参数也存储在defer struct中（？不确定），所以…</li>
<li>如果defer 中对（调用defer的函数的）返回值做了修改，也会影响到返回值（因为<code>return ret</code>不是原子操作，是先赋值再return）</li>
</ul>
<p>@ref</p>
<ul>
<li>理解 Go 语言 defer 关键字的原理 | Go 语言设计与实现：<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/</a></li>
<li>defer关键字 · 深入解析Go：<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a></li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul>
<li>小写开头的成员默认不被序列化</li>
<li>struct tag: <code>json:&quot;var_name&quot;</code> 指定序列化后的变量名</li>
<li>struct tag: <code>json:&quot;var_name,omitempty&quot;</code> 如果成员值为”zero-value”, 序列化将不包括此字段</li>
<li><p>struct tag: <code>json:&quot;-&quot;</code> 序列化时跳过此字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourFirstStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  Mem1 <span class="keyword">string</span>  <span class="string">`json:"variable1"`</span></span><br><span class="line">  Mem2 <span class="keyword">string</span>  <span class="string">`json:"variable2,omitempty"`</span></span><br><span class="line">  Mem3 <span class="keyword">string</span>  <span class="string">`json:"-"`</span></span><br><span class="line">  <span class="comment">// 每个成员没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Type(struct/map 等) → byte[]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice_of_byte, err := json.Marshal(obj)</span><br></pre></td></tr></table></figure>
</li>
<li><p>byte[] → Type</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">obj := <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json_str := <span class="string">`&#123;"Name":"X", "Age": 101&#125;`</span></span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(json_str), &amp;obj)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="时间-API"><a href="#时间-API" class="headerlink" title="时间 API"></a>时间 API</h1><ul>
<li>获取 int64时间戳: <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timestampSec <span class="keyword">int32</span> = time.Now().Unix()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><a href="https://geektutu.com/post/quick-go-test.html" target="_blank" rel="noopener">https://geektutu.com/post/quick-go-test.html</a></p>
<h1 id="go-命令行-amp-环境"><a href="#go-命令行-amp-环境" class="headerlink" title="go-命令行&amp;环境"></a>go-命令行&amp;环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">	go &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">	bug         start a bug report</span><br><span class="line">	build       compile packages and dependencies</span><br><span class="line">	clean       remove object files and cached files</span><br><span class="line">	doc         show documentation for package or symbol</span><br><span class="line">	env         print Go environment information</span><br><span class="line">	fix         update packages to use new APIs</span><br><span class="line">	fmt         gofmt (reformat) package sources</span><br><span class="line">	generate    generate Go files by processing source</span><br><span class="line">	get         add dependencies to current module and install them</span><br><span class="line">	install     compile and install packages and dependencies</span><br><span class="line">	list        list packages or modules</span><br><span class="line">	mod         module maintenance</span><br><span class="line">	run         compile and run Go program</span><br><span class="line">	test        test packages</span><br><span class="line">	tool        run specified go tool</span><br><span class="line">	version     print Go version</span><br><span class="line">	vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Golang/" rel="tag"># Golang</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/11.Programming-Language/C和CPP标准/" rel="next" title="C语言 & C++ 标准">
                <i class="fa fa-chevron-left"></i> C语言 & C++ 标准
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/11.Programming-Language/Golang-Tutorials.02.并发/" rel="prev" title="Golang Tutorials-02并发">
                Golang Tutorials-02并发 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">476</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">410</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang中的约定大于配置"><span class="nav-text">Golang中的约定大于配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Package-amp-Import"><span class="nav-text">Package &amp; Import</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#init"><span class="nav-text">init</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量"><span class="nav-text">变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全局变量"><span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本数据类型"><span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#string"><span class="nav-text">string</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型转换"><span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包"><span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制语句"><span class="nav-text">控制语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#type"><span class="nav-text">type</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#struct"><span class="nav-text">struct</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#interface"><span class="nav-text">interface</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#array"><span class="nav-text">array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice"><span class="nav-text">slice</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#map"><span class="nav-text">map</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#chan"><span class="nav-text">chan</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内置函数-len-append-copy-panic"><span class="nav-text">内置函数(len/append/copy/panic..)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#make"><span class="nav-text">make</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new"><span class="nav-text">new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make-vs-new"><span class="nav-text">make vs new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#panic-amp-recovery"><span class="nav-text">panic &amp; recovery</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#error"><span class="nav-text">error</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defer"><span class="nav-text">defer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化"><span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时间-API"><span class="nav-text">时间 API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单元测试"><span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-命令行-amp-环境"><span class="nav-text">go-命令行&amp;环境</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.基础/';
          this.page.identifier = '11.Programming-Language/Golang-Tutorials.01.基础/';
          this.page.title = 'Golang Tutorials-01基础';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
