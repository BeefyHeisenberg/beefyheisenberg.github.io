<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《存在主义心理治疗》读书笔记</title>
      <link href="/62.Psychology/%E3%80%8A%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/62.Psychology/%E3%80%8A%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E5%BF%83%E7%90%86%E6%B2%BB%E7%96%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《存在主义心理治疗》读书笔记"><a href="#《存在主义心理治疗》读书笔记" class="headerlink" title="《存在主义心理治疗》读书笔记"></a>《存在主义心理治疗》读书笔记</h1><p>欧文·亚隆提出的四个“生命的终极关怀”：<a href="https://www.amazon.com/Existential-Psychotherapy-Irvin-D-Yalom/dp/0465021476" target="_blank" rel="noopener">Existential Psychotherapy - by Irvin D. Yalom</a></p><blockquote><p>Organized around what Yalom identifies as the four <strong>“ultimate concerns of life”</strong> — death, freedom, isolation, and meaninglessness—the book takes up the meaning of each existential concern and the type of conflict that springs from our confrontation with each. He shows how these concerns are manifest in personality and psychopathology, and how treatment can be helped by our knowledge of them.</p></blockquote><h2 id="《导论》"><a href="#《导论》" class="headerlink" title="《导论》"></a>《导论》</h2><p>p6：一种动力性心理治疗<br>个体的心理动力学包括了在其内部运转的多种无意识和意识的力量、动机以及恐惧。<br>如果我们提问，哪些力量（还有恐惧和动机）处于冲突之中？内在意识和无意识之间的斗争的内容是什么？就是在这个关键点上，存在主义治理与其他动力性治疗分道扬镳，关于在个体内部互相作用的驱力、动机和恐惧，存在主义治理有完全不同的观点。</p><hr><p>p7：弗洛伊德派心理动力学<br>个体面临的冲突有多个层面：两种对立的本能（自我本能和力比多，或者后期理论中的叫法，爱欲和死欲<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>）；本能与环境要求的冲突，本能与内化了的环境要求相冲突——也就是与超我冲突。<br>为本能所驱动的个体就这样处于与这个世界的战争之中，因为这个世界阻碍着与生俱来的攻击欲望和性欲望的满足。</p><hr><p>p8：存在主义心理动力学<br>从充斥着我们每个人经验世界的日常琐事中抽离出来，给自己以独处、沉默、时间以及自由。如果我们能够清除或者“囊括”日常生活，如果我们对于自己在世界上的处境，对于我们的存在、我们的界限、我们的潜力进行深刻的反思，如果我们深入到所有层面的最底层，我们必然会面对存在的既定事实，面对“深度结构”，我之后将称之为“终极关怀”。<br>这些反思过程常常为某些紧急体验所催化。这些常被称作“边缘”或者“临界”状态，包括如下体验：面对自己的死亡、面临某些重大不可逆转的决定或者某些深具意义的图式在眼前崩塌。<br><strong>生命的四个终极关怀：死亡、自由、孤独和无意义。个体与这些生命真相的正面交锋，构成了存在主义动力性冲突的内容。</strong></p><ul><li>死亡。斯宾诺莎的话来说：“每一事物都在尽力维持自身是的存在”，而存在的一个核心冲突是，面对死亡必然性的意识与继续生存下去的愿望之间的张力。</li><li>自由。一般来说我们都认为自由是一个毋庸置疑的积极概念。在存在的意义上，自由意味着外部结构的空白，自由在这种含义上，带有一种可怕的暗示：它意味着我们所站立的地方并不坚实——什么都没有，是空的，无底深渊。存在主义一个关键的动力性冲突就是，我们无根基的处境与我们对根基与结构的渴望之间的冲突。</li><li>存在性孤独。无论我们之间变得有多么亲密无间，仍然存在一个最终无法逾越的鸿沟；我们每个人都是独自一人进入这种存在，同时也注定要独自离开。一方面是我们对自身绝对孤独的意识，另一方面是对接触、保护的渴望，以及成为一个更大整体一部分的愿望，存在性冲突就是这两个方面之间的张力。</li><li>无意义。一个人创造出来的意义是否坚强到令其能容忍生活？人类这种寻找意义的生物，却被投入到本身毫无意义的宇宙之中。于是，存在的动力性冲突便从进退维谷的境地中滋生出来。</li></ul><hr><p>p11<br>弗洛伊德的心理动力学是以发展为基础，跟“根本”和“原始”应该按照时间顺序来理解，都是“最初”的同义词。举例来说，焦虑的根本来源被认为是最早的性心理灾难：分离和阉割。<br>存在主义动力学并未执着于发展模型。人们没有理由认为“根本的”和“最初的”是同样的概念。要从存在主义的观点做深层的探索，并不意外着探索过去，而是意味着拂调日常的担忧，深刻的思索个人的存在处境，这意味着跳出时间之外来思索，思索我们的双脚和立足之间的关系，思索我们的意识与周围空间之间的关系，这并非意味着思考我们以何种方式成为现在的样子，而是思考我们到底是什么样子</p><hr><p>p24<br>存在主义在了解人类时，尽力避免采用主体与客体的二分法，存在主义立场挑战了传统的笛卡尔式世界观，后者是由客体和感知这些客体的主体所构成。<br>存在主义越过主体-客体的分割，不把人看作是可以在适当环境下感知外在现实的主体，而将人视为参与构建现实的观察者。<br>海德格总是谈到人类是“此在”（dasein），da意味“那里”，指的是人在那里、是一个被组成的客体（经验自我）这一事实，但此人同时也组成了世界（先验自我），“此在”的人既赋予事物意义，同时又感知这意义。</p><hr><h2 id="第一部《死亡》-todo"><a href="#第一部《死亡》-todo" class="headerlink" title="第一部《死亡》@todo"></a>第一部《死亡》@todo</h2><p>@todo</p><hr><h2 id="第二部《自由》-todo"><a href="#第二部《自由》-todo" class="headerlink" title="第二部《自由》@todo"></a>第二部《自由》@todo</h2><hr><h2 id="第三部《孤独》"><a href="#第三部《孤独》" class="headerlink" title="第三部《孤独》"></a>第三部《孤独》</h2><p>p377<br>…存在孤独被一层又一层世界的加工品所隐藏，每一层都包含了个人和集体的意义。我们只体验到了一个寻常的世界，一个由日常生活和“他们”构成的世界，我们周围是一个由熟悉的事物和制度所构成的稳定世界，一个所有物体和个体都彼此多重连接的世界。我们被平静地诱导入一种熟悉的、亲切的归属感。那极度空旷和孤独的原始世界被无声地深深掩埋了，只有在噩梦或者幻想中才会偶然发出短暂的声音。</p><p>我相信每个有自省能力的个体都会体验到过这样的时刻：一种陌生感浮现出来，所有的意义从事物上剥落，符号彻底瓦解，个体从那“熟悉”的安全锚上脱离，加缪在一篇早期作品中描述过这样的时刻，当时他身处一个陌生国度的酒店房间：</p><p>…</p><blockquote><p>这段可能来自加缪早期作品 [[../64.Novel-and-Poesy/F03.加缪札记]]</p></blockquote><p>p378<br>海德格用“不自在”来指代人失去了在世界中的熟悉感的状态，当人完全专注于表象世界，对自己的存在处境失去接触时，海德格称这个人处于“日常”或者“陷入”的模式里。<br>海德格在《存在与时间》的另一段说过，当人从“对世界的沉溺”中被带回，事物的意义被剥除时，就会因面对世界的孤寂、无情和虚无而焦虑。因此，当我们面对虚无，就会感到终极的恐惧。在面对虚无时，没有什么事或人可以帮助我们，就在这个时刻我们最完整地体验到了存在的孤独。</p><p>熟悉感的丧失不只牵涉具体的事物，其他可以提供结构和稳定性的事物，包括角色、价值观、原则、规则、伦理都可以以类似的方式被剥离其意义。</p><p>p382<br>人如何保护自己远离终极孤独的恐惧呢？人可以接纳一部分孤独，勇敢地（用海德格的话是“毅然地”）承受它，至于剩余的孤独，人会试图放弃单一性，进入与他人的关系中，所以，用以对抗孤独的恐惧的主要力量就是关系。</p><blockquote><p>毅然地承受：海德格的“向死而在”，Being towards death @ref: [[../61.Philosophy/05b.海德格《存在与时间》]]</p></blockquote><p>罗素在自传序言写的《What I have lived for》之一是“对爱情的渴望”，寻求爱情的动机他也写了“因为爱情解除孤寂——那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。”<br>罗素的深渊可能也是描写“存在性孤独”的</p><hr><p>p401 存在孤独与人际心理<br>如果我们无法发展能够让我们面对存在孤独的内心力量、自我价值感、认同感，无法接受事物本来的面貌、接纳焦虑的话，我们就会用间接的方式来寻求安全感。</p><ul><li><p>活在他人眼中。需要别人确认才觉得自己活着的人必然会逃避孤独，完全独自一人会让人太过接近存在孤独带来的焦虑感。</p></li><li><p>融合。人也可以借着与某物融合，比如某个团体、使命、国家、项目，摆脱孤独的自我感。人类的“普世冲突”是人想要成为独立的个体，但成为个体又需要忍受孤独。处理这种冲突的最常见模式是否认：个体先建造融合的幻想，也就是对自己说“我并不孤独，我是他人的一部分”。这样个体弱化了自我的边界，变成了比自己优越的另一个人或群体的一部分。融合以消除自我觉察这种极端的方式消除孤独感。</p></li><li><p>性和孤独。性的诱惑…是抵御对自由的意识和焦虑的强大堡垒，因为我们在性的魔力下，根本意识不到我们建构了自己的世界。…我们不觉得是自己选择或创造了性欲，它好像在我们之外，有着自己的力量，好像“比生活更有力量”</p></li></ul><h2 id="第四部《无意义感》"><a href="#第四部《无意义感》" class="headerlink" title="第四部《无意义感》"></a>第四部《无意义感》</h2><p>p447<br>存在主义理念把世界看作是偶然的，也就是任何事情都可能是另外一副样子。人构成了自身、自己的世界以及在这个世界中自身所处的情境。不存在“意义”。在宇宙中没有宏大的设计，没有指导生活的原则，除非个体自己创造这些原则。<br>因此，最根本的问题变成了：需要意义的个体如何在一个没有意义的世界中找到意义？</p><p>p452 《西西弗神话》<br>加缪用“荒谬”这个词来形容人在世上的基本情境，即寻求超越和意义的人类却生活在一个没有意义的世界中的困境。我们是道德的生灵，我们要求世界提供一个道德评判的基础，也就是一个具有价值蓝图的意义系统。但是世界不能提供这样一个基础，它对我们的期望无动于衷。人类的渴望和世界的冷漠之间的张力构成了加缪所说的“荒谬”的人类处境。</p><p>在更早期的作品《西西弗神话》中，加缪探索了他的虚无主义和伦理要求之间的冲突，并逐步发展出一种全新的、世俗的、人道主义的个人意义观点。他提出我们通过珍爱自己“绝望的深夜”建立新的生命意义，通过直面无意义的“漩涡”达到英勇的虚无主义的姿态。<br>作为个人只有通过有尊严地面对荒谬，才能够获得意义。“没有什么可以媲美人类的尊严”；<br>世界本身的无意义要通过反抗来超越，这是一种对自身处境的高傲反抗 。“蔑视可以征服任何命运”</p><blockquote><p>英勇的虚无主义</p></blockquote><p>p454 《苍蝇》<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup><br>俄瑞斯忒斯脱离了自己过去的意义体系，进入了他自身的无意义危机中——“我原本一直感觉到某种温暖有生命的东西，就像一种友好的存在。这种东西逝去了。多么空虚，无尽的空虚”。<br>在这个时刻，俄瑞斯忒斯在他的生命中做出了和萨特相同的一跃，不是跃入信念，而是跃入“参与”、跃入行动。他告别了追求舒适和安全的理想，以非凡的勇气，开始对新目标的追逐。<br>之后，俄瑞斯忒斯为了反抗宙斯，决定杀死埃癸斯托斯。他那时的宣言显示了明确的目的感，他选择了正义、自由和尊严，他知道生命中什么是“正确的”：</p><blockquote><p>“帮助人民从你邪恶的影响中解脱，这是正当的，让人民恢复作为人的尊严，这是<strong>正确的</strong>事”</p></blockquote><p>为什么要实现这些意义？萨特没有回答这个问题。<br>俄瑞斯忒斯只是简单的说：“我想要归属”；<br>服务他人、恢复人的尊严、拥抱自由“是正确的事情”；<br>每个人<strong>必须</strong>找到自己的路，我必须踏上旅途以便找到正在等候的、完全实现了自我的俄瑞斯忒斯。</p><p>p457<br>..列举一些能够给人提供生活目的感的世俗活动，支持这些活动的理由，也是萨特支持俄瑞斯忒斯的理由。它们看起来是正确的、美好的；它们提供内在的满足，而不需要别的动机来支持：<strong>利他、创造、体验（享乐主义）、自我实现、自我超越</strong></p><p>p463<br>自我实现。另一种个人意义的来源是相信人类必须力争实现自我，人们应该献身于实现自己的潜能。早在公元前4世纪，亚里士多德就提出因果目的观——有关内在定局的学说，他认为每一个物体或生命的真正结果或目的都是成就和实现其自身的存在，因此橡树籽长成橡树实现自己，婴儿则完全长成自我实现的成人<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p><p>马斯洛认为人有着向成长和人格整合的倾向<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>：“人类的构造迫使他走向越来越完全的存在，也就是大多数人所说的美好价值，走向平静、仁慈、勇敢、诚实、爱、无私和善良”。他回答了“我们为什么而活着”的问题，他认为我们活着是为了实现自己的潜能，他也回答了“我们该怎么活”的问题，他认为美好的价值本质上已经存在于个体内心，如果人信任自己的本来智慧，就能够直觉地发现这些价值。</p><p>p465<br>自我超越。前面提到的两种意义（自我实现和享乐），是与自我相关的，而其他几种意义反映出超越自身的利益，为某种外在于或“高于”自己的事务而努力的渴望。<br>西方思想的一个传统是不要暗语非自我超越性的生命意义。布伯<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>提出，人必须追问如下问题：“我寻找适合自己的特殊道路是为了什么？我整合自己的生命是为了什么？答案是：不是为了自我”。个体从自己开始是为了忘记自己，让自己沉浸在世界中。<strong>一个人了解自己是为了不要将全副心神贯注在自己身上</strong>。</p><p>p490<br>意义的意义之一就是降低焦虑，意义的存在能够减轻人在面对缺乏规律和结构的人生和世界时所产生的焦虑。我们需要意义，还有另一个重要的理由，一旦一种意义感产生，价值观也会随之产生，反过来价值观能够强化人的意义感。<br>人类对整体的知觉框架的需要以及对作为行为基础的价值体系的需要，形成了我们寻找生命意义的纯粹理由。但是一般说来，意义相关的问题并不纯粹，其他非意义的问题会附加于其上，从而混淆意义的问题。</p><p>p507<br>退后一步观看生活，但如果这一步迈得过大，就潜在着某种有害的东西。<br>当我们从生活中抽离，成为疏离的旁观者时，所有事情就变得无关紧要。这个位置被哲学家称之为“银河”或者“星云之眼”的视角。从这个位置来看，我们和其他所有的生物变得渺小而愚蠢，我们只是无数生命形态的一种。生命中的种种行为变得荒谬。那丰富、充满体验的片刻在时间的无限延展中变得微不足道。我们感到自己是渺小的尘埃，生命的全部也不过是弹指一挥。<br>这种宇宙视角使治疗师面临一个难以处理的问题，一方面，他的逻辑无懈可击。自我观察、跳出自身视角、从远处看自己的能力是人类最有价值的特质之一。人之所以为人正因为如此。在绝大多数情况下，一个更广阔和全面的视角通常能让观察者更客观，但另一方面这个视角又让生命的活力枯竭。<br>哲学的悲观主义传统，就是这种宇宙观点的衍生物。难怪叔本华的结论是：“没有任何事情值得我们去努力、付出和奋斗…所有美好的事情都是虚幻，世界终结了，破产了，仿佛一场无法支付起自身开销的生意”<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>。</p><p>首先，宇宙视角必然会导致叔本华所说的“没有什么真正重要，因而生命不值得一活”的观点，这其中的逻辑实际站不住脚，<strong>如果没什么真正重要，那么“没什么真正重要”也并不重要。</strong><br>纳戈尔<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>认为，采用宇宙视角，是人类最高等的、最珍贵的、最有趣的特质，它并不会让我们痛苦，除非我们自己造成痛苦。让宇宙视角对我们产生如此沉重的影响，暴露了我们不能够真正意识到这种视角本身并不重要的现实。纳戈尔指出，我们必须真正理解宇宙视角，同时必须了解采用这种视角是人类的长处，这样我才能重新回归荒的、充满反讽的生活之中，而不是陷入绝望。<br>凡事“无关紧要”的宇宙视角所带来的绝望下实际掩藏的是“至关重要”。例如叔本华认为没有任何事情是重要的，可许多事情对他来说是很重要的，譬如说服别人相信没有任何事情是重要的，反对黑格尔的思想体系，积极写作直到生命结束，从事哲学思考而不是自杀。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>维基百科上的<a href="https://en.wikipedia.org/wiki/Existential_therapy" target="_blank" rel="noopener">Existential therapy</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">弗洛伊德相信人类由互相冲突的两种欲望所驱动：爱欲（生存本能）与死欲（死亡本能）。弗洛伊德所说的爱欲，包含所有创造性、及产生生命的驱力。死欲代表一切有生之物内在的冲动，欲回归至平静状态，甚至最终回到不再存在。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">《苍蝇》（1943）是萨特根据古希腊神话故事改编的一部存在主义悲剧。作者借用这出浓郁的古代神话悲剧的诗意，艺术地破除了人对自然之谜的惶惑感，传递出人能战胜“上帝”，自由选择生活道路的现代意识。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">实现性原理 Principle of Actuality，是亚里士多德哲学的重要思想 <a href="https://terms.naer.edu.tw/detail/1313066/" target="_blank" rel="noopener">https://terms.naer.edu.tw/detail/1313066/</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">马斯洛：《动机与人格》</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zh.m.wikipedia.org/zh-hans/%E9%A9%AC%E4%B8%81%C2%B7%E5%B8%83%E4%BC%AF" target="_blank" rel="noopener">马丁·布伯</a> （Martin Buber，1878年2月8日－1965年6月13日）</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">A. Schopenhauer，cited in The Encyclopedia of Philosophy，Vol IV，ed. Paul Edwards (1923–2004)</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">T. Nagel，Mortal Questions</span><a href="#fnref:7" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
            <tag> 存在主义 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MBTI</title>
      <link href="/62.Psychology/MBTI%E7%AC%94%E8%AE%B0/"/>
      <url>/62.Psychology/MBTI%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在人格类型学中，迈尔斯-布里格斯性格分类指标（英语：Myers-Briggs Type Indicator，简称MBTI）是一种内省的自我报告问卷，表明人们在如何看待世界和做出决定方面存在不同的心理偏好。该测试尝试分配四个类别：内向（Introversion）或外向（Extroversion）、实感（Sensing）或直觉（Intuition）、思考（Thinking）或情感（Feeling）、判断（Judging）或感知（Perceiving）。取各类别的首字母来组成测试结果之类别名称，如“INFJ”或“ENFP”</p></blockquote><h1 id="MBTI的起源和发展"><a href="#MBTI的起源和发展" class="headerlink" title="MBTI的起源和发展"></a>MBTI的起源和发展</h1><p>阶段：</p><p>(1) 荣格: 《心理类型》, 《心理学》</p><p>(2) MBTI: 也即迈尔斯-布里格斯性格分类法, （英语：Myers-Briggs Type Indicator，简称MBTI）是性格分类理论模型的一种，其基本理论是根据瑞士心理分析家卡尔·荣格于1921年所出版的书籍《心理类型》。最先的研究者是美国心理学家凯瑟琳·布里格斯及其女儿伊莎贝尔·迈尔斯。 虽然在商界流行，但心理学界认为MBTI理论有缺陷，测量结果不可靠，而且同一个人不同时候测量的结果也不同。并指出这是巴纳姆效应的例子[4]。相比之下，五大性格特质是更好的性格测度工具。</p><p>(3) 凯西尔气质:<br>以下是柯尔塞（David West Keirsey）创立的柯尔塞气质分类法中，各种MBTI型态所对应的心理学原型，总共有四种“气质”：</p><ul><li>NT - 理性者</li><li>NF - 理想主义者</li><li>SP - 工匠</li><li>SJ - 监护人</li></ul><p>(4) 现代 心理测试/sns app …</p><ul><li>16Personality:</li><li>Soul : 星球</li></ul><h1 id="MBTI模型-四个维度"><a href="#MBTI模型-四个维度" class="headerlink" title="MBTI模型(四个维度)"></a>MBTI模型(四个维度)</h1><p><img src="/images/20220228103702.png" alt=""></p><p>➤ “外向”与“内向”: 发泄及获得心灵能量的方向。</p><ul><li>外向型（E，Extroverts）偏向专注于外在的人和事，倾向将能量往外释放。</li><li>内向型（I，Introverts）则专注于自己的思想、想法及印象，倾向将能量流往内。</li></ul><p>➤ “实感”与“直觉”: 是人们认识世界的非理性方法，即外界知觉，所说的是人们如何处理接收到的资料。</p><ul><li>实感型（S，Sensing）喜欢着眼于当前事物，惯于先使用五感来感受世界。</li><li>直觉型（N，Intuition）则着眼未来，着重可能性及预感，从潜意识及事物间的关联来理解世界。</li></ul><blockquote><p>私下里直觉N型的人认为感觉S型的人为世俗所束缚又缺乏想像力，而感觉型的人觉得直觉型的人不切实际 &amp; 太冲动</p></blockquote><p>➤ “情感”与“思考”: 情感及思考是下决定时内心挣扎所侧重的方向，并配合以上的能量走向。</p><ul><li>情感型（F，Feeling）偏好使用价值观及自我中心的主观评价来作决定。</li><li>思考型（T，Thinking）则偏好用“是－非”及“如果…就”的逻辑来作分析结果及影响，或者作决定。</li></ul><p>➤ “判断”与“感知”: 世界观及生活模式</p><ul><li>判断型（J，Judging）倾向于以结构化的方式认识世界，井然有序及有组织的生活，而且喜欢安顿一切事物。</li><li>感知型（P，Perceiving）则倾向于以非结构化的方式认识世界，始终开放选择机会，自然发生及弹性的生活。</li></ul><blockquote><p>要注意的是，判断（Judging）并不等同决断（Judgmental，包含主观及冲动的意思），而感知（Perceiving）亦不解作知觉（Perceptive，指对感觉作出反应的程度）。<br>判断型人(J)比知觉型人(P)更专注，而且更加容易接受一件事的终止。</p></blockquote><blockquote><p>J主导的人很少会错过截止日期或者约会迟到。知觉型人更加乐天，通常会同时进行好几个项目，对于截止日期也会随便一点。<br>当在做重大决策比如买车时，知觉型人更享受收集信息，对比商品的部分，但是一旦做出决定又会有点不安心－担心是否需要做更多的调查。判断型的人则会更高兴车已经买了和款也付了。</p></blockquote><h2 id="有关16personalities-模型中的-A-amp-T"><a href="#有关16personalities-模型中的-A-amp-T" class="headerlink" title="有关16personalities 模型中的 A &amp; T"></a>有关16personalities 模型中的 A &amp; T</h2><p>来自 <a href="https://www.16personalities.com/ch/%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">https://www.16personalities.com/ch/%E6%A8%A1%E5%9E%8B</a></p><ul><li>坚决型的人情绪稳定，冷静，放松，不会过度忧虑。（-A，意Assertive）</li><li>动荡型的人容易难为情，在乎形象，追求成功，完美主义。（-T，意Turbulent）</li></ul><blockquote><p>Our last scale, Identity, affects all others, showing how confident we are in our abilities and decisions. In a way, it acts as an internal sensor, reacting to the input we get from the environment – for instance, success or failure, feedback from other people, pressure caused by unexpected events and so on. Mind and Identity scales are the alpha and the omega of our model, acting like an external shell that we wear in all our interactions with the outside world – we discuss all four possible combinations of these traits in the “Strategies” section of our main theoretical article, but in this one, let’s take a look at what the Identity scale looks like.</p></blockquote><blockquote><p>Assertive (-A) individuals are self-assured, even-tempered and resistant to stress. They refuse to worry too much and do not push themselves too hard when it comes to achieving goals. Similarly, they are unlikely to spend much time thinking about their past actions or choices – according to Assertive types, what’s done is done and there is little point in analyzing it. Not surprisingly, people with this trait report more satisfaction with their lives and they also feel more confident in their abilities to handle challenging and unexpected situations.</p></blockquote><blockquote><p>In contrast, individuals with Turbulent (-T) identity are self-conscious and sensitive to stress. They experience a wide range of emotions and tend to be success-driven, perfectionistic and eager to improve. They are also more willing to change jobs if they feel stuck in their current one and to spend time thinking about the direction in which their life is going.</p></blockquote><blockquote><p>However, while the Assertive variant may seem more positive on the surface, that is not always the case – for instance, Turbulent individuals perform better in certain roles as they push themselves to achieve superior results, while Assertive ones do not care about the outcome that much. Always feeling the need to do more, to have more, and to be more, Turbulent types often forget how exhausting that can be to both themselves and the people around them – but it is entirely possible that this desire to always push themselves just a little further helps many Turbulent types to achieve what they seek to achieve.</p></blockquote><p>策略:<br>策略层显示我们做事和实现目标时所倾向的方式。共有四种策略：</p><p>自信独立者（内向型和坚定型 [I___-A]型）:<br>自信的个人主义者喜欢独自做事，与请教别人相比会选择相信自己的技能和直觉。他们知道自己擅长什么并非常自信。这些人格类型者认为责任和自信是非常重要的价值。他们不太在意别人的意见而更喜欢依靠自己。</p><p>掌控旁人者（外向型和坚定型 [E___-A]型）:<br>掌控旁人者们喜欢社会交往，常拥有高超的交流技巧，在社会活动中和需要依赖或指挥他人的情况下如鱼得水，这种类型的人对自己的能力很自信，表达观点时从不犹豫。在社会中扮演积极角色，能够驾驭他人对他们来说很重要。然而他们不大在乎别人对自己的看法。</p><p>不断进取者（内向型和动荡型 [I___-T]型）:<br>不断进取者是安静而独立的人们。他们完美主义追求成功，常常花很多时间和努力来确保工作结果尽善尽美。人如其名，不断进取者的奉献精神让他们成绩突出，然而他们常对自己的表现过分忧虑。</p><p>社会交往者（外向型和动荡型 [E___-T]型）:<br>最后一种策略被善于社交，精力充沛，追求成功的人所运用。社交活动者们停不下来，完美主义，感情容易大起大落。他们的好奇和努力工作的心态通常会使他们成绩突出，其中很敏感的人也不例外。运用这种策略的人格类型通常非常在意别人的看法；他们重视社会地位，无论做什么都想成功。</p><h2 id="INFJ-T-vs-INFJ-A"><a href="#INFJ-T-vs-INFJ-A" class="headerlink" title="INFJ-T vs INFJ-A"></a>INFJ-T vs INFJ-A</h2><p>问题：对于Fe作为主要功能的类型（ENFJ、INFJ）-Assertive，如何做到”他们不太在意别人的意见”的？</p><p>匆忙的机翻：<a href="/62.Psychology/INFJ-T-vs-INFJ-A/" title="INFJ-T-vs-INFJ-A">INFJ-T-vs-INFJ-A</a></p><h1 id="16种类型"><a href="#16种类型" class="headerlink" title="16种类型"></a>16种类型</h1><p><img src="/images/20220228103212.png" alt=""></p><p><img src="/images/20220315093333.png" alt=""></p><h2 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h2><p>@ref:</p><ul><li><a href="https://www.douban.com/note/485946729/" target="_blank" rel="noopener">内倾思考Ti</a></li><li><a href="https://www.douban.com/note/486424042/" target="_blank" rel="noopener">内倾直觉Ni</a></li><li><a href="https://www.douban.com/note/483226913/" target="_blank" rel="noopener">如何去爱一个INFJ</a></li><li><a href="https://www.douban.com/note/507538827/" target="_blank" rel="noopener">你是否因为自己的人格类型而产生偏见</a></li><li><a href="https://www.douban.com/note/461074194/" target="_blank" rel="noopener">如何操纵，哦不对，吸引不同类型的人（潘多拉魔盒打开了）</a></li><li><a href="https://www.douban.com/note/459576473/" target="_blank" rel="noopener">给16种人格的一句话建议</a></li><li><a href="https://www.douban.com/note/446420628/" target="_blank" rel="noopener">国外对16种人格的Stereotype（毒舌版）</a></li></ul><h2 id="类型成长阶段和功能类型"><a href="#类型成长阶段和功能类型" class="headerlink" title="类型成长阶段和功能类型"></a>类型成长阶段和功能类型</h2><p><a href="https://www.douban.com/note/665729881/?\_i=6016141VuwWSYh" target="_blank" rel="noopener">INFJ的人格成长阶段与功能类型</a></p><blockquote><p>在面对自己时，INFJ也是完美主义者。甚至他们对自己会比对别人要严苛得多，他们的Fe功能使得他们更愿意去原谅别人的过错和缺点。但由于他们认为自己是“知道得更多”的人，所以没办法对自己给予同样的宽厚。他们会认为，如果他们自己不能完美地展示他们的道德理想，那么他们又怎能合理去期望他人呢？就像耶稣所说的那样：“凡被给予的人，都将被要求；凡被委以重任的人，会有更多的要求。”</p></blockquote><p>豆瓣防404传送门:</p><ul><li><a href="https://rina92.lofter.com/post/1dc5c993_fbe42c8" target="_blank" rel="noopener">MBTI人格系列翻译整理①—— INFJ圣人型-Rina’s</a></li><li><a href="https://rina92.lofter.com/post/1dc5c993_fbf9693#" target="_blank" rel="noopener">MBTI人格系列翻译整理②—— INTJ专家型-Rina’s</a></li><li><a href="https://rina92.lofter.com/post/1dc5c993_1000ef75#" target="_blank" rel="noopener">MBTI人格系列翻译整理④—— INFP哲学家型-Rina’s</a></li><li><a href="https://rina92.lofter.com/post/1dc5c993_12bd665e#" target="_blank" rel="noopener">MBTI人格系列翻译整理⑦—— INTP学者型-Rina’s</a></li><li><a href="https://rina92.lofter.com/post/1dc5c993_12d725db" target="_blank" rel="noopener">MBTI人格系列翻译整理⑧—— ENTP发明家型-Rina’s</a></li></ul><h1 id="认知功能表"><a href="#认知功能表" class="headerlink" title="认知功能表"></a>认知功能表</h1><p><img src="/images/20220228103258.png" alt=""></p><p>以下参考<a href="https://www.douban.com/note/449995495/" target="_blank" rel="noopener">MBTI八种功能对人格的影响 - Yoli Inés - 豆瓣</a></p><p>人格类型的阳面我们首要运用的四种功能。不同的功能会在我们生命中的不同阶段出现与发展。在不同的阶段，我们会更活跃地应用对应的功能，并发现可以几乎毫不费力地应用它。我们会发现自己的兴趣逐渐转移，从过去吸引我们的事物上移开。</p><ol><li>主角（主导功能）－主导功能通常是我们在童年期即已发展出的功能。我们会倾向于首先运用它，指望它来解决我们的问题，帮助我们成功。这是我们最值得信赖和最常使用的功能，通常是相当成熟完善的。</li><li>配角（辅助功能）－辅助功能帮助我们自身的作用正如我们帮助他人。一旦我们能够熟练地运用主导功能，让作为配角的辅助功能来发挥作用会让我们更感舒适。当主导功能内倾时，外倾的辅助功能是我们与外界打交道的方式，会是活跃而易于被觉察的。</li><li>替补队员（第三功能）－替补队员为我们提供了恢复自我的途径。是配角的替补，并经常与配角共同协作。在我们年轻时，若不是情非得已，配角不能很好地完成任务，可能并不会有力地运用它。第三功能通常是我们发挥创造力的途径，会在我们像孩童般嬉戏时出现。在最糟的情况下，它稳定性不佳，会令我们自己与其他人偏离常轨。</li><li>龙套演员（劣势功能或第四功能）－龙套演员通常在我们中年以前并未发展。我们通常是先遇到它在跟我们捣乱，作为我们的内心的命令、恐惧及其他负面情绪出现。此类恐惧是劣势功能在发挥作用的体现，而我们常常在此时并不会成熟地去对待它。在龙套演员登场时，我们常常要投入相当多的精力——即使是在我们掌握了调配它的技能以后。一旦我们学会去信赖并发展它，龙套演员能够成为平衡我们生活的桥梁，连通我们的目标、灵感、理想。</li></ol><p>剩下的四种功能，处在我们意识的边缘，常常隐身在黑暗中，不会主动出现。它们常常会带给我们负面影响，然而，若我们愿意，同样可以将它们纳入觉知中，发挥它们的积极作用。</p><ol><li>对手（第五功能，Ne）－对手通常是让我们感到棘手的——无论何事发生，都拒绝“加入”我方阵营。我们或许可以通过有意让它上场来发展它，但通常可能并不会给它太多的戏份，要让它发挥自如也得投入我们更多的精力。从积极方面来讲，对手是主角的影子，它的存在是对主角的丰富，帮助我们更持久地追求目标。</li><li>批评家（第六功能，Fi）－批评家使我们能够找出弱点，打压别人。当别人运用它来对付我们时，我们就知道它是咋起作用的了。这一位常常在我们遭遇重大危机、顶着极大压力时，才登台表演。若我们愿意，可以让它继续留在台上。若要发挥它的积极作用，我们必须学会欣赏它，留一席之地给它。如此，它会拥有神奇的品质，带给我们深刻的智慧洞见。</li><li>骗子（第七功能，Te）－ 骗子会愚弄我们，让我们以为某些事情是重要的或值得关注的。它的意见通常被认为是不可信或不值得被关注的，若我们当真了，倒是会形成错觉或做出错误的决定。此时我们会发现自己陷入两难境地，左右皆非。尽管如此，它也有积极面，能以滑稽来助我们减压，教我们自嘲。如此，它可以为我们服务，在我们恢复精力时发挥作用。</li><li>魔鬼（第八功能，Si）－魔鬼通常不干好事儿。当它出现时，可能会让我们自毁毁人。受它影响作出的行动（或不作为）往往会令我们事后悔恨。通常，我们并不知道如何有意使用它，感觉它多半是在我们毫无觉察的情况下突然爆发的。话虽这么说，若我们心胸够宽广，魔鬼也可以改变阵营，倒戈投诚。这时它会成为有创造性的力量，带来新生——恰似将柠檬榨成柠檬汁，使我们不必抱怨柠檬的酸涩。</li></ol><h1 id="兼容关系"><a href="#兼容关系" class="headerlink" title="兼容关系"></a>兼容关系</h1><p>=&gt; <a href="/62.Psychology/MBTI各种类型兼容关系/" title="MBTI各种类型兼容关系">MBTI各种类型兼容关系</a></p><h1 id="批评与争议"><a href="#批评与争议" class="headerlink" title="批评与争议"></a>批评与争议</h1><p>MBTI在业界和网络心理测验中非常流行，但在心理学界饱受批评，现在学界已不使用，心理测量专家罗伯特‧霍根（Robert Hogan）说“大多数人格心理学家把MBTI视为比较复杂的幸运饼干”。MBTI存在的问题包括：</p><ul><li>性格偏好与职业的关联性<ul><li>没有证据指出特定性格的人适合从事特定的职业。</li></ul></li><li>二分法的问题<ul><li>分类中两极的性格应为互斥（不为互斥）但有时却是独立的（例如“理性”和“情感”可以并存），而不同轴向的性格应该独立，有时却有相关（例如“理解”和“情感”都有助于观察别人的情绪）。(思维过程本身就是个各种感觉混合的认知功能表过程，参考认知功能表，这个没问题)</li></ul></li><li>用语<ul><li>MBTI 的用语被批评为“很模糊和笼统”，任何行为都可以放到任何一种人格里而“放诸四海皆准”，故 MBTI 类型的描述为“巴纳姆效应”。</li><li>但有相反观点认为，各个 MBTI 类型的描述都是独特而准确阐释其大概的意思。 在上述基础下，创造凯尔西气质分类法的大卫·凯尔西将 MBTI 类型的定义延伸，加上了“气质”的分类从而细分 MBTI 类型在“语文应用”“知识领域”“教育范畴”等等的分别。</li></ul></li><li>缺乏客观性<ul><li>MBTI 学说的准确性完全依赖参与者为内省的自我报告评估提供诚实而且客观的答案，社会期望或过于夸张的反应会影响其准确度。比如如果测试者害怕评估结果会为其带来损失，测试者会倾向提供符合测试者期望而非基于个人意愿的选择。</li></ul></li></ul><hr><p>虽然 MBTI 类似于一些心理学理论，但它被批评为伪科学，并没有在有关学术研究领域获广泛承认。该指标显示出重大的科学（心理统计学）缺陷，主要包括：</p><ul><li>测验效度不理想（即没有测量到其测量目标，没有预测能力或没有可以概括的项目）；</li><li>信度不理想（同一个人在不同情境下获得不同结果）；</li><li>测量不独立的类别（已注意到一些二分特征相互关联）；</li><li>不全面（由于缺少神经质）</li></ul><p>MBTI 中使用的四个量表，与五大性格特质（<a href="/62.Psychology/BigFive/" title="BigFive">BigFive</a>）之中的四个有一定的相关性，后者更为不同领域普遍接受。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>@ref</p><ul><li><a href="https://en.wikipedia.org/wiki/Myers%E2%80%93Briggs_Type_Indicator" target="_blank" rel="noopener">Myers–Briggs Type Indicator - Wikipedia</a></li><li><a href="https://zh.wikipedia.org/wiki/邁爾斯-布里格斯性格分類法" target="_blank" rel="noopener">迈尔斯-布里格斯性格分类法 - 维基百科，自由的百科全书</a></li><li><a href="https://www.zhihu.com/question/20093985" target="_blank" rel="noopener">心理学学术界是怎样看待 MBTI 的？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/265530555" target="_blank" rel="noopener">谁能介绍一下mbti中的一三功能循环？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/418770172/answer/1449252330" target="_blank" rel="noopener">mbti各类型通常有哪些气质（给他人的第一印象）？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/393366148/answer/1452603058" target="_blank" rel="noopener">在现实生活中最不受欢迎、评价最低的mbti类型是什么？ - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> MBTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/52.Financing/F19a.2022-%E8%A1%8C%E6%83%85%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/52.Financing/F19a.2022-%E8%A1%8C%E6%83%85%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="行情备忘录"><a href="#行情备忘录" class="headerlink" title="行情备忘录"></a>行情备忘录</h1><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><ul><li>2.18美团闪崩：2月18日港股尾盘时候，FGW等14部门为了疫情后服务业恢复情况，决定倡导外卖等互联网平台降低商户服务费</li><li>2.21  传游戏公司2022年不新发版号，港股游戏概念股集体重挫：哔哩哔哩跌超9%，快手跌7%，腾讯跌超5%</li><li>2.24 阿里巴巴第三季度净利润同比下降 75%；</li><li>2.24 俄罗斯入侵乌克兰</li><li>3.2 G7和欧盟将俄罗斯七家银行踢出SWIFT国际结算系统</li><li>Apple停止在俄所有产品销售，暂停部分银行使用apple pay（fb禁止俄媒体投放广告，谷歌宣布 Google Pay 在俄罗斯无限期暂停使用；英特尔、戴尔、AMD 宣布向俄罗斯断供芯片、Oracle 表示已经暂停了在俄罗斯的所有业务 ）<a href="https://mp.weixin.qq.com/s/AppsO7pLGZobErc13IOeJw" target="_blank" rel="noopener">infq</a></li><li>2.28美国冻结俄罗斯央行海外资产</li><li>3.12 电子烟的口味方面禁止除烟草口味外的其他口味，雾化添加剂由122项减少至101项。然后美股雾芯科技开盘跌了40%</li><li>3.14 网曝阿里、腾讯裁员，PCG/CSIG裁员比例最高</li><li>3月14日，港股持续下挫。恒生指数盘中重挫逾1000点，跌超5%；恒生科技指数加速下跌，跌幅超11%，创下该指数最大单日跌幅纪录。其中港股互联网板块跌幅居前。北向资金一共流出 363亿 // 2月中旬以来，港股和中概ADR市场的大幅波动主要是投资者负面情绪的集中发酵所导致。美国SEC首次将五家中概企业列入“预摘牌清单”，这加剧了俄乌冲突、海外货币政策收紧等背景下的恐慌情绪。而3月16日我国金稳会上政策的积极指引又显著提振了投资者风险偏好。</li><li>3月16日，在国务院金融委专题会议召开后，证监会党委迅速召开扩大会议传达学习会议精神。证监会继续加强与美方监管机构的沟通，争取尽快就中美审计监管合作达成协议。抓紧推动企业境外上市监管新规落地，支持各类符合条件的企业到境外上市，保持境外上市渠道畅通。贝壳涨近60%，知乎、滴滴涨超40%，拼多多、爱奇艺涨超38%，阿里巴巴、京东、网易、百度均涨超20%。 //在美联储公布加息25个基点后，美股涨幅一度回落，随后大幅飙涨，上演深V反转，纳指涨势最猛，单日暴涨3.77%。美股纳指涨幅一度扩大至3%，标普500指数涨1.91%，道指涨1.06%。<ul><li>4.25: 上证指数跌破3000，综合原因：上海+北京疫情反复、俄乌冲突、美国通胀美联储5月加息未定、中美国债利差倒挂、中概ADR预摘牌名单</li></ul></li></ul><h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><ul><li>2021.4.10  阿里巴巴因滥用市场支配地位行为，被处182.28亿元巨额罚款</li><li>2021.7.24 双减政策落地，教培机构陷入倒闭潮 </li><li>2021.8.4 段永平抄底腾讯</li><li>2021.10 美团因“二选一”，涉嫌垄断行为被罚34.42亿元</li><li>2021.10 近日，查理·芒格旗下公司Daily Journal Corporation公布的第三季度13-F文件显示，该公司又购买了136740股阿里巴巴股票，使其股票总数达到302060股。<a href="https://finance.sina.com.cn/stock/hkstock/ggscyd/2021-10-07/doc-iktzqtyu0072135.shtml" target="_blank" rel="noopener">https://finance.sina.com.cn/stock/hkstock/ggscyd/2021-10-07/doc-iktzqtyu0072135.shtml</a> 10月7日，阿里巴巴率领一众互联网概念股大反弹。截至发稿，港股阿里巴巴大涨5.9%，报145.4港元。</li><li>2021.11 正式施行的《个人信息保护法》，该法律明确要求互联网平台不得有过度收集个人信息、大数据杀熟等行为。</li><li>2021.12.3 恒大债务危机：恒大集团在香港联交所发布无法履行2.6亿美元担保责任的公告，鉴于目前的流动性情况</li><li>2021.12.14 国家市场监管总局对腾讯、阿里、百度依法作出处罚</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PKM.00.个人知识管理-索引</title>
      <link href="/51.Productivity/PKM.00.Index/"/>
      <url>/51.Productivity/PKM.00.Index/</url>
      
        <content type="html"><![CDATA[<p>相关笔记：Meditations / Thinking-知识管理</p><p>@tag: #_Index</p><hr><h1 id="开始：PKM-的定义，包括什么"><a href="#开始：PKM-的定义，包括什么" class="headerlink" title="开始：PKM 的定义，包括什么"></a>开始：PKM 的定义，包括什么</h1><p>中文wiki <a href="https://zh.m.wikipedia.org/zh-hans/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">个人知识管理 - 维基百科，自由的百科全书</a></p><p>个人知识管理（英语：Personal Knowledge Management，简称PKM）是指个人对知识的搜集、分类、存储、索引等一系列过程。通过这个过程实现对个人行动更好的指引。个人知识管理反映了知识工作者对于个人学习和成长的诉求，属于信息学、知识管理的范畴。</p><p>搜索引擎出现之后，知识的本体记忆变得不那么重要，而快速搜集资料并内化学习的能力越来越成为学习者的重要技能，这种技能就属于个人知识管理（PKM）。</p><hr><p>英文wiki <a href="https://en.wikipedia.org/wiki/Personal_knowledge_management" target="_blank" rel="noopener">个人知识管理 - 维基百科</a></p><ul><li>个人知识管理( PKM ) 是一个收集信息的过程，人们在日常活动中使用这些信息来 “gather, classify, store, search, retrieve and share” （收集、分类、存储、搜索、检索和共享知识）( Grundspenkis 2007 ) 以及这些过程支持工作活动的方式 ( Wright 2005）。这是对知识工作者需要对自己的成长和学习负责的想法的回应（Smedley 2009）。它是一种自下而上的知识管理(KM) 方法（Pollard 2008）。</li><li>目前尚不清楚 PKM 是否仅仅是围绕个人信息管理(PIM) 的新包装。</li></ul><h1 id="01工作流"><a href="#01工作流" class="headerlink" title="01工作流"></a>01工作流</h1><p>施工中 // 下面要写的注意区分“写作”和“学习”，二者可能有不同的工作流</p><ul><li>开始<ul><li>Read it Later （Cubox，Safari的”阅读列表”，Pocket(已经很少使用)，甚至微信的群聊）</li><li>闪念笔记 （Drafts）</li></ul></li><li>处理<ul><li>阅读&amp;学习 （SQ3R）</li><li>初步笔记 （Inbox）</li></ul></li><li>知识回顾和内化  =&gt; 永久笔记 （Obsidian）</li></ul><h1 id="02笔记系统"><a href="#02笔记系统" class="headerlink" title="02笔记系统"></a>02笔记系统</h1><p>=&gt; @ref: <a href="/51.Productivity/PKM.01.我的笔记系统实践/" title="PKM.01.我的笔记系统实践">PKM.01.我的笔记系统实践</a></p><h1 id="03学习法"><a href="#03学习法" class="headerlink" title="03学习法"></a>03学习法</h1><p>学习方法： 研究如何将知识内化的方法论，费曼学习法/SQ3R/SQ5R…</p><p>=&gt; @ref: <a href="/51.Productivity/高效学习法/" title="高效学习法">高效学习法</a></p><h1 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h1><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part.1"></a>Part.1</h2><p>已整理至 [[PKM.01.我的笔记系统实践.md]]</p><hr><p>我在用的解决方案:</p><ul><li>笔记: 一句话概括，基于本地Markdown + 网盘同步，编辑使用VsCode/Atom/Sublime/Typora<ul><li>优点:<ul><li>数据完全属于自己，不用担心产品停止运营(经营不善)，退出中国市场(Google/Yahoo)</li><li>基于本地文件，很方便的使用网盘(Dropbox &gt; 坚果云 &gt; iCloud)同步</li><li>基于本地文件，很方便的使用Git同步，以及发布到支持Git Page的博客(Hexo等)</li><li>支持多种格式的导出，使用pandoc导出为各种格式(PDF/DOC/HTML等)</li><li>综上，「一处写作，多处发布」</li><li>打开的自由度: 比如在Chrome 里阅读，和网页没什么不同，网页打开的优点是 对于一个长网页，浏览器可以打开两个完全一样的窗口，但很多笔记App不支持同一篇笔记在两个窗口打开</li><li>使用专业文本编辑器(VsCode..)的强大功能 // 正则搜索,多行编辑,”Symbol”搜索</li><li>或者使用Typora这类支持“WYSIWYG”所见即所得、注重书写体验的编辑器</li><li>对于双链功能的支持，使用Obsidian打开笔记目录即可 (因为Mkd的表达能力，双链的最小支持单位，一般叫做”Block”，只支持文件级和”#”标题级)</li></ul></li><li>缺点:<ul><li>Markdown表达能力的不足，不支持复杂一点的排版(例如OneNote..)</li><li>笔记无法记录复杂一些的metadata（创建时间、修改时间、创建地点等），不过可以通过YAML Header解决</li><li>基于网盘 or git同步，没有现成的移动端App，解决方案如下:<ul><li>基于Git: WorkingCopy</li><li>基于Dropbox: Editorial，1Writer，Mweb</li><li>基于iCloud: 直接使用 iA Writer..等即可</li><li>基于坚果云: 直接使用坚果云网盘的Mkd预览功能</li></ul></li></ul></li></ul></li></ul><p>笔记原则:</p><ul><li>每篇笔记做到“原子化”，即每篇笔记阐述明白一个问题。如果写作过程中，发现笔记越写越大，</li><li>笔记的Link“克制化”，只有「笔记A」真的需要引用到「笔记B」的时候才建立两篇笔记的连接，胡乱建立双链是在毁掉自己的笔记系统（Obsidian-find-unlinked-files这种插件就是多余的）</li><li>笔记还是传统的文件夹进行分类，每个文件夹是一个“一级分类”，比如哲学、心理学、文化艺术、健康等……</li><li>规定“一级分类文件夹”下面不能再有子文件夹。不使用过深的文件夹也不必纠结分类的层级，因为层级过深的笔记会被遗忘</li><li>文件的命名，使用<code>二级类别-三级标题-笔记标题</code>的格式，当然这么多层级不是必须的。这样命名的好处是，只要按文件名排序，笔记就自动“聚类”排列了。另一个实际操作的便利是，在VSCode里按下<code>cmd+p</code> （文件名模糊搜索），我可以输入二级标题就可以列出相关的笔记，输入三级标题同样</li><li>当对一个领域的知识了解更加全面时，原来一个“一级分类”的文件夹不够用了，需要更细的分类。我的做法是，拆分。例如原来一个文件夹叫“亿级流量架构设计”，随着笔记类别的增多，这个文件夹分成两个更细粒度的文件夹“缓存设计”和“消息队列”，原来的“亿级流量架构设计”文件夹就没了，保证“库跟目录-分类目录-mkd文件”这种单层文件夹结构</li><li>笔记内的<code>#</code>标题也提供了一种层级，我只在永久笔记（Permanent notes）里使用<code>#</code>，这样的一个方便之处是，VSCode、Atom会把 mkd的标题解析为 Symbol，按下<code>cmd+T</code>（VSCode） 或者 <code>cmd+R</code>（Atom）可以在整个库模糊搜索 mkd的标题<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li><li>标签：用的时候也要克制，原则是“标签”的范围必须小于“文件夹”，例如“哲学”文件夹下面的 mkd文件，tag可以是“欧陆哲学”、“存在主义”等等，但不允许再出现“哲学”这个标签… 很多人的笔记系统用不好标签是因为没有提前规划，导致各种层级的标签都有。做个比喻，一个笔记库是一棵树的话，一级分类文件夹是主要枝干，一篇笔记是细小的枝干，Tag只能用来标记树叶，而不能标记枝干</li></ul><hr><p>@tag: #PKM #知识管理</p>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>About-Scriptorium</title>
      <link href="/About/About-Scriptorium/"/>
      <url>/About/About-Scriptorium/</url>
      
        <content type="html"><![CDATA[<h2 id="缮写室"><a href="#缮写室" class="headerlink" title="缮写室"></a>缮写室</h2><p><img src="/images/about-scriptorium.png" alt=""></p><h2 id="黄金诗篇"><a href="#黄金诗篇" class="headerlink" title="黄金诗篇"></a>黄金诗篇</h2><p><img src="/images/about-golden-verses.png" alt=""></p><h2 id="卡尔达诺书"><a href="#卡尔达诺书" class="headerlink" title="卡尔达诺书"></a>卡尔达诺书</h2><p><img src="/images/about-ars-magna.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> About </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自制榨果汁</title>
      <link href="/74.Foods/%E8%87%AA%E5%88%B6%E6%A6%A8%E6%9E%9C%E6%B1%81/"/>
      <url>/74.Foods/%E8%87%AA%E5%88%B6%E6%A6%A8%E6%9E%9C%E6%B1%81/</url>
      
        <content type="html"><![CDATA[<p>@ref：知乎 《你曾榨出过最好喝的果蔬汁搭配是什么？ - 毛羽立的回答 - 知乎》</p><p>我在台湾交换时，学校门口的夜市有一个现打蔬果汁摊儿，永远排长队。<br>有凤梨草莓猕猴桃汁，地瓜山药牛奶，木瓜鲜橙胡萝卜汁，红豆薏米牛奶……<br>还有几种以颜色命名的蔬果汁，内容物我记不太清了，大致描述一下。</p><ul><li>红色：草莓，蕃茄，西瓜，木瓜，莲雾，桃子</li><li>橙色：柠檬，甜橙，胡萝卜，芒果，南瓜，凤梨，柚子</li><li>绿色：小麦草，芭乐，芹菜，猕猴桃，芦荟，苦瓜</li><li>白色：香蕉，苹果，梨，薏仁，黄瓜，牛油果</li><li>黑色：葡萄，桑葚，黑布林，蓝莓</li></ul>]]></content>
      
      
      <categories>
          
          <category> 74.Foods </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>午餐肉</title>
      <link href="/74.Foods/%E5%8D%88%E9%A4%90%E8%82%89/"/>
      <url>/74.Foods/%E5%8D%88%E9%A4%90%E8%82%89/</url>
      
        <content type="html"><![CDATA[<p>@ref 豆瓣 《午餐肉爱好者的自我修养——顶级午餐肉指南》</p><p>新手入门： 梅林<br><img src="/images/IMG20220922-5.png" alt=""></p><p>中阶识货：长城白猪午餐肉<br><img src="/images/IMG20220922-6.png" alt=""></p><p>高阶吃货：德和云腿午餐肉<br><img src="/images/IMG20220922-7.png" alt=""></p><p>寻根觅祖：世棒午餐肉（SPAM）<br><img src="/images/IMG20220922-8.png" alt=""></p><p>欧洲货才装B：丹麦三花午餐肉（Tuilp）<br><img src="/images/IMG20220922-9.png" alt=""></p><hr><p>@ref: <a href="https://zhuanlan.zhihu.com/p/21744705" target="_blank" rel="noopener">我们一不小心吃掉了15公斤午餐肉 - 知乎</a></p><p><img src="/images/IMG20220922-10.png" alt=""></p><hr><p>上面提到的：梅林、长城</p><p>梅林：<br>1949年上海解放后，梅林罐头食品厂股份有限公司先于1954年公私合营，由上海轻工业管理局主管，后于1956年成为地方工业部掌管的重点企业。1958年1月8日，《人民日报》发表社论《从梅林看全国》，掀起增产节约、反对浪费的高潮，在全国产生了很大的影响，同时也极大的促进和激发了梅林罐头食品厂的创造热情。于是，梅林厂“双革”创奇迹，竞赛掀热潮，罐头品种增加到200余种。1960年10月1日，地处虹桥路808号的梅林罐头食品厂移至军工路224号，并将拥有较好制罐生产基础和技术实力的上海益民食品二厂的职工、设备全部并入。</p><p>长城：<br>1953年，苏联首次从我国进口水果罐头。当时，总公司尚无主管罐头业务的机构，而由主管水果业务的吴成章同志承办。1954年，我国对苏联出口罐头数量大增，有猪、牛、羊、家禽、水果、蔬菜等十多个品种。</p><p>1954年，我国首次对苏联出口猪肉罐头,是按我国传统口味生产的红烧猪肉，年底，李瑞征副经理去苏联谈判，苏联方面提出红烧肉不适合苏联人民的口味，不久苏联方面派罐头专家来试制清蒸猪肉；捷克派罐头专家试制原汁猪肉、午餐肉；民主德国派罐头专家试制浓汁猪肉（又称古拉许），这些品种基本上都是生猪肉装罐，不加酱油、白糖等调味品，原汁原味。当时，生产对苏联出口的罐头厂，都有苏联罐头专家驻厂或巡回检查验收才能发货。</p><p>对苏联、东欧出口罐头，统一使用长城牌商标，由总公司统一对外签订供货合同下达各地执行。对资出口罐头由上海、天津、广州、汕头、南宁、福州、厦门、青岛、大连等口岸公司对外经营。每个口岸都有一个或两个专用商标。上海梅林牌、绿叶牌，天津长城牌，广州、汕头天坛牌、珠江牌，南宁象山牌，福州、厦门水仙花牌，青岛飞轮牌、牡丹牌，大连红梅牌。有些品种如红烧猪肉、红烧扣肉、红烧牛肉、红烧鸡、红烧鸭、菠萝、桔子等，几个口岸交叉经营。</p><p>@ref： <a href="https://zhuanlan.zhihu.com/p/60363901" target="_blank" rel="noopener">忆五十年代我国的罐头生产和出口 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 74.Foods </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>啤酒</title>
      <link href="/74.Foods/%E5%95%A4%E9%85%92/"/>
      <url>/74.Foods/%E5%95%A4%E9%85%92/</url>
      
        <content type="html"><![CDATA[<p>Cheers🍻！</p><h2 id="啤酒分类"><a href="#啤酒分类" class="headerlink" title="啤酒分类"></a>啤酒分类</h2><p>艾尔啤酒：或是人类最早的啤酒</p><ul><li>艾尔（Ale），又称为顶部发酵（Top Fermentating）。使用该种方式发酵的啤酒，酵母位于啤酒液体顶部，通过表面大量聚集泡沫发酵。这种发酵方式适合温度高的环境，约16℃~24℃最佳，这样发酵的代谢产物能更多样。比如会产生酰类和酯类，这些物质极大地影响了啤酒风味，也是艾尔啤酒当中复杂香气的重要来源。<br>最初的艾尔啤酒并不加入啤酒花，后来渐渐地人们发现，在发酵过程中加入啤酒花后，不但可以延长保存期，还可以增加啤酒的苦味和香味。如今，艾尔啤酒呈现琥珀色，外观透亮，泡沫丰富细腻，挂杯持久，香气丰富，麦芽香气、酯香、酒花香气平衡宜人。<br> 在艾尔啤酒中，还有一些具体的细分，如淡色艾尔、IPA、APA、棕色艾尔、琥珀艾尔、烈性艾尔、小麦啤酒、波特、世涛等。</li><li>IPA（India Pale Ale）印度淡色艾尔： 最早是出现在印度的英国淡色艾尔啤酒。IPA啤酒为干型，呈深琥珀色，含大量酒花，口感偏苦，回味温醇，常带有热带水果味。</li><li>APA（ American Pale Ale）美式淡色艾尔：1980年11月美国的Sierra Nevada酒厂酿出了第一款实验性的美式淡色艾尔啤酒。APA啤酒的麦芽味相对较淡，苦味更明显，风味更浓郁，还常常带有一些柑橘水果的香气</li><li>波特啤酒（Porter）：是一种深色、麦芽味很浓、带点烘烤味道的艾尔啤酒。波特啤酒与棕色艾尔型啤酒不同，它更烈、酒体更丰富、颜色更深并带有更多的烘烤麦芽的味道。和艾尔啤酒的另一分支——世涛非常相似，都是黑色，都有咖啡、太妃糖、焦糖、大麦、燕麦、果仁等香气。</li></ul><p>拉格啤酒：全世界占比90%的啤酒</p><ul><li>拉格（Lager），又称为底部发酵（Bottom fermenting）。拉格啤酒发酵时，酵母在液体底部，发酵温度要求较低，酒精含量较低。由于酵母沉在发酵醪底部，酵母主要以单一的酒精代谢为主，所以拉格啤酒的口感更加简单，主要是大麦和小麦的原味。<br>拉格啤酒也包括一些细分种类，如淡色拉格、深色拉格、皮尔森、博克等。</li><li>皮尔森：诞生于捷克，如今遍布全世界，属于淡色系的拉格啤酒，爽口清冽，有淡淡的啤酒花苦味。皮尔森采用下层发酵法，是用浅色麦芽苦味较重的啤酒花酿造的lager（拉格）啤酒，麦汁浓度最高不超过12.5度。</li><li>深色拉格：颜色范围覆盖至琥珀色到非常深的红棕色，酒精度一般在 4.5%-6% 之间，通常带有烘烤、可可豆和焦糖等风味，口感比较柔和饱满。德国黑啤就是大家比较熟知的深色拉格。</li></ul><p>生啤熟啤：根据杀菌情况区分</p><ul><li>生啤是指不经过传统高温杀菌的啤酒，这类啤酒中还含有活性酵母菌，一般保存时间不宜太长，通常为桶装，口感鲜美，营养丰富。</li><li>熟啤是经过灭菌处理的啤酒，保存时间较长。起初是通过巴氏（高温瞬时）灭菌，但会使啤酒伴随老熟的味道；随着啤酒酿造技术成熟，美国、日本及欧洲一些国家采用低温膜过滤以及冷杀菌，具有较长的保质期，一般选择瓶装或罐装。</li></ul><h2 id="精酿入门"><a href="#精酿入门" class="headerlink" title="精酿入门"></a>精酿入门</h2><p><a href="https://www.zhihu.com/question/319531361/answer/1945585776" target="_blank" rel="noopener">有什么可以当口粮的精酿啤酒？ - 知乎</a></p><p><a href="https://www.zhihu.com/question/288080401" target="_blank" rel="noopener">精酿啤酒和国内普通啤酒有什么本质的区别？ - 知乎</a></p><ul><li>精酿啤酒比流水线生产的工业啤酒更追求品质，原料、工艺的选择都以突出品质为前提，始终把啤酒的风味放在首位。</li><li>用料上，精酿啤酒不计成本采用精良的原料，大部分使用纯麦芽糖化，工业啤酒更多采用低成本原料，例如大米，糖浆，玉米、淀粉等代替麦芽。</li><li>原料使用上，传统的工艺要求啤酒只能使用四种原材料，麦芽、酒花、酵母、水，但随着社会发展，现在的精酿更加多样，也有添加果汁等原料。whatever，区别于工业啤酒的使用低成本的原料发酵，使用添加剂、浸膏等代替酒花。</li><li>精酿啤酒讲究创新，在基础的四种原料外，大胆地尝试新原料，加入了很多匪夷所思的东西，有的精酿啤酒也会采用玉米、淀粉这类原料，不过始终坚持不使用人工添加剂。所以两者的区别不在原料种类，而在于精酿更重视原料的天然，选择原料的目的是为了突出啤酒的风味，而工业啤酒是为了降低成本。</li><li>发酵方式上，精酿啤酒大多采用艾尔酵母，进行上层发酵。一些精酿啤酒也会采用拉格工艺（下发酵工艺）。所以不能把工艺当作区分二者的绝对标准。</li><li>酒精度和麦芽汁浓度区分不可靠，<br>同保质期一样，精酿啤酒也有低酒精度和低麦芽汁浓度的，所以不能说所有的精酿啤酒酒精度和麦芽汁浓度都比普通啤酒高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 74.Foods </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>家庭常备药品</title>
      <link href="/73.Health-and-Medicine/%E5%AE%B6%E5%BA%AD%E5%B8%B8%E5%A4%87%E8%8D%AF%E5%93%81/"/>
      <url>/73.Health-and-Medicine/%E5%AE%B6%E5%BA%AD%E5%B8%B8%E5%A4%87%E8%8D%AF%E5%93%81/</url>
      
        <content type="html"><![CDATA[<p>家庭药箱中应有哪些常用药才能覆盖日常应急所需？根据家庭成员的构成，应主要覆盖内服药、外用药、特殊人群和辅助用品四大类别。</p><p>内服药常见的有感冒药、 解热镇痛药、止咳化痰药、止泻药、通便药、抗过敏药、助消化药七大类，一般不推荐储备抗菌类药物。<br>外用药主要有外用消毒药，如75%乙醇（酒精）、碘伏等；其他外用药如云南白药、风油精等；创可贴、灭菌医用棉签、纱布、绷带等卫生材料也要备齐。<br>家中如有特殊病患，还应按专科医师建议准备常用应急药物。如心血管疾病使用的硝酸甘油、阿司匹林，哮喘患者使用的硫酸沙丁胺醇气雾剂等。</p><h2 id="感冒药："><a href="#感冒药：" class="headerlink" title="感冒药："></a>感冒药：</h2><p>　　可备酚麻美敏片、维C银翘片。感冒是自限性疾病，一般不用药物治疗，多休息、多喝热水也可以自愈，但服药可缓解症状，所以口服感冒药通常是家庭药箱的常见成员。需要留意的是，很多感冒药都含有相同成分，一定要仔细看好说明书，避免重复用药，严格按推荐的剂量和用法。使用中成药时最好能分清风热感冒和风寒感冒或流行性感冒，不同类型的感冒使用的药物也不同。</p><h2 id="解热镇痛药："><a href="#解热镇痛药：" class="headerlink" title="解热镇痛药："></a>解热镇痛药：</h2><p>　　常见的有布洛芬混悬液、对乙酰氨基芬片。该类药物主要用于缓解感冒后发热、头痛、关节痛等症状。有胃病、消化道溃疡病史的人要慎用，疼痛症状明显加重或出现新的疼痛症状，以及连续用药三天不能缓解的，要咨询医生或药师。这两种药物均有儿童剂型可供选择。</p><h2 id="止咳化痰药："><a href="#止咳化痰药：" class="headerlink" title="止咳化痰药："></a>止咳化痰药：</h2><p>　　可备氢溴酸右美沙芬片、蛇胆川贝枇杷膏；化痰药物可以选择盐酸氨溴索片、乙酰半胱氨酸颗粒等。针对干咳，一般会使用中枢性镇咳药，目前，唯一一种非处方中枢性镇咳药是氢溴酸右美沙芬，市售有糖浆剂和片剂。</p><h2 id="止泻药："><a href="#止泻药：" class="headerlink" title="止泻药："></a>止泻药：</h2><p>　　可备口服补液盐散、蒙脱石散。前者能预防和纠正腹泻导致的脱水；后者是高效消化道黏膜保护剂，具有改善肠道的吸收和分泌功能，能有效阻止病原微生物的攻击。不过腹泻最好在发病初期到医院筛查病因，这样才能有的放矢。</p><h2 id="通便药："><a href="#通便药：" class="headerlink" title="通便药："></a>通便药：</h2><p>　　可选乳果糖。它不被人体吸收，通过刺激结肠蠕动，缓解便秘，尤其适宜老年人、孕产妇、儿童及术后便秘者。应注意，便秘不应单纯依赖药物治疗，还要从改变生活方式改良饮食习惯入手。</p><h2 id="抗过敏药："><a href="#抗过敏药：" class="headerlink" title="抗过敏药："></a>抗过敏药：</h2><p>　　如氯雷他定，属于抗组胺类抗过敏药，适用于皮肤过敏、食物及药物过敏等。氯雷他定除了有片剂外，还有儿童使用的糖浆剂和滴剂。</p><h2 id="助消化药："><a href="#助消化药：" class="headerlink" title="助消化药："></a>助消化药：</h2><p>　　如多酶片、健胃消食片等。</p><h2 id="家庭备药注意四大原则："><a href="#家庭备药注意四大原则：" class="headerlink" title="家庭备药注意四大原则："></a>家庭备药注意四大原则：</h2><p>　　第一，根据家庭人员的组成和健康状况备药，注意老人、小孩与孕妇的用药；严禁混入家庭成员过敏的药物；</p><p>　　第二，选择不良反应较少的非处方药（OTC药）；</p><p>　　第三，选择疗效稳定、用法简单的药物，如口服药、外用药等。</p><p>　　第四，选择常见病、多发病用药。家庭备药一般只是作为应急或方便，无需面面俱到。</p><hr><p>  @ref: <a href="http://baby.sina.com.cn/health/mmjk/hzbhy/2018-05-08/doc-ifyuwqfa7628610.shtml" target="_blank" rel="noopener">http://baby.sina.com.cn/health/mmjk/hzbhy/2018-05-08/doc-ifyuwqfa7628610.shtml</a></p>]]></content>
      
      
      <categories>
          
          <category> 73.Health-and-Medicine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中医药黑名单</title>
      <link href="/73.Health-and-Medicine/%E4%B8%AD%E5%8C%BB%E8%8D%AF%E9%BB%91%E5%90%8D%E5%8D%95/"/>
      <url>/73.Health-and-Medicine/%E4%B8%AD%E5%8C%BB%E8%8D%AF%E9%BB%91%E5%90%8D%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="马兜铃酸-细辛-amp-关木通-amp-鱼腥草"><a href="#马兜铃酸-细辛-amp-关木通-amp-鱼腥草" class="headerlink" title="马兜铃酸/细辛&amp;关木通&amp;鱼腥草"></a>马兜铃酸/细辛&amp;关木通&amp;鱼腥草</h2><ul><li>致病：马兜铃酸及其进入人体后代谢出来的马兜铃内酰胺1型会导致马兜铃酸肾病</li><li>药材：<ul><li>细辛(马兜铃科)</li><li>关木通(马兜铃科)</li><li>青木香</li><li>广防己</li><li>鱼腥草(折耳根)：目前被认为有强致癌性的是马兜铃酸I，而折耳根（鱼腥草）中含的则是马兜铃内酰胺-BII、马兜铃内酰胺-AII和马兜铃内酰胺-FII（总0.016g/kg）。鱼腥草不是马兜铃科的植物，但是其含有马兜铃酸在人体代谢后的产物内酰胺</li></ul></li><li>成品：<ul><li>当归四逆加吴茱萸生姜汤</li><li>龙胆泻肝丸</li><li>各类凉茶</li></ul></li><li>参考：<ul><li><a href="https://www.zhihu.com/question/47548920" target="_blank" rel="noopener">鱼腥草（折耳根）会导致马兜铃肾病，甚至肾衰吗？ - 知乎</a></li></ul></li></ul><h2 id="砷化物-雄黄"><a href="#砷化物-雄黄" class="headerlink" title="砷化物/雄黄"></a>砷化物/雄黄</h2><ul><li>药材：<ul><li>雄黄：四硫化四砷</li></ul></li><li>成品：<ul><li>牛黄解毒片：牛黄解毒片的成分有牛黄、雄黄、石膏、大黄、黄芩、桔梗、冰片和甘草</li></ul></li><li>参考：<ul><li><a href="https://www.zhihu.com/question/40735357" target="_blank" rel="noopener">牛黄解毒片中的雄黄会导致中毒么？ - 知乎</a></li></ul></li></ul><h2 id="重金属-朱砂"><a href="#重金属-朱砂" class="headerlink" title="重金属/朱砂"></a>重金属/朱砂</h2><ul><li>成分：硫化汞</li><li>成品：兰州牛黄清心丸</li></ul><h2 id="生物碱-乌头碱"><a href="#生物碱-乌头碱" class="headerlink" title="生物碱/乌头碱"></a>生物碱/乌头碱</h2><ul><li>致病：乌头类中药主要毒性成分是乌头碱等生物碱，人口服乌头碱3-5mg可使人致死。乌头碱主要损害循环系统及中枢神经系统，其对循环系统的损害主要是导致各种心律失常。</li><li>药材：<ul><li>附子：为毛茛科植物，母根叫乌头，为镇痉剂，冶风庳，风湿神经痛。侧根（子根）入药，叫附子。</li><li>草乌</li><li>川乌</li></ul></li><li>成品：<ul><li>云南白药</li></ul></li><li>参考：<ul><li><a href="http://yao.dxy.cn/article/72948" target="_blank" rel="noopener">云南白药中的毒药 - 丁香园</a></li><li><a href="http://news.163.com/special/reviews/aconite0910.html" target="_blank" rel="noopener">乌头类草药：处处带毒，防不胜防</a></li><li><a href="https://www.cmro.gov.hk/html/gb/health_info/pamphlet/The_safe_use_of_Chinese_medicines_containing_aconitum_alkaloids.html" target="_blank" rel="noopener">卫生署中医药规管办公室</a></li></ul></li></ul><h2 id="生物碱-番木鳖碱"><a href="#生物碱-番木鳖碱" class="headerlink" title="生物碱/番木鳖碱"></a>生物碱/番木鳖碱</h2><ul><li>致病：番木鳖碱（士的宁，strychnine）其口服中毒剂量成人一般为5～10 mg，口服致死量为30 mg。士的宁对整个中枢神经系统有兴奋作用。马钱子中毒的早期症状为头痛，头晕、恶心、呕吐、焦虑、烦躁不安及轻度抽搐，继之出现全身抽搐、感觉器官敏感性增高、牙关紧闭、痉笑、角弓反张、吞咽和呼吸困难。患者通常死于呼吸骤停。</li><li>药材：<ul><li>马钱子：马钱子是马钱科植物马钱的干燥成熟种子。马钱子含有多种生物碱，主要为番木鳖碱（士的宁，strychnine）和马钱子碱。别名有番木鳖、乌鸦眼、苦实、马前、牛银等</li></ul></li></ul><h2 id="黄连素"><a href="#黄连素" class="headerlink" title="黄连素"></a>黄连素</h2><p><a href="https://www.dxy.cn/bbs/newweb/pc/post/45745019" target="_blank" rel="noopener">长教训了！一颗黄连素片害我差点断送职业生涯</a></p><ul><li>蚕豆病是一种遗传性溶血性疾病，本质是红细胞葡萄糖-6-磷酸脱氢酶（G6PD）缺乏症的一种表现类型，这类病人可能因为食用蚕豆或服用特定药物诱发溶血反应，严重时可出现黄疸，甚至危及生命。</li><li>黄连素片（盐酸小檗碱片）就是蚕豆病的禁用药之一，这个药可能会导致蚕豆病病人溶血</li></ul><blockquote><p>黄连是一种常用的中药，不仅“治病”，还能“防病”。例如我国某些地区有给新生儿喂黄连的习俗，认为可以“去胎毒”。由于国内药物不良反应的监测与上报均不完善，我们很难得到黄连中毒及不良反应的全面信息，但新生儿因喂黄连导致中毒，产生溶血、胃肠道反应乃至致死的事件，却时有耳闻。<br>黄连并不会对所有新生儿或成人都产生毒性，而是针对某些特定人群。遗传的原因使这些人体内缺少一种酶，即葡萄糖-6-磷酸脱氢酶，简称G6PD。缺少这种酶的人，体内无法产生足够的NADPH，而NADPH又是抗氧化剂GSH循环使用的必须物质。简言之，缺少G6PD，人体就不能产生足够的抗氧化剂，容易受到氧自由基的损伤。人体中氧含量最丰富的细胞是专门携带氧的红细胞，而红细胞只能靠GSH来抗氧化。当体内氧化剂突然增多时，红细胞就会产生大量的氧自由基。正常人可以自体清除氧自由基，但缺少G6PD的人则不能，红细胞会受自由基损伤而大量破坏，也就是溶血反应。人会头痛、全身不适、高热、肾功能衰竭，严重者可致死。历史上记载这种病多见于蚕豆产地，大多因吃新鲜蚕豆而诱发，所以又叫蚕豆病。<br>中国人缺乏G6PD的很多，尤其是南方人群，据报道发病率最高的广东省可达8.7%。而给新生儿喂黄连的也以南方居多。因为历史的原因，这类习俗也传到了东南亚。因为“疗效”没有任何依据，却会有溶血的风险，在上世纪70年代，新加坡就禁用了黄连。2016年新加坡解除了黄连禁令，但仍然禁止给婴儿、G6PD酶素缺乏症患者、孕妇和哺乳期妇女使用。美国则在上世纪90年代禁用了含黄连的膳食补充剂。</p></blockquote><blockquote><p>参考： <a href="https://zhuanlan.zhihu.com/p/38325689" target="_blank" rel="noopener">黄连翻案为哪般？ - 知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 73.Health-and-Medicine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>饮食健康.升糖指数（GI）</title>
      <link href="/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E5%8D%87%E7%B3%96%E6%8C%87%E6%95%B0%EF%BC%88GI%EF%BC%89/"/>
      <url>/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E5%8D%87%E7%B3%96%E6%8C%87%E6%95%B0%EF%BC%88GI%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li>GI (Glycemic index / 升糖指数)：GI越高意味着食物转化成血糖的时间越短。</li><li>为何高碳水食物导致犯困：碳水化合物含量较高且升糖指数较高的，会迅速导致血糖升高从而导致大量胰岛素的分泌。胰岛素让一种特别的氨基酸—色氨酸进入大脑，而色氨酸在大脑中会转变成血清素导致人们犯困。</li><li>食物升糖指数： <ul><li>高GI食物： 白面包，白米，红薯，白薯</li><li>低GI食物： 黑豆，lentil，鹰嘴豆，芝麻，花生，瓜子，核桃，腰果，糙粮，蘑菇等</li></ul></li></ul><p><img src="/images/食物升糖指数（GI）/15948892509400.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 73.Health-and-Medicine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>饮食健康.高嘌呤食物</title>
      <link href="/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E9%AB%98%E5%98%8C%E5%91%A4%E9%A3%9F%E7%89%A9/"/>
      <url>/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E9%AB%98%E5%98%8C%E5%91%A4%E9%A3%9F%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<p>▶ 嘌呤： 有机化合物，分子式C5H4N4,无色结晶，在人体内嘌呤氧化而变成尿酸。人体尿酸过高就会引起痛风。</p><p>▶ 食物含量(单位 100g食物/mg嘌呤)：</p><ul><li>低嘌呤（小于50毫克）：<ul><li>五谷类（米、麦、高梁、玉米、马铃薯）</li><li>蛋类（鸡蛋、鸭蛋）</li><li>奶制品（牛奶、奶酪）</li><li>水果</li></ul></li><li>中等嘌呤（50~150毫克）：<ul><li>肉类：鸡肉、猪肉、牛肉、羊肉、鱼100~150mg、虾80~130mg</li><li>豆类：黑豆、绿豆、红豆、花豆、碗豆</li></ul></li><li>高嘌呤：<ul><li>海产：紫菜270mg、</li><li>动物内脏： 鸭肝300mg、牛肝233mg、牛肾200mg、胰脏825mg</li><li>肉汤：160-400mg</li></ul></li></ul><blockquote><p>@ref: <a href="https://baike.baidu.com/item/%E5%98%8C%E5%91%A4%E9%A3%9F%E7%89%A9/8536185" target="_blank" rel="noopener">嘌呤食物_百度百科</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 73.Health-and-Medicine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>饮食健康.生酮饮食</title>
      <link href="/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E7%94%9F%E9%85%AE%E9%A5%AE%E9%A3%9F/"/>
      <url>/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E7%94%9F%E9%85%AE%E9%A5%AE%E9%A3%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="生酮饮食"><a href="#生酮饮食" class="headerlink" title="生酮饮食"></a>生酮饮食</h2><p>▶ 生酮饮食：大幅降低碳水化合物比例，蛋白质比例不变，空缺出来的部分就靠脂肪类填补。</p><p>生酮饮食（ketogenic diet，或简称keto diet）指的是脂肪含量多、蛋白质含量中低、碳水化合物含量极低的食物。这类食物给人体带来酮症（ketosis），从而导致了酮类（ketones）分子的形成。当人体因缺少碳水化合物而被迫燃烧脂肪以补充能量时，上述过程就会发生。</p><p>「生酮」是指一个令身体产「生」「酮」体的过程。由于摄取极低量的碳水化合物，促使肝糖用尽，身体便会开始燃烧脂肪，继而产生称为「酮体」的代谢物。</p><blockquote><p>医学上曾经主用于治疗儿童的困难控制型癫痫；<br>正常情况下，碳水化合物经人体吸收后会转化为葡萄糖运往身体各处及供给能量，尤其是用于维持大脑运作。然而由于生酮饮食中只摄取少量的低碳水化合物，肝脏便会将脂肪转换为脂肪酸和酮体。酮体运到脑部取代葡萄糖成为能量来源。当血液中酮体含量达到一定程度时，即为酮症，能缓和癫痫的频繁发作。</p></blockquote><p><img src="/images/20220226012906.png" alt=""></p><h2 id="如何安排三餐"><a href="#如何安排三餐" class="headerlink" title="如何安排三餐"></a>如何安排三餐</h2><p>一份生酮食谱需要人们严格执行膳食计划，其中包括：像培根、多脂奶油和黄油等高脂肪食物，与此同时，还要严格限制如淀粉类蔬菜的摄入，包括：番薯、全谷物以及某些特定的水果。这种饮食习惯上的巨大改变会导致呕吐、消化不良、无意识的体重减轻以及风险增高的营养不良的现象。</p><p>每日热量 = 5%碳水 + 25%蛋白质 + 70%脂肪</p><ul><li>在进行生酮饮食时，碳水化合物应只占总热量的5%！生酮饮食餐单的比例限定每天碳水化合物的摄取量少于50克，从而降低胰岛素的分泌量，减少胰岛素阻抗的程度，更能稳定体重。</li><li>蛋白质提供20%到25%的热量</li><li>依靠脂肪提供约70%到75%剩下最大部分的热量。</li></ul><p>三餐示例:</p><ul><li>早餐:<ul><li>煎鸡蛋</li><li>咖啡或热茶中加入一大已融化的奶油、椰子油或中链脂肪酸油来作为生酮饮品<ul><li>午餐:</li><li>鸡肉沙拉, 搭配 初榨橄榄油、牛油果油或以这些油品来制作的沙律酱</li><li>晚餐:</li><li>煎三文鱼</li></ul></li></ul></li></ul><h2 id="阿特金斯饮食法"><a href="#阿特金斯饮食法" class="headerlink" title="阿特金斯饮食法"></a>阿特金斯饮食法</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E7%89%B9%E9%87%91%E6%96%AF%E9%A5%AE%E9%A3%9F%E6%B3%95" target="_blank" rel="noopener">阿特金斯饮食法 - 维基百科，自由的百科全书</a></p><blockquote><p>阿特金斯饮食法（英语：Atkins diet）是美国医生罗伯特·阿特金斯（Robert Atkins）创造的一种颇具争议的减肥饮食方法，其要求完全不吃碳水化合物，而可以吃高蛋白的食品，即不吃任何淀粉类、高糖分的食品，而多吃肉类、鱼。其核心是控制碳水化合物的摄入量，类似生酮饮食，从而将人体从消耗碳水化合物的代谢转化成以消耗脂肪为主的代谢模式。[1][2]阿特金斯饮食法被认为属于“食物盲从”，只有薄弱的证据支撑其在减肥方面的有效性。<br>多吃高蛋白质食物会增加肾的负担，所以该方法并不适合有肾脏病的人使用（多数国家的肾脏疾病患病率超过10%，而且许多轻微的肾脏疾病患者并不自知）。</p></blockquote><p><a href="https://www.zhihu.com/question/280966542" target="_blank" rel="noopener">阿特金斯和生酮哪个好，有什么区别？阿特金斯减肥法会不会也让身体进入生酮期？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 73.Health-and-Medicine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>饮食健康.IBS（肠易激综合征）</title>
      <link href="/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.IBS%EF%BC%88%E8%82%A0%E6%98%93%E6%BF%80%E7%BB%BC%E5%90%88%E5%BE%81%EF%BC%89/"/>
      <url>/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.IBS%EF%BC%88%E8%82%A0%E6%98%93%E6%BF%80%E7%BB%BC%E5%90%88%E5%BE%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><p>肠易激综合征（irritable bowel syndrome，IBS）</p><ul><li>“喝了冰冻饮料就会拉肚子”</li><li>“紧张一点会有腹痛感”</li><li>“吃了某些‘寒气’食物就会拉肚子”</li><li>“肚子痛然后马上就像上厕所”</li><li>压力、紧张也会导致： <a href="https://mp.weixin.qq.com/s/xYoaQaW1N-oM9gmISHGtKw" target="_blank" rel="noopener">一有压力就胃痛，肠易激综合征如何解决？</a></li></ul></li><li><p>什么引起：腹泻由FODMAP（Fermentable Oligo-, Di-, Mono-saccharides And Polyols，可发酵的寡糖，二糖，单糖和多元醇）引起，FODMAP包括：</p><ul><li>Fructose：果糖</li><li>Lactose：乳糖</li><li>Mannitol：甘露糖醇</li><li>Sorbitol：山梨糖醇</li><li>GOS：低聚半乳糖</li><li>Fructan：果聚糖</li></ul></li></ul><ul><li><p>为什么FODMAP等糖类引起腹泻：</p><ul><li>无法被小肠吸收的短链碳水化合物（被称为FODMAP）会将进入大肠，大肠内细菌会迅速发酵FODMAP并产生过量气体。</li><li>大量水分和过量气体导致肠道过分扩展，肠壁因扩张而过分延伸，肠壁上高度连接的神经会马上向大脑传输疼痛信号。于是人就会出现腹痛、腹泻。</li></ul></li><li><p>IBS患者不能吃什么：高FODMAP的食物</p><ul><li>Furctose 果糖： 蜂蜜</li><li>Lactos 乳糖： 牛奶</li><li>Mannitol 甘露糖醇/Sorbitol 山梨糖醇： 雪梨、桃子、苹果</li><li>GOS 低聚半乳糖/Fructan 果聚糖：小麦、黑麦、洋葱、大蒜、豆类</li></ul></li></ul><ul><li>IBS患者吃什么：低FODMAP的食物可以降低IBS症状，燕麦、香蕉、少量芒果、少量北杏仁是符合低FODMAP的食物<ul><li>麦片：避免添加奶粉和糖的麦片</li></ul></li></ul><p>图1: FODMAP糖类 和 引起腹泻的原因<br><img src="/images/IBS/15949232146885.jpg" alt="-w679"></p><p>识别生活中常见的高/低FODMAP食物：<br>注意! 面粉(面包,馒头,面)是高FODMAP, 米饭是低FODMAP食物<br><img src="/images/IBS/15949232497059.jpg" alt="-w679"></p><p>@ref： <a href="https://zhuanlan.zhihu.com/p/141590924" target="_blank" rel="noopener">经常肚子痛拉肚子？你很可能患有IBS - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 73.Health-and-Medicine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fitness-and-Gym指南</title>
      <link href="/73.Health-and-Medicine/Fitness-and-Gym%E6%8C%87%E5%8D%97/"/>
      <url>/73.Health-and-Medicine/Fitness-and-Gym%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="健身房-器械"><a href="#健身房-器械" class="headerlink" title="健身房-器械"></a>健身房-器械</h1><h2 id="力竭和组间休息"><a href="#力竭和组间休息" class="headerlink" title="力竭和组间休息"></a>力竭和组间休息</h2><blockquote><p><a href="https://www.zhihu.com/question/25022205" target="_blank" rel="noopener">每组力竭的话和组间休息时间怎么安排？ - 知乎</a><br>什么是组间间歇？假设我们锻炼一个部位采用abcd四个动作，我们首先使用a动作，一般采用递增的重量连续做四组，a动作四组之间的休息时间即为组间间歇时间。还有一种情况是a动作四组结束之后与b动作之间的休息时间，同样b动作结束后连接c动作的时间。<br>正确的组间间歇：你可以通过带一个秒表或者一款心率表去健身房，通过这两块表来控制组间间歇时间，组间间歇一般在0s—90s之间（除硬拉，深蹲等大重量动作），并且时间越短越好。</p></blockquote><h2 id="Gym-颈前正握下拉"><a href="#Gym-颈前正握下拉" class="headerlink" title="[Gym]颈前正握下拉"></a>[Gym]颈前正握下拉</h2><p><img src="/images/Fitness-Gym/16038802165474.jpg" alt=""></p><h2 id="Gym-宽握引体向上"><a href="#Gym-宽握引体向上" class="headerlink" title="[Gym]宽握引体向上"></a>[Gym]宽握引体向上</h2><p><img src="/images/Fitness-Gym/16038803955092.jpg" alt=""></p><h1 id="使用哑铃进行练习"><a href="#使用哑铃进行练习" class="headerlink" title="使用哑铃进行练习"></a>使用哑铃进行练习</h1><h2 id="哑铃7天训练-飞特那斯"><a href="#哑铃7天训练-飞特那斯" class="headerlink" title="哑铃7天训练-飞特那斯"></a>哑铃7天训练-飞特那斯</h2><p><a href="https://www.zhihu.com/zvideo/1521844652630454272" target="_blank" rel="noopener">全身哑铃7天训练方案，适合所有人，家庭训练必备 - 知乎</a></p><p>哑铃7天训练时间表<br>第1天，背+肩：00：00-03：11<br>第2天，胸+肩：03：12-06：28<br>第3天，休息：06：28-06：30<br>第4天，二头+三头：06：30-11：18<br>第5天，三角肌：11：18-13：40<br>第6天，臀腿+小腿：13:40-16：33<br>第7天，休息:16：33-16：35</p><p><img src="/images/IMG20220919.png" alt="../_images/IMG20220919.png"></p><h3 id="Day-1（背-肩）"><a href="#Day-1（背-肩）" class="headerlink" title="Day 1（背+肩）"></a>Day 1（背+肩）</h3><p><img src="/images/IMG20220919-1.png" alt="../_images/IMG20220919-1.png"></p><p><img src="/images/IMG20220919-2.png" alt="../_images/IMG20220919-2.png"></p><p><img src="/images/IMG20220919-3.png" alt="../_images/IMG20220919-3.png"></p><p><img src="/images/IMG20220919-4.png" alt="../_images/IMG20220919-4.png"></p><p><img src="/images/IMG20220919-5.png" alt="../_images/IMG20220919-5.png"></p><p><img src="/images/IMG20220919-6.png" alt="../_images/IMG20220919-6.png"></p><p><img src="/images/IMG20220919-7.png" alt="../_images/IMG20220919-7.png"></p><h2 id="哑铃训练动作参考"><a href="#哑铃训练动作参考" class="headerlink" title="哑铃训练动作参考"></a>哑铃训练动作参考</h2><h3 id="单臂哑铃划船"><a href="#单臂哑铃划船" class="headerlink" title="单臂哑铃划船"></a>单臂哑铃划船</h3><p><img src="/images/Fitness-Gym/16038804712616.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038805257133.jpg" alt=""></p><h3 id="坐姿臂弯举"><a href="#坐姿臂弯举" class="headerlink" title="坐姿臂弯举"></a>坐姿臂弯举</h3><p><img src="/images/Fitness-Gym/16038810777986.jpg" alt=""></p><h3 id="哑铃颈后臂屈伸"><a href="#哑铃颈后臂屈伸" class="headerlink" title="哑铃颈后臂屈伸"></a>哑铃颈后臂屈伸</h3><p><img src="/images/Fitness-Gym/16038812423162.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038813322401.jpg" alt=""></p><h3 id="哑铃推举-侧平举"><a href="#哑铃推举-侧平举" class="headerlink" title="哑铃推举/侧平举"></a>哑铃推举/侧平举</h3><p><img src="/images/Fitness-Gym/16038813899796.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038821099928.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038821238073.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 73.Health-and-Medicine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/72.Math-and-Logic/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/"/>
      <url>/72.Math-and-Logic/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="➤-贝叶斯公式"><a href="#➤-贝叶斯公式" class="headerlink" title="➤ 贝叶斯公式"></a>➤ 贝叶斯公式</h2><ul><li>P(A|B)是B发生的情况下, A发生的可能性, 贝叶斯公式:<br>$$ P(A|B) = P(B|A)*P(A)/P(B) $$</li></ul><p>@ref: <a href="https://zhuanlan.zhihu.com/p/22467549" target="_blank" rel="noopener">Think Bayes - 我所理解的贝叶斯定理 - 知乎</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/72.Math-and-Logic/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/72.Math-and-Logic/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="➤-傅里叶变换"><a href="#➤-傅里叶变换" class="headerlink" title="➤ 傅里叶变换"></a>➤ 傅里叶变换</h2><ul><li>傅里叶级数: 任何周期函数, 都可以看做不同振幅,不同相位的正弦波的叠加</li><li>图: 周期函数 → N个正弦波叠加</li><li>上图从频域看… 频域的x/y轴物理意义是? 即傅里叶级数的频谱</li><li>上图频域里的离散信号, 如果无限接近连续..</li><li>频域的相位谱</li><li>傅里叶级数: (时域)周期连续 → (频域)非周期离散</li><li>傅里叶变换: (时域)非周期连续→ (频域)非周期连续</li><li>虚数: 虚数i也即-1的平方根, 乘以虚数可以理解为: 旋转</li><li>欧拉公式: $$ e^(ix) = cos(x) + isin(x) $$</li></ul><p><img src="/images/20220217153337.png" alt="../_images/Pasted image 20220217153337.png"></p><hr><p>@ref: <a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">傅里叶分析之掐死教程（完整版）更新于2014.06.06 - 知乎</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/72.Math-and-Logic/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/72.Math-and-Logic/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论相关概念"><a href="#博弈论相关概念" class="headerlink" title="博弈论相关概念"></a>博弈论相关概念</h1><ul><li>纳什均衡</li><li>囚徒困境</li><li>重复博弈</li><li>大众定理</li><li>信息</li><li>帕累托最优</li><li>零和博弈</li><li>非零和博弈</li><li>微分包含式</li><li>拍卖博弈</li></ul><h1 id="帕累托最优"><a href="#帕累托最优" class="headerlink" title="帕累托最优"></a>帕累托最优</h1><p><strong>帕累托最优</strong> 也称为帕累托效率（Pareto Efficiency）、帕雷托最佳配置，是博弈论中的重要概念，并且在经济学， 工程学和社会科学中有着广泛的应用。<br>　　帕累托最优是指资源分配的一种理想状态，假定固有的一群人和可分配的资源，从一种分配状态到另一种状态的变化中，在没有使任何人境况变坏的前提下，使得至少一个人变得更好，这就是帕累托改进或帕累托最优化。帕累托最优的状态就是不可能再有更多的帕累托改进的余地；换句话说，帕累托改进是达到帕累托最优的路径和方法。帕累托最优是公平与效率的“理想王国”。<br>　　帕累托最优回答的是效率问题。从社会福利角度出发，用效率来评价总体经济运行有其合理性，因为如果资源配置未达到帕累托最优，那么，总有一些人能改善境况而没有人会受损，也就是说，社会福利总量肯定能上升，那么通过一种恰当的分配或补偿措施，能使所有人的境况都有所改善。[1]</p><p><strong>举例1：</strong><br>假设现在有两个人，甲和乙，分10块蛋糕，并且两个人都喜欢吃蛋糕。10块蛋糕无论在两个人之间如何分配，都是帕累托最优，因为你想让某一个人拥有更大利益的唯一办法是从另一个人手里拿走蛋糕，导致的结果是那个被拿走蛋糕的人利益受损</p><h1 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h1><p><strong>纳什均衡</strong> 是指博弈中这样的局面，又称为非合作博弈均衡，对于每个参与者来说，只要其他人不改变策略，这个参与者就无法改善自己的状况。纳什证明了在每个参与者都只有有限种策略选择并允许混合策略的前提下，纳什均衡定存在。以两家公司的价格大战为例，价格大战存在着两败俱伤的可能，在对方不改变价格的条件下既不能提价，否则会进一步丧失市场;也不能降价,因为会出现赔本甩卖。于是两家公司可以改变原先的利益格局，通过谈判寻求新的利益评估分摊方案。相互作用的经济主体假定其他主体所选择的战略为既定时，选择自己的最优战略的状态，也就是纳什均衡。</p><p><strong>举例1：</strong><br>1950年，由就职于兰德公司的梅里尔·弗勒德和梅尔文·德雷希尔拟定出相关困境的理论，后来由顾问艾伯特·塔克以囚徒方式阐述，并命名为“囚徒困境”。经典的囚徒困境如下：</p><p>警方逮捕甲、乙两名嫌疑犯，但没有足够证据指控二人有罪。于是警方分开囚禁嫌疑犯，分别和二人见面，并向双方提供以下相同的选择：</p><ul><li>若一人认罪并作证检控对方（相关术语称“背叛”对方），而对方保持沉默，此人将即时获释，沉默者将判监10年。</li><li>若二人都保持沉默（相关术语称互相“合作”），则二人同样判监半年。</li><li>若二人都互相检举（互相“背叛”），则二人同样判监5年。</li></ul><p><img src="/images/博弈论-囚徒困境.png" alt=""></p><p><strong>解说：</strong></p><p>如同博弈论的其他例证，囚徒困境假定每个参与者（即“囚徒”）都是利己的，即都寻求最大自身利益，而不关心另一参与者的利益。参与者某一策略所得利益，如果在任何情况下都比其他策略要低的话，此策略称为“严格劣势”，理性的参与者绝不会选择。另外，没有任何其他力量干预个人决策，参与者可完全按照自己意愿选择策略。</p><p>囚徒到底应该选择哪一项策略，才能将自己个人的刑期缩至最短？两名囚徒由于隔绝监禁，并不知道对方选择；而即使他们能交谈，还是未必能够尽信对方不会反口。就个人的理性选择而言，检举背叛对方所得刑期，总比沉默要来得低。试设想困境中两名理性囚徒会如何作出选择：</p><ul><li>若对方沉默、我背叛会让我获释，所以会选择背叛。</li><li>若对方背叛指控我，我也要指控对方才能得到较低的刑期，所以也是会选择背叛。</li></ul><p>二人面对的情况一样，所以二人的理性思考都会得出相同的结论——选择背叛。背叛是两种策略之中的支配性策略。因此，这场博弈中唯一可能达到的纳什均衡，就是双方参与者都背叛对方，结果二人同样服刑5年。</p><p>这场博弈的纳什均衡，显然不是顾及团体利益的帕累托最优解决方案。以全体利益而言，如果两个参与者都合作保持沉默，两人都只会被判刑半年，总体利益更高，结果也比两人背叛对方、判刑5年的情况较佳。但根据以上假设，二人均为理性的个人，且只追求自己个人利益。均衡状况会是两个囚徒都选择背叛，结果二人判监均比合作为高，总体利益较合作为低。这就是“困境”所在。例子有效地证明了：非零和博弈中，帕累托最优和纳什均衡是互相冲突的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>天文学101</title>
      <link href="/71.Science-and-Tech/%E5%A4%A9%E6%96%87%E5%AD%A6101/"/>
      <url>/71.Science-and-Tech/%E5%A4%A9%E6%96%87%E5%AD%A6101/</url>
      
        <content type="html"><![CDATA[<p>@tag: #入门101 #天文学</p><h2 id="恒星生命周期"><a href="#恒星生命周期" class="headerlink" title="恒星生命周期"></a>恒星生命周期</h2><blockquote><p><a href="https://www.youtube.com/watch?v=Lf6srcoTpg8&amp;vl=zh-Hans" target="_blank" rel="noopener">太阳会死亡吗？红巨星、中子星和黑洞等都是哪来的？李永乐老师讲恒星演化 - YouTube</a></p></blockquote><p>恒星演化:</p><ul><li>初始: 星际云(氢, 氦)</li><li>原恒星: (氢 -&gt; 氦)</li><li>主序星阶段(恒星壮年)<ul><li>不是所有的原恒星都能变成恒星, 质量不够的原恒星-&gt;褐矮星(不是恒星)</li><li>介于0.08太阳质量 ~ 0.5太阳质量, 原恒星-&gt;红矮星, 红矮星上发生的聚变 氢 -&gt; 氦</li><li>介于0.5太阳质量 ~ 8太阳质量之间: 原恒星-&gt;黄矮星(太阳), 发生的聚变 氢 -&gt; 氦 -&gt; 碳</li><li>大于8太阳质量: 原恒星-&gt;蓝色恒星, 质量越大的恒星寿命越短, 发生的聚变 氢 -&gt; 氦 -&gt; 碳 -&gt; 铁</li></ul></li></ul><p>由于主序星阶段, 质量降低, 聚变变强, 导致膨胀,<br>黄矮星(太阳) -&gt; 红巨星(半径非常大) -&gt; 外围物质抛洒形成星云, 核心收缩形成白矮星, 最后阶段 白矮星(质量不够无法形成黑洞) -&gt; 黑矮星;<br>蓝色恒星 -&gt; 红超巨星(半径非常大) -&gt; 超新星爆发(宋朝记录的超新星爆发-&gt;蟹状星云) -&gt; 核心收缩后 -&gt; 变成中子星,<br>    如果蓝色恒星的质量更大, 超新星爆炸后, 核心坍塌变成黑洞</p><p>恒星质量(由小到大)，在生命末期，分别会形成白矮星、中子星、黑洞</p><p><img src="/images/20220206234637.png" alt=""></p><h1 id="黑洞"><a href="#黑洞" class="headerlink" title="黑洞"></a>黑洞</h1><blockquote><p>参考: <a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E6%B4%9E" target="_blank" rel="noopener">黑洞 - 维基百科，自由的百科全书</a></p></blockquote><p>黑洞（英语：black hole）是根据广义相对论所推论、在宇宙空间中存在的一种质量相当大的天体和星体（并非是一般认知的“洞”概念）。黑洞是由质量足够大的恒星在核聚变反应的燃料耗尽后发生引力坍缩而形成。黑洞的质量是如此之大，它产生的引力场是如此之强，以致于大量可测物质和辐射都无法逃逸，就连传播速度极快的光子也逃逸不出来。由于类似热力学上完全不反射光线的黑体，故名黑洞。[1]在黑洞的周围，是一个无法侦测的事件视界，标志着无法返回的临界点[2]，而在黑洞中心有一个密度趋近于无限的奇点。</p>]]></content>
      
      
      <categories>
          
          <category> 71.Science-and-Tech </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Цесаревич (броненосец)</title>
      <link href="/66.History/%D0%A6%D0%B5%D1%81%D0%B0%D1%80%D0%B5%D0%B2%D0%B8%D1%87%20(%D0%B1%D1%80%D0%BE%D0%BD%D0%B5%D0%BD%D0%BE%D1%81%D0%B5%D1%86)/"/>
      <url>/66.History/%D0%A6%D0%B5%D1%81%D0%B0%D1%80%D0%B5%D0%B2%D0%B8%D1%87%20(%D0%B1%D1%80%D0%BE%D0%BD%D0%B5%D0%BD%D0%BE%D1%81%D0%B5%D1%86)/</url>
      
        <content type="html"><![CDATA[<h2 id="Цесаревич"><a href="#Цесаревич" class="headerlink" title="Цесаревич"></a>Цесаревич</h2><p>皇太子号战列舰，又译太子号，俄语：Цесаревич）是俄罗斯帝国海军向法国订购的前无畏舰，先后参加了日俄战争和第一次世界大战。本舰所参与的战斗中最著名的是在黄海海战中作为俄国太平洋舰队旅顺分舰队旗舰，交战中舰桥因为受到日军一发炮弹命中，舰队指挥机构瘫痪，从而导致俄国舰队突围失败。本舰虽受重创，依旧趁夜逃脱日军封锁前往胶洲湾，在当地受到德国当局扣押直到战争结束。战后皇太子号返回俄国，加入波罗的海舰队，参加了一战。1917年俄国国内动荡时，舰上水兵发生哗变并参加了革命，舰名也随之更改为公民号（俄语：Гражданин）。@Ref：<a href="https://zh.m.wikipedia.org/zh-hans/%E7%9A%87%E5%A4%AA%E5%AD%90%E8%99%9F%E6%88%B0%E5%88%97%E8%89%A6" target="_blank" rel="noopener">皇太子号战列舰 - 维基百科，自由的百科全书</a></p><p><img src="/images/%D0%9A%D1%80%D0%BE%D0%BD%D0%BF%D1%80%D0%B8%CC%81%D0%BD%D1%86-1.png" alt="../_images/Кронпри́нц-1.png"></p><h2 id="模型制作参考"><a href="#模型制作参考" class="headerlink" title="模型制作参考"></a>模型制作参考</h2><ul><li><a href="https://tieba.baidu.com/p/7146335463" target="_blank" rel="noopener">【图片】long time no see先来个小船，皇太子1904，基本直做，换master炮管和船坞木甲板【模型船吧】_百度贴吧</a></li><li><a href="http://mt.sohu.com/20170307/n482643700.shtml" target="_blank" rel="noopener">【战舰】“迅速突围，驶往海参崴！ ”- 鏖战黄海的皇太子号战列舰-搜狐</a></li></ul><h2 id="历史涂装考证"><a href="#历史涂装考证" class="headerlink" title="历史涂装考证"></a>历史涂装考证</h2><p><img src="/images/russian-navy-tsesarevich-battleship-1917-1.png" alt="../_images/russian-navy-tsesarevich-battleship-1917-1.png"></p><p>① 配色表（1917） @Ref:  <a href="https://www.aliexpress.com/item/32414131136.html" target="_blank" rel="noopener">https://www.aliexpress.com/item/32414131136.html</a></p><p><img src="/images/russian-navy-tsesarevich-battleship-1917-2.png" alt="../_images/russian-navy-tsesarevich-battleship-1917-2.png"></p><p><img src="/images/russian-navy-tsesarevich-battleship-1917-3.png" alt="../_images/russian-navy-tsesarevich-battleship-1917-3.png"></p><p><img src="/images/russian-navy-tsesarevich-battleship-1917-4.png" alt="../_images/russian-navy-tsesarevich-battleship-1917-4.png"></p><p>② 1917 @Ref: <a href="http://thegreatcanadianmodelbuilderswebpage.blogspot.com/2015/08/tsesarevich-1917.html" target="_blank" rel="noopener">http://thegreatcanadianmodelbuilderswebpage.blogspot.com/2015/08/tsesarevich-1917.html</a></p><p><img src="/images/russian-navy-tsesarevich-battleship-1917-5.png" alt="../_images/russian-navy-tsesarevich-battleship-1917-5.png"></p><p><img src="/images/russian-navy-tsesarevich-battleship-1917-6.png" alt="../_images/russian-navy-tsesarevich-battleship-1917-6.png"></p><p>③ 1917 @Ref:  <a href="http://www.trumpeter-china.com/index.php?g=home&amp;m=product&amp;a=show&amp;id=195" target="_blank" rel="noopener">俄罗斯海军”皇太子”号战列舰1904年 05338-1/350系列-小号手 TRUMPETER</a></p><p><img src="/images/russian-navy-tsesarevich-battleship-1917-7.png" alt="../_images/russian-navy-tsesarevich-battleship-1917-7.png"></p><h2 id="未完工的皇太子"><a href="#未完工的皇太子" class="headerlink" title="未完工的皇太子"></a>未完工的皇太子</h2><p>Ohlife：2020.8.3《酱油皇太子》<br><img src="/images/IMG20200803.png" alt=""></p><p>想搞模型的心思又蠢蠢欲动了，动机可能如下： 给小时候圆梦，给小时候的爱好画个句号（毕竟这是个消耗精力，还透支健康的事儿），或者… 为了让房间里的书桌看起来不那么空荡荡（？？？）<br>然后花了大概一个周日的下午开始挑选船模，三大俗（大和、首相、密苏里）首先排除。还是模型店客服给推荐的皇太子，搜了一下这艘前无畏舰的资料，发现还挺有意思： 日俄战争前被给予厚望在沙俄太平洋分舰队担任旗舰，日俄战争是个不怎么光彩的战历，日俄战争结束后得以返回波罗的海舰队，但主力地位不保。整个一战之前，经常无所事事的独自在海上巡弋，孤独王子的名号也这样而来。二月革命后两次易主，彻底沦为冷板凳队员，直到被除籍拆解。突然觉得，这不挺像我嘛。 所以就买买买了</p><ul><li>1899在法国土伦造船厂开始建造（舰名：Кронпри́нц）</li><li>1901年匆匆下水，船厂一直在测试，期间问题不断，航速不达标、主炮供弹系统都出现过问题。</li><li>1903年交付俄方（当时还叫俄罗斯帝国），太子回国报到的旅程也是几经周折，途中主机三度故障。途径意大利、希腊、斯里兰卡、印尼、新加坡，终于在12月达到旅顺港。加入沙俄太平洋分舰队担任旗舰。</li><li>1904日俄战争爆发，沙俄太平洋舰队决定从旅顺突围驶回海参崴。途中遭遇xx拦截，黄海海战爆发。皇太子重创三笠，随后受损被迫驶向胶州湾。</li><li>1906战争结束，皇太子返回俄国，加入波罗的海舰队。一战爆发前，皇太子号战舰经常无所事事地独自在海上巡逻，舰上的水兵把这艘经常独来独去的军舰开玩笑地称为“孤独的王子”。</li><li>1914一战斗爆发，主力地位被更先进的“彼得罗巴甫洛夫斯克”替代。然后“皇太子”号就一直被用于在波罗的海同德国人周旋，它时常在没有任何军舰掩护的情况下孤独地单舰在海上巡弋</li><li>1917二月革命后，沙俄政府倒台，皇太子站在了临时政府一边，改名为“公民号”（Гражданин），临时政府倒台后，被编入苏维埃红海军。由于“皇太子”号从技术上说已经过时，它一直没有得到完全修复，苏维埃政府对它也不重视，所以这位“孤独的王子”就一直独自静悄悄停泊在港湾里。</li><li>1925年，在血腥的俄国内战即将结束之际， 这位“孤独的王子”也走到了它“一生”的尽头，它退出了红海军现役，接着被卖掉拆成小块回炉，支援社会主义建设。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 66.History </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大舰巨炮 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/66.History/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E6%97%B6%E7%A9%BA%E5%9B%BE/"/>
      <url>/66.History/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E6%97%B6%E7%A9%BA%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/IMG20220921.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大舰巨炮</title>
      <link href="/66.History/%E5%A4%A7%E8%88%B0%E5%B7%A8%E7%82%AE/"/>
      <url>/66.History/%E5%A4%A7%E8%88%B0%E5%B7%A8%E7%82%AE/</url>
      
        <content type="html"><![CDATA[<p>多铆蒸钢，大舰巨炮。亿万炮塔，亿万荣光！</p><h1 id="海战史"><a href="#海战史" class="headerlink" title="海战史"></a>海战史</h1><ul><li>1805-<a href="https://zh.m.wikipedia.org/wiki/%E7%89%B9%E6%8B%89%E6%B3%95%E5%8A%A0%E6%B5%B7%E6%88%B0" target="_blank" rel="noopener">特拉法尔加海战 - 维基百科，自由的百科全书</a></li><li>1894-<a href="https://zh.m.wikipedia.org/wiki/%E9%BB%84%E6%B5%B7%E6%B5%B7%E6%88%98_(1894%E5%B9%B4" target="_blank" rel="noopener">黄海海战 (1894年) - 维基百科，自由的百科全书</a>)</li><li>1905-<a href="https://zh.m.wikipedia.org/wiki/%E5%AF%B9%E9%A9%AC%E6%B5%B7%E5%B3%A1%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">对马海峡海战 - 维基百科，自由的百科全书</a></li><li>1916-<a href="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E5%BE%B7%E5%85%B0%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">日德兰海战 - 维基百科，自由的百科全书</a></li><li>1941-<a href="https://zh.wikipedia.org/wiki/%E7%8F%8D%E7%8F%A0%E6%B8%AF%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">珍珠港事件 - 维基百科，自由的百科全书</a></li><li>1942-<a href="https://zh.m.wikipedia.org/wiki/%E7%8F%8A%E7%91%9A%E6%B5%B7%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">珊瑚海海战 - 维基百科，自由的百科全书</a></li><li>1942-<a href="https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E5%B2%9B%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">中途岛海战 - 维基百科，自由的百科全书</a></li><li>1944-<a href="https://zh.m.wikipedia.org/wiki/%E9%9B%B7%E4%BC%8A%E6%B3%B0%E7%81%A3%E6%B5%B7%E6%88%B0" target="_blank" rel="noopener">莱特湾海战 - 维基百科，自由的百科全书</a></li></ul><h1 id="陈列馆"><a href="#陈列馆" class="headerlink" title="陈列馆"></a>陈列馆</h1><ul><li><p><a href="https://page.om.qq.com/page/OpAfxwpDZC-zeS9jT2Ochq9Q0" target="_blank" rel="noopener">铁甲舰、前无畏舰、无畏舰、超无畏舰有啥区别？又是如何演化的？</a> @ref: </p></li><li><p><a href="https://zh.m.wikipedia.org/zh/%E9%98%BF%E9%87%91%E7%A7%91%E7%89%B9%E5%8F%B7%E6%88%98%E5%88%97%E8%88%B0" target="_blank" rel="noopener">阿金科特号战列舰- 维基百科，自由的百科全书</a></p></li><li><a href="https://zhuanlan.zhihu.com/p/27545575" target="_blank" rel="noopener">多铆蒸刚的图腾——阿金库尔号战舰传奇 - 知乎</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%83%A1%E5%BE%B7%E5%8F%B7%E6%88%98%E5%88%97%E5%B7%A1%E6%B4%8B%E8%88%B0" target="_blank" rel="noopener">胡德号战列巡洋舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E6%81%A9%E9%9C%8D%E6%96%AF%E7%89%B9%E8%99%9F%E6%88%B0%E8%89%A6" target="_blank" rel="noopener">沙恩霍斯特号战列舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E7%B4%8D%E7%88%BE%E9%81%9C%E8%99%9F%E6%88%B0%E8%89%A6" target="_blank" rel="noopener">纳尔逊号战舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E7%BE%85%E5%BE%B7%E5%B0%BC%E8%99%9F%E6%88%B0%E8%89%A6" target="_blank" rel="noopener">罗德尼号战舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%A8%81%E5%B0%94%E5%A3%AB%E4%BA%B2%E7%8E%8B%E5%8F%B7%E6%88%98%E5%88%97%E8%88%B0" target="_blank" rel="noopener">威尔士亲王号战列舰 - 维基百科，自由的百科全书</a></li><li><a href="https://www.sohu.com/a/391584137_99978337" target="_blank" rel="noopener">二战美军经典驱逐舰拉菲号</a></li><li><a href="https://zhuanlan.zhihu.com/p/20735323" target="_blank" rel="noopener">战巡金刚杂谈（一） - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/20807863" target="_blank" rel="noopener">战巡/战舰金刚杂谈（二） - 知乎</a></li><li><a href="https://zh.m.wikipedia.org/zh/%E9%9B%AA%E9%A2%A8%E8%99%9F%E9%A9%85%E9%80%90%E8%89%A6" target="_blank" rel="noopener">雪風號驅逐艦 - 维基百科，自由的百科全书</a></li><li><a href="https://zhuanlan.zhihu.com/p/266144718" target="_blank" rel="noopener">二战日本沉没的大中型水面舰艇 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 66.History </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大舰巨炮 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/66.History/%E6%B8%B8%E6%88%8F%E3%80%8ARise-of-Kingdoms%E3%80%8B%E4%B8%AD%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BA%BA%E7%89%A9/"/>
      <url>/66.History/%E6%B8%B8%E6%88%8F%E3%80%8ARise-of-Kingdoms%E3%80%8B%E4%B8%AD%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BA%BA%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="大西庇阿"><a href="#大西庇阿" class="headerlink" title="大西庇阿"></a>大西庇阿</h2><p><img src="/images/IMG20220922-1.png" alt=""><br>大西庇阿（前235年—前183年），全名为普布利乌斯·科尔内利乌斯·西庇阿。古罗马统帅和政治家。他是第二次布匿战争中罗马方面的主要将领之一，以在扎马战役中打败迦太基统帅汉尼拔而著称于世。由于西庇阿的胜利，罗马人以绝对有利的条件结束了第二次布匿战争。西庇阿因此得到他那著名的绰号：“阿非利加征服者”。</p><h2 id="贝利萨留（Belisarius）"><a href="#贝利萨留（Belisarius）" class="headerlink" title="贝利萨留（Belisarius）"></a>贝利萨留（Belisarius）</h2><p><img src="/images/IMG20220922.png" alt=""><br>贝利萨留（约505年～565年），又名贝利萨留斯，拜占庭帝国统帅、军事家。他一生当中的大多数战役是以少胜多。<br>贝利萨留出生于色雷斯。早年任皇帝查士丁尼一世的侍卫。527年率军参加对波斯的战争。529年，升任禁卫军长官。530年，任德拉总督，击败4万波斯-阿拉伯联军，名声大振。532年，镇压君士坦丁堡的尼卡起义，解救被围困的皇帝。533～534年，仅率1万步兵和6000骑兵入侵北非，灭汪达尔-阿兰王国并俘其国王。回国后被授予执政官称号。535年，出征意大利的东哥特王国，登陆西西里岛。536年攻入意大利南部，随后北上占领罗马。540年，攻陷东哥特都城拉韦纳，俘东哥特王。曾经用“自己将政变”为计谋欺骗敌方获胜，结果因此受到查士丁尼一世的怀疑。562年，被指控参与谋反，被捕入狱。563年，获释。565年，去世，享年61岁。</p><h2 id="海尔曼"><a href="#海尔曼" class="headerlink" title="海尔曼"></a>海尔曼</h2><p>英文名：Arminius阿米尼乌斯<br>德语作Hermann赫尔曼</p><p>阿米尼乌斯，或称阿尔米尼乌斯，于公元前18年生于日耳曼尼亚，日耳曼部族切鲁西人(Cherusci)的首领。小被送往罗马当人质。长大后，他成为罗马辅助部队一队骑兵的首领。9年他大败罗马人，在条顿堡森林(Teutoburg Forest)歼灭普布利乌斯·昆克提尼乌斯·瓦卢斯(Publius Quinctilius Varus)的3个军团。15年他巧妙地抵挡了罗马发动的全面进攻，但在16年，他在安格里瓦尔瓦战役败给了罗马将领日尔曼尼库斯，17年与马科曼尼人(Marcomanni)国王马罗波都(Maroboduus)进行战斗。在取得胜利以後，他被日耳曼尼亚部落的对手首领下令暗杀。</p><p>条顿堡森林战役：<br>公元9年9月，瓦卢斯带领十七、十八、十九三个军团从夏营返回东营过冬，连同辎重、家属共计逾两万两千人，阿米尼乌斯召集日耳曼各部落共同伏击罗马人，他施计引诱罗马人进入条顿堡森林，通过三场战斗，他歼灭了罗马人的3个军团，瓦卢斯自杀身亡。<br>当奥古斯都得知瓦鲁斯及三个罗马军团全军覆没，便痛叫”Quintili Vare, legiones redde!” (‘Quintilius Varus, give me back my legions!’)“瓦鲁斯，把军团还给我！”</p><h2 id="佩拉约"><a href="#佩拉约" class="headerlink" title="佩拉约"></a>佩拉约</h2><p>佩拉约（西班牙语：Pelayo，拉丁语：Pelagius，约685年－737年）685年出生于西班牙，他建立了阿斯图里亚斯王国，从718年开始统治直到去世。他在科法敦加战役的胜利，被视为“收复失地运动”的起点，基督徒从摩尔人手中收复伊比利亚半岛，从他建立独立的基督教西班牙国家对抗摩尔人政权开始，但是并没有强力的证据证明他的目的是复兴过去的西班牙王国或者只是因为任何宗教渴望的刺激。</p><h2 id="源义经"><a href="#源义经" class="headerlink" title="源义经"></a>源义经</h2><p><img src="/images/IMG20220922-2.png" alt=""></p><p>源义经（1159年—1189年6月15日），幼名牛若（うしわかまる）。日本传奇英雄，平安时代末期的名将。出身于河内源氏的武士，家系乃清和源氏其中一支，河内源氏的栋梁源赖信的后代。为源义朝的第九子，源赖朝之弟。<br>源义经之父源义朝在平治之乱中为平清盛所败后，源义经在七岁时被送到京都鞍马寺学习，改名遮那王。之后投奔奥州，受到奥州藤原氏当主藤原秀衡的庇护。承治四年（1180年），源义经与同父异母的兄长源赖朝一齐举兵讨伐平家，在著名的战役源平合战中战功彪炳，威名显赫。但也因功高震主为源赖朝所猜忌，最终兄弟反目成仇。源赖朝得到后白河天皇的院宣后，在全国发布通缉命令追捕源义经。源义经在走投无路之下再度投靠藤原秀衡，藤原秀衡死后，其子藤原泰衡开始排挤源义经。文治五年（1189年），源赖朝亲自率兵讨伐平泉。迫于源赖朝之压力，藤原泰衡把枪口转向了源义经。源义经最后在衣川馆自尽。<br>源义经为日本人所爱戴的传统英雄之一，而且由于其生涯富有传奇与悲剧的色彩，在许多故事、戏剧中都有关于他的描述，在许多神社中也奉祀著源义经。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Yeremenko</title>
      <link href="/66.History/Yeremenko/"/>
      <url>/66.History/Yeremenko/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Yeremenko.png" alt="../_images/Yeremenko.png"></p><p>这张照片的拍摄者是 Max Vladimirovich Alpert（Макс Влади́мирович А́льперт），Max Alpert 后来回忆拍摄于 1941——1943 年间，对照片中军装进行分析后发现不同于 M43 式军装，所以应该也不是 1943 年拍摄。作者并不知道照片中人物的信息，但并不能就此认为照片中信息为宣传系统的杜撰——战争时期苏联并未将其宣传为“牺牲的政治委员”，而只是单纯地描述为 Комбат。</p><p>直到战后第 29 年，原伏罗希洛夫格勒、现卢甘斯克地区一户家庭写信给作者，认为这是他们的家人 Oleksiy Hordiyovych Yeremenko（Єременко Олексій Гордійович），共青团真理报与作者和当地政府联系，通过战前照片对比，以及亲历战斗的当事人回忆，认为 Oleksiy Hordiyovych Yeremenko 是照片上的人。</p><p>Oleksiy Hordiyovych Yeremenko 当时是苏联第 18 军第 4 步兵师第 220 步兵团下属政治委员，1942 年 7 月 12 日在伏罗希洛夫格勒地区霍罗舍村带领部队反攻时阵亡。 两名健在的这场战斗的参与者——隶属于第 285 师的 Vasily Sevastianovich 中校，以及同属于第 220 步兵团并在后来接替 Yeremenko 政委职务的 Alexander Matvajevich Makarov 少校接受了共青团真理报、伏罗希洛夫格勒地区政府和 Yeremenko 家人的质询和联合调查，各自独立描述了当时的情况并相互印证。而最具决定性的证据来自拍摄者 Max Vladimirovich Alpert 本人——1942 年 7 月，他正是在伏罗希洛夫格勒地区进行战地摄影。相关调查结果发表于苏联 1987 年 11 月《科学与生活》杂志。苏联政府在调查结束后向 Yeremenko 的家人发布了更新后的阵亡通知。</p><p>作者：Exotic Hadron<br>链接：<a href="https://www.zhihu.com/question/39071432/answer/805757644" target="_blank" rel="noopener">https://www.zhihu.com/question/39071432/answer/805757644</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 66.History </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电影和电视剧list</title>
      <link href="/65.Movies/%E7%94%B5%E5%BD%B1list/"/>
      <url>/65.Movies/%E7%94%B5%E5%BD%B1list/</url>
      
        <content type="html"><![CDATA[<p>★★★★★</p><ul><li>阳光灿烂的日子</li><li>少年派</li><li>地球最后的夜晚</li><li>她 / Her</li></ul><p>★★★★</p><ul><li>两杆大烟枪</li><li>低俗小说</li><li>银翼杀手</li><li>头号玩家</li><li>失控玩家</li><li><p>永无止境 / Limitless</p></li><li><p>角斗士</p></li><li>绿皮书</li><li>路边野餐</li><li>漫长的婚约</li></ul>]]></content>
      
      
      <categories>
          
          <category> 65.Movies </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>战时笔记-维特根斯坦</title>
      <link href="/64.Novel-and-Poesy/%E6%88%98%E6%97%B6%E7%AC%94%E8%AE%B0/"/>
      <url>/64.Novel-and-Poesy/%E6%88%98%E6%97%B6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>仅《战时笔记》的私人部分</p></blockquote><p>14.8.15<br>船上的船员是一群猪！没有任何志向，令人难以置信地粗俗、愚蠢、邪恶，因此以下说法自然不成立：一项共同的伟大事业必然使人变得高尚</p><p>14.9.2<br>几乎完全没有感性上的要求，以前我总是想象着是在与一个朋友交谈，但是几乎没有这样的事了</p><p>14.9.12<br>我总是一再地在心中对自己说托尔斯泰的如下一段话：一个人从肉体上说是软弱无力的，但是经由精神他成为自由的</p><p>14.9.15<br>削土豆皮之于我就如同磨镜片之于斯宾莎诺一样</p><hr><p>《笔记》中反复提到的：感性上的需求、打飞机、工作（志愿兵的工作是？）——“工作了一些时间”，“今天几乎没有工作”、还没有获得那个‘综览’</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>S01.博尔赫斯</title>
      <link href="/64.Novel-and-Poesy/S01.%E5%8D%9A%E5%B0%94%E8%B5%AB%E6%96%AF/"/>
      <url>/64.Novel-and-Poesy/S01.%E5%8D%9A%E5%B0%94%E8%B5%AB%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="我用什么才能留住你（1934）"><a href="#我用什么才能留住你（1934）" class="headerlink" title="我用什么才能留住你（1934）"></a>我用什么才能留住你（1934）</h2><p>我用什么才能留住你<br>我给你萧索的街道、绝望的落日、荒郊的月亮。<br>我给你一个久久地望着孤月的人的悲哀。<br>我给你我已死去的祖辈，后人们用大理石祭奠的先魂<br>我父亲的父亲，阵亡于布宜诺斯艾利斯的边境，两颗子弹射穿了他的胸膛，死的时候蓄着胡子，尸体被士兵们用牛皮裹起；<br>我母亲的祖父——那年才二十四岁——在秘鲁率领三百人冲锋，如今都成了消失的马背上的亡魂。<br>我给你我的书中所能蕴含的一切悟力，以及我生活中所能有的男子气概和幽默。<br>我给你一个从未有过信仰的人的忠诚。<br>我给你我设法保全的我自己的核心——不营字造句，不和梦交易，不被时间、欢乐和逆境触动的核心。<br>我给你早在你出生前多年的一个傍晚看到的一朵黄玫瑰的记忆。<br>我给你关于你生命的诠释，关于你自己的理论，你的真实而惊人的存在。<br>我给你我的寂寞、我的黑暗、我心的饥渴；我试图用困惑、危险、失败来打动你。</p><h2 id="关于天赐的诗——天堂应该是图书馆的模样"><a href="#关于天赐的诗——天堂应该是图书馆的模样" class="headerlink" title="关于天赐的诗——天堂应该是图书馆的模样"></a>关于天赐的诗——天堂应该是图书馆的模样</h2><p>上帝同时给我书籍和黑夜，这可真是一个绝妙的讽刺，<br>我这样形容他的精心杰作，且莫当成是抱怨或者指斥。<br>他让一双失去光明的眼睛主宰起这卷册浩繁的城池，<br>可是，这双眼睛只能浏览那藏梦阁里面的荒唐篇什，<br>算是曙光对其追寻的赏赐。<br>白昼徒然奉献的无数典籍，<br>就像那些毁于亚历山大的晦涩难懂的手稿一般玄秘。</p><p>有位国王傍着泉水和花园忍渴受饥，<br>那盲目的图书馆雄伟幽深，我在其间奔忙却漫无目的。<br>百科辞书、地图册、东方和西方、世纪更迭、朝代兴亡、经典、宇宙及宇宙起源学说，<br>尽数陈列，却对我没有用场。</p><p>我心里一直都在暗暗设想，天堂应该是图书馆的模样</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R02.阿赫玛托娃</title>
      <link href="/64.Novel-and-Poesy/R02.%E9%98%BF%E8%B5%AB%E7%8E%9B%E6%89%98%E5%A8%83/"/>
      <url>/64.Novel-and-Poesy/R02.%E9%98%BF%E8%B5%AB%E7%8E%9B%E6%89%98%E5%A8%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Anna%20Akhmatova.png" alt=""></p><h2 id="缪斯"><a href="#缪斯" class="headerlink" title="缪斯"></a>缪斯</h2><p>深夜，我等着她的来临，<br>好像我的生命十分危险。<br>什么荣誉，什么青春，什么自由，<br>都摆在这位手持诗笛的可爱客人面前。</p><p>她来了！她撩开披巾，<br>仔细看了看我。<br>我对她说：“是你给但丁口授了地狱篇？”<br>她回答：“是我。”</p><h2 id="致缪斯"><a href="#致缪斯" class="headerlink" title="致缪斯"></a>致缪斯</h2><p>缪斯姐姐望了我一眼，<br>她的目光清澈又晶莹。<br>她还夺走了我的金戒指，<br>我的第一件春日的礼品。</p><p>缪斯！你看世人是多么幸福——<br>无论是少女、少妇，还是寡妇……<br>我宁愿在尘寰中死去，<br>也强似遭受这种幸福的桎梏。</p><p>尽管我也会去采撷<br>那一朵稚嫩的雏菊；<br>但在这人世间我命定要忍受<br>每一次失恋的痛苦。</p><p>伴着窗前的烛光燃到清晨，<br>我内心并不思念任何人，<br>我并不想、并不想、并不想知道<br>世人怎样把别的少女亲吻。</p><p>明天的镜子面前，我将受到嘲讽：<br>“你的目光既不清澈，又不晶莹……”<br>那我要轻声地回答：<br>“是缪斯夺去了上帝赐予的礼品。”</p><h2 id="没有英雄人物的叙事诗"><a href="#没有英雄人物的叙事诗" class="headerlink" title="没有英雄人物的叙事诗"></a>没有英雄人物的叙事诗</h2><p>null</p><h2 id="黄昏"><a href="#黄昏" class="headerlink" title="黄昏"></a>黄昏</h2><p>null</p><h2 id="北方哀歌"><a href="#北方哀歌" class="headerlink" title="北方哀歌"></a>北方哀歌</h2><p>根本没有玫瑰色的童年……<br>没有雀斑、没有小熊、没有玩具，<br>没有慈祥的姑姑，也没可怕的叔叔，<br>甚至小河碎石中间也没有朋友。<br>我从小就觉得自己是<br>某人的梦，某人的呓语，<br>或者是某人镜中的身影，<br>没有名字，没有血肉，<br>没有发生过什么事情，<br>我已经晓得了我应当<br>犯的种种罪行。<br>于是我，像梦游者迈动脚步，<br>踏入人生，使人生为之一怔：<br>它在我面前变成草原一片，<br>成了当年普罗塞尔平娜在这儿散步的地方，<br>两扇大门突然在我这个无亲无故、<br>笨手笨脚的人的面前敞开，<br>人们从门里走了出来，口中喊道：<br>“她来了，她本人来了！”<br>我惊奇地望着他们，<br>心里想：“他们疯了！”<br>他们越是赞美我，<br>越是夸奖我，<br>我就越觉得在世界上生活可怕，<br>我就越想从梦中苏醒过来。<br>我知道，像我这样的人，<br>在牢房里，在坟墓中，在疯人院，<br>在一切应当觉醒的地方，<br>应付出百倍代价，<br>可是却长期忍受着幸福的煎熬。</p><hr><p>这里，我们全是酒鬼和荡妇，<br>我们在一起多么郁闷！<br>连壁画上的鲜花和小鸟<br>也在思念流动的云彩。</p><p>你抽着一管黑色的烟斗，<br>缭绕的烟雾那样神奇。<br>我穿着狭窄的衬裙，<br>让身材显得更加俏丽。</p><p>几扇小窗永远被钉死，<br>是担心雾淞，抑或是雷电？<br>你那机敏的眼睛<br>如同一对警惕的猫眼。</p><p>啊，我的心多么忧伤！<br>莫非在等待死期的来临？<br>那个如今正在跳舞的女人，<br>她命中注定要下地狱。</p><hr><p>在人们的亲近中存在隐秘的界限，<br>爱慕和激情也不能将它跨越，――<br>哪怕嘴唇在不安的寂静里相互融合，<br>哪怕心灵由于爱情而一片片碎裂。</p><p>友谊在此软弱无力，崇高<br>与炽热的幸福填充了岁月，<br>灵魂是自由的，不懂得<br>情欲那迟缓的慵懒。</p><p>它的追求者丧失理智，而它的<br>占有者却因此苦恼不堪……<br>如今，你该明白，为什么<br>我的心脏不在你的手掌下跳动。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R01.安魂曲</title>
      <link href="/64.Novel-and-Poesy/R01.%E5%AE%89%E9%AD%82%E6%9B%B2/"/>
      <url>/64.Novel-and-Poesy/R01.%E5%AE%89%E9%AD%82%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<p>献　词</p><p>在这哀痛面前高山会低头，<br>滔滔的江水也会静止不流，<br>但重重牢门依然紧紧地关闭，<br>门后是“苦役犯阴暗的炕头”，<br>还有那致人死命的哀愁。<br>和风究竟为谁轻轻吹拂，<br>夕阳究竟给谁舒开眉头——<br>对此我们概不知晓，<br>我们到处听见的声音<br>只是钥匙在门锁上刺耳的转动，<br>还有士兵的皮靴声声沉重。<br>我们像赶晨祷一样早起，<br>穿过变得野性的都城，<br>在那儿聚集，比死人还缺乏生气，<br>太阳低低，涅瓦河雾气濛濛，<br>然而希望却在远方歌唱。<br>宣告判决……当即泪水夺眶，<br>我已经远离了一切人，<br>仿佛有一种挖心般的剧痛，<br>仿佛是被粗野地推倒在地，<br>可依然前行……步履蹒跚……孤孤单单。<br>在那两年险恶时光中的女难友们，<br>如今又都流落在何处何方？<br>她们有什么幻觉，<br>在那西伯利亚的暴风雪中？<br>她们又仿佛看到了什么，<br>在那月亮圆圆的时候？<br>我把惜别的情意送到她们心头。<br>　　　　　　　　　　　　　　　　　　　　 （1940.3.）</p><p>序曲</p><p>这事情发生的时候，<br>唯有死人才会高兴，<br>高兴他获得了安宁。<br>列宁格勒像多余的废物，<br>在自己的监狱周围彷徨，<br>被判罪的人走着，成队成行，<br>苦难的折磨使他们神情癫狂，<br>火车的汽笛短促地<br>把离情别绪吟唱。<br>在沾满鲜血的皮靴下，<br>在囚车黑色的轮胎下，<br>无辜的罗斯在痛苦挣扎，<br>死亡的星辰高悬在我们头上。<br>　<br>你被带走正是黎明时分，<br>我跟在你的身后，像送殡一样。<br>小儿女在狭窄的房内啼哭，<br>神龛前是一支滴泪的烛光。<br>圣像在你双唇上留下一丝凉意，<br>临终的冷汗在你的额角上流淌……<br>不能忘啊不能忘！——<br>我要像弓箭手的妻子那样，<br>哭倒在克里姆林塔楼之旁。</p><p>（1935.秋.莫斯科）</p><p>静静的顿河静静地流，<br>昏黄的月色照入楼。<br>　<br>昏黄的月色歪戴着帽，<br>走进屋来照见人身影。<br>　<br>这个女人身染疾病，<br>这个女人孤苦伶仃。<br>　<br>丈夫已去儿入狱，<br>请为我祈祷上帝。<br>　<br>不，这并不是我，<br>这是受苦受难的另一个。<br>假如是我怎能忍受，<br>那简直是祸从天落，<br>让黑色的呢绒将它遮住，<br>让人们拿走所有的灯火……<br>只留下茫茫夜色。<br>　<br>你是爱取笑别人的人，<br>你是所有朋友的宠儿，<br>你是皇村开心的犯戒者，<br>如今要让你明白，<br>你一生的境遇又将如何——<br>你要站在克列斯特铁窗旁边，<br>排在三百号，手托探监的物品，<br>滴下你滚滚的热泪，<br>烤化新年的冰层。<br>像监狱的那株白杨摇曳，<br>无声无息——而大墙里<br>有多少无辜的生命在死去……</p><p>（1938）</p><p>我高声哀号十七个月，<br>千呼万唤你回家，<br>我匍伏在刽子手的脚下，<br>我的儿子啊，你使我担惊受怕。<br>一切似乎都永远黑白颠倒，<br>现在我已无法分得一点不差，<br>谁个是人，谁个是兽，<br>死刑究竟还要等待多久。<br>只有摇炉散香之声，<br>还有鲜花团团簇簇，<br>脚印一个又一个，<br>伸向某个茫然不知的去处。<br>一颗巨大的星星<br>以行将毁灭相威胁<br>直眉瞪眼地把我看住。</p><p>（1939）<br>　<br>一周一周轻轻掠过。<br>发生了什么，总是一片迷茫，<br>儿子啊，他们日夜盯着你<br>如何进入牢房，<br>他们又以怎样的凶恶目光<br>像鹰隼一样把你张望。<br>说着你那高高的十字架，<br>议论着你的死亡。 　　　　　　　　　　　　　　　　　　　　</p><p>（1939.春.）</p><p>判决</p><p>巨石般的词句压向<br>我一息尚存的胸膛，<br>没什么，我已经有了准备，<br>无论怎样我都能承当。<br>今天我有很多事要做，<br>我要让记忆断根绝蒂，<br>我要使心灵变成石头，<br>我要把生活重新学习。<br>可是……夏日炎炎的噪音，<br>好像过节在我窗前声声不断。<br>我早已预感会有这晴朗的一天，<br>和那空空荡荡的房间。</p><p>（1934.夏.喷泉居）</p><p>致死神</p><p>你迟早要来——为何不是现在？<br>我非常艰难地将你等待。<br>我熄灯灭火为你把门敞开，<br>你是如此普通，又是这般奇怪。<br>随便你采用什么形式进来，<br>是像一枚浸过毒汁的炮弹落下，<br>或是像手持哑铃的惯匪偷偷地进来，<br>或是化作伤寒的烟雾散开。<br>还是带着熟悉到令人恶心的<br>你编造出来的谎言——<br>让我在天蓝色的帽子上方<br>看见房管员那吓得苍白的脸。<br>如今这一切对我都无所谓。<br>叶尼塞河波涛滚滚，<br>北极星亮光熠熠。<br>心爱者双眸中那蓝色的火花<br>遮蔽住最后的畏惧。</p><p>（1939.8.19.喷泉居）</p><p>疯狂已用一侧翅膀<br>把心灵的一半遮住，<br>灌我以灼热的酒浆<br>招引我走向黑色的深谷。<br>　　　<br>我心中非常清楚<br>我该把胜利让给它，<br>倾听着自己的呓语，<br>似乎是他人的胡话。<br>　<br>（无论我如何哀求，<br>不管我怎样恳求）<br>它也不肯点头应允<br>我把任何东西带走：<br>无论是儿子恐惧的眼神——<br>那麻木不仁的痛苦，<br>还是那雷雨临头的日子，<br>和那监狱相会的时候。<br>无论是亲爱者双手留下的凉意，<br>无论是那动人心弦的菩提树荫，<br>还是那最后慰藉的话语——<br>从远方传来的轻微声音。</p><p>（1940.5.4.）<br>　<br>钉十字架</p><p>“母亲，不要为我哭泣，<br>我还呆在棺材里。”</p><p>I</p><p>天使高歌赞颂伟大的时刻，<br>而苍穹却溶化在烈火之中。<br>我对父亲说：“为什么把我遗弃！”<br>而对母亲说：“啊，不要为我哭泣……”<br>　　　　　　　　　　　　　<br>II</p><p>马格达利娜捶胸痛哭，　　　　　<br>心爱的门徒化作了石头，　　<br>而母亲默默伫立的地方，　　<br>却无人敢把目光相投。　　</p><p>尾声</p><p>I</p><p>我知道，我的容颜是怎样的消瘦，<br>眼睑下闪现着何等的惊忧，<br>痛苦是如何在双颊上<br>描绘出粗硬的楔形纹皱，<br>满头浅灰色和浓黑色的卷发<br>如何突然变得白发满头，<br>微笑在柔顺的双唇上枯萎，<br>恐惧之情在干笑声中颤抖。<br>我不是只为我一个人祈祷，<br>而是为了所有的那些人们，<br>他们同我一起站在耀眼的红墙下，<br>无论是冬日的严寒<br>还是七月的酷暑。<br>　　　　　　　　　　　　　　<br>II</p><p>举哀的时刻又已临近。<br>我看着，听着，感觉着你们：<br>　　　<br>既有那位被人扶到窗口的女人，<br>也有那位不能踏上故土的女性，<br>　<br>还有那位摇着头的女子是多么美丽，<br>她曾经说过：“来这就像回到家里。”<br>　　　<br>我本想把她们的名字一一说出。<br>无奈名单已被夺去，无从得悉。<br>　<br>我为她们织就一块宽大的裹尸布，<br>用偷偷听到的她们的只言片语。<br>　<br>我随时随地都把她们回忆，<br>哪怕新的灾难临头也不会忘记，<br>　<br>即使我历尽磨难的嘴被堵住，<br>亿万人民也会用我的呼喊抗议，<br>　<br>在我命丧黄泉之日的前夕，<br>就让他们对我这样致悼念之意。<br>　<br>如果有朝一日在这个国家里，<br>有人想为我把纪念碑竖立，<br>　<br>但只有在这样一个条件之下，<br>我同意以此来纪念胜利——<br>　　　<br>不要立在我出生的海边，<br>我与大海已经断绝联系，<br>　<br>不要立在皇村花园朝思暮想的树桩旁，<br>因为令人心碎的影子在那里把我寻觅，<br>　<br>把它立在我站过三百小时的地方，<br>在那里门栓从来不曾为我开启。<br>　<br>因为在获得解脱的死亡之中，<br>我害怕会把黑色囚车的嘶鸣忘记。<br>　<br>我害怕忘却那令人可憎的牢门关闭声，<br>和那老妇人如负伤野兽般的哀泣。<br>　<br>要让那不会转动的青铜眼帘，<br>流下溶化的雪水，像泪水滴滴，<br>　<br>让监狱的鸽子到远方去飞翔，<br>让船只在涅瓦河上静静地游弋。</p><p>（1940.3.）</p><hr><p>@link: <a href="/64.Novel-and-Poesy/R02.阿赫玛托娃/" title="R02.阿赫玛托娃">R02.阿赫玛托娃</a></p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>魔兽世界系列</title>
      <link href="/64.Novel-and-Poesy/G01.%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C%E7%B3%BB%E5%88%97/"/>
      <url>/64.Novel-and-Poesy/G01.%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="《最后的守护者》"><a href="#《最后的守护者》" class="headerlink" title="《最后的守护者》"></a>《最后的守护者》</h2><p><img src="/images/IMG20220914.png" alt=""></p><p>最后的守护者<br>原著:Jeff Grubb 翻译:麦德三世(主要翻译)</p><h3 id="第一章-卡拉赞"><a href="#第一章-卡拉赞" class="headerlink" title="第一章 卡拉赞"></a>第一章 卡拉赞</h3><p>最后他们到了卡德加的住处。这里离那个宴会厅不是很远。“自己收拾一下吧，”摩洛斯 把手上的灯笼递给卡德加，“厕所在最里面。床下有个夜壶。好了以后到下面的厨房来一趟。 库克会给你热点菜的。”</p><p>卡德加的房间是契形的，更适合做修道院僧侣的悔过室(小黑屋 )而不是法师的。一边 墙边靠着一个狭窄的床，对面墙边则靠着一个同样狭窄的桌子，桌上有个空架子。另有一间 用来放东西的壁橱。卡德加都没打开自己的背包，直接将其扔进了壁橱，然后踱到同样奉行苗条主义的窗边。</p><p>窗户是镶铅条细薄玻璃，架在正中的转轴上。卡德加缓缓地推开半边窗，窗底凝固的润滑油像软泥一样被扯开。</p><p>这里的视点依然处于塔上非常高的位置，在双月的照耀下，塔周围的群山显得灰暗和裸露。从这个高度望出去，卡德加发现这里以前显然是座巨大的环形山，由于一直受到岁月的风化才变成如今这样。难道说某座大山被人从此地像拔蛀牙一样拔走了?还是因为周围的山生长太快，而中间的山几乎不生长，结果留下怎么一块神奇的地方?</p><p>卡德加怀疑麦迪文的母亲从太古时代就呆在这里了，亲眼看着大陆的升起、沉没，或是甚至经历过开天辟地。即使是以一个法师的标准来说，八百年也太长太长了。即便是活两百年，按教科书上所说，大部分的人类法师也都已经虚弱得像张薄纸一样，一碰就死了。七百五十五岁然后还生了个孩子!卡德加摇了摇自己的脑袋，怀疑麦迪文是不是在耍他?</p><p>卡德加脱下他的旅行斗篷，然后看了那间“最里面”的设施— —它们都很朴素。但还是有一大缸冷水、一个脸盆和一面失去了光泽的优质镜子。卡德加想试着用一个镜面法术来加 热那些水，不过最后还是决定由它去。</p><p>缸里的水质不错，卡德加换了套干净点的衣服后觉得舒服多了——一件舒适的及膝衬衫和一条健身裤。差不多可以动身了。他从行包里拿出一把小型餐刀 ，考虑了一会儿，将其塞入了一边靴筒里。</p><p>他回到走廊，才想起自己并不知道厨房在哪。兽栏那边好像不出产食物，因此厨房肯定是安排在塔里的。很可能在底层或者一二层，以便于用泵汲水。而且一定要很容易到达宴会厅，就算这个宴会厅可能不常用。</p><p>卡德加轻易的就摸索到了回到宴会厅楼座的路，但是他还得找到自己想象中的那个七歪八拐通往厨房的楼梯。于是他就得在宴会厅的数个出口中作出选择。卡德加选了看起来最有可能的一个，结果发现是条死路——只有一条走廊，末端就是一个没其它出口的空屋，和他 自己那间很像。他又选了一条路，结果类似。</p><p>第三次选择将这个年轻人带入了一场的战斗的中心地带。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
            <tag> 魔兽世界 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F03.加缪札记</title>
      <link href="/64.Novel-and-Poesy/F03.%E5%8A%A0%E7%BC%AA%E6%9C%AD%E8%AE%B0/"/>
      <url>/64.Novel-and-Poesy/F03.%E5%8A%A0%E7%BC%AA%E6%9C%AD%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="《Carnets》-1935-1951"><a href="#《Carnets》-1935-1951" class="headerlink" title="《Carnets》, 1935-1951"></a>《Carnets》, 1935-1951</h2><p>What gives value to travel is fear. It is the fact that, at a certain moment, when we are so far from our own country … we are seized by a vague fear, and an instinctive desire to go back to the protection of old habits … this is why we should not say that we travel for pleasure. There is no pleasure in traveling, and I look upon it more as an occasion for spiritual testing … Pleasure takes us away from ourselves in the same way as distraction, in Pascal’s use of the word, takes us away from God. Travel, which is like a greater and a graver science, <em>brings us back to ourselves</em>.</p><p>译：<br>旅行中最有价值的部分是恐惧。旅行者远离了家乡，一种模糊的恐惧感随之而来，他本能的渴望旧环境。正是在恐惧中，你变得敏感，外界的轻微的变动都令你颤抖不已，你的内心再度充满疑问，要探询自身存在的意义。人类的所有知识、情感、精神世界，不都因这追问而起？</p><p><a href="https://www.goodreads.com/quotes/898728-what-gives-value-to-travel-is-fear-it-is-the" target="_blank" rel="noopener">https://www.goodreads.com/quotes/898728-what-gives-value-to-travel-is-fear-it-is-the</a></p><h2 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h2><p>国内版本<a href="https://book.douban.com/subject/25959670/" target="_blank" rel="noopener">卡繆札記. III (豆瓣)/ 黄馨慧译</a>：</p><p>《卡謬札記》分為三卷，是1935年5月至1959年12月卡謬親自撰寫的最後書信、札記、隨筆，是了解世紀大師的經典代表作。</p><p>第一卷是卡繆自一九三五年五月至一九四二年二月的札記，是了解卡繆其人和思想不可或缺的典籍，也是理解其作品的重要關鍵，他在札記中寫下他的讀書雜感以及寫作構思的方式，其中有動人的哲學的思維。</p><p>《卡繆札記》的前二卷（一九三五－一九五一）在作者去世後不久即出版。但當年還有未曝光的筆記，正是第三卷的內容。</p><p>第三卷可看到《夏天》、《墮落》和《放逐與王國》的源起。我們也看到了作者對《反抗者》所掀起的激烈論戰如何反應。還有許多關於數個未及完成的寫作計畫：譬如一個寫茱莉‧萊比納斯的劇本，或是一個將浮士德和唐璜兩主題合而為一的劇本，當然，更有他已著手進行的《第一個人》。</p><p>卡繆在最後這幾本筆記中，較諸之前筆記寫下了更多他私人生活中的重要事件：希臘旅行、阿爾及利亞戰爭之慘烈，獲諾貝爾獎。這些筆記剛開始只是卡繆的寫作工具，到後來卻更像是他的日記。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F02.夏天集</title>
      <link href="/64.Novel-and-Poesy/F02.%E5%A4%8F%E5%A4%A9%E9%9B%86/"/>
      <url>/64.Novel-and-Poesy/F02.%E5%A4%8F%E5%A4%A9%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="《蒂巴萨的婚礼》"><a href="#《蒂巴萨的婚礼》" class="headerlink" title="《蒂巴萨的婚礼》"></a>《蒂巴萨的婚礼》</h2><p>《Noces à Tipasa》1936 - 1937<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p>走了几步，苦艾的气味就呛得我们喉咙难受。他那灰色的绒毛盖满了无际的废墟。它的精华在热气中蒸腾，从地上到天上弥漫着一片慷慨的酒气，天都为之摇晃了。<em>我们迎着爱情和欲望走去。我们不寻求什么教训，也不寻求人们向伟大所要求的那种苦涩的哲学。阳光之外，亲吻之外，原野的香气之外，一切对我们来说都微不足道。</em> 对于我，我不想一个人独自来到这里。我经常和我喜欢的那些人一起来，我在他们脸上看到了明媚的微笑。这里，我把秩序和节制留给别人去说。这是自然的大放纵，这是大海的大放纵，我整个儿地被抓住了。</p><hr><p>我在这里明白了什么是光荣，那就是无节制的爱的权利。在这个世界上只有一种爱情。抱紧一个女人的躯体，这也是把从天空降下的大海的那种奇特的快乐留在自己身上。刚才，当我想扑向一丛苦艾，让它的芬芳进入我的身体时，我应该不顾一切偏见地意识到，我正在完成一桩真理，这既是太阳的真理，也是我的死亡的真理。从某种意义上说，我在这里玩耍的，正是我的生命，这生命散发着火热的石头的气味，充满了大海和刚刚开始鸣叫的蝉的叹息。</p><h2 id="《重返蒂巴萨》"><a href="#《重返蒂巴萨》" class="headerlink" title="《重返蒂巴萨》"></a>《重返蒂巴萨》</h2><p>《Retour à Tipasa》1959<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p><p>正午，我站在半沙半土的山坡上，望着大海。山坡上长满了天芥菜，那一片片的天芥菜，仿佛近几个月激浪退下时留下的水沫。大海这时已筋疲力尽，翻腾不动了。我消除了两种干渴，这两种干渴是不能长久欺骗的，除非一个人变得冷酷无情。这两种干渴就是美和赞叹。因为惟有不被爱才是厄运，惟有不爱才是不幸。今天，我们大家都死于这种不幸；因为鲜血和仇恨使心失去血肉，对于正义的长久要求耗尽了爱，而正义却恰恰产生于爱。我们生活在喧嚣中，在这喧嚣中，爱是不可能的，而只有正义也是不够的；因此，欧洲憎恨白昼，只知道给自己以不义。但是，为了不使正义变得萎缩，变成一枚果肉干而涩的橙子，我在蒂巴萨重新认识到，必须在自己身上保留一种新鲜和一股快乐的源泉，使之不受污损，必须钟爱逃脱了不义的白昼，必须怀着这种争得来的光明投入战斗。我在这里重新发现了过去的美和一片年轻的天空，我掂量着我的运气，终于明白了，在我们的疯狂肆虐的那些年里，对于这一片天空的回忆从未离开过我。是这回忆最终使我不绝望。我一直清楚蒂巴萨的废墟比我们的工地和瓦砾都年轻。在这里，世界每天都在一片常新的光明中重新开始。啊，光明！这是古代戏剧中所有人物面对着命运发出的呼喊。这最后的依靠也是我们的依靠，我现在明白了。<em>在隆冬，我终于知道了，我身上有一个不可战胜的夏天。</em></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://fr.wikipedia.org/wiki/Noces_(Albert_Camus)" target="_blank" rel="noopener">https://fr.wikipedia.org/wiki/Noces_(Albert_Camus)</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.arts.chula.ac.th/doc/pr/2.pdf" target="_blank" rel="noopener">https://www.arts.chula.ac.th/doc/pr/2.pdf</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F01.西西弗神话</title>
      <link href="/64.Novel-and-Poesy/F01.%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/"/>
      <url>/64.Novel-and-Poesy/F01.%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>真正严肃的哲学问题只有一个，那便是自杀。判断人生值不值得活，等于回答哲学的根本问题。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D02.里尔克诗选</title>
      <link href="/64.Novel-and-Poesy/D02.%E9%87%8C%E5%B0%94%E5%85%8B%E8%AF%97%E9%80%89/"/>
      <url>/64.Novel-and-Poesy/D02.%E9%87%8C%E5%B0%94%E5%85%8B%E8%AF%97%E9%80%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Rilke.png" alt=""></p><p><a href="https://book.douban.com/subject/26438579/" target="_blank" rel="noopener">杜伊诺哀歌 (豆瓣)</a></p><blockquote><p>《Duino Elegies》第一首哀歌1912年起稿于杜伊诺城堡，经历长久的等待之后，在1922年的穆佐城堡，里尔克于八天之内完成了整部诗集。十首哀歌构成了一个整体，直观合而为一的生与死。诗人本人称《杜伊诺哀歌》是“奇迹”和“恩典”。</p></blockquote><hr><h2 id="《哀歌之一》"><a href="#《哀歌之一》" class="headerlink" title="《哀歌之一》"></a>《哀歌之一》</h2><p>如果我叫喊，谁将在天使的序列中</p><p>听到我？即使他们之中有一位突然</p><p>把我拥到他胸前，我也将在他那更强大的</p><p>存在的力量中消失。因为美不是什么</p><p>而是我们刚好可以承受的恐怖的开始，</p><p>而我们之所以这样赞许它是因为它安详地</p><p>不屑于毁灭我们。每一位天使都是可怕的。</p><p>因此我抑制自己，吞下深处黑暗的</p><p>呜咽的叫声。啊，我们需要时</p><p>可以求助于谁？不是天使，不是人；</p><p>就连那些知道的野兽也意识到</p><p>在这个被解释的世界我们</p><p>并不感到很安全。也许仍有</p><p>某棵树留在斜坡上，供我们日夜观看，</p><p>仍有为我们留下的昨天的散步和对于一个习惯的</p><p>长期效忠，这习惯一旦跟我们住下便不愿离开。</p><p>哦，还有黑夜，那黑夜，当一阵充满无限空间的风</p><p>啃起我们的脸。黑夜为了谁而不留下——这想望已久的、</p><p>温和的、不报幻想的存在，这颗孤寂的心</p><p>与它相会是如此痛苦。难道情人们就更容易些吗？</p><p>但是他们继续利用彼此来隐藏各自的命运。</p><p>难道你还不知道吗？将你怀中的虚空抛进</p><p>我们呼吸的空间；也许鸟儿们</p><p>会带着更热情的飞翔感到这扩大的空气。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D01.给青年诗人的信</title>
      <link href="/64.Novel-and-Poesy/D01.%E7%BB%99%E9%9D%92%E5%B9%B4%E8%AF%97%E4%BA%BA%E7%9A%84%E4%BF%A1/"/>
      <url>/64.Novel-and-Poesy/D01.%E7%BB%99%E9%9D%92%E5%B9%B4%E8%AF%97%E4%BA%BA%E7%9A%84%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>1902年，青年卡卜斯就读于维也纳新城陆军学校，还未满二十岁，他已经感受到了职业带来的压力。像任何一个处在人生转折时期的年轻人一样，卡卜斯对于未来的人生充满疑虑，而眼下更要紧的，是如何处理职业道路与个人意趣之间的矛盾。在私人生活中，他爱好读书，也尝试写作，一次偶然的机会，他了解到自己所喜爱的诗人里尔克年轻时也有过一段和自己相似的遭遇——在陆军学校读书，喜欢寂寞，忍受着宿舍生活的压抑……而如今，他已经是一名成熟的诗人，这让卡布斯倍感宽慰。他立即决定把自己的诗寄给里尔克看，同时附上一封信，向前辈坦言自己内心的动荡。</p><p>很快，卡卜斯收到了回信。此后的五年间，二人持续保持着通讯，在一来一往的信件中，里尔克不仅对创作和诗艺提出了深度的见解，对于文学领域之外一切与人生有关的话题，他也毫无保留地向这位身处困顿中的青年人告知自身的经验，希望他能够更加耐心地对待成长中的苦闷，追求生活的真意。里尔克或许未曾想过，这些信件会在日后集结成册，传递给一代又一代的青年人。如今，《给青年诗人的十封信》已是世界范围内的经典之作，它所面对的受众远不只是渴望成为诗人的青年，而是所有徘徊在审美、信仰、寂寞、爱与真理的边缘，尚未将深度和意义赋予生活的人们。</p><h2 id="第四封信"><a href="#第四封信" class="headerlink" title="第四封信"></a>第四封信</h2><p>这里周围是伟大的田野，从海上吹来阵阵的风，这里我觉得，那些问题与情感在它们的深处自有它们本来的生命，没有人能够给你解答；因为就是最好的字句也要失去真意，如果它们要解释那最轻妙、几乎不可言说的事物。</p><p>…</p><p>身体的快感是一种官感的体验，与净洁的观赏或是一个甜美的果实放在我们舌上的净洁的感觉没有什么不同；它是我们所应得的丰富而无穷的经验，是一种对于世界的领悟，是一切领悟的丰富与光华。</p><p>我们感受身体的快感并不是坏事；所不好的是：几乎一切人都错用了、浪费了这种经验，把它放在生活疲倦的地方当作刺激，当作疏散，而不当作向着顶点的聚精会神。就是饮食，也有许多人使之失去本意：一方面是“不足”，另一方面是“过度”，都搅浑了这个需要的明朗；同样搅混的，是那些生命借以自新的一切深的、单纯的需要。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C14.动物凶猛</title>
      <link href="/64.Novel-and-Poesy/C14.%E5%8A%A8%E7%89%A9%E5%87%B6%E7%8C%9B/"/>
      <url>/64.Novel-and-Poesy/C14.%E5%8A%A8%E7%89%A9%E5%87%B6%E7%8C%9B/</url>
      
        <content type="html"><![CDATA[<p>那时侯，好像永远是夏天，太阳总是有空出来伴随着我，阳光充足，太亮，使得眼前一阵阵发黑。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C13.现代诗</title>
      <link href="/64.Novel-and-Poesy/C13.%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
      <url>/64.Novel-and-Poesy/C13.%E7%8E%B0%E4%BB%A3%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<p>《镜中》<br>只要想起一生中后悔的事<br>梅花便落了下来<br>比如看她游泳到河的另一岸<br>比如登上一株松木梯子</p><p>危险的事固然美丽<br>不如看她骑马归来<br>面颊温暖，<br>羞惭。低下头，回答着皇帝<br>一面镜子永远等候她<br>让她坐到镜中常坐的地方<br>望着窗外，只要想起一生中后悔的事<br>梅花便落满了南山</p><hr><p>现在，我只需把胸中的钝痛精细分辨<br>命名、加注、锁入正确的屉格：哪些眼泪是为<br>受苦的父亲而流，哪些为染霜的爱，又有哪些<br>仅仅出于颤栗，为这永恒广漠、无动于衷的星星监狱里<br>我们所有人的处境。假如每种精微的裂痛<br>都能如烦恼于唯识宗，找到自己不偏不倚的位置<br>如罪业于但丁的漏斗，它们将变得可以承受。</p><p>每种我不屑、不愿、不能倾诉的苦痛<br>都将郁结成棕色、橄榄色、水银色的香料<br>在时光的圣水瓶里酝酿一种奇迹。修辞术在受难的心前<br>隐遁无踪，言语尽是轻浮，假如不是为了自救<br>铺陈不可饶恕。假如可以带粉笔进入迷宫，以纯蓝<br>标记每一处通往灾祸的岔口：“我到过这儿<br>必将永不再受诱”，它们将变得可以承受。</p><p>假如我尝过的每种汞与砷<br>能使你免于读懂这首诗<br>——它们将变得可以承受，<br>小病号。</p><hr><h2 id="灵泊"><a href="#灵泊" class="headerlink" title="灵泊 "></a>灵泊 </h2><p>灵泊寒冷，我知道。<br>夏日末梢，我见到一名隐士<br>隐士和他金红的狐狸<br>獭白的猫，壁炉上涡旋的马蜂<br>油亮的葫芦，扎人的蓑衣<br>隐士的家中感觉不到寒冷<br>我们坐在花园里饮酒<br>被爬山虎吞噬的山墙不断落下<br>生脆的枯叶，湿润的蜗壳，半截壁虎<br>一只老鼠在近处翻检熟悉的宝物<br>我们坐在花园中，直到秋日的苹果纷纷滚落我的肩头<br>直到白葡萄失去麝香，梨失去她寒碜的红<br>直到我成全预言只身落入灵泊<br>好冷啊，这儿没有可以踩实的土<br>让我种一棵酸枣，回旋的雾淞<br>染蓝了一切，密密匝匝似负冲的水墨<br>灵泊里没有奇行的巨人，狼的眼珠，蝙蝠的尖喙<br>没有苦苦呼救的人，甚至没有灵魂受苦<br>幽蓝的轻霾折叠着自身，掠过沙漠松针<br>掠过雪原燃烧的褶皱，透视阻挠的云朵<br>而它们也认了罪，跌下来，晒作罂粟壳，被踩扁<br>发出崎岖的玻璃声；我光脚踏过云田<br>脸在雨衣里涨得通红，我精确地踩了又踩<br>身后是一畦装满鱼化石的脚印，我朝山阴走去<br>看见老鼠匆匆把脸藏进蔓蓉树冠<br>灵泊寒冷<br>每个知道秘密的人都应该保持沉默。</p><h2 id="布鲁斯"><a href="#布鲁斯" class="headerlink" title="布鲁斯"></a>布鲁斯</h2><p>我用左边肘窝想念巴黎，用肚脐，用盘突的脊柱<br>用胛骨间柔软的凹陷，我用十二指肠想念巴黎<br>我抵达前，巴黎是一船内脏缤纷的锦鲤<br>我被逐后，她是一屋子尖刀，一罐动脉，一井手影<br>我想念她的暴雨，当光之霰弹射向双偶咖啡馆的玻璃顶<br>我想念她的午后，当坏人们掸着烟灰等待天堂开演，而我是最坏一个<br>我想念她藤蔓的夜，当我被绞成浆果而时光成酒<br>我要跪下舔她梦的钢弦<br>我要晃动一只蔚蓝的小舟直到它载满淫棍，疯子和纵火犯<br>要它痛饮塞纳河水直到桅杆上升，处决着鹳鸟，捣毁黄道的驿站<br>为猎户座重新布棋，我用锁骨想念每列洞穿我的旧地铁<br>我想念因为我被禁止诉说吗，像那些深深嵌入生命的麻绳<br>碾磨出潋滟的碧玺，划出爱情一般空幻的光弧吗？<br>我知道在巴黎，所有的庆典都绝不可逆，地狱只能再现一次<br>在巴黎，爱神的名字在气球中浪笑，宇宙娼妇<br>扔掉阉人的风镐，在穹顶卷刃，在月食圆心与日珥摔跤。</p><h2 id="布鲁斯2-（天狼星）"><a href="#布鲁斯2-（天狼星）" class="headerlink" title="布鲁斯2 （天狼星）"></a>布鲁斯2 （天狼星）</h2><p>是谁吃了我的白日梦<br>是你吗，天狼星——<br>吞掉我的钢琴，啃断琴凳小腿，嘎吱嘎吱细嚼着<br>白键，配三个黑键，活泼地怨诉地，嚼碎了爱欲的手指饼<br>先要把琴谱舔湿，让它一页一页透明地映出<br>南国薄荷园，深谙归途的雀鸟，轻盈滑水的独角仙<br>然后伸出舌头，如歌地幽默地，环绕琴槌根部打圈<br>你会看到那儿升起了蓝紫色星星，小小的古尔德<br>扑捉着跌倒着，那笑脸你早看腻，对不对，天狼星？<br>所以还要吞下我的弓，我的蜜蜡松香，我的GDAE<br>还有指板，还有琴马，还有F孔下我曾用来填满自己的<br>桃符和谶语，友谊和阴茎，航海图与竹蜻蜓<br>我从没有像今天这么满，这么紧绷，这么含泪欲滴，请把我<br>请把我一点不留地吃完吧！我的河童恋人发间怒生仙人球<br>他不喜欢弦乐，不爱拿螳螂开玩笑，更痛恨艾瑞克·萨梯<br>我们的孩子终夜下着蛇梯棋，像三只下楼梯的荧光梨<br>悲怆地坚定地，向我习得落子无悔的本领<br>我必须找到我的老花镜，找到壁炉里的鱼罐头<br>这是他承诺的奖励。我用门牙撬罐头，庄严地生气勃勃地，渐强地，渐强地<br>——这黑压压的蜂群是什么，莫非我释放了地狱？<br>瞧你都干了什么，哦天狼星！！</p><h2 id="致未婚夫"><a href="#致未婚夫" class="headerlink" title="致未婚夫"></a>致未婚夫</h2><p>在半光的清晨，我睁开含雾的眼睛：<br>白如极地的窗棂<br>沙沙游走的4B铅笔——</p><p>坐在地上、轻咬下唇的你，表情专注得<br>让我害羞了。一千零一回，你笔端互为镜相的我<br>微微启口，露出小圆牙齿，渴慕远方</p><p>眼中没有航标；手臂耷拉于床沿，折断的桅杆般<br>伸向你：我知它凝白丰润，适合红麝串<br>以及浮世春宫，一切易凋零而不可惜之事</p><p>被你的画框固定。我们从此各自<br>把前尘扫除干净吗？旧相片、旧礼物，删订吻的<br>蛛网编年史；说声“是”多么简单，惟它通向的</p><p>不止是婚姻。在半光的黄昏我栽下一株酸枣<br>你在枝头点缀一捧翠鸟，无拘束点水滑翔的奥秘<br>在禽类的脚胫，缕缕看不见的银丝线</p><p>深入酸枣树底，根茎与卷须疾涌的幽旅：<br>时光总比地名、寓言总比写实<br>可靠吗？当你噙下我口中的海盐</p><p>在我们半是雨水、半是帆影的新居里。</p><h2 id="在托尔金墓前"><a href="#在托尔金墓前" class="headerlink" title="在托尔金墓前 "></a>在托尔金墓前 </h2><p>其实霍比特人和侏儒是你来不及装罐的<br>手工蜂蜜对吧，养蜂人冷灼的清晨也挖空<br>铜壶上歌唱的苹果，延宕他满有恩泽的噩梦</p><p>你溯回的香蕉船，泊在正被云朵拭去刻度的<br>牛津运河的钟面，黄水仙在舱顶狎着炊烟<br>石臼爱石杵，就入定成一酒窝青苔的弥勒像</p><p>在岸边，铁锈信箱含着铁锁，为你不定期的夜巡<br>它已九次咬破了舌根；你的书架透过舷窗翻动我：<br>几本洛布丛书，诗体《埃达》，古英语修辞字典</p><p>蜷成虫洞的泛黄地图，《奥菲爵士》的译稿摊开<br>至奥菲离开安全树荫的那一页，地下王国的壁龛里<br>瓶中胎儿且吞吐珠光：如果一间藏书室不能顺水漂流</p><p>瞪羚还会爱上松鼠吗？恐霉的不是怪兽与批评家<br>而我从未醒着跟随你，穿过默顿学院叹息的黄墙<br>平躺在安全的驳船，商议六分仪座的航向，此时索隆</p><p>也会是软心肠的臂状星云呢，在银河幽黯的齿缝间<br>他汇拢所有结构稳固的星座，为一个灵光永不消逝<br>咕噜也可安睡其中的圆圈；填补黑洞的精灵以三色堇</p><p>演绎圣三一，把它抛在墓石上，我的掌心渴望着荆棘：<br>“贝伦，贝伦，”千万雪珠在墓穴里深沉而温柔地滚动<br>“路西恩。”我假装聆听着宇宙中原谅一切的回声。</p><pre><code>--2013. 4</code></pre>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C12.贾樟柯电影手记</title>
      <link href="/64.Novel-and-Poesy/C12.%E8%B4%BE%E6%A8%9F%E6%9F%AF%E7%94%B5%E5%BD%B1%E6%89%8B%E8%AE%B0/"/>
      <url>/64.Novel-and-Poesy/C12.%E8%B4%BE%E6%A8%9F%E6%9F%AF%E7%94%B5%E5%BD%B1%E6%89%8B%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>  陌生之地总会带给我精神的穿越：回到过去，去到未来。沉入地心，或飞向太空。短暂的出走会让我和自己固有的生活告别。离开熟悉的朋友，离开说来说去好多年的话题，离开自己的专业，离开自己深信不疑的精神系统……出走是自我叛逆的契机，让自己流动起来，悬浮起来，倒置起来，让自己颠覆自己。</p><p>  窗外，夜幕将要降临北京，这座过于喧嚣的城市，无法迎接幽冷的月光。我突然想远行，乘着夜幕去到山西任意一个小城。那里城池千年，一定明月高挂。我知道我是想写东西了，在办公室找了一摞信纸，十几只用惯了的粗黑墨笔，决定到大同去。</p><p>  每次旅行都能激活我的想象，灵感像是藏着的野性，你必须将自己放虎归山。</p><hr><ul><li>加缪对旅行的感受： <a href="/64.Novel-and-Poesy/F03.加缪札记/" title="F03.加缪札记">F03.加缪札记</a></li><li>[[../62.Psychology/《存在主义心理治疗》读书笔记]] / 第三部《孤独》：“我们周围是一个由熟悉的事物和制度所构成的稳定世界，一个所有物体和个体都彼此多重连接的世界。我们被平静地诱导入一种熟悉的、亲切的归属感”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C11.我与地坛</title>
      <link href="/64.Novel-and-Poesy/C11.%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/"/>
      <url>/64.Novel-and-Poesy/C11.%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/</url>
      
        <content type="html"><![CDATA[<p>它等待我出生，然后又等待我活到最狂妄的年龄上忽地残废了双腿。四百多年里，它一面剥蚀了古殿檐头浮夸的琉璃，淡褪了门壁上炫耀的朱红，坍圮了一段段高墙又散落了玉砌雕栏，祭坛四周的老柏树愈见苍幽，到处的野草荒藤也都茂盛得自在坦荡。这时候想必我是该来了。十五年前的一个下午，我摇着轮椅进入园中，它为一个失魂落魄的人把一切都准备好了。那时，太阳循着亘古不变的路途正越来越大，也越红。在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。自从那个下午我无意中进了这园子，就再没长久地离开过它。我一下子就理解了它的意图。正如我在一篇小说中所说的：“在人口密聚的城市里，有这样一个宁静的去处，像是上帝的苦心安排。”</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
            <tag> 史铁生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C10.陆文夫-美食家</title>
      <link href="/64.Novel-and-Poesy/C10.%E9%99%86%E6%96%87%E5%A4%AB-%E7%BE%8E%E9%A3%9F%E5%AE%B6/"/>
      <url>/64.Novel-and-Poesy/C10.%E9%99%86%E6%96%87%E5%A4%AB-%E7%BE%8E%E9%A3%9F%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="美食家-1"><a href="#美食家-1" class="headerlink" title="美食家(1)"></a>美食家(1)</h2><p>　　朱自冶起得很早，睡懒觉倒是与他无缘，因为他的肠胃到时便会蠕动，准确得和闹钟差不多。眼睛一睁，他的头脑里便跳出一个念头：“快到朱鸿兴去吃头汤面！”这句话需要作一点讲解，否则的话只有苏州人，或者是只有苏州的中老年人才懂，其余的人很难理解其中的诱惑力。<br>　　那时候，苏州有一家出名的面店叫作朱鸿兴，如今还开设在怡园的对面。至于朱鸿兴都有哪许多花式面点，如何美味等等我都不交待了，食谱里都有，算不了稀奇，只想把其中的吃法交待几笔。吃还有什么吃法吗？有的。同样的一碗面，各自都有不同的吃法，美食家对此是颇有研究的。比如说你向朱鸿兴的店堂里一坐：“喂（那时不叫同志）！来一碗××面。”跑堂的稍许一顿，跟着便大声叫喊：“来哉，××面一碗。”那跑堂的为什么要稍许一顿呢，他是在等待你吩咐吃法：硬面，烂面，宽汤，紧汤，拌面；重青（多放蒜叶），免青（不要放蒜叶），重油（多放点油），清淡点（少放油），重面轻浇（面多些，浇头少点），重浇轻面（浇头多，面少点），过桥——浇头不能盖在面碗上，要放在另外的一只盘子里，吃的时候用筷子搛过来，好像是通过一顶石拱桥才跑到你嘴里……如果是朱自冶向朱鸿兴的店堂里一坐，你就会听见那跑堂的喊出一连串的切口：“来哉，清炒虾仁一碗，要宽汤、重青，重浇要过桥，硬点！”</p><h2 id="吃喝小引-2"><a href="#吃喝小引-2" class="headerlink" title="吃喝小引(2)"></a>吃喝小引(2)</h2><p>　　叫花子的头头把手一扬，叫花子们呼啦一声散开，我这个手提竹篮，倚门而立，饥肠辘辘的特殊叫花子便到了朱自冶的面前。这个叫花子所以特殊，是因为他知道一点地理历史，自由平等，还读过三民主义；他反对好吃，还懂得人的尊严。当叫花子呼啦一声散开而把我烘托出来的时候，我满腔怒火，汗颜满面，恨不得要把手中的竹篮向朱自冶砸过去！可是我得忍气吞声地从朱自冶的手中接过钞票，按照他的吩咐到陆稿荐去买酱肉，到马咏斋去买野味，到五芳斋去买五香小排骨，到采芝斋去买虾子鲞鱼，到某某老头家去买糟鹅，到玄妙观里去买油汆臭豆腐干，到那些鬼才知道的地方去把鬼才知道的风味小吃寻觅……</p><h2 id="美食家-24"><a href="#美食家-24" class="headerlink" title="美食家(24)"></a>美食家(24)</h2><p>　　杨中宝来了，是由他的孙子陪同来的。他先把我们的店里里外外看了一遍，不停地点头叫好，说是和过去简直不能比。特别是那宽大的厨房，冰箱，排气风扇，炊事用具，雪白的灶头，他当年在交际处也没有这种条件。我把所有菜单都请他过目，他看得十分仔细。</p><p>　　杨中宝开讲的时候，全店上下都来了，把个小会场挤得满满的。我请他解放思想，放开来讲，多讲缺点。可是杨中宝讲得很有分寸，入情入理：</p><p>　　“我看了，你们工作得蛮好。要说苏州的名菜，你们差不多全有了，烧得也好。缺点是原料不足和卖得太多引起的。这事很难办，现在吃得起的人太多，十块八块全不在乎。据讲有些名菜你们连听也没有听见过，这也难怪，一种菜往往会有很多名字。比如说苏州的‘天下第一菜’，听起来很吓人，其实就是锅巴汤……”</p><p>　　下面轰地一声笑起来了。</p><p>　　“就是锅巴汤，你们的菜单上天天有。有些名菜你们应该知道，但是不能入菜单，大量供应有困难。比如说鲃肺汤，那是用鲃鱼的肺做的。鲃鱼很小，肺也只有蚕豆瓣那么大，到哪里去找大量的鲃鱼呢？其实那鲃肺也没有什么吃头，主要是靠高汤、辅料，还得多放点味精在里面。鲃肺汤所以出名，那是因为国民党的元老于右任到木渎的石家饭店吃了一顿，吃后写了一首诗，诗中写道：‘老桂开花天下香，看花走遍太湖旁；归舟木渎犹堪记，多谢石家鲃肺汤。’从此石家饭店出了名，鲃肺汤也有了名气。有些名菜一半儿是靠怪，一半儿是靠吹。”</p><p>…</p><p>　　随着这一声叫喊夕大家的眼睛都看住池塘的南面，自古君子远庖厨也，厨房和书房隔着一池碧水。</p><p>　　电影开幕了：孔碧霞的女儿，那个十分标致的姑娘手捧托盘，隐约出现在竹木之间，几隐几现便到了石板桥的桥头。她步态轻盈，婀娜多姿，桥上的人夕水中的影，手中的盘，盘中的菜，一阵轻风似的向吃客们飘来，象现代仙女从月宫饭店中翩跹而来重该死的朱自冶竟然导演出这么个美妙的镜头，即使那托盘中是装的一盆窝窝头，你也会以为那窝窝头是来自仿膳，慈禧太后吃过的！</p><p>　　托盘里当然不是窝窝头，盖钵揭开以后，使人十分惊奇，竟然是十只通红的番茄装在雪白的瓷盘里。我也楞住了，按照苏州菜的程式，开头应该是热炒。什么炒鸡丁，炒鱼片，炒虾仁等等的，从来没见过用西红柿开头篁这西红柿是算菜还是算水果呢？</p><p>　　朱自冶故作镇静，把一只只的西红柿分进各人的碟子里，然后象变戏法似的叫一声“开！”立即揭去西红柿的上盖：清炒虾仁都装在番茄里！</p><p>　　人们兴趣盎然，纷纷揭盖。</p><p>　　朱自冶介绍了：“一般的炒虾仁大家常吃，没啥稀奇。几十年来这炒虾仁除掉在选料与火候上下功夫以外，就再也没有其它的发展。近年来也有用番茄酱炒虾仁的，但那味道太浓，有西菜味。如今把虾仁装在番茄里面，不仅是好看，请大家自品。注意，番茄是只碗，不要连碗都吃下去。”</p><p>　　我只得佩服了，若干年来我也曾盼望着多给人们炒几盘虾仁，却没有想到把虾仁装在番茄里。秋天的番茄很值钱，丢掉多可惜，我真想连碗都吃下去。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C05绿毛水怪</title>
      <link href="/64.Novel-and-Poesy/C05.%E7%BB%BF%E6%AF%9B%E6%B0%B4%E6%80%AA/"/>
      <url>/64.Novel-and-Poesy/C05.%E7%BB%BF%E6%AF%9B%E6%B0%B4%E6%80%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="我在荒岛上迎接黎明"><a href="#我在荒岛上迎接黎明" class="headerlink" title="我在荒岛上迎接黎明"></a>我在荒岛上迎接黎明</h2><p>我在荒岛上迎接黎明。太阳初升时，忽然有十万支金喇叭齐鸣。阳光穿过透明的空气，在喑蓝色的天空飞过。在黑暗尚未褪去的海面上燃烧着十万支蜡烛。我听见天地之间钟声响了，然后十万支金喇叭又一次齐鸣。我忽然泪下如雨，但是我心底在欢歌。有一柄有弹性的长剑从我胸中穿过，带来了剧痛似的巨大感。这是我一生最美好的时刻，我站在那一个门坎上，从此我将和永恒连结起。……因为确确实实地知道我已经胜利，所以那些燃烧的字句就在我眼前出现，在我耳中轰鸣。这是一首胜利之歌，音韵铿锵，犹如一支乐曲。我摸着水湿过的衣袋，找到了人家送我划玻璃的那片硬质合金。于是我用有力的笔迹把我的诗刻在石壁上，这是我的胜利纪念碑。在这孤零零的石岛上到处是风化石，只有这一片坚硬而光滑的石壁。我用我的诗把它刻满，又把字迹加深，为了使它在这人迹罕到的地方永久存在。</p><p>我小的时候，常有一种冰凉的恐怖使我从睡梦中惊醒，我久久地凝视着黑夜。我不明白我为什么会死。到我死时，一切感觉都会停止，我会消失在一片混沌之中。我害怕毫无感觉，宁愿有一种感觉会永久存在。哪怕它是疼。</p><p>长大了一点的时候，我开始苦苦思索。我知道宇宙和永恒是无限的，而我自己和一切人一样都是有限的。我非常非常不喜欢这个对比，老想把它否定掉。于是我开始思考是否有一种比人和人类都更伟大的意义。想明白了从人的角度看来这种意义是不存在的以后，我面前就出现了一片寂寞的大海。人们所做的一切不过是些死前的游戏……</p><p>在冥想之中长大了以后，我开始喜欢诗。我读过很多诗，其中有一些是真正的好诗。好诗描述过的事情各不相同，韵律也变化无常，但是都有一点相同的东西。它有一种水晶般的光辉，好像是来自星星……真希望能永远读下去，打破这个寂寞的大海。我希望自己能写这样的诗。我希望自已也是一颗星星：如果我会发光，就不必害怕黑暗。如果我自己是那么美好，那么一切恐惧就可以烟消云散。于是我开始存下了一点希望——如果我能做到，那么我就战胜了寂寞的命运。但是我好久好久没有动笔写，我不敢拿那么重大的希望去冒险。如果我写出来糟不可言，那么一切都完了。</p><p>我十七岁到南方去插队。旱季里，那儿的天空是蓝湛湛的，站在小竹楼里往四下看，四外的竹林翠绿而又苗条。天上的云彩又洁白又丰腴，缓缓地浮过。我觉得应该试一试。</p><p>开始时候像初恋一样神秘，我想避开别人来试试我自己。午夜时分，我从床上溜下来，听着别人的鼻息，悄悄地走到窗前去，在皎洁的月光下坐着想。似乎有一些感受、一些模糊不清的字句，不知写下来是什么样的。在月光下，我用自来水笔在一面镜子上写。写出的字句幼稚得可怕。我涂了又写，写了又涂，直到把镜子涂成暗蓝色，把手指和手掌全涂成蓝色才罢手。回到床上，我哭了。这好像是一个更可怕的噩梦。</p><p>后来我在痛苦中写下去，写了很久很久，我的本子上出很多歪诗、臭诗，这很能刺激我写下去。到写满了三十个笔记时，我得了一场大病，出院以后弱得像一只瘦猫。正午时分，蹲下又站起来，四周的一切就变成绿色的。</p><p>我病退回北京，住在街道上借来的一间小屋里。在北京借到很多书，我读了很多文艺理论，从亚利士多德到苏联比西莫夫，试着从理性分析中找到一条通向目标的道路，结果一无所成。</p><p>那时候我穷得发疯，老盼着在地上捡到钱。我是姑姑养大的，可是她早几年死了。工作迟迟没有着落，又不好意思找同学借钱。我转起各种念头，但是我绝对不能偷。我做不出来。想当临时工，可是户口手续拖着办不完。剩下的只有捡破烂一条路了。</p><p>在天黑以后，我拿了一条破麻袋走向垃圾站。我站在垃圾堆上却弯不下来。这也许需要从小受熏陶，或者饿得更厉害些。我拎着空麻袋走开时却碰上一位姑娘从这儿走过。我和她只有一面之识，可她却再三盘问我。我编不出谎来，只好照实招了。</p><p>她几乎哭了出来，非要到我住的地方去看看不可。在那儿，我把我的事情都告诉她了。那一天我很不痛快，就告诉她准备把一切都放弃。她把我写过的东西看了一遍之后，指出有三首无可争议的好诗。她说事情也许不像我想的那么糕。但是我无论如何也想不起那三首诗是怎么写出来的了。我还不是一个源泉，一个发光体，那么什么也安慰不了我。</p><p>后来她常到我这儿来，我把写的都给她看，因为她独具慧眼，很能分出好坏来。她聪明又漂亮。后来我们把这些都放下，开始谈起恋爱来，晚上在路灯的暗影里接吻。过了三个月她要回插队的老家去，我也跟她去了。</p><p>在大海边上，有一个小村镇。这儿是公社的所在地，她在公社当广播员，把我安排在公社中学代课。 她有三间大瓦房，盖在村外的小山坡上，背朝着大海，四面不靠人家，连院墙都没有，从陆上吹来的风毫无阻碍地吹着门窗。她很需要有人做伴，于是我也住进那座房子，对外说我是她的表哥，盖这座房子用了我家的钱。人家根本不信，不过也不来管我们的闲事。我们亲密无间，但是没感到有什么必要去登记结婚。我住在东边屋里，晚上常常睡不着觉在门口坐着，她也常来陪我坐。我们有很多时候来谈论，有很多次谈到我。看来写诗对我是一个不堪的重负，可是这已经是一件不可更改的事情了。我必须在这条路上走到底。我必须追求这种能力，必须永远努力下去。我的敌手就是我自己，我要它美好到使我满意的程度。她希望我能斗争到底。她喜欢的就是人能做到不可能做到的事情，她的一切希望就系之于此。如果没有不可能的事情，那么一切都好办了。</p><p>我不断地试下去，写过无数的坏诗。偶尔也写过几个美好的句子，但是没有使她真正满意的一篇。我好像老在一个贫乏的圈子里转来转去，爬不出去。我找过各种各样的客观与主观原因，可是一点帮助也没有。她说我应该从原地朝前跨一步，可是我动弹不得。</p><p>我就这么过了好几年。有时挎着她的手到海边去散步时我想：“算了吧！我也算是幸福的了。她是多么好的伴侣。也许满足了就会幸福。”可是我安静不下来。我的脑子总是在想那个渺茫的目标。我常常看到那个寂寞的大海。如果我停下来，那么就是寂寞，不如试下去。</p><p>昨天早上，校长让我带十几个学生去赶大潮。我们分两批到大海中间的沙滩上去挖牡蛎，准备拿回去卖给供销社，给学校增加一点收入。下午第一批学生上船以后，忽然起了一阵大风，风是从陆上吹来的。这时潮水已经涨到平了沙滩，浪花逐渐大起来，把沙洲上的沙子全掀了起来。如果把我们打到海里，学生们会淹死，我也可能淹死，淹不死也要进监狱。我让学生们拉住我的腰带，推着我与大浪对抗。我身高一米九○，体重一百八十斤，如果浪卷不走我，学生们也会安全。</p><p>小船来接我们时，浪高得几乎要把我浮起来，一浮起来我们就完了。小船不敢靠近，怕在沙滩上搁浅，就绕到下风处，我把学生一个一个从浪峰上推出去，让他们漂到船上去。最后一个学生会一点水，我和他一起浮起来时，他一个狗刨动作正刨在我下巴上，打得我晕了几秒钟，醒过来时几乎灌饱了。我再浮上水面，小船已经离得很远。我喊了一声，他们没有听见，我又随浪沉下去。再浮到浪时，小船已经摇走，他们一定以为我淹死了。</p><p>我在海里挣扎了很久，陆地在天边消失了。我一个劲地往海底沉，因为我比重太大，很不容易浮起来。大海要淹死我。可是我碰上了一条没浆的小船在海里乱漂。我爬上船去，随它漂去。我晕得一塌糊涂，吐了个天翻地覆。天黑以后，风停了。我看见这座大海之中的小孤岛，就游了上来。</p><p>我在荒岛上迎接黎明，我听到了金喇叭的声音。在这个荒岛上，我写出了一生中第一首从源泉涌出来的诗，我把它刻在了石上。</p><p>在我的四周都是海，闪着金光，然后闪着银光，天空从浅红变作天蓝。海面上看不见一条船。在这小岛顶上有一座玩具一样的龙王庙。也许人们不会来救我，我还要回到海里，试着自己游回岸上去，但是我并不害怕。我不觉得饿，还可以支持很久。我既可以等待，也可以游泳。现在我愿意等待。于是我叉手于胸站在小岛顶上。我感到自豪，因为我取得了第一个胜利，我毫不怀疑胜利是会接踵而至的。我做到了第一件做不到的事情，我也可以接着做下去。我喜欢我的诗，因为我知道它是真正美好的，它身上有无可争辩的光辉。我也喜欢我自己造出的我自己，我对他满意了。</p><p>有一只小船在天边出现，一个白色的小点，然后又像一只白天鹅。我站在山顶上，把衬衫脱下来挥舞。是她，独自划着一条白色的救生艇，是从海军炮校的游泳场搞来的。她在船上挥着手。我到岸边去接她。</p><p>她哭着拥抱我，说在海上找了我一夜。人们都相信我已经淹死了，但是她不相信我会死。我把她引到那块石头前，让她看我写的诗。她默默地看了很久，然后向我要那片硬质合金，要把我的名字刻上去。可是我不让她刻。我不需要刻上我的名字。名字对我无关紧要。我不希望人们知道我的名字，因为我的胜利是属于我的。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
            <tag> 王小波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C04白银时代</title>
      <link href="/64.Novel-and-Poesy/C04.%E7%99%BD%E9%93%B6%E6%97%B6%E4%BB%A3/"/>
      <url>/64.Novel-and-Poesy/C04.%E7%99%BD%E9%93%B6%E6%97%B6%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>大学二年级时有一节热力学课，老师在讲台上说道：“将来的世界是银子的。”</p><h2 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h2><p>在花店里，有个穿黑皮短裙的女孩子对我挤眉弄眼，我没理她。后来她又跟我走了一路，一直追到停车场，在我身后说些带挑逗意味的疯话……最后，她终于拦住我的车门，说道：大叔，别假正经了——你到底是不是只鸭？我闷声喝道：滚蛋！把她撵走了。这种女孩子从小就不学好，功课都是零分，中学毕业就开始工作；和我们不是一路人。然后我坐在方向盘后面咳声叹气，想着“棕色的”从来就没有注意过我。要是她肯注意我，和我闲聊几句，起码能省下几道数学题。她解题的速度太快，现有的数学题不够用了。</p><h2 id="未来世界"><a href="#未来世界" class="headerlink" title="未来世界"></a>未来世界</h2><p>我舅舅上个世纪（20世纪）末生活在世界上。有件事我们大家都知道：在中国，历史以三十年为极限，我们不可能知道三十年以前的事。我舅舅比我大了三十多岁，所以他的事我就不大知道——更正确的说法是不该知道。他留下了一大堆的笔记、相片，除此之外，我还记得他的样子。他是个肤色黝黑的大个子，年轻时头发很多，老了就秃了。他们那个时候的事情，我们知道的只是：当时烧煤，烧得整个天空乌烟障气，而且大多数人骑车上班。</p><p>…</p><p>每个星期天，他都要到我们家来吃饭。我的物理老师也常来吃饭，她就住在我们家前面的那栋楼，在家里我叫她小姚阿姨。这位小姚阿姨当时三十岁刚出头，离了婚，人长得非常漂亮，每次她在我家里上过厕所后，我都要抢进去，坐在带有她体温的马桶上，心花怒放。</p><p>…</p><p>夏天我们到河边去游泳时，我只顾从小姚阿姨的游泳衣缝往里看——那东西实在严实，但也不是无隙可钻，尤其是她刚从水里出来时——所以很少到水里去，以致被晒塌了好几层皮，像鬼一样的黑。小姚阿姨却晒不黑，只会被晒红。她觉得皮肤有点痒时，就跳到水里去，然后水淋淋地上来，在太阳底下接着晒。这个过程使人想到了烹调书上的烤肉法，烤得滋滋响或者起了泡，就要拿出来刷层油或者是糖色。她就这么反复泡制自己的皮肉，终于在夏天快结束时，使腿的正面带上了一点黄色。我对这些不感兴趣，只想看到她从水里出来时背带松驰，从泳衣的上端露出两小块乳房，如果看到了就鼓掌欢呼。这使她每次上岸都要在肩上提一把。提了以后游泳衣就会松驰下来，连乳头的印子都没有了，这当然是和我过不去的举动。她走到我身边时，总要拧我一把，说道：小坏蛋，早晚我要宰了你。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
            <tag> 王小波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C03黑铁时代</title>
      <link href="/64.Novel-and-Poesy/C03.%E9%BB%91%E9%93%81%E6%97%B6%E4%BB%A3/"/>
      <url>/64.Novel-and-Poesy/C03.%E9%BB%91%E9%93%81%E6%97%B6%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>2010年我住在北戴河，住在一片柴油燃烧的烟云之下。冬天的太阳出来以后，我看到的是一片棕色的风景。这种风景你在照片和电视上都看不到，因为现在每一个镜头的前面都加了蓝色的滤光片。这是上级规定的。这种风景只能用肉眼看见。假如将来有一天，上级规定每个人都必须戴蓝色眼镜的话，就再没有人能看到这样的风景。天会像上个世纪一样的蓝。领导上很可能会做这样的规定，因为这样一来，困扰我们的污染问题就不存在了。在我过四十八岁生日那一天早上，我像往日一样去上班。这一天就像我这一辈子度过的每一天一样，并不特别好，也不特别坏。我选择这一天开始我的日记，起初也没有什么特别的寓意。只是在时隔半年，我在整理这些日记时，才发现它是一系列变化的开始。所以我在这一天开始记日记，恐怕也不全是无意的了。</p><p>有关数盲症，我还知道这样一些事：它只在壮年男子身上发作，而且患这种病的人都是做技术工作的。官方对它的解释是：这是一种职业病，是过度劳累造成的，所以数盲症患者总能得到很好的待遇。这一点叫人垂涎欲滴，而且心服口服。数盲者不能按行阅读，只能听汇报；不能辩向，只能乘专车；除了当领导还能当什么？这是正面的说法。反面的说法是：官方宣布的症状谁知是真是假。数盲清正廉洁，从来没有数盲贪赃枉法（不识数的人不可能贪），更没有人以权谋私，任何人都服气。这也是正面说法。反面的说法是他们用不着贪赃枉法，只要拿领导分内的就够多了。正面的说法是领导上的待遇并不超过工作需要，反面的说法是超过了好几百倍；所以应该算算账。为此要有一种计数法、一种记账法、一种逻辑，对数盲和非数盲通用，但又不可能。有位外国的学者说，数盲实质上是不进位，只要是工作用了无穷进制计数法。这种算法我们学不会。假如你就这一点对数盲发牢骚，他就笑眯眯地安慰你说：你们用的二进制、十进制我们也不会嘛。大家各有所长，都是工作需要。</p><p>现在要说明的是，北戴河是华北一座新兴的科技城市，它之所以是科技城市，是因为技术部设在这里。王二是技术部的老大哥，也就是常务副部长。这是未患数盲症的人所能担任的最高职务，是一种类似工头的角色。有时他把自己叫做“王二”，有时把自己叫做“我”；但从来不把自己叫做“老大哥”，这个称呼是专供别人使用的。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>我设计的柴油机没有爆炸过——这种东西不会爆炸，除非你在气缸里放上雷管，而那种爆炸就不是我的责任了——我去砸碱是另有理由。大概是在十年以前吧，就像天外来客一样，技术部里来了一个归国留学生，学工程的博士。当然了，在他看来我们都是垃圾，我们的设计都是犯罪，我们听了也都服气。然后他就当了老大哥，我下台了。这使我很高兴。就是现在，谁要肯替我当这个老大哥，就是我的大恩人。他一到部里来，大家都觉得自己活着纯属多余，当然也不肯干活；因此就把他累得要死。</p><p>除了设计工作，他还给我们开课，从普通物理到数字电路全讲。听课的寥寥无几，但我总是去听的。我从他那里学了不少东西，所以才能设计柴油机，速校里学的东西只够设计蒸汽机——过去我设计的动力机械就是蒸汽机，装到汽车上，把道路轧出深深的车辙——后来我和他发生了技术路线上的争论——他主张大胆借鉴新技术，一步跨入二十一世纪；我主张主要借鉴二十世纪前期的技术，先走进二十世纪再说，理由如下：你别看我们这些人是垃圾，底下的人更是垃圾。提高技术水平要一步步一米这本是两个非数盲之间的争论，争着争着，数盲就介入了，把我定为右倾机会主义路线头子，送到湖边去砸碱。有个女孩子毅然站了出来——她就是我前妻。砸了两年，提前被接了回来。这是因为好多人得了数盲症（包括那位留学生），部里缺人，又把我调回来当老大哥。这位留学生当了我们部长，隔三差五到部里来转转，见了我就放些臭屁：老大哥，以前的事你要正确对待呀！我就说：正确对待！部长，我爱你！搂住就给他个kiss。其实不是kiss，而是借机把鼻涕抹到他脸上。他一转身我就伸脚钩他的腿。谁要是被碱水泡过两年，准会和我一样。</p><p>有关砸碱的事，需要补充一下。当你用十字镐敲到厚厚的碱层上时，碱渣飞溅，必须注意别让它迸进眼睛里。这是因为碱的烧伤有渗透性，会把眼睛烧瞎。你最好戴保护眼镜，但是谁也不会给你这种眼镜（你只能自己做），也不会告诉你这件事（你只能自己知道），所以有好多人把眼睛烧瞎了——有人瞎一只眼，有人瞎两只眼。瞎了两只眼的人就可放心大胆地不戴眼镜砸碱，因为再没有眼睛可瞎了。</p><p>红毛衣的事后来是这样的：小孙判下来之后，我们部里该派个人看守他——这种事一般是轮班去的，而且总是我排第一班。这一回她站了出来，自告奋勇去基层锻炼。我前妻当年也是这样的，开完了宣判会，大义凛然地走到我面前，喝道：王犯，把手伸出来！</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
            <tag> 王小波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C02青铜时代</title>
      <link href="/64.Novel-and-Poesy/C02.%E9%9D%92%E9%93%9C%E6%97%B6%E4%BB%A3/"/>
      <url>/64.Novel-and-Poesy/C02.%E9%9D%92%E9%93%9C%E6%97%B6%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="序-万寿寺"><a href="#序-万寿寺" class="headerlink" title="序 万寿寺"></a>序 万寿寺</h2><p>我终于有了勇气来谈谈我在文学上的师承。小时候，有一次我哥哥给我念过查良铮先生译的《青铜骑士》：　<br>我爱你，彼得建造的大城<br>我爱你庄严、匀整的面容<br>涅瓦河的流水多么庄严<br>大理石平铺在它的两岸……<br>他还告诉我说，这是雍容华贵的英雄体诗，是最好的文字。相比之下，另一位先生译的《青铜骑士》就不够好：<br>我爱你彼得的营造<br>我爱你庄严的外貌……<br>现在我明白，后一位先生准是东北人，他的译诗带有二人转的调子，和查先生的译诗相比，高下立判。那一年我十五岁，就懂得了什么样的文字才能叫作好。</p><h2 id="第一章-万寿寺"><a href="#第一章-万寿寺" class="headerlink" title="第一章 万寿寺"></a>第一章 万寿寺</h2><p>莫迪阿诺在《暗店街》里写道：“我的过去一片朦胧……”。这本书就放在窗台上，是本小册子，黑黄两色的封面，纸很糙，清晨微红色的阳光正照在它身上。病房里住了很多病人，不知它是谁的。我观察了很久，觉得它像是件无主之物，把它拿到手里来看；但心中惕惕，随时准备把它还回去。过了很久也没人来要，我就把它据为己有。过了一会儿，我才骤然领悟到：这本书原来是我的。这世界上原来还有属于我的东西──说起来平淡无奇，但我确实没想到。病房里弥漫着水果味、米饭味、汗臭味，还有煮熟的芹菜味。在这个拥挤、闭塞、气味很坏的地方，我迎来了黎明。我的过去一片朦胧……</p><p>病房里有一面很大的玻璃窗。每天早上，阳光穿过不平整的窗玻璃，在对面墙上留下火红的水平条纹；躺在这样的光线里，有如漂浮在溶岩之中。本来，我躺在这张红彤彤的床上，看那本书，感到心满意足。事情忽然急转而下，大夫找我去，说道，你可以出院了。医院缺少床位，多少病人该住院却进不来──听他的意思，好像我该为此负责似的。我想要告诉他，我是出于无奈（别人用汽车撞了我的头）才住到这里的，但他不像要听我说话的样子，所以只好就这样了。</p><p>此后，我来到大街上，推着一辆崭新的自行车，不知该到哪里去。一种巨大的恐慌，就如一团灰雾，笼罩着我──这团雾像个巨大的灰毛老鼠，骑在我头上，早晨城里也有一层雾，空气很坏，我自己也带着医院里的馊味。我总觉得空气应该是清新的，弥漫着苦涩的花香──如此看来，《暗店街》还在我脑中作祟……</p><p>莫迪阿诺的主人公失去了记忆。毫无疑问，我现在就是失去了记忆。和他不同的是，我有张工作证，上面有工作单位的地址。循着这个线索，我来到了“西郊万寿寺”的门前。门洞上方有“敕造万寿寺”的字样，而我又不是和尚……这座寺院已经彻底破旧了，房檐下的檩条百孔千疮，成了雨燕筑巢的地方，燕子屎把房前屋后都变成了白色的地带，只在门前留下了黑色的通道。这个地带对人来说是个禁区。不管谁走到里面，所有的燕巢边上都会出现燕子的屁股，然后他就在缤纷的燕粪里，变成一个面粉工人，燕子粪的样子和挤出的儿童牙膏类似。院子里有几棵白皮松，还有几棵老得不成样子的柏树。这一切似曾相识……我总觉得上班的地点不该这样的老旧。顺便说一句，工作证上并无家庭住址，假如有的话，我会回家去的，我对家更感兴趣……万寿寺门前的泥地里混杂着砖石，掘地三尺也未必能挖干净。我在寺门前巡逡了很久，心里忐忑不安，进退两难。直到有一个胖胖的女人经过。她从我身边走过时抛下了一句：进来呀，愣着干啥。这几天我总在愣着，没觉得有什么不对。但既然别人这么说，愣着显然是不对的。于是我就进去了。</p><p>出院以前，我把《暗店街》放在厕所的抽水马桶边上。根据我的狭隘经验，人坐在这个地方才有最强的阅读欲望。现在我后悔了，想要回医院去取。但转念一想，又打消了这个主意。把一本读过的书留给别人，本是做了一件善事；但我很怀疑自己真有这么善良。本来我在医院里住得好好的，就是因为看了这本书，才遇到现在的灾难。我对别的丧失记忆的人有种强烈的愿望，想让他们也倒点霉──丧失了记忆又不自知，那才是人生最快乐的时光……</p><p>对于眼前这座灰蒙蒙的城市，我的看法是：我既可以生活在这里，也可以生活在别处；可以生活在眼前这座水泥城里，走在水泥的大道上，呼吸着尘雾；也可以生活在一座石头城市里，走在一条龟背似的石头大街上，呼吸着路边的紫丁香。在我眼前的，既可以是这层白内障似的、磨砂灯泡似的空气，也可以是黑色透明的、像鬼火一样流动着的空气。人可以迈开腿走路，也可以乘风而去。也许你觉得这样想是没有道理的，但你不曾失去过记忆──在我衣服口袋里，有一张工作证，棕色的塑料皮上烙着一层布纹。里面有个男人在黑白相片里往外看着。说实在的，我不知道他是谁。但是，既然出现在我口袋里，除我之外，大概也不会是别人了。也许，就是这张证件注定了我必须生活在此时此地。</p><p>早上，我从医院出来，进了万寿寺，踏着满地枯黄的松针，走进了配殿。我真想把鞋脱下来，用赤脚亲近这些松针。古老的榆树，矮小的冬青丛，都让我感到似曾相识；令人遗憾的是，这里有股可疑的气味，于茅厕相似，让人不想多闻。配殿里有个隔出来的小房间，房间里有张桌子，桌子上堆着写在旧稿纸上的手稿。这些东西带着熟悉的气息迎面而来──过去的我带着重重叠叠的身影，飘扬在空中。用不着别人告诉我，我就知道，这是我的房间、我的桌子、我的手稿。这是因为，除了穿在身上的灰色衣服，这世界上总该有些属于我的东西──除了有些东西，还要有地方吃饭，有地方睡觉，这些在目前都不要紧。目前最要紧的是，有个容身的地方。坐在桌子后面，我心里安定多了。我面前还放了一个故事。除了开始阅读，我别无选择了。</p><p>“晚唐时，薛嵩在湘西当节度使。前往驻地时，带去了他的铁枪”。故事就这样开始了。这个故事用黑墨水写在我面前的稿纸上，笔迹坚挺有力。着种纸是稻草做的，呈棕黄色，稍稍一折就会断裂，散发着轻微的霉味。我面前的桌子上有不少这样的纸，卷成一捆捆的，用橡皮筋扎住。随手打开一卷，恰恰是故事的开始。走进万寿寺之前，我没想到会有这么多故事。可以写几个字来对照一下，然后就可认定是不是我写了这些故事。但我觉得没有必要。在医院里醒来时，我左手的食指和中指上，都有黑色的墨迹。这说明我一直用黑墨水来写字。在我桌子上，有一个笔筒，里面放满了蘸水钢笔，笔尖朝上，像一丛龙舌兰的样子；笔筒边上放着一瓶中华牌绘图墨水。坐在这个桌子面前，我想道：假如我不是这个故事的作者，也不会有别人了；虽然我一点不记得这个故事。这些稿子放在这里，就如医院窗台上的《暗店街》。假如我不来认领，就永无人来认领。这世界之所以会有无主的东西，就因为有人失去了记忆。</p><p>手稿上写道：盛夏时节，在湘西的红土丘陵上，是一片萧杀景象；草木凋零，不是因为秋风的摧残，却是因为酷暑。此时山坡上的野草是一片黄色，就连水边的野芋头的三片叶子，都分向三个方向倒下来；空气好像热水迎面浇来。山坡上还刮着干热的风。把一只杀好去毛的鸡皮上涂上盐，用竹杆挑到风里去吹上半天，晚上再在牛粪火里烤烤，就可以吃了。这种鸡有一种臭烘烘的香气。除了风，吃腐肉的鸟也在天上飞，因为死尸的臭味在酷热中上升，在高空可以闻到。除了鸟，还有吃大粪的蜣螂，它们一反常态，嗡嗡地飞了起来，在山坡上寻找臭味。除了蜣螂，还有薛嵩，他手持铁枪，出来挑柴禾。其它的生灵都躲在树林里纳凉。远远看去，被烤热的空气在翻腾，好像一锅透明的粥，这片山坡就在粥里煮着──这故事开始时就是这样。</p><h2 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h2><p>虽然记忆已经恢复，我有了一个属于自己的故事，但我还想回到长安城里──这已经成为一种积习。一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。对我来说，这个世界在长安城里。我最终走进了自己的屋子──那座湖心的水榭，在四面微白的纸壁中间，黑沉沉的一片睁大红色的眼睛──火盆在屋子里散发着酸溜溜的炭味儿。而房外，则是一片沉重的涛声，这种声音带着湿透了的雪花的重量──水在搅着雪，雪又在搅着水，最后搅成了一锅粥。我在黑暗里坐下，揭开火盆的盖子，乌黑的炭块之间伸长了红蓝两色的火焰。在腿下的毡子上，满是打了捆的纸张，有坚韧的羊皮纸，也有柔软的高丽纸。纸张中间是我的铺盖卷。我没有点灯，也没有打开铺盖，就在杂乱之中躺下，眼睛绝望地看着黑暗。这是因为，明天早上，我就要走上前往湘西风凰寨的不归路。薛嵩要到那里和红线汇合，我要回到万寿寺和白衣女人汇合。长安城里的一切已经结束。一切都在无可挽回地走向庸俗。</p><h2 id="第十六章-红拂夜奔"><a href="#第十六章-红拂夜奔" class="headerlink" title="第十六章 红拂夜奔"></a>第十六章 红拂夜奔</h2><p>李靖、红拂、虬髯公世称风尘三侠，隋朝末年，他们三人都在洛阳城里住过。大隋朝的人说，洛阳城是古往今来最伟大的城市；但唐朝的人又说，长安是古往今来最伟大的城市；宋朝的人说，汴梁是古往今来最伟大的城市；所以很难搞清到底哪里是古往今来最伟大的城市。洛阳城是泥土筑成的筑城的。土是用远处运来的最纯净的黄土，放到笼屉里蒸软后…</p><h2 id="第二十七章"><a href="#第二十七章" class="headerlink" title="第二十七章"></a>第二十七章</h2><p>你不能从人群里认出我来的，尽管你知道我头发灰白，一年四季总穿灰色的衣服。现在每天我都到系里去上班，在我的办公桌上故了一个老式的墨水池，那东西看上去像个眼镜，左边的一个墨水瓶里是红墨水，右面一个是蓝墨水，中间的凹槽里放了好多蘸水笔尖。每天早上我来时，都要仔细把笔尖挑选一遍，把磨秃了的笔尖拣出来，包在一张纸里扔进废纸篓；然后戴上老花镜批阅学生的作业。这些学生是加州伯克利教的。批完之后我把这些作业本拿到对面他的办公桌上，然后看教科书的校样，到十一点钟我到厕所去洗手准备回家——有人在洗手池上放了一撮洗衣粉，用它可以去掉手上的墨水渍。我就是这样一天天老下去了。从这个样子你决看不出我每天每夜每小时每一分钟都在想入非非，怀念着十七岁时见到的紫色天空，岸边长满绿色芦苇的河流，还有我的马兄弟。我本来不是这样，是装成这样的。你不可能从一个削瘦、憔悴的数学教师身上看到这些。有关人随时在想些什么，我只知道一个例子，就是我自己，别人不可能把一切都告诉我。所以我只好推己及人。在统计学上可以证明，以一个例子的样本来推论无限总体，这种方法十分之坏。安妮·弗兰克就犯了这种错误，从自己是善良的推出了所有的人都是善良的，虽然这份善良被深藏在心里，这个推论简直是黑色幽默。但是在这件事上没有别的方法了。到目前为止，没有一件事能让我相信我是对的，就是人生来有趣。过去有趣，渴望有趣，内心有趣却假装无趣。也没有一件事能证明我是错的，让我相信人生来无趣，过去无趣现在也无趣，不喜欢有趣的事而且表里如一。所以到目前为止，我只能强忍着绝望活在世界上。</p><p>全书完<br>一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
            <tag> 王小波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C01黄金时代</title>
      <link href="/64.Novel-and-Poesy/C01.%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3/"/>
      <url>/64.Novel-and-Poesy/C01.%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>我二十一岁时，正在云南插队。陈清扬当时二十六岁，就在我插队的地方当医生。我在山下十四队，她在山上十五队。</p><p>…</p><p>当然，我对此有不同的意见，在我看来，这东西无比重要，就如我之存在本身。天色微微向晚，天上飘着懒洋洋的云彩。下半截沉在黑暗里，上半截仍浮在阳光中。那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</p><h2 id="第十七章-革命时期的爱情"><a href="#第十七章-革命时期的爱情" class="headerlink" title="第十七章 革命时期的爱情"></a>第十七章 革命时期的爱情</h2><p>《序》<br>这是一本关于性爱的书。性爱受到了自身力量的推动，但自发地做一件事在有的时候是不许可的，这就使事情变得非常的复杂。举例言之，颐和园在我家北面，假如没有北这个方向的话，我就只好向南走，越过南极和北极，行程四万余公里到达那里。我要说的是：人们的确可以牵强附会地解释一切，包括性爱在内。故而性爱也可以有最不可信的理由。</p><p>王二年轻时在北京一家豆腐厂里当过工人。那地方是个大杂院，人家说过去是某省的会馆。这就是说，当北京城是一座灰砖围起的城池时，有一批某个省的官商人等凑了一些钱，盖了这个院子，给进京考试的举人们住。这件事太久远了。它是一座细砖细瓦的灰色院子，非常的老旧了；原来大概有过高高的门楼，门前有过下马石栓马桩一类的东西，后来没有了，只有一座水泥门桩的铁栅栏门，门里面有条短短的马路，供运豆腐的汽车出入。马路边上有一溜铁皮搭的车棚子，工人们上班时把自行车放在里面。棚子的尽头有个红砖砌的小房子，不论春夏秋冬里面气味恶劣，不论黑夜白天里面点着长明灯，那里是个厕所。有一段时间有人在里面的墙上画裸体画，人家说是王二画的。</p><p>王二在豆腐厂里当工人时，北京冬天的烟雾是紫红色的，这是因为这座城里有上百万个小煤炉，喷出带有二氧化硫的煤烟来。当阳光艰难地透过这种煤烟时，就把别的颜色留在天顶上了。这种颜色和他小时候见过的烟雾很近似。对于颜色，王二有特别好的记忆力。但是不管你信也好，不信也罢，他居然是个色盲。早知道自己是个色盲，他也不去学画，这样可以给自己省去不少的麻烦。</p><h2 id="第二十二章"><a href="#第二十二章" class="headerlink" title="第二十二章"></a>第二十二章</h2><p>有关那位姓颜色的女大学生，有一点需要补充的地方，那就是在我清醒的时候，也觉得她挺麻烦的。比方说，我正在五楼顶上和一伙人汗流浃背地布置滚木檑石，准备把进犯者通通砸死，忽听她在二楼叫我，就急星火撩地跑了去。你猜是叫我干啥罢——叫我吃面条。我留在这楼里，破坏了自己的房子，出卖了自己家的利益，还长了一身虱子，就是为了吃这种没油没盐盛在茶缸里的面条吗？我对她很反感，觉得她婆婆妈妈的。但这是我清醒时候的事。到了我睡着，或是自以为睡着了的时候，就和她拥抱，接吻，用双手爱抚她的乳房。干这种事时，她老掐我的胳膊，第二天胳臂上青印累累。这说明这样的事发生过。但是不管她怎么掐，我都没有醒来。除了没有醒，别的事都和醒着时一样。比方说，过道里点了一盏马灯，灯光一会儿红，一会黄，游移不定。地下有好多草垫子，给人一种建筑工地的印象。我一点没觉得是在我住了十几年的家里。姓颜色的大学生嘴里有一股奶油软糖的味道。她乳罩左边有四个扣子，解起来麻烦无比。在那方寸之地集中的扣子比我全身剩下的扣子还多，这说明女人简直是不能沾。我已经决定把这当一场梦，不管她怎么掐，都不肯醒来。这件事我没有告诉X海鹰，任凭她怎么问。我觉得把这种事告诉她不适宜。</p><p>…</p><p>我和姓颜色的大学生爬地沟到海淀镇去买大饼，那些地沟是砖头砌成，顶上盖着水泥板。从里面用灯光照着时，那些砖头重重叠叠，仿佛要向里面压下来。那是一段不近的路。我们俩都戴了涂胶的手套，姓颜色的大学生膝盖上还套了田径队员练腿时绑的砂袋——当然，袋里的铁砂倒掉了。我告诉她说，进了地沟就要像狗一样爬，口袋里的东西都要掏出来，否则会丢掉。她就把钱拿出来，塞到乳罩里，以免爬掉了。然后我们下到地沟里，开始爬了。我嘴里叼着马灯，爬起来膝盖不着地而且很快，这种技术也不是练了一年两年。姓颜色的大学生跟在后面，看来她爬地沟还有点天份，能跟上我。爬了一段，姓颜色的大学生忽然坐在地下，说：“小叭狗！！”，就哈哈地笑起来了。</p><h2 id="第二十三章"><a href="#第二十三章" class="headerlink" title="第二十三章"></a>第二十三章</h2><p>X海鹰带我到她家里去那一天，天幕是深黄色的，正午时分就比黄昏时还要昏暗。我跟在她的车轮后面跑过洒满了黄土的马路——那时候马路上总是洒满了地铁工地运土车上落下的土，那种地下挖出来的黄土纯净绵软，带有糯性。天上也在落这样的土。我以为就要起一场飞砂走石的大风，但是跑着跑着天空就晴朗了，也没有起这样的风。我穿着油污的工作服，一面跑一面唱着西洋歌剧——东一句西一句，想起哪句唱哪句。现在我想起当年的样子来，觉得自己实在是惊世骇俗。路上的行人看到我匆匆跑过，就仔细看我一眼。但是我没有把这些投来的目光放在心上。</p><h2 id="第四十三章-2015"><a href="#第四十三章-2015" class="headerlink" title="第四十三章 2015"></a>第四十三章 2015</h2><p>上个世纪渤海边上有个大碱厂，生产红三角牌纯碱，因而赫赫有名。现在经过芦台一带，还能看到海边有一大片灰蒙蒙的厂房。因为氨碱法耗电太多，电力又不足，碱厂已经停了工，所需的碱现在要从盐碱地上刨来。这项工作十分艰苦，好在还有一些犯了错误的人需要改造思想，可以让他们去干。除此之外，还需要有些没犯错误的人押送他们，这就是这个故事的前因。我舅舅现在还活着，会有什么样的后果还很难说。总而言之，我舅舅在盐碱地上刨碱，小舅妈押着他。刨碱的地方离芦台不很远。</p><p>每次我路过芦台，都能看到碱厂青白的空壳子厂房。无数海鸟从门窗留下的大洞里飞进飞出，遮天盖地。废了的碱厂成了个大鸟窝，还有些剃秃瓢拴脚镣的人在窝里出入，带着铲子和手推车。这说明艰苦的工作不仅是刨碱，还有铲鸟粪。听说鸟粪除了做肥料，还能做食品的添加剂。当然，要经过加工，直接吃可不行。<br>…<br>我舅舅在碱场劳改时，每天都要去砸碱。据他后来说，当时的情形是这样的：他穿了一件蓝大衣，里面填了再生毛，拖着那副大脚镣，肩上扛了十字镐，在白花花的碱滩上走。那地方的风很是厉害，太阳光也很厉害，假如不戴个墨镜，就会得雪盲，碱层和雪一样反光。如前所述，我舅舅没有墨镜，就闭着眼睛走。小舅妈跟在后面，身穿呢子制服，足蹬高统皮靴，腰束武装带，显得很是英勇。她把大檐帽的带子放下来，扣在下巴上。走了一阵子，她说：站住，王犯！这儿没人了，把脚镣开了罢。我舅舅蹲下去拧脚镣，并且说：报告管教，拧不动，螺丝锈住了！小舅妈说：笨蛋！我舅舅说：这能怪我吗？又是盐又是碱的。他的意思是说，又是盐又是碱，铁器很快就会锈。小舅妈说：往上撒尿，湿了好拧。我舅舅说他没有尿。其实他是有洁癖，不想拧尿湿的罗丝。小舅妈犹豫了一阵说：其实我倒有尿棗算了，往前走。我舅舅站起身来，扛住十字镐，接着走。在雪白的碱滩上，除了稀疏的枯黄芦苇什么都没有。走着走着小舅妈又叫我舅舅站住，她解下武装带挂在我舅舅脖子上，走向一丛芦苇，在那里蹲下来尿尿。然后他们又继续往前走，此时我舅舅不但扛着镐头，脖子上还有一条武装带、一支手枪、一根警棍，走起路来东歪西倒，完全是一副怪模样。后来，我舅舅找到了一片碱厚的地方，把蓝大衣脱掉铺在地上，把武装带放在旁边，就走开，挥动十字镐砸碱。小舅妈绕着他嘎吱嘎吱地走了很多圈，手里掂着那根警棍。然后她站住，从左边衣袋里掏出一条红丝巾，束在脖子上，从右衣袋里掏出一副墨镜戴上，走到蓝大衣旁边，脱掉所有的衣服，躺在蓝大衣上面，摊开白晰的身体，开始日光浴。</p><p>过了不久，那个白晰的身体就变得红扑扑的了。与此同时，我舅舅迎着冷风，流着清水鼻涕，挥着十字镐，在砸碱。有时小舅妈懒洋洋地喊一声：王犯！</p>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
            <tag> 王小波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我们仰望星空会震撼</title>
      <link href="/63.Culture-and-Arts/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%BB%B0%E6%9C%9B%E6%98%9F%E7%A9%BA%E4%BC%9A%E9%9C%87%E6%92%BC/"/>
      <url>/63.Culture-and-Arts/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%BB%B0%E6%9C%9B%E6%98%9F%E7%A9%BA%E4%BC%9A%E9%9C%87%E6%92%BC/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="https://zhuanlan.zhihu.com/p/53381006" target="_blank" rel="noopener">为什么我们仰望星空会震撼｜混乱博物馆 - 知乎</a></p><p>康德在《纯粹理性批判》的结语中说：「有两种东西越经常反复思想，就给人灌注了时时更新、与日俱增的惊赞和敬畏：头上的星空和内心的道德律。」的确，当我们在夜晚置身旷野，仰望星空，就会有一种让人眩晕的、不真实的震撼感。</p><p>这可能与深渊恐惧症（Bathophobia）、巨物恐惧症（Megalophobia）等一系列恐惧症（Phobia）有所关联。</p><p>特定性恐惧症（Specific Phobia）是常见的心理学现象，它是由特定物体或情景引发的恐惧症状，这与原始的恐惧具有相同的反射机理：</p><p>当眼睛捕捉到危险的信号，并传递给大脑中的杏仁核，就会激发恐惧感，启动一种被称为「战斗或逃跑反应」的心理机制：肾上腺素水平提高，心跳加快，头皮发麻、胃部不适，甚至眩晕、呕吐，此时，要么快速逃离，要么拼死一搏。</p><p>恐惧是人类在长久的演化之中，为了适应复杂的自然环境形成的一种本能，它提高了人类面对强大威胁的反应速度，利于我们的生存。</p><p>人类的安全感，建立在自己熟悉的、符合经验认知的基础之上，而身处不符合自己经验的环境或周围出现这样的事物，则会引发不安、恐慌和警觉，这是一种长期演化形成的保护机制。</p><p>我们即使对宇宙的真实尺度一无所知，但我们只要抬起头，就能直观感受到几乎占据了整个视域的星空，是个完全在我们经验之外的时空。我们对星空的恐惧和震撼，归根到底，是我们的日常与我们头顶上的“真实”之间的冲突。</p><hr><p>《缮写室》中提到 agora，旷野恐惧症（agoraphobia）的词源 @ref：[[../64.Novel-and-Poesy/《缮写室》 Quick-view]]</p><p>[[../53.Photograph/使用谷歌街景进行街拍]]中也提到摄影师 Jacqui Kenny 的“广场恐惧症”</p><p>对于星空，有些人（比如我）感到是震撼而非恐惧 ——也许如里尔克所说：美恰好是我们刚好可以承受的恐怖的开端，@ref[[../64.Novel-and-Poesy/D02.里尔克诗选]]</p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿连德的大数据乌托邦</title>
      <link href="/63.Culture-and-Arts/%E9%98%BF%E8%BF%9E%E5%BE%B7%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8C%E6%89%98%E9%82%A6/"/>
      <url>/63.Culture-and-Arts/%E9%98%BF%E8%BF%9E%E5%BE%B7%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8C%E6%89%98%E9%82%A6/</url>
      
        <content type="html"><![CDATA[<p>@link:  <a href="/63.Culture-and-Arts/赛博朋克/" title="赛博朋克">赛博朋克</a></p><hr><h2 id="Wiki：赛博协同控制工程"><a href="#Wiki：赛博协同控制工程" class="headerlink" title="Wiki：赛博协同控制工程"></a>Wiki：赛博协同控制工程</h2><p>@ref: <a href="https://www.wikiwand.com/zh-cn/%E8%B5%9B%E5%8D%9A%E5%8D%8F%E5%90%8C%E6%8E%A7%E5%88%B6%E5%B7%A5%E7%A8%8B" target="_blank" rel="noopener">赛博协同控制工程 - Wikiwand</a></p><p>赛博协同控制工程（英文：Project Cybersyn，简称：Cybersyn或Synco）是智利总统萨尔瓦多·阿连德在1971 - 1973年任期内建设的一项计算机网络工程，用于构建分布式决策支持系统，以支持国民经济的管理。该项目由四个模块组成：经济模拟器、确认工厂生产情况的定制软件、控制室和连接至一台主机的全国电报机网络。</p><p>赛博协同控制工程基于可行性系统模型（英语：）和神经网络方法进行设计，并采用当时的先进技术：包括国有企业中的电报机网络，可用于与圣地亚哥的政府进行信息收发,和用于监视生产指标的统计模型软件可近乎实时的接收实地采集的信息，如原材料供应和工人旷工等，并向工人事先发出预警。情况严重的情况下，系统也会向中央政府发出预警。政府同样也会将数据输入经济模拟软件（CHECO, CHilean ECOnomic simulator的缩写），以预测经济决议的可能结果。管理者可在控制室（Opsroom）观看经济数据，对紧急情况制定合理应对措施，并在预警情况利用电报机网络向企业和工厂发送指导建议。</p><p>赛博协同控制工程的首席架构师是英国运筹学家斯塔福德·比尔（英语：），该系统体现了他在工业管理中的组织控制论概念。其主要目标之一是将工业企业的决策权下放到工人中，以便发展工厂的自我监管。</p><p>1973年9月11日的军事政变后，赛博协同控制工程被废弃，其控制室也被摧毁。</p><p><img src="/images/Project-Cybersyn.png" alt="Project Cybersyn"></p><h2 id="王洪喆：阿连德的大数据乌托邦-——智利互联网考古"><a href="#王洪喆：阿连德的大数据乌托邦-——智利互联网考古" class="headerlink" title="王洪喆：阿连德的大数据乌托邦 ——智利互联网考古"></a>王洪喆：阿连德的大数据乌托邦 ——智利互联网考古</h2><p><a href="http://m.aisixiang.com/data/103794.html" target="_blank" rel="noopener">王洪喆：阿连德的大数据乌托邦</a></p><p>一九七二年十二月三十日，智利总统萨尔瓦多·阿连德视察了位于首都圣地亚哥的一间未来主义格调操作室。它似乎更像是库布里克电影中的场景，而不像是一个南美洲国家政府在经济战争中的指挥中心。在这间充满七十年代现代主义美学的六角形房间里，智利全国的经济数据经由电传机网络（telex）汇聚于此。而控制论（cybernetics）——一门试图构建生物、机器和社会系统之间共性的战后通信和控制科学，将帮助阿连德实现他承诺给这个国家带来的社会主义变革。它的创造者预计，政府的工业管理者将根据国家经济活动的实时数据和宏观视图做出快速决策，进而通往对整个社会主义国家生产生活的民主管理。这就是“赛博协同工程”（Project Cybersyn）——曾经真实存在于二十世纪历史中的“大数据”社会主义乌托邦——一个来自南美洲的控制论互联网革命。历经十年的寻访与写作，伊登·梅迪纳（Eden Medina）以开创性的著作《控制论革命者》，让这段少为人知的历史重见天日。</p><p>为了达成在内忧外患中完成工业国有化和经济增长的紧迫目标，阿连德任命了年轻的财政和技术官费尔南多·弗洛雷斯（Fernando Flores）实验新的管理办法。在阅读了斯塔福德·比尔的著作后，弗洛雷斯发现比尔的控制论思想跟智利的民主社会主义方案之间存在高度的亲缘性。二十世纪六十年代，比尔在英国致力于改造大型工厂中传统的中央到部门层层传达、指令式的管理理念。从控制论的稳态（homeostasis）类比出发，比尔将企业视为一个各部门之间协同的有机体，而管理的目标是对有机体的状态进行实时监控，只在必要时给出干预。</p><p>   …</p><p>那么，技术人员如何尝试将政治价值观注入技术人造物之中呢？首先，比尔希望在工厂经理和国家计划部门之间建立一种诚实而负责的关系。他认为，联网汇聚的统计概况将使得管理者难以伪造生产数据，不像苏联的工厂管理者在完成计划的压力下篡改记录。联网系统会使得异常立即显现，促使进一步调查。不过，比尔限制了系统收集的生产指标数量，这一方面防止计算机的信息过载，但更重要的是可防止国家事无巨细的微观干预和权力滥用，保证企业一定的自主性。这与苏联几乎在同一时期试图构建的全国经济控制论系统相区别。苏联控制论学者的愿景，是通过对各项经济指标的穷尽以达到模型的精确模拟和生产调节的全知全能。因此，比尔认为赛博协同的设定区分了智利和苏联的社会主义。</p><p>其次，赛博协同的反馈设计试图找到基层自主性和“全国一盘棋”之间的平衡点。例如，当系统检测到生产异常时，中央操作室将同时向计划部门和工厂管理者预警。政府会给工厂经理和工人们一个有限的时间窗口来查找和解决潜在问题。由此，企业在合理的程度上保持了自主性。如果相关企业和个人无法在这段时间内解决问题，政府再介入干预。这种干预将限制工厂的自主性，但是比尔认为这对于保持整个经济系统的稳定性是必不可少的。</p><p>最后，系统的设计反映了阿连德提高就业水平的承诺，这是政府计划的一个关键部分。计算机通常与工厂自动化相关联，在提高生产率水平的同时也使得企业减少其劳动力。而赛博协同将以不导致失业的方式使用计算机，它不急于指向自动化，而是帮助工厂和政府利用现有的人力和物力提高工业生产率。</p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智利 </tag>
            
            <tag> 赛博朋克 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科幻的朋克们</title>
      <link href="/63.Culture-and-Arts/%E7%A7%91%E5%B9%BB%E7%9A%84%E6%9C%8B%E5%85%8B%E4%BB%AC/"/>
      <url>/63.Culture-and-Arts/%E7%A7%91%E5%B9%BB%E7%9A%84%E6%9C%8B%E5%85%8B%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="都有哪些科幻朋克？"><a href="#都有哪些科幻朋克？" class="headerlink" title="都有哪些科幻朋克？"></a>都有哪些科幻朋克？</h2><ol><li><a href="/63.Culture-and-Arts/赛博朋克/" title="赛博朋克">赛博朋克</a></li><li>蒸汽朋克( Steampunk)：齿轮、钟表、压力阀、护目镜、礼服、热气球、发条 /<em>《爱死机》中的《狩猎愉快》——东方蒸汽朋克</em>/</li><li>柴油朋克(Dieselpunk)：二战、神秘主义、柴油动力、钢铁、管道、废土与后启示录背景、炮塔</li><li>原子朋克(Atompunk)：冷战、原子技术、喷气技术和太空技术、核动力（核动力坦克、核动力火车）、共产主义苏维埃和未来主义建筑</li><li>真空管朋克(晶体管朋克)(Transistorpunk)：冷战、特定的60年代美式审美风格、镀铬技术、真空管、二代计算机、原子能  /<em>Rick的传送枪是不是…</em>/</li><li>生物朋克(Biopunk)</li><li>纳米朋克( Nanopunk)</li></ol><p>@ref: <a href="https://zhuanlan.zhihu.com/p/108032282" target="_blank" rel="noopener">科幻朋克大盘点 - 知乎</a></p><h2 id="原子朋克"><a href="#原子朋克" class="headerlink" title="原子朋克"></a>原子朋克</h2><p>冷战为背景，原子能及火箭技术发展为科技基础的美学形式及复古未来主义。原子朋克风格下的世界，核能技术得到高度发展与应用，人们的生活条件逐渐向好，建筑、服饰、交通工具等要素色彩鲜艳且视觉上十分干净，只是战争与毁灭的威胁时刻存在，社会结构普遍呈现出极端化的反乌托邦风格。</p><p>50、60年代对未来交通方式和载具的想象：<br><img src="/images/Atompunk-1.png" alt="../_images/Atompunk-1.png"></p><p>电影：《潜行者》（Сталкер），1979 ，塔可夫斯基，<br>其蓝本为前苏联科幻作家斯特鲁伽茨基兄弟创作的原著小说《路边野餐》<br><img src="/images/Atompank-Stalker.png" alt="../_images/Atompank-Stalker.png"></p><p>游戏：《原子之心》（Atomic Heart）：设定在平行时空下20世纪50年代的苏联，二战期间开发出的机器人和其他先进技术帮助苏联走上巅峰。这是一个理想化的乌托邦世界：社会和谐，环境优美；城市井然有序，阳光洒落在公园和城镇广场；科技发达，日常生活充满自动化，人类向太空发起冲击……生活看似完美无瑕，符合我们当今世界的期望。但随着这个理想世界的阴暗面逐渐显现，苏联的未来会走向何方？</p><p>建筑：The Presidium of Russian Academy of Sciences、the Palace of Soviet、Palace of Ceremonies…  // @ref: <a href="/63.Culture-and-Arts/Arch.建筑（苏联）/" title="Arch.建筑（苏联）">Arch.建筑（苏联）</a></p><p>相关：</p><ul><li><a href="https://www.gcores.com/articles/134239" target="_blank" rel="noopener">藏在「原子朋克」中的拓荒精神 | 机核 GCORES</a></li><li><a href="https://aesthetics.fandom.com/wiki/Atompunk" target="_blank" rel="noopener">Atompunk | Aesthetics Wiki | Fandom</a></li><li><a href="https://store.steampowered.com/app/668580/Atomic_Heart/" target="_blank" rel="noopener">Steam 上的Atomic Heart</a></li><li><a href="https://music.douban.com/subject/1762828/" target="_blank" rel="noopener">新裤子 我们是自动的</a></li></ul><h2 id="晶体管朋克"><a href="#晶体管朋克" class="headerlink" title="晶体管朋克"></a>晶体管朋克</h2><p>@todo</p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇怪的东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代主义文学</title>
      <link href="/63.Culture-and-Arts/%E7%8E%B0%E4%BB%A3%E4%B8%BB%E4%B9%89%E6%96%87%E5%AD%A6/"/>
      <url>/63.Culture-and-Arts/%E7%8E%B0%E4%BB%A3%E4%B8%BB%E4%B9%89%E6%96%87%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="现代主义文学"><a href="#现代主义文学" class="headerlink" title="现代主义文学"></a>现代主义文学</h1><blockquote><p><a href="https://baike.baidu.com/item/现代主义文学" target="_blank" rel="noopener">https://baike.baidu.com/item/现代主义文学</a></p></blockquote><ul><li><p>魔幻现实: 魔幻现实主义是通过“魔法”所产生的幻景来表达生活现实的一种创作方法。魔幻是途径，表现生活现实是目的。用魔幻的东西将现实隐去，展示给读者的是一个循环往复的、主观时间和客观时间相混合、主客观事物的空间失去界限的世界。艺术上则在现实描绘中引入大量超自然因素，奇迹、幻觉、梦境甚至鬼魂形象出现于小说情节中，时序关系常被打乱，叙述富于跳跃性，有时场面带有象征色彩，显示出鲜明的地狱和民族特点。它堪称是“移植”和“寻根”相结合的成功范例。它既是对现实的深刻开掘，又是对历史的严肃反思；既有对本大陆传统文化的寻本探源，又有对欧美现代主义的广泛吸收。</p><ul><li>马尔克斯：《百年孤独》</li></ul></li><li><p>超现实: 20年代兴起于法国，它由达达主义发展而来。1919达达派诗人：布勒东(创始人)发表了第一个《超现实主义宣言、阿拉贡（《共产党人》，社会主义现实主义作品，反法西斯）、艾吕雅。他们认为文学不是再现现实，而是要表现“超现实”，即由“梦幻与现实转化成的绝对现实”，是现实与非现实两种要素的统一物。在内容上为了描绘超现实，他们反对逻辑推理的思维活动，推崇潜意识和梦，甚至让文学成为梦幻、潜意识乃至精神错乱的产物。强调梦幻、贬斥理性，成为其美学的重要标志。他们主张写人的潜意识、梦境，写事物的巧合，并提出“自动写作法”来作为表现上述内容的创作方法。</p></li><li><p>象征主义: 象征主义具有鲜明的特征：创造病态的“美”；表现内心的“最高真实”；运用象征暗示；在幻觉中构筑意象；用音乐性来增加冥想效应。它发展了前期象征主义的艺术特点，反对肤浅的抒情和直露的说教，主张情与理的统一，通过象征暗示、意象隐喻、自由联想和语言的音乐性去表现理念世界的美和无限性。</p><ul><li>叶芝：《驶向拜占庭》</li><li>英国T·S·艾略特：《荒原》（1922）</li></ul></li><li><p>表现主义: 抽象化；变形；面具的运用；时空的真幻错杂；注重声光效果；象征和荒诞的手法。其理论纲领是“艺术是表现不是再现”，主张文学不应再现客观现实，而应表现人的主观精神和内在激情，表现透过表象所把握到的事物的本质，对事物外在形态的精确描绘毫无意义。其诗歌情绪炽烈、雄辩，追求力度，抒情方式夸张，常采用浓缩的诗句。戏剧和小说常采用抽象的象征手法表现深刻的哲理和主题。</p><ul><li>卡夫卡： 《城堡》（1915）、《变形记》（1915）</li></ul></li><li><p>意识流: 它以象征暗示、内心独白、自由联想等意识流的创作方法为主要特征，在本世纪20—30年代英、美、法等国形成一个颇为壮观的现代主义文学流派。意识流小说家所运用的艺术手法各有侧重，但艺术特征是共同的：“作家退出小说”；情节淡化；大量的内心独白和自由联想；时空交替和心理时间；象征暗示和对比联想；语言使用上的创新和变异。</p><ul><li>爱尔兰的乔伊斯：《都柏林人》、《青年艺术家的肖像》</li><li>英国的伍尔芙：《墙上的斑点》、《到灯塔去》</li><li>法国的普鲁斯特：《追忆似水年华》</li></ul></li><li><p>达达主义: 现代西方文艺流派。第一次世界大战期间产生于瑞士，1915年来自罗马尼亚的法国诗人斯当·查拉为首的艺术小集体，在苏黎世的咖啡馆里以随手翻到的词语“达达”命名，即是指纯粹出于偶然，没有任何意义，什么也不是。对文化传统、现实生活、艺术规律采取极端反叛的态度，反映了第一次世界大战期间欧洲青年一代中的一部分人的苦闷心理和寻找出路的状态。</p></li><li>存在主义: 存在主义文学在存在主义哲学基础上产生，它是以文学的形式宣传存在主义哲学思想。其特征是理性多于形象；核心是“存在先于本质”、“世界是荒谬的”，“人生是痛苦的和自由选择”，只有通过自由选择寻找生存之路。“荒谬”和“痛苦”是存在主义文学的基本主题。世界是荒谬的，人生是痛苦的，一方面描写资本主义世界的荒诞性，另一方面表现人的不幸与毁灭，以及孤独、失望、恐惧的思想情绪。</li></ul><hr><ul><li>(文化中的)现代主义: <a href="/63.Culture-and-Arts/现代主义（Modernism）/" title="现代主义（Modernism）">现代主义（Modernism）</a></li><li>解构主义: <a href="/63.Culture-and-Arts/解构主义/" title="解构主义">解构主义</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>现代主义(Modernism)</title>
      <link href="/63.Culture-and-Arts/%E7%8E%B0%E4%BB%A3%E4%B8%BB%E4%B9%89%EF%BC%88Modernism%EF%BC%89/"/>
      <url>/63.Culture-and-Arts/%E7%8E%B0%E4%BB%A3%E4%B8%BB%E4%B9%89%EF%BC%88Modernism%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/lives/735801655068483584" target="_blank" rel="noopener">现代主义与现代艺术 - 知乎 Live</a></p><ul><li>＊什么是 Modernism （现代主义），现代主义与我们所说的「现代」有啥不同？</li><li>＊现代主义都表现在哪几个方面？</li><li>＊如何理解现代主义艺术的思想根基？佛洛依德＋尼采＝世界都疯了</li><li>＊现代主义艺术的重要作品：毕加索，杜尚，波丘尼，未来主义里的「声音诗歌」</li><li>＊人类走入后现代时期，怀疑主义中产生的当代艺术</li></ul>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有趣的符号</title>
      <link href="/63.Culture-and-Arts/%E7%A5%9E%E7%A7%98%E5%AD%A6%E7%AC%A6%E5%8F%B7/"/>
      <url>/63.Culture-and-Arts/%E7%A5%9E%E7%A7%98%E5%AD%A6%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="有趣的符号"><a href="#有趣的符号" class="headerlink" title="有趣的符号"></a>有趣的符号</h1><p>@inbox：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/131343793" target="_blank" rel="noopener">宗教神秘学符号扫盲 - 知乎</a></li></ul><hr><h2 id="潘洛斯三角"><a href="#潘洛斯三角" class="headerlink" title="潘洛斯三角"></a>潘洛斯三角</h2><p>彭罗斯三角（Penrose triangle）是不可能物体中的一种。最早是由瑞典艺术家Oscar Reutersvärd在1934年制作。英国数学家罗杰·彭罗斯（Roger Penrose）及其父亲莱昂内尔·彭罗斯设计及推广，并在1958年2月份的《英国心理学月刊》（British Journal of Psychology）中发表，称之为“最纯粹形式的不可能”。</p><p><img src="/images/20220206234911.png" alt=""></p><h2 id="潘洛斯阶梯"><a href="#潘洛斯阶梯" class="headerlink" title="潘洛斯阶梯"></a>潘洛斯阶梯</h2><p><img src="/images/20220206235002.png" alt=""></p><h2 id="莫比乌斯环-mobius"><a href="#莫比乌斯环-mobius" class="headerlink" title="莫比乌斯环(mobius)"></a>莫比乌斯环(mobius)</h2><p>莫比乌斯带（德语：Möbiusband），又译梅比斯环、莫比乌斯环或麦比乌斯带，是一种只有一个面（表面）和一条边界的曲面，也是一种重要的拓扑学结构。它是由德国数学家、天文学家莫比乌斯和约翰·李斯丁在1858年独立发现的。这个结构可以用一个纸带旋转半圈再把两端粘上之后轻而易举地制作出来。事实上有两种不同的莫比乌斯带镜像，他们相互对称。如果把纸带顺时针旋转再粘贴，就会形成一个右手性的莫比乌斯带，反之亦类似。</p><h2 id="克莱因瓶"><a href="#克莱因瓶" class="headerlink" title="克莱因瓶"></a>克莱因瓶</h2><p>在数学领域中，克莱因瓶（德语：Kleinsche Flasche）是指一种无定向性的平面，比如二维平面，就没有“内部”和“外部”之分。克莱因瓶最初的概念提出是由德国数学家费利克斯·克莱因提出的。克莱因瓶和莫比乌斯带非常相像。<br>  要想像克莱因瓶的结构，可先试想一个底部镂空的红酒瓶。现在延长其颈部，向外扭曲后伸进瓶子的内部，再与底部的洞相连接。<br><img src="/images/20220206235116.png" alt=""></p><h2 id="衔尾蛇"><a href="#衔尾蛇" class="headerlink" title="衔尾蛇"></a>衔尾蛇</h2><p>@todo</p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇怪的东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赛博朋克</title>
      <link href="/63.Culture-and-Arts/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B/"/>
      <url>/63.Culture-and-Arts/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B</a></p><p>Cyberpunk 以信息技术为主体的科幻故事之分支。它的故事背景大都创建于“低端生活与高等科技的结合”（Combination of Low life and High tech）[2]，普遍拥有先进的科学技术，再以一定程度崩坏的社会结构做对比[3]；剧情框架时常关于社会秩序受到政府或财团、秘密组织的高度控制，而角色利用其中的漏洞做出了某种突破。类似风格者还有以蒸气技术为主体的“蒸气朋克”，和以生化技术为主体的“生化朋克”等。</p><p>赛博朋克很大程度上诞生于1960至1970年代的新浪潮科幻运动。当时的菲利普·狄克、罗杰·泽拉兹尼、J·G·巴拉德、菲利普·荷塞·法默和哈兰·艾里森等作家回避了早期科幻小说的乌托邦倾向，尝试描绘一个在毒品文化、科技以及性革命的冲击下所带来的新世界。</p><p>日本的赛博朋克作品始于1982年大友克洋的系列漫画《亚基拉》，其后1988年改编成的动漫电影使得这门科幻类别普及开来。</p><p>在早期的赛博朋克作品里，菲利普·狄克所著作的《仿生人会梦到电子羊吗？》最受注目，小说亦被改编成1982年电影《银翼杀手》，可以被看作是赛博朋克风格和主题的典型例子。</p><hr><p>@ref： <a href="https://zhuanlan.zhihu.com/p/20416279" target="_blank" rel="noopener">论香港为何成为赛博朋克的概念圣地——从《攻壳机动队》说起 - 知乎</a></p><blockquote><p>从词源上讲，赛博朋克（Cyberpunk）由单词『控制论』（Cybernetics）和『朋克』（Punk）组成。Cybernetics一词最初是指代表机器与动物互动、控制与沟通的理论，在通俗文化中则泛指电子人、机器人、电子手术等。而Punk一词从诞生之初就传达着来自社会底层的反叛之声，无论是朋克音乐还是朋克流行文化。</p></blockquote><p>香港为何成为赛博朋克的概念圣地？</p><ul><li>表——香港与赛博朋克在视觉特征上的契合</li><li>里——香港与赛博朋克在精神概念上的契合</li><li>一个猜想——对东方的好奇</li></ul>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解构主义</title>
      <link href="/63.Culture-and-Arts/%E8%A7%A3%E6%9E%84%E4%B8%BB%E4%B9%89/"/>
      <url>/63.Culture-and-Arts/%E8%A7%A3%E6%9E%84%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%A7%8B%E4%B8%BB%E7%BE%A9" target="_blank" rel="noopener">解构主义 - 维基百科，自由的百科全书</a></p><hr><p>如何简单地理解与区分解构主义与结构主义？ - Partfolio的回答 - 知乎<br><a href="https://www.zhihu.com/question/19631505/answer/906425529" target="_blank" rel="noopener">https://www.zhihu.com/question/19631505/answer/906425529</a></p><p>要了解结构主义，我们首先要知道它反对的是什么—-即“结构主义”。上世纪中期的法国，形成了一股结构主义（Constructionsim）潮流。结构主义的共同倾向在于试图把我研究对象的内在逻辑结构，从深层的结构分析中找出对象的意义。通俗的来说，就是将一切事物总结和归类，并为之确定一个中心。</p><p>解构在后现代的语境中实际上已经逐渐被通俗化为反对先有的一切框架并在此基础上提出质疑的一种方法论和批判精神，同时他的核心也在于反对二元对立论，这也是为什么解构能在服装设计和各个领域如此受追捧的原因。</p><blockquote><p>LGBTQ运动其实也是在逐渐解构性别二元对立论，让所有人都知道，这世界不仅只有男人和女人，也不是所有感情都是异性相吸。然而其实许多人误解了解构主义。“其实，解构主义不是一种新的建筑风格，也不是一种反建筑或社会的先锋运动。 它既不遵循“规则”，也不是为了获得特定的美学，又不是反对社会困境的反叛。 它是释放形式和体量的无限可能性。”</p></blockquote><p>在解构主义的思想诞生的十几年后，就出现了以杜尚为代表的达达主义艺术流派。<br>1915年到1922年一群艺术家，在瑞士集结，以一种无政府主义的，荒诞的，非理性的，自我主义的，杂乱无章的，反传统的，随意形式的表现形式，来反对世界大战的毫无意义的暴力，否定不可信的政府。</p><p>他们认为政府是不可信的，社会是不可信的，历史是不可信的，甚至语言也是不可信的。强调个人主义，虚无主义<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，他们的诗歌没有语言，只有语气词；他们的艺术是用现成的产品贴出来的或者是印刷品。这就是达达—-它反对一切形式的权威，反对一切规律性的规律，唯一可以相信的就是恒变，随机性，调侃性是它的表现手法。其中的佼佼者杜尚展出了一件惊动整个世界的作品《泉》。</p><p><img src="/images/杜尚-泉.png" alt=""></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">[[../61.Philosophy/10.虚无主义]]</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绘画流派</title>
      <link href="/63.Culture-and-Arts/%E7%BB%98%E7%94%BB%E6%B5%81%E6%B4%BE/"/>
      <url>/63.Culture-and-Arts/%E7%BB%98%E7%94%BB%E6%B5%81%E6%B4%BE/</url>
      
        <content type="html"><![CDATA[<p>▶ 印象派:<br><a href="https://zh.wikipedia.org/wiki/%E5%8D%B0%E8%B1%A1%E6%B4%BE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8D%B0%E8%B1%A1%E6%B4%BE</a><br>印象派（法语：Impressionnisme），是指于1860年代法国开展的一种艺术运动或一种画风。印象派的命名源自于莫奈于1874年的画作《印象·日出》，遭到学院派的攻击，并被评论家路易·乐华挖苦是“印象派”（起源）。<br>印象派画作常见的特色是笔触未经修饰而显见，构图宽广无边，尤其着重于光影的改变、对时间的印象，并以生活中的平凡事物做为描绘对象。著名的艺术家有莫内、马内、窦加、雷诺阿等，其中塞尚后开创了后印象派。</p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蒸汽波</title>
      <link href="/63.Culture-and-Arts/%E8%92%B8%E6%B1%BD%E6%B3%A2/"/>
      <url>/63.Culture-and-Arts/%E8%92%B8%E6%B1%BD%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p>@tag: #蒸汽波 #赛博朋克 #大卫</p><hr><h2 id="What’s-蒸汽波-Vaporwave"><a href="#What’s-蒸汽波-Vaporwave" class="headerlink" title="What’s 蒸汽波(Vaporwave)"></a>What’s 蒸汽波(Vaporwave)</h2><p><a href="https://baike.baidu.com/item/%E8%92%B8%E6%B1%BD%E6%B3%A2/23614172" target="_blank" rel="noopener">蒸汽波_百度百科</a>：“是一种受cyberpunk文化影响很深的online microscenes” // @ref: <a href="/63.Culture-and-Arts/赛博朋克/" title="赛博朋克">赛博朋克</a></p><p>Vapor：水汽、水蒸气；无实质之物、自夸者；幻想；蒸汽浪潮。</p><p>Vaporwave兴起于2010年初期，2014~2015年几乎达到全盛时期，关于vaporwave的音乐创制和艺术作品开始崭露头角，已经衍生出一系列的子文化和周边产品，具有大量多样性和模糊性的亚风格类别和信息传达。<br>vaporwave既是批评和讽刺后工业时代的消费主义社会，80年代的雅皮士文化，同时那种低保真音质和Album Art也展现出了好奇与迷恋的怀旧感。</p><p>在蒸汽波的元素中，运用最多的有：海豚、像素风、大卫等各种石膏像、故障艺术、椰子树、棕榈树、旧window弹窗、赛博朋克、绚丽的色彩、油漆桶色彩等复古视觉元素。</p><p><img src="/images/Vaporwave-and-David.png" alt="../_images/Vaporwave-and-David.png"></p><h2 id="蒸汽波与赛博朋克有什么关联？-知乎"><a href="#蒸汽波与赛博朋克有什么关联？-知乎" class="headerlink" title="蒸汽波与赛博朋克有什么关联？ - 知乎"></a><a href="https://www.zhihu.com/question/60055795" target="_blank" rel="noopener">蒸汽波与赛博朋克有什么关联？ - 知乎</a></h2><p>既然谈到关联，基本上就要往这种审美风格的<strong>文化内涵</strong>上靠拢了。</p><p><strong>赛博朋克的文化内涵和背景是后资本主义时代</strong>。寡头经济，财富高度集中，形成永久性的财富阶级，科技超高但统治阶级漠视庞大的底层人的生活。硬要说的话，赛博朋克的审美元素是从北欧风，工业风上面一脉相承过来的。</p><p>蒸汽波是这个年代去怀念泡沫年代的一种符号。怀念的本体，其实是city pop风格，泡沫都市。但是因为有怀念这个过程在，city pop变得不再是最合适描述泡沫都市的风格了，而是蒸汽波。也就是说，city pop是那个年代的现在时，而蒸汽波是那个年代的过去时。个人对于审美风格的成因理解。<strong>因为思想过程会对审美元素进行适当加工和扭曲</strong>。</p><p>总的来说，<strong>赛博朋克是未来，而蒸汽波是过去。</strong></p><p>这两种风格我都写了文章：</p><p>《审美2020》- 赛博朋克 - 蒸汽姬的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/355480559" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/355480559</a></p><p>《审美2020》- 蒸汽波 - 蒸汽姬的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/355480339" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/355480339</a></p><h2 id="lofi，jazzhiphop，蒸汽波应该如何区分-知乎"><a href="#lofi，jazzhiphop，蒸汽波应该如何区分-知乎" class="headerlink" title="lofi，jazzhiphop，蒸汽波应该如何区分? - 知乎"></a><a href="https://www.zhihu.com/question/310869566" target="_blank" rel="noopener">lofi，jazzhiphop，蒸汽波应该如何区分? - 知乎</a></h2><p>lofi指的是刻意去追求低音质，模拟磁带/低采样率/失真效果。jazz hip-hop和蒸汽波可以是lofi的，由于这二者采样的来源会有lofi的成分，有些选择把低音质的美学放大了而已；但lofi不尽然是以上两种，比如说outsider house（例子：Ross From Friends）。</p><p>jazz hip-hop，实际上就是指以爵士乐、放克、灵歌等等你听着就很黑人的音乐为主要采样源和音乐灵感的嘻哈音乐，是爵士和嘻哈的融合产物。素材上跟vaporwave有重合之处，但是蒸汽波可能还有city pop等等上世纪后期的流行曲风。并且，jazz hip-hop的形式还是嘻哈音乐，听节奏就听得出来。</p><p>vaporwave（蒸汽波）发展到现在，已经从一个网络梗变成一种美学了，而且主要是一种美学。其内核可以说是一种（虚幻的）怀旧，主要手法是对过去的流行事物进行放大，扭曲和拼贴。蒸汽波现在有很多种形式，比如融合了disco和house成分的future funk，还有放大了lounge成分的mallsoft，但总的来说其美学跟jazz hip-hop是不一致的。jazz hip-hop可能更偏向于一种流畅自由的感觉，可以有lofi的怀旧感，但不会直接指向某一个文化符号。蒸汽波则是怀旧、超现实感、城市文化记忆、消费主义、早期互联网、90年代资本主义世界、经典赛博朋克等一大团属于过去的幻觉的当代改造。也就是说，还是要多听。</p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>克苏鲁</title>
      <link href="/63.Culture-and-Arts/%E5%85%8B%E8%8B%8F%E9%B2%81/"/>
      <url>/63.Culture-and-Arts/%E5%85%8B%E8%8B%8F%E9%B2%81/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://zhuanlan.zhihu.com/p/24254182" target="_blank" rel="noopener">来自深海的呼唤——简述克苏鲁神话体系 - 知乎</a></li><li><a href="https://www.gcores.com/articles/26797" target="_blank" rel="noopener">什么是“克苏鲁式恐惧”？对克苏鲁神话体系的探讨与个人观点 | 机核 GCORES</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇怪的东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缪斯</title>
      <link href="/63.Culture-and-Arts/%E7%BC%AA%E6%96%AF/"/>
      <url>/63.Culture-and-Arts/%E7%BC%AA%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<p>@tag: #希腊神话</p><p>缪斯是希腊神话主司艺术与科学的九位古老文艺女神的总称。她们代表了通过传统的音乐和舞蹈、即时代流传下来的诗歌所表达出来的神话传说。她们原本是守护赫利孔山泉水的水仙，属于宁芙的范畴。后来人们将奥林匹斯神系的阿波罗设立为她们的首领。缪斯女神常常出现在众神或英雄们的聚会，轻歌曼舞，一展风采，为聚会带来不少的愉悦与欢乐。</p><p>缪斯即是艺术的代表，也是艺术本身（英语中music，音乐，一词来自缪斯）。在希腊人掌握文字以前，缪斯也是学习的代表和神。泰勒斯所写的第一本希腊的天文学书籍就是以诗的体裁写的，许多苏格拉底以前的哲学书的体裁也是诗体。柏拉图和毕达哥拉斯都认为哲学是艺术（μουσική）的一部分。希罗多德将他写的《历史》的每一卷以一个不同的缪斯命名。</p><hr><p>在文学作品中，缪斯常常是叙述者的身份，而作者本人不过是记录者。赫西俄德（Hesiod）被称为“希腊训谕诗之父”，他经常去缪斯的居住地赫利孔山（Helicon），他称有一天放羊时，缪斯给予他写诗的本领，告诉他诸神的故事，于是他写下了《神谱》。</p><p>根据《神谱》，缪斯是宙斯与记忆女神谟涅摩叙涅（Mnemosyne）的九个发束金带的女儿。她们最开始是赫利孔山的泉水仙女，有一匹长有双翼的白马相伴，这匹马是马神珀伽索斯（Pegasus），为美杜莎与海神波塞冬所生。据说当珀伽索斯踏过赫利孔山的土地时，圣泉喷涌而出，其中一眼是希波克里尼灵感泉（Hippocrene），可使饮用之人写出美妙的诗句。</p><p>缪斯能歌善舞，其后代也都继承了艺术天赋，擅弹七弦琴的俄耳甫斯和歌声美妙的海妖塞壬都是缪斯的子女。塞壬曾与缪斯进行歌唱比赛，最终塞壬惨败，被缪斯拔光了羽毛，从而失去了翅膀无法飞翔，缪斯用塞壬的翅膀编织成了象征自己胜利的王冠。此外，还有一位叫塔米里斯（Thamyris）的歌手向缪斯发起歌唱挑战落败，缪斯惩罚他的狂傲使他失明，还收回他写诗和弹奏七弦琴的才华，可见人类的才华都是缪斯赐予的，她可以给予，也可以收回。</p><p><a href="https://www.metmuseum.org/learn/educators/lesson-plans/muses-vs-sirens" target="_blank" rel="noopener">Muses vs. Sirens</a>：<br><img src="/images/Muses%20vs%20Sirens.png" alt="../_images/Muses vs Sirens.png"></p><blockquote><p>Marble sarcophagus with the contest between the Muses and the Sirens, 3rd quarter of 3rd century A.D. Roman. Marble, Pentelic, 21 3/4 x 77 1/4 x 22 1/2 in. (55.3 x 196.2 x 57.2 cm). The Metropolitan Museum of Art, New York, Purchase, Rogers Fund, 1910 (10.104)</p></blockquote><p>古希腊有很多神殿供诗人向缪斯祈求灵感，神庙中陈列着与缪斯相关的艺术品，这就是博物馆（museum）的起源。英语单词museum由muse（缪斯）和表示“场所”的后缀-um组成，本意就是“缪斯的神殿”。此外，英语单词music（音乐）和mosaic（马赛克）也来自缪斯，本意分别是“art of the Muses”（缪斯的艺术）和“work of the Muses”（缪斯的作品）。</p><p>关于缪斯的人数有众多说法，最早只有三位缪斯，是三位一体的老一辈诗歌女神，但比较经典常见的说法还是九位，九位缪斯女神司管着不同领域，艺术作品中的形象各不相同。</p><p>@ref: <a href="https://zhuanlan.zhihu.com/p/359919585" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/359919585</a></p><hr><p>缪斯（文艺） - 涅墨西斯（复仇）- 摩伊赖（命运） - 比亚（暴力） - 克拉托斯（力量） - 厄洛斯（爱）- 忒弥斯（正义） - 墨提斯（智慧） - 塔那托斯（死亡） - 许普诺斯（睡眠）</p><hr><p>@link: [[../64.Novel-and-Poesy/R02.阿赫玛托娃]] / 致缪斯</p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SCP</title>
      <link href="/63.Culture-and-Arts/SCP/"/>
      <url>/63.Culture-and-Arts/SCP/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/SCP.png" alt="../_images/SCP.png"></p><p>SCP基金会是一个虚构的特工组织，作为同名互联网接龙小说创作项目中的主要要素。在该虚构宇宙中，SCP基金会是一个跨国秘密组织，负责搜寻并收容各种具有异常属性的个体、地点或物体（统称为“异常”），其宗旨为“控制”（Secure），“收容”（Contain），“保护”（Protect）。在现实世界中，SCP基金会是一个基于网站社区的协同写作小说项目，其文章包含多种类型的元素和风格，如科学幻想、都市奇幻和恐怖小说。</p><hr><p>YouTube上的SCP介绍：<a href="https://www.youtube.com/c/scpexplainedstoryanimation" target="_blank" rel="noopener">SCP Explained - Story &amp; Animation - YouTube</a></p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇怪的东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Roger Waters-如何回应偏见</title>
      <link href="/63.Culture-and-Arts/Roger%20Waters-%E5%A6%82%E4%BD%95%E5%9B%9E%E5%BA%94%E5%81%8F%E8%A7%81/"/>
      <url>/63.Culture-and-Arts/Roger%20Waters-%E5%A6%82%E4%BD%95%E5%9B%9E%E5%BA%94%E5%81%8F%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=ml373MHAtXo&amp;ab_channel=CNN" target="_blank" rel="noopener">(2) Pink Floyd co-founder explains meaning behind warning at the top of his show - YouTube</a></p><p>Roger Waters 告诉 Michael Smerconish：“You’re not reading enough” 你该多读书</p><p><img src="/images/Youre-not-reading-enough.png" alt="../_images/Youre-not-reading-enough.png"></p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>北京建筑上的大屋顶</title>
      <link href="/63.Culture-and-Arts/Arch.%E5%8C%97%E4%BA%AC%E5%BB%BA%E7%AD%91%E4%B8%8A%E7%9A%84%E5%A4%A7%E5%B1%8B%E9%A1%B6/"/>
      <url>/63.Culture-and-Arts/Arch.%E5%8C%97%E4%BA%AC%E5%BB%BA%E7%AD%91%E4%B8%8A%E7%9A%84%E5%A4%A7%E5%B1%8B%E9%A1%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么北京很多房子上，总要加个这样的「大屋顶」？-知乎"><a href="#为什么北京很多房子上，总要加个这样的「大屋顶」？-知乎" class="headerlink" title="为什么北京很多房子上，总要加个这样的「大屋顶」？ - 知乎"></a><a href="http://daily.zhihu.com/story/9634341" target="_blank" rel="noopener">为什么北京很多房子上，总要加个这样的「大屋顶」？ - 知乎</a></h2><p>/<em>这算不算一种“反-批判地域性主义”？@ref: <a href="/63.Culture-and-Arts/Arch.批判地域性主义/" title="Arch.批判地域性主义">Arch.批判地域性主义</a></em>/</p><hr><p>1895 年甲午战争战败之后，清廷上下积极提倡洋化。清末所有的衙署都建成了西洋风格，民间在 1900 年后建的商业铺面也都热衷西洋装饰。</p><p>中式传统民居更是被贬得一无是处。1905 年《汉口日报》一篇文章将中西住房做了一番对比称：「（中国民居）入其室则黑暗世界；而西人洋楼高矗，窗闼洞开，足以收纳空气……比之华民住屋，真有天堂地狱之分。」</p><p>这种情况并没有持续太久。中式民居虽然永堕「地狱」，但殿堂式建筑的「大屋顶」不久就时来运转，第一次世界大战爆发后，中国人在战火连天的欧洲面前重拾自信，社会精英们脱下西服，换回了长衫马褂。</p><p>中国人民的文化自信，很快刮到了建筑领域。</p><p>1930 年前后，国民政府定都南京后，在建筑上大力推崇「中国固有之形式」，给西式建筑增加中式大屋顶的重任，也就交到了中国建筑师手里。</p><p>直到抗战爆发前，国民政府主持修造了中山陵等一大批政府机关和公共事业建筑，大多都采用了西式建筑结构加「大屋顶」的形式。</p><p>不过，虽然「大屋顶」有官方加持，在南京等地声势浩大且波及北京，但在当时建筑界，就已不乏质疑之声。</p><p>著名建筑学家梁思成认为，「大屋顶」建筑在理论和设计建造方面都存在明显的缺陷，「均注重外形的摹仿，而不顾中外结构之异同处，所采用的四角翘起的中国式屋顶，勉强生硬的加在一座洋楼上，其上下结构划然不同旨趣」。</p><p>在梁思成看来，中国古代建筑的优点在于其梁架式结构，与现代建筑的框架结构有很多异曲同工之处，并且「每个部分莫不是内部结构坦率的表现」，合乎现代建筑设计原则。生硬采用钢筋混凝土去模仿木构架建筑的具体形态，破坏了中式建筑的真趣味，是最不聪明的借鉴手法。</p><p>同时，梁思成还指出，给近现代西式建筑强行加大屋顶在经济并不划算，「糜费侈大」，不适应当时中国贫弱的基本国情。</p><p>直到 1949 年后，梁思成等人的在「大屋顶」问题上仍然态度顽固。1950 年 1 月，梁还在营建学研究会上强调：「（大屋顶建筑）不伦不类，犹如一个穿西装的洋人，头戴红缕帽，胸前挂一块缙子，脚上穿一双朝靴，自己以为是一个中国人！」</p><p>不过，随着苏联专家的到来，梁思成们很快投降了。</p><p>「要像爱女朋友那样爱民族形式」</p><p>50 年代初，大批苏联援华专家来到中国，其中也包括市政与建筑专家。</p><p>在当时特殊的政治环境下，苏联专家们理所当然地把持了中国建筑界的话语权，他们传达给中方的信息相当明确：采用民族形式才是社会主义建筑，坚决与资产阶级的现代主义建筑划清界限。</p><p>苏联专家们的意见，代表了苏联最高领袖的意见。早在 1935 年，在斯大林亲自指导下，苏联公布了《改建莫斯科市总计划的决议》，指出要以「民族形式」表达「社会主义的内容」。</p><p>随后设立的苏联建筑科学院，更明确表示要对「资产阶级的」现代主义建筑流派进行「歼灭性打击」。</p><p>这种环境下锻炼出来的苏联援华专家，当然执着于「民族形式」。如苏联专家维拉索夫就表示，他「看见上海就愤怒」，因为上海遍地西洋式建筑，缺乏民族风格，「很不进步」。另一位在清华大学指导建筑教学的专家阿谢普可夫，则要求学生「要像爱女朋友那样爱民族形式」。</p><p>至于中国建筑的民族风格是什么样的，苏联专家们也早已成竹在胸。1949 年 9 月，苏联市政专家组组长阿布拉莫夫第一次见到中方人员时，就专门嘱咐北京建筑要搞成西直门那样的「民族形式」，怕中方人员不懂，还在纸上勾画了一个箭楼的轮廓。</p><p>中共对苏联专家的意见深表认同，《人民日报》对建筑学界提出要求，在首都建设的建筑设计上「必须批判和克服资本主义的设计思想，学习社会主义的设计思想，特别是向苏联专家学习」。</p><p>从 1951 年开始，以梁思成为首的北京建筑学界开展了多次自我批判，「痛悔过去误信了割断历史的建筑理论」，将一贯认可的「国际主义」建筑和现代主义建筑风格都视为反动的、代表资产阶级的、世界主义的体现。</p><p>即便如此，北京建筑界还是对到底应该如何发扬民族风格表示了疑虑：「创造我们的新建筑。这是一个极难的问题。老实说，我们全国的营建工作者恐怕没有一个人知道怎样去做。」</p><p>1952 年建成的「四部一会」大楼，几个大屋顶共花费 30 多万元<br><img src="/images/IMG20220922-11.png" alt=""></p><p>1952 年建成的地安门机关宿舍大楼，顶部 6 个亭子的工料造价达 54.6 万元<br><img src="/images/IMG20220922-12.png" alt=""></p><p>「梁思成路线」被打倒后，北京的建筑风格问题并未得出答案：不加装饰的现代风格是「资本主义」，加「大屋顶」又是「封建复古主义」，到底该盖什么样的房子？</p><p>答案在 1958 年揭晓。</p><p>为庆祝国庆十周年，展现建国伟大成就，北京决定建设一批庆典建筑，即「十大建筑」。高层明确指示，重大建筑仍要采用「民族形式」，因此大屋顶建筑仍占很大的比例，如民族文化宫、全国农业展览馆、北京火车站等。其他建筑也或多或少带有传统装饰元素。</p><p><img src="/images/IMG20220922-13.png" alt=""></p><p><img src="/images/IMG20220922-14.png" alt=""></p><p><img src="/images/IMG20220922-15.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Arch.批判地域性主义</title>
      <link href="/63.Culture-and-Arts/Arch.%E6%89%B9%E5%88%A4%E5%9C%B0%E5%9F%9F%E6%80%A7%E4%B8%BB%E4%B9%89/"/>
      <url>/63.Culture-and-Arts/Arch.%E6%89%B9%E5%88%A4%E5%9C%B0%E5%9F%9F%E6%80%A7%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>批判地域性主义(Critical Regionalism)是一个建筑学词汇，指一种利用建筑物所在的地理文脉(Geographical context)信息反对现代建筑中出现的没有归属性(Identity)和无位置感(Placelessness)的理论态度。</p><ul><li><a href="https://www.archdaily.cn/cn/966943/zai-ping-pi-pan-xing-di-yu-zhu-yi-zai-di-jian-zhu" target="_blank" rel="noopener">再评批判性地域主义：在地建筑 | ArchDaily</a></li><li><a href="https://baike.baidu.com/item/%E6%89%B9%E5%88%A4%E5%9C%B0%E5%9F%9F%E6%80%A7%E4%B8%BB%E4%B9%89/2357397" target="_blank" rel="noopener">批判地域性主义_百度百科</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Arch-建筑（苏联）</title>
      <link href="/63.Culture-and-Arts/Arch.%E5%BB%BA%E7%AD%91%EF%BC%88%E8%8B%8F%E8%81%94%EF%BC%89/"/>
      <url>/63.Culture-and-Arts/Arch.%E5%BB%BA%E7%AD%91%EF%BC%88%E8%8B%8F%E8%81%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/28062459" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28062459</a></p><ol><li>Druzhba Sanatorium，“友谊疗养院”， 1985，乌克兰克里米亚<br> 这个疗养院建在乌克兰的雅尔塔（Yalta，学过中学历史都听过这个地方吧）的海边，像一个飞碟停在一根大柱子上面，现在就是个休闲娱乐场所。<br><img src="/images/IMG20220923-7.png" alt="../_images/IMG20220923-7.png"></li></ol><ol start="2"><li><p>Ministry of Highways，1975，格鲁吉亚第比利斯<br> 这是前苏联的一个标识化的未来主义建筑，在格鲁吉亚的首都Tbilisi（第比利斯），当初修建了是为了当他们高速公路部（一个政府部门）的办公大楼的。建筑师就是当时的高速路部长Giorgi Chakhava。设计就是为了让建筑更少量地接触地面，阳光可以从更多的角度照射进窗子。在苏联解体后这个建筑物被废弃了十几年，后来被格鲁吉亚银行（Bank of Georgia，就是一个商业银行，不是央行）买了下来，内部装修全部重新做了一遍。现在就是这个银行的总部大楼了。<br><img src="/images/IMG20220923-8.png" alt="../_images/IMG20220923-8.png"></p></li><li><p>Palace of Ceremonies, 1985, Tbilisi，格鲁吉亚<br> 这又是一个修建在格鲁吉亚首都第比利斯的后现代建筑，被叫做“典礼宫殿”。这种建筑故意被造成有教堂的特征，因为它起的作用就是教堂该有的功能，比如婚礼，孩子出生庆祝，等等。但有个严格的要求便是，只有非基督徒才能使用这个地方。这栋建筑便是苏联对无神论主张的一种态度。<br><img src="/images/IMG20220923-9.png" alt="../_images/IMG20220923-9.png"></p></li><li><p>House of Soviet，1970开建，一直未完工，俄罗斯<br> 这个栋烂尾楼是苏联的粗野主义（Brutalist style）的一个典范。这栋楼在俄罗斯的飞地Kaliningrad（加里宁格勒，在立陶宛和波兰之间），而且所在这片地非常出名，就是在Königsberg castle（哥尼斯堡城堡）原址上修建出来的。因为哥尼斯堡城堡在二战时被炸得几乎不能复原，所以直接拆了，原址基础上修了这么一个怪物。<br><img src="/images/IMG20220923-10.png" alt="../_images/IMG20220923-10.png"></p></li></ol><ol start="5"><li><p>Circle houses of Moscow, 1972，俄罗斯<br> 这栋楼是为了献给1980年莫斯科奥运会而修建的，当时设计的是5个环，但修了一个环之后发现财力完全跟不上，就只好停了。但好的地方是，至少把这个圆给修完了。<br><img src="/images/IMG20220923-11.png" alt="../_images/IMG20220923-11.png"></p></li><li><p>Institute of Robotics and Technical Cybernetics，1968，俄罗斯<br> 在俄罗斯圣彼得堡的国家机器人研究院，这个研究院的主攻方向就是太空船和军用机器人，因为形状奇特，在当地被人叫做“白色郁金香”。这个地方属于军事重地，所以这个建筑物很难靠近，更不可能有无人机之类的飞过去看。<br><img src="/images/IMG20220923-12.png" alt="../_images/IMG20220923-12.png"></p></li><li><p>Space Arches，1983，格鲁吉亚<br> 第比利斯的“玫瑰革命广场”（命名于2003年在格鲁吉亚发生的一场革命，在这一年对于格鲁吉亚才算真正意义上结束了前苏联的统治，虽然那个时候前苏联已经消失了十多年了）上的后现代建筑拱门显得非常奇幻。在拱门前面有个很大的广场，一直延伸到Kura river的岸边。但很可惜，后来整个拱门在2005年因为政局改变，这种象征前苏联思想的产物会成为首当其中被毁掉的建筑。<br><img src="/images/IMG20220923-13.png" alt="../_images/IMG20220923-13.png"></p></li><li><p>Grodno Drama Theater，1984，白俄罗斯<br> Grodno是白俄罗斯与波兰边界的一个小城市，这里修建的剧院中心在当地绝对是异类。它坐落在尼曼河边，像一座发狂的堡垒一样。<br><img src="/images/IMG20220923-14.png" alt="../_images/IMG20220923-14.png"></p></li></ol><ol start="9"><li>Hotel Salute, 1984，乌克兰基辅<br> 乌克兰的“致敬酒店”（我也不知道有官方的翻译没，我自己就是这么叫的）便矗立在基辅市中心。<br><img src="/images/IMG20220923-15.png" alt="../_images/IMG20220923-15.png"></li></ol><ol start="10"><li><p>The Presidium of Russian Academy of Sciences，1994，俄罗斯<br>这栋楼是俄罗斯国家科学院，坐落在莫斯科，修了将近二十年，在1994年才完工。在顶部有玻璃与金属所构成的装饰，当地人都把这个栋楼的顶部叫做“金色大脑”。<br><img src="/images/IMG20220923-16.png" alt="../_images/IMG20220923-16.png"></p></li><li><p>Housing complex，1976，格鲁吉亚<br>窗子被做成半圆的样子特别有未来主义的风格，再加上斑驳苍凉的水泥石墙，这些建筑显得特别有工业质感。<br><img src="/images/IMG20221001.png" alt="../_images/IMG20221001.png"></p></li><li><p>the Palace of Soviet，未修建，设计于上世纪30年代<br>当时设计这栋楼的时候，目的在于让这栋楼成为整个苏联的行政管理中心，所以叫它“苏联宫殿”，当时设计了有100层楼，高度有将近495米（现在上海环球金融中心高达492米，是世界第七高的摩天楼），可以想象野心有多大。<br><img src="/images/IMG20221001-1.png" alt="../_images/IMG20221001-1.png"></p><p><img src="/images/IMG20221001-2.png" alt="../_images/IMG20221001-2.png"></p><hr></li></ol><p>苏联之所以喜欢修这么多未来主义的建筑其实是因为在上世纪20到30年代受到意大利未来主义思潮的影响，再加上苏联在这时才建立，百业待兴。同时国家意志展现了疯狂的强势面，在这种环境下，苏联的诗人，艺术家到建筑师都对未来充满了极大的期待，因为大家都从没见过一个国家能这么高度的中央集权，集中全国的资源来办一件事情。</p><p>我们可以看一下苏联在上世纪70年代，也就是修建以上建筑物的年代，是怎么憧憬未来的。</p><p>这是停车场，车辆全部被运到钢架之上悬挂。<br><img src="/images/IMG20221001-3.png" alt="../_images/IMG20221001-3.png"></p><p>未来的航运与陆地交通体系。</p><p><img src="/images/IMG20221001-4.png" alt="../_images/IMG20221001-4.png"></p><p><img src="/images/IMG20221001-5.png" alt="../_images/IMG20221001-5.png"></p><p><img src="/images/IMG20221001-6.png" alt="../_images/IMG20221001-6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Arch-建筑（欧洲）</title>
      <link href="/63.Culture-and-Arts/Arch.%E5%BB%BA%E7%AD%91%EF%BC%88%E6%AC%A7%E6%B4%B2%EF%BC%89/"/>
      <url>/63.Culture-and-Arts/Arch.%E5%BB%BA%E7%AD%91%EF%BC%88%E6%AC%A7%E6%B4%B2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="古希腊与古罗马建筑"><a href="#古希腊与古罗马建筑" class="headerlink" title="古希腊与古罗马建筑"></a>古希腊与古罗马建筑</h2><p>第一个区别：古罗马神殿只有正面一个台阶入口，其他方向都是高出地面数米的基底。而古希腊则把神殿的基底都修成台阶，让人可以从四面八方进入。</p><p>也许背后的原因在于古希腊人对神祇的看法并不像古罗马人那样具有完备的仪式感与疏离感。神祇对于古希腊人来说更加亲密，更容易敬拜。</p><p>第二个区别：古罗马很注重神殿正面入口的建造，会花大量精力在正面的雕塑与造型上面。而且背面和部分侧面往往是用墙封闭起来的。</p><p>前面三种柱式是古希腊用的，古罗马时期又创造了后面两种，但是他们仍然也使用前面三种。<br><img src="/images/IMG20220923-6.png" alt=""></p><h2 id="拜占庭风格"><a href="#拜占庭风格" class="headerlink" title="拜占庭风格"></a>拜占庭风格</h2><p>建筑内部无支撑的圆形穹顶。穹隅和角拱是拜占庭建筑工程技术的标志，它们使得这种样式得益可能并且大量普及。</p><p><img src="/images/IMG20220923-17.png" alt=""></p><h2 id="哥特风格"><a href="#哥特风格" class="headerlink" title="哥特风格"></a>哥特风格</h2><p>尖塔高耸、尖形拱门、大窗户及绘有圣经故事的彩色大玻璃。设计中利用十字拱、飞券、修长的立柱，营造出轻盈修长的飞天感。</p><p>飞扶壁（英语：Flying buttresses）是一种起支撑作用的建筑结构部件，凌空跨越下层附属空间（如走道、小祈祷室等）连接到顶部高墙上肋架券的起脚部位，用于平衡肋架拱顶（英语：Rib vault）对墙面的侧向推力。</p><p>飞扶壁：<br><img src="/images/IMG20220923-18.png" alt=""></p><h2 id="巴洛克风格"><a href="#巴洛克风格" class="headerlink" title="巴洛克风格"></a>巴洛克风格</h2><p>17~18世纪在意大利文艺复兴建筑基础上发展起来的一种建筑和装饰风格。其特点是外形自由，追求动感，喜好富丽的装饰、雕刻和强烈的色彩，常用穿插的曲面和椭圆形空间来表现自由的思想和营造神秘的气氛。</p><p>巴洛克（Baroque）此字源于西班牙语及葡萄牙语的“变形的珍珠”(—barroco)。作为形容词，此字有“俗丽凌乱”意。欧洲人最初用这个词指“缺乏古典主义均衡特性的作品”，它原是18世纪崇尚古典艺术的人们，对17世纪不同于文艺复兴风格的一个带贬义的称呼，现今这个词已失去了原有的贬义，仅指17世纪风行于欧洲的一种艺术风格。</p><p>巴洛克建筑风格特征：</p><p>1、它有豪华的特色，它既有宗教的特色又有享乐主义的色彩； // 建筑的正面有很复杂的雕塑，不再严格使用对称原则</p><p>2、它有着浓重的宗教色彩，宗教题材在巴洛克艺术中占有主导的地位；</p><p>3、大多数巴洛克的艺术家有远离生活和时代的倾向，如在一些天顶画中，人的形象变得微不足道，如同是一些花纹</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/51293458" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51293458</a></li><li><a href="https://www.bunbo.com.cn/news/architecture/2012/italy.html" target="_blank" rel="noopener">https://www.bunbo.com.cn/news/architecture/2012/italy.html</a></li></ul><h2 id="附：希腊石柱"><a href="#附：希腊石柱" class="headerlink" title="附：希腊石柱"></a>附：希腊石柱</h2><p>古希腊最主要的大型建筑是神庙。那时人们信奉的是多神教，各行各业个地方都有自己的守护神。希腊神庙的建筑特点是广泛地运用石柱。因此基石、柱子和盖在他上面的檐部的处理，基本上决定了神庙的外貌。列柱之美即建筑美学的具体体现。古代希腊人创造了多立克、爱奥尼亚、科林斯3种石柱形态。</p><ul><li><p>多立克柱式——是较为朴实庄重的一种柱式，为多里安人所创造的。他的柱身比例较为粗短，柱的下端直接置于石台上，不加另外基座。柱的顶端是由一扁圆形垫石托着一块厚实的方形石板，再与上面的楣梁连接，整个柱形朴素、稳重、坚固。著名的雅典卫城的帕提农神庙即采用的是多立克柱式。</p><p><img src="/images/IMG20220923-2.png" alt=""></p></li><li><p>爱奥尼亚柱式——由小亚细亚沿海的伊奥尼亚人所创造的。他的柱身修长，垂直线纹精细。柱的底部加上了圆形基座，柱的顶端加了涡卷形装饰。整个柱式优美、轻灵、典雅。广泛出现在古希腊的大量建筑中，如雅典卫城的俄瑞克忒翁神庙。<br><img src="/images/IMG20220923-1.png" alt=""></p></li></ul><ul><li><p>科林斯柱式——出现较晚，流行于希腊化时期，最初为科林斯人所创造而得名。这种柱式是从爱奥尼亚式变化而成，所不同的是柱顶端的一对漩涡形纹没有了，代之以繁密重迭的卷叶形装饰，更显的精致华美。科林斯柱式最初用于建筑内部，到希腊化后期和罗马时期才更多地用于大型建筑。雅典的宙斯神庙采用的正是科林斯柱式。</p><p><img src="/images/IMG20220923-3.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/63.Culture-and-Arts/Arch.%E5%85%B6%E4%BB%96/"/>
      <url>/63.Culture-and-Arts/Arch.%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<ul><li>解构主义建筑</li><li>Brutalist style / 粗野主义<ul><li><a href="https://en.wikipedia.org/wiki/Brutalist_architecture" target="_blank" rel="noopener">Brutalist architecture - Wikipedia</a></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>卡特尔16PF</title>
      <link href="/62.Psychology/%E5%8D%A1%E7%89%B9%E5%B0%9416PF/"/>
      <url>/62.Psychology/%E5%8D%A1%E7%89%B9%E5%B0%9416PF/</url>
      
        <content type="html"><![CDATA[<p>卡特尔16PF（Cattell’s 16 Personality Factor，简称16PF），十六种人格因子</p><p>十六种人格因素的含义如下：</p><p><img src="/images/Cattell-16FP-1.png" alt="../_images/Cattell-16FP-1.png"></p><p><img src="/images/Cattell-16FP-2.png" alt="../_images/Cattell-16FP-2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>盖洛普-克里夫顿优势</title>
      <link href="/62.Psychology/%E7%9B%96%E6%B4%9B%E6%99%AE-%E5%85%8B%E9%87%8C%E5%A4%AB%E9%A1%BF%E4%BC%98%E5%8A%BF/"/>
      <url>/62.Psychology/%E7%9B%96%E6%B4%9B%E6%99%AE-%E5%85%8B%E9%87%8C%E5%A4%AB%E9%A1%BF%E4%BC%98%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="/images/20220207210604.png" alt=""></p><h1 id="优势1-5"><a href="#优势1-5" class="headerlink" title="优势1-5"></a>优势1-5</h1><h2 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h2><p><img src="/images/20220207210627.png" alt=""></p><h2 id="战略"><a href="#战略" class="headerlink" title="战略"></a>战略</h2><p><img src="/images/20220207210652.png" alt=""></p><h2 id="交往"><a href="#交往" class="headerlink" title="交往"></a>交往</h2><p><img src="/images/20220207210712.png" alt=""></p><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><p><img src="/images/20220207210732.png" alt=""></p><h2 id="排难"><a href="#排难" class="headerlink" title="排难"></a>排难</h2><p><img src="/images/20220207210753.png" alt=""></p><h1 id="优势5-10"><a href="#优势5-10" class="headerlink" title="优势5-10"></a>优势5-10</h1>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多巴胺 and 内啡肽</title>
      <link href="/62.Psychology/%E5%A4%9A%E5%B7%B4%E8%83%BA-and-%E5%86%85%E5%95%A1%E8%82%BD/"/>
      <url>/62.Psychology/%E5%A4%9A%E5%B7%B4%E8%83%BA-and-%E5%86%85%E5%95%A1%E8%82%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="多巴胺"><a href="#多巴胺" class="headerlink" title="多巴胺"></a>多巴胺</h2><p>多巴胺是一种神经传导物。它将兴奋及开心的信息传递，也与上瘾有关。阿尔维德—卡尔森等三人研究多巴胺而获得诺贝尔奖。</p><p>多巴胺代表快乐吗？并非如此。有研究表明多巴胺奖赏通路的本质是奖赏。<br>在心理学中，当人作出某一决策后如果被证实正确并产生了好的结果，大脑会向负责决策的区域发送“奖赏”信号，这会促进人的认知能力进一步提升，形成良性循环，这被称作“奖赏效应”。</p><p>多巴胺产生的’快感’真是来自快乐的时刻吗？更多研究发现，多巴胺的效用产生于期待奖赏，而不是获得奖赏。多巴胺≈ want，所带来的是渴望和幻想。</p><p>多巴胺的副作用：成瘾的痛苦<br>可以对比一下现在的手机上瘾，我们很多时候只是在不停的点开“下一条”，即使很累也舍不得放开。这就是多巴胺的奖励机制在告诉你，“下一条会很爽”，当你强迫自己放下手机，你会觉得很焦虑，多巴胺只是让我们对下一个充满期待而已。</p><blockquote><p>成瘾（英语：Addiction）是指一种重复性的强迫行为，即使这些行为已知可能造成不良后果的情形下，仍然被持续重复。这种行为可能因中枢神经系统功能失调造成，重复这些行为也可以反过来造成神经功能受损——Wikipedia<br>在奖励机制中，内啡肽，脑啡肽，内源性大麻素等属于“胡萝卜”型，而多巴胺则属于“大棒”型。前三者给人们带来的是获得后的满足感，而多巴胺给人带来的则是获得前的饥渴感。动物其实都很懒得，“大棒”让动物保持想要吃到胡萝卜应该有的高度兴奋的精神状态（别以为兴奋就是快乐！你被食肉动物追杀的时候就非常兴奋）</p></blockquote><h2 id="内啡肽"><a href="#内啡肽" class="headerlink" title="内啡肽"></a>内啡肽</h2><p>内啡肽（endorphin）亦称安多芬或脑内啡，是一种内成性（脑下垂体分泌）的类吗啡生物化学合成物激素。它能与吗啡受体结合，产生跟吗啡、鸦片剂一样有止痛和欣快感。等同天然的镇痛剂。利用药物可增加脑内啡的分泌效果。内啡肽类似于是成就感，内心宁静。</p><p>内腓肽可以帮助人保持年轻快乐的状态，所以内腓肽也被称之为“快感荷尔蒙”或者“年轻荷尔蒙”。</p><p>诺贝尔奖金获得者罗杰．吉尔曼发现，人体产生内啡肽最多的区域以及内啡肽受体最集中的区域，居然就是学习和记忆的相关区域，因此内啡肽可以提高学习成绩，加深记忆。腓肽能够调整不良情绪，调动神经内分泌系统，提高免疫力，缓解疼痛。内腓肽的激发下，人能顺利入梦，消除失眠症，并使人的身心处于轻松愉悦的状态中，让免疫系统实力得以强化。</p><p>内腓肽可以对抗疼痛、振奋精神、缓解抑郁;还能让我们可以抵抗哀伤，创造力勃发，提高工作效率等等; 充满爱心和光明感，积极向上，愿意和周围的人交流勾通。</p><hr><p>@ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/24697188" target="_blank" rel="noopener">从快感到成就感：多巴胺vs内啡肽 - 知乎</a></li><li><a href="https://www.jianshu.com/p/7363cc368024" target="_blank" rel="noopener">奖励系统，多巴胺与洗脑术 - 简书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MBTI各种类型兼容关系</title>
      <link href="/62.Psychology/MBTI%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E5%85%B3%E7%B3%BB/"/>
      <url>/62.Psychology/MBTI%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="https://www.douban.com/group/topic/66137129/?_i=90819740ykPbNx" target="_blank" rel="noopener">16种性格兼容关系图</a></p><hr><p>下图为思想相容性，红色代表思想或价值观最不相容，蓝色代表最佳相容，不过不相容不代表不能相处。蓝色应该也指最佳拍档、最佳工作伙伴。(貌似是工作中的关系)</p><p><img src="/images/20220404222145.png" alt=""></p><p>下图: 橘色为不喜欢，绿色为喜欢<br><img src="/images/20220404222218.png" alt=""></p><p>【因为Socionics 和MTBI有微妙不同，此图对MBTI分法不能互通，如果条件是J和P的话倒是可以参考，比如INFJ和INFP的拟恒关系，管制关系和受益关系也非常奇妙。】<br>这方面的问题请关注Socionics小组的翻译 <a href="http://www.douban.com/group/tmxk/" target="_blank" rel="noopener">http://www.douban.com/group/tmxk/</a>,<br>原图出处 <a href="http://www.socionics.com/rel/relcht.htm" target="_blank" rel="noopener">http://www.socionics.com/rel/relcht.htm</a><br><img src="/images/20220404222326.png" alt=""></p><p>由 <a href="http://www.douban.com/group/topic/65518821/" target="_blank" rel="noopener">Yoli</a>提供的翻译:<br><img src="/images/20220404222352.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> MBTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INFJ-T-vs-INFJ-A</title>
      <link href="/62.Psychology/INFJ-T-vs-INFJ-A/"/>
      <url>/62.Psychology/INFJ-T-vs-INFJ-A/</url>
      
        <content type="html"><![CDATA[<p>匆忙的机翻，原文:<a href="https://www.16personalities.com/articles/assertive-advocate-infj-a-vs-turbulent-advocate-infj-t" target="_blank" rel="noopener">Assertive Advocate (INFJ-A) vs. Turbulent Advocate (INFJ-T) | 16Personalities</a></p><hr><p>虽然自信（INFJ-A）和动荡（INFJ-T）倡导者可能更相似而不是不同，但他们的身份人格特质在两者之间提供了一些细微的差异。它在很大程度上影响了每个人思考，行动和回应他们世界的方式。</p><p>自信的倡导者更有可能自信和放松。动荡的倡导者可能会更多地质疑自己，并且通常对压力源更敏感。要了解有关自信和湍流身份之间的一般差异的更多信息，请访问其概述页面。</p><p>74%的自信倡导者认为他们有效地管理了生活中的压力，而动荡的倡导者则为28%。</p><h2 id="动荡和自信的倡导者和他们生活中的人们"><a href="#动荡和自信的倡导者和他们生活中的人们" class="headerlink" title="动荡和自信的倡导者和他们生活中的人们"></a>动荡和自信的倡导者和他们生活中的人们</h2><p>所有倡导者个人主要通过他们的感受过滤它们来决定事情，他们的决定往往反映了他们对道德的价值。他们如何看待人们以及他们正在经历的事情是他们性格类型的一个决定性因素。但是，与自信的倡导者相比，动荡的倡导者可能会将同情他人的同情心提高一个档次。</p><p>动荡的倡导者经常让他们的激情带领他们取得伟大的成就。这些因素是由于他们对生活中人民的尊重以及对道德和理想主义问题的关心而推动的。他们可能会过度卷入他人的问题。这种参与甚至可能产生一种超同理心，这些人格与他们寻求帮助的人过于认同。</p><p>如果动荡的倡导者变得投入，然后无法达到他们认为应该达到的程度，那么动荡的自我批评可能会过于严厉。他们可能会陷入沉思，陷入忧虑和遗憾的痛苦泥潭。</p><p>75%的动荡倡导者表示，他们很容易在任何地方看到困难，而自信倡导者的这一比例为42%。</p><p>除此之外，动荡的倡导者更愿意夸大困扰他们或伤害他们所关心的人的事情的影响。具有这种性格类型的人经常将事情解释为比实际情况糟糕得多。但这种夸张很少是故意的或不诚实的。这更多地反映了他们对事物持有更多负面看法的倾向。它可以真正反映他们的信仰。但是，即使它来自一个好地方，放大问题也会给已经困难的情况增加不必要的压力和强度。</p><p>当自信的倡导者被不公正、不平等或他人的问题所困扰时，他们更有可能以充满希望的方式做出回应。他们可能同样关注任何令人不安的担忧和人类的困难，但他们拒绝被它们所强调。</p><p>35%的动荡倡导者认为他们处于控制之中，即使事情出了问题，相比之下，72%的自信倡导者</p><p>这并不意味着这些个性没有真正的投入，或者他们不在乎。除了烦恼之外，还有很多方法可以引起人们对他人困境的兴趣。</p><p>自信的倡导者在与他人交往时比他们的同行更有可能保持均匀的情感龙骨。与其花很多时间思考一些人可能遭受的痛苦和不幸，这些性格类型更有可能从可能导致更积极未来的计划和愿景的角度来思考。他们可以像《动荡的倡导者》一样强烈地想象好东西的出现，就像《动荡的倡导者》一样，想象他们的担忧和遗憾。</p><p>但这种乐观情绪有时会产生负面结果。通过玫瑰色眼镜生活并不总是能促进清晰的视力。自信的倡导者可能会对需要解决的合法重要问题不屑一顾，而是选择专注于更光明的事情。在这些情况下，他们可能会忽略基本任务。动荡的倡导者更有可能在自信的倡导者之前很久就发现这些事情。</p><p>动荡和自信的倡导者都倾向于提升他们的朋友，他们爱上的人，甚至他们的同事。这些性格通常认为是他们所重视和同意的人中最好的。他们可能不那么善待那些违背他们的对错感或看起来是假的。</p><p>然而，两者之间有一个区别：自信的倡导者通过一个过滤器来看待事物，这个过滤器重视人性，并希望在他们的生活中拥有人（在有限的内向剂量内）。相比之下，动荡的倡导者更有可能超越仅仅想要人们的生活。这些性格更愿意为他人着想，也更受别人对他们的看法的影响。这种对他人的需求和他们的意见可以帮助他们与他人建立深厚的联系，并允许他们在需要时更好地合作。</p><p>38%的动荡倡导者发现在没有事先咨询任何人的情况下做出重要决定很容易，而自信倡导者的这一比例为71%。</p><p>然而，与动荡的倡导者不同，自信的倡导者并没有受到他人意见的深刻影响 - 也许有时对他们不利。这使得这些人物能够以独立和简化的方式接近他们生活中的各种任务。</p><p>73%的动荡倡导者感到有压力达到某个标准（例如，家庭，汽车，工资），而42%的自信倡导者</p><p>但是，这种独立性在什么时候演变成傲慢呢？所有内向型人格类型都喜欢独处——或者，至多在一小群精心挑选的人中间。也就是说，自信的倡导者可以夸大独狼的角色。这些自信的个人主义者可以变得如此独立，以至于他们忘记了他人的需求和愿望。</p><p>动荡的倡导者可以走另一条路 - 不断寻求认可，扼杀他们的个性，并在等待所有重要人物善意地看待他们的行动和想法时挫败他们的努力。取悦每个人是生活中难得的成就，追求它让很多人停滞不前。</p><p>93%的动荡倡导者经常害怕被其他人拒绝，而自信倡导者的这一比例为52%。</p><h2 id="改变，后悔，倡导身份差异"><a href="#改变，后悔，倡导身份差异" class="headerlink" title="改变，后悔，倡导身份差异"></a>改变，后悔，倡导身份差异</h2><p>由于他们共同的评判人格特质，这两种类型的倡导者都更喜欢常规和可预测性。两人都不是特别喜欢被惊讶。</p><p>然而，自信的倡导者更有可能接受事件中不寻常的转变，他们更容易接受非正统的想法和人。他们往往比动荡的同龄人更具冒险精神 - 可能是因为他们的信心。</p><p>动荡的倡导者，作为他们寻求持续改进的一部分，可能会接受变革，但只有在合理范围内。具有这种性格类型的人喜欢对它有一些控制权，并保证它在正确的时刻是正确的变化。他们可能比自信的同行承担更少的风险。</p><p>87%的动荡倡导者发现很难不让压力事件对他们产生负面影响，相比之下，自信倡导者的这一比例为47%。</p><p>倡导者都对过去有着深刻的敬意。他们倾向于深刻而热情地记住事情在他们生活中展开的方式。他们从过去的日子里为未来收集教训。然而，当他们的过去是艰难的时，自信的倡导者就不会那么为遗憾而烦恼，而动荡的倡导者可能会紧紧抓住这种失望和失误的记忆。</p><p>86%的动荡倡导者经常感到后悔，而自信倡导者的这一比例为48%。</p><p>遗憾可以给动荡的倡导者的未来行为带来积极或消极的影响：积极的，如果他们有动力弥补过去的失误;消极地，如果这些人格陷入内疚或愤怒。如果他们认为自己伤害了别人，这可能会特别具有破坏性。</p><p>因为后悔不会对他们产生太大的影响，所以自信的倡导者可能不那么有动力去纠正过去的错误。如果他们能把失败视为不重要，他们可能不会学到通过反复试验来最好地教授的关键课程。这可能会让这些人格比他们想要的更频繁地重复他们的错误。</p><p>89%的动荡倡导者经常发现自己纠结于过去的错误，而自信倡导者的这一比例为61%。</p><h2 id="差异摘要"><a href="#差异摘要" class="headerlink" title="差异摘要"></a>差异摘要</h2><p>这两种性格类型都关心其他人，但自信的倡导者可能会更有希望，而动荡的倡导者则专注于问题的困难部分。<br>动荡的倡导者往往受到他们的担忧和担忧的推动，这些可以用来取得重大进展。<br>自信和动荡的倡导者都可能陷入生活的戏剧性事件中，但那些动荡的人可能会受到更多的影响。<br>压力和遗憾对自信倡导者的影响较小，但这不应该与他们的不关心相混淆。<br>因为他们的遗憾更重于他们，动荡的倡导者比自信的倡导者更有可能从他们的错误中吸取教训。<br>自信的倡导者比动荡的倡导者受他人意见的影响要小。但是，太少或过多地关注别人的意见，也有其自身的困难。<br>自信的倡导者更有可能在他们的生活中想要人，而动荡的倡导者可能会觉得他们在生活中需要人。<br>相同但不同 - 这就是我们在单一人格类型中探索自信和动荡身份时发现的。对于倡导者来说，这意味着他们有着同样的激情，对他人的同样关心，同样的秩序感，以及对是非的相同程度的信念。</p><p>然而，这也意味着每种人格类型对隐喻玻璃都有不同的看法。是半满还是半空？他们在多大程度上对其他人和事件做出反应，以及他们在多大程度上向前迈进？这都是自我探索之旅的一部分。</p><h2 id="你是个INFJ-T"><a href="#你是个INFJ-T" class="headerlink" title="你是个INFJ-T?"></a>你是个INFJ-T?</h2><p>湍流倡导者（INFJ-T）具有令人难以置信的学习和成长能力，但他们并不总是认识到自己的真正潜力。这就是为什么我们制作了《动荡的倡导者》的超能力：成为最好的自己——不改变你是谁。</p><p>如果你是一个动荡的倡导者，动荡的倡导者超能力将赋予你放弃自我批评并拥抱你真正是谁的能力。一路上，你会改变你的心态，改善你的人际关系，追求你的梦想，所有这些都是通过利用你最大的优势 - 你一直内在的优势。</p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gallup（盖洛普） and MBTI 评测的联系</title>
      <link href="/62.Psychology/Gallup-and-MBTI/"/>
      <url>/62.Psychology/Gallup-and-MBTI/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.gallup.com/cliftonstrengths/en/250133/compare-mbti-myers-briggs-cliftonstrengths.aspx" target="_blank" rel="noopener">https://www.gallup.com/cliftonstrengths/en/250133/compare-mbti-myers-briggs-cliftonstrengths.aspx</a></p><p>已故盖洛普资深科学家菲尔·斯通，哈佛大学前任心理学教授，研究了 MBTI 和 克利夫顿StrengthsFinder（<a href="/62.Psychology/盖洛普-克里夫顿优势/" title="盖洛普-克里夫顿优势">盖洛普-克里夫顿优势</a>）之间的关系。斯通过他的206个学生进行了这两项完整的评估。研究表明两者之间的评估某些预期的相关性。</p><p>例如，如果克利夫顿StrengthsFinder显示，分析是你五大主题之一，MBTI第三维度你就可能属于内倾思考（Ti）或者外倾思考（Te）。如果体谅是你的五大主题之一，你MBTI第二维度很可能是感觉型（Fi 或 Fe）。同样，如果你有纪律，你就可能是MBTI第四维度是判断型。</p><p>斯通的学生反馈克利夫顿 StrengthsFinder既更适用，比 MBTI更准确。</p><p>打个比方：想象一下，一个房子有好几个的房间。 MBTI表示，其中一个是最舒适的居住的房间。克利夫顿StrengthsFinder则代表的家具，设备，装饰，房间内的其他细节，从而帮助我们理解个人独特的天生的能力。无论是MBTI和克利夫顿StrengthsFinder都能揭示个性有价值的信息，都可以帮助个人与组织的战略发展。</p><blockquote><p>Gallup Senior Scientist Phil Stone, a psychology professor at Harvard, examined the relationship between Myers-Briggs and the CliftonStrengths assessment. Stone had 206 of his students complete assessments through both instruments. The study showed some expected correlations between the two assessments. For example, if the CliftonStrengths assessment shows that Analytical is one of your Top 5 areas of talent, MBTI is likely to identify you as Thinking. If Empathy is in your Top 5 (CliftonStrengths), you are likely to be Feeling (MBTI). Likewise, if Discipline is in your Top 5 (CliftonStrengths), you’re probably also Judging (MBTI). Stone’s work depicts the accuracy of the two assessments for defining a person’s innate natural thoughts, feelings and behaviors.</p></blockquote><blockquote><p>Now let’s take a closer look at the applicability of each. Imagine a house and the rooms within it. MBTI indicates the room in which an individual is most comfortable residing. The CliftonStrengths assessment represents the furnishings, functional pieces, decorations and other details inside that room, helping us understand the individual’s unique innate abilities. Said differently, MBTI is the ZIP code, and CliftonStrengths puts you in front of the door.</p></blockquote><hr><p><img src="/images/20220405131002.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> MBTI </tag>
            
            <tag> 克利夫顿优势 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Big Five 笔记</title>
      <link href="/62.Psychology/BigFive/"/>
      <url>/62.Psychology/BigFive/</url>
      
        <content type="html"><![CDATA[<h2 id="What’s-Big-Five"><a href="#What’s-Big-Five" class="headerlink" title="What’s Big Five"></a>What’s Big Five</h2><p>人格结构五因素模型（Big Five Structure，Five-Factor Model) 或译为大五人格模型</p><p>OCEAN：人格结构中的五个因素后来被称为“大五”（big five），强调该人格模型中每一维度的广泛性。这五个维度因素是神经质（N）、外倾性（E）、经验开放性（O）、宜人性（A）和认真性（C）。</p><h2 id="OCEAN量表"><a href="#OCEAN量表" class="headerlink" title="OCEAN量表"></a>OCEAN量表</h2><p>得出五因素模型的一个很重要的方法就是基于问卷研究。科斯塔（Costa<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>）等人根据对16PF<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>的因素分析和自己的理论构想编制了测验五因素的NEO—P1人格量表（NEO—PI Five-Factor Inventory）。该量表包括300个项目，被试在五点量表（从完全同意到完全不同意）上指出每个句子表示他们自身特点的程度。除了五个因素上的得分，被试还有为每个维度量表设置的六个测量特质水平的层面量表得分，这些层面量表提供了有关大五因素的每个因素内的行为的更大区分性。有关人格大五特质因素和相关特征见下表。</p><p><img src="/images/Big-Five.png" alt="../_images/Big-Five.png"></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://socialsci.libretexts.org/Bookshelves/Psychology/Book%3A_Personality_Theory_in_a_Cultural_Context_(Kelland)/10%3A_Trait_Theories_of_Personality/10.07%3A_Paul_Costa_and_Robert_McCrae_and_the_Five-Factor_Model_of_Personality" target="_blank" rel="noopener">10.7: Paul Costa and Robert McCrae and the Five-Factor Model of Personality - Social Sci LibreTexts</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">卡特尔16PF（Cattell’s 16 Personality Factor，简称16PF）=&gt; <a href="/62.Psychology/卡特尔16PF/" title="卡特尔16PF">卡特尔16PF</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>情绪管理</title>
      <link href="/62.Psychology/05.%E6%83%85%E7%BB%AA%E7%AE%A1%E7%90%86/"/>
      <url>/62.Psychology/05.%E6%83%85%E7%BB%AA%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>@ref <a href="https://www.zhihu.com/question/20789554/answer/46482883" target="_blank" rel="noopener">怎样进行良好的情绪管理？ - 知乎</a></p><p>ABCDE情绪管理:</p><p>心理学家阿尔伯特.艾利斯提出的情绪反应的ABC模式。</p><ul><li>A（Activating Event）——事件或情境</li><li>B（Beliefs）——你对这个事情或情境抱有的信念（即你的态度，想法，评价，解释）</li><li>C（Consequences）——结果：情绪结果（比如焦虑），行为结果（比如攻击），生理结果（如心悸，手脚冰凉）</li></ul><p>C中出现的不良反应(激怒/抱怨..) 出在你对事情的判断上。</p><p>一些常见的思维习惯/思维模式会使你对情况出现误判，从而导致坏心情，并再接再厉地影响你解决问题的能力。那么，找到并处理这些错误的想法，重新修订你的判断与结论，就可以帮助我们从自己给自己设下的圈套中走出来，所以，我们在ABC的基础上，再加上D（Disputing）和E（Effective Rational Beliefs）两个步骤，即：</p><ul><li>D——找出你通常使用的那些有可能会误导你，使你得出不准确结论或判断的错误的思维模式。</li><li>E——找到新的有效办法，来帮助我们解决我们面对的问题。</li></ul><p>作者：袁小麦<br>链接：<a href="https://www.zhihu.com/question/20789554/answer/46482883" target="_blank" rel="noopener">https://www.zhihu.com/question/20789554/answer/46482883</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><p>@ref: <a href="https://www.zhihu.com/question/19824961/answer/32378386" target="_blank" rel="noopener">如何对抗负面情绪？ - 知乎</a></p><p>积极心理学兴起之前，心理学是病理式的，是“治问题”的科学。这种“治问题”的思维随着心理学在大众群体中的普及，已经根深蒂固到每个人的内心了。有了消极情绪，就来问，怎么办。</p><p>塞里格曼在20世纪末掀起了积极心理学的潮流，怎么对抗负面情绪?<br>过去心理学会告诉你，寻找负面情绪的根源然后去解决，过去经历也好，当下困扰也罢。但是，这种治疗式的思维，让我们在过去的半个多世纪，抑郁症患者没有减少，反而大幅度增加了。</p><p>现在心理学会告诉你，不要对抗负面情绪。</p><p>我来告诉你为什么：<br>研究发现，积极情绪和消极情绪是独立的两个维度，对抗消极情绪，或者说“解决问题”，并不能带来积极的正面的情绪，负面消极的减少了，最多也只能回到“0”状态。这也就是为什么，过去“消极心理学”，并没有给人们带来主观幸福感的上升，甚至连负面的，例如抑郁症的减少都没有达到。</p><p><img src="/images/20220303004307.png" alt=""></p><p>所以，负面情绪是不用对抗的，过去半个世纪的经验告诉我们，对抗消极只会让你更消极。我很喜欢动机老师这个答案来支持这个观点：<a href="http://www.zhihu.com/question/22063688" target="_blank" rel="noopener">为什么心理咨询要把接纳自己作为一件很重要的事去强调？</a></p><p>因此，我们可以换个思维，从“0”状态的右边开始入手，学会给自己创造积极体验和正面情绪。</p><p>Fredrickson（2002）提出了<strong>“积极情绪的扩展建构理论”</strong>（the broaden-and-build theory of positive emotions）：</p><p><img src="/images/20220303004356.png" alt=""></p><p>所以，当积极正向的情绪出来的时候，它自然会扩大你的心理应对资源，久而久之，你的消极负面的情绪，你就能够去应对了。</p><p>看喜剧片，这对你来说能够创造积极体验，很好，但是不够（你自己也觉得不够）。<br>这里就区分两种积极体验：</p><ul><li>感官愉悦（sensory pleasure）：这是积极情绪体验的一种重要形式，指机体消除内部紧张力之后的一种主观体验，是人感觉器官放松的结果。它属于<strong>感觉类</strong>的体验。例如，你目前正在运用的策略，看电影看喜剧片，它刺激你的感觉，让人放松感觉器官，从而享受到感官愉悦。这种方式很好，也很重要。</li><li>心理享受（psychological pleasure）：指个体打破了某种固有的自我平衡，超越了个体自身的原有状态，例如艺术家在创造艺术作品。类似于马斯洛所说的高峰体验。它属于<strong>知觉类</strong>的体验。它的影响效果时间更长，更深刻。这点上需要你去探索。</li></ul><p>因为心理享受是知觉类的体验，因此它的产生必须要有个体的认知评价为先导，即要把握对象对自我的意义。<br>所以，去寻找生活中，对你最有意义的人、事、物。去改变你的生活优先权（life priority）。将重要的，对你更有意义的事情先做，这里推荐采铜老师的答案供指导：<a href="http://www.zhihu.com/question/22238159" target="_blank" rel="noopener">你有什么相见恨晚的知识想推荐给年轻人？</a><br>不要因为暂时看不到事情的长期收益，而放弃不去做；而只做短期收益高，但半衰期短的事情（例如，你现在在做的看喜剧片。当然要做，但是不能仅仅只做这种事。）</p><p>所以，通过积极情绪的扩建理论，我们的观点是：短期收益高的事情带来<strong>感官愉悦</strong>，我们需要去做，不时的去放松自己；而长期收益高，但短期看不到效果的事情，我们也要去做，它会在某些时刻带给你<strong>心理享受</strong>，让你在应对生活中的困扰时，有更多的心理应对资源。</p><p>至于你如果要追问，如何找到提高心理享受的办法。我就没有办法回答你了。因为它属于知觉类体验，要知道每个人对于同一件事情的知觉都是不同，它依赖于对于事件意义的评价。所以，这件事情上，你要自己探寻。</p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>黑暗三角特质</title>
      <link href="/62.Psychology/03c.%E9%BB%91%E6%9A%97%E4%B8%89%E8%A7%92%E7%89%B9%E8%B4%A8/"/>
      <url>/62.Psychology/03c.%E9%BB%91%E6%9A%97%E4%B8%89%E8%A7%92%E7%89%B9%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="https://mp.weixin.qq.com/s/50_EMVUSeHRlgqO8Kz3E8A" target="_blank" rel="noopener">渣男为什么总有人爱</a></p><p>跟这有关的是一种叫做黑暗三角（Dark Triad）的特质，它有点类似于中文语境中的“腹黑”。如果用我们常用的语言捕捉一下，大概是一种“高冷、自恋、冲动、善于欺骗、情绪波动小、冷酷无情”的特质。</p><ul><li>自恋</li><li>马基雅维利主义</li><li>精神病态</li></ul><p>➤ 自恋（Narcissism）: 精神分析学派较早关注自恋的人格心理学意义, 弗洛伊德将其视为一种人格障碍, 属于临床和变态心理学研究的领域, Kohut认为自恋是普通人人性的一部分, 从而将自恋引入人格和社会心理学。亚临床阶段的自恋(subclinicalnarcissism)一般具有以下特征: <strong>自我中心、爱慕虚荣、自我吹嘘、支配性、优越感、傲慢无礼和自以为是</strong>。</p><p>➤ 马基雅维利主义（Machiavellianism）: 在心理和行为上一般表现为: <strong>冷酷无情、擅长操纵、阴谋算计、实用主义、注重结果和忽视道德</strong>。<br>=&gt; [[../61.Philosophy/10.马基雅维利主义]]</p><p>➤ 精神病态（Psychpath）:  最初被定义为一种以反社会心理和行为为特征的人格障碍(Hare, 1991),虽未被收入美国精神疾病诊断和统计手册(DSM-Ⅳ), 精神病态一直被认为是反社会行为的预测指标(Harpur, Hart &amp; Hare, 1994), 对精神病态的早期研究主要局限在临床和变态心理学范围内, 被试主要是罪犯和精神病人。随着研究深入,Hare、Lilienfeld 和Andrews对上述刻板印象提出异议, 在他们看来亚临床阶段的精神病态(subclinical psychopathy)更像是一种人格特质, 精神病态者(psychopaths)并非个个都是病人或罪犯, 正常人也有病态心理和病态行为。由此, 精神病态成为人格心理学的研究对象, 被试逐渐扩展到普通人群。作为人格特质, 精神病态在行为上一般表现为: <strong>行为冲动、寻求刺激、缺乏共情、缺乏责任感、缺乏焦虑</strong>。<br>=&gt; <a href="/62.Psychology/03b.人格障碍/" title="03b.人格障碍">03b.人格障碍</a></p><p>由于在研究中，拥有其中一个特质的人，通常又会或多或少地拥有其他一到两个特质的特征，所以才将三个特质合并建立黑暗三角特质进行了研究</p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人格障碍</title>
      <link href="/62.Psychology/03b.%E4%BA%BA%E6%A0%BC%E9%9A%9C%E7%A2%8D/"/>
      <url>/62.Psychology/03b.%E4%BA%BA%E6%A0%BC%E9%9A%9C%E7%A2%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="人格障碍"><a href="#人格障碍" class="headerlink" title="人格障碍"></a>人格障碍</h1><p>人格障碍，或人格（性格）疾患／异常／违常（Personality disorders）。是精神疾病中，对于一群特定拥有长期而僵化思想及行为病患的分类。这类疾患常可因其人格和行为的问题而导致社会功能的障碍。<br>人格违常是据美国精神医学学会所定，这类疾患的表现是跨文化和国界的。它们被定义成发病期至少要能追溯到成长期早期或更早。要能符合人格违常诊断的最低标准是疾患本身必须已干扰到个人、社会、或职业功能。</p><ul><li>A型 （奇怪型或异常型疾患）<ul><li>妄想型人格违常</li><li>孤僻型人格违常</li><li>精神分裂型人格违常</li></ul></li><li>B型 （戏剧型或情感型疾患）<ul><li>反社会人格违常</li><li>边缘型人格违常</li><li>戏剧化人格违常</li><li>自恋型人格违常</li></ul></li><li>C型 （焦虑型或恐惧型疾患）<ul><li>畏惧型人格违常</li><li>依赖型人格违常</li><li>强迫型人格违常</li></ul></li></ul><h2 id="回避型人格障碍"><a href="#回避型人格障碍" class="headerlink" title="回避型人格障碍"></a>回避型人格障碍</h2><p>因为害怕在别人面前丢脸，此类患者经常选择可独立完成工作的职业，以降低与人社交的机会。有些患者会幻想与他人拥有完美、被爱和被别人接受的关系，不过因他们觉得自己不值得拥有这些关系，所以并不主动去追求。他们只有在确信不会被拒绝的情况下才愿意与人建立关系，并只关注自己的缺点，经常贬低自我。</p><p>ICD‐10指出APD的特征包括：</p><ul><li>泛化的紧张感与忧虑</li><li>相信自己在社交上笨拙，没有吸引力或不如别人</li><li>在社交场合过分担心会被人指责或拒绝</li><li>除非肯定受人欢迎否则不肯与他人打交道</li><li>出于维护躯体安全感的需要，在生活风格上有许多限制</li><li>由于担心批评、指责或拒绝，回避那些与人密切交往的社交或职业活动。</li></ul><h2 id="依赖型人格"><a href="#依赖型人格" class="headerlink" title="依赖型人格"></a>依赖型人格</h2><p>美国精神疾病诊断与统计手册（DSM-IV-TR）中收录了依赖型人格障碍的诊断标准。它提出的特点是一种普遍的、过分的想要被照料的需求而导致了顺从和依从于他人并害怕分离的心理状态。并且在成年早期开始发生，存在于多种社会背景下。</p><p>需要具备以下列出的至少三条特性：</p><ul><li>鼓励或是允许别人为自己人生中绝大多数的重要事件做决定；</li><li>相比所依赖的人的需要，将自己的需要置于次要的位置，并且过分地顺从于所依赖人的意愿；</li><li>甚至不愿意向自己所依赖的人提出合理的要求；</li><li>因为害怕没有能力照顾好自己，独处时会觉得不自在或无助；</li><li>被先占观念困扰：害怕被亲密关系中的他人抛弃，或是被独自留下需要照顾自己；</li><li>在没有他人极多的建议和保证的情况下，没有足够的能力做日常决定。</li></ul><h2 id="分裂型人格障碍"><a href="#分裂型人格障碍" class="headerlink" title="分裂型人格障碍"></a>分裂型人格障碍</h2><p>其特征在于对社会联系缺乏兴趣，倾向于独立生活、沉默寡言和感情淡漠。受影响者可能无法和他人形成健康的依赖关系，也可能会描绘出丰富的幻想世界。</p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>心理学效应</title>
      <link href="/62.Psychology/03a.%E5%BF%83%E7%90%86%E5%AD%A6%E6%95%88%E5%BA%94/"/>
      <url>/62.Psychology/03a.%E5%BF%83%E7%90%86%E5%AD%A6%E6%95%88%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="心理学效应"><a href="#心理学效应" class="headerlink" title="心理学效应"></a>心理学效应</h1><h2 id="巴纳姆效应"><a href="#巴纳姆效应" class="headerlink" title="巴纳姆效应"></a>巴纳姆效应</h2><p>巴纳姆效应（Barnum effect，是 Paul Meehl 为表对费尼尔司·泰勒·巴纳姆的敬意而命名，又称巴南效应、弗拉效应（英语：Forer effect））是一种心理现象：人很容易相信一个笼统的一般性的人格描述，并认为它特别适合自己并准确地揭示了自己的人格特点，而这些描述往往十分模糊及普遍，以致能够放诸四海皆准适用于很多人身上。</p><p>巴纳姆效应能够对于为何不少伪科学如占星学、占卜或心理测验等被普遍接受提供一个不十分完全的解释。</p><h2 id="自我实现预言"><a href="#自我实现预言" class="headerlink" title="自我实现预言"></a>自我实现预言</h2><p>自证预言（英语：Self-fulfilling prophecy；又称“自我应验预言”或“自我实现预言”），是由美国社会学家罗伯特·金·莫顿提出的一种社会心理学现象，是指人们先入为主的判断，无论其正确与否，都将或多或少的影响到人们的行为，以至于这个判断最后真的实现。[1]通俗的说，自证预言就是我们总会在不经意间使我们自己的预言成为现实。<br>信念和行为之间的正反馈被认为是自我应验预言成真的主要原因。虽然此类预言的例子可以一直追溯到古希腊和古印度时期的文学作品，然而“自证预言”这个名称直到20世纪才由著名社会学家罗伯特·金·莫顿提出，并对它的结构和推论作了比较系统化的定义。莫顿在他的著作《社会理论和社会结构》中对自我应验预言作了如下阐述[2]：<br>自我应验预言是一种能够唤起新的行为的预言，并且该行为使得本来错误的概念变成了正确。<br>吸引力法则被视为是自证预言的一种。</p><p>这一理论最著名的实验出自1968年Rosenthal博士与Jacobson博士所完成。首先，他们给一所中学的所有学生进行智商测试，然后告诉老师一些学生的智商非常高，让老师相信这些学生在来年的学习成绩中将会飞跃成长。但事实上这些所谓的“高智商”的学生非真的高智商，而是随机抽取。因此，他们智商不见得比其余学生还高。随后的实验结果惊人：那些被老师认为“高智商”的学生（事实跟其余学生的智商一样）在来年的学习成绩确实突飞猛进。<br>科学家认为原因有可能是：</p><pre><code>1. 老师的期望值在不知不觉中给了这些“高智商”学生更多的感情投入2. 给了更多学习资料和让他们研究艰深的学习内容3. 对于“高智商”学生的学习，老师在不自觉中给了更多的反馈4. 老师在不自觉中给了这些学生在课堂中活跃的机会。</code></pre><p>@ref:<br><a href="https://zhuanlan.zhihu.com/p/20095159" target="_blank" rel="noopener">自证预言 | 我为什么忍不住把事情往最坏的方面想？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>社会心理学</title>
      <link href="/62.Psychology/03.%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/"/>
      <url>/62.Psychology/03.%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="社会心理学"><a href="#社会心理学" class="headerlink" title="社会心理学"></a>社会心理学</h1><p>社会心理学是从跟社会的关联研究人属的心理学和社会学的学问领域。被个人内过程的研究，对人过程的研究，集体内过程的研究，集合现象的研究等分类。而心理学家则认为，社会心理学是一门在社会情景下，以人的心理行为活动为研究对象，以实证方法为手段，基于心理学、社会学相关理论的社会科学。</p><h2 id="内在现象"><a href="#内在现象" class="headerlink" title="内在现象"></a>内在现象</h2><h3 id="自我概念"><a href="#自我概念" class="headerlink" title="自我概念"></a>自我概念</h3><p>自我概念是指人们对自我的一切信念的一个术语。</p><p>=&gt; <a href="/62.Psychology/03a.心理学效应/" title="03a.心理学效应">03a.心理学效应</a></p><h3 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h3><p>在社会心理学领域，态度被定义为是被学习的，是一个人、一件物品、一个地方或者事件的整体评估，影响着人的思想和行动。更简单的来说，态度是赞成或反对、喜好或厌恶的基本表达，或如本所说，喜欢和不喜欢。例子包括喜欢巧克力冰淇淋，或赞同特定政党的价值观。</p><h3 id="说服"><a href="#说服" class="headerlink" title="说服"></a>说服</h3><p>近年来，说服这个话题受到了广泛的关注。说服是一种积极的方式去影响或指引他人更倾向于某种态度，思想或行为通过理性或情绪化的方式。说服更依赖于“呼吁”，而不是压力或强迫。已经发现了许多影响说服过程的变量;这些通常在五个主要类别中出现:“谁”说“什么”和“谁”和“如何”。</p><h3 id="社会认知"><a href="#社会认知" class="headerlink" title="社会认知"></a>社会认知</h3><p>社会认知是一个现在正不断发展的社会心理学领域，它研究人们如何感知、思考以及记住他人的信息。很多研究都基于人们对(他人)不同于非社会目标的看法。</p><h2 id="人际现象"><a href="#人际现象" class="headerlink" title="人际现象"></a>人际现象</h2><h3 id="社会影响"><a href="#社会影响" class="headerlink" title="社会影响"></a>社会影响</h3><p>社会影响是一个包罗万象的术语，用来描述人们对彼此影响作用。它被认为是社会心理学的一个基本价值，与对态度和说服的研究有很大的重叠。社会影响的三个主要方面包括:从众、顺从和服从。社会影响也与群体动力学的研究密切相关，因为在社会群体中，多数决原则都是最强的。</p><h3 id="人际吸引"><a href="#人际吸引" class="headerlink" title="人际吸引"></a>人际吸引</h3><p>是与他人在情感之间互相亲密的状态，一种人关系关系的肯定形式，按照吸引程度，可分成亲合、喜欢和爱情。首先亲合是低层次的人际吸引，喜欢是中等程度的吸引，爱情是最强烈的吸引形式。</p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 社会心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代心理学史</title>
      <link href="/62.Psychology/02.%E7%8E%B0%E4%BB%A3%E5%BF%83%E7%90%86%E5%AD%A6%E5%8F%B2/"/>
      <url>/62.Psychology/02.%E7%8E%B0%E4%BB%A3%E5%BF%83%E7%90%86%E5%AD%A6%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="现代心理学史"><a href="#现代心理学史" class="headerlink" title="现代心理学史"></a>现代心理学史</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>@ref: <a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E7%90%86%E5%AD%A6%E5%8F%B2" target="_blank" rel="noopener">心理学史 - 维基百科，自由的百科全书</a></p><p>现代心理学一般认为是起始于十九世纪末冯特的构造主义，历经精神分析、行为主义等，一直到近期的认知主义，然而在行为主义盛行时被抵制的理性主义随着认知科学的进步而再度兴起，之前因技术问题而无法深入探讨的内在认知历程再度受到重视。</p><p>现代心理学早期由冯特（Wilhelm Wundt）于德国莱比锡大学创立首间心理学实验室而兴起，及后首位美国心理学家威廉·詹姆士编写美国首本心理学教科书《心理学原理》，以及鼓吹将心理学专业化的斯坦利·霍尔于1887年创办了《美国心理学杂志》（American Journal of Psychology）及于1892年担任第一届的美国心理学会会长后，心理学开始在美国发展。而德国其后则发展出由马科斯·韦特墨所创立的格式塔学派，又称为完形心理学。奥地利精神科医生弗洛伊德于二十世纪初凭其临床治疗经验中所创立的精神分析学亦对后来心理学发展具有深远影响，尤其是在心理治疗方面。</p><p>二十世纪早期的自然科学偏向机械式宇宙观，因此当时的心理学家提出行为主义的研究方法，并认为不应探讨意识这种无法量化且模糊不清的议题，其行为主义深受当时的学界风气支持，且借由行为主义方法得来的资料远比精神分析方法得来的资料有说服力，而精神分析因其研究方法有太多的问题，且太过于主观的判定，导致大多数的心理学家都急于与精神分析划清关系，并不断强调心理学不是研究意识的学问。行为学派的代表心理学家包括伊万·巴甫洛夫、约翰·华生、史金纳等。</p><p>行为主义盛行其间的心理学派，除了行为主义与精神分析外，还有从[[../61.Philosophy/05.存在主义]]延申出来的存在心理学并进一步于二十世纪六零年代演变出人本主义，被称为除行为学派和精神分析以外，心理学上的“第三势力”。人本主义的代表人物包括：卡尔·罗哲斯和亚伯拉罕·马斯洛等。</p><p>二十世纪六、七十年代起，随着医疗科技和实验方的进步，例如EEG（脑电图）和MRI（磁共振成像）等技术的出现，为认知心理学、脑神经心理学等研究领域带来高速的发展。另一方面， <a href="/62.Psychology/03.社会心理学/" title="03.社会心理学">03.社会心理学</a> 承继完形心理学的基础，以及二次大战后的社会需要，亦成为了心理学研究上的一股新势力。 社会心理学的代表人物包括：库尔特·勒温、菲腊·津巴多、所罗门·阿希等。</p><p>以上的学派都对现代心理学有深浅不一的影响，有些学派的理论内容可能已被推翻而只剩下一些名词还被延用于心理学之中，有些学派的理念随着科技的发展再度受到重视，因此心理学史是由不断的尝试错误与修正所累积下来的历史。</p><hr><h2 id="科学心理学"><a href="#科学心理学" class="headerlink" title="科学心理学"></a>科学心理学</h2><p>  心理学作为一门独立的学科是开始于1874年，那一年，德国的生理学家威廉·冯特发表两册的心理学教科书——《生理心理学的原理》（Principles of Physiological Psychology）——，在序言里大胆宣称：“要建立一个新的科学领域”；冯特也因此被称为“心理学之父”。<br>  1875年，莱比锡大学聘冯特为教授；1879年，他在莱比锡大学建立世界第一个专门的心理实验室，吸引了来自世界各地的学生。<br>  10余年后，也就是1890年代，美国各大学风起云涌地仿效此举，建立数十座心理学实验室，尤其1892这一年就成立了20座，这一年也是美国心理学会的成立年。通常将1874年作为科学心理学诞生的时间，这一时间比许多自然科学脱离哲学而形成独立学科的时间为晚。冯特也是第一个把自己称为心理学家的人。其他早期而重要的心理学家包括艾宾浩斯等。</p><h2 id="构造主义"><a href="#构造主义" class="headerlink" title="构造主义"></a>构造主义</h2><p>  德国心理学家威廉·冯特被认为是将实验引入心理学研究的人，被誉为“实验心理学之父”。冯特着重于将心理分解成为基本的元素，这是由于当时化学的进步，后者在分析物质元素与结构上取得突破。虽然冯特自己不是构造主义者，他的学生爱德华·B·铁钦纳成为了构造主义的思想家，与机能主义者对立。</p><h2 id="机能主义"><a href="#机能主义" class="headerlink" title="机能主义"></a>机能主义</h2><p>  机能主义相对于结构主义而生，并受到美国哲学家、科学家、心理学家威廉·詹姆士影响颇多。詹姆士认为心理学应该有实用价值，心理学家应该找到有益于人的科学方式。<br>  其它19世纪的杰出人物有德国心理学家赫尔曼·艾宾浩斯，他是研究记忆实验的先驱，在柏林洪堡大学创立了学习与遗忘的量化模型。苏俄心理学家伊万·彼得罗维奇·巴甫洛夫，他在对狗进行实验时发现了“古典制约”，并将其应用与人类。<br>   自二十世纪50年代起，冯特、詹姆士、艾宾浩斯与其他实验心理学家们所发展的实验技术方向更加趋向研究认知——关注信息以及信息处理——最终演化为认知科学中的一部分。</p><h2 id="精神分析"><a href="#精神分析" class="headerlink" title="精神分析"></a>精神分析</h2><p>  精神分析学是一种研究意识、解释经历的方法；是一种关于人类行为的理论系统；是一种针对心理、情绪的治疗方法，特别是对潜意识中的冲突进行心理治疗。弗洛伊德的精神分析中的很多理论基于解释法、内省法以及临床观察。精神分析法广为流传，因为它的研究对象涉及性别、压抑、心理发展中的潜意识等。这些问题在当时都被列为社会禁忌，弗洛伊德则提供了催化剂，使得问题可以在正式社交中得以公开讨论。在临床上，弗洛伊德是自由联想的先驱，他对释梦治疗也很有研究。<br>  弗洛伊德对瑞士精神科医师卡尔·荣格的影响很大，后者的分析心理学与深度心理学互补。<br>  精神分析及其治疗受到诸多人士的批评，到二十世纪末，美国高等院校心理学院变得更加倾向于实证主义，将弗洛伊德理论边缘化</p><h2 id="行为主义"><a href="#行为主义" class="headerlink" title="行为主义"></a>行为主义</h2><p>  在整个20世纪的上半叶，行为主义学派支配了当时的心理学，其主张心理学是：“寻求理解特定的环境刺激如何控制特定类型的行为”。其主张心理学应分析先行的环境条件，即在行为之前出现、而且为一个机体产生反应或抑制反应提供活动场所的条件。因此，他们把行为反应看做是机体理解、预测和控制的行为，并因此做出相应的结果。基于对实验和变量的严格控制和强调，行为主义学对后来的心理学研究有着重要的影响。其代表人物为史金纳，然而其对于内在的认知历程是存而不论，近期流行的认知主义则是重视之前忽视的内在认知历程，代表人物有皮亚杰、米勒、西蒙等。<br>  当今世界主要的心理学学派有五大观点，每一个观点都强调行为及心理过程的不同方面。其主要包括神经心理学、精神分析学、行为主义心理学、人本主义心理学、认知心理学</p><h2 id="人本主义"><a href="#人本主义" class="headerlink" title="人本主义"></a>人本主义</h2><p>  二十世纪50年代，在行为主义与精神分析的影响下，人本心理学应育而生。应用现象学、交互主体性、第一人称视角，人本主义试图捕捉整个人——而不是人格或认知的一部分。人本主义心理学关注人类独特问题的基础，例如个人的自由意志、成长、自我实现、认同、死亡、孤独、自由与意义。人本过程的特点在于它关注主观臆想、拒绝宿命、着重成长的积极性而不是病理因素。<br>  一些人本学派的奠基人，如美国心理学家亚伯拉罕·马斯洛，创立了需求层次理论；卡尔·罗哲斯，创立了个人中心治疗。在此之后，正面心理学剖析了人本主义，对其更进一步的科学分析。</p><h2 id="存在主义"><a href="#存在主义" class="headerlink" title="存在主义"></a>存在主义</h2><p>  在二十世纪50到60年代，美国原精神分析学家罗洛·梅在德国哲学家马丁·海德格尔、丹麦哲学家索伦·奥贝·克尔凯郭尔的影响下，走上了心理学存在主义之路。这包括存在心理治疗。<br>  存在主义心理学不同于其它人本学派，即人性中立视角、对焦虑的积极观点等。存在主义心理学注重于人文主题，如死亡、自由意志、意义，并认为意义可以被神话、或是讲述方式改变。对于死亡及未来的真实性，通常会鼓励人们接受自由意志，尽管令人焦虑。</p><h2 id="认知主义"><a href="#认知主义" class="headerlink" title="认知主义"></a>认知主义</h2><p>  认知主义心理学派研究心理活动，包括解决问题、知觉、记忆、学习等。作为认知科学的一部分，这个心理学分支与其它学科有密切联系，包括神经科学、哲学、语言学等。<br>  诺姆·乔姆斯基在批评行为学概念中的“刺激”、“相应”、“强化”时，触发了一场心理学“认知革命”。乔姆斯基辩称这种观点会以一种肤浅、模糊的方式应用到复杂的人类行为中，特别是在语言习得的领域上。有一种假定认为人类天生拥有一种“内在的”语言习得机能，然而对于行为主义来说，这个问题在于所有行为，包括语言在内，都必须通过学习和强化来获得。社会学习理论家，如阿尔波特·班杜拉称儿童的生活环境有助于行为的改良。<br>  与此同时，技术进步帮助人们重拾被行为主义抛弃的心理活动与表述，如认知等。英国神经科学家查尔斯·斯科特·谢灵顿爵士与加拿大心理学家唐纳德·赫布应用实验总结了心理现象与人脑结构、功能之间的联系。计算机科学与人工智能的兴起，使得人类信息处理时常与机械信息处理相互类比。对认知的研究被应用于二战，用以理解武器操作。在二十世纪晚期，认知主义成为心理学的统领范式，认知心理学成为了流行分支。<br>  认知心理学认为隐蔽的心理活动应该使用科学的方式进行研究，心理学家创立了两种概念：阈下刺激物与内隐记忆，对应精神分析的潜意识或行为学的偶然形成行为。行为主义元素与认知心理学被整合成为认知行为疗法的基础。这种心理治疗由美国心理学家阿尔伯特·艾利斯和精神病学家亚伦·T·贝克创立而成。认知心理学与其它学科，如精神哲学、计算机科学、神经科学，一道被归入的上层学科认知科学。</p><hr><p>@ref:</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E7%90%86%E5%AD%A6" target="_blank" rel="noopener">心理学 - 维基百科，自由的百科全书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理学分支</title>
      <link href="/62.Psychology/01.%E5%BF%83%E7%90%86%E5%AD%A6%E5%88%86%E6%94%AF/"/>
      <url>/62.Psychology/01.%E5%BF%83%E7%90%86%E5%AD%A6%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="心理学分支"><a href="#心理学分支" class="headerlink" title="心理学分支"></a>心理学分支</h1><p>@todo待整理: <a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E7%90%86%E5%AD%A6#%E5%88%86%E6%94%AF" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BF%83%E7%90%86%E5%AD%A6#%E5%88%86%E6%94%AF</a></p><h2 id="临床心理学"><a href="#临床心理学" class="headerlink" title="临床心理学"></a>临床心理学</h2><p>临床心理学的研究与应用包括理解、预防、缓解心理痛苦与紊乱，促进心理健康和个人成长。虽然临床心理学家也会参与研究、教学、咨询、出庭作证、程序编订与管理，但该分支的中心是心理测评与治疗。</p><h2 id="认知心理学"><a href="#认知心理学" class="headerlink" title="认知心理学"></a>认知心理学</h2><p>认知心理学研究心理活动中的认知。知觉、注意、理智、思维、解题、记忆、学习、语言、情绪都在它的研究领域之中。经典认知心理学与认知主义学派有相互联系，根据机能主义与实验心理学，认知主义支持心理信息处理模型。</p><p>在更广域的层面上，认知科学是一种跨学科范畴，包括认知心理学、认知神经科学、人工智能、语言学、人机互动、计算神经科学、数理逻辑与人类学。计算机常被用于模拟这类实验现象。 计算机模拟为研究思维的功能组织提供了工具，神经系统科学则为大脑活动提供了度量衡。</p><h2 id="发展心理学"><a href="#发展心理学" class="headerlink" title="发展心理学"></a>发展心理学</h2><p>发展心理学着重于人类意志在毕生当中的发展过程，试图理解人们在世界中如何意识、理解、行动，并且研究这些现象是如何随着年龄而改变的。这些研究可能会着重于认知、感情、道德、社交、神经的发展。研究人员在探究儿童案例时使用一系列特殊的方式，以使得观察在自然的环境中进行，或是干脆与他们在实验中进行互动。这些实验常常以游戏或是活动的方式呈现，既好玩，又有科学意义；研究人员甚至设计出非常灵巧的方式以研究婴儿的心理活动。在研究儿童心理之余，发展心理学家也会研究人类毕生的老化过程，特别是在某些时段的快速转变（例如青少年和老年）。发展心理学家设计了一整套心理学理论来支持他们的研究。<br>如原”生家庭理论”</p>]]></content>
      
      
      <categories>
          
          <category> 62.Psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哲学家普遍赞同什么观点？（PhilPapers Survey 2020）zz</title>
      <link href="/61.Philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6%E6%99%AE%E9%81%8D%E8%B5%9E%E5%90%8C%E4%BB%80%E4%B9%88%E8%A7%82%E7%82%B9%EF%BC%9F%EF%BC%88PhilPapers-Survey-2020%EF%BC%89/"/>
      <url>/61.Philosophy/%E5%93%B2%E5%AD%A6%E5%AE%B6%E6%99%AE%E9%81%8D%E8%B5%9E%E5%90%8C%E4%BB%80%E4%B9%88%E8%A7%82%E7%82%B9%EF%BC%9F%EF%BC%88PhilPapers-Survey-2020%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Philpapers-Survey-2020"><a href="#Philpapers-Survey-2020" class="headerlink" title="Philpapers Survey 2020"></a>Philpapers Survey 2020</h2><p>@ref: </p><ul><li><a href="https://zhuanlan.zhihu.com/p/428768169" target="_blank" rel="noopener">哲学家普遍赞同什么观点？（PhilPapers Suvery 2020) - 知乎</a></li><li><a href="https://www.zhihu.com/question/496172592" target="_blank" rel="noopener">如何评价2020 Philpapers Survey的结果？ - 知乎</a></li><li><a href="https://survey2020.philpeople.org/" target="_blank" rel="noopener">https://survey2020.philpeople.org/</a></li></ul><hr><p>摘自 <a href="https://zhuanlan.zhihu.com/p/428768169" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/428768169</a></p><p>就在昨天，Philpapers Survey 2020的结果终于出来了！PhilPaper 采访了全球各地1785位职业哲学家100个哲学问题（回应量前五的是美国859人、英国163人、加拿大127人、德国89人和澳大利亚59人）。让我们来看一看他们对一部分问题的回应吧！对原文感兴趣的直接点击注解1<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p>注意，（1）所有下文的百分比涵盖两种情况，要么哲学家接受该观点（accept）要么哲学家倾向于接受该观点（lean towards）（2）我只挑了我感兴趣或者我对该话题有了解的问题进行翻译（3）非分析哲学专业读者请注意，哲学中通常对很多词语的理解和我们平常理解不太一样，甚至区别很大（4）本调查的问题大多是分析哲学问题，而分析哲学是说英语国家的主流，所以为了有参考性，英语国家的必然会多一些（5）至于为何没有询问其它非分析哲学问题，编者首先指出确实很多职业哲学家对这一点表达了不满，他们的回应大概是他们尝试创作了一些非分析哲学的问题，但是写出来后发现擅长的人太少了以至于无法保证数据的可参考性。他们说，对于这点，他们很对不起大家，下次会努力的<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>（6）职业哲学家是指读完哲学博士并且大多在校执教（7）我在翻译时并没查中文是如何翻译这些词的，具体请对照英文翻译，谢谢！</p><p><strong>先验知识（a priori knowledge）</strong></p><ul><li><p>认同：72.67%</p></li><li><p>不认同18.47%</p></li></ul><p><strong>美学价值（aesthetic value）</strong></p><ul><li><p>客观的43.53%</p></li><li><p>主观的40.59%</p></li></ul><p><strong>哲学的目的（the aim of philosophy）</strong></p><ul><li><p>真理&amp;知识42.18%</p></li><li><p>理解55.79%</p></li><li><p>智慧31.17%</p></li><li><p>幸福12.65%</p></li><li><p>善或公正22.70%</p></li></ul><p><strong>分析性和综合性的区分（analytic and synthetic）</strong></p><ul><li><p>有62.48%</p></li><li><p>没有25.78%</p></li></ul><p><strong>快感机器（experience machine就是说，有一台机器一旦你进去就不能出来了，它能让你感受到一切你想要的美好的感受，而且你进去后你根本不知道自己在这个机器中）</strong></p><ul><li><p>进入35.72%</p></li><li><p>不进入50.52%</p></li></ul><p><strong>世界的存在（external world）</strong></p><ul><li><p>唯心主义（idealism大致是乔治·贝克莱【George Berkeley】那种）6.63%</p></li><li><p>怀疑主义（skepticism）5.44%</p></li><li><p>非怀疑实在主义（non-skeptical realism）79.54%</p></li></ul><p><strong>哪种对世界存在怀疑论（external-world skepticism）的回应是最有说服力的？（Response to external-world skepticism (which is strongest?)）</strong></p><ul><li><p>溯因推理（abductive）22.13%</p></li><li><p>情境主义式回应（contextualist）10.74%</p></li><li><p>信条派回应（dogmatist）13.43%</p></li><li><p>认知外在论回应（epistemic externalist）18.90%</p></li><li><p>语义外在论（semantic externalist）8.38%</p></li><li><p>务实回应（pragmatic）22.77%</p></li></ul><p><strong>自由意志（free will）</strong></p><ul><li><p>相容论（compatibilism）59.16%</p></li><li><p>自由主义（libertarianism）18.83%</p></li><li><p>没有自由意志11.21%</p></li></ul><p><strong>性别（gender）</strong></p><ul><li><p>生理的（biological）29.04%</p></li><li><p>心理的（psychological）21.54%</p></li><li><p>社会的（social）63.10%</p></li><li><p>不是真实的（unreal）4.23%</p></li></ul><p><strong>上帝</strong></p><ul><li><p>神论18.93%</p></li><li><p>无神论66.95%</p></li></ul><p><strong>知识</strong></p><ul><li><p>经验主义（empiricism）43.90%</p></li><li><p>理性主义（rationalism）33.51%</p></li></ul><p><strong>自然法则（laws of nature）</strong></p><ul><li><p>休谟论（Humean）31.27%</p></li><li><p>非休谟论54.31%</p></li></ul><p><strong>生命的意义</strong></p><ul><li><p>主观的33.04%</p></li><li><p>客观的32.06%</p></li><li><p>不存在16.12%</p></li></ul><p><strong>心灵内容（mental content）</strong></p><ul><li><p>内在论（internalism）26.35%</p></li><li><p>外在论（externalism）58.12%</p></li></ul><p><strong>元伦理（meta-ethics）</strong></p><ul><li><p>道德实在论（moral realism）62.07%</p></li><li><p>道德非实在论26.12%</p></li></ul><p><strong>元伦理理论</strong></p><ul><li><p>非自然实在论（non-naturalism）26.56%</p></li><li><p>自然实在论（naturalist realism）31.64%</p></li><li><p>构成主义（constructivism）20.80%</p></li><li><p>抒发论（expressivism）10.64%</p></li><li><p>错误论（error theory）5.27%</p></li></ul><p><strong>元哲学（meta-philosophy，大概是研究哲学时我们的前提条件是否应该符合科学）</strong></p><ul><li><p>自然主义（naturalism）50.16%</p></li><li><p>非自然主义31.12%</p></li></ul><p><strong>心灵（mind）</strong></p><ul><li><p>物理主义（physicalism）51.93%</p></li><li><p>非物理主义32.08%</p></li></ul><p><strong>道德评价（moral judgement）</strong></p><ul><li><p>认知论（ cognitivism）69.25%</p></li><li><p>非认知论（non-cognitivism）20.72%</p></li></ul><p><strong>道德动力（moral motivation）</strong></p><ul><li><p>内在论41.01%</p></li><li><p>外在论39.33%</p></li></ul><p><strong>Newcomb’s problem（你参加了一个游戏，在你面前摆着两个非透明的箱子，箱子甲里面有一千元，而箱子乙中有一百万元。假设在你进入房间做决定之前，有一台准确率接近100%的机器会预测你将要做出的选择。如果它认为你只会拿箱子乙，那么箱子乙中的一百万就会原封不动的放在那里；可是如果它预测你会两个箱子都拿走，箱子乙中的一百万就会被取出。我们应该怎么做？）</strong></p><ul><li><p>拿箱子乙31.19%</p></li><li><p>拿两个箱子39.03%</p></li></ul><p><strong>规范伦理（normative ethics）</strong></p><ul><li><p>道义论（deontology康德类似的道德论）32.05%</p></li><li><p>结果论（consequentialism）30.56%</p></li><li><p>德性论（virtue ethics）36.99%</p></li></ul><p><strong>个人同一性（personal identity）</strong></p><ul><li><p>生理论（比如拥有同一个大脑）19.07%</p></li><li><p>心理论（比如记忆的延续）43.65%</p></li><li><p>额外观点论（比如有灵魂further-fact view）14.86%</p></li></ul><p><strong>哲学进程（philosophical progress</strong>）</p><ul><li><p>没有进步3.83%</p></li><li><p>有一点46.59%</p></li><li><p>很多41.69%</p></li></ul><p><strong>种族（race）</strong></p><ul><li><p>生理的18.68%</p></li><li><p>社会的63.43%</p></li><li><p>不真实的15.04%</p></li></ul><p><strong>科学</strong></p><ul><li><p>科学实在论（scientific realism）72.35%</p></li><li><p>科学非实在论15.04%</p></li></ul><p><strong>传送器（就是从地球扫描你的身体的全部信息，再将这些信息传送到比如火星，火星再根据这些信息用当地的材料复制出一个你，同时，地球会将被扫描信息的那个人毁灭）</strong></p><ul><li><p>你存活了下来35.24%</p></li><li><p>你死了40.06%</p></li></ul><p><strong>真理</strong></p><ul><li><p>对应（correspondence）51.37%</p></li><li><p>压缩（deflationary）24.53%</p></li><li><p>认知（epistemic）10.16%</p></li></ul><p><strong>知识的概念（analysis of knowledge）</strong></p><ul><li><p>有依据真信念（justified true beliefs）23.61%</p></li><li><p>其它理论32.20%</p></li><li><p>无法分析（no analysis）30.63%</p></li></ul><p><strong>死刑</strong></p><ul><li><p>道德上允许17.74%</p></li><li><p>道德上不允许75.13%</p></li></ul><p><strong>意识（consciousness）</strong></p><ul><li><p>二元论（dualism）21.96%</p></li><li><p>抹杀论（eliminativism）4.51%</p></li><li><p>功能论（functionalism）33.04%</p></li><li><p>恒等论（identity theory，比如，你的行为就是你大脑的xx神经运动）13.33%</p></li></ul><p><strong>人类基因改良</strong></p><ul><li><p>道德上允许64.21%</p></li><li><p>道德上不允许19.45%</p></li></ul><p><strong>休谟的观点</strong></p><ul><li><p>他是怀疑论者36.47%</p></li><li><p>他是自然主义者54.93%</p></li></ul><p><strong>永生</strong></p><ul><li><p>我要！44.92%</p></li><li><p>我才不要！41.33%</p></li></ul><p><strong>思想上传到电脑中</strong></p><ul><li><p>人死亡54.23%</p></li><li><p>人依然活着27.46%</p></li></ul><p><strong>有哲学知识么？</strong></p><ul><li><p>没有3.60%</p></li><li><p>有一点32.52%</p></li><li><p>有很多56.22%</p></li></ul><p><strong>科学中是否存在人的价值（Values in science (is ideal scientific reasoning necessarily sensitive or insensitive to non-epistemic values?): necessarily value-free, necessarily value-laden, or can be either?）</strong></p><ul><li><p>必然不存在（necessarily value-free）17.69%</p></li><li><p>必然存在（necessarily value-laden）44.02%</p></li></ul><p><strong>Wittgenstein</strong></p><ul><li><p>早期理论好24.61%</p></li><li><p>晚期理论好57.53%</p></li></ul><p><strong>政治哲学（Political philosophy）</strong></p><ul><li><p>社群主义（communitarianism）27.26%</p></li><li><p>平等主义（egalitarianism）44.05%</p></li><li><p>自由主义（libertarianism）13.40%</p></li></ul><p><strong>政治哲学中的方法</strong></p><ul><li><p>理想论（ideal theory）32.44%</p></li><li><p>非理想理论58.02%</p></li></ul><p><strong>政治</strong></p><ul><li><p>资本主义29.52%</p></li><li><p>社会主义53.02% （注意，对西方人来说，加拿大瑞典挪威等是他们首先想到的社会主义国家）</p></li></ul><p><strong>时间</strong></p><ul><li><p>A论27.25%</p></li><li><p>B论38.20%</p></li></ul><p><strong>环境哲学</strong></p><ul><li><p>以人类为中心（anthropocentric）42.25%</p></li><li><p>不以人类中心50.67%</p></li></ul><p><strong>思考能力，下列的各组中是否有一些成员是有意识的？（Other minds (for which groups are some members conscious?)）</strong></p><ul><li><p>人类95.15%</p></li><li><p>猫88.55%</p></li><li><p>鱼65.29%</p></li><li><p>苍蝇34.52%</p></li><li><p>蚯蚓24.18%</p></li><li><p>植物7.23%</p></li><li><p>粒子2.01%</p></li><li><p>新生婴儿84.34%</p></li><li><p>目前的AI 3.39%</p></li><li><p>以后的AI 39.19%</p></li></ul><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我发现很多读者对实在论（realism）很多感到惊讶。比如像我们是否知道或者有依据相信世界存在、道德、自由意志、科学、自然定律等等都可以称之为实在论。我后来想了一下，感觉原因可能至少有两点。首先，或许一些读者对哲学的相关概念不是很理解。比如，道德实在论是元伦理的理论，和它相对的是道德非实在论。但是注意，道德非实在论和道德相对论是两个话题（至少普遍大多哲学家是这样想的）。道德实在论者照样可以是道德相对主义者（这样的人可以说，在这个文化中，将刚出生男孩的脚剁下来道德上是绝对错的；但是在另一个文化中这样做道德上是可以被允许的）；而道德非实在论者可以相信道德是绝对的（他们可以说，道德价值本身是不存在的，但是跺脚行为在任何文化任何时间都是坚决不能推崇的）。还有就是在西方分析哲学论文中，我们基本不会看见证明（prove/proof）一词，而只是给出合理的理由就好。这也是为什么有那么多实在论者，他们在乎的更多的是依据，我们是否有相信的道理，而不是排除所有出错的可能。</p><p>其次，我突然想起自己大一时也是怀疑这个怀疑那个的，记得大一到大二自己成天吆喝着自由意志不存在，或者我们没法知道世界存在。现在想想，是因为那是上哲学课时，老师只是在介绍问题，他们一般会花很久介绍为什么有哲学家认为自由意志不存在，贝克莱的唯心主义的论证是什么等等。而教授一般只会花一小部分时间解释其它哲学家是如何回应这些问题的。这就难免导致自己片面的理解这些哲学家的回应，忽略了哲学本身的复杂程度。这也是为什么国外哲学新生的常见现象是认为（1）人没有自由意志并且（2）道德是相对的，甚至对于（2）很多哲学家直接在学术论文中戏称“大一相对论者”（Freshman relativist）。我个人揣测也是如此，大家很多人都是读过为什么说人没有自由意志，或者为什么因果关系是休谟式的便就再没继续研究下去？</p><p>当然，我这样揣测没有任何意图，只是好奇为何人们会对实在论很多而感到震惊。其实我个人本身在上文问题中至少有7-8个问题也都倾向于小众观点。</p><p>简单瞅了一眼问卷发起者的文章见注解3<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，下面是一些值得关注的信息，这些信息更适合哲学专业或者懂英语的人阅读，因为我并没有翻译，抱歉！</p><p><strong>参与者的年龄统计</strong></p><p><img src="https://pic2.zhimg.com/v2-515479d17a07e2918fdcd3718a4f52b9_b.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/80/v2-515479d17a07e2918fdcd3718a4f52b9_1440w.jpg" alt=""></p><p>见注解3原文21页</p><p><strong>参与者性别统计</strong></p><p><img src="https://pic3.zhimg.com/v2-aeb29be57b98cd8676aa15c17c2b896a_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-aeb29be57b98cd8676aa15c17c2b896a_1440w.jpg" alt=""></p><p>见注解3原文22页</p><p><strong>参与者所在领域（philosophical traditions)</strong></p><p><img src="https://pic2.zhimg.com/v2-4a8f0b54bf141c57add387027d47e9b5_b.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/80/v2-4a8f0b54bf141c57add387027d47e9b5_1440w.jpg" alt=""></p><p>见注解3原文22页</p><p><strong>参与者主要研究方向（Areas of specialization）</strong></p><p><img src="https://pic3.zhimg.com/v2-36e921b21b642a133943d7120eacc3ce_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-36e921b21b642a133943d7120eacc3ce_1440w.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-d1bb2349cb3317c5fbef37e18827a865_b.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/80/v2-d1bb2349cb3317c5fbef37e18827a865_1440w.jpg" alt=""></p><p>见注解3原文23页</p><p><strong>参与者最认同哪位哲学家（most identified with）</strong></p><p><img src="https://pic3.zhimg.com/v2-b0d4be8af89a1d9c156fe9a31a0a1866_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-b0d4be8af89a1d9c156fe9a31a0a1866_1440w.jpg" alt=""></p><p>见注解3文章的24页</p><ol><li>亚里士多德 2. 休谟 3. 康德 4. 维特根斯坦 5. 大卫路易斯（David Lewis) 6. 威拉德·冯·奥曼·蒯因 7. 弗雷格 8 鲁道夫·卡尔纳普 9 罗素 10 柏拉图 14 马克思</li></ol><p><strong>和2009年的调查相比，变动最大的观点是</strong></p><p><img src="https://pic3.zhimg.com/v2-6a99c3b7c40af0a88601f7721cd9a1b2_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-6a99c3b7c40af0a88601f7721cd9a1b2_1440w.jpg" alt=""></p><p>见注解3原文25页</p><p><strong>参与2009年调查那批人在2020年调查变化幅度最大的观点是</strong></p><p><img src="https://pic4.zhimg.com/v2-a26afc3ef49265a4896b31160fe3f98b_b.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-a26afc3ef49265a4896b31160fe3f98b_1440w.jpg" alt=""></p><p>见注解3文章25页</p><p><strong>亚洲参与调查的哲学系（中国大学大家一眼了然，就不翻译了哈）</strong> <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p><p><img src="https://pic3.zhimg.com/v2-767962cd696f537323fa1d6197ab934a_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-767962cd696f537323fa1d6197ab934a_1440w.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-7681db8b45b74eb744bac963613a1941_b.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/80/v2-7681db8b45b74eb744bac963613a1941_1440w.jpg" alt=""></p><p>上下二图见注解4</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://survey2020.philpeople.org/" target="_blank" rel="noopener">https://survey2020.philpeople.org/</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://survey2020.philpeople.org/survey/design/thoughts" target="_blank" rel="noopener">Perhaps the most common objection to the 2020 survey was that the survey questions were strongly skewed to certain traditions and orientations in philosophy. Respondents from non-analytic philosophical traditions often reported feeling somewhat alienated by the questions, and even respondents from analytic traditions sometimes reported that the questions reflected a fairly traditional conception of philosophy that did not fully represent philosophy as it is done in 2020.We acknowledge these criticisms as reasonable. We made some attempt to find questions from non-analytic traditions, but it was difficult to find candidates that enough of our target group would be familiar with… We’re especially sorry for bringing about feelings of alienation. We will try harder next time. </a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://philarchive.org/archive/BOUPOP-3" target="_blank" rel="noopener">https://philarchive.org/archive/BOUPOP-3</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://survey2020.philpeople.org/survey/design/target-departments" target="_blank" rel="noopener">https://survey2020.philpeople.org/survey/design/target-departments</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>认知偏差手册</title>
      <link href="/61.Philosophy/%E8%AE%A4%E7%9F%A5%E5%81%8F%E5%B7%AE%E6%89%8B%E5%86%8C/"/>
      <url>/61.Philosophy/%E8%AE%A4%E7%9F%A5%E5%81%8F%E5%B7%AE%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf" target="_blank" rel="noopener">认知偏差知识手册</a> @todo 待整理</p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先验与后验</title>
      <link href="/61.Philosophy/%E5%85%88%E9%AA%8C%E4%B8%8E%E5%90%8E%E9%AA%8C/"/>
      <url>/61.Philosophy/%E5%85%88%E9%AA%8C%E4%B8%8E%E5%90%8E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="先验与后验"><a href="#先验与后验" class="headerlink" title="先验与后验"></a>先验与后验</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%85%88%E9%A9%97%E8%88%87%E5%BE%8C%E9%A9%97" target="_blank" rel="noopener">先验与后验 - 维基百科，自由的百科全书</a></p><p>先验（a priori ；也译作 先天）在拉丁文中指“来自先前的东西”，或引申为“有经验之前”。近代西方传统中，认为先验指无需经验或先于经验获得的知识。它通常与后验知识相比较，后验指的是“有经验之后”，即”需要经验”。这一区分来自于中世纪逻辑所区分的两种论证，从原因到结果的论证称为“先验的”，而从结果到原因的论证称为“后验的”（a posteriori）。</p><p>认识论的基本问题之一是究竟是否存在任何重要的先验知识。通常来说，理性主义者相信存在先验知识，而经验主义者认为所有知识根本上源于某种经验（通常是外部经验），即便有先验知识在某种意义上也不重要。还有些经验主义者认为先验知识只是对语词意义的分析，而与世界无关。</p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是价值</title>
      <link href="/61.Philosophy/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%B7%E5%80%BC/"/>
      <url>/61.Philosophy/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>@ref <a href="https://www.zhihu.com/question/361851239/answer/945015231" target="_blank" rel="noopener">哲学家如何理解「价值」，什么是「价值」? - 知乎</a></p><p>“价值”这个概念在不同的哲学分支中的含义也有所不同。这里我主要讲一下伦理学中的“价值”这一概念。简单来说，伦理学中的“价值”就是我们通常所说的“好”或者“善”（goodness）。当我们在说某件事物或某个行为是“好”的时候，我们其实就是在说它具有“价值”。</p><p>首先，根据其应用范围，价值可以分为“道德价值”（moral value）和“幸福价值”（prudential value）。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p>道德价值:</p><ul><li>道德价值主要应用于结果主义（consequentialism）。结果主义认为，一个事物的道德价值决定了我们应当如何对它进行道德评判，并以此来规范我们的行为。如果一个行为能够导致道德价值的增加，那么这个行为就是我们应该做的。相反，如果一个行为所造成的后果具有负面的道德价值，那么我们就不应当这样做。</li><li>不同的哲学家对道德价值的理解也不尽相同。比如，相对主义认为什么具有道德价值是由人或者文化所决定的；福利主义（welfarism）认为人（或动物）的幸福是唯一具有道德价值的东西；道德虚无主义（moral nihilism）认为道德价值不存在；G.E.Moore则认为道德价值存在，但是无法被精确定义。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li></ul><p>幸福价值:</p><ul><li>与道德价值不同，幸福价值仅仅应用于对个体状况的讨论。如果一个事物对某个个体是好的，那么这个事物就对这个个体有着幸福价值。</li><li>关于幸福价值的理论主要有三种：<ul><li>享乐主义（hedonism）：使个体快乐的东西就是对这个个体好的东西</li><li>欲望满足理论（desire stisfaction theory）：能够满足个体欲望的东西就是对这个个体好的东西</li><li>客观清单理论（objective list theory）：某些事物是具有客观的幸福价值的（比如：事业、友谊、孩子、教育、知识等）。</li></ul></li><li>幸福价值并不会直接影响我们的道德判断，但是很多规范性理论（比如福利主义）会将幸福价值包含在道德价值之中，从而使幸福价值能够间接地影响我们的道德判断。比如，伦理利己主义（ethical egoism）认为道德价值就是一个人自身的幸福价值。</li><li>功利主义（utilitarianism）则认为所有具有感受能力的个体的幸福价值都是道德价值的一部分。也有一些理论认为幸福价值并不一定被道德价值所包含。比如目的论平等主义（telic egalitarianism）认为平等本身是具有道德价值的。因此即使平等会导致幸福价值的减少，我们也应当追求平等。</li><li>多元主义（pluralism）认为道德价值是由很多因素决定的，而幸福价值可能仅仅只是其中之一。</li></ul><p>另外，我们还可以通过价值的来源将其分为“内在价值”（intrinsic value），“外在价值”（extrinsic value）或/和“工具价值”（instrumental value）。<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p><ul><li>内在价值指的是一个事物本身所具有的价值。内在价值来源于事物的内在属性。</li><li>外在价值和工具价值则是一个事物由于和其他事物的联系而被赋予的价值。他们源于其他事物的内在价值。具体的可以参考这个回答：<a href="https://www.zhihu.com/question/28903722" target="_blank" rel="noopener">哲学上对内在价值（Intrinsic Value）的研究是什么样的？</a></li></ul><p>有关价值的更多的讨论可以参考：</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//plato.stanford.edu/entries/value-theory" target="_blank" rel="noopener">Value Theory</a></li><li><a href="https://link.zhihu.com/?target=https%3A//plato.stanford.edu/entries/value-intrinsic-extrinsic/" target="_blank" rel="noopener">Intrinsic vs. Extrinsic Value</a></li><li><a href="https://link.zhihu.com/?target=https%3A//plato.stanford.edu/entries/well-being/" target="_blank" rel="noopener">Well-Being</a></li></ul><hr><p>参考:</p><p>作者：王昱洲<br>链接：<a href="https://www.zhihu.com/question/361851239/answer/945015231" target="_blank" rel="noopener">https://www.zhihu.com/question/361851239/answer/945015231</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">“prudential value”直译为“审慎价值”。但是我感觉这个翻译并不能体现其含义，并且由于个这个概念与“幸福”（well-being）通常被放在一起理解，故译为“幸福价值”。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Moore提出了著名的“开放问题论证”： 1. 如果X等同于“善”, 那么 “X真的是善的吗”这个问题就是无意义的. 2. “X真的是善的吗”这个问题不是无意义的。3. 因此，X不等同于“善”</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">“工具价值”通常被等同于“外在价值”。但是也有一些人认为存在非工具性的“外在价值”。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>罗素《What I Have Lived For》</title>
      <link href="/61.Philosophy/%E7%BD%97%E7%B4%A0%E3%80%8AWhat%20I%20Have%20Lived%20For%E3%80%8B/"/>
      <url>/61.Philosophy/%E7%BD%97%E7%B4%A0%E3%80%8AWhat%20I%20Have%20Lived%20For%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>《我为什么而活着》是《罗素自传》的序言, 原文:</p><blockquote><p>What I Have Lived For</p><p>Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. These passions, like great winds, have blown me hither and thither, in a wayward course, over a great ocean of anguish, reaching to the very verge of despair.</p><p>I have sought love, first, because it brings ecstasy - ecstasy so great that I would often have sacrificed all the rest of life for a few hours of this joy. I have sought it, next, because it relieves loneliness–that terrible loneliness in which one shivering consciousness looks over the rim of the world into the cold unfathomable lifeless abyss. I have sought it finally, because in the union of love I have seen, in a mystic miniature, the prefiguring vision of the heaven that saints and poets have imagined. This is what I sought, and though it might seem too good for human life, this is what–at last–I have found.</p><p>With equal passion I have sought knowledge. I have wished to understand the hearts of men. I have wished to know why the stars shine. And I have tried to apprehend the Pythagorean power by which number holds sway above the flux. A little of this, but not much, I have achieved.</p><p>Love and knowledge, so far as they were possible, led upward toward the heavens. But always pity brought me back to earth. Echoes of cries of pain reverberate in my heart. Children in famine, victims tortured by oppressors, helpless old people a burden to their sons, and the whole world of loneliness, poverty, and pain make a mockery of what human life should be. I long to alleviate this evil, but I cannot, and I too suffer.</p><p>This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.</p></blockquote><p>翻译如下:</p><blockquote><p>我为什么而活着</p><p>对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，这三种纯洁但无比强烈的激情支配着我的一生。这三种激情，就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。</p><p>我寻求爱情，首先因为爱情给我带来狂喜，它如此强烈，以致我经常愿意为了几小时的欢愉而牺牲生命中的其他一切。我寻求爱情，其次是因为爱情解除孤寂——那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。我寻求爱情，最后是因为在爱情的结合中，我看到圣徒和诗人们所想象的天空景象的神秘缩影。这就是我所寻求的，虽然它对人生似乎过于美好，然而最终我还是得到了它。</p><p>我以同样的热情寻求知识，我希望了解人的心灵。我希望知道星星为什么闪闪发光，我试图理解毕达哥拉斯的思想威力，即数字支配着万物流转。这方面我获得一些成就，然而并不多。</p><p>爱情和知识，尽可能地把我引上天堂，但同情心总把我带回尘世。痛苦的呼号的回声在我心中回荡，饥饿的儿童，被压迫者折磨的受害者，被儿女视为可厌负担的无助的老人，以及充满孤寂、贫穷和痛苦的整个世界，都是对人类应有生活的嘲讽。我渴望减轻这些不幸，但是我无能为力，而且我自己也深受其害。</p><p>这就是我的一生，我觉得它值得活。如果有机会的话，我还乐意再活一次。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生的意义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马基雅维利主义</title>
      <link href="/61.Philosophy/10.%E9%A9%AC%E5%9F%BA%E9%9B%85%E7%BB%B4%E5%88%A9%E4%B8%BB%E4%B9%89/"/>
      <url>/61.Philosophy/10.%E9%A9%AC%E5%9F%BA%E9%9B%85%E7%BB%B4%E5%88%A9%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="马基雅维利和《君主论》"><a href="#马基雅维利和《君主论》" class="headerlink" title="马基雅维利和《君主论》"></a>马基雅维利和《君主论》</h1><p>马基雅维利: <a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E5%9F%BA%E9%9B%85%E7%B6%AD%E5%88%A9" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%A6%AC%E5%9F%BA%E9%9B%85%E7%B6%AD%E5%88%A9</a></p><h2 id="《君主论》"><a href="#《君主论》" class="headerlink" title="《君主论》"></a>《君主论》</h2><blockquote><p>在此书中马基雅维利阐述了一个君主（统治者）应该采用怎样的统治手段才能保住自己的政权。书中人性本恶的部分类似中国荀子、先秦法家思想，尤其在论证“君主应该不择手段达到目的”这一命题时，和韩非子继承申不害提出的“重术”观点不谋而合。[1]:123马基雅维利所假设的人性本恶也反映出他认为必须使用残忍权力才能达成实际目标的主张。君主不该对于其臣民抱有完全的信赖和信任。</p></blockquote><h2 id="《论李维》"><a href="#《论李维》" class="headerlink" title="《论李维》"></a>《论李维》</h2><blockquote><p>《论李维》是对李维《罗马史》前十卷的研析，马基雅维利总结了一系列的历史教训，描述了共和国应该如何成立、架构，涵盖了对权力制衡、政治权力分立的好处、以及共和国比君主国优秀之处。在《论李维》一书中，马基雅维利的政治哲学初露端倪，对之后法国的卢梭产生了深远的影响。在《民约论》中，卢梭就多次引用了马基维利的著作。</p></blockquote><h1 id="马基雅维利主义"><a href="#马基雅维利主义" class="headerlink" title="马基雅维利主义"></a>马基雅维利主义</h1><ul><li><a href="https://www.zhihu.com/question/58589132" target="_blank" rel="noopener">马基雅维利主义的弱点是什么？ - 知乎</a></li><li><a href="https://wiki.mbalib.com/wiki/%E9%A9%AC%E5%9F%BA%E9%9B%85%E7%BB%B4%E5%88%A9%E4%B8%BB%E4%B9%89" target="_blank" rel="noopener">马基雅维利主义 - MBA智库百科</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚无主义</title>
      <link href="/61.Philosophy/10.%E8%99%9A%E6%97%A0%E4%B8%BB%E4%B9%89/"/>
      <url>/61.Philosophy/10.%E8%99%9A%E6%97%A0%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="虚无主义-维基百科，自由的百科全书"><a href="#虚无主义-维基百科，自由的百科全书" class="headerlink" title="虚无主义 - 维基百科，自由的百科全书"></a><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%97%A0%E4%B8%BB%E4%B9%89" target="_blank" rel="noopener">虚无主义 - 维基百科，自由的百科全书</a></h2><p><strong>虚无主义</strong>（英语：Nihilism，源自拉丁语nihil）是一种哲学或佛学中的一系列观点，它拒绝人类存在的一般或基本方面，如客观真理、知识、道德、价值观或意义。不同的虚无主义立场持有不同的观点，即人类价值观是毫无根据的，生命没有意义，知识是不可能的，或者某些实体不存在或毫无意义。</p><p>虚无主义的学者可能认为它只是一个贴在各种不同哲学上的标签，或是一个由唯名论、怀疑主义和哲学悲观主义产生的独特历史概念，也可能来自基督教本身。当代对这一思想的理解很大程度上源于尼采的“虚无主义危机”，从中衍生出两个核心概念：更高价值的破坏和对生命肯定的反对。</p><p>在普遍使用中，该术语通常是指存在虚无主义的形式，根据这种形式，生命没有内在价值、意义或目的。<br>虚无主义中的其他突出立场包括拒绝所有规范和伦理观点（道德虚无主义），拒绝所有社会和政治制度（政治虚无主义，英语：Political nihilism）；<br>认为没有知识可以或确实存在的立场（认识论虚无主义，英语：Epistemological nihilism）；<br>以及许多形而上学立场断言非抽象对象不存在（形而上学虚无主义，英语：Metaphysical nihilism）；<br>复合对像不存在（分体虚无主义，英语：Mereological nihilism），甚至生命本身不存在。</p><h2 id="为什么《瑞克和莫蒂》里的瑞克很痛苦？-知乎"><a href="#为什么《瑞克和莫蒂》里的瑞克很痛苦？-知乎" class="headerlink" title="为什么《瑞克和莫蒂》里的瑞克很痛苦？ - 知乎"></a><a href="https://www.zhihu.com/question/54732488/answer/2352682900" target="_blank" rel="noopener">为什么《瑞克和莫蒂》里的瑞克很痛苦？ - 知乎</a></h2><h2 id="最容易支持虚无主义的mbti类型是什么？-知乎"><a href="#最容易支持虚无主义的mbti类型是什么？-知乎" class="headerlink" title="最容易支持虚无主义的mbti类型是什么？ - 知乎"></a><a href="https://www.zhihu.com/question/386420830/answer/1654747075" target="_blank" rel="noopener">最容易支持虚无主义的mbti类型是什么？ - 知乎</a></h2><p>Ti/Ni/Ne功能高度发展，Fi/Si/Se较弱的个体容易感受到虚无。<br>总体来讲，虚无主义者中INTP、ENTP、INFJ、INTJ居多。</p><h2 id="INFP型人格和虚无主义冲突吗？-知乎"><a href="#INFP型人格和虚无主义冲突吗？-知乎" class="headerlink" title=" INFP型人格和虚无主义冲突吗？ - 知乎"></a><a href="https://www.zhihu.com/question/437151690/answer/1653827142" target="_blank" rel="noopener"> INFP型人格和虚无主义冲突吗？ - 知乎</a></h2><p>从八维功能来看，INFP的第一功能Fi（内倾情感）是一个能够确立并不断加固个人价值体系，维持情感内循环“自给自足”从而无需与他人互动的功能。</p><p>Fi注重外物与“我”的联系，在探索外部世界时，会在外物与自我之间建立无数包含独特意义的情感纽带。</p><p>以下是Fi使用者面对新事物时，经常下意识思考的问题：</p><p>“这件事给我带来了怎样的情绪体验？”<br>“这一事物在我眼中是怎么样的，我会如何评价它呢？它是善是恶，是美是丑？是否能够被我内心的价值标准所接受呢？”</p><p>而这与虚无主义者惯常的思维模式有着较大差别。多数虚无主义者以Ti（内倾思考）为主导功能，力求以绝对旁观者的视角看待事物，以至于进入一种无我的状态。<br>Ti又被称为溯源逻辑，擅长追本溯源，解剖出事物背后的一切逻辑节点并加以分析，最后得出一个精炼的普适性的模型。<br>许多Ti使用者之所以会陷入虚无，正是因为Ti将一切事物都解构了，使得他们看清了许多真相——个人的存在有多么渺小；社会是如何不受人为控制而运作；道德和意义感不过是人虚构其上的产物；以及一个终将到来的万物寂灭的结局。<br>发展到极端的Ti，便是一个如此反生物性的功能。它蔑视常人那套浮于表面的感知视角，不去看树在地面之上的那一部分，而是拼命挖掘出盘虬错节的树根，扔到主人面前说“这才是本质”。于是，它的主人只能一直凝视着那些丑陋可怖的树根，无法像常人那样再去欣赏树的美丽，这彻底摧毁了他们作为一个人的感知，让他们从此堕入虚无的深渊。</p><h2 id="論INTJ的思維方式-GetIt01"><a href="#論INTJ的思維方式-GetIt01" class="headerlink" title="論INTJ的思維方式 - GetIt01"></a><a href="https://www.getit01.com/p2018082141507177/" target="_blank" rel="noopener">論INTJ的思維方式 - GetIt01</a></h2><p>INFJ的虛無主義。INFJ的思維方式是從一個肯定命題推導另一個肯定命題，這種思維方式可以依據結論再次推導肯定命題，甚至可以依據新的結論再次推導肯定命題。然而，這種推導是無限的，INFJ不知道最後的結論是什麼，這導致INFJ常思考生活的最終意義卻找不到真正的結論。INFJ的虛無主義正是由於無法確認行為的最終意義的無意義感。<br>INTJ的循環論也源於這種思維方式。如果未知的否定命題等同於另外一個肯定命題，那麼在形式上這種思維方式轉化為一個肯定的命題推導另一個肯定的命題（當然，真正運用這種思維方式的人格是INFJ人格，INTJ只是表明上運用），例如，大導致小，生導致死。這類命題可以結合為循環命題，例如大導致小，小導致大，生導致死，死導致生。道教的陰陽相生是典型的INTJ的話語。黑格爾認為哲學最終是一個圓圈，最原初的概念可通過不斷推導回到自身，這是典型的INTJ循環論。</p><h2 id="从四个层次谈虚无主义和存在主义的区别-知乎"><a href="#从四个层次谈虚无主义和存在主义的区别-知乎" class="headerlink" title="从四个层次谈虚无主义和存在主义的区别 - 知乎"></a><a href="https://zhuanlan.zhihu.com/p/259158726" target="_blank" rel="noopener">从四个层次谈虚无主义和存在主义的区别 - 知乎</a></h2><h2 id="存在主义和虚无主义最大的区别在哪里？-知乎"><a href="#存在主义和虚无主义最大的区别在哪里？-知乎" class="headerlink" title="存在主义和虚无主义最大的区别在哪里？ - 知乎"></a><a href="https://www.zhihu.com/question/24806211" target="_blank" rel="noopener">存在主义和虚无主义最大的区别在哪里？ - 知乎</a></h2><h2 id="寻找人生意义不要落入虚无的陷阱–理论-人民网"><a href="#寻找人生意义不要落入虚无的陷阱–理论-人民网" class="headerlink" title="寻找人生意义不要落入虚无的陷阱–理论-人民网"></a><a href="http://theory.people.com.cn/n1/2016/1129/c40531-28905111.html" target="_blank" rel="noopener">寻找人生意义不要落入虚无的陷阱–理论-人民网</a></h2><p>人生的意义，其实就是寻找、发现、创造、体现并传递意义。换句话说，人生本来是没有所谓先天定义的意义的。如果有，那只能说有生物进化上的意义，那就是物种的生存和繁殖。而人，不仅仅是生物的个体，更是社会，文化和精神的个体，我们肯定会有高于动物本性的智慧和理性，因此， 作为一个有积极人性的人，我们其实是用一生证明了自己的存在不是一种偶然；我们的一生也不是平淡无奇的等待死亡的过程。它一定要有特殊的属于我们自己的意义和价值的。</p><p>……</p><p>如何让我们的年轻人在此时此刻找到人生的意义呢？我个人觉得，一个很重要同时又很简单的积极心理学的方法就是：让自己经常想一想， 我们在哪些时候、哪些地方，做哪些事情，会让我们产生旺盛的生命力的感觉，有什么值得我们感动，有什么事情值得我们留恋，什么事情让我们喜悦，什么事情让我们安定，什么事情让我们感兴趣，什么事情给我们希望，什么事情让我们敬仰，什么事情让我们热爱。凡是让我们能够体验到人世间最美好的积极心理体验的事情，都会让我们意识到生活的意义。因为，感情就是人生的意义之一。</p><p>除了积极的情绪体验之外，著名华裔心理学家王载宝还提出来我们可以在自己的成就、社会的接纳和尊严、精神和文化生活、亲情和友情、宗教体验、社会服务和贡献，以及幸福的体验（如福流）中发现意义。</p><p>因此，寻找和发现人生的意义不是一种抽象概念，不是宗教或者政治的宣传，它是我们的生活，是一个困惑、艰难，而后快乐、幸福的心路历程。当我们快乐的时候，我们的心理能量更充沛，思维更开放，生活的态度更积极，因此也更容易发现生命的意义。（作者系清华大学心理学系主任）</p><h2 id="罗素的《What-I-have-Lived-for》"><a href="#罗素的《What-I-have-Lived-for》" class="headerlink" title="罗素的《What I have Lived for》"></a>罗素的《What I have Lived for》</h2><p>@link </p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实用主义</title>
      <link href="/61.Philosophy/10.%E5%AE%9E%E7%94%A8%E4%B8%BB%E4%B9%89/"/>
      <url>/61.Philosophy/10.%E5%AE%9E%E7%94%A8%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>实用主义的根本纲领是把确定信念作为出发点，把采取行动当作主要手段，把获得实际效果当作最高目的。 实用主义者英文原名是Pragmatism，源出希腊文πρανμα，意思即是行为、行动。 而实用主义者对行为、行动的解释，关注行动是否能带来某种实际的效果，也就是关注直接的效用、利益，有用即是真理，无用即为谬误。</p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05b.海德格《存在与时间》</title>
      <link href="/61.Philosophy/05b.%E6%B5%B7%E5%BE%B7%E6%A0%BC%E3%80%8A%E5%AD%98%E5%9C%A8%E4%B8%8E%E6%97%B6%E9%97%B4%E3%80%8B/"/>
      <url>/61.Philosophy/05b.%E6%B5%B7%E5%BE%B7%E6%A0%BC%E3%80%8A%E5%AD%98%E5%9C%A8%E4%B8%8E%E6%97%B6%E9%97%B4%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/1783111/" target="_blank" rel="noopener">存在与时间 (豆瓣)</a></p><hr><p><a href="https://book.douban.com/subject/1783111/blockquotes" target="_blank" rel="noopener">存在与时间（2006 陈嘉映 / 王庆节 合译） - 原文摘录</a> </p><ul><li>此在的非本真状态并不意味着‘较少’存在或‘较低’存在。非本真状态反而可以是按照此在最充分的具体化情况而在此在的忙碌、激动、兴致、嗜好中规定此在。</li><li>@todo 待整理</li></ul><h2 id="“此在”的三层空间"><a href="#“此在”的三层空间" class="headerlink" title="“此在”的三层空间"></a>“此在”的三层空间</h2><p>摘自《一个等待与无用的民族：庄子与海德格尔的第二次转向》/第一章/1.2：<code>《存在与时间》：在被抛与筹划之间</code></p><blockquote></blockquote><p>// 海德格的“三层空间”：<br>// - 被抛的处境：沉沦、或以操持与烦生存于世<br>// - 向着未来筹划：离开常人的沉沦<br>// - 决断的到时：向死而在</p><p>《存在与时间》确立了这一系列新哲学话语的起点以及基本的结构—— <strong>一个三层的基本“范型”</strong>。《存在与时间》也有一个基本的出发点：即只有“此在”（Dasein）追问存在本身的意义，<strong>其他存在者只是追问 存在者的存在者性或者存在者的整体，从而遗忘了存在本身，传统形而上学就是如此</strong>。只有“此在”通过生存的出离，去追问存在的意义，才能打开之间的场域。<br>// ‘场域’指三层之间的空间，打开场域才能将周围-共在-自身区分开来</p><ul><li><p>1.221.第一层是“被抛的处境”：人类被抛在一个三重世界之中，<strong>这是区分为“周围-共在-自身（um-mit-selbst-Welt）”的三重世界</strong>。“此在”被抛于世，因此可以从现象学区域本体论的方式区分为：周围世界——共在世界——自身世界。<br>“此在”以 操心与烦<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 的情调生存于世：周围世界是与自然生活环境相关的现存生活世界；共在世界主要是一些明确打交道的他人；自身世界则是“此在”追问存在而与其他存在者区分开来，尤其与常人区分开来。<br>无论是烦神，还是烦忙，“此在”总是从被抛的世界中开始自身筹划。<br>—— 在这个日常生活世界中，“此在”的生存出离拉开了与常人的距离，这是存在者的生存论差异所打开的间距或“之间”。</p></li><li><p>1.222.第二层是“筹划的敞开”：“此在”的自身理解与筹划，摆脱沉沦状态（某个主体的“自身理解”——“筹划”——“意义展开”——针对的则是“沉沦”状态，甚至是敌对状态）。<br>“此在”要从常人状态区分开来，必须以“烦”为基本情调去进行主动的筹划<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，这就是“此在”的意义理解与解释，建构一个本己的意义世界，<br>这个阶段以“用具”（Zeug）的“使用”(Gebrauch)为生存论操作的重心，通过区分开生存论的“上手状态”（Zuhandenheit）与现存的“手前状态”，以现象学解释学的“作为”结构建构一个意义关联的世界（以解释学方式补充胡塞尔现象学noesis-noema的意向对象与意向活动），<br>并且继续展开“烦”（或操心）的意义结构，才可能避免常人的沉沦（verfallen）[3]。“此在”的意义理解通过不同的言谈或沉默的倾听，或者携带朋友的声音，与常人相区分，并向着未来筹划。而不与之一道筹划的他者则成为对手或敌人，成为对峙或争辩的一方。<br>—— <strong>把这个筹划所赋予的意义世界与常人并不筹划的沉沦世界区分开来</strong>，形成存在论的差异或“间域”，它有待于敞开，并不现存地存在着，它来自于“此在”的生存筹划，才可能与常人的世界彻底区分开来，这需要斗争，需要争执，才可能打开此间域，让上升的继续上升，让沉沦的彻底沉沦，甚至被灭绝。</p></li><li><p>1.223.第三层是“决断的到时”：“此在”的生存筹划尽管敞开了空间，但要保持持续的敞开，要彻底与常人区分开来，形成决定性的事件，则必须决断，才可能实现自身的自身性，这是“时间性的到时”与“边缘域的构成与敞开”。<br><strong>“此在”向着未来筹划，必须进入更为彻底的出离状态，这是“此在”倾听良知召唤的无声之音，而产生“畏”的情调，通过“向死而在”<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>的先行，因为只有“死”才是“最为本己的、无所旁涉的、不可超越的、确知的、然而又是不确定的可能性[1]”（SZ: 309/367），甚至是“不可能的可能性”</strong>。“此在”才成为本己的，才获得时间性的有限性规定，但这又并非生物学的死亡与死去，反而更为靠近基督教良机的发生。而这个等待与倾听，只有通过决心，才可能保持敞开，只有在决断中形成边缘域，这就形成了“此在”的意义，即时间性。</p></li></ul><p>1.23.海德格尔的哲学由此确立哲学话语的生成模式，从《存在与时间》开始，海德格尔区分开“此在”（Dasein）与“常人”，常人是注定沉沦的，只有“此在”才会去追问存在的意义而出离自身，摆脱“人性”，成为生存者，在倾听良知召唤中，向死而在，而获得“本真”（Authentic）<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>或本己的自身性，即获得时间性，建构起自身世界的视域。不断进入“被抛”的状态，再通过某个主体生存出离的决断，向着存在去理解与“筹划”，这构成海德格尔最为基本的哲学动作，并且打开“之间”的地带。由此形成了海德格尔最为基本的思考框架：一方面，“此在”必须不断深入被抛处境（Geworfenheit），越是深入被抛的处境，进入更深的深渊，越是抵达世界的深处，越是经验到实际性的处境；另一方面，也就越是需要去筹划或开抛（Entwurf），向着更高的高处筹划，不断筹划，更为敞开。这个被抛与敞开的张力，不断打开“之间”的场域，就是“此在”生存的新世界。存在论差异之为差异：就在于不断打开这个间域，而非陷入静止停顿之中。</p><blockquote><p>本真（Authentic） @link: <a href="/61.Philosophy/05a.此在的本真-海德格的存在主义/" title="05a.此在的本真-海德格的存在主义">05a.此在的本真-海德格的存在主义</a></p></blockquote><p><a href="https://www.sohu.com/a/200698036_227314" target="_blank" rel="noopener">https://www.sohu.com/a/200698036_227314</a></p><hr><p>@tag: #存在主义 #海德格</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">烦： 在《存在与时间》里，人的行为举止分成三个方面：和形形色色的事物打交道，和他人打交道，和自己打交道。这三个方面，分别用Besorgen，Fuersorge，Sorge来标识。Sorge一词具有忧虑担心和操持置办两重主要的含义。Besorgen也有忧虑担心和操持置办两重主要的含义，只不过Sorge更突出忧虑而Besorgen更突出置办，因为后者主要具动词性而且有个及物的词头be。Fuersorge既然以Sorge为词根，难免有Sorge的意味，不过通用的含义主要是照顾、帮助、救济。这三个词，熊伟先生分别译作烦、烦心、麻烦。我分别译作烦、烦忙、烦神。 by 陈嘉映</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">筹划： 海德格尔在《哲学论稿》中使用了以werfen为词根的一组词语，主要包括entwerfen，loswerfen，Entwurf，Entwerfer，Entworfenes，Werfer，Wurf，Gegenwurf，Loswurf，Geworfenheit等。这些词语按说都有“抛”(werfen)这个词根，但英译者却作了一个区分：  Entwurf 翻译作 projecting-open（筹划性开启） ，entwerfen 翻译作 to project-open（筹划） ；除这两者之外，上述其他带有werfen的词语则统统以英文throw和throwing译之，也即以“抛”译之。我原先比较赞同英译者的这种做法，稍作修正，把动词entwerfen和名词Entwurf译为“筹划”(或“筹划性开启”)，因为正如英译者指出的，这两者指的是一种为存有所居有的开启和揭示行为；其他诸词则以“抛”为字根译之。 by 孙周兴</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">沉沦（verfallen）： “沉沦”一词听起来带有否定的意义，但在海德格尔自己看来，以“常人”标识日常存在的此在，并且以“沉沦”标识日常此在的基本存在方式，并没有直接的伦理学意义。所谓“沉沦”并不带有任何消极的评价，而是意味着：此在首先且通常总是寓于它所烦忙的世界，多半消失在常人的公众意见中。“此在首先总是已经从它自身脱落、即从本真的能自己存在脱落而沉沦于‘世界’。共处是靠闲谈、好奇和两可来引导的，而沉沦于‘世界’就意指消散在这种共处中”。（海德格尔，1999年，第204页） by 孙周兴</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">“向死而在”或“向死而生”： 德文Das Sein zum Tode，英文Being towards death</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">本真： 本真（Authenticity），或译真诚性。真诚性（authenticity）连通著个人的未来和过去，使自我具有连续性。它还要求在这种关系上接受自己的死亡。</span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05a.此在的本真-海德格的存在主义</title>
      <link href="/61.Philosophy/05a.%E6%AD%A4%E5%9C%A8%E7%9A%84%E6%9C%AC%E7%9C%9F-%E6%B5%B7%E5%BE%B7%E6%A0%BC%E7%9A%84%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
      <url>/61.Philosophy/05a.%E6%AD%A4%E5%9C%A8%E7%9A%84%E6%9C%AC%E7%9C%9F-%E6%B5%B7%E5%BE%B7%E6%A0%BC%E7%9A%84%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="此在的本真-海德格的存在主义"><a href="#此在的本真-海德格的存在主义" class="headerlink" title="此在的本真-海德格的存在主义"></a>此在的本真-海德格的存在主义</h1><blockquote><p>海德格尔的『此在』在德语里翻译成“Dasein”，在黑格尔体系里，“Dasein”意指“定在”或“有限存在”，物质世界或具体历史的有限性对应真理总体的无限性。“Da”表示“在此之中”，“此”表示“这里”。</p></blockquote><p>海德格把『此在』关切自身的存在 称为牵挂（care），牵挂也是『此在』与世界的基本关联，也是『此在』在“这个世界”获得意义的基础。</p><p>牵挂由：生存（唯物的“存在”），实际性(存在于在……之中)，沉沦(存在于……状态里)，以及言谈组成。</p><p>沉沦（非指消极状态，也非道德上的堕落）的日常体现：闲谈，好奇，两可。</p><blockquote><p>闲谈：本质是诉说的快感，不为真实性和合理性负责，不必经过自我验证<br>好奇：这里不是指求知欲，而是放纵自己于世界，寻求不安和激动。不操持于所及的世界，而是涣散在新的可能性中<br>两可：在“共在”的状况下，处在一种随从、不做决断的状态</p></blockquote><p>这三种日常方式被称为“此在的沉沦”，但它们不是消极的，而是『此在』从“本真”状态脱离，而消失于常人的公共意见中（常人：自身之外的大众）</p><p>那么此在的“本真”又是一种什么状态呢？<br>本真(Authentic)是此在的一种生活状态：『此在』在面对一个孤独的局面时采取决断的态度，并且敢于承担自己的唯一性和个体性，那么可以说，此在进取了本真(Authentic)的状态。并且此在意识到这个状态的存在。</p><blockquote><p>海德格尔认为，当人与自己的死亡遭遇时，真实的属己的自我才会显露出来。死亡是对现实世界的否定，当人面对死亡时，才会停止对外界的忧虑和担心，从牵挂中脱离开来，从外界中孤立出自己，成为“真正的存在”。</p></blockquote><blockquote><p>[[../62.Psychology/《存在主义心理治疗》读书笔记]] /第三部《孤独》： 海德格用“不自在”来指代人失去了在世界中的熟悉感的状态，当人完全专注于表象世界，对自己的存在处境失去接触时，海德格称这个人处于“日常”或者“陷入”的模式里。 </p></blockquote><hr><p>=&gt; <a href="/61.Philosophy/05.存在主义/" title="05.存在主义">05.存在主义</a></p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>05.存在主义Index</title>
      <link href="/61.Philosophy/05.%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
      <url>/61.Philosophy/05.%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="存在主义"><a href="#存在主义" class="headerlink" title="存在主义"></a>存在主义</h1><blockquote><p>存在主义的产生，有着强烈的时代背景。当时，两次世界大战使人的生存受到威胁，使人的尊严在战争中被践踏，而战后的经济萧条和各种社会问题又加深了人们心理上的阴影，形成了普遍的生存危机感。战后科技对社会生活的渗透，又使人们受到机械的控制和管理，人被平均化、整体化，个人的独立性和自主创造性被泯灭，“被异化了”成为人们的共同感觉。所有这一切，都已经不能用传统社会进步和人生观来说明和解释了。失去了生存的精神支柱而感到空虚和惶惑不安的人们，需要重新思考生存的目的和意义。为此，存在主义产生并发展起来。</p></blockquote><p>存在主义（英语：existentialism），是一个哲学的非理性主义思潮，它认为人存在的意义是无法经由理性思考而得到答案的，以强调个人、独立自主和主观经验。尼采和克尔凯郭尔可被看作其先驱。在20世纪中它流传非常广泛，其哲学思想还延续到了60年代兴起的人本主义。雅斯贝尔斯和海德格尔、保罗·萨特和加缪是其代表人物。</p><p>其最突出的命题是：世界没有终极的目标；人们发现自己处于一个隐隐约约而有敌意的世界中；世界让人痛苦；人们选择而且无法避免选择他们的品格、目标和观点；不选择就是一种选择，即是选择了“不选择”；世界和我们的处境的真相最清楚地反映在茫然的心理不安或恐惧的瞬间。</p><p>参考: <a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89" target="_blank" rel="noopener">存在主义 - 维基百科，自由的百科全书</a></p><p><img src="/images/哲学笔记/15509875952795.jpg" alt="OneNote/Mind Sketch/存在主义"></p><hr><p>用牛津的存在主义指南的归纳，存在主义有以下五种主题：</p><ol><li>存在先于本质：你是你的选择的结果。// 把存在（你遇到的事情，你对事情的观点，你做的决定）视为比本质（客观存在的事实或者物质）更重要的存在</li><li>时间就是生命本质 （time is of the essence）：时间并不能被测量，个体不同的体验，时间并不相同。</li><li>人本主义：以人为本，寻找生活的意义，反抗非人性的异化。</li><li>自由/与责任：你的个体选择，不能被任何道德标准所框住，你的选择创造了你。但你对你的自由负有责任。</li><li>伦理思考是终极命题（ethical considerations are paramount）：每个大家都有自己的理论，但是总体理论是探寻我们个体与社会的伦理真谛。</li></ol><p>参考自：<a href="https://www.zhihu.com/question/19558616/answer/175862602" target="_blank" rel="noopener">什么是存在主义？存在主义的起源及社会背景是什么样的？ - 知乎</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="存在先于本质"><a href="#存在先于本质" class="headerlink" title="存在先于本质"></a>存在先于本质</h3><p>其最著名和最明确的倡议是让-保罗·萨特的格言：<code>存在先于本质</code>（法语：l’existence précède l’essence）：</p><blockquote><p>人的存在则表现为种种可能性，经领会、筹划、选择获得本身的规定性，所以他是存在先于本质。萨特在《存在主义是一种人道主义》等著作中对此作了详尽阐述，断言不存在设定人性范本的上帝，也不存在古典哲学倡导的普遍人性<br>人的生存状态展现出来的是，首先有人，人遭逢自己，在世界中涌现出来，然后才给自己下定义。开始人一无所有，只在后来他才成为某种东西。他不仅是自己设想的人，而且是他志愿成为的人。人们无法以固定的现成的人性说明人的行动，人获得本质的过程不外是自我设计、自我造就的过程，人就是他一系列行动的总和，他实现自己有多少，他就有多少存在。该原则意味着主观性和自由是研究人的存在的出发点，强调个人在世界上的独特地位及自决能力。</p></blockquote><h3 id="荒谬"><a href="#荒谬" class="headerlink" title="荒谬"></a>荒谬</h3><p>荒谬这个概念是指世界本身没有意义，只有我们赋予它的意义。这无意义性还涵盖着世界的是非不分与不公平。这与“坏事不会发生在好人身上”的概念相左；对世界而言，打个比方说，没有所谓的好人或坏人；发生的事就这样发生了，它可能降临在任何“好”人或“坏”人身上。</p><p>因为世界是荒谬的，任何时候任何事可能发生在任何人身上，而一件坏事就能迫使人直接面对荒谬。荒谬这概念一直以来都在文学上相当突出。克尔凯郭尔、贝克特、卡夫卡、陀思妥耶夫斯基、尤内斯库、乌纳穆诺、皮蓝德罗、萨特、海勒和加缪的许多文学作品都在描述人遭遇到世界的荒谬。</p><p>在痛苦地察觉到此无意义后，加缪在《薛西弗斯的神话》中称“真正严肃的哲学问题只有一个，就是自杀。”虽然针对这类可能极度有害遭遇的“药方”各自不同，不论是克尔凯郭尔的宗教“阶段”或加缪的坚持不懈，大多数存在主义哲学家的焦点都在帮助人们避开不好的生活方式，以免置于丧失一切意义的长期险境之中。这种意义崩解的可能性会对自身平静构成重要威胁，而这也就违背存在主义的哲学。[12]据信因自杀是可能的而使得所有人都是存在主义者。</p><h2 id="海格德尔"><a href="#海格德尔" class="headerlink" title="海格德尔"></a>海格德尔</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>海德格尔指出西方哲学自从柏拉图便误解存在的意思，去研究个别存在的问题而不去研究存在本身的问题。换句话说，海德格尔不相信所有对存在的探讨焦点放在个别存在物／实体及其性质。对于海德格尔来说，一个对存在更可信的分析是查探已经了解的存在物的基础或者促成存在物如实体展现的背后基础。[1] 但是自从哲学家都忽略了这个更基本理论前期的存在，并且以此推导其他理论，错把那些理论在各处应用，终于混淆我们对存在及人类存在的理解。为免这些深层误解，海德格尔相信哲学的探求应该新方式来进行，重踏哲学历史足迹，一步一步出发。</p><p>二十世纪三十年代中期起，海德格尔 开始了对西方哲学史的系统性的阐释。他从现象学的、解释学的、存在论的角度研究了一些重要哲学家的著作，并且试图将这些著作未被思考过的前提和偏见展示出来。根据海德格尔的说法, 所有至今的哲学蓝图，都是对世界的 单向度的理解，这种单向度，他认为是所有形而上学的标志。</p><p>按照海德格尔的观点，这种形而上学的 对世界的理解, 在现代“技术”中达到了顶峰。“技术”这个概念，他不仅理解成一种中性的用来达到目的的手段，而且他试图去展示：通过技术，我们对世界的理解也发生了变化。</p><p>根据他的观点，由于技术，我们从实用的角度，去看待地球。由于技术的全球性传播，和毫无节制的对自然资源的利用，海德格尔在技术中看到了一种不可抗拒的危险。</p><p>他把艺术看成是技术的对立面，并且从三十年代末开始，他根据荷尔德林的诗，领会到了对于单纯的技术性的世界关联方式的替代方式。</p><p>海德格尔曾尝试引领哲学家脱离形而上学及知识论的问题而朝向本体论的问题。这就是存在的意义。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E4%B8%81%C2%B7%E6%B5%B7%E5%BE%B7%E6%A0%BC%E5%B0%94" target="_blank" rel="noopener">马丁·海德格尔 - 维基百科，自由的百科全书</a></p></blockquote><h3 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h3><h4 id="此在"><a href="#此在" class="headerlink" title="此在"></a>此在</h4><p>海德格尔的“此在”在德语里翻译成“Dasein”，在黑格尔体系里，“Dasein”意指“定在”或“有限存在”，物质世界或具体历史的有限性对应真理总体的无限性。“Da”表示“在此之中”，“此”表示“这里”</p><h4 id="此在的牵挂"><a href="#此在的牵挂" class="headerlink" title="此在的牵挂"></a>此在的牵挂</h4><p>牵挂（Care）是一种状态，是“此在”（Dasein）关切它本身的存在。<br>因为“此在（Dasein）”的本性 在于它的生存（existence），也就是实现它的可能性。对任何从当前现实，朝向未来状况的变动，都必会产生这样的问题——“ 我将做什么？”这就是牵挂（Care）。牵挂（Care）植根于“此在”选择（Choice）它的存在的能力之中。<br>牵挂（Care）被视为“此在”（Dasein）与世界之间的基本关联，并且是“此在”这个世界中获得意义的基础。它是“此在”所有经验的基本状态。<br>由于所有的选择（Choice）都在世界中作出，牵挂就成为“在此世界中存在”的“此在”之存在的特性。<br>牵挂由生存（先于自身存在）、实际性（已经存在于……之中）、沉沦（存在于……状态里）和言谈组成，并且将“此在”（Dasein）显示于其整体之中。</p><ul><li>生存（先于自身存在）</li><li>实际性（已经存在于……之中）</li><li>沉沦（存在于……状态里）</li><li>言谈</li></ul><p>它与时间性，即人类生活的时间结构息息相通。《存在与时间》中的“此在与时间性”部分就试图将时间性（Temporality）揭示为牵挂的所有要素的根基。</p><h4 id="此在的本真和沉沦"><a href="#此在的本真和沉沦" class="headerlink" title="此在的本真和沉沦"></a>此在的本真和沉沦</h4><p>【此在】有两种生存状态，本真的和非本真的。</p><ul><li><p>本真，“真诚的”（authentic）生存状态，如果此在（它、他或她）在面对这么一个孤独局面时采取决断的态度，并且敢于承担自己的唯一性和个体性，那么此在可说是进入了“真诚的”（authentic）生存状态，并意识到这个状态的含义。真诚性（authenticity）连通著个人的未来和过去，使自我具有连续性。它还要求在这种关系上接受自己的死亡。<br>海德格尔认为，当人与自己的死亡遭遇时，真实的属己的自我才会显露出来。在真正属已状态中，“我”总是居先的，尽管这个“我”并不等同于一个传统哲学意义上的主体。</p></li><li><p>非本真，“不真诚的”（inauthenticity）状态，如果一个人被畏惧压倒，通过没入于众人或匿名的“人们”[They，das Man]来保护自己，正如人们通常所做的那様，这就是此在的非本真状态。在“不真诚的”（inauthenticity）状态中，“人们”（They）居先，人失去了自己的存有意义。<br>这种态度或姿态就是 海德格尔所说的此有的“沉沦”[fallingness，Verfallen]，即此有避开自身，让自身沉沦于日常的一般性事务中，与俗世共浮沉。// 沉沦状态指的是一个人失去自我独立思考能力，把自我本身归入到群体中，用群体思维来思考问题的状态。</p></li></ul><h5 id="沉沦的体现"><a href="#沉沦的体现" class="headerlink" title="沉沦的体现"></a>沉沦的体现</h5><p>【沉沦】的体现有：闲谈、好奇、两可（海德格的“沉沦”并不是一种消极的评价，也不是指此在道德上的堕落）</p><blockquote><p>1闲谈：闲谈的本质是相互言说的快感,不为真实性合理性 负责。不经过自我考证。<br>2好奇：这里不是指为了有所知,而是为了放纵自己于世界,寻求不安和激动.不逗留于操心所及的周围世界,涣散在新的可能性中。// 八卦，新闻，看热闹<br>3两可：指在共在状况下,此在处于一种不知不觉的虚伪，随从，无决断的状态。“这种两可总是把它所寻求的东西传递给好奇，并给闲言披上一种假象，仿佛在闲言中万事俱已决断好了。”</p></blockquote><p>这三种日常方式被称为”沉沦”,但它们不是消极的.这是此在从本真脱落而消失于常人的公共意见中,与杂然共在.即非本真的状态.这种状态是有诱惑力和安定作用的,可以减少独自探索的痛苦和承担责任。<br>在这种沉沦状态中，常人失去了能够为自己行为负责的个体性，成为异己力量的附庸。</p><h5 id="为何沉沦"><a href="#为何沉沦" class="headerlink" title="为何沉沦"></a>为何沉沦</h5><p>在海德格尔看来，畏和“怕”不同。因为怕有确定的对象。或者怕某物，或者怕某人，总之是担心某一对象会给自己造成某种伤害。“怕”所表现的只是此在特定情况下的“当下状态”，而不是此在的“在本身”。畏与怕不同的是，不知道畏什么，“畏之所畏说明的是：进行威胁者什么也不是……但‘什么也不是’并不意味着无”。</p><p>而沉沦给了解脱畏的一种方式,当此在处于共在的状况下,闲谈,好奇,两可都能摆脱畏.</p><h4 id="此在的死亡"><a href="#此在的死亡" class="headerlink" title="此在的死亡"></a>此在的死亡</h4><p>海德格尔指出，死亡是对现实世界生活的否定。当人面对死亡时，才会停止对世界的忧虑和担心，从陷落中孤立出自己，成为真正的存在。死亡是属于个人的事，他人无法替代，衹能靠你自己体验死亡。死亡是任何时候都可能发生的，人在什么时候死亡，都是合理的，没有规定你该活多久。人应随时准备死亡。<br>因此, 海德格尔指出，人必须正视死亡，从恐惧中明白自己活着的重要性。为自己计划未来时，必须包括死亡。人不该衹接受生命，而拒绝接受死亡。</p><h5 id="向死而生"><a href="#向死而生" class="headerlink" title="向死而生"></a>向死而生</h5><p>向死而生 (Being-towards-death)，意思是当人意识到自己终将一死时，就会深刻反思自己生命的意义。海德格称每个此在皆有死亡的可能性，生命的经验将在那一刻完全终结。当人意识到那一刻终将来临，就会反思自己整个人生规划。</p><h3 id="著作"><a href="#著作" class="headerlink" title="著作"></a>著作</h3><h4 id="《存在与时间》1927"><a href="#《存在与时间》1927" class="headerlink" title="《存在与时间》1927"></a>《存在与时间》1927</h4><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%9C%A8%E8%88%87%E6%99%82%E9%96%93" target="_blank" rel="noopener">存在与时间 - 维基百科，自由的百科全书</a></p></blockquote><h2 id="加缪"><a href="#加缪" class="headerlink" title="加缪"></a>加缪</h2><p><img src="/images/哲学笔记/15544688533146.jpg" alt=""></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>阿尔贝·加缪（Albert Camus，1913年11月7日—1960年1月4日），法国作家、哲学家，存在主义文学、“荒诞哲学”的代表人物。主要作品有《局外人》、《鼠疫》等。</p><p>加缪于1957年获得诺贝尔文学奖，他在20世纪50年代以前，一直被看作是存在主义者，尽管他自己多次否认。</p><p>1943年4月，加缪结识了萨特（让-保罗·萨特）和波伏娃，在哲学和戏剧等方面的共同爱好使他们成了非常亲密的朋友。然而萨特倾向于共产党和马克思主义，而加缪则对苏联社会有着比较清醒的认识。</p><p>1951年加缪发表了哲学论文《反抗者》之后，遭到了左派知识分子阵营的攻击，并引起一场与萨特等人长达一年之久的论战，最后与萨特决裂。这时人们才发现，加缪是荒诞哲学及其文学的代表人物。</p><p>加缪在他的小说、戏剧、随笔和论著中，深刻地揭示出人在异己的世界中的孤独、个人与自身的日益异化，以及罪恶和死亡的不可避免。但他在揭示出世界的荒诞的同时却并不绝望和颓丧，他主张要在荒诞中奋起反抗，在绝望中坚持真理和正义，他为世人指出了一条基督教和马克思主义以外的自由人道主义道路。他直面惨淡人生的勇气，他“知其不可而为之”的大无畏精神，使他在第二次世界大战之后不仅在法国，而且在欧洲并最终在全世界，成为他那一代人的代言人和下一代人的精神导师。</p><p><strong>“荒诞”</strong> 是他强调的最重要的一个概念。“荒诞”这个概念也是20世纪文学和哲学中非常重要的关键词之一。但是，对“荒诞”的解释则大为不同，各人有各人的表述。加缪是这么说的：<br><code>这个世界是不合理的，这是人们可以明确说出的表述。但是，荒诞是这一不合理性与人的心灵深处所呼唤的对理性的强烈要求的对立。</code><br>听上去，他的这句解释特别的拗口和费解，其实，他理解的人生荒诞感，是人对世界的主观感受。加缪认为，人在面对艰难而机械的现实生存的时候，每天都要按照一个节奏和生活模式来生存，必然要产生出我为什么要这么生活，我为什么不能以其它方式生活的荒诞感，可是，偏偏人就不能以其它方式生活，人还必须要以人现在的方式生活。” 于是，这就产生了荒诞感。</p><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><h4 id="人道主义"><a href="#人道主义" class="headerlink" title="人道主义"></a>人道主义</h4><p>加缪思想的核心是人道主义，人的尊严问题，一直缠绕着他的创作、生活和政治斗争的根本问题。《薛西弗斯神话》和《局外人》构成了加缪文学创作的母题，包含着加缪未来作品的核心问题。书中，薛西弗斯（又译：西叙福斯、西西弗斯）的幸福假设的提出，其本质动机，不在荒诞，因为荒诞不能告诉我们何谓幸福及不幸；之所以加缪假设薛西弗斯是幸福的，是因为他认为只有幸福的生活才符合人的尊严。</p><p>反抗才能体现尊严。薛西弗斯被责为永罚，却幸福，这绝对是一种反抗，也是在这种条件下唯一可能的反抗形式。加缪在假设薛西弗斯幸福的时候，充分运用了想象和独断，其潜台词，却是人类尊严的需要。</p><h4 id="二元对立"><a href="#二元对立" class="headerlink" title="二元对立"></a>二元对立</h4><p>加缪的创作存在大量的二元对立的主题，其中有一些直接作为书名如反与正，流放和王国等，荒诞和理性，生与死，堕落和拯救，阳光和阴影，有罪和无辜。这些二元对立的主题经常成对出现，而且互不取消，甚至有相反相成的意思，这是他的一大特点和魅力之所在。加缪在他的随笔中数次使用这样的修辞方式：用一片黑暗来形容明亮的阳光。随笔中也许不过是一种修辞，但这种修辞代表的思维方式却贯穿了加缪几乎全部的创作，成为他的重要特色。<br>正是在这样对矛盾的正视当中反映了人类思维的局限及其与世界的断裂。二元对立的两极互相为对方的存在而存在，形成强大的张力，悖论和歧义性、多义性在此从生，这也成为加缪难以被定义的地方，其间人道主义一以贯之，然而人道主义本来就是意义含混的词。</p><h4 id="存在主义-1"><a href="#存在主义-1" class="headerlink" title="存在主义"></a>存在主义</h4><p>在第二次世界大战以后，人们更感到前途渺茫，苦闷彷徨，人的生存面临严重威胁，人失去了安全感，人被绝望、孤独和无家可归的情绪所笼罩，这时理性主义、科学主义和乐观主义逐步被荒诞哲学所取代。人们普遍感受到这个世界的荒诞性，人存在的荒诞性，于是荒诞哲学应运而生。存在主义哲学对于“荒诞”的解释是：由于人和世界的分离，世界对于人来说是荒诞的、毫无意义的，而人对荒诞的世界无能为力，因此不抱任何希望，对一切事物都无动于衷。</p><p>阿尔贝·加缪是存在主义哲学家中对荒诞论述得最为全面、最深刻，并使之具有新意的人之一，这也是他的哲学的最大特色，因而被人们称之为“荒诞哲学” 。荒诞哲学是资产阶级文明遭到严重冲击的哲学表现。随着西方资本主义社会在其发展过程中不断暴露出它的痼疾，和由此带来的灾难性、毁坏性后果，诸如剧烈的阶级斗争和社会震荡，周期性的经济危机，两次世界大战，法西斯主义的崛起和它对人的灭绝人性的迫害，“使得人们在资本主义发展初期所滋长蔓延起来的对理性和科学的颂扬，对社会进步的乐观幻想，迅速被一种所谓‘存在的不可理解’，‘人的存在的走投无路的悲剧性’的感觉所取代”。</p><p>存在主义包容了各种各样思想的一种思潮，在各种公认的存在主义思想之间也存在着尖锐的矛盾。简单而言，存在主义的重大主题为个人对于存在的恐惧，荒诞的感受；它反映人在面对世界时所感到的一种情绪：孤立无援、个人承担但无意义的世界荒谬而没有尽头、个人处于一种“被抛弃”的境地。</p><blockquote><p>参考自 <a href="https://baike.baidu.com/item/%E9%98%BF%E5%B0%94%E8%B4%9D%C2%B7%E5%8A%A0%E7%BC%AA/1358953" target="_blank" rel="noopener">阿尔贝·加缪（法国作家、哲学家）_百度百科</a></p></blockquote><h3 id="著作-1"><a href="#著作-1" class="headerlink" title="著作"></a>著作</h3><h4 id="《局外人》1942"><a href="#《局外人》1942" class="headerlink" title="《局外人》1942"></a>《局外人》1942</h4><p>《局外人》形象地体现了存在主义哲学关于“荒谬”的观念；由于人和世界的分离，世界对于人来说是荒诞的、毫无意义的，而人对荒诞的世界无能为力，因此不抱任何希望，对一切事物都无动于衷。</p><blockquote><p><a href="https://baike.baidu.com/item/%E5%B1%80%E5%A4%96%E4%BA%BA/3784787" target="_blank" rel="noopener">局外人（阿尔贝·加缪著中篇小说）_百度百科</a></p></blockquote><h4 id="《反抗者》1951"><a href="#《反抗者》1951" class="headerlink" title="《反抗者》1951"></a>《反抗者》1951</h4><p> 为了将《西西弗神话》中所蕴含的主题更加深入地进行形而上的追索和沉入到历史经验的脉络中，1951 年，加缪完成了酝酿十年之久的哲学随笔《反抗者》。在这部著作中，加缪提出了如下命题：“我反抗，故我在”。“我们每天遭受的苦难中，反抗所起的作用犹如‘我思’在思想范畴所起的作用一样。 它是第一个明显的事实，然而这个事实使人摆脱了孤独状态。它使所有的人都接受了第一种价值。我反抗，故我们存在。”也只有反抗，人类才能最终超越荒诞的境地。</p><p>那么，何谓反抗者？加缪开宗明义地说：“一个说‘不’的人。然而，它虽然拒绝，却并不放弃：他也是从一开始行动就说‘是’的人。”“不”与“是”，岂不是相互矛盾？这正是加缪的深刻性和复杂性所在。 他举例说，当一个奴隶向主人说“不”时，他是一个反抗者。但同时，他又是一个说“是”的人，因为当他反抗时，他事实上肯定了主人与奴隶界限的存在。肯定与否定的共存，构建出反抗的价值，也就是人存在的价值。也就是说，反抗表面上看起来是否定之物，“其实它表现了人身上始终应该捍卫的东西，因而十足地成为肯定之物”。无论如何，反抗都应该成为一种绝对命令，因为反抗代表了人的不肯屈服的那一部分，是“人的最独特的东西”，也是人之为人、人的尊严感的体现。</p><p>在《反抗者》中，加缪将反抗分为两种：“形而上的反抗”和“历史上的反抗”。“形而上的反抗是人挺身而起反对其生存状态与全部创造。它之所以是形而上的，是因为它否认人与创造的目的。”从萨德的颂扬个人情欲与恶的“绝对否定”的反抗，到伊万·卡拉马佐夫的“拒绝得救”——除非拯救所有的人，否则无一人得救——式的反抗，再到尼采的对抗虚无主义<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的“绝对肯定”的反抗，加缪构建了一个“反抗的形而上学”：我反抗，故我存在。反抗既是一种生命的尊严，也是一种生命的创造。“之所以存在反抗，是因为谎言、 非正义与暴力部分地构成了反抗者的生存状况。他若要坚持反抗，则要下决心完全不杀人与说谎，永远不同意一切杀人与暴力的行动。他也不能让自己杀人与说谎。”也就是说，反抗不是为了我们自己的存在而去杀人，相反，是为了“创造我们现在的存在而活着，并让他人活着”。反抗何时会走向它的反面？加缪认为，反抗堕落的形式之一就是革命。</p><p>在“历史上的反抗”一节中，加缪以“革命”为关键词，考察了自1793 年以来的历次革命运动，他得出的结论是：反抗一旦从纯心灵领域进入到历史领域的实际行动，就会变成改变社会秩序和结构的暴力行为。一旦反抗者变成革命者，形而上的谋杀就会带来普遍杀人的时代。反抗者的“不”与“是”的辩证平衡一旦被破坏，反抗就会演变为暴力与杀人的循环游戏。“大部分革命的形式与特点就在于杀人。所有的或几乎所有的革命都曾经是杀人的。”真正激怒萨特的，正是加缪对历史主义的清算，和对马克思主义的质疑。“马克思主义就其一个方面来说，是认为人是有罪的而历史是无罪的学说。” 人们一旦以历史之名，将杀戮制度化与合法化，反抗的历史将演变为一部血腥的历史。例如，苏联社会主义所依傍的斯大林化的马克思主义，不但将杀人合法化，而且变成了一种政府行为和国家恐怖主义，于是，便为人类反抗史带来了一份沉重的历史清单：流放、审判、集中营、劳改营、秘密处决、铁幕、 冷战……他甚至将苏联制度与法西斯制度做了一个意味深长的对比：“把法西斯主义的目标与俄国共产主义的目标混为一谈是不正确的。前者由刽子手自己颂扬刽子手，而后者更富有悲剧性，竟由受害者来颂扬刽子手。前者从未想过要解放所有的人，而仅仅想解放某些人而征服其他人。后者就其最深刻的原则而言，旨在解放所有的人，但要暂时地奴役他们所有的人。” 革命走入歧途的原因，就在于它的不知节制。“节制并非反抗的反面。反抗正是节制，在捍卫着它，穿过历史及其混乱而重新创立节制。”加缪如此言说，无异于与法国政治左派公然决裂，向萨特公开叫板。正如阿隆森教授所言：“在《反抗者》临近尾声时，加缪显然想激萨特作出回应，但是，为什么他不愿意提到朋友的名字？加缪强烈反对萨特的立场，想要了解一种历史导向的哲学何以是道德的，他似乎不得不与萨特正面交锋，而同时他又极力避免这样做。</p><p>作者：OnePerson<br>链接：<a href="https://www.zhihu.com/question/19558616/answer/234453332" target="_blank" rel="noopener">https://www.zhihu.com/question/19558616/answer/234453332</a><br>来源：知乎</p><h4 id="《西西弗的神话》1942"><a href="#《西西弗的神话》1942" class="headerlink" title="《西西弗的神话》1942"></a>《西西弗的神话》1942</h4><p>在加缪的笔下，西西弗是一位荒诞的英雄。西西弗拥有巨大的精神力量，他是一个注定要与失败的命运抗争的人，他没有怨恨，没有犹豫，不存任何希望，他明明知道劳而无功，却朝着不知道尽头的痛苦，脚步沉重而均匀地走去，他清楚地知道，无数次的胜利其实是无数次的失败，但它只是激起了轻蔑，“没有轻蔑克服不了的命运”，他知道自己是命运的主人，他永远前进，他的行动就是对荒谬的反抗，他朝着山顶所进行的斗争本身就足以充实一颗人心，完全没有必要消除荒谬，关键是要活着，是要带着这种破裂去生活。人有精神，但还有至关重要的身体，精神依靠身体去穷尽现在的一切</p><h2 id="萨特"><a href="#萨特" class="headerlink" title="萨特"></a>萨特</h2><p><img src="/images/哲学笔记/15544347555311.jpg" alt=""></p><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>让-保罗·萨特（法语：Jean-Paul Sartre，1905年6月21日－1980年4月15日），著名法国哲学家、作家、剧作家、小说家、政治活动家，存在主义哲学大师及二战后存在主义思潮的领军人物，被誉为二十世纪最重要的哲学家之一。其代表作《存在与虚无》是存在主义的巅峰作品。<br>他主张一切从人、人的意识出发，来研究人和这个世界，把人的主观意识的存在看成是一切存在的根本。</p><p>参考： <a href="https://zh.wikipedia.org/wiki/%E8%AE%A9-%E4%BF%9D%E7%BD%97%C2%B7%E8%90%A8%E7%89%B9" target="_blank" rel="noopener">让-保罗·萨特 - 维基百科，自由的百科全书</a></p><h3 id="哲学理论和重要概念"><a href="#哲学理论和重要概念" class="headerlink" title="哲学理论和重要概念"></a>哲学理论和重要概念</h3><p>萨特的哲学是一种激进的自由意志主义。这种理论和决定论相对，认为人类有绝对的自由。“上帝已死”，尼采名言可以看作萨特哲学的一个基本前提。结果是人变成被抛弃。因为在人的身内身外，都无法找到依托的东西。人没有存在的理由。而如果确实是存在先于本质，人就不能用一种天生的现有的人性来解释自己的行动；也就是说，没有决定论。人是自由的。人就是自由。另一方面，如果上帝不存在，人就没有价值（<a href="/61.Philosophy/什么是价值/" title="什么是价值">什么是价值</a>）和戒律说明人的行为是正当的。没有价值领域。人孤寂独处，无可辩解。这就是萨特说“人是被判定为自由”时想要表达的意思。因为一个人并不是自愿存在于世的，然而一旦存在，他就是自由的；但同时他要对自己所做的一切负责。</p><p>参考自： <a href="https://zh.wikipedia.org/wiki/%E8%AE%A9-%E4%BF%9D%E7%BD%97%C2%B7%E8%90%A8%E7%89%B9#%E5%93%B2%E5%AD%A6%E7%90%86%E8%AE%BA%E5%92%8C%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener"></a></p><h4 id="虚无（Nothingness）"><a href="#虚无（Nothingness）" class="headerlink" title="虚无（Nothingness）"></a>虚无（Nothingness）</h4><p>“虚无”（nothingness）是人的意识作为“对己存有”（For-Itself）之根本特质，人在朝向未来，投射出理想的自我之时，他便不再只是当下的自己，这时，他从理想的状态回头看自己，而否定眼前的自己。</p><p>否定自己，就是将眼前的自己虚无化。但是，人们藉以否定当下状态的理想既然尚未实现，所以也是一种虚无。如此一来，人生彻头彻尾都由虚无所贯穿。然而，虚无不表示否定生命的意义。</p><p>相反地，萨特认为，这样才能肯定人之为人的意义。因为，假若人只是固定不变的物体，则他将任人摆布，这难道不是对人最大的否定吗？或许我们用“缺乏”（lack）来解释“虚无”的涵义会更为恰当。当人心中有个理想，因而对照出现状的种种缺失时，他就是处于一种“缺乏”（lack）的状态。</p><blockquote> <a href="/61.Philosophy/10.虚无主义/" title="10.虚无主义">10.虚无主义</a></blockquote><h4 id="自己创造自己"><a href="#自己创造自己" class="headerlink" title="自己创造自己"></a>自己创造自己</h4><p>@todo</p><h4 id="对他存有（Being-for-others）"><a href="#对他存有（Being-for-others）" class="headerlink" title="对他存有（Being-for-others）"></a>对他存有（Being-for-others）</h4><p>@todo</p><h4 id="存在者的五种处境"><a href="#存在者的五种处境" class="headerlink" title="存在者的五种处境"></a>存在者的五种处境</h4><p>@todo</p><h3 id="著作-2"><a href="#著作-2" class="headerlink" title="著作"></a>著作</h3><h4 id="《禁闭》"><a href="#《禁闭》" class="headerlink" title="《禁闭》"></a>《禁闭》</h4><blockquote><p>他人即地狱这出自萨特的剧本《禁闭》。剧本是非常典型的三一律，而场景是在地狱的一个房间中。<br>剧中三个主角都是身前犯有罪行的人，加尔散是个胆小绝，无耻的逃兵，伊内斯是同性恋，并且拥有强大欲望支配别人的心理变态，而艾丝黛儿是个沉浸于男人怀中的色情狂，同时也是一个狠毒的溺婴犯。<br>他们三个身前毫不相识的人，被狱卒陆续送到了这个密闭的房间。这个房间里没有镜子，这让三个角色都异常的抓狂。加尔散说“只要能照一下镜子，我什么都舍得拿出来。”艾丝黛儿说“当我不照镜子的时候，我摸自己也没用，我怀疑自己是否真的还存在。”没有镜子的密室，他们只能将互相当做镜子，从对方那里寻找到自己存在的证据。在这个没有酷刑的地狱，他们的折磨来自他们互相的关系。在这个没有黑夜的地狱，他们无时无刻不暴露在别人的目光中。<br>为了得到解脱和自由，他们开始试图去证明自己，去寻找自己存在的意义。<br>因此加尔散这个胆小鬼，要证明自己不是懦夫他开始试图说服充满强势力量的伊内斯，而伊内斯这个同性恋，她需要去支配别人，于是她将艾丝黛儿视为自己彰显支配力量的猎物。而艾丝黛儿她沉溺与男人的怀抱，她需要从加尔散这个密室中唯一的男人那里证明自己的魅力从而去满足她色情狂的心。他们三个人就像是旋转木马一样一直互相追逐，而在这样之中他人便自然的形成了地狱的酷刑。从而导致最后他们发出了”他人即地狱“的哀嚎。</p></blockquote><p>这样看来虽然不难让人理解 <strong>”他人即地狱”</strong> 的含义，但是却产生了许多误解。萨特曾说，许多人误解了他的意思，人们以为他所说的是人与人的关系已经坏透了，而且永远都是难以沟通的。但是他却不是这个意思。他想说的是人只有通过自我选择才能决定自我存在，只有通过自我选择才能获得自由。剧中的人物已经死了，他们不能再进行选择，而我们却可以。所以不管我们身处于何种地狱般的环境之中，我们都可以自由的去打碎它。所以，“他人即地狱”其实含有了多层含义。</p><p>1、若不能正确对待别人，那么他人便是地狱。<br>2、要正确对待他人对自己的判断，否则他人依旧是地狱。<br>3、如果不能正确的对待自己，你也可以变成自己的地狱。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="/61.Philosophy/10.虚无主义/" title="10.虚无主义">10.虚无主义</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>04.分析哲学</title>
      <link href="/61.Philosophy/04.%E5%88%86%E6%9E%90%E5%93%B2%E5%AD%A6/"/>
      <url>/61.Philosophy/04.%E5%88%86%E6%9E%90%E5%93%B2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>分析哲学（analytic philosophy）是现代西方哲学流派。认为传统哲学关于形而上学的思辨是没有意义的，主张哲学的任务在于“清思”，用尽可能客观的方法对语言进行逻辑分析，并阐明它们的意义。有广义、狭义之别。广义的，凡主张哲学的唯一任务在于“分析”（不管是哪一种分析）的，都可称为分析哲学。如英国穆尔的“概念分析”，逻辑原子论的“逻辑分析”，逻辑实证主义的“句法的”和“语义的”分析，牛津学派的“通常语言”的分析等便是。狭义的，专指第二次世界大战前后开始流行于英国的语言“通常用法”的分析学派或“语言哲学”学派。</p><p>谈论世界和谈论”谈论”<br>我们不能分析思想, 我们只能分析思想的表达, 即分析语言.</p><h2 id="弗雷格"><a href="#弗雷格" class="headerlink" title="弗雷格"></a>弗雷格</h2><p><a href="https://baike.baidu.com/item/%E5%BC%97%E9%9B%B7%E6%A0%BC" target="_blank" rel="noopener">弗雷格_百度百科</a></p><h2 id="罗素"><a href="#罗素" class="headerlink" title="罗素"></a>罗素</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%AF%E7%89%B9%E5%85%B0%C2%B7%E7%BD%97%E7%B4%A0" target="_blank" rel="noopener">伯特兰·罗素 - 维基百科，自由的百科全书</a></p><h2 id="维特根斯坦"><a href="#维特根斯坦" class="headerlink" title="维特根斯坦"></a>维特根斯坦</h2><p><img src="/images/哲学笔记/15544729895245.jpg" alt=""></p><p>路德维希‧约瑟夫‧约翰‧维特根斯坦（德语：Ludwig Josef Johann Wittgenstein；1889年4月26日－1951年4月29日）是一名奥地利哲学家。他生于奥地利，后入英国籍。维特根斯坦是20世纪最有影响力的哲学家之一，其研究领域主要在语言哲学、心灵哲学和数学哲学等方面。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>第一次世界大战开始后，本可免服兵役的维特根斯坦作为志愿兵积极入伍，在战场上完成了标志所谓哲学的语言学转向的 <strong>《逻辑哲学论》</strong> 的初稿。《逻辑哲学论》后他认为所谓的哲学问题已被解决，于是怀着贵族式的热忱前往奥地利南部山区，投入格律克尔倡导的奥地利学校改革运动，成为一名小学教师。有着理想主义追求的维特根斯坦在这里过着苦行僧般的生活，对学生也充满了热情，然而却被无法理解的家长们视为“疯狂的家伙”，他们拒绝了这个古怪家伙提出的收养其中一个或两个学生的要求。</p><p>1928年春在听了数学家布劳维尔在维也纳有关“数学、科学和语言”的一次讲演后，维特根斯坦重新萌发了强烈的哲学探索的兴趣。1929年，维特根斯坦重返剑桥，以《逻辑哲学论》作为论文，通过了由罗素和G.E.摩尔主持评审的博士答辩后，留在三一学院教授哲学，并于1939年接替摩尔成为哲学教授。1947年，坚信“哲学教授”是“一份荒唐的工作”的维特根斯坦从剑桥辞职，以专心思考、写作。</p><p>去世后由弟子安斯康姆和拉斯·里斯出版了被认为是引导了语言哲学新的走向的 <strong>《哲学研究》</strong>。维特根斯坦的一生极富传奇色彩，被罗素称为“天才人物的最完美范例”：富有激情、深刻、炽热并且有统治力。</p><blockquote><p>参考: <a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%B7%E7%BB%B4%E5%B8%8C%C2%B7%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6" target="_blank" rel="noopener">路德维希·维特根斯坦 - 维基百科，自由的百科全书</a></p></blockquote><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>维特根斯坦是 <strong>语言学派</strong>（大约相当于分析哲学）的主要代表人物。在西方哲学界，有人称他的哲学为上一世纪唯心主义哲学转变为本世纪分析哲学的“革命”；也有人称他是把现代哲学方法“推进到决定性转折的第一人”。</p><p>他的哲学主要研究的是语言。他想揭示当人们交流时，表达自己的时候到底发生了什么。他主张哲学的本质就是语言。语言是人类思想的表达，是整个文明的基础，哲学的本质只能在语言中寻找。他消解了传统形而上学的唯一本质，为哲学找到了新的发展方向。</p><h3 id="著作"><a href="#著作" class="headerlink" title="著作"></a>著作</h3><h4 id="《逻辑哲学论》"><a href="#《逻辑哲学论》" class="headerlink" title="《逻辑哲学论》"></a>《逻辑哲学论》</h4><p>让哲学成为语言学问题，哲学必须直面语言，“凡是能够说的事情，都能够说清楚，而凡是不能说的事情，就应该沉默”，哲学无非是把问题讲清楚</p><ul><li>世界是一切发生的事情。</li><li>发生的事情，即事实，就是诸事态[2]的存在。</li><li>事实的逻辑图像是思想。</li><li>思想是有意义的命题。</li><li>命题是基本命题的真值函项。</li></ul><h4 id="《哲学研究》"><a href="#《哲学研究》" class="headerlink" title="《哲学研究》"></a>《哲学研究》</h4><p>把哲学回归哲学，在解构之后是建构，创造一套严格的可以表述哲学的语言是不可能的，因为日常生活的语言是生生不息的，这是哲学的基础和源泉，所以哲学的本质应该在日常生活中解决，在“游戏”中理解游戏。</p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.德国古典哲学</title>
      <link href="/61.Philosophy/03.%E5%BE%B7%E5%9B%BD%E5%8F%A4%E5%85%B8%E5%93%B2%E5%AD%A6/"/>
      <url>/61.Philosophy/03.%E5%BE%B7%E5%9B%BD%E5%8F%A4%E5%85%B8%E5%93%B2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="德国古典哲学"><a href="#德国古典哲学" class="headerlink" title="德国古典哲学"></a>德国古典哲学</h1><h2 id="康德"><a href="#康德" class="headerlink" title="康德"></a>康德</h2><p><img src="/images/哲学笔记/15544724913854.jpg" alt=""></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>伊曼努尔·康德（德文：Immanuel Kant，公元1724年4月22日—公元1804年2月12日），<br>康德是启蒙运动时期最后一位主要哲学家，是德国思想界的代表人物。他调和了勒内·笛卡儿的理性主义与弗朗西斯·培根的经验主义，被认为是继苏格拉底、柏拉图和亚里士多德后，西方最具影响力的思想家之一。<br>康德有其自成一派的思想系统，并且有为数不少的著作，其中核心的三大著作被合称为“三大批判”，即《纯粹理性批判》、《实践理性批判》和《判断力批判》，这三部作品有系统地分别阐述他的知识学、伦理学和美学思想。《纯粹理性批判》尤其得到学术界重视，标志着哲学研究的主要方向由本体论转向认识论，是西方哲学史上划时代的巨著，被视为近代哲学的开端。此外，康德在宗教哲学、法律哲学和历史哲学方面也有重要论著。<br>康德哲学理论的一个基本出发点是，认为将经验转化为知识的理性（即“范畴”）是人与生俱来的，没有先天的范畴我们就无法理解世界。他的这个理论结合了英国经验主义与欧陆的理性主义，对德国唯心主义与浪漫主义影响深远。</p><blockquote><p>参考：<a href="https://zh.wikipedia.org/wiki/%E4%BC%8A%E6%9B%BC%E5%8A%AA%E5%B0%94%C2%B7%E5%BA%B7%E5%BE%B7" target="_blank" rel="noopener">伊曼努尔·康德 - 维基百科，自由的百科全书</a></p></blockquote><hr><p>康德凭借着他的三部“批判性”的著作，为先验方法作出相应的结构：</p><ul><li>分析论，分析理性的有效机能；</li><li>辨证论，展示理性的可能失误；</li><li>方法论，列举实用的各种规则。</li></ul><h3 id="哲学思想"><a href="#哲学思想" class="headerlink" title="哲学思想"></a>哲学思想</h3><h4 id="《纯粹理性批判》"><a href="#《纯粹理性批判》" class="headerlink" title="《纯粹理性批判》"></a>《纯粹理性批判》</h4><blockquote><p>《纯粹理性批判》要回答的问题是：我们能知道什么？康德的回答是：我们只能知道自然科学让我们认识到的东西，哲学除了能帮助我们澄清使知识成为可能的必要条件，就没有什么更多的用处了。自从柏拉图以来的哲学家把这个问题彻底给颠倒了。在此之前，人们让认识向外部事物看齐，而康德说，如果我们颠倒一下，让事物向我们的认识看齐，该会如何？于是康德认为客体必须按照主体的认识形式来形成知识。康德把这一思维方法与哥白尼的“日心说”相比较：哥白尼以前，人们认为一切星球围着我们地球转，哥白尼却说，我们地球是在围着其它星球转。</p></blockquote><hr><p>以下参考： <a href="https://zh.wikipedia.org/wiki/%E7%B4%94%E7%B2%B9%E7%90%86%E6%80%A7%E6%89%B9%E5%88%A4" target="_blank" rel="noopener">纯粹理性批判</a></p><p>康德在第二版序言，首先做出了一个假设：“不是知识符合对象，而是对象符合知识的先天认识形式”，这一新思路，就好像哥白尼从地心说转变成了日心说，康德称之为哲学界的“哥白尼式革命”。</p><p>康德提出了“先天综合判断”，“先天综合判断”这个概念来自于休谟综合命题与分析命题的区分。休谟认为分析命题是谓词包含在主词之中，比如“人都是会死的“，”死“包含在”人“这个概念之中，所以一切分析命题都是必然命题；综合命题的主词与谓词没有先天的逻辑关系，比如”人坐在椅子上“，休谟称之为偶然命题。康德为了寻求既是先天必然的，又对经验世界起作用的知识，增加了“先天综合判断”。康德不认为所有综合命题都是后天的，而一些先天的综合命题就是“先天综合判断”。</p><p><img src="/images/哲学笔记/15544734408543.jpg" alt=""></p><p>在导言中，康德提出了全书的总纲：纯粹理性的总任务是要解决“先天的综合判断”如何可能的问题；并按这总问题细分了以下的三个问题：<br>1.纯粹数学如何可能？<br>2.纯粹自然科学如何可能？<br>3.形而上学作为科学如何可能？</p><p>康德把全书大致的分为了五部分：“1.先验感性论，2.先验逻辑论，3.先验分析论，4.先验辩证论，5.先验方法论”</p><ul><li><p>先验感性论：<br>“先验感性论”主要是阐明，只有通过人的感性知识(接受能力)所先天具有的直观形式即“空间”和“时间”两大要素去整理自在之物（的表象即现象界）刺激感官的感觉材料，才能获得确定的感性知识，同时，空间和时间也是数学知识的先天直观形式。</p></li><li><p>先验逻辑论：<br>“先验逻辑论”的阐明“感性必须与知性结合，直观必须与思维结合，才能产生自然科学的知识”，因而必须有一门不同于形式逻辑的先验逻辑来探讨知性的结构及其运用于经验对象时的各种原理。先验逻辑立足于知识与对象的关系，即知识的内容，而不是单纯的思维形式，这标著辩证逻辑在近代的萌芽。</p></li><li><p>先验分析论：<br>“先验分析论”（真理的逻辑）阐明了知性的先天概念和先天原理是自然科学之所以可能的根据和条件。在概念分析论中，通过对知性判断中的逻辑机能的分析。而先验分析论当中的原理分析论主要阐明了知性指导判断力把范畴运用于现象的法规。</p></li><li><p>先验辩证论：<br>“先验辩证论”（幻相的逻辑）主要阐明了理性不可避免地要超越现象去认识的本体，由此产生的作为自然倾向的形而上学只不过是一些先验的幻相，而不可能是真正的科学。康德在先验辩证论的导言之中指出，理性这种推广能力由于要从有条件者出发通过推论去认识无条件者。</p></li><li><p>先验方法论：<br>先验方法论首先阐明，纯粹理性的经验使用虽然有正确的使用法规（知性的先更原理），但其理论的（思辨的、先验的）奥用却没有法规可言，因而必须对其先验使用方法(从定义出发的独断论、从正反两方争辩并互相证伪怀疑论方法、还有假设和证明的的方法等四个方面)加以训练，确立一些“消极的”规则，以限制纯粹理性的扩充到可能经验之外的倾向，从而为建立一种有关经验的形而上学准备了方法论的原则。</p></li><li><p>知识论要义与其他：<br>虽然康德使用的是批判哲学，他本人却建立起一套完整的哲学理论。他本人自称发动了一场哲学领域内的哥白尼革命。在康德所处的时代，欧洲哲学思想主要有两种重要理论：由约翰·洛克、大卫·休谟等人发展出来的经验主义，以及笛卡儿等人的理性主义。经验主义者认为人类对世界的认识与知识来源于人的经验，而理性主义者则认为人类的知识来自于人自身的理性。<br>而康德则在一定程度上接合了两者的观点。康德认为知识是人类同时透过感官与理性得到的。经验对知识的产生是必要的，但不是唯一的要素。把经验转换为知识，就需要理性（康德与亚里士多德一样，将这种理性称为“范畴”），而理性则是天赋的。人类通过范畴的框架来获得外界的经验，没有范畴就无法感知世界。因此范畴与经验一样，是获得知识的必要条件。但人类的范畴中也有一些可以改变人类对世界的观念的因素，他意识到，事物本身与人所看到的事物是不同的，人永远无法确知事物的真正面貌。</p></li></ul><h4 id="《实践理性批判》"><a href="#《实践理性批判》" class="headerlink" title="《实践理性批判》"></a>《实践理性批判》</h4><blockquote><p>《实践理性批判》是康德的前一部著作《纯粹理性批判》的归宿和目的。所谓“实践理性”，是指实践主体的意志，对于实践理性的“批判”，就是要考察那规定道德行为的“意志”的本质以及它们遵循的原则。全书包括“纯粹实践理性的原理论”和“纯粹实践理性的方法论”两大部分。该书的重要理论意义在于，它把人的主体性问题突出出来，强调了人格的尊严与崇高，表现了强烈的人本主义精神。</p></blockquote><p>  伦理学方面，康德否定意志受外因支配的说法，而是认为意志为自己立法，人类辨别是非的能力是与生俱来的，而不是从后天获得。这套自然法则是无上命令，适用于所有情况，是普遍性的道德准则。康德认为真正的道德行为是纯粹基于义务而做的行为，而为实现某一个个人功利目的而做事情就不能被认为是道德的行为。因此康德认为，一个行为是否符合道德规范并不取决于行为的后果，而是采取该行为的动机。<br>  康德还认为，只有当我们遵守道德法则时，我们才是自由的，因为我们遵守的是我们自己制定的道德准则，而如果只是因为自己想做而做，则没有自由可言，因为你就成为各种事物的奴隶。</p><h4 id="《判断力批判》"><a href="#《判断力批判》" class="headerlink" title="《判断力批判》"></a>《判断力批判》</h4><blockquote><p>《判断力批判》要回答的问题是：我们可以抱有什么希望？康德给出的答案是：如果要真正能做到有道德，我就必须假设有上帝的存在，假设生命结束后并不是一切都结束了。“判断力批判”中，康德关心的问题还有人类精神活动的目的、意义和作用方式，包括人的 <strong>美学鉴赏能力</strong> 和 <strong>幻想能力</strong> 。</p></blockquote><h2 id="黑格尔"><a href="#黑格尔" class="headerlink" title="黑格尔"></a>黑格尔</h2><p><img src="/images/哲学笔记/15544730896874.jpg" alt=""></p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>格奥尔格·威廉·弗里德里希·黑格尔（德语：Georg Wilhelm Friedrich Hegel，常缩写为G. W. F. Hegel；公元1770年8月27日—公元1831年11月14日），德国哲学家。</p><p>许多人认为，黑格尔的思想，标志着19世纪德国唯心主义哲学运动的顶峰，对后世哲学流派，如存在主义和马克思的历史唯物主义都产生了深远的影响。更有甚者，由于黑格尔的政治思想兼具自由主义与保守主义两者之要义，因此，对于那些因看到自由主义在承认个人需求、体现人的基本价值（<a href="/61.Philosophy/什么是价值/" title="什么是价值">什么是价值</a>）方面的无能为力，而觉得自由主义正面临挑战的人来说，他的哲学无疑是为自由主义提供了一条新的出路。</p><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><h4 id="国家观"><a href="#国家观" class="headerlink" title="国家观"></a>国家观</h4><p>他的国家概念指的不是现存的国家制度，而是精神的国家理念。现实的国家只是国家理念的表现。国家的本质在于它是伦理理念的现实，是绝对自在自为的理性的东西。黑格尔对国家与社会进行了区分，市民社会是外在的国家，是主观意志、个人利益的结合形式。国家以它至高无上的意志、伦理精神把整个民族凝聚为一个有机的统一体。国家先于并高于家庭、市民社会，是它们存在的前提，是决定的力量，是人类生活的最高形式。它是自我与他人、个人与社会、特殊利益与普遍利益的统一。个人只是国家的一些环节，生活在国家中，才能获得个人的人格、自由和价值。黑格尔对德国古典哲学中整体国家观的倾向给予充分发挥，表明了他对古希腊以伦理和整体为特征的城邦国家观的崇尚。</p><h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4><p>黑格尔在18世纪末至19世纪初的哲学中提出了辩证发展的理论。他的发展和变化的学说对于辩证法的形成起了很大的作用。黑格尔的辩证法认为整个历史和精神的世界是一个过程，就是说，是在不断的地运动着，变化着，发展着和改造着的。同时过程内部的矛盾是事物自身运动和发展的源泉。黑格尔把辩证法应用到关于概念，判断的学说上，应用到认识的逻辑上。</p><p>黑格尔历来同其他曾抱有稍类似的形而上学观点的人有两点区别。一点是强调逻辑：实在的本性从它必须不自相矛盾这个唯一的考虑就能推演出来。另一个（与第一点密切相关的）区别特征是称作辩证法的三元运动。他的最重要的著作是两部《逻辑学》（Logic），要想正确理解他对其它问题的见解的依据，这两部书不可不懂。逻辑照黑格尔的理解，他明确地说和形而上学是一回事；那是一种跟普通所说的逻辑完全不同的东西。</p><p>他的看法是：任何平常的谓语，如果把它认作是限定“实在”全体的，结果它就是自相矛盾的。我们不妨举巴门尼德的学说：唯一实在的“太一”是球状的，作为一个粗浅的实例。任何东西如果没有边界便不会是球状的，而除非它外部有什么（至少有虚空间），它才可能有边界。因此，假定整个宇宙是球状的，便自相矛盾。（如果把非欧几里得几何抬出来，对这个议论未尝不可以有异议，但是这议论作为一个说明例子，也算可用。）</p><p>以上黑格尔观点类似于康德的二律背反。用以说明实在事物的内在矛盾性。并且这种矛盾性永恒存在，而结实这种存在的矛盾只能运用形而上学，即解释为绝对的“精神”，亦或是康德所说的“物自体”</p><h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4><p>认识作为整体看，具有三元运动。认识始于感官知觉，感官知觉中只有对客体的意识。然后，通过对感觉的怀疑批判，认识成为纯主体的。最后，它达到自认识阶段，在此阶段主体和客体不再有区别。所以自意识是认识的最高形态。当然，在黑格尔的体系中必得如此，因为最高一种的认识一定要是“绝对”所具有的认识，既然“绝对”是 “全体”，所以在它自身之外再没有任何东西要它认识了。<br>依黑格尔的意见，在最好的思维中，思想变得通畅无阻，水乳交融。真和假并不像普通所想的那样，是判然分明的对立物；没有任何事物是完全假的，而我们能够认识的任何事物也不是完全真的。“我们能够多少有些错误地去认识”；我们将绝对真理归于某一件孤离知识时便发生这种情况。像“凯撒是哪里出生的？”这种问题，有一个直截了当的答案，这答案从某个意义上说是真的，但是在哲学的意义上不真。按哲学讲， “真理就是全体”，任何部分事物都不十分真。<br>黑格尔说：“理性即对全部实在这种有意识的确信。”这并不是说分立的人是全部实在；就他的分立性来说，他不是十分实在的，但是他的实在处在于他参与整体的“实在”。随着我们变得日益理性，这种参与也相应地增大。<br>《逻辑学》末尾讲的“绝对理念”，是一种像亚里士多德的“神”似的东西。绝对理念是思维着自身的思想。很明显，“绝对”除思维自身而外什么也不能思维，因为除对我们理解“实在”的偏狭错误的方式而言外，不再有任何旁的东西。据他说，“精神”是唯一的实在，它的思想借自意识向自身中映现。定义“绝对理念”的实际原话非常晦涩。瓦勒斯译之如下：绝对的理念的统一，就是理念的概念，这概念以理念的本身作为对象，而且从这一概念看来，客观世界即是一理念——在这客观世界里一切规定均统一起来了（德文原文更难懂）。</p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>02.西方哲学史</title>
      <link href="/61.Philosophy/02.%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8F%B2/"/>
      <url>/61.Philosophy/02.%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="西方哲学史"><a href="#西方哲学史" class="headerlink" title="西方哲学史"></a>西方哲学史</h1><p><strong>西方哲学不同时代主要关注对象：</strong></p><ul><li>古代哲学: 本体论（Ontology）是探究世界的本原或基质的哲学理论，“存在”，物质的存在与精神存在之间的区别</li><li>近代哲学: 认识论（epistemology）, 康德: 对理性认识能力的考察。认识论即个体的知识观，也即个体对知识和知识获得所持有的信念，主要包括有关知识结构和知识本质的信念和有关知识来源和知识判断的信念，以及这些信念在个体知识建构和知识获得过程的调节和影响作用，长久以来一直是哲学研究的核心问题。</li><li>现代哲学: 语言哲学(弗雷格Frege~维特根斯坦)</li></ul><p><strong>附-极简欧洲史：</strong></p><blockquote></blockquote><ul><li>古典时代： 古希腊、古罗马</li><li>中世纪： 5世纪西罗马帝国灭亡~1453年东罗马帝国灭亡（君士坦丁堡陷落）</li><li>近代<ul><li>文艺复兴： 13xx~16xx（14~17世纪）</li><li>宗教改革：</li><li>启蒙运动：16xx~17xx（17-18世纪）</li></ul></li><li>现代<ul><li>工业革命：1765~1844（18世纪60年代~19世纪）</li><li>政治革命：1848~</li><li>一战/二战：1914~1945</li></ul></li></ul><h2 id="西方哲学系谱图（整理）"><a href="#西方哲学系谱图（整理）" class="headerlink" title="西方哲学系谱图（整理）"></a>西方哲学系谱图（整理）</h2><h3 id="①古希腊罗马哲学（BC6-世纪-AD4-世纪）"><a href="#①古希腊罗马哲学（BC6-世纪-AD4-世纪）" class="headerlink" title="①古希腊罗马哲学（BC6 世纪 ~ AD4 世纪）"></a>①古希腊罗马哲学（BC6 世纪 ~ AD4 世纪）</h3><p>古希腊罗马哲学包括自然哲学、形而上学和伦理哲学三个阶段，为西方哲学的理性思辨和形而上学打下了传统根基。它提出了逻辑、存在、实体等成为西方哲学的经典命题，而柏拉图和亚里士多德关于共相性质的争论开启了中世纪基督教哲学关于唯名论和实在论的争论。</p><blockquote><ul><li>苏格拉底代表论著：《克堤拉斯篇》《泰阿泰德篇》《智士篇》《政治家篇》</li><li>柏拉图代表论著：《对话录》《理想国》《柏拉图对话集》</li><li>亚里士多德代表论著：《工具论》《物理学》《形而上学》《伦理学》《政治学》</li><li>欧几里得：《几何原本》</li><li>恩培多克勒：《论自然》《论净化》</li></ul></blockquote><p><img src="/images/哲学笔记/15512504150216.jpg" alt=""></p><h3 id="②中世纪基督教哲学（4-世纪-14-世纪）"><a href="#②中世纪基督教哲学（4-世纪-14-世纪）" class="headerlink" title="②中世纪基督教哲学（4 世纪 ~ 14 世纪）"></a>②中世纪基督教哲学（4 世纪 ~ 14 世纪）</h3><p>中世纪哲学指的是西欧和中东在中世纪的哲学体系，其时间范围没有定论，大致上是从基督化的罗马帝国时期至文艺复兴时期。<br>西罗马帝国崩溃后，基督教成为西欧不可侵犯的绝对意识形态，哲学成为“神学的婢女”，被基督教信仰的浓重阴影所笼罩。从教父哲学（柏拉图-奥古斯丁体系）到经院哲学（亚里士多德-阿奎那体系）的过渡反应了希腊罗马理性精神的复苏，而唯名论和实在论的对立为近代理性主义和经验论的兴起开辟了道路。</p><blockquote><p>时间推进到中世纪，随着天主教的教会力量进入统治阶级，其神职人员开始将古希腊的哲学思想与宗教相结合，产生了经院哲学。经院哲学将萌芽期的自然科学和天主教的神学通过古希腊哲学的思想融合在一起。上帝成了至高无上的存在，这个世界都是上帝的造物，太阳是为了给大地带来光明，大地是为了生长草木，植物是为了饲养动物，而作为天主照自己肖像造的人，则是为了能认识及爱慕自己的造物主，在天主恩宠中过世的人则可以升入永恒的天堂。</p></blockquote><ul><li>奥古斯丁代表论著：《忏悔录》《论三位一体》《上帝之城》《论自由意志》《论美与适合》</li><li>阿奎纳代表论著：《神学大全》《论君主政治》《反异教大全》《亚里士多德（政治学）诠释》</li><li>威廉·奥卡姆代表论著：《逻辑大全》《辩论集7篇》</li></ul><p><img src="/images/哲学笔记/15512504469699.jpg" alt=""></p><h3 id="③近代早期西欧哲学（14-世纪-18-世纪）"><a href="#③近代早期西欧哲学（14-世纪-18-世纪）" class="headerlink" title="③近代早期西欧哲学（14 世纪 ~ 18 世纪）"></a>③近代早期西欧哲学（14 世纪 ~ 18 世纪）</h3><p>西方哲学史上的近代早期一般指17世纪和18世纪，其中18世纪常被称为启蒙时代。现代哲学不同于其前身，它和传统权威例如教会、学院、亚里士多德的关系更加独立，出现了对知识基础和形而上学体系建设的新兴趣；和摆脱了自然哲学的近代物理学的出现。从17世纪开始，近代哲学就以认识论为研究重点。由于经验论（经验主义）与唯理论（理性主义）的争论，使物质与精神的关系作为认识论的首要问题突显出来。<br>近代早期西欧哲学从文艺复兴和宗教改革运动开始，演化出欧陆唯理论同不列颠经验论的对立，其核心是理性反思和对经验（外在或内在）的重视。唯理论演变成莱布尼茨-沃尔夫体系中的独断论，而经验论则在休谟那里成为彻底的怀疑主义，这为法兰西启蒙思想和德意志古典哲学的出现埋下了伏笔。</p><blockquote><p>进入16世纪，随着宗教改革文艺复兴启蒙运动，人文主义开始颠覆天主教会的统治。经验主义和理性主义从实证和思考两个方向对经院哲学发起挑战。经验主义方向上，从伽利略到牛顿等人逐渐建设起自然哲学并与狭义的哲学开始分离，成为日后的自然科学。理性主义则随着笛卡尔的“我故我在”开始重新推演上帝的存在与否。近代哲学中经验主义主张知识只能通过人的感官经验来获得，而理性主义主张知识独立于感官经验之外由人的理性通过推理获得。经验主义和理性主义的发展让认识论成为近代哲学的主题。随着康德在《纯粹理性批判》中将经验主义和理性主义进行融合和批判，近代哲学开始收束，并归结于黑格尔。</p></blockquote><ul><li>莱布尼茨代表论著：《神义论》《单子论》《论中国人的自然神学》</li><li>沃尔夫代表论著：《关于人类理智能力的理性思想》《关于上帝、世界及人的灵魂的理性思想》（讲演“中国的实践哲学”，1721）</li><li>休谟代表论著：《人性论》《道德原则研究》《人类理解研究》《宗教的自然史》</li></ul><p><img src="/images/哲学笔记/15512504691465.jpg" alt=""></p><h3 id="④法兰西启蒙思想和唯物主义（18-世纪）"><a href="#④法兰西启蒙思想和唯物主义（18-世纪）" class="headerlink" title="④法兰西启蒙思想和唯物主义（18 世纪）"></a>④法兰西启蒙思想和唯物主义（18 世纪）</h3><p>18世纪法国哲学包括法国自然神论和唯物主义两块，探讨的核心问题是人与自然的关系，理论上则表现为思维和存在的关系。法国自然神论奠定了西方政治学的基础，而激进的卢梭则引导了后世批判哲学（马克思和尼采）的出现。法国唯物主义者否定自由意志，但推崇人的理性，使理性主义成为法国哲学鲜明的特点。</p><blockquote><ul><li>伏尔泰代表论著：《哲学通信》《形而上学论》</li><li>孟德斯鸠代表论著：《论法的精神》</li><li>卢梭代表论著：《论人类不平等的起源和基础》《社会契约论》《爱弥儿》《忏悔录》</li></ul></blockquote><p><img src="/images/哲学笔记/15512504945124.jpg" alt=""></p><h3 id="⑤德意志古典哲学（1770-1844）"><a href="#⑤德意志古典哲学（1770-1844）" class="headerlink" title="⑤德意志古典哲学（1770 ~ 1844）"></a>⑤德意志古典哲学（1770 ~ 1844）</h3><p>从18世纪中后期开始，直到19世纪初，哲学便进入了近代哲学的总结时期，这就是德国古典哲学时期。有两条线索标志着转折的到来：一、思维与存在的关系更加明确；二、产生了系统辩证法。其代表人物有I.康德、J.G.费希特、F.W.谢林、G.W.F.黑格尔等。<br>德意志古典哲学体系的出现标志着传统西方哲学的最高成就。它将考察重点转向主体与客体的关系，实现了西方哲学继亚里士多德形而上学体系之后的第二次飞跃。康德通过对自在之物和现象的严格区分，发展出认识论的先验（<a href="/61.Philosophy/先验与后验/" title="先验与后验">先验与后验</a>）自我意识统摄机能和道德实践领域的纯粹理性，以及沟通两者的判断力批判。黑格尔通过辩证法三段论将整个世界容纳在绝对精神从自在状态过渡到自为状态，最终达成绝对理性自我意识的宏大历史过程。因此，黑格尔成为最后一个形而上学大体系，并引发费尔巴哈和马克思对其的反思。</p><blockquote><ul><li>康德代表论著：《纯粹理性批判》《实践理性批判》《判断力批判》</li><li>黑格尔代表论著：《精神现象学》《逻辑学》《哲学科学全书纲要》《法哲学原理》</li></ul></blockquote><p><img src="/images/哲学笔记/15512505169403.jpg" alt=""></p><h3 id="⑥过渡时期-19世纪（1844-1900）"><a href="#⑥过渡时期-19世纪（1844-1900）" class="headerlink" title="⑥过渡时期-19世纪（1844 ~ 1900）"></a>⑥过渡时期-19世纪（1844 ~ 1900）</h3><p>从19世纪中叶开始，西方哲学就进入现代哲学阶段。因为在19世纪中期，欧洲的工业革命几近完成。</p><p>现代哲学，特别是19世纪中后期的哲学流派，有叔本华的意志主义，新康德主义，新黑格尔主义，马克思主义。<br>然而此时的哲学与后来的存在主义、现象学等在当代一般归为“欧陆哲学”，与二十世纪以后着重严谨逻辑与语词分析所发展出的“分析哲学”（<a href="/61.Philosophy/04.分析哲学/" title="04.分析哲学">04.分析哲学</a>）成为风格迥异的两大西方哲学典范。</p><ul><li><p>唯意志主义：该潮流在费希特和谢林的学说下，又经过康德以及黑格尔的影响，终于由叔本华所注意到其中尚未被探索的领域——人类生命和一切生命基本特性的东西，即是“意志”。<br>而尼采也有所谓的“权力意志”这种学说，一种关于生命与世界的与叔本华类似的诠释。但，尼采对其进行彻底的改革，有“对所有价值（<a href="/61.Philosophy/什么是价值/" title="什么是价值">什么是价值</a>）重新作出评价”的论述。将其大胆的心理概括传统从宗教、艺术到道德、社会，再到科学和认识本身。</p></li><li><p>黑格尔主义：从G.W.F.黑格尔思想体系发展出来的庞大哲学运动。<br>K.马克思的著作本身不能说成是一种哲学，更不是一种哲学体系，但他的全部论述是对哲学，特别是对黑格尔体系中的唯心主义进行的激进批判。他认为哲学必须变成现实，人就不能在只是解释世界，必须即改造世界本身，有改造人对世界的认识。但是尽管马克思本人批判黑格尔的观念论，但其思想却深受黑格尔的特别是辨证论的影响。并将其基本本质作了自然主义的改造。这之后，从19世纪末期到20世纪初期，马克思的哲学思想才在恩格斯、普列汉诺夫和列宁等人的阐释和补充下，为辩证唯物论和历史唯物论，并形成新的世界观。</p></li></ul><p>过渡时期代表人物及论著：</p><blockquote><ul><li>叔本华：《作为意志和表象的世界》</li><li>尼采：《权力意志》《悲剧的诞生》《查拉图斯特拉如是说》《希腊悲剧时代的哲学》《论道德的谱系》</li><li>马克思：《资本论》《共产党宣言》《关于费尔巴哈的提纲》《1844年经济学哲学手稿》</li></ul></blockquote><p><img src="/images/哲学笔记/15512505427703.jpg" alt=""></p><h3 id="⑦现代哲学-20世纪"><a href="#⑦现代哲学-20世纪" class="headerlink" title="⑦现代哲学-20世纪"></a>⑦现代哲学-20世纪</h3><p>进入20世纪，西方哲学上主流有两条：</p><ul><li>一、由弗雷格、罗素创立的，并以维特根斯坦为主的分析哲学（<a href="/61.Philosophy/04.分析哲学/" title="04.分析哲学">04.分析哲学</a>）。它把哲学问题变成语言分析问题，由此产生了逻辑经验主义或逻辑实证主义以及其他语言分析相关的哲学派系。</li><li>二、由胡塞尔创立的现象学发展起来，以海德格尔为主的存在主义。它把哲学问题变成对个人生存状态的反思，由此产生了解释学。</li></ul><p><strong>附表-德意志古典哲学~过渡时期~现代哲学代表人物：</strong></p><table><thead><tr><th>时代</th><th>理论</th><th>人物</th><th>流派</th></tr></thead><tbody><tr><td>工业革命</td><td>唯心主义</td><td>康德（1724~1804）</td><td>德意志古典哲学</td></tr><tr><td></td><td>客观唯心主义</td><td>黑格尔（1770~1831）</td><td>德意志古典哲学</td></tr><tr><td></td><td>唯意志主义</td><td>叔本华（1788~1860）</td><td>欧陆哲学</td></tr><tr><td>政治革命</td><td>唯意志主义</td><td>尼采（1844~1900）</td><td>欧陆哲学</td></tr><tr><td></td><td>唯物主义</td><td>费尔巴哈（1804~1872）</td><td></td></tr><tr><td></td><td>唯物主义</td><td>马克思（1818~1883）</td><td></td></tr><tr><td>一战二战</td><td>逻辑实证主义</td><td>弗雷格（1848~1925）</td><td>分析哲学</td></tr><tr><td></td><td>逻辑实证主义</td><td>罗素（1872~1970）</td><td>分析哲学</td></tr><tr><td></td><td>逻辑实证主义</td><td>维特根斯坦（1889~1951）</td><td>分析哲学</td></tr><tr><td></td><td>存在主义</td><td>海德格尔（1889~1976）</td><td></td></tr><tr><td></td><td>存在主义</td><td>萨特（1905~1980）</td><td></td></tr><tr><td></td><td>存在主义</td><td>加缪（1913~1960）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.哲学简介</title>
      <link href="/61.Philosophy/01.%E5%93%B2%E5%AD%A6%E7%AE%80%E4%BB%8B/"/>
      <url>/61.Philosophy/01.%E5%93%B2%E5%AD%A6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="哲学简介"><a href="#哲学简介" class="headerlink" title="哲学简介"></a>哲学简介</h1><blockquote><p>大部分哲学研究的基本内容可以归纳为本体论认识论和方法论。<br>本体论探寻的是这个世界最根本的东西是什么，WHAT；<br>认识论探究的是人的意识如何理解这个世界，WHY；<br>方法论探讨的是人的意识如何作用于世界，HOW。<br>作用于个人的话，那就是门卫三问，你是谁，从哪里来，到哪里去。</p></blockquote><p>以下参考自: <a href="https://zh.wikipedia.org/wiki/哲学" target="_blank" rel="noopener">哲学 - 维基百科，自由的百科全书</a></p><h2 id="词源"><a href="#词源" class="headerlink" title="词源"></a>词源</h2><p>英语词语<code>Philosophy</code>（拉丁语：philosophia）源于古希腊语中的<code>φιλοσοφία</code>，意思为“爱智慧”，有时也译为“智慧的朋友”，该词由φίλος（philos，爱）的派生词φιλεῖν（Philein，去爱）和σοφία（Sophia，智慧）组合而成。一般认为，古希腊思想家毕达哥拉斯最先在著作中引入“哲学家”和“哲学”这两个术语。</p><p>“哲”一词在中国起源很早，如“孔门十哲”，“古圣先哲”等词，“哲”或“哲人”，专指那些善于思辨，学问精深者，即西方近世“哲学家”，“思想家”之谓。在《易经》当中已经开始讨论哲学问题，形而上学的中文名称取自《易经·系辞上传》“形而上者谓之道，形而下者谓之器”一语。1874年，日本启蒙家西周，在《百一新论》中首先用汉文“哲学”来翻译<code>philosophy</code>一词</p><h2 id="哲学是什么"><a href="#哲学是什么" class="headerlink" title="哲学是什么"></a>哲学是什么</h2><p>对哲学的主题亦存在许多看法。一些人认为哲学是对问题本身过程的审查；另外一些人则认为实质上存在着哲学必须去回答的哲学命题。</p><ul><li>哲学所涉及的研究范畴是其它学科的总和，它给出对世界本质的解释，在很大程度上影响着接受者的世界观。</li><li>哲学是研究范畴及其相互关系的一门学问。范畴涉及到一门学科的最基本研究对象、概念和内容，哲学具有一般方法论的功能。</li><li>哲学和其他承述问题方法的差异是有批判性的、有条理的方法以及以理性为基础的辩论。</li><li>后现代主义把哲学定义为创造概念的学术。</li></ul><h2 id="研究基础"><a href="#研究基础" class="headerlink" title="研究基础"></a>研究基础</h2><p>古希腊哲学家透过问问题来进行哲学实践，他们所提的问题大概可以归类为三类，这三类问题分别形成了哲学的基础学科——分别是 <strong>形而上学</strong>、<strong>伦理学</strong>、<strong>认识论</strong>（或知识论）</p><h3 id="哲学基本问题"><a href="#哲学基本问题" class="headerlink" title="哲学基本问题"></a>哲学基本问题</h3><p>所谓 <strong>哲学基本问题</strong> 是一个马克思主义哲学中的术语，又称哲学根本问题或哲学最高问题。<br>恩格斯于1886年在《费尔巴哈与德国古典哲学的终结》中，第一次明确提出全部哲学的基本问题 “全部哲学,特别是近代哲学的重大的基本问题，是思维和存在的关系问题。”。他认为哲学的基本问题有两个方面：</p><ul><li>思维和存在的第一性问题，即何者为本原的问题；</li><li>思维和存在的同一性问题，即思维能否正确认识存在的问题。</li></ul><p>换言之，就是意识和物质之间的关系问题，根据对这个问题的不同回答而形成唯心主义哲学和唯物主义哲学两大对立派别。</p><h2 id="哲学分支"><a href="#哲学分支" class="headerlink" title="哲学分支"></a>哲学分支</h2><p>哲学家对哲学的不同理解，遂形成了很多不同的 <strong>主要分支</strong>：</p><ol><li>形而上学：（英语：Metaphysics）是指研究存在和事物本质的学问。形而上学是哲学研究中的一个范畴，被视为“第一哲学”和“哲学的基本问题”。它指通过理性的推理和逻辑去研究不能直接透过感知所得到答案的问题，它是人类理性对于事物最普遍的面相和终极的原因的探索的一门学科。<blockquote><p>形而上学的主要问题包括：根本上有什么存在？（What is ultimately there?）它是什么样的？（What is it like?）</p></blockquote></li><li>逻辑学：怎样产生正确的思想？我什么时候能够确定的说一个东西没有意义？ 怎样批判的思考复杂的争论？</li><li>知识论：知识论是探讨知识的本质、起源和范围的一个哲学分支。<blockquote><p>世界可以被认知么？我们怎么确定我们知道？我们怎知道别的思维存在？</p></blockquote></li><li>伦理学/价值论： （英语：Ethics 或 Moral Philosophy）也称为道德哲学或道德学，是对人类道德生活进行系统性思考和研究的学科；在此，“道德”被定义为一群人或一种文化所认可的所有行为准则。伦理学试图从理论层面建构一种指导行为的法则体系，并且对其进行严格的评判。</li><li>美学： （英语：aesthetics），是以对美的本质及其意义的研究为主题的学科。<blockquote><p>什么是艺术？什么是美？任何事情都是美的么？品位有没有标准？艺术是有含义的么？如果是，它有什么含义。什么是好的艺术？艺术有目的么，还是“为了艺术而 艺术”？我们和艺术有什么联系？艺术怎样影响我们？有些艺术是否不道德？艺术有极限么？艺术会腐蚀社会么？会改良社会么？艺术家真的知道他们作品的内容 么？比如说，一个演员演美国总统，他会知道做总统相关的所有的事情么？艺术都是模仿么？在模仿过程中会有什么损失或获得么？所有的东西都是原创的么？</p></blockquote></li></ol><blockquote><p><a href="https://zh.wikipedia.org/wiki/Portal:%E5%93%B2%E5%AD%A6/%E5%88%86%E6%94%AF" target="_blank" rel="noopener">主题:哲学/分支 - 维基百科，自由的百科全书</a></p></blockquote><h2 id="哲学历史"><a href="#哲学历史" class="headerlink" title="哲学历史"></a>哲学历史</h2><p>=&gt; <a href="/61.Philosophy/02.西方哲学史/" title="02.西方哲学史">02.西方哲学史</a></p>]]></content>
      
      
      <categories>
          
          <category> 61.Philosophy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>户外露营</title>
      <link href="/54.Trips-and-Exploration/%E6%88%B7%E5%A4%96%E9%9C%B2%E8%90%A5/"/>
      <url>/54.Trips-and-Exploration/%E6%88%B7%E5%A4%96%E9%9C%B2%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.zhihu.com/question/43389258/answer/1881196041" target="_blank" rel="noopener">户外野营的神级装备有哪些？ - 知乎</a></li><li><a href="https://sspai.com/post/75980" target="_blank" rel="noopener">户外不完全吃饱指南 - 少数派</a></li></ul><h2 id="雪拉杯"><a href="#雪拉杯" class="headerlink" title="雪拉杯"></a>雪拉杯</h2><p>我们常说的雪拉杯或者塞拉杯，全称是 Sierra cup，是美国十分著名的户外环境组织雪拉俱乐部(Sierra Club)的周边产品，其使用最早可以追述到1905年</p><p><img src="/images/Sierra-cup.png" alt="../_images/Sierra-cup.png"></p><p>1、起源</p><p>它的起源与加利福尼亚的锡耶拉有关，最早可以追溯到20世纪初，是美国最大、历史最久、最有影响力的草根环境保护组织“塞拉俱乐部”的周边产品。在物资匮乏的年代，“塞拉杯”凭借其低廉的价格、实用性&amp;便携性，在户外界迅速火了起来。如果你是历史迷，那么同样会喜欢这款杯子！</p><p>2、荒野的象征</p><p>在鼓励人们去户外的时代，塞拉杯被认为是背包客&amp;攀岩爱好者的“理想之杯”，也得到了普及。随着时代的进步，越来越多的人越来越多的人意识到“保护荒野”的重要性以及其内在价值。</p><p>推荐品牌：Cook’n’Escape</p><h2 id="克米特椅"><a href="#克米特椅" class="headerlink" title="克米特椅"></a>克米特椅</h2><p>Kermit Chair</p><p><img src="/images/Kermit-Chair.png" alt="../_images/Kermit-Chair.png"></p>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LAME.阿根廷 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/LAME.%E9%98%BF%E6%A0%B9%E5%BB%B7/"/>
      <url>/54.Trips-and-Exploration/LAME.%E9%98%BF%E6%A0%B9%E5%BB%B7/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www.lvmama.com/trip/show/263115" target="_blank" rel="noopener">阿根廷的国茶——马黛茶</a></li><li>博尔赫斯：<ul><li>“天堂应该是图书馆的模样”，圣菲大道上的雅典人书店位于大道1860号，由原先的光明剧院改造而成，店内设有博尔赫斯专区，他的处女诗集《布宜诺斯艾利斯的激情》被置放在一个显眼的位置上，仿若诗人独自站立在舞台中央。@ref: <a href="https://share.nctvcloud.com/folder257/folder649/2020-11-18/1l5mw6L3lbHc9s2J.html" target="_blank" rel="noopener">卢桢：在布宜诺斯艾利斯的城市深处，寻找博尔赫斯</a></li><li>博尔赫斯纪念馆：布宜诺斯艾利斯-Adrogue镇  //关于博尔赫斯， @ref: [[../64.Novel-and-Poesy/S01.博尔赫斯]]</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EURO.意大利 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/EURO.%E6%84%8F%E5%A4%A7%E5%88%A9/"/>
      <url>/54.Trips-and-Exploration/EURO.%E6%84%8F%E5%A4%A7%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.maps-italy.com/%E6%84%8F%E5%A4%A7%E5%88%A9%E5%9C%B0%E5%9B%BE-%E6%97%85%E6%B8%B8%E4%B8%9A/%E6%84%8F%E5%A4%A7%E5%88%A9%E7%9A%84%E6%97%85%E6%B8%B8%E5%9C%B0%E5%9B%BE" target="_blank" rel="noopener">意大利的旅游地图-意大利旅游地图(南部欧洲-欧洲)</a>：</p><p><img src="/images/Italy.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EURO.俄罗斯 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/EURO.%E4%BF%84%E7%BD%97%E6%96%AF/"/>
      <url>/54.Trips-and-Exploration/EURO.%E4%BF%84%E7%BD%97%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<p>@toc</p><ul><li>加里宁格勒（柯尼斯堡大教堂）</li><li>莫斯科</li><li>彼得堡（冬宫广场、马琳剧院、涅瓦大街、滴血救世主教堂、普希金公寓）</li></ul><hr><p>@inbox:</p><ul><li><a href="https://new.qq.com/rain/a/20201014A0BDFV00" target="_blank" rel="noopener">为什么俄罗斯人这么喜欢阿迪达斯《reddit趣闻004期》_腾讯新闻</a></li></ul><h2 id="柯尼斯堡"><a href="#柯尼斯堡" class="headerlink" title="柯尼斯堡"></a>柯尼斯堡</h2><p>即如今俄罗斯加里宁格勒州首府加里宁格勒，位于桑比亚半岛南部，由条顿骑士团北方十字军于1255年建立，先后被条顿骑士团国、普鲁士公国和东普鲁士定为首都或首府。柯尼斯堡曾是德国東部的文化中心之一。</p><p>1945年柯尼斯堡戰役后，苏联红军占领城市。战后，根据《波茨坦协定》，柯尼斯堡成为苏联领土。1946年，为纪念刚逝世的苏联共产党和苏维埃国家领导人米哈伊尔·加里宁，柯尼斯堡更名为加里宁格勒。</p><p>康德是柯尼斯堡最值得骄傲的儿子。然而1724年4月22日清晨5点当他在普列戈利亚河上的克奈普霍夫（德语：Kneiphof）岛（Kneiphof）降生之时，这座城市还尚未设立。直至6月13日，岛上市镇才正式与河北岸的柯尼斯堡老城（德语：Altstadt (Königsberg)）和勒伯尼希特（德语：Löbenicht）并为一处。<br>新城的规模和人口超过了首都柏林，是普鲁士王国最大的城市。<br>康德在这里出生，在这里受教育，学成之后，又在柯尼斯堡大学任教，一直到他1804年去世，他一生都未远离他的故乡，去世之后，他被埋葬在柯尼斯堡的大教堂。这座拥有四百多年历史的大教堂是当地罕见的未遭受战火摧毁的古建筑。</p><p><img src="/images/IMG20220923.png" alt="2018年11月27日在俄罗斯加里宁格勒，康德波罗的海联邦大学内的一尊康德（Immanuel Kant）雕像遭人泼上油漆。摄：Vitaly Nevar / TASS via Getty Images"><br>@ref:</p><ul><li><a href="https://www.zhihu.com/question/21675546/answer/1763410189" target="_blank" rel="noopener">康德应该算德国人还是俄国人？ - 知乎</a></li><li>俄羅斯加里寧格勒為機場命名辦網上投票，加里寧格勒民間及網絡也掀起「反康德熱潮」: <a href="https://theinitium.com/article/20181205-evening-brief/" target="_blank" rel="noopener">https://theinitium.com/article/20181205-evening-brief/</a></li></ul><hr><p>现代建筑：4.House of Soviet 也在这里 @ref [[../63.Culture-and-Arts/Arch.建筑（苏联）]]</p><blockquote><p>这个栋烂尾楼是苏联的粗野主义（Brutalist style）的一个典范。这栋楼在俄罗斯的飞地Kaliningrad（加里宁格勒，在立陶宛和波兰之间），而且所在这片地非常出名，就是在Königsberg castle（哥尼斯堡城堡）原址上修建出来的。因为哥尼斯堡城堡在二战时被炸得几乎不能复原，所以直接拆了，原址基础上修了这么一个怪物。</p></blockquote><p><img src="/images/IMG20221001-7.png" alt="../_images/IMG20221001-7.png"></p><h2 id="圣彼得堡"><a href="#圣彼得堡" class="headerlink" title="圣彼得堡"></a>圣彼得堡</h2><p>“彼得堡”相同的中文翻译有几座城市：</p><ul><li>彼德堡（英语：Peterborough）或译“彼得伯勒”，位于英国英格兰东区域剑桥郡</li><li>彼得堡 (北达科他州)（Petersburg），美国北达科他州纳尔逊县的一个市镇</li><li>彼得堡縣（Peterborough County），加拿大安大略省的一個地方行政區</li></ul><p>圣彼得堡市（俄语：Са́нкт-Петербу́рг，罗马化：Sankt-Peterburg，旧名列宁格勒，是俄罗斯的联邦直辖市，也是西北部联邦管区和列宁格勒州的首府，曾为俄罗斯首都。位于俄罗斯西北部，濒临芬兰湾，涅瓦河流经过市区，为俄罗斯在波罗的海一带的重要港口和军事基地。</p><p>圣彼得堡由彼得大帝于1703年5月27日建立，在1712年至1918年期间为俄罗斯帝国的首都，并为帝国三次大革命——第一次俄国革命、俄国二月革命、十月革命的中心。圣彼得堡多次因时空背景而易名：第一次世界大战于1914年爆发后，圣彼得堡为因应当时“去日耳曼化”的风潮而改名为“彼得格勒”（Петрогра́д）；在列宁逝世后又改名为“列宁格勒”（Ленингра́д）。第二次世界大战苏德战争期间，列宁格勒被德军围城封锁长达872天，导致多达150万人死于饥饿，战后该城被授予“英雄城市”称号，并有三个下辖城市被授予“军事荣誉城市”称号——罗蒙诺索夫、克隆斯塔和科尔皮诺。1991年苏联解体后，列宁格勒经过公投决议后，恢复使用圣彼得堡的原名。</p><hr><ol><li>阿赫玛托娃文学纪念博物馆（Anna Akhmatova Literary and Memorial Museum）：<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%A8%9C%C2%B7%E9%98%BF%E8%B5%AB%E7%8E%9B%E6%89%98%E5%A8%83%E6%96%87%E5%AD%A6%E7%BA%AA%E5%BF%B5%E5%8D%9A%E7%89%A9%E9%A6%86" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AE%89%E5%A8%9C%C2%B7%E9%98%BF%E8%B5%AB%E7%8E%9B%E6%89%98%E5%A8%83%E6%96%87%E5%AD%A6%E7%BA%AA%E5%BF%B5%E5%8D%9A%E7%89%A9%E9%A6%86</a></li><li>安娜·阿赫玛托娃，白银时代（Анна Ахматова. Серебряный Век）：是俄罗斯圣彼得堡的一个博物馆，位于该市西南部的阿夫托沃（Avtovo），靠近同名的地铁站阿夫托沃站，专注于安娜·安德烈耶芙娜·阿赫玛托娃，以及其他在俄国文学的白银时代开始写作的20世纪上半叶俄国其他诗人和文学人物的生平与著作。博物馆位于一座普通公寓楼的底层。</li></ol><p>@link: [[../64.Novel-and-Poesy/R02.阿赫玛托娃]]</p><hr><p>/<em>《 不存在的白夜 》中的冬宫广场、马琳剧院、涅瓦大街、滴血救世主教堂、普希金公寓</em>/</p><p>许多年后 ， 面对汹涌的云层 ， 我会想起那天早晨看见涅瓦河冰封的时刻 。<br>那是抵达俄罗斯的次日 ， 我们赶去圣彼得堡国立大学历史系开会 ， 需要从涅瓦大街靠近海军部的住处穿过冬宫广场和瓦西里岛 ， 去到河对岸的门捷列夫街 。 前一天晚上已经在马琳剧院见到一条小运河冻成不自然的粉绿色——其实只是尚未完全冰冻的水面映出剧院外墙的色彩 ， 像个宏伟而住满肺科病人的翡翠宫 。 剧院内部则是一座金黄的琥珀殿 ， 一个四处渗动着半透明蜂蜜的巨大蜂房 。</p><p>我们在那里看了现代芭蕾 Camera Obscura ， 据说是根据纳博科夫 《 黑暗中的笑声 》 改编 。 彼得堡的芭蕾果然是这世上的珍宝 ， 只感到舞者的肌肉纷纷羽化成诗 ， 看不见的水禽向人类学习着飞翔 ， 而紫裙舞姬的足尖每次点地都犹如踩在我心上 ， 牵起生理性的疼痛 。<br>…</p><p>而这些都不重要 ， 那令人心悸的实际上是人类肢体与音乐语言之间某种近乎梵我合一的内在一体性 ， 这种一体性写在我们的基因里 ， 却在日常的疲惫 、 散乱 、 松懈中被我们损毁 。 芭蕾舞者正是以一种惊人的反刍能力让我们看到我们曾所应是 ， 那个人人都行走于大地如同阿佛洛狄特初次升起于群贝与泡沫的黄金时代 。 人类曾同时是鹰 ， 是鹤 ， 是孔雀 、 海豚和豹子 ， 现在却只是人 ， 在最好的情况下 。 即使羽片般的轻盈脱胎自厚重的血痂 ， 马琳的芭蕾舞台是映照我们的失落的一面圆镜 。</p><p>但现在是融雪日的清晨 ， 人间的悲剧与喜剧齐齐退场 ， 寂静的时刻即将到来 ， 巨大的浮冰彼此撞击着 ， 缝隙间露出墨色河水 ， 昭告一种简洁而叵测的命运 。 一排鸭子如雕像般蹲伏在冰面上 ， 似在哀悼着水中生活的终结 。 黑与白 ， 除此之外就是不远处冬宫影影绰绰的淡绿色 ， 到了第二天 ， 连这淡绿也在忽然笼罩全城的浓雾中消隐 ， 水天相接于一片凛然的白 。 站在桥畔眺望涅瓦河 ， 我想象在这些几何形状的碎冰上跳房子 ， 或是谨慎地一步一步走入看起来并不遥远的太虚幻境 。 消失的诱惑如此真实 ， 人若低头 ， 就不肯呼救 。</p><p>…</p><p>再没有什么比救世主滴血大教堂内部更是这种密集美学的完整化身 。 仿佛在某个神秘的时刻 ， 星空下所有的天使齐齐鼓动羽翼 ， 发出幽邃的叹息 ， 深蓝的穹窿和墙壁无一处不被这种叹息凝固而成的镶嵌画填满 。 东正教圣像传统与俄罗斯现代装饰美学糅合的结果是这座教堂生理性的美会令一些人心生厌恶 （ 就如他们厌恶新艺术运动以及穆哈的画）：就一座宗教建筑而言它太过耽美了 。 而我在其中独自逡巡了将近两个时辰 ， 无法比里尔克说得更好——美不过是我们恰好能承受的恐怖的开端 。</p><blockquote><p>出自里尔克：《杜伊诺哀歌》：哀歌之一</p></blockquote><p>…</p><p>但我毕竟找到了普希金的公寓 ， 并在玻璃柜里看到了娜塔莉亚的缎子舞鞋 ， 浅金色的 ， 放在一块酒红天鹅绒上 。 在那所公寓博物馆里我还看见了其他东西：那个法国纨绔发来的挑衅书 ， 那场决斗中普希金所使用的枪支 ， 他最后一次离开寓所时穿过的木门 ， 那天摊开在会客室书桌上的诗稿 ， 决斗负伤后他被抬回家中所躺卧的沙发 ， 墙上的煤油灯……</p><p>整栋公寓里我最爱他的书房 。 被三面墙的桃花心木书架环绕却还不至于密恐 ， 书架塞得满满且顶天立地却还不至使人压抑得无法动笔 ， 座钟 、 手杖 、 墙上的剑 ， 书桌上友人赠送的小黑人墨水瓶 。 书桌是真正可以写作的书桌 ， 足够大并且杂乱无章 ， 是我能感觉舒服的工作环境 ， 而我自己的书房多少也有点奔这个方向而去 。 我知道书桌边的普希金雌雄同体 ， 无需枪支就能决绝有力 ， 无需死亡与悲剧就已获得绝对的寂静 。</p><h2 id="莫斯科-搓澡"><a href="#莫斯科-搓澡" class="headerlink" title="莫斯科-搓澡"></a>莫斯科-搓澡</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMDU5ODcwNw==&amp;mid=2650822950&amp;idx=1&amp;sn=f4a94c91f0d7b9bad212b21e20fe70c4&amp;from=1088293010&amp;wm=3333_2001&amp;weiboauthoruid=1224713490" target="_blank" rel="noopener">像一个真正的战斗民族一样洗个战斗澡 - 天才张</a></p><p>上次聊了聊世界四大浴种中土耳其的浴的经历，还剩下的其他三大浴种是俄罗斯浴、芬兰浴、和日本浴。</p><p>听了酒店的介绍，我毅然放弃了更有历史的，全俄第一家公共浴室Sanduny，据说普希金和普京都在里面搓过灰，但我还是选择了更为私密有专属房间，并有专人服务的另一家浴室。</p><p>从右边那个小门进去就是正式的桑拿房了。走进桑拿房，排山倒海般的滚烫热浪瞬间把我包围。桑拿房里只有一张小木床，上面铺满了松树枝。小哥示意我，进去趴在床上，想到莫斯科四季酒店的礼宾部再三向我保证过，推荐的这家浴室绝对正规，绝对优质，我牙一咬，浴袍一脱趴了上去(别忘了里面还有双保险比基尼)。</p><p><img src="/images/IMG20220922-16.png" alt=""></p><p>紧接着，重头戏来了，也是俄罗斯浴的精髓，瓦尼亚开始用沾了热水的不知道什么树枝，抽打我的背部全身。用的就是就刚挂得满屋子都是的那些树杈子。</p><p>俄罗斯人认为，用这种抽打的方法不仅可以舒筋活血，逼走积在身体里的千年寒气，同时，这些植物在高温下会释放精油，随着一下下的抽打可渗透进张开的毛孔中，具有保健作用。</p><p>其实我能感觉到瓦尼亚同志在抽打我的过程中完全没有用力，但毕竟是树枝抽，又夹着百摄氏度左右的热水，每一下落到身上，必须都要咬紧牙根。</p><p>在我不知该替俄国大文豪们扼腕，还是操心自己红颜薄命的时候，瓦尼亚同志突然开始倒数：“Three… Two…One…” 我还没来得及问，英雄你何出此言呐，一桶冰水直接就浇了下来。</p>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EURO.荷兰 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/EURO.%E8%8D%B7%E5%85%B0/"/>
      <url>/54.Trips-and-Exploration/EURO.%E8%8D%B7%E5%85%B0/</url>
      
        <content type="html"><![CDATA[<p>@inbox:</p><ul><li><a href="https://www.zhihu.com/question/27469267" target="_blank" rel="noopener">在荷兰生活是种什么样的体验？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/24839853" target="_blank" rel="noopener">荷兰是个怎样的国家？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/31620359" target="_blank" rel="noopener">定居荷兰是一种什么样的体验？ - 知乎</a></li></ul><hr><h2 id="阿姆斯特丹"><a href="#阿姆斯特丹" class="headerlink" title="阿姆斯特丹"></a>阿姆斯特丹</h2><ul><li>Van Gogh Museum：梵高美术馆有4层，主要展出的是梵高一生中各个时期的主要作品，作品的数量占到梵高所有作品总量的1/4，《向日葵》、《吃土豆的人》，《盛开的杏树》和多幅梵高自画像都在这里，此外还收藏梵高的素描，以及其与弟弟提奥来往的书信，是世界上最大的一座梵高博物馆<ul><li>从中央火车站乘2/5路有轨电车，在Van Baerlestraat站</li></ul></li><li>Rembrandt House：<a href="https://art.icity.ly/museums/8r504p5" target="_blank" rel="noopener">伦勃朗故居博物馆 - 每日环球展览 - iMuseum</a></li><li>犹太区：<ul><li>犹太历史博物馆（JoodsHistorisch Museum）：其中有一个部分是斯宾诺莎（Baruch Spinoza）</li><li>滑铁卢广场（Waterlooplein）的跳蚤市场</li></ul></li></ul><h2 id="还有蘑菇"><a href="#还有蘑菇" class="headerlink" title="还有蘑菇"></a>还有蘑菇</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/20866348" target="_blank" rel="noopener">在梵高博物馆门口吃迷幻松露 - 知乎</a></li><li><a href="https://www.sohu.com/a/446255150_220095" target="_blank" rel="noopener">梵高、蘑菇与Ferdy，在荷兰的一些感悟</a></li><li><a href="https://m.ebiotrade.com/Newsf/2016-4/2016415154156804.htm" target="_blank" rel="noopener">Nature解答关于梵高的百年生物学谜题 - 生物通</a></li></ul><hr><p><a href="https://baijiahao.baidu.com/s?id=1737607305820141214&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">荷兰，吃迷幻蘑菇上飞机</a></p><p>虽然荷兰以迷幻蘑菇著称，由于安全问题（如年轻人服用迷幻蘑菇后坠河身亡），现在在荷兰能合法购买到的往往是减弱版的菌丝。不过为方便阅读，本文还会称为蘑菇。</p><p>等我从梵高博物馆出来的时候，已经六点要闭馆了。遂做了一个异常大胆的决定，在回青旅的路上路过的一个公园里吃，然后马上去机场，一个小时过渡时间我肯定已经到机场了（多亏荷兰机场近）。</p><p>此时再看指示屏幕，看到屏幕的紫色背景特别鲜亮，画面像天气预报的gif版一样有动感，那些字母仿佛也动了起来，我突然意识到我完了。我坐下来看着地面，机场的地板已经不是平整的了，开始起起伏伏，似乎有紫色和绿色的藤蔓不断在地面上伸展开来，远处走来的人像是电影人物出场一样，好像有微风吹着她们的头发，感觉我来到了另一个世界。我沉浸在这个神奇的世界，又努力让自己保持清醒，千万不能错过登机。终于通知了登机口，旁边的女孩起身了，我赶紧跟上。</p><p>终于解决了所有问题，可以静静地在候机厅等飞机来了。这个时候，我注意到候机厅挂着的一副画，就是下面这幅，我就彻底沦陷了。。这幅画里的所有东西都动了起来，里面的人都开始走动，我似乎都能听到海滩上喧闹的声音，海浪开始哗哗不断冲上岸，所有的帐篷开始不断飘动，就像水母一样的一张一合，很有节奏感，所有东西都以同样的节奏在慢慢飘动，就像呼吸一样自然安逸。白色、红色、黄色、紫色……所有的颜色都变得异常鲜亮，非常漂亮，配上节奏感的飘动（这大概就是店员说的little wave），让我整个人沉浸在里面无法自拔－－那像是另外一个世界，而我以上帝视角在看着另一个世界的生灵，好像这个世界就是我创造的，而且只有我知道只有我可以看到，是我和它们之间的小秘密，这个想法让我很开心，一直偷着乐，嘴角也不自觉上扬（这应该就是药效里提到的happy／laughing）。它们一张一合地好像在和我说话：“主人，看吧，这就是我们的世界，是不是很美很神奇，我们都是有灵性的生物，我们是你创造的，这个世界只有你知道，只有你能看到，这是属于我们的小秘密哦～要偷偷的，千万别被人发现哦～”然后我笑着想“够了，你们这些naughty kids”</p><p>我时不时看看窗外看飞机有没有来；时不时看看地面，紫色和绿色的藤蔓仍在不断生长；看看周围的人，头发会动，想要从头发上长出什么妖怪来，像是爱丽丝漫游仙境里的反派，因为他们会把我拉回现实，我就不高兴看人，一直看物；时而看一眼手机，想着要不要给家人给男票报个平安，但是看到手机上的app也像浮萍一样在屏幕里飘动，很轻盈很漂亮（突然觉得iphone的扁平化设计简直太机智太科学了），就不想发信息或语音了，只想好好沉浸在这个美丽的世界；偶尔想想想正经事，比如刚才为什么工作人员会让我塞行李，为什么以前坐easyjet都没有这种事，但是一想正经事我就觉得不开心，不能好好享受眼前的另一个世界，所以还是多看看眼前的画里的精灵吧。</p><p>等了好久，飞机终于缓缓地要降落了，easyjet的橙色本来就比较鲜艳，在我的眼里实在是美得不行，感觉像是天外飞来的座骑，来接公主回到自己的王国（当然我就是那个公主啦）。我很开心飞机来接我，但是一想到我要是走了，画里的精灵就要离开我了，它们给我了这么多快乐，好舍不得离开它们。我沉浸在自己公主梦的YY中，又开心又有着淡淡的伤感，于是我拍了上面的那幅画的照片，这样至少以后我还可以通过照片怀念它们（我真是脑洞大的不行。。）。</p><hr><p><a href="https://www.klook.com/zh-TW/blog/%E8%BF%B7%E5%B9%BB%E6%9D%BE%E9%9C%B2/" target="_blank" rel="noopener">超ㄎㄧㄤ体验：去荷兰一定要吃的「 迷幻松露」！ - Klook 客路部落格</a></p><p>「 迷幻松露」通常被大家称为「蘑菇」，但它其实不是真正意义上的mushroom。<br>但它和蘑菇事实上没有本质区别，两者关系简单可以用几点概括：</p><ol><li>松露是由霉菌形成的菌核，而在这些结成块状的菌核上，可以生长出蘑菇。所以可以说蘑菇是松露的果实。</li><li>迷幻松露含有的致幻成分和蘑菇本质上是一样的，只是蘑菇的致幻成分浓度更高，效果也更强。</li><li>在荷兰，其交易是违法的，却可以合法经营。不过鉴于松露就是蘑菇出土前的菌核，也就是说松露养一养就可以长出蘑菇，所以Smartshops（出售各类合法迷幻物品的商店）也出售所谓的Growbox。通过Growbox可以自己培养出迷幻蘑菇。但是培养出蘑菇后，就不能再进行交易。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EURO.希腊 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/EURO.%E5%B8%8C%E8%85%8A/"/>
      <url>/54.Trips-and-Exploration/EURO.%E5%B8%8C%E8%85%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="雅典"><a href="#雅典" class="headerlink" title="雅典"></a>雅典</h2><p>雅典卫城（Ακρόπολη）是希腊最杰出的古建筑群，为宗教政治的中心地。现存的主要建筑有山门、帕特农神庙、伊瑞克提翁神庙等。这些古建筑都是人类遗产和建筑精品，在建筑学史上具有重要地位</p><p>从雅典各个方向都可以看到耸立于雅典卫城山上顶端的帕特农神庙，据说远古这里曾供奉著高达10m的雅典娜神像，是举世闻名的古代七大奇观之一。帕特农神庙建于公元前447年，是著名建筑师和雕刻家菲迪亚斯的杰作</p><p>奥林匹亚宙斯神庙位于雅典卫城东南方500米，始建于公元前515年，但直到公元2世纪哈德良皇帝统治时期才兴建完成，是当时希腊规模最大的神庙。据说原有104根壮观的列柱，目前仅存15根。</p><p><img src="/images/IMG20220923-4.png" alt="雅典卫城- 帕提农神庙"></p><h2 id="奥林匹亚"><a href="#奥林匹亚" class="headerlink" title="奥林匹亚"></a>奥林匹亚</h2><p>奥林匹亚（希腊语：Ολυμπία）是希腊南部平原的一个城市，位于伯罗奔尼撒的西北。它是古代厄利斯用以祭拜宙斯的宗教中心，又是古代奥林匹克运动会的遗址。其中由菲迪亚斯所作的奥林匹亚宙斯神像是世界七大奇迹之一。</p><ul><li>赫拉神庙位于阿尔提斯的北区，它是圣地内最老的围柱式神庙和希腊最早的多立克式神庙之一。</li><li>宙斯神庙，其风格是科林斯式神庙。</li></ul><p>奥林匹亚圣域格局图：<br><img src="/images/IMG20220923-5.png" alt=""></p><h2 id="克里特"><a href="#克里特" class="headerlink" title="克里特"></a>克里特</h2><p>据荷马史诗所记说，“在深红葡萄酒色的海中，是一片美丽，富庶的土地，四面环水，岛上的人多得数不清，城市有九十个”。岛屿地处埃及、希腊、意大利及腓尼基之间，自古为战略要冲和贸易重镇，岛上有米诺斯王宫等遗迹。</p>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CN香港 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/CN.%E9%A6%99%E6%B8%AF/"/>
      <url>/54.Trips-and-Exploration/CN.%E9%A6%99%E6%B8%AF/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.zhihu.com/question/37121661" target="_blank" rel="noopener">香港有哪些经典的城市赏景地？ - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/21952404" target="_blank" rel="noopener">Instagram网红才不会告诉你的香港十大建筑拍摄地 - 知乎</a><ul><li>祖尧村, 荔景</li><li>坪石邨，九龙</li><li>西环邨，坚尼地城</li><li>彩虹邨，九龙</li><li>爱民邨，九龙</li><li>励德邨，铜锣湾</li><li>华富邨，薄扶林</li><li>百福花园，北角</li><li>坚尼地城</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CN天津 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/CN.%E5%A4%A9%E6%B4%A5/"/>
      <url>/54.Trips-and-Exploration/CN.%E5%A4%A9%E6%B4%A5/</url>
      
        <content type="html"><![CDATA[<p>@inbox</p><ul><li><a href="https://zhuanlan.zhihu.com/p/130230631" target="_blank" rel="noopener">天津｜从北到南走进一本城市编年史 - 知乎</a></li><li><a href="https://www.zhihu.com/question/23555326/answer/179780008" target="_blank" rel="noopener">天津有什么好玩的地方? - 知乎</a></li><li><a href="https://www.zhihu.com/question/54172441/answer/640747592" target="_blank" rel="noopener">在天津一个人一天去哪玩比较好？ - 知乎</a></li><li><a href="https://www.zhihu.com/column/p/37032788" target="_blank" rel="noopener">天津市历代地名牌考（上） - 知乎</a></li><li><a href="https://www.zhihu.com/question/30457250/answer/51438813" target="_blank" rel="noopener">天津有哪些深藏不露的餐馆？ - 知乎</a></li></ul><hr><h1 id="河北区-📍"><a href="#河北区-📍" class="headerlink" title="河北区 📍"></a>河北区 📍</h1><h2 id="王串场"><a href="#王串场" class="headerlink" title="王串场"></a>王串场</h2><p>@ref: <a href="https://zhuanlan.zhihu.com/p/54379184" target="_blank" rel="noopener">有一种回忆，叫王串场 - 知乎</a></p><p>王串场，大致是由真理道、金钟河大街、红星路和新阔路这四条道围成的区域。</p><p>“开”意指“开洼地带”，天津“四开”分别指：</p><ul><li>“南开”，就是过去老城厢西门以南的开洼地，差不多是今天南马路和南门外大街相交的西南方向区域，“西广开”则是南开再往西的开拓地。</li><li>“北开”，就是红桥区河北大街、原北营门东马路交汇的开阔地，今河海花园、瞰海一带；</li><li>“西开”，就是今天西开教堂以西一带的开阔地。</li><li>有人认为老城以东就是海河，往东走就掉河里头了，所以天津没有“东开”。但实际上天津不但有东开，而且它今天的知名度不比前三个地方小，这个东开，就是河北区王串场。</li></ul><p>在今王串场区域东北角有一片楼叫“开城里”，对过儿就是七十八中。因为前文提到，王串场的最初的人口聚集地就在东北部，所以我一开始认为，这个“开城”是以前延续下来的地名，因为“开城”从字面意思看，可以理解为东开地区形成人口聚落的开始。<br>后来才知道满不是这么回事，原来现在的王串场一带的20多个居民区的名字，字头字尾连起来是首诗：</p><blockquote><p>津开城垣焕玉容，<br>彩环盛宇萃华屏；<br>花芳景秀茵春艳，<br>泉清水明溪波莹。</p></blockquote><p>其实天津以诗为名的地方不少，比如福桥里、贵桥里的“桥”系列连起来就是“福贵乐康宁观览”；华苑各小区名字连起来就是“安居莹碧绮，天地日长久”等等。</p><h2 id="觉悟社"><a href="#觉悟社" class="headerlink" title="觉悟社"></a>觉悟社</h2><p>天津觉悟社纪念馆位于天津市河北区宙纬路三马路三戒里，系依托觉悟社旧址而建，旧址是由7间青砖木结构平房组成的小宅院，1984年9月16日对外开放，1986年邓颖超专程来馆视察并题写匾额，为天津市文物保护单位和爱国主义教育基地。</p><p>觉悟社是五四运动时期天津的青年学生团体，1919年9月16日成立，领导人物有周恩来等，其核心人员为天津学生联合会和天津女界爱国同志会的20名男女青年，成员对外废除姓名，用拈阄的方式确定代号和化名。觉悟社团结进步青年开展反封建、反帝国主义活动、改造社会挽救祖国的斗争活动，积极学习和传播马克思主义，成为中国共产党成立前的重要革命组织之一。1920年底，觉悟社集体活动结束，组织不复存在</p><p><img src="/images/IMG20220919-10.png" alt="觉悟社纪念馆，东北是李叔同书法碑林"></p><h2 id="扶轮中学"><a href="#扶轮中学" class="headerlink" title="扶轮中学"></a>扶轮中学</h2><p>民国七年（1918 年）二月，京奉、津浦、京汉、京绥四路员工联合组建的“铁路同人教育会”在北京成立。交通部次长（时任交通总长曹汝霖）叶恭绰⑴为会长、交通部路政司司长 关庚麟⑵为副会长，徐世章⑶（时任交通部次长）、詹天佑⑷（时任总工程师）、施肇曾⑸（时任交通银行董事长）、周自齐⑹（前交通总长）、徐廷爵⑺、王景春 ⑻、任凤苞⑼、丁士源⑽、陈梦雄、孙鸿哲(1932年任唐山工程学院院长，西南交通大学)、方仁元、龙学竞⑾为董事。随即以“扶轮公学”为统一校名 在“四路” ⑿沿线筹建员工子弟学校。</p><p>是年夏，铁路同人教育会借用位于吕纬路与五马路交口处属于津浦铁路局的一块地基用于创建子弟中学，即天津扶轮公学第一中学。这是 我国铁路创办最早的一所员工子弟中学。聘请毕业于北京高等师范学堂的顾宝埏（赞延）先生任校长兼算术教员，主持建校工作；同年10月，学校面向“四路”员 工子弟招生，首届招收新生2个班共80人（男生），聘请职员兼教员11人，11月4日开学，实行“壬子癸丑学制”（旧四年制中学），前两年为普通科，后两 年分为文、理、商等科。经投标，由天津振元木器场承建的两座校舍楼分别于民国八年（1919年）和十年（1921年）建成投入使用，南楼为教学楼，北楼为 办公兼宿舍楼，两楼均用青石条砌成，仍为该校标志性建筑。两楼于1993年被天津市河北区认定为文物保护单位。</p><p><img src="/images/IMG20220919-11.png" alt="扶轮中学"></p><h2 id="大悲禅院"><a href="#大悲禅院" class="headerlink" title="大悲禅院"></a>大悲禅院</h2><p>@ref： <a href="https://zhuanlan.zhihu.com/p/51920290" target="_blank" rel="noopener">天津地名故事丨大悲禅院 - 知乎</a></p><p>大悲禅院坐落河北区天纬路，是天津现存规模最大、历史最为悠久的佛门寺院。</p><p>大悲院始建于清代顺治末年（一说建于明代），因寺内供奉一尊高达3.6米的“大慈大悲救苦救难的观世音菩萨”而得“大悲”之名。</p><p>随着时代的变迁，大悲院几度沉浮。光绪二十六年（1900年），八国联军攻占天津，寺院被洗劫；民国时期又长期被法院、消防队、警察所占用。以至于到了解放前，只剩下了现在的西院。</p><p>1942年，大悲院扩建，在原有寺院的东侧陆续修建天王殿、大雄宝殿、大悲殿、东西配殿等建筑，连同园林景观等配套设施总计8000余平方米。</p><p>1945年，大悲院由南京请来了唐代高僧玄奘法师顶骨舍利，专设纪念堂作为镇寺之宝供奉。但在1956年，为了促进中印两国人民的友好交往，在印度政府的请求下，玄奘法师顶骨舍利重新回到了印度那烂陀寺遗址。</p><p>解放以后，大悲院曾在政府的协助下又进行过一次修缮，之后由天津的甲骨文专家王襄先生，书写了篆文的“古剎大悲禅院”，镌刻在寺院山门之上。</p><p>上世纪6、70年代，由于中国正经历特殊时期，大悲禅院也未能幸免，遭到了前所未有的破坏，寺庙内的文物被洗劫一空，损失惨重，之后76年的唐山大地震，寺院建筑又倒塌了一部分。所以直到1980年，大悲院才开始进行修复工作，并重塑所有佛像。</p><p>大悲院看似是一座寺庙，但实际上其不亚于一座小型博物馆，比如在大雄宝殿中供奉的佛祖金身像为明代所铸造，通高五米，重达六吨，是国家二级文物。</p><p>除此之外值得一提的是1956年在寺内设立的弘一大师（李叔同）纪念堂。<br>李叔同生于天津，通古博今，专攻音乐和绘画，创办了中国第一个话剧社“春柳社”，主演了《茶花女》等名剧。后来他在杭州虎跑寺剃度为僧，并南下福建泉州，穷其一生潜心钻研佛经戒律，成为了一代宗师。如果您没听说过他，那您肯定听过一首歌叫《送别》。“长亭外，古道边，芳草碧连天。晚风拂柳笛声残，夕阳山外山。”这首传唱度十分高的歌曲，就是弘一法师所作</p><h2 id="小关大街"><a href="#小关大街" class="headerlink" title="小关大街"></a>小关大街</h2><p>@ref: <a href="https://zhuanlan.zhihu.com/p/62290166" target="_blank" rel="noopener">天津河北区“小关大街”：消失的700年老街 - 知乎</a></p><p><img src="/images/IMG20220919-8.png" alt="80年代小关地图"></p><h2 id="金钢桥"><a href="#金钢桥" class="headerlink" title="金钢桥"></a>金钢桥</h2><p>金钢桥是中国天津市连接红桥区与河北区的一座桥梁建筑。始建于1996年，长600米，宽15米，为双层拱桥。前身为始建于1903年的开启式铁桥。目前，金钢桥坐落在中山路南端、横跨海河之上的金钢桥是天津市内重要的交通桥梁之一。</p><ol><li>金钢桥的前身为“窑洼木浮桥”，1901年，袁世凯任直隶总督兼北洋通商大臣之后，于1902年将原驻保定的直隶总督衙门搬移至天津并兴建河北新区。1903年，为了加强河北新区与海河对岸天津老城的沟通和联系，原木浮桥被改建为双叶承梁式钢架桥，并称其为“金钢桥”，桥长76.20米，宽为6.45米，中跨长为11.60米，桥身下部分为三孔。桥台用条石砌筑，桥面铺设有木板，可开启。后来，该桥因不能负重并于1922年在桥下游18米处建另建成一座大型钢梁双叶立转开启式新桥，1924年，新金刚桥竣工。</li><li>新金刚桥的设计和材料供应都为美国施特劳开启桥公司承包，天津大昌实业公司主持安装。桥长85.80米，宽为17米，两旁设有宽2米的人行道。新金刚桥的桥墩距桥面24.4米，为钢筋混凝土结构，桥的上部结构为上承式钢桁架，桥基部分设有气压况箱，桥墩和桥台部分为钢筋混凝土结构。桥的两边跨和中跨分别为固定桥孔和双叶立抟开启孔。此外，作为开启桥，新金刚桥可以从中间用电力操纵吊起开成八字形。建新金钢桥之后，旧金钢桥成便桥并于1927年因待修停用。日占天津时期的1942年，日军将金刚桥的桥梁拆除，仅剩下原有的四座桥墩。</li><li>中华人民共和国成立后，1981年，天津市人民政府利用原有桥墩建成钢架便桥。1996年5月1日，天津市人民政府因金刚桥成为危桥的缘由决定对其进行改建。同年11月20日，新双层拱桥建成并沿用其名</li></ol><p>这张老明信片反映的是20年代第二代金钢桥建成不久的情景：<br><img src="/images/IMG20220919-21.png" alt="新金刚桥"></p><h2 id="万国桥（解放桥）"><a href="#万国桥（解放桥）" class="headerlink" title="万国桥（解放桥）"></a>万国桥（解放桥）</h2><p><img src="/images/IMG20220919-20.png" alt="万国桥"></p><h2 id="望海楼教堂"><a href="#望海楼教堂" class="headerlink" title="望海楼教堂"></a>望海楼教堂</h2><p><img src="/images/IMG20220919-18.png" alt="望海楼教堂"></p><h2 id="意大利风情街"><a href="#意大利风情街" class="headerlink" title="意大利风情街"></a>意大利风情街</h2><p>上世纪二十年代的意式风情街:</p><p><img src="/images/IMG20220919-16.png" alt="马可波罗广场"></p><h1 id="和平区-📍"><a href="#和平区-📍" class="headerlink" title="和平区 📍"></a>和平区 📍</h1><h2 id="天津音乐厅"><a href="#天津音乐厅" class="headerlink" title="天津音乐厅"></a>天津音乐厅</h2><p>天津音乐厅原名平安电影院或小白楼音乐厅，坐落在天津市和平区小白楼地区南京路、浙江路、开封道和建设路四路交口处，为浙江路32号。其前身为始建于1922年的平安电影院。此后，原建筑于2005年拆除重建。2009年，新天津音乐厅落成，目前，天津音乐厅已成为天津的国际专业音乐厅。</p><p>@ref: <a href="https://zh.m.wikipedia.org/zh-hans/天津音乐厅" target="_blank" rel="noopener">https://zh.m.wikipedia.org/zh-hans/天津音乐厅</a></p><p><img src="/images/IMG20220919-12.png" alt="平安电影院 - 1922年建"></p><p><img src="/images/IMG20220919-17.png" alt="小白楼音乐厅"></p><h2 id="起士林餐厅"><a href="#起士林餐厅" class="headerlink" title="起士林餐厅"></a>起士林餐厅</h2><p>起士林（德语：Kiessling），是中国天津市的一家著名西餐厅，1901年由德国人阿尔伯特·起士林开办，地址曾先后位于天津法租界大法国路（今和平区解放北路）和天津德租界、天津美租界交界的威廉街（今河西区解放南路）。后与当时位于天津英租界马场道（Race Course Road）与达文波道（Davenport Road）交汇处（今和平区浙江路和建设路交汇处的浙江路33号）的维克多力餐厅合并。该建筑虽然和原貌有较大变化，但仍是重点保护等级历史风貌建筑和天津市文物保护单位。</p><p>1954年，起士林餐饮部分与当时的维克多力餐厅合并。维克多力餐厅原名“义顺合”，20世纪20年代初开业，至20世纪40年代扩大经营并改名维克多力。以经营俄式西餐大菜为主，同时兼做英、法、德、意式名菜和西点。起士林与维克多力合并后，定名为起士林餐厅。而两店的面包。西点制作部分，单独设立了起士林食品厂，专门从事西点、糖果、巧克力等生产。文化大革命期间，起士林餐厅先后更名为天津餐厅、工农兵餐厅等。1970年，起士林餐厅职工联合给时任中华人民共和国总理周恩来写信请求恢复起士林餐厅老字号，七天后得到国务院批准。之后，起士林在大理道和南市食品街开办了两家分店，在河北省秦皇岛市北戴河也恢复了分店。1990年7月5日，起士林餐厅正式更名为“起士林大饭店”，不但设有西餐厅、客房，而且有舞厅和卡拉OK等附属设施。1998年12月18日，起士林餐厅北京分店开业，位于东城区南河沿大街华龙街2楼。</p><p>起士林餐厅现主营德式西餐，兼做俄、英、法、意五国西式大菜，其代表菜有“奶油烤杂拌”、“罐焖牛肉”、“奶汁烤鱼”等。</p><p>@ref: <a href="https://zh.m.wikipedia.org/zh-hans/起士林餐厅" target="_blank" rel="noopener">https://zh.m.wikipedia.org/zh-hans/起士林餐厅</a></p><p><img src="/images/IMG20220919-14.png" alt="起士林（浙江路总店）- 原维克多力餐厅"></p><p><img src="/images/IMG20220919-13.png" alt="起士林（浙江路总店）- 2020"></p><h2 id="先农大院"><a href="#先农大院" class="headerlink" title="先农大院"></a>先农大院</h2><p>先农大院始建于1925年，坐落于当时的天津英租界的威灵顿道（Wellington Road）与达克拉道（Douglas Road）交口（今和平区河北路与洛阳道交口），占地面积为8100平方米，总建筑面积为8400平方米，由建筑围合形成建筑组团，该建筑群目前为一般保护等级历史风貌建筑。</p><p>先农大院建于1925年，由成立于1901年的先农地产工程股份有限公司的英籍工程师雷德设计，在当时该大院多为先农地产公司的高级职员居住，所以取名为先农大院。</p><p>大院由英式联排住宅、英式独立的住宅等六幢建筑组成，功能布局合理，居住舒适，是典型的中产阶级住宅。</p><p><img src="/images/IMG20220919-22.png" alt="先农大院1 - 2020~2021"></p><p><img src="/images/IMG20220919-23.png" alt="先农大院2 - 2020~2021"></p><p><img src="/images/IMG20220919-19.png" alt="生活在先农大院里的英国人"></p><p>@ref: <a href="https://zh.m.wikipedia.org/zh-hans/先农大院" target="_blank" rel="noopener">先农大院 - 维基百科，自由的百科全书</a></p><h2 id="先农公司大楼"><a href="#先农公司大楼" class="headerlink" title="先农公司大楼"></a>先农公司大楼</h2><p>先农公司大楼（英语：Tientsin Land Investment CO.,LTD. Building）又称天津先农公司大楼，始建于1923年至1924年，由英商先农工程股份有限公司英籍建筑师奈尔（D.LYLE）设计，坐落于当时天津英租界的海大道（英语：Taku Road，今和平区大沽北路111号），原建筑已于2006年拆除。</p><p>“2005年大沽北路拓宽改造工程中原计划保留，但时隔一年之后，该建筑被拆除。”</p><p><img src="/images/IMG20220919-15.png" alt="先农公司大楼 - 2006年拆"></p><h1 id="河东区-📍"><a href="#河东区-📍" class="headerlink" title="河东区 📍"></a>河东区 📍</h1><h2 id="大直沽"><a href="#大直沽" class="headerlink" title="大直沽"></a>大直沽</h2><p>@ref：<a href="https://zhuanlan.zhihu.com/p/55361710" target="_blank" rel="noopener">大直沽——天津城市原生点 - 知乎</a></p><p>大直沽影院原址是比利时工部局翻译靳云波的私人戏楼。</p><p>新中国建立初期，政府为了解决大直沽、大王庄一带的工人不能看电影的问题，1956年区政府将坐落在大直沽九号路的“新民戏院”改建为“大直沽影戏院”，总共有690个席位。<br>1964年为了更好的观影效果，大直沽影戏院进行原址重建，拆除了观众厅的10棵柱子，座席也增加到802个 ，安装了国产放映设备 ，定名“大直沽影剧院”。<br>但在1979年正月初一的时候因火灾被烧毁，1986年重建后更名为“大直沽影院”。</p><p><img src="/images/IMG20220919-9.png" alt="大直沽六号路1号"></p><h1 id="爬楼机位-📸"><a href="#爬楼机位-📸" class="headerlink" title="爬楼机位 📸"></a>爬楼机位 📸</h1><p>↓拍摄于2017-4-2 周日 19:00，FUJIFILM X-T1，15 秒，50 mm，ISO200，<br>天津环球金融中心①、金融街中心②、以及中心公园<br><img src="/images/IMG20220919-25.png" alt=""></p><p><img src="/images/IMG20220919-24.png" alt="贵都大厦"></p><hr><p>↓拍摄于2017-10-1 周日 18:15，SONY ILCE-7M2，ƒ/8，10 秒，16 mm，ISO100，<br>解放南路（横）、新围堤道（中环线，竖）<br><img src="/images/IMG20220919-26.png" alt=""></p><p><img src="/images/IMG20220919-27.png" alt="明珠大厦"></p><hr><p>↓拍摄于2017-10-2 周日 18:07，SONY ILCE-7M2，ƒ/10，4 秒，16 mm，ISO100，<br>天津之眼<br><img src="/images/IMG20220920-1.png" alt=""><br><img src="/images/IMG20220920.png" alt="壹街区"></p>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天津 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN北京 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/CN.%E5%8C%97%E4%BA%AC/"/>
      <url>/54.Trips-and-Exploration/CN.%E5%8C%97%E4%BA%AC/</url>
      
        <content type="html"><![CDATA[<p>@toc: 博物馆、旧货市场、话剧、青旅、建筑、城中村</p><hr><p>@inbox</p><ul><li><a href="https://www.zhihu.com/question/25835899/answer/294415971" target="_blank" rel="noopener">北京有什么鲜为人知的、很好玩的地方？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/27893066/answer/38957291" target="_blank" rel="noopener">在北京生活有什么鲜为人知的技巧？ - 知乎</a>：小西天电影资料馆、三联、国博、凡士林润肤露/ 滤水壶…</li><li><a href="https://www.zhihu.com/question/26731916/answer/39744124" target="_blank" rel="noopener">北京海淀区有哪些被埋没的好地方？ - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/28447262" target="_blank" rel="noopener">这5家我经常去的旧货市场，都在北京6环内 - 知乎</a>： 孙河市场/大柳树/天宝/新七彩</li><li><a href="https://www.zhihu.com/question/334995780/answer/749427135" target="_blank" rel="noopener">北京哪里商场好逛? - 知乎</a></li><li><a href="https://www.zhihu.com/question/31265981" target="_blank" rel="noopener">在北京看话剧，有哪些剧场值得推荐？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/23514293" target="_blank" rel="noopener">北京有哪些青年旅舍值得推荐？ - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/22315958" target="_blank" rel="noopener">北京41家博物馆亲身体验攻略手册 - 知乎</a></li><li><a href="https://cn.tripadvisor.com/Attractions-g294212-Activities-c47-t3-Beijing.html" target="_blank" rel="noopener">北京市 10 大建筑物 - Tripadvisor</a></li><li><a href="https://www.zhihu.com/question/22213994" target="_blank" rel="noopener">北京值得观赏的现代的建筑有哪些？ - 知乎</a><ul><li>红砖美术馆、树美术馆、鸿坤美术馆、中央美术学院美术馆、今日美术馆、宋庄美术馆</li><li>篱苑书屋</li><li>北京西站，扩展阅读： [[../63.Culture-and-Arts/Arch.北京建筑上的大屋顶]]</li><li>侨福芳草地</li></ul></li></ul><h2 id="考古系列"><a href="#考古系列" class="headerlink" title="考古系列"></a>考古系列</h2><ul><li>万寿寺  @link: [[../64.Novel-and-Poesy/C02.青铜时代]]</li><li>《阳光灿烂的日子》拍摄地：<a href="https://www.douban.com/note/318385496/?_i=4603426kQHWhAK" target="_blank" rel="noopener">2013《游·阳光灿烂的日子》拍摄地~</a>：段祺瑞执政府旧址、恭王府、辅仁大学、利马窦墓、东四六条、莫斯科餐厅、北展剧场 // @link：[[../64.Novel-and-Poesy/C14.动物凶猛]]</li><li><a href="https://www.douban.com/note/258980183/?_i=3862022kQHWhAK" target="_blank" rel="noopener">从胡同北平到大院北京</a></li><li><a href="https://www.163.com/renjian/article/BER5PDB0000153N3.html" target="_blank" rel="noopener">六郎庄死了，我很怀念它<em>网易人间</em>网易新闻</a></li></ul><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><p>单向街买到的《书虫漫游北京指南》：书店、博物馆、文化地标、咖啡厅<br><img src="/images/Map-书虫漫游北京指南.png" alt=""></p><p>《北京市城区街道图-1982版》：<br><img src="/images/Map-北京市城区街道图1982.png" alt=""></p><h2 id="废墟探险"><a href="#废墟探险" class="headerlink" title="废墟探险"></a>废墟探险</h2><p><a href="https://zhuanlan.zhihu.com/p/21547256" target="_blank" rel="noopener">关于北京废墟探险，我能告诉你们的 - 知乎</a><br>1，帖子中所讲到的大部分地标性废墟，现在都已经消失了——小汤山医院、沃德兰乐园、玉泉路主题公园……早都拆了；朝内81号商业化了，有专人值守；首钢、首钢二通厂等地也都陆续在改造，如今也大都不是图片当中的样子。城市当中的拆迁区，也是今天去一个样，明天去另外一个样。所以不要刻舟求剑。</p><p>2，废墟探险的乐趣，首先在于探索和发现，之后才是探访与记录。如果你真的喜欢废墟探险，就自己去找找吧，从网络上、从现实中，都会有线索。我当初拍摄的好多市内废墟，都是我花费了大量时间，背着相机在老城区里、胡同里来回串找到的。</p><hr><p><a href="https://www.zhihu.com/question/21798332/answer/68011198" target="_blank" rel="noopener">北京有哪些被废弃的地方值得一看？推荐理由是什么？ - 知乎</a></p><p>首钢、玉泉路乐园（绝版）、沃德兰乐园（绝版）、广渠门烂尾楼（绝版）</p>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CN上海 / 玩什么</title>
      <link href="/54.Trips-and-Exploration/CN.%E4%B8%8A%E6%B5%B7/"/>
      <url>/54.Trips-and-Exploration/CN.%E4%B8%8A%E6%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>@inbox:</p><ul><li><a href="https://www.zhihu.com/question/21901692/answer/210866954" target="_blank" rel="noopener">上海有哪些适合一个人吃饭的餐厅？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/24550268/answer/51911732" target="_blank" rel="noopener">上海有哪些深藏不露的餐馆？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/31208132/answer/51122620" target="_blank" rel="noopener">在上海和喜欢的姑娘在一起有哪些好玩的地方？ - 知乎</a></li></ul><hr><h2 id="徒步路线"><a href="#徒步路线" class="headerlink" title="徒步路线"></a>徒步路线</h2><p><a href="https://www.douban.com/group/topic/4528970/?_i=3855880kQHWhAK" target="_blank" rel="noopener">上海的十条漫步线路</a></p><ul><li>漫步线路1　　中山公园——愚园路——江苏路——华山路——徐家汇</li><li>漫步线路2　　徐家汇——衡山路——淮海路</li><li>漫步线路3　　延安西路——新华路——淮海路——华山路——徐家汇</li><li>漫步线路4　　漕宝路地铁站——漕宝路——桂林路——田林路——宜山路</li><li>漫步线路5　　徐家汇——建国西路——建国中路——建国东路——西藏南路</li><li>漫步线路6　　外滩——南京东路——南京西路——静安寺</li><li>漫步线路7　　南京西路——陕西南路——长乐路——镇宁路</li><li>漫步线路8　　淮海中路——汾阳路——东平路——乌鲁木齐路</li><li>… …</li></ul>]]></content>
      
      
      <categories>
          
          <category> 54.Trips-and-Exploration </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用谷歌街景进行街拍</title>
      <link href="/53.Photograph/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E8%A1%97%E6%99%AF%E8%BF%9B%E8%A1%8C%E8%A1%97%E6%8B%8D/"/>
      <url>/53.Photograph/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E8%A1%97%E6%99%AF%E8%BF%9B%E8%A1%8C%E8%A1%97%E6%8B%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Jacqui-Kenny"><a href="#Jacqui-Kenny" class="headerlink" title="Jacqui Kenny"></a>Jacqui Kenny</h1><ul><li><a href="https://www.163.com/dy/article/G4CAJOJJ0545IA3Z.html" target="_blank" rel="noopener">“我不是摄影师，是谷歌街景截图艺术家”_网易订阅</a></li><li><a href="https://www.wowlavie.com/article/ae2001375" target="_blank" rel="noopener">Google地图街景创作！ 英国艺术家Jacqui Kenny截下独特迷人美景</a></li><li>Ins： <a href="https://www.instagram.com/streetview.portraits/" target="_blank" rel="noopener">https://www.instagram.com/streetview.portraits/</a></li></ul><p>居住在伦敦，患有广场恐惧症的艺术家 Jacqui Kenny，选择让它成为自己环游世界的交通工具，和照相机。</p><p>“广场恐惧和焦虑限制了我旅行的能力，于是我找到了另一种看世界的方式。”</p><p>在名为「streetview.portraits」的 Instagram 账号下，Jacqui Kenny 写下这段自我介绍。账号的第一张照片发布于 2016 年，是谷歌街景视角下的蒙古达尔汗城一角。</p><p>5 年来，Kenny 给自己的标签从来没变过：Agoraphobic Traveller，广场恐惧症旅行者。两个看上去完全相互排斥的词汇，被谷歌街景地图，以及她本人的好奇心和创作欲连在一起。</p><p><img src="/images/IMG20220922-3.png" alt=" Jacqui Kenny"></p><h1 id="Michael-Wolf"><a href="#Michael-Wolf" class="headerlink" title="Michael Wolf"></a>Michael Wolf</h1><p><a href="https://www.zhihu.com/question/33060496" target="_blank" rel="noopener">谷歌街景对街头摄影造成了哪些影响？ - 知乎</a></p><p>Michael Wolf本身是以他的大尺寸建筑摄影出名，主要拍的是香港和芝加哥，比如 “architecture of density” and “the transparent city” 系列。但他前几年开始对公共环境的监控摄像头感兴趣，接着又关心到个人隐私和公共摄像头的关系，于是从摄影师的角度出发，他在问自己，作为现代科技武装下的街头摄影师，我们需要和被拍摄的对象保持多远的距离？</p><p>这个问题并不新，许多摄影师和概念艺术家都研究过，例如我最爱的法国女艺术家Sophia Calle就做过一系列类似问题的探索，她雇佣了一个私家侦探，跟拍了自己的一天。</p><p>Michael Wolf后来做的一个摄影项目很出名，大家肯定都记得，是“Tokyo compression”，就是蹲在日本地铁里拍那些被压在车厢里的日本人的脸。有一种在公共空间窥探个人隐私、私人痛苦的感觉。link：<a href="https://link.zhihu.com/?target=http%3A//photomichaelwolf.com/%23tokyo-compression/1" target="_blank" rel="noopener">MICHAEL WOLF PHOTOGRAPHY</a></p>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何评价富士的classic chrome胶片模拟？</title>
      <link href="/53.Photograph/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E5%AF%8C%E5%A3%AB%E7%9A%84Classic-Chrome%E8%83%B6%E7%89%87%E6%A8%A1%E6%8B%9F/"/>
      <url>/53.Photograph/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E5%AF%8C%E5%A3%AB%E7%9A%84Classic-Chrome%E8%83%B6%E7%89%87%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<p>@tag: #摄影 #相机 #Fujifilm</p><p><a href="https://www.zhihu.com/question/58228287/answer/188459425" target="_blank" rel="noopener">https://www.zhihu.com/question/58228287/answer/188459425</a></p><p>Classic chrome 的饱和度非常低，比Provia/Neg这些都要低，同时也抑制了高光部分的亮度，但是阴影更暗，色彩上蓝色偏青，黄和绿偏橙。</p><p><img src="/images/20220327234625.png" alt=""></p><p>上面的色调和饱和度坐标图可以看到，Classic chrome的饱和度是最低的， 同时色调稍稍强烈一些。</p><p>富士并没有给早期的机型（X100，x100s等）更新这个胶片模拟，但是可以通过Provia来模拟classic chrome ：</p><ol><li>高光色调-1，降低高光，保留更多高光细节</li><li>阴影色调+1，使阴影部分更暗</li><li>色彩-2，把饱和度降到最低</li></ol><p>这样调整出来的Provia预设更像classic chrome，下面是样片：</p><p><img src="/images/20220327234642.png" alt=""></p><p><img src="/images/20220327234654.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索尼α系列-PP设置</title>
      <link href="/53.Photograph/%E7%B4%A2%E5%B0%BC%CE%B1%E7%B3%BB%E5%88%97PP%E8%AE%BE%E7%BD%AE/"/>
      <url>/53.Photograph/%E7%B4%A2%E5%B0%BC%CE%B1%E7%B3%BB%E5%88%97PP%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>@tag: #摄影 #相机 #说明书</p><h2 id="PP的配置项说明"><a href="#PP的配置项说明" class="headerlink" title="PP的配置项说明"></a>PP的配置项说明</h2><p>@ref <a href="https://helpguide.sony.net/ilc/1420/v1/zh-cn/contents/TP0000527199.html" target="_blank" rel="noopener">帮助指南 | 图片配置文件</a></p><p>黑色等级</p><ul><li>设定黑色等级。（-15至+15）</li></ul><p>伽玛: 选择伽玛曲线。</p><ul><li>Movie：动态影像用的标准伽玛曲线</li><li>Still：静止影像用的标准伽玛曲线</li><li>Cine1：柔化暗部的对比度，强调亮部的层次以再现轻松彩色的动态影像。（相当于HG4609G33）</li><li>Cine2：类似于[Cine1]，但实施了优化以适于编辑最高100%的视频信号。（相当于HG4600G30）</li><li>…</li></ul><p>黑伽玛: 校正低亮度区域的伽玛。</p><ul><li>范围：选择校正范围。（宽 / 中 / 窄）</li><li>等级：设定校正等级。（-7（最大黑色压缩）至+7（最大黑色伸展））</li></ul><p>膝点: 设定视频信号压缩用的膝点和斜率，通过将被摄体高亮度区域的信号限制在相机的动态范围内来防止曝光过度。</p><p>模式: 选择自动/手动设置。</p><ul><li>自动：自动设定膝点和斜率。</li><li>手动：手动设定膝点和斜率。</li></ul><p>色彩模式: 设定色彩的类型和级别。</p><ul><li>Movie：当［伽玛］设定为［Movie］时的适合色彩。</li><li>Still：当［伽玛］设定为［Still］时的适合色彩。</li><li>Cinema：当［伽玛］设定为［Cine1］时的适合色彩。</li><li>Pro：类似Sony专业相机标准画质的色调（与ITU-709伽玛组合时）</li><li>ITU709矩阵：与ITU-709标准相应的色彩（与ITU-709伽玛组合时）</li><li>黑白：将饱和度设为0以进行黑白拍摄。</li><li>S-Gamut：以拍摄后图像将被处理为前提的设置。当［伽玛］设定为［S-Log2］时使用。</li></ul><p>饱和度: 设定色彩饱和度。（-32至+32）</p><p>色彩相位: 设定色彩相位。（-7至+7）</p><p>色彩浓度: 设定各色相的色彩深度。颜色越深该功能的效果越明显，对于没有颜色的被摄体效果不明显。向正方向增加设定值时颜色会显得更深，向负方向减少设定值时颜色会显得更浅。将［色彩模式］设为［黑白］（黑和白）时该功能也有效。</p><ul><li>［R］-7 （淡红）至 +7 （深红）</li><li>［G］-7 （淡绿）至 +7 （深绿）</li><li>［B］-7 （淡蓝）至 +7 （深蓝）</li><li>［C］-7 （淡青）至 +7 （深青）</li><li>［M］-7 （淡品红）至 +7 （深品红）</li><li>［Y］-7 （淡黄）至 +7 （深黄）</li></ul><h2 id="PP设定示例"><a href="#PP设定示例" class="headerlink" title="PP设定示例"></a>PP设定示例</h2><p>@ref <a href="https://post.smzdm.com/p/az59qp2p/" target="_blank" rel="noopener">巧用sony a7m3的PP设置，直出日式小清新照片</a></p><ul><li>黑色等级：+15。让阴影亮起来，降低对比度。</li><li>伽马：Cine4。没理由，挨个试了之后发现这个我最喜欢。</li><li>黑伽马：范围：窄。等级：+7。让黑色部分亮起来，继续降低对比度。</li><li>膝点：手动。点：97.5%，斜率：+2。让高光降一点，还是降低对比度。</li><li>色彩模式：ITU709矩阵。也没理由，挨个试了之后选的。</li><li>饱和度：+5。</li><li>色彩相位：-2。偏黄偏绿。</li><li>色彩浓度：R：+3，G：-2，B：-2，C：0，M：0，Y：-4。挨个试了之后的选择。</li><li>细节——等级+7。调整：模式：手动。V/H平衡：0。B/W平衡：类型1。限制：7。Crispning：0。高亮细节：0。</li></ul><p>@ref <a href="https://www.youtube.com/watch?v=wFeXD7TdFh8" target="_blank" rel="noopener">【摄影教程】这样简单设置索尼pp值，拍出来就是电影感</a></p><p><img src="/images/20220226004324.png" alt=""></p><ul><li>黑色等级：+3</li><li>伽马：Cine4</li><li>黑伽马：范围：宽，等级：+4</li><li>漆点：手动（最大点80%，斜率-5）</li><li>色彩模式：Pro</li><li>饱和度：0</li><li>色彩浓度：R=+2 / G=+1 / B=-1 / C=-4 / M=-3 / Y=+2</li><li>细节：-6</li></ul>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>扫街指南</title>
      <link href="/53.Photograph/%E6%89%AB%E8%A1%97%E6%8C%87%E5%8D%97/"/>
      <url>/53.Photograph/%E6%89%AB%E8%A1%97%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Bresson.png" alt=""></p><ul><li>在杂乱中寻找结构</li><li>在日常中寻找美感</li><li>脚步慢下来，这样可以避免错过的瞬间</li><li>帽子和口罩</li><li>气温不宜高于25摄氏度 or 低于0度，不适宜的天气会扫兴</li></ul><hr><ul><li><a href="http://www.cnu.cc/works/123182" target="_blank" rel="noopener">决定性的瞬间 | 布列松作品精选</a></li><li><a href="https://new.qq.com/rain/a/20210305A0FFIL00" target="_blank" rel="noopener">“我不是摄影师，是谷歌街景截图艺术家”</a></li><li><a href="/53.Photograph/使用谷歌街景进行街拍/" title="使用谷歌街景进行街拍">使用谷歌街景进行街拍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相机manual.索尼α7m3</title>
      <link href="/53.Photograph/%E7%9B%B8%E6%9C%BAmanual.%E7%B4%A2%E5%B0%BC%CE%B17m3/"/>
      <url>/53.Photograph/%E7%9B%B8%E6%9C%BAmanual.%E7%B4%A2%E5%B0%BC%CE%B17m3/</url>
      
        <content type="html"><![CDATA[<p>@tag: #摄影 #相机 #说明书</p><h2 id="自定义按键-amp-操作Tips"><a href="#自定义按键-amp-操作Tips" class="headerlink" title="自定义按键 &amp; 操作Tips"></a>自定义按键 &amp; 操作Tips</h2><ul><li>按键设定：<ul><li>C1：对焦区域（中间/区域/广域）</li><li>C2：对焦模式（单次/连续/手动）</li><li>C3：测光方式（多重/中心/点测）</li><li>方向键↓：屏幕亮度</li><li>删除键：屏幕触摸On/Off</li></ul></li><li>菜单收藏：<ul><li>静音拍摄/AF辅助照明/长曝降噪/防抖</li></ul></li></ul><h2 id="一般拍摄option"><a href="#一般拍摄option" class="headerlink" title="一般拍摄option"></a>一般拍摄option</h2><ul><li>[ ] 关闭WiFi 和NFC 延长续航</li><li>[ ] 白平衡：偏冷 B1M1  / 偏暖 A2M2</li><li>[ ] 创意风格：清淡（对比+1、饱和-1）or Portrait</li><li>[ ] 曝光：+1/3~2/3</li></ul><h2 id="风光-amp-长曝拍摄option"><a href="#风光-amp-长曝拍摄option" class="headerlink" title="风光&amp;长曝拍摄option"></a>风光&amp;长曝拍摄option</h2><ul><li>[ ] 拍摄1：影像质量（RAW+J ）</li><li>[ ] 拍摄4：ISO 100 , 关闭多帧降噪（拍摄多张合成）</li><li>[ ] 拍摄6：打开长时间曝光降噪（时间+一倍）</li><li>[ ] 拍摄6：关闭高ISO降噪（对RAW无效）</li><li>[ ] 拍摄7：关闭SteadyShot（如果上三脚架）</li><li>[ ] 齿轮6：镜头校正-失真补偿（如果用16-35需要开启此选项）如果用手动Helios44需打开阴影补偿（改善暗角）</li></ul><h2 id="创意风格"><a href="#创意风格" class="headerlink" title="创意风格"></a>创意风格</h2><p><img src="/images/20220225232553.png" alt=""></p><p>@ref <a href="https://www.youtube.com/watch?v=5ACrztLOI7I&amp;ab_channel=IsaacWEAPON" target="_blank" rel="noopener">Eng Sub最简单改善“索尼黄”的方法：机内创意风格和色彩模式全对比「Isaac WEAPON」 - YouTube</a></p><p>自带创意风格(哪个更适合拍人像)</p><ul><li>Standard(标准):</li><li>Neutral(中性): 比Std更柔和, 清晰度↓, 饱和度↓, 肤色比Std更好(少了黄绿色), 适合后期加工</li><li>Light(清淡): 并不清淡, 肤色仍旧有黄绿</li><li>Portrait(人像):  优化了肤色, 完全可用</li><li>Clear(清澈): 未测试</li></ul><h2 id="PP（图片配置文件）"><a href="#PP（图片配置文件）" class="headerlink" title="PP（图片配置文件）"></a>PP（图片配置文件）</h2><a href="/53.Photograph/索尼α系列PP设置/" title="索尼α系列PP设置">索尼α系列PP设置</a><h2 id="待测试选项"><a href="#待测试选项" class="headerlink" title="待测试选项"></a>待测试选项</h2><ul><li>[ ] （测试）更小的光圈和更长曝光时间</li><li>[ ] （测试）全景模式接片</li><li>[ ] （测试）后期堆栈叠加</li></ul><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><ul><li>[ ] 延时拍摄App</li><li>[ ] 多重曝光App</li><li>[ ] 平滑反射App</li></ul>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相机manual.富士X100F</title>
      <link href="/53.Photograph/%E7%9B%B8%E6%9C%BAmanual.%E5%AF%8C%E5%A3%ABX100F/"/>
      <url>/53.Photograph/%E7%9B%B8%E6%9C%BAmanual.%E5%AF%8C%E5%A3%ABX100F/</url>
      
        <content type="html"><![CDATA[<p>@tag: #摄影 #相机 #Fujifilm #说明书</p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><ul><li>Q键：检查图片尺寸/白平衡/ND/对焦等..</li><li>长按对焦杆, 锁定 //设置为“OFF”以防止误碰导致AF点移动</li><li>长按MENU键, 锁定</li><li>ISO默认使用AUTO3方案(最高3200, 快门1/60)</li><li>ND滤镜: 在日光下使用慢快门和大光圈, 可在Q中开启</li></ul><h2 id="自定义按键"><a href="#自定义按键" class="headerlink" title="自定义按键"></a>自定义按键</h2><ul><li>对焦辅助灯：MENU→ AF/MF→ <code>AF辅助灯</code></li><li>WiFi传输：MENU→ 拍摄选项（第3个）→ <code>无线通信</code></li><li>数码变焦(50mm/70mm)：MENU→ 拍摄选项（第3个）→ <code>数码远射增距镜</code></li><li>按键设定：<ul><li>MENU键：长按锁定/解除锁定 // 仅对MENU键有效</li><li>对焦杆：长按可进行设置    // 仅对对焦杆有效</li><li>Fn键：是否开启面部/眼睛识别</li><li>▲键：DRIVE（单张/连拍/包围/视频）可开启胶片包围</li><li>▼键：胶片模拟</li><li>◀ 键：白平衡</li><li>▶ 键：ISO</li></ul></li><li>取景器拨杆按钮(Fn2按钮):<ul><li>长按: 设定</li><li>短按: 进入设置功能，当前设置为【控制环设定】</li><li>按住+转动对焦环: 依据设置功能切换</li></ul></li></ul><p><img src="/images/富士X100F/X100F方向键.jpg" alt=""></p><h2 id="图像质量-IQ"><a href="#图像质量-IQ" class="headerlink" title="图像质量 IQ"></a>图像质量 IQ</h2><ul><li>图像尺寸: 默认值L (3:2)</li><li>图像质量: 默认值<code>FINE</code></li><li>动态范围: 默认值<code>100%</code>，影响高光细节, 动态范围200%在ISO 400+时可以使用, 动态范围400%在ISO 800+时可以使用, 对RAW文件有效</li><li>高光色调: 值越大, 高光部分越亮, 值越小, 能保留更多高光细节, 只影响JPG</li><li>阴影色调: 值越大, 阴影部分越暗, 值越小, 能保留更多暗部细节, 只影响JPG</li><li>降噪功能: 减少高ISO的噪点, 默认值<code>0</code></li><li>长时间曝光降噪: 减少场曝光的斑点, 默认值<code>开</code></li></ul><h2 id="对焦-AF-MF"><a href="#对焦-AF-MF" class="headerlink" title="对焦 AF/MF"></a>对焦 AF/MF</h2><ul><li>释放/对焦优先: 快门按钮释放时, 没有清晰对焦也会拍摄, 默认值<code>释放</code></li></ul><h2 id="胶片模拟"><a href="#胶片模拟" class="headerlink" title="胶片模拟"></a>胶片模拟</h2><p>X轴:  低饱和 <- -=""> 高饱和<br>Y轴:  色调柔和 <- -=""> 色调强烈<br><img src="/images/富士X100F/Tonality%20Hard.jpg" alt="Tonality Hard"></-></-></p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><p><img src="/images/富士X100F/x100f部件.png" alt="X100F部件"></p><h2 id="闪光灯选项"><a href="#闪光灯选项" class="headerlink" title="闪光灯选项"></a>闪光灯选项</h2><p><img src="/images/富士X100F/闪光灯功能设置.png" alt=""></p><p><img src="/images/富士X100F/闪光灯模式设置.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相机manual.TT350s闪光灯</title>
      <link href="/53.Photograph/%E7%9B%B8%E6%9C%BAmanual.TT350s%E9%97%AA%E5%85%89%E7%81%AF/"/>
      <url>/53.Photograph/%E7%9B%B8%E6%9C%BAmanual.TT350s%E9%97%AA%E5%85%89%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="📸-TT350s闪光灯使用说明"><a href="#📸-TT350s闪光灯使用说明" class="headerlink" title="📸 TT350s闪光灯使用说明"></a>📸 TT350s闪光灯使用说明</h1><p>@tag: #摄影 #闪光灯 #说明书</p><h2 id="闪光灯按键："><a href="#闪光灯按键：" class="headerlink" title="闪光灯按键："></a>闪光灯按键：</h2><p><code>Mode键</code>：</p><ul><li>短按 在Multi(频闪), TTL, M之间切换</li><li>长按 进入频闪, set设定 3 - 2Hz, 一共闪3次频率2Hz</li></ul><p><code>Sync键</code>：</p><ul><li>短按 进入高速模式, 闪光指数下降</li><li>长按 切换无线模式的: 无线主 / 无线从 / 机顶灯</li></ul><p><code>Slave键</code>：</p><ul><li>短按 设置无线的分组: A / B / C</li><li>长按 设置无线频道</li></ul><p><code>Zoom键</code></p><ul><li>短按 调节焦距（扩散板打开的情况下固定14mm）</li><li>长按<ul><li>AF ON（AF辅助闪光）</li><li>ST ON（自动休眠秒数）</li><li>BL ON（背光秒数）</li></ul></li></ul><h2 id="X1s-引闪器按键："><a href="#X1s-引闪器按键：" class="headerlink" title="X1s 引闪器按键："></a>X1s 引闪器按键：</h2><p><code>CH/OK</code>：</p><ul><li>短按 设置频道号0~32</li><li>长按 进入Fn设置, Fn00~Fn07, 按GR可以设置：<ul><li>Fn01 设置延迟</li><li>Fn04 频闪模式</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>胶片测光经验表</title>
      <link href="/53.Photograph/film.%E8%83%B6%E7%89%87%E6%B5%8B%E5%85%89%E7%BB%8F%E9%AA%8C%E8%A1%A8/"/>
      <url>/53.Photograph/film.%E8%83%B6%E7%89%87%E6%B5%8B%E5%85%89%E7%BB%8F%E9%AA%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>@tag: #摄影 #胶片</p><p>以下如果没有特殊说明, 默认是ISO200的胶卷, 快门速度250</p><p>室外：</p><ul><li>白天/晴朗: f16</li><li>白天/多云: f11</li><li>白天/阴影: f5.6, 接近日落,光线变弱的时候f4</li><li>白天/阴天: f4</li></ul><p>室内：</p><ul><li>白天明亮的室内: 参考室外阴天</li><li>灯光较暗(参考卧室): f1.8 快门30, 或者f1.8 快门15</li><li>灯光较亮(参考公司): f1.8 快门30或60(未测)</li></ul><p>夜间：</p><ul><li>夜间明亮的街道(南锣夜市): f1.8 快门30(未测)</li><li>夜间暗的街道(四环路灯): f1.8 快门15</li></ul><h1 id="阳光16法"><a href="#阳光16法" class="headerlink" title="阳光16法"></a>阳光16法</h1><blockquote></blockquote><p>艳阳16 阴天8<br>多云11 日暮4<br>阴云压顶5.6<br>雨天落雪同日暮</p><p>解释:<br>快门固定在胶片ISO的倒数，比如晴天日光下，光圈f16 + ISO200胶片 + 1/250快门（阳光16法只适用于春秋两季，如果夏季需要减少一档曝光，冬季提一档曝光）</p>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 胶片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宾得SPII使用说明</title>
      <link href="/53.Photograph/film.%E5%AE%BE%E5%BE%97SPII%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/53.Photograph/film.%E5%AE%BE%E5%BE%97SPII%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="http://www3.xitek.com/papers/xixi/spotmatic.htm" target="_blank" rel="noopener">SPOTMATIC历史</a></li><li><a href="http://www.butkus.org/chinon/pentax/pentax_spotmatic/pentax_spotmatic.htm" target="_blank" rel="noopener">在线说明书</a></li><li><a href="http://blog.sina.com.cn/s/blog_64822c3b0100r5fg.html" target="_blank" rel="noopener">M42镜头的光圈顶针</a></li><li><a href="https://site.douban.com/142843/widget/notes/6941749/note/202068292/" target="_blank" rel="noopener">美能达X-700说明</a></li></ul><p>卷片杆下面的拨盘没有实际作用，只是一个标记，方便记住当前用的什么胶卷（黑白/日光/灯光），还有一个窗能显示20/36的字样，大概是记录胶卷的张数吧，后面的<code>EX.</code> 是exposures的缩写。<br>向上提起卷片杆，胶卷舱门会打开。</p><blockquote><p>如何取出胶卷：</p><ol><li>相机底有一个按钮，要按下去才能倒片。按下去的时候不会听到声音，只是按下去后它不会自己弹起来。</li><li>然后拉出相机机顶左侧卷片杆，顺时针方向旋转。手感上会有明显的阻碍感，那是倒片把手带动胶卷暗盒内的片轴拉动整卷胶片回绕。</li><li>最后，当回绕的手感明显变得更顺滑时，胶片已经被回绕进胶卷暗盒。提起倒片把手弹开后背，取出胶卷。</li></ol></blockquote><p>与宾得Spotmatic SP相机配套的镜头名称是<code>Auto Takumar1：1.8/55 Ashahi Opt Co.</code>或<code>AutoTakumar 1：1.4/55 Ashahi OptCo.</code>。<br>该镜头最近调焦距离从0.45米至无限远，调焦手感较平滑。<br>镜头后部螺纹接口外缘有一选择拨动钮，将钮拨至露出“A”时，为自动式光圈，此时后部顶针发生作用。选择到使用的光圈时，光圈仍全开；压下顶针，光圈收缩；<br>将钮反方向拨动露出“M”时，为手动光圈，此时顶针脱离控制结构，光圈随设定收缩。</p>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 相机 </tag>
            
            <tag> 胶片 </tag>
            
            <tag> 说明书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/53.Photograph/bookmark-%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1/"/>
      <url>/53.Photograph/bookmark-%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.zhihu.com/question/19561587/answer/52648789" target="_blank" rel="noopener">如何拍摄夜晚的星空，需要做哪些准备工作？ - 知乎</a></li><li><a href="https://cn.guidetoiceland.is/the-northern-lights/northern-lights-pictures" target="_blank" rel="noopener">冰岛极光摄影|设备推荐、设置参数、常见问题 | Guide to Iceland</a></li><li><a href="https://www.zhihu.com/question/25695143" target="_blank" rel="noopener">极光的拍摄对于相机和镜头以及参数设置有哪些要求？ - 知乎</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/53.Photograph/bookmark-%E5%A6%82%E4%BD%95%E6%8B%8D%E5%A6%B9/"/>
      <url>/53.Photograph/bookmark-%E5%A6%82%E4%BD%95%E6%8B%8D%E5%A6%B9/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://zhuanlan.zhihu.com/p/23245505" target="_blank" rel="noopener">怎么拍妹子显瘦？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/38437324/answer/91925899" target="_blank" rel="noopener">旅行拍照穿的超好看（上镜）的衣服有哪些？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/19671417/answer/48429099" target="_blank" rel="noopener">拍照时怎样摆姿势好看？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/26954818/answer/36848459" target="_blank" rel="noopener">什么样的灯光和角度下人比较好看？ - 知乎</a></li><li>其他<ul><li><a href="https://www.zhihu.com/question/21422541/answer/73835499" target="_blank" rel="noopener">男性拍照时有哪些不错的姿势可以选择？ - 知乎</a></li><li><a href="https://www.zhihu.com/question/38478558/answer/126802534" target="_blank" rel="noopener">如何用手机拍出一张特别好看的自拍？ - 知乎</a></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/53.Photograph/bookmark-M43%E7%B3%BB%E7%BB%9F/"/>
      <url>/53.Photograph/bookmark-M43%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCO滤镜使用指南</title>
      <link href="/53.Photograph/VSCO%E6%BB%A4%E9%95%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/53.Photograph/VSCO%E6%BB%A4%E9%95%9C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>TLDR：</p><blockquote></blockquote><ul><li>A1： 胶片复古，绿色</li><li>A6：“非常适合人像，一定要试一试”</li><li>B2： 黑白，经典</li><li>B5~B6：黑白，情绪</li><li>C1： 海水、天空，粉色</li><li>E1~E2： 表现红色、蓝色</li><li>H1~H3： 多彩夏日</li><li>N1：    明亮的黄色，香蕉</li><li>S1~S3： Clean</li></ul><h2 id="A1-A3"><a href="#A1-A3" class="headerlink" title="A1-A3"></a>A1-A3</h2><p>A1 - A3 主打模拟胶片风格，提高了中间色调的同时有轻微过度曝光，色调比较柔和。官方使用了 Analog（模拟）、Archetype（典范）这两个词来命名，恰当概述了这三款滤镜，可以说是是拍摄肖像、室内和食物的完美选择。下面是这三款预设滤镜的参考作品：</p><p><img src="/images/VSCO/Melody%20Hansen%20Al.jpg" alt="Melody Hansen A"></p><h2 id="A4-A6"><a href="#A4-A6" class="headerlink" title="A4-A6"></a>A4-A6</h2><p>VSCO 这样形容 A4-A6 号滤镜：</p><blockquote><p>它尽可能保留了自然色调，同时带有轻微的色彩转换和褪色效果。</p></blockquote><p>A4 号滤镜对照片进行了一些褪色处理，并且增强了棕色的饱和度，给人一种略带温暖的感觉。A5 的褪色效果会更加强烈一些，红色通道被压低，整体给人一种酷酷的感觉。A6 貌似平淡无奇，但却赋予了照片清新简约的风格，漂亮的棕色的已经对肤色的友好，是我非常喜欢的一枚滤镜。</p><p><img src="/images/VSCO/15883415142043.jpg" alt=""></p><p>这三款滤镜的表现非常符合官方对它的设定。请尽量避免将其运用到色彩鲜艳的场景中，对于室内静物，食物以及一些北欧简约低调的场景都非常适合。另外，A6 款真的非常适合人像，一定要试一试。</p><h2 id="B-经典黑白"><a href="#B-经典黑白" class="headerlink" title="B 经典黑白"></a>B 经典黑白</h2><p>B 系列是黑白经典滤镜包，让照片在彩色和黑白之间起了微妙变化，其中 B1、B2 和 B3 官方使用了「Black &amp; White Classic（经典黑白）」命名，3 款滤镜对暗部细节表现十分优秀，适用于各种场景。下面是 B1、B2 和 B3 的参考样片：</p><p><img src="/images/VSCO/15883417420209.jpg" alt=""></p><p>B 系列中的另外三款黑白滤镜 B4、B5 和 B6 官方则使用了「Black &amp; White Moody」命名，即略显情绪化，从色彩上反映出些许忧郁。相比之下，这三款滤镜更适合于肖像，高对比度使细节充满了更多戏剧性的色彩。而当其用于景物时，也可以表现出更多的纹理。</p><p><img src="/images/VSCO/15883417673472.jpg" alt=""></p><h2 id="C1-C3-Vibrant-Classic"><a href="#C1-C3-Vibrant-Classic" class="headerlink" title="C1-C3 Vibrant Classic"></a>C1-C3 Vibrant Classic</h2><p>C1 会让画面的整体色调带上一层粉红色，白色区域会非常明显。同时使得蓝色偏青，这一点在拍摄晴朗天空等场景时会特别突出。由于对比度提升幅度大，C1 也容易造成阴影部分的细节损失。</p><p><img src="/images/VSCO/15883408321786.jpg" alt=""></p><p>C2 虽然也提升了画面的对比度，但同时也提升了画面的亮度。与此同时，C2 对画面的原有色调保留比较好，所以 C2 和 C1 的区别非常大。在光线不太好的地方，选择 C2 要比 C1 的效果好很多。但是，当光线本身较为充足时，C2 又容易导致亮部过曝。</p><p>C3 是这三枚滤镜中我最喜欢的，它对画面的对比度和亮度的影响介于 C1 和 C2 之间，相对比较普适。</p><p><img src="/images/VSCO/15883408510414.jpg" alt=""></p><h2 id="C4-C9-Chromatic"><a href="#C4-C9-Chromatic" class="headerlink" title="C4-C9 Chromatic"></a>C4-C9 Chromatic</h2><p>该系列主打中世纪模拟胶片色彩，柔和而又稳重的中性色调让人感觉很「静」，肖像或静物类照片使用这套滤镜，会有非常棒的效果。</p><p><img src="/images/VSCO/15883410198733.jpg" alt=""></p><blockquote><p>根据我使用一周的情况看来，这个系列在日常的适用情形比较少，效果感觉可以通过选择其他更常用的滤镜，配合参数微调达到近似效果，考虑到价格原因，我给出 三星（3/5）的评分，各位可参照示例图并对照平日自己的拍照风格来选用。</p></blockquote><h2 id="E-万用之选"><a href="#E-万用之选" class="headerlink" title="E 万用之选"></a>E 万用之选</h2><p>官方使用 Essence（本质）和 Archetype（原型）两个词来描述它。该系列色彩明亮而通透、丰富却不显艳丽的特点，适用场景广泛，可谓万用之选，相信你也会喜欢上这种色彩。下面带来 E 系列的参考作品：</p><p><img src="/images/VSCO/15883373450955.jpg" alt=""></p><p><img src="/images/VSCO/15883405969295.jpg" alt=""></p><p><img src="/images/VSCO/15883373810163.jpg" alt=""></p><h2 id="F-Mellow"><a href="#F-Mellow" class="headerlink" title="F Mellow"></a>F Mellow</h2><p>官方使用 Desaturated（欠饱和的）和 Understated（轻描淡写）来形容 F 系列的三款滤镜。<br>F1-F3：Mellow/Fade（柔和/淡色）。标签：低饱和度，肖像。低饱和度且颜色轻淡，F系列预设包用于展现出一种简洁。作为一个能保证表现出胶片品质的万能包，漂亮的肤色和宁静的日常生活是它的长项。F2会使图片偏蓝。 适合原本就很蓝色的照片。 比如海水。</p><p><img src="/images/VSCO/15883374256751.jpg" alt=""></p><h2 id="G-Portraits"><a href="#G-Portraits" class="headerlink" title="G Portraits"></a>G Portraits</h2><p>G 系列是一款人物肖像滤镜包，提供了出色的肤色处理效果。这三款滤镜适用于较为清新风格的人物照片，能使肌肤获得较为均匀而又明亮的着色效果。G1、G2 和 G3 可以说是每个摄影爱好者必备的滤镜。</p><blockquote><ul><li>G系列的滤镜能让图片变红。 特别是需要正红的颜色。</li><li>G1/G2和G3 : 肖像，拥有明亮的肤色，G1，G2和G3为所有肖像提供一个讨人喜欢的预设集合。</li></ul></blockquote><p><img src="/images/VSCO/15883377248720.jpg" alt=""></p><h2 id="H1-H3-多彩夏日"><a href="#H1-H3-多彩夏日" class="headerlink" title="H1-H3 多彩夏日"></a>H1-H3 多彩夏日</h2><p>H1 - H3 以 Polychrome Summer（多彩夏日）命名，微妙的粉色、黄色、紫色丰富表现出夏日时光的美好回忆。该系列擅长时尚潮流风格、生活或静物类的照片，是一个完美的通用滤镜包。</p><p><img src="/images/VSCO/15883402239315.jpg" alt=""></p><h2 id="H4-H6-多彩冬日"><a href="#H4-H6-多彩冬日" class="headerlink" title="H4-H6 多彩冬日"></a>H4-H6 多彩冬日</h2><p>H4 - H6 由 Polychrome Winter（多彩冬日）命名，采用更多的冷色调来营造出冬季的梦幻色彩。该系列对拍摄时尚、生活和静物类的照片表现优异，同样也是一个完美的通用滤镜包。</p><p><img src="/images/VSCO/15883402732289.jpg" alt=""></p><h2 id="K-深红"><a href="#K-深红" class="headerlink" title="K 深红"></a>K 深红</h2><p>K 系列基于经典的柯达彩色胶卷，色彩明亮而深红。K 系列虽然仅 K1、K2、K3 三款滤镜，但都非常经典，适合各种场景。我猜测 VSCO 之后会继续扩充 K 系列。下面是这三个滤镜的参考作品：</p><p><img src="/images/VSCO/15883401388694.jpg" alt=""></p><h2 id="M-情绪"><a href="#M-情绪" class="headerlink" title="M 情绪"></a>M 情绪</h2><p>M 即取自于英语单词 Mood（情绪）的首字母，稍微褪色和曝光不足表现于 M1、M2、M3 之中。夸张的棕色和绿色使这个滤镜包搭配自然景观最好，适用于静物及较为广阔的环境照片。</p><p><img src="/images/VSCO/15883400433369.jpg" alt=""></p><p>M4、M5、M6 表现出来的微妙褪色感来源于 70 年代的复古色调，这三款滤镜是用于城市环境和肖像照片的理想之选。下面是参考作品：</p><p><img src="/images/VSCO/15883400843239.jpg" alt=""></p><h2 id="N-现代"><a href="#N-现代" class="headerlink" title="N 现代"></a>N 现代</h2><p>N1 - N3 主打时尚的艺术气息，色彩明亮同时又富有冲击力。当你拍摄这种风格的照片时，能得到非常棒的效果。官方使用了 New Modern（现代），Lights（光亮）这两个词来命名这三款滤镜。下面是参考作品：</p><p><img src="/images/VSCO/15883399328967.jpg" alt=""></p><h2 id="P-胶片电影"><a href="#P-胶片电影" class="headerlink" title="P 胶片电影"></a>P 胶片电影</h2><p>P 系列是有三部分组成，包含 P1- P9，共 9 个滤镜，主打胶片电影效果。其中 P1、P2、P3 是暖色调，模拟了温暖、奶油似的色彩和流行的胶片电影效果。适用于食物、时尚和日常生活拍摄的照片。下面 6 幅作品作为这三个滤镜的参考：</p><p><img src="/images/VSCO/15883397290595.jpg" alt=""></p><p>同系列下的冷色包由 P4、P5、P6 组成，充满着冷色调以及稍许褪色效果的三个滤镜，模拟出了非常棒的胶片电影效果，偏蓝的冷色调能广泛适用于各种景物照片。</p><p><img src="/images/VSCO/15883397544358.jpg" alt=""></p><h2 id="S-Clean"><a href="#S-Clean" class="headerlink" title="S Clean"></a>S Clean</h2><p>S 系列（S1 - S6）应该是大部分人使用频率最高的系列之一了，其中，S1、S2、S3 提供了明亮而干净的滤镜效果，这三款滤镜因具有较高的亮度，可以将人物肤色表现得非常完美，在搭配肖像照片或背景色较淡的场景照片时，可以达到最优效果。下面是这三款滤镜的参考作品：</p><p><img src="/images/VSCO/15883394504350.jpg" alt=""></p><p>另三款 S4、S5、S6 明亮且色彩更加温暖，充满了夏天的氛围。温暖的橙色和黄色色调非常适合于画面表现活跃的肖像画，有一种沐浴在阳光下的感觉。</p><p><img src="/images/VSCO/15883394732082.jpg" alt=""></p><h2 id="T-忧郁-暗调"><a href="#T-忧郁-暗调" class="headerlink" title="T 忧郁-暗调"></a>T 忧郁-暗调</h2><p>T 系列强烈的褪色效果带有轻微的情绪化，以较高的灰度、丰富的戏剧性般的色调作为补充。T1、T2 和 T3 滤镜将这种气氛带入到一些包含自然环境和光线较暗的照片之中，灰蒙蒙的感觉增添了照片些许神秘感，适合一些纯自然环境的照片和整体不是特别明亮的照片。</p><p><img src="/images/VSCO/15883391308379.jpg" alt=""></p><p><img src="/images/VSCO/15883391473152.jpg" alt=""></p><h2 id="X-黑白褪色"><a href="#X-黑白褪色" class="headerlink" title="X 黑白褪色"></a>X 黑白褪色</h2><p>X 系列也同属于黑白滤镜，作为 B 系列的补充。其中， X1、X2 和 X3 官方使用了「Black &amp; White Heavy Fade」命名，表现出强烈的黑白色调，并稍带褪色感。使用这三款滤镜之后，画面会略显粗糙感，其灰色色调也充满了强烈的戏剧色彩。这几款滤镜质量高，广泛适用。</p><p><img src="/images/VSCO/15883389888598.jpg" alt=""></p><p><img src="/images/VSCO/15883390436236.jpg" alt=""></p><p>X4、X5 和 X6 官方则使用了「Black &amp; White Light Tone」命名，即表现黑白色调的同时，质感较轻。柔和而略显活跃的色调，使这三款滤镜更接近于自然。同时大胆的提供了浓淡双色版本， 适用于各种场景，不要错过如此经典的滤镜包。</p><p><img src="/images/VSCO/15883395145970.jpg" alt=""></p><p><img src="/images/VSCO/15883395310420.jpg" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://sspai.com/post/27883" target="_blank" rel="noopener">VSCO Cam 滤镜包详解及购买指南（一） - 少数派</a></li><li><a href="https://sspai.com/post/27885" target="_blank" rel="noopener">VSCO Cam 滤镜包详解及购买指南（二） - 少数派</a></li><li><a href="https://sspai.com/post/28017" target="_blank" rel="noopener">VSCO Cam 滤镜包详解及购买指南（三） - 少数派</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> VSCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F71.202204-离岸人民币对美元升破6.6</title>
      <link href="/52.Financing/F71.202204-%E7%A6%BB%E5%B2%B8%E4%BA%BA%E6%B0%91%E5%B8%81%E5%AF%B9%E7%BE%8E%E5%85%83%E5%8D%87%E7%A0%B46.6/"/>
      <url>/52.Financing/F71.202204-%E7%A6%BB%E5%B2%B8%E4%BA%BA%E6%B0%91%E5%B8%81%E5%AF%B9%E7%BE%8E%E5%85%83%E5%8D%87%E7%A0%B46.6/</url>
      
        <content type="html"><![CDATA[<p>汇率的三元悖论：@link: <a href="/52.Financing/F29.蒙代尔不可能三角/" title="F29.蒙代尔不可能三角">F29.蒙代尔不可能三角</a></p><p><a href="https://www.zhihu.com/question/519753736/answer/2383355227" target="_blank" rel="noopener">人民币对美元汇率逼近 6.2 元时代，这意味着什么？ - 知乎</a><br>3月3日，中国人民银行授权中国外汇交易中心公布，2022年3月3日银行间外汇市场人民币汇率中间价为：1美元对人民币6.3016元，较上一交易日提升335个基点。此外，在岸人民币、离岸人民币对美元汇率处于6.32关口。</p><p><a href="https://www.zhihu.com/question/517305926/answer/2358340793" target="_blank" rel="noopener">离岸人民币对美元升破 6.32 关口，创 2018 年 5 月来新高，说明什么？ - 知乎</a></p><p><a href="https://finance.sina.com.cn/money/forex/forexroll/2021-11-24/doc-iktzscyy7513148.shtml" target="_blank" rel="noopener">中国外汇 | 李晓：后布雷顿森林体系的国际货币格局|美元<em>新浪财经</em>新浪网</a></p><ul><li>1971年8月15日美国关闭黄金兑换窗口、布雷顿森林体系（美元与黄金挂钩）走向崩溃</li><li>布体系瓦解后，美元体系接管：由美元发挥关键货币功能，即美元在国际贸易、投资计价结算中居主导地位，在全球官方储备和金融资产中居领先地位，在全球信用周转体系中居核心地位的国际货币体系。现阶段的美元体系主要依靠三个机制来运行。<ul><li>第一，石油交易的美元计价机制</li><li>第二，商品美元还流机制。</li><li>第三，美国对外债务的本币计价机制。<br>美元体系给世界带来的风险与成本：</li></ul></li><li>美元体系日愈具有自利性，其给世界带来的风险与成本日益增加，美元汇率的周期性波动甚至成为触发许多国家和地区货币金融危机的重要因素。</li><li>面临着日益上升的通货膨胀压力，美联储正在酝酿退出宽松政策。虽然其具体操作节点与进程尚未明确，但注定将给世界，尤其是新兴经济体的货币与金融稳定带来新一波巨大冲击。</li></ul><h2 id="人民币汇率破6-3"><a href="#人民币汇率破6-3" class="headerlink" title="人民币汇率破6.3"></a>人民币汇率破6.3</h2><p><a href="https://mp.weixin.qq.com/s/8U-QdwC4I2VgDBo74k843g" target="_blank" rel="noopener">人民币贬值，跟美元 &amp; 疫情有关系？</a></p><ul><li>导致RMB贬值的原因：<ul><li>美联储加息，流通的美元减少，导致升值</li><li>国内因为疫情出口下降，间接导致RMB贬值</li></ul></li><li>央行应对措施：<ul><li>降低“外汇准备金”：可以提供借贷的外汇（$美元）增加，流通的美元增加…</li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/506999784" target="_blank" rel="noopener">人民币贬值真的会促进中国经济增长吗？ - 知乎</a></p><ul><li>如果汇率下跌利好经济，央行为何还要下调外汇存款准备金率？：央行决定从5月15日起，下调外汇存款准备金率1个百分点，由现行的9%下调至8%。截至3月末，我国外币存款余额1.05万亿美元。将外汇存款准备金率下调1%，意味着外汇市场可以增加105亿美元的供给能力。央行这次“下调”，是在离岸人民币对美元汇率短短五个交易日贬值超过3%的形势下紧急释放的外汇政策。政策的即时后果反映了政策的意图。消息落地后，离岸人民币拉升超过200个基点，升破6.58关口；4月25日一度跌破6.57关口的人民币对美元即期汇率，接连收复6.57、6.56关口，升至6.55。</li><li>RMB贬值带来的影响：<ul><li>对出口无利好，比如从出口来讲，东南亚走出疫情，制造业迅速恢复产能，以更低的价格截留我们的出口订单。美元和大多数发达国家，开始转向货币紧缩周期，抑制消费，减少了对中国商品的总需求。这两个因素实际上将抵消一部分甚至大部分人民币汇率下降所带来的出口价格下降的竞争优势。</li><li>放大输入性通胀：特别是在目前因为俄乌战争，能源和大宗商品价格持续高位的形势下，再叠加人民币汇率贬值的影响，输入性通胀的影响将变得更为可怕。</li><li>加重我们的外债负担：汇率下跌，一方面会增加我们的外债本金，同时还推高外债利率。</li><li>加剧资本外流：在美联储不断释放加息预期，但我们开始转向实施适当宽松的货币政策之后，海外投资者再次选择转向西方市场，对我们的债券、证券需求开始下降，对我们的投资冲动开始消退。</li><li>刺破资产泡沫。汇率贬值会导致资产缩水，这是基本常识。人民币贬值在重估GDP的同时，还会导致价格高估、泡沫较大的资产价格破裂，这对于房地产业是一个极其不利的消息。因为人民币大幅贬值，国内外游资将抛售人民币资产，转换为美元资产，中小城市的房价会率先下跌，随后也会轮动到大城市的房价下跌。</li></ul></li></ul><p><a href="https://www.zhihu.com/question/461394272/answer/2377724977" target="_blank" rel="noopener">当初人民币的汇率破7大家都十分关注，现在人民币汇率到达了6.3，会有什么影响吗？ - 知乎</a><br>从经济学常识来讲，汇率的形成，影响的主要因素涉及到 <em>货币发行量、外债规模、外汇储备规模，进出口规模，外资对我国的直接投资和人民币对外直接投资</em>。一直以来，我们的汇率实际上并非按这些因素所导致的对人民币和外汇的需求变化通过供求市场来形成，主要还是央行控制下的汇率。不过最近这些年，央行通过汇率改革，从直接控制进化为间接控制，即改为通过控制换汇交易来影响汇率的形成。</p><ul><li>改革开放阶段：我们开始用货币灌水的手段发展经济。刚开始的时候，我们增发人民币，M2还是挂钩我们的外汇储备规模的。毕竟只要有汇率这东西存在，你本币的M2如不和外汇储备挂钩，一旦有人做空本币，那就非常危险了</li><li>2005-2014：受制于房地产成为了支柱产业和经济发展核心推动力的政策，人民币发行脱离了外储的制约，成为房地产规模急剧扩张的推手。2005-2014这十年，M2与外汇储备保持着4:1左右比较稳固的联系，2015年开始，M2与外储的关系开始失去控制，但和商品房销售额建立了稳定的关联，M2与商品房销售额保持着12.5:1的稳定联系。<em>在M2为了适应房地产扩张的需要而同步扩张的时候，我们的外汇储备并未同步跟上扩张的步伐</em>。 一边为了应对房地产的迅速扩张，货币供应量不得不大幅度增加。外债的增长、M2的增速、GDP的增速，都基本上以接近外汇储备2倍速增长，这意味着什么？为什么经济高速增长，外汇储备却相形见绌？因为中国外汇净收入(<code>出口-进口+海外投资盈利+外来投资-外来投资盈利+入境外国游客-本国出境游+国民接收海外汇入-国民境内汇出</code>)的增幅，完全跟不上外债和M2扩张的步伐。前年、去年，我们开始提住房不炒的时候，央行肯定就意识到，一旦房价走低，房地产规模缩小，房地产会严重影响经济走疲，反过来刺激经济，又必须增发 m2。但现在m2不仅已经失去了房地产的联系，又失去了外储的依靠，同时低规模的外储也无法做M2的依靠，因为外储的增速肯定无法追赶M2的脚步，毕竟M2与外储的比例，已经从2010年的25:1，如脱缰的野马，迅速扩大73:1了</li></ul><blockquote><p><em>M1-M2同比增长率的差值</em>是股市资金供应的一个指标之一 若M1-M2的差值不断变大，说明存款活期化，企业和居民交易活跃，经济景气度上升。若M1-M2的差值不断变小，则表明企业和居民选择将资金以定期的形式存在银行，未来可选择的投资机会有限，多余的资金开始从实体经济中沉淀下来，经济运行回落。 货币供应与股市之间的实证关系表明，M1-M2差值与上证指数呈现较为明显的正向关系。M1-M2差值的拐点对股指有指示作用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F71.202204-中美国债利差倒挂</title>
      <link href="/52.Financing/F71.202204-%E4%B8%AD%E7%BE%8E%E5%9B%BD%E5%80%BA%E5%88%A9%E5%B7%AE%E5%80%92%E6%8C%82/"/>
      <url>/52.Financing/F71.202204-%E4%B8%AD%E7%BE%8E%E5%9B%BD%E5%80%BA%E5%88%A9%E5%B7%AE%E5%80%92%E6%8C%82/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="onenote:https://d.docs.live.net/80b0141f307a273d/文档/Scriptorium/Finance.one#4月：中美国债利差出现倒挂&amp;section-id={B2BD8B93-3A4A-461E-BD19-E438AD33E29C}&amp;page-id={12A13A7D-E432-4E61-90AB-CCB7437E8F8D}&amp;end" target="_blank" rel="noopener">2022年4月：中美国债利差出现倒挂</a></p><p>有关债券的收益率，简单来说是当债券买少卖多，债券价格下跌，但是债券收益率上涨。有关债券的票面利率参考<a href="/52.Financing/F33.债券/" title="F33.债券">F33.债券</a> 中债券的票面利率和到期收益率的部分。</p><p>我们提起（国债）收益率倒挂，有两种情况：</p><ol><li>久期长的国债收益率 &gt; 久期短的国债 // 可能的原因：投资者不看好短期市场，会购买长期国债，长期国债的收益降低</li><li>中美国债收益率倒挂（自2010年起，中债收益率都高于美债，22年以来，美债收益率持续上升，中美利差收窄，4月美债收益率超过中债） 这里说的是10年国债，进入2022年后，美国的3年债，2年债，10年债收益率先后超过中国。为什么中国国债收益率&gt;美债才是“正常情况”？因为过去四十年大多数时间，中国经济增长率更高，说明国内（非国债）投资的收益高，国债要给出更高的利率才能卖出去</li></ol><h2 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h2><p>比如说2019年8月14日，美国1年期国债收益率为1.79%，2年期为1.57%，十年期国债收益率为1.56%，期限越长收益率反而越低，而且这是2007年以来的首次。</p><p>国债收益率倒挂原因有两个，一个是经济中的流动性不足，直接推高了短期利率；第二是人们不看好未来，避险情绪高涨，对久期长的国债给出了不合常理的高价，直接拉低了久期长的国债收益率。</p><p>通常国债收益率倒挂是经济危机的前兆。<br>2000年7月，美国出现国债收益率倒挂，2001年美国出现经济衰退。<br>2006年8月，美国出现国债收益率倒挂，2008年全球经济危机来临。<br>2019年8月，美国出现国债收益率倒挂，2020年美国和全球经济出现严重衰退，当然这次的直接原因是新冠疫情</p><h2 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h2><p>中美国债利差收窄甚至倒挂：</p><ol><li>倒挂产生的原因</li><li>会有什么影响？</li></ol><p>➤产生原因：</p><ul><li>投资者对美国长期经济不看好，抛售国债，导致国债价格↓，收益率↑（可能）</li><li>美联储“缩表”，抛售国债 or 终止国债再投资，导致国债价格↓，收益率↑（可能）</li><li>中国国内疫情影响，股市下跌，投资者更倾向于购买国债躲避风险，导致国债价格↓，收益率↑</li></ul><p>“美联储缩表”参考: <a href="/52.Financing/F22.美联储-宏观调控手段/" title="F22.美联储-宏观调控手段">F22.美联储-宏观调控手段</a></p><p>➤影响：</p><ul><li>美债收益率上行，会降低A股股息率的吸引力；同时美债收益率上行导致美股下跌（有人认为中美利差倒挂是美国经济衰退的预兆），市场风险偏好下降，对A股产生传染效应</li><li>美债收益率上行，会降低人民币资产吸引力。今年2、3月份，外资连续净减持人民币债券803亿和1125亿元，其中分别净减持人民币国债354和518亿元，均连创新高。（但这可能不完全是利差因素所致，最近这波外资流出背后的原因或是，2月份俄乌冲突不断升级，地缘政治风险外溢，以及3月中下旬以来国内疫情多点散发，经济复苏前景不明，市场避险情绪上升）</li><li>中美利差收紧，隐含了美联储加息预期，可能对中国货币政策产生一定制约。</li></ul><p>➤ 中美国债利差和A股的相关性: 来源：<a href="https://www.touzid.com/compare/index.html#/edit-3213" target="_blank" rel="noopener">https://www.touzid.com/compare/index.html#/edit-3213</a></p><blockquote><p>自2010年开始，中美利差（褐色）一直都是正的（中国债收益&gt;美国债收益），当利差收紧时，A股走势大概率下行</p></blockquote><p><img src="/images/20220505162430.png" alt=""></p><h2 id="国债收益率"><a href="#国债收益率" class="headerlink" title="国债收益率"></a>国债收益率</h2><p><a href="https://www.zhihu.com/question/47382711/answer/2418290388" target="_blank" rel="noopener">美国10年期国债收益率上升和下跌意味着什么？这里的原理是什么啊？还有离岸人民币汇率代表什么啊？ - 知乎</a><br>国债收益和价格关系：</p><ul><li>期限：比如十年国债，十年后可以收回本金。一般来说久期越长的债券票面利率越高。</li><li>票面利率：比如票面价值￥100、利率5%的十年国债，每年可以获得5%的利息，十年后可以取回本金</li><li>票面价值：类似股票，卖出的多就越便宜<br>国债收益率如何浮动：<br>例如十年国债，票面价格100，利率5%，假如经济很好，大家都跑去股市投资去了，进入债市的钱少，那么国债拍卖的时候，人们愿意出的价格是95，收益率：[（150-95）/95]/10=4.29%=<strong>5.8%</strong>。</li></ul><p>引起国债收益率变化的原因可能有：</p><ul><li>发行的国债太多，or被抛售国债太多，国债价格下降，收益率提高 (待确认)</li><li>“美国财政部宣布购买更多长期国债，从而协助美联储压低长期利率”。怎么操作的呢？就是：<strong>购买更多长期国债→市场上长期国债的数量减少→长期国债的价格上升（溢价）→收益率下降。</strong></li><li>比如川普通过减税方式让资金回流美国，但产业没有跟着回流，大企业资金无处可去，于是大规模回购本公司的股票，资金还是无处可去，因为美国经济没有足够的产业吸纳回流的资金（产业还是更愿意往东南亚等地转移）。资本只能购买国债，导致：购买更多长期国债→市场上长期国债的数量减少→长期国债的价格上升（溢价）→收益率下降。</li><li>股市收益高，投资者更不愿购买国债，国债价格降低，收益率提高 (待确认)</li></ul><p><img src="/images/20220505162353.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F71.202204-A股见底了吗</title>
      <link href="/52.Financing/F71.202204-A%E8%82%A1%E8%A7%81%E5%BA%95%E4%BA%86%E5%90%97/"/>
      <url>/52.Financing/F71.202204-A%E8%82%A1%E8%A7%81%E5%BA%95%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h2 id="如何判断A股估值是否到底了？"><a href="#如何判断A股估值是否到底了？" class="headerlink" title="如何判断A股估值是否到底了？"></a>如何判断A股估值是否到底了？</h2><p>@tldr：一些可能有用的指标</p><ul><li>大盘指数的三个量：PE百分位%、股价、交易量 - by【4.25重挫8%，见证历史 - 芝Sir】见下文↓</li><li>股债收益差： 宽基指数E/P - 国债收益率（看收益差的百分位，越高意味着越被低估）<ul><li>另外参考 <a href="/52.Financing/F33.债券/" title="F33.债券">F33.债券</a> 中关于“国债收益率在资产配置中的使用”</li></ul></li><li>格雷厄姆指数：一般用宽基指数E/P ÷ 国债收益率 （大于2意味着股市非常低估）// @ref <a href="/52.Financing/F23b.市场估值指标/" title="F23b.市场估值指标">F23b.市场估值指标</a></li><li>融资融券余额：这里应该比较增速差，反映市场的多空情绪 // @ref: 融资融券</li><li>现在是政策底、情绪底、市场底的哪一个底？见下文↓</li><li>流动性：新增社融增量增加（可能更多的和经济情况相关，但经济预期差，股市也不会好）<a href="/52.Financing/F23a.社融和M2/" title="F23a.社融和M2">F23a.社融和M2</a></li><li>通过宏观经济指标：<ul><li>铜油比、金铜比、金铜比…宏观经济研究员们创造的一个又一个指标 <a href="/52.Financing/F34.期货/" title="F34.期货">F34.期货</a></li><li>中美利差收窄甚至倒挂，这些指标更多的是一个宏观经济的预期，对股市有间接影响</li><li>美元指数：美刀作为避险资产，一般来说指数走强很大概率意味着全球经济“可能衰退”，或者有局部战争</li></ul></li><li>以及 <a href="https://finance.sina.com.cn/stock/stockzmt/2022-04-13/doc-imcwiwst1520773.shtml" target="_blank" rel="noopener">中金|先发制人：A股左侧择时指标探讨|先发制人<em>新浪财经</em>新浪网</a>提到的几种左侧择时指标：估值百分位、股权风险溢价（股债收益差）、期权认沽认购比、融资融券增长比、中国波指（50ETF恐慌指数, VIX）、北向资金、前后成交额差异…</li></ul><h2 id="政策底、情绪底、市场底、盈利底"><a href="#政策底、情绪底、市场底、盈利底" class="headerlink" title="政策底、情绪底、市场底、盈利底"></a>政策底、情绪底、市场底、盈利底</h2><p><a href="https://fund.eastmoney.com/a/202204132341057942.html" target="_blank" rel="noopener">政策底、情绪底、市场底 你都搞清楚了吗？_天天基金网</a></p><p>政策底、情绪底、市场底什么是：</p><ul><li>政策底主要是指在市场持续下跌时，政府出台一系列组合拳“救市”。一般来说，“政策底”的确认通常伴随着政策组合拳的持续出台，包括货币政策、财政政策和资本市场相关政策。政策落地，往往货币宽松先行，而财政政策和资本市场政策的持续发力是构筑“政策底”的重点。</li><li>情绪底”，就是指市场主要投资者对于市场后续走势已经极度悲观，说简单点就是大家对后市不看好，已经不想再“买买买”了。情绪底虽然比较难量化，但我们也可以根据一些数据来跟踪。比如证券市场新增开户人数和<em>公募基金新发认购情况</em>。</li><li>市场底，是指市场在一段时间内下跌趋势走完后，形成的一个低点指数，它是过去一段时期内真正的最低指数。</li><li>盈利底，伴随着经济下行，不同行业的龙头企业在该季度的盈利都不甚理想，当季度财报（不佳）陆续公布时，还会有一次下跌。</li></ul><p>从A股历次筑底行情统计来看，市场一般呈现“政策底—市场底—盈利底”的时间规律：<br>回看市场发现，“政策底”通常领先于“市场底”1.5-3个月：<br>2008-2009年“政策底—市场底—盈利底”分别出现在2008年9月、10月和2009年3月；<br>2015-2016年“政策底—市场底—盈利底”分别出现在2015年7月、8月和2016年6月；<br>“市场底”不一定领先于“盈利底”：2012年盈利底早于市场底3个月；2018年盈利底与市场底同步。(资料来源：《华西证券李立峰：A股历次筑底有何特征？》)</p><hr><p>熊市三阶段：</p><p>熊市第一阶段：少数投资者对经济和企业盈利的前景能否维持产生怀疑。过高的估值或信贷的收紧驱动产业资本的减持。边际减仓驱动的下跌。</p><ul><li>熊市第二阶段：经济和流动性的趋势性恶化，伴随一些长期的制度性的担心，使得投资人系统性普遍性的主动避险减仓。</li><li>熊市第三阶段：带止损线的资金，带杠杆的资金，资产管理的资金，因为止损、爆仓、赎回，被迫抛售。// <strong>“杠杆底”</strong>：<br>熊市第四阶段：大部分投资人信心依然脆弱，盈利依然下行。但市场不再趋势下跌，转为震荡企稳。</li></ul><p>但从中长期来看，有两个数据是判断大a股基本面的较好的参考指标。一个是PMI，一个是A股累计归母净利润增速。@ref: 半夏投资李蓓： <a href="https://mp.weixin.qq.com/s/CartYlNnGXXziwzni3rYbg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CartYlNnGXXziwzni3rYbg</a></p><hr><p><a href="http://mp.weixin.qq.com/s?__biz=MzUxNDQ0ODY4Ng==&amp;mid=2247483863&amp;idx=1&amp;sn=ec8e5162bfb4a92249502b86571666ea" target="_blank" rel="noopener">4.25重挫8%，见证历史 - 芝Sir</a><br>见底的三个特征：</p><ul><li>价格跌幅大</li><li>估值新低：</li><li>成交量低：<code>成交额缩小到近一年的50%-60%左右</code> or <code>成交额回到上一轮牛市刚启动的水平</code></li></ul><blockquote><p>近5日的日均成交额是8213亿元，近一年的日均成交额是10655亿元，而2019年2月上旬牛市刚启动的成交额约4000-5000亿元，</p></blockquote><p>那具备两个特征，少了一个会怎么样呢？有两种可能性：</p><ul><li>第一种短期内开启一波反弹行情，但不是大行情，类似2015年9月或者2016年2月的状态。</li><li>第二种接着缩量，直到缩量特征满足，之后直接开启下一轮大行情。</li></ul><h2 id="新增社融增量"><a href="#新增社融增量" class="headerlink" title="新增社融增量"></a>新增社融增量</h2><p>▷ 社融数据：<br>新增社融增速（以六个月移动平均为计算标准）有40个月左右的周期运行规律。每隔40个月左右新增社融增速会转正并加速上行进入到上行周期，随着新增社融增速转正并进入上行周期，A股也将开启两年半的上行周期。当然到新增社融增速转负之后，A股表现将会更加平淡，甚至不排除有出现回撤的可能，如此一来A股存在三年半左右的周期运行规律。</p><p>@ref: <a href="https://wallstreetcn.com/articles/3651779" target="_blank" rel="noopener">新增社融增速转正与A股转机 - 华尔街见闻</a><br><img src="/images/20220505162933.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F59.凯利公式</title>
      <link href="/52.Financing/F59.%E5%87%AF%E5%88%A9%E5%85%AC%E5%BC%8F/"/>
      <url>/52.Financing/F59.%E5%87%AF%E5%88%A9%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>约翰·拉里·凯利出生于1923年12月26日，二战期间凯利到了法定服役年龄，在海军航空部队当了4年飞行员，曾是二战期间的王牌飞行员。1953年他获得了物理学博士学位，博士论文题目为“不同材料的二阶弹性研究”，这项研究非常重要，使得凯利收到了贝尔实验室的工作邀请。这样30岁的凯利来到了贝尔实验室工作</p></blockquote><p><img src="/images/IMG20220915-1.png" alt=""><br>该公式最早于1956年由物理学家约翰·L·凯利在《贝尔系统技术期刊》中发表，可以用来计算一个在期望净收益为正的独立重复赌局中，使本金长期增长率最大化的投注资金比例。</p><p><img src="/images/IMG20220915-2.png" alt=""></p><p><strong>玩一个设定对你有利的游戏</strong><br>假设现在有一个公平的投资游戏，获胜和失败的概率都是50%。如果获胜，玩家的收益率是40%；如果失败，玩家会亏损30%。<br>对于一个理性人来说，他一定会选择参加这个游戏，并且把这个游戏重复下去。<br>为什么呢？因为单次游戏的期望收益是正数，也就是说，游戏的设计对他是有利的。<br>举个例子，玩家投入1元钱，那么获胜可以取得<code>1*(1+40%)=1.4</code>元，而失败可以拿回<code>1*(1-30%)=0.7</code>元，这两种情况出现的概率都是50%，所以进行一次游戏后，玩家资产的期望是<code>1.4*50%+0.7*50%=1.05</code>元。玩家净赚0.05元，收益率5%。</p><p>在这样的情况下，如果初始资金是1元，游戏将重复100次，我们应该如何分配每次投资的仓位呢？<br>肯定会有朋友认为，既然单次游戏的结果这么有利，那岂不是投得越多，赚得越多？我每把都全仓梭哈不就好了吗？<br>——全仓梭哈会怎么样呢？<br>由于胜率是50%，出手100次，那么获胜的期望次数是50次，失败的次数也是50次，按此假定（当然实际情况可能会有差异）。则玩家最终的资产是：</p><p><img src="/images/IMG20220915-3.png" alt=""></p><p>说到这里，也许有的朋友还是不能理解，这看似优势满满的设定，是如何在全仓梭哈的过程中蚕食掉我们的资产的呢？<br>因为全仓梭哈的玩家，就类似于一个赌徒，将自己过多的暴露在了“极端风险”当中，“十赌九输”也并不是一句玩笑话。<br>为了便于理解，我们不妨举个更极端的例子</p><p>如果用凯利公式，可以算出收益最大的下注比例是40%</p><p><img src="/images/IMG20220915-4.png" alt=""></p><p>@ref： </p><ul><li><a href="https://xueqiu.com/9322843818/166347039" target="_blank" rel="noopener">与友漫谈——什么是凯利公式 - 雪球</a></li><li><a href="https://xueqiu.com/3951090421/222138868" target="_blank" rel="noopener">还不重视仓位管理？看似小事，却可以决定你的投资收益率- 雪球</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F52n.ETF网格</title>
      <link href="/52.Financing/F52n.%E7%BD%91%E6%A0%BC%E4%BA%A4%E6%98%93%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F52n.%E7%BD%91%E6%A0%BC%E4%BA%A4%E6%98%93%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="ETF网格总结"><a href="#ETF网格总结" class="headerlink" title="ETF网格总结"></a>ETF网格总结</h2><ul><li>网格的买入方式决定了只适合手里有一定存量资金的, 网格交易是价格碰到格子就触发交易, 如果短期变化很大(多次触格)会有多次资金投入, 定投只是每月发工资了就投;</li><li>网格的局限性: 只适合有幅度的震荡行情:<ul><li>如果是长期熊市, 会很快用完资金, 并被套住;</li><li>如果是长期牛市, 网格又不能非常好的提高收益(单边上涨时, 每上升一格就卖出一部分, 相比按照PE分批止盈的方式盈利更差)</li><li>如果长期横盘(震荡幅度不大, 很少触到网格), 资金利用率会很低</li><li>如果股价上or下穿破网格, 需要重新调整网格和数值</li></ul></li></ul><p>ETF网格构建工具 =&gt; <a href="https://hushicai.github.io/ETF/" target="_blank" rel="noopener">ETF网格计算器</a></p><h2 id="网格交易法（双向）"><a href="#网格交易法（双向）" class="headerlink" title="网格交易法（双向）"></a>网格交易法（双向）</h2><p>➤ <a href="https://www.zhihu.com/question/39851961/answer/2369449424" target="_blank" rel="noopener">不知道哪位交易员可以解释下网格交易法？ - 秦KK的回答 - 知乎</a></p><p><img src="/images/20220404231924.png" alt=""></p><p>先看上涨情形:</p><ul><li>每次到达一个新格, 就开一个多单(绿)+一个空单(红)</li><li>上涨到达B的格子时, 首先平掉A的盈利, 然后在B处开一个多单+一个空单</li><li>上涨到达B的格子时, 首先平掉B的盈利, 然后在C处开一个多单+一个空单</li><li>当股价达到定点C的时候, 如下图:<br><img src="/images/20220404230124.png" alt=""></li></ul><p>当股价下跌时:</p><ul><li>当从C跌回B, 把刚刚平掉的多单补回来, 同时卖掉C点的空单(红)</li><li>…<br><img src="/images/20220404230914.png" alt=""></li></ul><p><img src="/images/20220404232058.png" alt=""></p><p>➤ <a href="https://www.zhihu.com/question/39851961/answer/86308750" target="_blank" rel="noopener">不知道哪位交易员可以解释下网格交易法？ - 知乎</a><br>信息论之父申农在黑板上给大家演示：任何一个价位买进资金的50%，也就是说资金数量：股票市值=50%：50%。股票价格上涨一定幅度就卖出一部分股票，保持剩余的资金数量：剩余股票市值=50%：50%；反之股票价格下跌一定幅度，就用剩余资金买进一部分股票，始终保持剩余资金数量：剩余股票市值=50%：50%。用这个办法来对付股票价格的随机走势，长期交易是盈利的。他在十多年的交易生涯中，资金获得了29%的年复利增长。50岁后因为得了老年痴呆症，交易战绩没能延续。我在这里暂且称上面使用的交易数学模型为“等比例仓位模型”—-事实上，50%完全可以是其他的百分比数值。</p><p>➤ <a href="https://h5.1234567.com.cn/app/news/?code=202111082173305075" target="_blank" rel="noopener">指数基金买卖网格交易 具体如何操作？ 天天基金</a></p><ul><li>哪些指数更适合网格交易？ 近2年来，年化波动率超过25%的行业指数和宽基指数，它们的年化波动率和收益率相对更优，对比观察发现，休闲服务、有色金属、电气设备、创业板指等主流行业表现突出，投资者可尝试进行网格交易。</li></ul><p>➤ <a href="https://xueqiu.com/3167081651/55785555" target="_blank" rel="noopener">关于网格交易（forcode原创）</a></p><ul><li>起始买入价，一般在公司陷入暂时危机、股价处在最近几年最低位、PE/PB极低的时候开始关注。</li><li>起始买入量，我一般定在可投资总资产的1%以内，一般最低不少于1万元，这样手续费比较合算点；而每个交易间隔的递增交易量，尽量控制在总仓位的0.2%</li><li>交易间隔，我现在倾向于股价波动4~8%触发一次交易，尽量取整数间隔，方便记忆。比如20元以内的标的，每下跌1元触发一次交易。</li><li>起始卖出价，我现在一般定在反弹超过4个交易间隔（大约20%）开始分批卖出、下跌超过4个交易间隔开始分批买入。</li><li>以及：网格交易闲置资金的问题？网格交易投资标的的选择？</li></ul><p>➤ <a href="https://zhuanlan.zhihu.com/p/159272273" target="_blank" rel="noopener">ETF 网格交易策略（全） - 尼基的梦 - 知乎</a></p><ul><li>用上证指数作为表格标的…  3680 ~ 2440</li><li>如何估算网格上限, 用了GNP(证券化率)</li></ul><p><img src="/images/20220328031202.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F52m.FOF策略</title>
      <link href="/52.Financing/F52m.FOF%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F52m.FOF%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="whats’s-FOF"><a href="#whats’s-FOF" class="headerlink" title="whats’s FOF?"></a>whats’s FOF?</h2><p>@ref <a href="https://wiki.mbalib.com/wiki/FoF" target="_blank" rel="noopener">FoF - MBA智库百科</a></p><p>FoF（Fund of Funds）是一种专门投资于其他证券投资基金的基金。FoF并不直接投资股票或债券，其投资范围仅限于其他基金，通过持有其他证券投资基金而间接持有股票、债券等证券资产，它是结合基金产品创新和销售渠道创新的基金新品种。  　一方面，FoF将多只基金捆绑在一起，投资FoF等于同时投资多只基金，但比分别投资的成本大大降低了；  　　<br>另一方面，与基金超市和基金捆绑销售等纯销售计划不同的是，FoF完全采用基金的法律形式，按照基金的运作模式进行操作；FoF中包含对基金市场的长期投资策略，与其他基金一样，是一种可长期投资的金融工具。</p><ul><li><a href="https://xueqiu.com/7245734636/211668149" target="_blank" rel="noopener">FOF系列 | 选基需要懂股票吗？ - 雪球</a></li><li><a href="https://xueqiu.com/7245734636/212666324" target="_blank" rel="noopener">FOF系列 | 选股和选基，哪个更难？ - 雪球</a></li><li><a href="https://xueqiu.com/7245734636/206388215" target="_blank" rel="noopener">FOF系列 | 专业买手是如何选基金的？ - 雪球</a><br>-</li></ul><h2 id="FOF策略"><a href="#FOF策略" class="headerlink" title="FOF策略"></a>FOF策略</h2><p>@ref: <a href="http://fund.jrj.com.cn/2017/08/12005822887062.shtml" target="_blank" rel="noopener">史上最全！关于FOF的七大典型投资策略（好文！）-基金频道-金融界</a></p><p>从当前市场上的投资策略种类来看，大致有七种，包括：</p><ul><li>投资策略一：美林投资时钟策略 =&gt; <a href="/52.Financing/F21a.美林时钟/" title="F21a.美林时钟">F21a.美林时钟</a></li><li>投资策略二：Alpha/Beta投资策略<ul><li><a href="cubox://card?id=ff8080817fb08fd3017fb6ca7a44431b" target="_blank" rel="noopener">聊聊对冲策略（一）：α（alpha）和β（beta） - 知乎</a></li><li><a href="cubox://card?id=ff8080817fb0892b017fb72c9e851c86" target="_blank" rel="noopener">初学者的Alpha和Beta</a></li></ul></li><li>投资策略三：动量配置策略和反转配置策略 <a href="cubox://card?id=ff8080817f76ac46017f7bbab0f51cf5" target="_blank" rel="noopener">MACD指标在量化策略实战中如何应用？</a></li><li>投资策略四：成本平均策略和时间分散化策略</li><li>投资策略五：核心·卫星投资策略</li><li>投资策略之六：「杠铃」投资策略</li><li>投资策略之七：买入并持有策略</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F52c.轮动策略</title>
      <link href="/52.Financing/F52c.%E8%BD%AE%E5%8A%A8%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F52c.%E8%BD%AE%E5%8A%A8%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>如果说宏观大类资产配置是宏观视角下选优质资产，那么行业轮动就是权益市场视角下选热门行业。</p><ul><li>宏观: 大类资产配置(β)</li><li>中观: 行业轮动(smart β)</li><li>微观: 个股(α)</li></ul><p>轮动策略：行业轮动、风格轮动、大小盘轮动等。<br>行业轮动其实本身也是风格切换的一种表现。只是它的这种切换的属性在一个行业上，而不是单纯的大盘或者说市场的风格上</p><p>@ref: <a href="https://xueqiu.com/9920631642/222255434" target="_blank" rel="noopener">行业轮动策略及代表基金经理分享 - 雪球</a></p><h2 id="大小盘轮动"><a href="#大小盘轮动" class="headerlink" title="大小盘轮动"></a>大小盘轮动</h2><p>@ref: <a href="https://mp.weixin.qq.com/s?__biz=MzU1MzkyOTA4MA==&amp;mid=2247484758&amp;idx=1&amp;sn=d5652189f8271e18c48ec0a0aab8f75d" target="_blank" rel="noopener">手把手教你构建轮动策略</a></p><ul><li>动量效应是由Jegadeesh和Titman提出的，是指股票的收益率有延续原来的运动方向的趋势，即过去上涨的资产未来还会上涨，过去下跌的资产未来还会下跌。</li><li>交易策略：每天收盘后将沪深300ETF（510300）和创业板（159915）按照最近20个交易日的涨幅排序，排名第一并且20日涨幅大于2%则次日以开盘价买入；如果排名不是第一或者20日涨幅小于-2%则次日开盘价卖出；如果以上两个条件都不满足则买入银华日利（511880）</li><li>在趋势明显的的市场，轮动策略的效果更好，优势明显。比如牛市中市场趋势性上涨，容易获得超额收益；熊市中择时机制能够及时预警，赎回权益资产买人货基，从而躲避下跌降低熊市风险。在趋势不明显的震荡市场中，轮动策略的劣势也暴露无遗，反复“打脸”在所难免。</li></ul><h2 id="行业轮动"><a href="#行业轮动" class="headerlink" title="行业轮动"></a>行业轮动</h2><p>@ref: <a href="https://www.myquant.cn/docs/python_strategyies/111" target="_blank" rel="noopener">行业轮动(股票) - 经典策略 - 掘金量化</a></p><p>本策略每隔1个月定时触发计算：<br>SHSE.000910.SHSE.000909.SHSE.000911.SHSE.000912.SHSE.000913.SHSE.000914<br>(300工业.300材料.300可选.300消费.300医药.300金融)这几个行业指数过去<br>20个交易日的收益率并选取了收益率最高的指数的成份股获取并获取了他们的市值数据<br>随后把仓位调整至市值最大的5只股票上</p><p>标的：行业ETF @link <a href="/52.Financing/F32b.行业ETF/" title="F32b.行业ETF">F32b.行业ETF</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F52b.布林线策略</title>
      <link href="/52.Financing/F52b.%E5%B8%83%E6%9E%97%E7%BA%BF%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F52b.%E5%B8%83%E6%9E%97%E7%BA%BF%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>布林线均值回归策略认为，标的价格在上轨线和下轨线围成的范围内浮动，即使短期内突破上下轨，但长期内仍然会回归到布林带之中。 因此，一旦突破上下轨，即形成买卖信号。 当股价向上突破上界时，为卖出信号，当股价向下突破下界时，为买入信号。</p><p>以创业板ETF为例: </p><ul><li>收盘价超过上轨, 次日买入</li><li>收盘价低于上下轨, 次日清仓, 同时买入货币基金</li></ul><p>这个策略在宽基指数上效果普遍优于一直买入持有, 但出现宽幅震荡的情况会被打脸</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F52a.双均线策略</title>
      <link href="/52.Financing/F52a.%E5%8F%8C%E5%9D%87%E7%BA%BF%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F52a.%E5%8F%8C%E5%9D%87%E7%BA%BF%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="双均线策略"><a href="#双均线策略" class="headerlink" title="双均线策略"></a>双均线策略</h2><p>@ref ETF之家：<br>双均线策略是经典的趋势择时策略,<br>具体策略为:</p><ul><li>当50ETF的20日均线高于120日均线时, 次日买入</li><li>当20日均线低于120日均线时, 次日卖出, 同时换成货币基金</li></ul><hr><p>@ref: <a href="https://www.myquant.cn/docs/python_strategyies/153" target="_blank" rel="noopener">双均线策略(期货) - 经典策略 - 掘金量化</a><br>本策略以SHFE.rb2101为交易标的，根据其一分钟(即60s频度）bar数据建立双均线模型，<br>短周期为20，长周期为60，当短期均线由上向下穿越长期均线时做空，<br>当短期均线由下向上穿越长期均线时做多,每次开仓前先平掉所持仓位，再开仓。<br>注：为了适用于仿真和实盘，在策略中增加了一个“先判断是否平仓成功再开仓”的判断逻辑，以避免出现未平仓成功，可用资金不足的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F51a.Quant-量化交易经典策略</title>
      <link href="/52.Financing/F51a.Quant-%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%BB%8F%E5%85%B8%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F51a.Quant-%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%BB%8F%E5%85%B8%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="量化交易主要有哪些经典的策略？"><a href="#量化交易主要有哪些经典的策略？" class="headerlink" title="量化交易主要有哪些经典的策略？"></a>量化交易主要有哪些经典的策略？</h1><h2 id="flyerye的回答-知乎-https-www-zhihu-com-question-26594258-answer-271090168"><a href="#flyerye的回答-知乎-https-www-zhihu-com-question-26594258-answer-271090168" class="headerlink" title="flyerye的回答 - 知乎 https://www.zhihu.com/question/26594258/answer/271090168"></a>flyerye的回答 - 知乎 <a href="https://www.zhihu.com/question/26594258/answer/271090168" target="_blank" rel="noopener">https://www.zhihu.com/question/26594258/answer/271090168</a></h2><p>这是一个对于刚入门的投资者的好问题。讲之前，先推荐一本好书《<a href="https://www.zhihu.com/search?q=Efficiently+Inefficient&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A271090168%7D" target="_blank" rel="noopener">Efficiently Inefficient</a>》（作者：Lasse Heje Pedersen）。它对于想了解<a href="https://www.zhihu.com/search?q=%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A271090168%7D" target="_blank" rel="noopener">对冲基金</a>的朋友，是一本很好的启蒙书籍。不说废话，讲正题。从对冲基金的角度，交易策略可以有以下分类（来自《Efficiently Inefficient》）：</p><p><img src="/images/20220405095731.png" alt=""></p><p><strong>我们可以先把交易策略大体分成三类：1）股票策略 2）宏观策略 3）套利策略。其中，股票策略和宏观策略的收益主要来自投资目标的实际价值（absolute value）的变化，而套利策略的收益来自一对或一组投资目标的相对价值（relative value）的变化。</strong>这三者不是完全的独立，比如套利策略也有应用于股票市场，宏观资产配置也会借鉴股票策略中基本面分析方法。之所以这么分是因为三者有各自显著的特点。下面我们来逐一介绍：</p><p>1）股票策略：<strong>股票策略主要指的是单一的应用于股票市场的交易策略。按照人的主观和计算机在策略的参与程度，我们把股票策略分成主动权益投资和主动量化投资。</strong>这里的主动投资更准确的翻译是决定型交易，之所以称为主动权益投资，是因为这是业界一般的称呼。主动权益投资主要是靠投资者的主观判断，他们通过对行业和企业的深入调查，形成自己的投资逻辑，然后进行筛选股票。这里又根据交易的限制分为多空策略，做多策略和做空策略。这里提一下做空策略（见于国外），只做空的投资者往往会把目标锁定在，那些对外披露的报告和实际表现不符的公司，然后去调查该公司的财务状况是否作假。该策略类型的代表就是<a href="https://www.zhihu.com/search?q=%E6%B5%91%E6%B0%B4%E5%85%AC%E5%8F%B8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A271090168%7D" target="_blank" rel="noopener">浑水公司</a>（Muddy Waters Research）。</p><p>相较于主动权益投资，<strong>主动量化投资</strong>是把自己的逻辑输入计算机，通过计算机的快速运算，来构建自己的投资组合。<strong>它和主动权益投资的区别体现在研究的深度和广度上。</strong>量化投资依赖于数据。换句话说，对于那些不是以数据形式存在的信息（比如与他人的谈话），计算机是没法获得的，也无法转化成交易信号。从这个角度来看，量化投资对单一股票的研究深度不如主动权益投资。但是，借助于计算机的快速处理能力，量化投资所构建的自动化模型，能在短时间内消化各种类型的数据信息，并且把它转换成有价值的交易信号。从这个角度来看，量化投资在研究的广度上比主动权益投资更具有优势。<strong>在中国的股票市场，目前主要存在的量化交易策略是多因子选股模型（具体不在这里做介绍）和一些基于流动性的高频交易策略。</strong>前者更适用于资金规模大的<a href="https://www.zhihu.com/search?q=%E5%85%AC%E5%8B%9F%E5%9F%BA%E9%87%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A271090168%7D" target="_blank" rel="noopener">公募基金</a>，后者则适用于追求短期高回报的<a href="https://www.zhihu.com/search?q=%E7%A7%81%E5%8B%9F%E5%9F%BA%E9%87%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A271090168%7D" target="_blank" rel="noopener">私募基金</a>。</p><p>2）宏观策略：<strong>宏观策略的投资范围不局限于单一类型的市场，而是进行全类型市场的投资。这一类型的策略又可以分成以期货为投资工具的CTA策略，和宏观资产配置策略。CTA策略是动量策略的代表作。动量策略又称作<a href="https://www.zhihu.com/search?q=%E8%B6%8B%E5%8A%BF%E5%9E%8B%E7%AD%96%E7%95%A5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A271090168%7D" target="_blank" rel="noopener">趋势型策略</a>。</strong>它研究的是价格的变化趋势，基于行为金融学，找到价格变化背后的规律（动量和反转），通过趋势变化的规律赚取收益。CTA通过期货标的物，可以把自己的投资范围扩大到各个类型的资产，这样的目的是为了分散动量策略本身的高风险。宏观资产配置策略多被一些全球资产管理公司以及投行（如德意志银行）采用。<strong>策略主要研究的是宏观经济的变化，然后做多或做空某一区域的所有类型的市场。</strong>比如如果某资产管理公司相信中国经济会持续高速增长，它就会做多中国的股指，做多中国的国债，做多与中国贸易有关联的大宗商品等等。</p><p>3）套利策略：套利在这里是一种方式，因此它理论上可用于不同类型的市场。<strong>对于固收类产品，因为未来的现金流动比较固定，所以其价格与到期时间，利率，通胀，信用利差之间的关系更为确定。借助这个特点，投资者能更容易找到固收类产品之间的关系，也产生出更为多样的套利策略。</strong>另外，在海外市场，固收类产品有着更丰富的结构特性和相应的衍生品（如CDS）作为辅助，所以相应的策略比国内市场更为多样。事件驱动类的套利一般用在兼并收购这类事件，通过预测事件是否成功，从而做多或做空与参与者相关的股票，债券等产品。</p><p>当然，策略的分类方式不是固定的。本篇只是借助《Efficiently Inefficient》的对冲基金策略的分类方式对几个常见的交易策略进行了介绍。细化到量化交易的策略，可以包括股票市场的多因子选股模型，高频交易，CTA，宏观资产配置，固定收益套利等。像高频交易，固定收益套利这类的策略，底下还有很多细分的量化交易策略。具体的，可以看看专门这方面的书籍。</p><h2 id="BigQuant的回答-知乎-https-www-zhihu-com-question-26594258-answer-157360336"><a href="#BigQuant的回答-知乎-https-www-zhihu-com-question-26594258-answer-157360336" class="headerlink" title="BigQuant的回答 - 知乎 https://www.zhihu.com/question/26594258/answer/157360336"></a>BigQuant的回答 - 知乎 <a href="https://www.zhihu.com/question/26594258/answer/157360336" target="_blank" rel="noopener">https://www.zhihu.com/question/26594258/answer/157360336</a></h2><p>量化交易起源于国外，在国外已经至少有长达几十年的发展历程，因此我们先看一下国外比较经典有效的一些策略。</p><p><strong>中长线的交易策略：</strong></p><ul><li><strong>Aberration trading system</strong></li></ul><p>Aberration 交易系统由Keith Fitschen 于1986 年发明，1993 年KeithFitschen 将该系统商业化发布，自发布之日起，该系统业绩一直名列前茅，在1997 年、2001 年、2005 年已发布交易系统的业绩排名中该系统均排名前十。该交易系统的特点是同时交易在8 种不同的品种上，包括谷物、肉类、金属、能源、外汇、金融以及股指期货等。Aberration 交易系统的交易频率常常是每年交易某一品种3-4 次，60%的时间都持有仓位，平均每笔交易持仓60 天。它通过长线交易捕捉趋势来获取巨额利润。那它如何来弥补亏损呢？因为它同时交易在多个不相关的市场，当某一品种损失时，另一品种可能获利。在一年的时间里，总是有某一种或者多种品种能获得巨额利润。这些大的利润弥补了那些没趋势市场的小额亏损。Aberration 交易系统对资金进行组合管理，因此可以接受比较大的资金量。</p><ul><li><strong>Andromeda</strong></li></ul><p>Andromeda 交易系统于2001 年由Petros Development Corp 开发，是一个长线趋势交易系统，依赖简单的数学公式完全客观地进行交易，不带主观成分，并可以使用在多个市场。该系统于2002 年4 月发布，其核心优势是在公开发布之后也依然能保持稳定业绩。Andromeda 交易系统针对不同的市场都是用采同一套规则和参数，并没有进行最优化处理，属于非曲线匹配系统，样本外测试和样本内测试的结果一致，并且在发布后将近十年的时间里得到了验证。不同大小的资金账户皆可使用，由于是日线模型，因此不需要天天盯市，所有的进场出场指令均在下一日的开盘执行，有时候也可能很多天没有交易。</p><p>Andromeda 平均每笔交易的持仓时间为60-65 天，该系统的一大特色是，交易终止点不是根据价格，而是根据持仓时间而定。</p><ul><li><strong>Checkmate trading system</strong></li></ul><p>Checkmate 交易系统是一个独特的交易系统，该系统最大的特点是，它的目标不是最大化利润，而是保证收益率的一致性和最大回撤最小化。该系统在全部的品种上使用相同的交易法则和参数，因此避免了过度优化和曲线匹配的问题。Checkmate 在进场点选择上把关严格，可能在跟踪时同时监控多个品种，但交易很少，这使Checkmate 使用的保证金平均来看会比其他系统要少。因此这个系统可以让较小的账户里来交易大额的组合。Checkmate 是中线交易系统，目的是捕捉中线趋势，它采用改进趋势过滤，这种方法可以使Checkmate 经常能在获利最大的最近高点或低点离场，这点和那些有大回撤的趋势系统有所不同，它能迅速止盈离场，因此Checkmate 让交易者的心理相对舒适。</p><ul><li><strong>Golden SX trading system</strong></li></ul><p>Golden SX 系统发布于1995 年，到目前16 年的时间里，仅2005 年一年不盈利。它可以同时交易在13 个不同的品种上，并且采用相同的交易法则。Golden SX 采用一个十分有效的指标GSX Indicator，在开始交易前会先等市场有小幅回调再介入，以此来改进交易的成功率。系统有两种止损方法，一个是资金保护止损点，另一个是持有头寸后基于盈利的止损，这样可以保护资金的同时保证盈利。</p><p>新的改进版本Golden SX Electronic 于2009 年发布。可以对其中2 个参数做一定优化，也可以不优化。1983 年-2010 年的测试显示，该系统有60%的时间持有头寸，多个市场的平均胜率在56%左右。</p><ul><li><strong>Ready-Set-Go trading system</strong></li></ul><p>Ready-Set-Go 交易系统是一个长线交易系统，可以使用在多个市场，自2000 年公布以来都是使用相同的法则和参数，参数值可以根据市场趋势强弱自动调整。该系统可以使用在多个市场，自1970 以来至2011 年中，系统交易于8 个市场，在扣除每笔交易100 美元费用后平均收益率43%，平均每年每个市场交易3-4 笔。</p><p>Ready-Set-Go 的进场点和离场点均会随趋势强度的变化而变化，持仓时间从一两周至半年不等，极少数情况会持仓1 年。该系统只有50-60%的时间是持有头寸的。它的止损方式是基于波动率过滤的移动止损，可以为百分比止损，或是资金止损。</p><ul><li><strong>STC S&amp;P Daytrade trading system</strong></li></ul><p>该系统每月平均交易10 笔左右，每天交易不超过2 笔。市场总是有起有伏，该系统首先采用”Price Trend Indicator”价格趋势指数来判断市场是超买还是超卖，超买的市场应该卖出头寸，超卖的市场应该买入头寸。第一笔交易进场方法是根据<a href="https://www.zhihu.com/search?q=%E5%BC%80%E7%9B%98%E4%BB%B7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">开盘价</a>设一个区间，高于开盘价某些点位即买入，低于开盘价某些点位即卖出。日趋势通常会在3-4 天后改变方向，或是遇到跳空开盘，这些日子被称为”key reversal days”关键转折日。这种日子在目前的市场正在不断增多，因此有一套”Superior Clear-OutReversal Enhancement”系统来帮助找出反转信号并开始新方向的交易。最后，该系统每天都有不同的风险暴露，因此需要设臵止损，系统采用”Dynamic Risk Exposure Stops”方法止损。</p><p><strong><a href="https://www.zhihu.com/search?q=%E6%97%A5%E5%86%85%E4%BA%A4%E6%98%93%E7%AD%96%E7%95%A5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">日内交易策略</a>日内的经典策略有：</strong></p><ul><li><strong>RANGE BREAK</strong></li></ul><p>波动区间突破交易，根据昨天波动幅度的一定百分比，来触发当日的趋势交易，如果昨天的波动幅度是异常的，应当对该波动幅度进行必要的调整，以保持合理性。</p><ul><li><strong><a href="https://www.zhihu.com/search?q=%E8%8F%B2%E9%98%BF%E9%87%8C&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">菲阿里</a>四价</strong></li></ul><p>昨天高点，昨天低点，昨天收盘，今天开盘，可并称为菲阿里四价，它是由日本期货冠军菲阿里实盘采用的主要突破交易的参照系，此外，因菲阿里主观心智交易的模式，决定了其在实际交易中，还大量结合应用了“阻溢线”的概念，即我们通常所说的压力、支撑线。</p><ul><li><strong><a href="https://www.zhihu.com/search?q=%E7%A9%BA%E4%B8%AD%E8%8A%B1%E5%9B%AD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">空中花园</a></strong></li></ul><p>开盘突破，是最快的一种入场方式，当然出错的概率也最高，开盘第一根K线是收阳，还是收阴，是判断日内趋势可能运动方向的标准，我们发现这种入场在当天开盘 高开或低开时更为有效。在《<a href="https://www.zhihu.com/search?q=%E6%9C%9F%E5%B8%82%E6%88%AA%E6%8B%B3%E9%81%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">期市截拳道</a>》中，我把这种交易策略称为“空中花园”，有幸的是，听说<a href="https://www.zhihu.com/search?q=%E8%A5%BF%E8%92%99%E6%96%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">西蒙斯</a>在早期也曾经应用过类似的交易策略。</p><ul><li><strong><a href="https://www.zhihu.com/search?q=%E6%A8%AA%E7%9B%98%E7%AA%81%E7%A0%B4&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">横盘突破</a></strong></li></ul><p>较易于实现量化的形态突破，有分型，窄幅横盘突破，各种K线组合、双顶、双底、缠论三买三卖等，较难于实现量化的形态突破，有趋势线、圆孤顶底、旗型、菱 形、三角形等各种经典技术分析形态，趋势之后是盘整，盘整之后是趋势，横盘突破的交易策略，充分体现了波动性循环的价格波动规律，我们需要做的事情就是合 理量化盘整的定义：周期跨度、波动幅度。</p><ul><li><strong>基于固定百分比幅度的转向交易</strong></li></ul><p>该系统曾在某交易系统策略大赛中荣获第二名的殊荣，也是笔者最为衷情的日内突破交易策略。相对而言，基于固定点位的突破，可能会受制于品种价格区域的变化而变迁，基于固定百分比幅度的突破，则较少受到类似的困扰，除非该品种的<a href="https://www.zhihu.com/search?q=%E6%B3%A2%E5%8A%A8%E6%80%A7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">波动性</a>水平发生巨变。</p><ul><li><strong>HANS123</strong></li></ul><p>作为<a href="https://www.zhihu.com/search?q=%E5%A4%96%E6%B1%87%E5%B8%82%E5%9C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">外汇市场</a>上广为流传的一种突破交易策略，HANS123以其简捷的开盘后N根K线（分钟）的高低点突破，作为交易信号触发的评判标准。这也是一种入场较早的交易模式，配套价格包括带、时间确认、波动幅度要求等项过滤技术、或可提高其胜算。</p><ul><li><strong>日均ATR波动性突破</strong></li></ul><p>我们有理由相信，当一定幅度的ATR波动性幅度已经发生，我们将更愿意去赌日内波动的方向朝着这个已经完成一定幅度ATR的方向继续发展，比较的基准，可以是开盘价，也可以是日内创下的新高、新低记录位置。</p><ul><li><strong>ORB失败突破</strong></li></ul><p>ORB交易最早于1988年由美国基金经理托比提出，它通过衡量开盘价与最高价、最低价距离的取小者，为失败突破幅度，后市一旦超出这个幅度，就认为真正的突破。在实际应用过程中，早评的突破、窄幅波动日后的突破，可以作为有效的过滤条件。</p><ul><li><strong>分时均价黄线</strong></li></ul><p>在此我无意讨论其它均线系统的日内表现，分时均价黄线，因其广泛出现于各类交易软件的内置分时走势图中，因而，就交易策略的自我实现预言而论，它的地位格外突出，醒目。</p><ul><li><strong>日内ATR波动性突破</strong></li></ul><p>与E7不同，E10更侧重于短期市场波动率的变化评估，波动性突破，在一定程度上具备适应市场的功能，在实际应用于适应不同市场环境的能力更强。</p><p>量化的字面含义其实表明是对收益和风险进行数量化建模管理。通常是结合“对冲”俩字一起使用。量化对冲策略即同时利用量化手段和对冲技巧的投资策略。经典的量化对冲策略有市场中性策略、事件驱动套利策略三种。</p><p>具体可见下图所示：</p><p><img src="/images/20220405095456.png" alt="22"></p><p><strong>市场中性策略：</strong></p><p>市场中性策略通过构造股票多空组合减少对某些风险的暴露;最典型的对冲策略是Alpha策略，通过构建相对价值策略来超越指数，通过指数期货或期权等风险管理工具消除投资组合的大部分或全部系统风险，获得额外收益。由于买入和卖出金额接近，中和了市场总体风险，管理业绩与市场牛熊无关，这就是“股票市场中性策略”的由来。国内对冲策略产品大多采用买入现货、卖出期货的对冲策略，期货价格和现货价格之间的差异会影响策略表现。</p><p><strong>套利策略：</strong></p><p>统计套利：统计套利通过对相关证券进行对冲来获得与市场相独立的稳定性收益。在价格出现背离走势的时候买进表现相对差的，卖出表现相对好的，就可以期待在未来当这种背离趋势得到纠正时获得相对稳定的收益。它的风险在于如果市场并未按照预想出现价格回归，而是进一步扩大价差，可能会产生风险。</p><p>期现套利：期现套利是指某种期货合约，当期货市场与现货市场在价格上出现差距，低买高卖而获利。当现货指数被低估，某个交割月份的期货合约被高估时，投资者可以卖出该期货合约，同时根据指数权重买进<a href="https://www.zhihu.com/search?q=%E6%88%90%E4%BB%BD%E8%82%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">成份股</a>。当现货指数被高估，某个交割月份的期货合约被低估时，如果允许融券，投资者可以买入该期货合约，同时按照指数权重融券卖空成份股。和统计套利类似，它的风险在于期货和现货的价差并未收敛而是进一步扩大。</p><p>ETF套利：ETF(Exchange Traded Fund)交易型开放式指数基金，通常又被称为<a href="https://www.zhihu.com/search?q=%E4%BA%A4%E6%98%93%E6%89%80%E4%BA%A4%E6%98%93%E5%9F%BA%E9%87%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">交易所交易基金</a>。由于其有两个价格，即<a href="https://www.zhihu.com/search?q=%E5%9F%BA%E9%87%91%E5%87%80%E5%80%BC&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A157360336%7D" target="_blank" rel="noopener">基金净值</a>和交易所交易价格，所以一旦两个价格相差过多时，就可以高卖低买套利。风险在于交易价格随时波动，较难捕捉，也可能会有流动性困难。</p><p>分级基金套利：一般分级基金有5个价格，母基金净值，A类份额净值、A类份额交易价格、B类份额净值、B类份额交易价格，正常情况下，A的净值+B的净值=2*母基金净值，当(A的交易价格+B的交易价格)大于或小于两倍母基金净值时，也可以通过高卖低买获利。但实际情况中，由于申购到拆分到卖出并非T+0，而交易价格又是瞬息万变的，可能会套利失败。</p><p>事件驱动套利策略：利用特殊事件造成的对资产价格的错误定价，买入股价受事件正面影响的公司，卖出股价受事件负面影响的公司，从错误定价中谋利。</p><p>CTA期货策略：CTA即commdity trading advisor,直译为商品交易顾问。其中期货套利策略即从不同期货市场或是同一市场内不同期货合约间的价差中寻求利润，风险和之前介绍的套利风险类似，即出现差价放大的情况。而趋势交易策略目前CTA运用最广泛的，通过运用大量不同的指标去除市场噪音并寻找当前的市场趋势，然后建立头寸，他们从市场趋势的持续发展中渔利。这个策略在市场出现震荡，没有表现出很强的趋势时失效。</p><p><strong><a href="https://link.zhihu.com/?target=https%3A//bigquant.com/%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_answer%26utm_campaign%3D170722_157360336_zhihu_answer" target="_blank" rel="noopener">BigQuant - 人工智能量化投资平台</a></strong></p><p><strong>一些经典的策略举例</strong>：</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/994%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_1" target="_blank" rel="noopener">《【重磅】AI Alphas(A股版)》</a></li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/111838%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_2" target="_blank" rel="noopener">AI超越传统量化选股，通过AI自动获得收益提升</a>》</li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/2564%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_3" target="_blank" rel="noopener">如何选出符合一定条件的股票</a>》</li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/111643%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_4" target="_blank" rel="noopener">快速理解AI量化策略</a>》</li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/201%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_5" target="_blank" rel="noopener">基于LSTM的股票价格预测模型</a>》</li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/320%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_6" target="_blank" rel="noopener">LSTM Networks应用于股票市场之Sequential Model</a>》</li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/254%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_7" target="_blank" rel="noopener">借助talib使用技术分析指标来炒股</a>》</li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/255%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_8" target="_blank" rel="noopener">大师系列之价值投资选股策略</a>》</li><li>《价值选股策略——基于机器学习算法》</li><li>《<a href="https://link.zhihu.com/?target=https%3A//bigquant.com/community/t/topic/110508%3Futm_source%3Dzhihu%26utm_medium%3Dzhihu_article%26utm_campaign%3Drecommend_10" target="_blank" rel="noopener">选股+择时策略组合</a>》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F51.Quant-量化交易101</title>
      <link href="/52.Financing/F51.Quant.%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93101/"/>
      <url>/52.Financing/F51.Quant.%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93101/</url>
      
        <content type="html"><![CDATA[<p>@tag: #入门101 #量化交易</p><hr><p>@todo:</p><ul><li><a href="https://leetcode-cn.com/circle/article/kvwd0R/" target="_blank" rel="noopener">量化交易入门指南 - 力扣（LeetCode）</a></li><li>待整理: <a href="/52.Financing/F51a.Quant-量化交易经典策略/" title="F51a.Quant-量化交易经典策略">F51a.Quant-量化交易经典策略</a></li></ul><hr><p>➤ 数据下载:</p><ul><li>果仁网 20年上证指数（大盘）</li></ul><p>➤ 相关库:</p><p>使用工具——BaostockBaostock是一个免费、开源的证券数据平台，我们可以用它来遍历沪深市选股，监测股票行情，进行量化分析和定投回测。Baostock的安装方法和其他Python包一样，pip install baostock就行。类似的包还有Dtshare、Tushare，这两个都是免费的Python金融数据接口库，可以自行选择，不过Tushare现在取数需要注册和积分，稍有点麻烦。</p><p>  Baostock官方说明文档：baostock.com<br>  Tushare官方说明文档：tushare.pro/document/1<br>  Dtshare官方说明文档：<a href="http://dt-share.com" target="_blank" rel="noopener">http://dt-share.com</a></p><hr><p> QUANTAXIS，程序员们还有其他轮子可供选择 quantopian，优矿，JoinQuant，vnpy，Abu量化等等。QUANTAXIS是个只能本地部署的基于python的量化开源系统。有基于Docker部署和基于pip部署和基于Git部署三种方法</p><p> @ref: <a href="https://zhuanlan.zhihu.com/p/273440530" target="_blank" rel="noopener">35岁程序员的退路：量化投资学习路径(2) - 知乎</a></p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>策略索引:</p><ul><li>行业量化轮动 &amp; 大小盘轮动:  <a href="/52.Financing/F52c.轮动策略/" title="F52c.轮动策略">F52c.轮动策略</a></li><li>布林线策略: <a href="/52.Financing/F52b.布林线策略/" title="F52b.布林线策略">F52b.布林线策略</a></li><li>均线策略: <a href="/52.Financing/F52a.双均线策略/" title="F52a.双均线策略">F52a.双均线策略</a></li><li>网格交易：<a href="/52.Financing/F52n.网格交易策略/" title="F52n.网格交易策略">F52n.网格交易策略</a></li><li>待整理：<a href="/52.Financing/F51a.Quant-量化交易经典策略/" title="F51a.Quant-量化交易经典策略">F51a.Quant-量化交易经典策略</a></li></ul><p>发现一个网站叫<a href="https://www.myquant.cn/docs/python_strategyies/153" target="_blank" rel="noopener">“掘金量化”</a>, 是个卖自家策略代码的, 网站上有一些策略的解释, 也有源代码</p><p><img src="/images/20220404232742.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F49.戴维斯双杀</title>
      <link href="/52.Financing/F49.%E6%88%B4%E7%BB%B4%E6%96%AF%E5%8F%8C%E6%9D%80/"/>
      <url>/52.Financing/F49.%E6%88%B4%E7%BB%B4%E6%96%AF%E5%8F%8C%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="戴维斯双杀"><a href="#戴维斯双杀" class="headerlink" title="戴维斯双杀"></a>戴维斯双杀</h2><p><code>P = PE*EPS</code>, 即<br>$$ 股价 = 市盈率 * 每股净利润 $$ </p><p>股价受到企业盈利和企业估值产生的乘数效应的影响，在成长股成长的过程中PE和EPS都会增长，而最终股价增长的幅度是两者增长倍数的乘积。</p><p>如果EPS（利润）下降，可能带来PE同时下降，估值和每股净利润的下滑导致的股价暴跌。<br>该模型向上叫做“戴维斯双击”，向下叫做“戴维斯双杀”</p><h2 id="什么是杀业绩、杀估值"><a href="#什么是杀业绩、杀估值" class="headerlink" title="什么是杀业绩、杀估值"></a>什么是杀业绩、杀估值</h2><p>$$ Price = EPS<em>PE = 利润</em>市盈率 $$</p><p>其中利润是“业绩”，市盈率即“估值”，<br>企业经营＝不断的把估值转化为预期中的业绩，但是高业绩增长又进一步提高估值，一旦业绩变差，上面的转化无法持续，就是戴维斯双杀。<br><img src="/images/IMG20220915.png" alt=""></p><p>其中，估值分为几部分：</p><ul><li>情绪： 理解为股东情绪？</li><li>业绩预期：是对未来的预测。始终围绕的着业绩的增长，高价值（投入资本回报）和风险<ul><li>增长：经常性的超预期可以获得市场的经常性溢价。比如连续几年稳定增长20%，这部分也会进入估值，变为增长预期。</li><li>高价值：高价值企业，会获得经常性溢价。比如roe比较高，容易形成复利，RNG三要素明显，经营态势良好。</li><li>风险：比如高负债，周期性。</li></ul></li></ul><p>①是否为估值杀：<br>在业绩和企业经营态势没有发生变化的情况下，可以简单的归结为估值杀，比如在熊市底部的杀跌阶段，白马股也无法逃过估值的下降，这是由市场极度悲观情绪导致的。</p><p>②是否为业绩杀：<br>企业的动态经营信息会告诉我们，如果业绩不及市场预期，在悲观的情况下，会迎来短期业绩杀，这也是市场定价周期与企业经营周期之间的时差导致的。<br>市场定价是每天都在进行的，而企业经营周期是一个缓慢的过程，基本面的改变需要时间。当市场对企业产生了积极的情绪，而短期业绩又不能符合预期的话，市场先生大概率会以下跌作为响应。</p><p>③双杀：代表企业的经营基本面和态势都发生了变化。比如某企业连续几年增长，而在遇到市场天花板之后增速放缓，作为成长股就要遭遇双杀。在估值杀、业绩杀、双杀之间存在时滞效应。由于企业的经营数据只按照季度对外公布，在股价下跌开始，看起来像是估值杀，因为短期业绩或业绩增速并未发生大变化。 随后公布的财报如果不及预期，可能出现业绩杀。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F44.周期股</title>
      <link href="/52.Financing/F44.%E5%91%A8%E6%9C%9F%E8%82%A1/"/>
      <url>/52.Financing/F44.%E5%91%A8%E6%9C%9F%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/384284730" target="_blank" rel="noopener">什么是「周期股」，它是如何形成的，有哪些特点？ - 知乎</a></p><p>什么是周期股：指支付股息非常高（股价相对不会太高），并随着经济周期的盛衰而涨落的股票 // @ref: <a href="/52.Financing/F21.经济的周期性/" title="F21.经济的周期性">F21.经济的周期性</a></p><p>该类股票诸如煤炭（传统能源）、钢铁、有色、化工、航运等行业的股票，当整体经济上升时，这些股票的价格也迅速上升；当整体经济走下坡路时，这些股票的价格也下跌。<br>与之对应的是非周期股，生产必需品的公司，不论经济走势如何，人们对这些产品的需求都不会有太大变动，例如食品饮料和医药生物行业。</p><p>周期股与经济走势高度绑定，并有一定的提前反应。可以参照的一个价格信息是国际大宗商品价格走势，国际大宗商品价格走势是经济形势好坏的晴雨表，周期股的走势与国际大宗商品价格走势也有密切的关系。</p><p>对于强周期行业，在景气周期顶点PE很低，却往往是可能需要卖出的时候；而景气低点盈利很少或者亏损，股价很低的时候PE却很高</p><hr><p><a href="https://zhuanlan.zhihu.com/p/354866504" target="_blank" rel="noopener">有色大涨的逻辑分析 - 知乎</a></p><p>…综上所述，可以发现经济周期投资中离我们最近的就是库存周期(基钦周期)，实际投资中短周期的投资机会也更多，通过观察一些短期指标即挖掘隐含的投资机会。比如观察经济复苏的先行指标：<em>生产价格指数PPI、采购经理指数PMI，以及工业品的库存</em></p><ul><li>通常将PPI与PMI两者结合看，如果连续几个月同时上扬，那么经济基本面可能好转，意味着经济开始复苏。</li><li>此时我们可以叠加工业企业产成品库存来加以判断，如果库存在低位，那么一旦经济复苏预期上升，库存周期的投资机会便来临。</li></ul><p>统计局“工业企业经济效益指标”中的<em>工业企业产成品存货</em>数据，用它的同比（一阶变化率）作为周期判断指标: 存货同比上升则为补库存，存货同比下降则为去库存。</p><p>PPI &amp; PMI：@link: <a href="/52.Financing/F23.宏观统计指标/" title="F23.宏观统计指标">F23.宏观统计指标</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F41.K线图及指标</title>
      <link href="/52.Financing/F41.K%E7%BA%BF%E5%9B%BE%E5%8F%8A%E6%8C%87%E6%A0%87/"/>
      <url>/52.Financing/F41.K%E7%BA%BF%E5%9B%BE%E5%8F%8A%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="K线"><a href="#K线" class="headerlink" title="K线"></a>K线</h2><p>▷ K线图, 英文名：K Chart, Candlestick Chart</p><blockquote><p>中文中的「K 线图」一词与英文字母 K 没关系，也是从日语误译而来：「K 线」音译自日文汉字「罫線」（kei-sen），因为日语「罫線表」一词指行情图表，并不专指 K 线图，这个张冠李戴的翻译，最终因简单好记不胫而走，成了一个让世界人民莫名其妙的中文词。</p></blockquote><ol><li>最上方的一条细线称为上影线，中间的一条粗线为实体，下面的一条细线为下影线。</li><li>当收盘价高于开盘价，也就是股价走势呈上升趋势时，我们称这种情况下的 K 线为阳线，中部的实体以空白或红色表示。反之称为阴线用黑色实体或绿色表示。</li><li>上影线的长度表示最高价和收盘价之间的价差，实体的长短代表收盘价与开盘价之间的价差，下影线的长度则代表开盘价和最低价之间的差距。</li></ol><p><img src="/images/20220226145517.png" alt=""></p><h2 id="K线形态"><a href="#K线形态" class="headerlink" title="K线形态"></a>K线形态</h2><p><img src="/images/20220331145900.png" alt=""></p><ul><li>① 全秃阳线：也称光头光脚阳线，该线是一条既无上影线，也无下影线的图线。因开盘价是最低价，收盘价是最高价，故当天一直处于上升走势，表示上升走势强劲，后市可持续看好。</li><li>② 开盘秃阳线：也称光脚阳线，即只有上影线而无下影线的阳线。因收盘价并不是最高价，而开盘价是最低价，当天依然处于上升行情，但上挡压力开始显现。</li><li>③ 收盘秃阳线：也称光头阳线，即只有下影线而无上影线的阳线。因收盘价是最高价，当天虽有下跌，但开盘价依然较低，表示上升力度较大，行情持续看好。</li><li>④ 大阳线：实体较长，又带有上下影线，因实体较长，当天涨幅较大，显示较强上升走势，行情持续看好。</li><li>⑤ 小阳线：也称小棋子，实体较小，带有不太长的上下影线，涨跌走势不明朗，行情难料。</li><li>⑥ 星形阳线：也称极阳线，实体很小，上下影线更短，相对上方小阳线，走势更加不确定，涨跌难判断。</li><li>⑦ 长下影阳线：也叫上吊阳线，实体较小，下影线较长，无上影线，或只有很短的上影线。该图线若处在高价位，是行情见顶信号，感觉已经涨不动了，可考虑卖出股票；若处在低价位，也同样表示涨不动了，是行情见底的信号，可考虑买入股票。</li><li>⑧ 长上影阳线：也叫流星线，实体较短，上影线较长，无下影线或只有很短的下影线。该图线与长下影阳线的性质一样，若处在高价位，是行情见顶的信号，应卖出股票；若处在低价位，则是行情见底的信号，可考虑买入股票。</li></ul><p><img src="/images/20220331145923.png" alt=""></p><ul><li>① 全秃阴线：也称光头光脚阴线，该线是一条既无上影线，也无下影线的图线。开盘价是最低价，收盘价是最高价，上升走势很弱，行情看淡。</li><li>② 收盘秃阴线：也称光脚阴线，即只有上影线而无下影线的阴线。遇到上涨阻力较大，行情看淡。</li><li>③ 开盘秃阴线：也称光头阴线，即只有下影线而无上影线的阴线。虽然下挡出现了一定程度的支撑，但行情一时可能还难以变好。</li><li>④ 大阴线：即实体大，而又带有上下影线的图线，当天下跌幅度较大，显示弱势走势，后市看淡。</li><li>⑤ 小阴线：也叫小棋子，实体较小，同时带有不太长的上下影线，当天涨跌幅度不大，走势扑朔迷离，行情难料。</li><li>⑥ 星形阴线：也称极阴线，实体相对小阴线来说更小，上下影线也较短，走势不确定，涨跌难判断。</li><li>⑦ 长下影阴线：也叫上吊阴线，实体较小，下影线较长，无上影线，或只有很短的上影线，该图线若处在高价位，是行情见顶的信号，应卖出股票；若处在低价位，则是行情见底的信号，可考虑买入股票。</li><li>⑧ 长上影阴线：也叫流星线，实体较短，上影线较长，无下影线或只有很短的下影线。该图线与上吊阳线的性质一样，若处在高价位，是行情见顶的信号，应卖出股票；若处在低价位，则是行情见底的信号，可考虑买入股票。</li></ul><p><img src="/images/20220331145945.png" alt=""></p><ul><li>① 四值同一线：即开盘价、最高价、最低价、收盘价为同值图线。在上升趋势里，显强势；在下降趋势里，显弱势。这种 K 线图一般只出现在涨停板，也叫做一字板涨停。</li><li>② 丁字线：也称风筝线,特点是开盘价与收盘价是一样的，这种 K 线图处在高位，显示见顶信号；处在低位，显示见底信号。</li><li>③ 倒丁字线：也称灵位线，特点同丁字线，处在高位，显示见顶信号；处在低位，显示见底信号。</li><li>④ 十字星线：特点同丁字线，处在高位，显示见顶信号；处在低位，显示见底信号。</li></ul><h2 id="复权让-K-线图更真实"><a href="#复权让-K-线图更真实" class="headerlink" title="复权让 K 线图更真实"></a>复权让 K 线图更真实</h2><p>@ref: <a href="https://sspai.com/post/66097" target="_blank" rel="noopener">如何选择一支好基金 04 | 你必须知道的关于基金的十个问题 - 少数派</a></p><ul><li>（1）什么是复权？什么是向前复权与向后复权？</li><li>（2）在哪些情况下需要复权？</li><li>（3）如何复权?</li></ul><h2 id="分时图"><a href="#分时图" class="headerlink" title="分时图"></a>分时图</h2><p>➤ 大盘（上证指数、深成指数）分时图</p><ul><li>白线：也即“上证指数”，在上海证券交易所全部上市企业股票（包括A股和B股）经过加权计算得出的；</li><li>黄线：不加权计算出的指数，黄线的走势反应了小盘的走势</li></ul><hr><p>➤ 股票&amp;基金分时图</p><ul><li>白线：实时成交价格；</li><li>黄线：当日平均成本线，是根据每笔成交量按照移动加权计算的价格的反映，表示该种股票即时成交的平均价格(当日的平均成本)，即当天成交总金额除以成交总股数</li><li>紫线：IOPV</li></ul><p>单位基金份额估计净值</p><blockquote><p>IOPV(Indicative Optimized Portfolio Value) 是由交易所计算的ETF实时单位净值的近似值,以便于投资者估计ETF交易价格是否偏离了内在价值。每15秒计算并公告，计算方法是由证券交易所根据基金管理人提供的计算方法及每日提供的申购、赎回清单，按照清单内组合证券的最新成交价格计算</p></blockquote><p>扩展阅读：如何通过基金的IOPV进行套利</p><h2 id="▷-MA"><a href="#▷-MA" class="headerlink" title="▷ MA"></a>▷ MA</h2><p>移动平均线－MA (Moving Average):  <code>当日MA = 过去N天的收盘价求算数平均</code>, 类似一个N天的滑动窗口;</p><p>一般以日线MA5、MA10解析短期走势，以MA30、MA60解析中期走势，以 M125和M250解析中长期走势。而以5–30分钟K线做短线操作，以周、月、年K线中的均线走向解析长期走向。</p><p><img src="/images/20220403164337.png" alt="MA5-10-20"></p><p>MA基本用法: </p><ul><li>均线向上是均线多头</li><li>均线向上产生的交叉是金叉,反之是死叉。</li><li>多头排列就是市场趋势是强势上升势，均线在5—10—20—30—60k线下支撑排列向上为多头排列。均线多头排列趋势为强势上升势，操作思维为多头思维。进场以均价线的支撑点为买点，下破均价线支撑止损。</li><li>空头排列就是市场趋势是弱势下跌趋势，均线在5—10—20—30—60k线上压制k线向下排列为空头排列。均线空头排列为弱势下跌趋势。进场以均价线的阻力位为卖点，上破均价线止损。</li></ul><h2 id="▷-MACD"><a href="#▷-MACD" class="headerlink" title="▷ MACD"></a>▷ MACD</h2><p>指数平滑移动平均线（英语：Moving Average Convergence / Divergence，缩写：MACD，港澳台称为指数平滑异同移动平均线）</p><p><img src="/images/20220403162738.png" alt="MACD"></p><ul><li>白色线(DIF):  表示快线(12日EMA)和慢线(26日EMA)的差离值, <code>DIF = EMA12 - EMA26</code><ul><li>EMA12: 最近12日移动平均值= <code>前一日EMA12 × 11/13 + 今日收盘价×2/13</code></li><li>EMA26: 最近26日移动平均值= <code>前一日EMA26 × 25/27 + 今日收盘价×2/27</code></li></ul></li><li>黄色线(DEA): 即再计算上面DIF的9日EMA= <code>前一日DEA×8/10 + 今日DIF×2/10</code></li><li>红蓝色柱: 即为MACD柱状图 = <code>(DIF-DEA)×2</code></li></ul><p>MACD基本用法: </p><ul><li>DIFF 向上穿过 DEA 时，被称为“金叉”，这是一个买入信号</li><li>DIFF 向下穿过 DEA 时，被称为“死叉”，这是一个卖出信号</li><li>更多: <a href="https://baike.eastmoney.com/item/MACD%e6%9f%b1%e7%8a%b6%e5%9b%be" target="_blank" rel="noopener">词条页面_百科_东方财富网</a></li></ul><p>@ref: <a href="https://www.zhihu.com/question/36411902/answer/2384383208" target="_blank" rel="noopener">MACD指标在量化策略实战中如何应用？ - 邢不行的回答 - 知乎</a> // 结论很有意思</p><h2 id="▷-顶背离-amp-底背离"><a href="#▷-顶背离-amp-底背离" class="headerlink" title="▷ 顶背离 &amp; 底背离"></a>▷ 顶背离 &amp; 底背离</h2><ul><li>顶背离:  K线上涨, 但是MACD（DIF和DEA）趋势向下，“一般是股价在高位即将反转转势的信号，表明股价短期内即将下跌，是卖出股票的信号”</li><li>底背离:  K线下跌, 但是MACD（DIF和DEA）向上，“预示着下跌行情将结束”</li></ul><p><img src="/images/20220403165211.png" alt="背离"></p><h2 id="▷-布林-BOLL-线"><a href="#▷-布林-BOLL-线" class="headerlink" title="▷ 布林(BOLL)线"></a>▷ 布林(BOLL)线</h2><p>在所有的指标计算中，BOLL指标的计算方法是最复杂的之一，其中引进了统计学中的标准差概念，涉及到中轨线（MB）、上轨线（UP）和下轨线（DN）的计算。<br>另外，和其他指标的计算一样，由于选用的计算周期的不同，BOLL指标也包括日BOLL指标、周BOLL指标、月BOLL指标年BOLL指标以及分钟BOLL指标等各种类型。<br>经常被用于股市研判的是日BOLL指标和周BOLL指标。虽然它们的计算时的取值有所不同，但基本的计算方法一样。  　　</p><p>以日BOLL指标计算为例，其计算方法如下：</p><ul><li>中轨线=N日的移动平均线 </li><li>上轨线=中轨线＋两倍的标准差</li><li>下轨线=中轨线－两倍的标准差 　　</li></ul><p>在股市分析软件中，BOLL指标一共由四条线组成，即上轨线UP 、中轨线MB、下轨线DN和价格线。其中上轨线UP是UP数值的连线，用黄色线表示；中轨线MB是MB数值的连线，用白色线表示；下轨线DN是DN数值的连线，用紫色线表示；价格线是以美国线表示，颜色为浅蓝色。</p><p>BOLL指标中的上、中、下轨线的意义 　　</p><ol><li>BOLL指标中的上、中、下轨线所形成的股价通道的移动范围是不确定的，通道的上下限随着股价的上下波动而变化。在正常情况下，股价应始终处于股价通道内运行。如果股价脱离股价通道运行，则意味着行情处于极端的状态下。</li><li>在BOLL指标中，股价通道的上下轨是显示股价安全运行的最高价位和最低价位。上轨线、中轨线和下轨线都可以对股价的运行起到支撑作用，而上轨线和中轨线有时则会对股价的运行起到压力作用。</li><li>一般而言，当股价在布林线的中轨线上方运行时，表明股价处于强势趋势；当股价在布林线的中轨线下方运行时，表明股价处于弱势趋势。</li></ol><p>BOLL指标中的上、中、下轨线之间的关系</p><ol><li>当布林线的上、中、下轨线同时向上运行时，表明股价强势特征非常明显，股价短期内将继续上涨，投资者应坚决持股待涨或逢低买入。 </li><li>当布林线的上、中、下轨线同时向下运行时，表明股价的弱势特征非常明显，股价短期内将继续下跌，投资者应坚决持币观望或逢高卖出。</li><li>当布林线的上轨线向下运行，而中轨线和下轨线却还在向上运行时，表明股价处于整理态势之中。如果股价是处于长期上升趋势时，则表明股价是上涨途中的强势整理，投资者可以持股观望或逢低短线买入；如果股价是处于长期下跌趋势时，则表明股价是下跌途中的弱势整理，投资者应以持币观望或逢高减仓为主。</li><li>布林线的上轨线向上运行，而中轨线和下轨线同时向下运行的可能性非常小，这里就不作研判。  　</li><li>当布林线的上、中、下轨线几乎同时处于水平方向横向运行时，则要看股价目前的走势处于什么样的情况下来判断。</li></ol><h2 id="▷-顾比均线"><a href="#▷-顾比均线" class="headerlink" title="▷ 顾比均线"></a>▷ 顾比均线</h2><p><a href="https://xueqiu.com/2356382715/204101803" target="_blank" rel="noopener">一个简单易行的基金买入策略 - 雪球</a><br>顾比均线： GMMA（Guppy Multiple Moving Average）——顾比复合移动平均线，简称顾比均线</p><ul><li>顾比均线由两组均线构成，分别是长期组（黄线部分）和短期组（蓝线部分）。</li><li>短期组6根均线，分别是3、5、8、10、12和15日（周、月）平均线；</li><li>长期组也是6根均线，分别是30、35、40、45、50和60日（周、月）平均线。</li><li>这两组指标分别反映了短线交易者和中长期投资者的行为，当这两组指标相互靠近的时候，说明投资者和投机者对于证券的价值有了共识，而当两组相互远离的时候，就说明对价值产生了分歧</li></ul><p>“从偏股混合基金指数2005年以来的月线图来看，在顾比均线短期组完全上穿长期组时买入，胜率达到了100%”</p><p>场外基金怎么显示GMMA？ <a href="https://xueqiu.com/2356382715/207958894" target="_blank" rel="noopener">顾比均线在基金投资中的运用 - 雪球</a></p><h2 id="阻力位-amp-支撑位"><a href="#阻力位-amp-支撑位" class="headerlink" title="阻力位 &amp; 支撑位"></a>阻力位 &amp; 支撑位</h2><ul><li><a href="https://bbs.pinggu.org/thread-3837876-1-1.html" target="_blank" rel="noopener">【陈珺盈】：支撑位和阻力位背后的秘密 - 经管之家(原人大经济论坛)</a></li><li><a href="https://www.jsgroup-chn.com/cn/education/education-themes/technical-analysis/support-and-resistance/" target="_blank" rel="noopener">支撑位与阻力位</a></li></ul><p>压力位另一种解释：潜在卖盘是随机分布在现价上方的，卖盘越少，那就意味着卖盘分布的越稀疏，不同卖盘之间的间隙越大，这时候制造波动所需要的资金越少，或者说同样的资金所能制造的波动越大。  （当然，亦有可能这些卖盘大部分集中在某个区域，但这就意味着这区域上方的卖盘会更加稀疏，形成类似「真空带」，只要价格涨破这个区域，那就意味着这区域的卖盘被吃光了，上面的卖盘会非常少，于是会非常容易涨。我们可以把这区域称之为「压力位」。一旦突破压力，就会打开上涨空间。）</p><h2 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h2><p>@ref: <a href="https://www.ttyfp.com/chaogu/22065.html" target="_blank" rel="noopener">炒股必备画线技巧一：平行线、X线、下降趋势线、上升趋势线 – 天云复盘</a></p><ul><li>上升趋势线</li><li>平行线：平行线是在切线（趋势线）的基础上发展而来。我们在画切线的时候，无论是上升通道的支撑线还是下降通道的压力线，似乎股价总在一个特定的通道内运行</li></ul><h2 id="五浪理论"><a href="#五浪理论" class="headerlink" title="五浪理论"></a>五浪理论</h2><p><a href="https://baike.baidu.com/item/%E4%BA%94%E6%B5%AA%E7%90%86%E8%AE%BA/2390299" target="_blank" rel="noopener">五浪理论_百度百科</a></p><p>第一浪建仓浪，第二浪洗盘浪，第三浪主升浪</p><p><img src="/images/%E8%89%BE%E7%95%A5%E7%89%B9%E6%B3%A2%E6%B5%AA.png" alt="../_images/艾略特波浪.png"></p><h2 id="所谓“股票技术分析”"><a href="#所谓“股票技术分析”" class="headerlink" title="所谓“股票技术分析”"></a>所谓“股票技术分析”</h2><p>@ref:</p><ul><li><a href="https://www.zhihu.com/question/25625592" target="_blank" rel="noopener">专业量化交易从业人士如何看待传统的技术分析？ - 知乎</a> ：这里的传统技术分析包括像均线、布林带，或者MACD等技术指标，他们在量化从业人士的工具箱中处于什么地位？</li><li><a href="https://www.zhihu.com/question/36411902" target="_blank" rel="noopener">MACD指标在量化策略实战中如何应用？ - 知乎</a> =&gt; <a href="/52.Financing/F51.Quant.量化交易101/" title="F51.Quant.量化交易101">F51.Quant.量化交易101</a></li></ul><hr><p><a href="https://wiki.mbalib.com/wiki/%E8%82%A1%E7%A5%A8%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90" target="_blank" rel="noopener">股票技术分析 - MBA智库百科</a></p><ul><li>技术分析包含的内容<ul><li>技术分析理论的主要的代表有道氏理论、波浪理论、江恩法则等。  　　</li><li>主要分析方法有K线（日本线）理论、切线理论、形态理论、量价关系理论。  　　</li><li>主要的分析指标包括：趋势型指标、超买超卖型指标、人气型指标、大势型指标等内容。</li></ul></li><li>技术分析的特性: 技术分析区别于其他分析方法的关键在于，它更像一门艺术。<ul><li>其一、<strong>在它的各种理论体系中，从定义到规则，都带有明显的经验总结色彩，不具备严格的数学推理过程；</strong>  // 哈哈哈 　　</li><li>其二、它包含的理论很多，每位技术分析家都有不同的见地  // 像不像星座？</li></ul></li></ul><p><a href="https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87" target="_blank" rel="noopener">技术指标_百度百科</a></p><ul><li>目前,证券市场上的各种技术指标数不胜数。例如,相对强弱指标(RSI)、随机指标(KD)、趋向指标(DMI)、平滑异同平均线(MACD)、能量潮（OBV)、心理线、乖离率等。这些都是很著名的技术指标,在股市应用中长盛不衰。而且,随着时间的推移,新的技术指标还在不断涌现。包括：MACD（平滑异同移动平均线）DMI趋向指标（趋向指标）DMA EXPMA（指数平均数）TRIX（三重指数平滑移动平均）BRARCR VR（成交量变异率）OBV（能量潮）ASI（振动升降指标）EMV（简易波动指标）WVAD（威廉变异离散量）SAR（停损点）CCI（顺势指标）ROC（变动率指标）BOLL（布林线）WR（威廉指标）KDJ（随机指标）MIKE（麦克指标）。</li></ul><p><a href="https://www.zhihu.com/question/21094650" target="_blank" rel="noopener">股票技术指标哪些最常用？ - 知乎</a></p><ul><li>MACD</li><li>移动平均线: 均线又分MA（简单算术移动平均线）、SMA（加权移动平均线）、EMA（指数平滑移动平均线）</li><li>布林带</li><li>震荡类技术指标: KDJ、RSI、WMS、乖离率等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F39.桥水全天候策略</title>
      <link href="/52.Financing/F39.%E6%A1%A5%E6%B0%B4%E5%85%A8%E5%A4%A9%E5%80%99%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F39.%E6%A1%A5%E6%B0%B4%E5%85%A8%E5%A4%A9%E5%80%99%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>@tag: #资产配置</p><p>风险平价(Risk Parity)理论，风险平价的意思是通过配置不同类型的资产（如股票、债券、商品、黄金等），目的是创造一个更好的分散组合，这个分散组合将有更好的收益风险比率，天候策略能适应各种经济环境，在风险最小的情况下获取市场平均回报。</p><p>在漫长的投研积累过程中，Ray Dalio 最终把经济环境拆分成了四类，并描绘出了全天候策略：</p><blockquote><p>这个四宫格和平时看到的不太一样，并不是把2个要素当做2个轴组成四宫格，黄色上下表示通胀高低，红色上下表示经济增长高低</p></blockquote><p><img src="/images/IMG20221003-2.png" alt=""></p><p>1、经济上升期：股票、商品、公司信用债、新兴市场债券将有较好表现；// 增长<br>2、经济下降期：普通债券、通胀联系债券表现较好； // 衰退<br>3、通胀上升期：通胀联系债券、商品、新兴市场债券表现较好； // 通胀<br>4、通胀下降期：股票、国债、公司债表现较好。 // 通缩</p><blockquote><p>比较<a href="/52.Financing/F21a.美林时钟/" title="F21a.美林时钟">F21a.美林时钟</a>，1对应复苏期，2=衰退期，3=通胀期，4没有对应（美林时钟把滞胀期考虑进去了，但没有考虑通缩，桥水全天候有通缩期）</p></blockquote><p>达里奥认为四宫格涵盖了可能出现的经济情形，而且这四种情形会等概率的情况出现，所以只需要在每种可能出现的场景中配置相同风险的资产，即可确保无论在哪种经济条件下都能很好控制风险敞口。</p><p>而桥水基金公司的全天候策略基金做的工作是，假定不知道图中四个象限内未来哪种资产表现较好，试图买入各种类别的资产相同权重（25%）来分散风险，也即是说“四宫格”期望通过将风险等量分布于四种经济环境来达到组合的分散和平衡。</p><p>@ref: <a href="http://www.etf.group/trade/834.html" target="_blank" rel="noopener">基于桥水的中国版全天候策略–ETF之家</a></p><hr><p>详细说风险平价(Risk Parity)理论：</p><p>全天候（AW）的理念：</p><ul><li>承认风险（波动无可避免），但AW组合要求在不同周期内风险要等分（波动率都25%）</li><li>每种资产给整个投资组合带来的波动率相同。简单的说，如果股票的波动率是国债的10倍，那么国债的持仓就应该是股票的10倍，这样股票和国债对投资组合的影响才能相同。并不是“当前时期的x资产收益最高，就在这个周期就优先多配x资产”。</li></ul><p>如上，全天候策略的特点是低波动低风险（Sharpe Ratio是0.73），收益率并不太高</p><p>为了实现Risk Parity，通常需要借助杠杆（主要是债券，因为波动率低，想让它和其他东西波动一样需要持有相当于资金量数倍的国债，这会就需要用到保证金交易了）。在几十年前，甚至现在，在资产组合里用上杠杆都会被视为是一种高风险的举动，虽然这样做可以实际上降低风险。<br>为了应对类似08这样的股市回调，Ray Dalio给AW加上了Depression gauge（萧条度量），似乎是在萧条时将股票转成T-Bills，具体细节不知。</p><p>一直有人质疑AW或RiskParity类基金赚钱只是因为放大了债券上的收益，赶上了债券几十大年牛市。<br>Bob Prince认为，加息发生在经济过热（至少是向好）或者通胀的时候，那时AW可以通过股票和商品获利。比如1972~81也是加息周期，但伴随着大通胀，所以AW表现也不错。</p><p>@ref: <a href="https://www.zhihu.com/question/22929725" target="_blank" rel="noopener">Ray Dalio 的「全天候交易策略」是什么？如何理解？ - 知乎</a></p><hr><p>如何执行风险平价(Risk Parity)策略？<br>比如上面提到了通过xx资产的波动率决定它在组合中的比例，是如何观测xx资产的波动率呢？</p><p>1，风险的度量。经典的有方差，VaR，ES等等，每家公司具体的选择不同，结果会很不同。2，数据的质量。这里的数据不是指价格的原始数据，而是作为模型输入的参数。举个例子，如果风险测度选择传统的方差，那就免不了涉及到协方差矩阵。原始数据直接估计出的协方差矩阵很noisy，最简单的方法是用高斯先验shrinkage一下</p><p>@ref: <a href="https://www.zhihu.com/question/24742021" target="_blank" rel="noopener">就算 Raymond Dalio 的「全天候交易策略」被公布出来，让其保持领先优势的核心在哪里？他人模仿的难点在哪？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F35.REITs</title>
      <link href="/52.Financing/F36.REITs/"/>
      <url>/52.Financing/F36.REITs/</url>
      
        <content type="html"><![CDATA[<p>@tag: #REITs</p><p><a href="https://xueqiu.com/3179670287/216537149" target="_blank" rel="noopener">在我的投资组合里，必须要持有什么样的REITs基金？ - 雪球</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F35.金融衍生品</title>
      <link href="/52.Financing/F35.%E9%87%91%E8%9E%8D%E8%A1%8D%E7%94%9F%E5%93%81/"/>
      <url>/52.Financing/F35.%E9%87%91%E8%9E%8D%E8%A1%8D%E7%94%9F%E5%93%81/</url>
      
        <content type="html"><![CDATA[<p>衍生品主要四大类：远期，互换，期权，期货</p><p> <a href="https://wiki.mbalib.com/wiki/%E7%BB%93%E6%9E%84%E6%80%A7%E7%90%86%E8%B4%A2%E4%BA%A7%E5%93%81" target="_blank" rel="noopener">结构性理财产品</a></p><h2 id="衍生品1-雪球"><a href="#衍生品1-雪球" class="headerlink" title="衍生品1-雪球"></a>衍生品1-雪球</h2><p><a href="https://xueqiu.com/9322843818/165295388" target="_blank" rel="noopener">与友漫谈——障碍期权之雪球结构 - 雪球</a></p><p>障碍期权可分为敲出期权（knock-out）和敲入期权（knock-in）两类。当标的资产价格达到一定水平时，敲出期权不再存在；当标的价格达到一定水平时，敲入期权才开始存在。我们常常听到的雪球结构期权就是障碍期权，设计中即包括敲入事件，也包括敲出事件，这样一来，最后的收益就取决于挂钩标的走势和敲入、敲出事件发生的时间</p><p>比如有这样一款产品：<br><img src="/images/IMG20221002.png" alt="../_images/IMG20221002.png"></p><p>收益计算规则：</p><ol><li>发生敲出事件，产品提前结束，具体收益需要用年化票息率计算，比如第1个月就敲出，实际持有1个月，18%/12=1.5%，收益=本金*1.5%。</li><li>发生敲入事件，未发生敲出事件。如果到期日股价&gt;期初价格，投资者收益为0；如果到期日股价&lt;期初价格，需承担标的下跌损失。</li><li>如果敲入和敲出都没有发生，产品12个月到期，按约定票息率18%结算。<br>由于最后的收益取决于挂钩标的走势和敲入、敲出事件发生的时间，那么会出现几种情形呢？</li></ol><p>在12个月期限内，共有5种可能性，逐一分析：<br><img src="/images/IMG20221002-1.png" alt="../_images/IMG20221002-1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F34.期货</title>
      <link href="/52.Financing/F34.%E6%9C%9F%E8%B4%A7/"/>
      <url>/52.Financing/F34.%E6%9C%9F%E8%B4%A7/</url>
      
        <content type="html"><![CDATA[<p>@tag: 期货</p><p><strong>开仓</strong>也叫建仓，是指投资者新买入或新卖出一定数量的股指期货合约。如果投资者将这份股指期货合约保留到最后交易日，他就必须通过现金交割来了结这笔期货交易。</p><ul><li>卖出合约一方，叫空方，货品（标的）跌价获利</li><li>买入合约一方，叫多方，货品涨价获利</li></ul><p><strong>持仓</strong>：股指期货投资者在开仓之后尚没有平仓的合约，叫做未平仓合约，也叫持仓。开仓之后股指期货投资者有两种方式了结股指期货合约：或者择机平仓，或者持有至最后交易日并进行现金交割。</p><ul><li>期货逐日盯市制度：每天都会结算一次保证金、合约的盈亏（如果合约涨价，空方需要把合约上涨的价格给多方账户，从空方保证金扣除，如果空方保证金不足，需要再补保证金</li><li>货品单价有可能跌成负的（a买入期货合约，但是又卖不出去无法平仓…</li></ul><p><strong>平仓</strong>，是指期货投资者买入或者卖出与其所持股指期货合约的品种、数量及交割月份相同但交易方向相反的股指期货合约，了结股指期货交易的行 为。</p><ul><li>一般期货都不会交割，而在交割前平仓</li><li>平仓分为对冲平仓和强行平仓</li><li>对冲平仓：对于多方，是卖出合约</li><li>强行平仓：如果未及时增加保证金，会被强行平仓</li></ul><p>@ref: <a href="https://baike.eastmoney.com/item/%e5%b9%b3%e4%bb%93" target="_blank" rel="noopener">词条页面_百科_东方财富网</a></p><p><strong>期货交割</strong>是指期货合约到期时，交易双方通过该期货合约所载商品所有权的转移，了结到期未平仓合约的过程。交割方式有现金交割、实物交割两类：现金交割是指合约到期日，核算交易双方买卖价格与到期日结算价格相比的差价盈亏，把盈亏部分分别结算到相应交易方，期间不涉及标的实物交割；实物交割是指合约到期日，卖方将相应货物按质按量交入交易所指定交割仓库，买方向交易所交付相应货款，履行期货合约。一般金融证券类期货合约以现金交易为主，商品期货合约以实物交割方式为主。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F33.债券</title>
      <link href="/52.Financing/F33.%E5%80%BA%E5%88%B8/"/>
      <url>/52.Financing/F33.%E5%80%BA%E5%88%B8/</url>
      
        <content type="html"><![CDATA[<p>@todo： 长端利率 </p><ul><li><a href="https://new.qq.com/rain/a/20210803A0AIWO00" target="_blank" rel="noopener">谁来决定长端利率？</a></li><li><a href="https://www.zhihu.com/question/277535562/answer/2475711808" target="_blank" rel="noopener">什么是长端利率，什么是短端利率？ - 知乎</a></li></ul><hr><p>关注几个指标：债券市场余额、存量、新发、成交额</p><p><a href="chrome-extension://oemmndcbldboiebfnladdacbdfmadadm/http://pdf.dfcfw.com/pdf/H3_AP201912311373114704_1.pdf" target="_blank" rel="noopener">华泰期货：中国债券市场结构介绍.pdf</a><br>截至2019年12月29日，中国债券市场余额达到96.96万<br>目前利率总存量为53.51万亿元，较年初增加6.16万亿，利率债市场仍然是目前国内最大的债券市场；信用债存量为32.83万亿元，较年初增加4.3万亿；同业存单数量为10.62万亿元，较年初增加0.74万亿元。</p><p><a href="http://www.gov.cn/xinwen/2021-01/26/5582794/files/960716cc49f7469a95fb9a82812de1b9.pdf" target="_blank" rel="noopener">2020年金融市场运行情况 .pdf</a>：<br>2020年，国债发行7万亿元，地方政府债券发行6.4万亿元，金融债券1发行9.3万亿元，政府支持机构债券发行3580亿元，资产支持证券发行2.3万亿元，同业存单发行19万亿元，公司信用类债券发行12.2万亿元</p><p>2020年，债券市场现券交易量253万亿元，同比增长16.5%。其中，银行间债券市场现券交易量232.8万亿元，日均成交9350.4亿元，同比增长12%。交易所债券市场现券成交20.2万亿元，日均成交830.4亿元，同比增长142.6%</p><p>股票市场：两市全年成交额206.83万亿元，同比增长62.3%，</p><hr><p>短融：<br>短期融资券(Commercial Paper, CP)，是指具有法人资格的非金融企业在银行间债券市场发行的，约定在1年内还本付息的债务融资债券，是一种流动性较高、风险较低的债券，所以从风险收益特征上看，这只基金有点像短债产品，风险收益介于货币基金与普通债券型基金之间。</p><h2 id="债券的收益率-vs-票面利率"><a href="#债券的收益率-vs-票面利率" class="headerlink" title="债券的收益率 vs 票面利率"></a>债券的收益率 vs 票面利率</h2><p>国债收益率 和 债券(基金)价格是负相关的：</p><blockquote><p>十年期国债收益率，完整的表述应该是十年期国债持有到期年化收益率（YTM）。它与国债价格是负相关关系，国债价格上涨，收益率就下跌；国债价格下跌，收益率就上涨。</p></blockquote><p>比如，一个十年期国债产品，票面价格是100元，发行时确定的<strong>票面利率</strong>是3.5%，每半年兑付一次利息。如果在国债交易市场上该产品的交易价格是90元，则买到该国债产品的持有人每年获得的收益就不是3.5%，而是3.5÷90×100%=3.89%。当然我们在英为财情等平台看到的实时国债收益率，它的计算方法（贴现率）比这个复杂，我们只需要了解这个道理就行了。</p><p><strong>票面利率（Coupon rate）</strong>：</p><p>票面利率是指发行债券时规定应付的并直接印刷在债券票面上的利率，表示每年应付的利息额与债券面额之比。<br>票面利率的高低直接影响着证券发行人的筹资成本和投资者的投资收益，一般是证券发行人根据债券本身的情况和对市场条件分析决定的。<br>债券的付息方式是指发行人在债券的有效期间内，向债券持有者分批支付利息的方式，债券的付息方式也影响投资者的收益。  　　</p><p>票面利率固定的债券通常每年或每半年付息一次。Coupon亦指息票，即附于债券上，供持有人支取利息的凭证。  　　</p><p>企业债券必须载明债券的票面利率。票面利率的高低在某种程度上不仅表明了企业债券发行人的经济实力和潜力，也是能否对购买的公众形成足够的吸引力的因素之一。  　　</p><p>债券的票面利率越低，债券价格的易变性也就越大。在市场利率提高的时候，票面利率较低的债券的价格下降较快。但是，当市场利率下降时，它们增值的潜力较大。如果一种附息债券的市场价格等于其面值，则到期收益率等于其票面利率；如果债券的市场价格低于其面值（当债券贴水出售时），则债券的到期收益率高于票面利率。反之，如果债券的市场价格高于其面值（债券以升水出售时），则债券的到期收益率低于票面利率。总之，债券价格、到期收益率与票面利率之间的关系可作如下概括：  　　</p><ul><li>票面利率＜到期收益率－债券价格＜票面价值 </li><li>票面利率=到期收益率－债券价格=票面价值</li><li>票面利率＞到期收益率－债券价格＞票面价值</li></ul><h2 id="国债"><a href="#国债" class="headerlink" title="国债"></a>国债</h2><p>➤十年期国债收益率是各类资产估值的锚:</p><p>资产从大类来讲有房产、股票（权益）、债券、商品、黄金、现金，等等。<br>逐利是资本的本性，另一方面资本随时在寻找价值（估值）洼地。所以我们创造了一个又一个的估值指标：房地产的投资价值用“租售比”衡量；股票有大家熟知的市盈率、市净率、市销率、巴菲特指标；商品、黄金有“金油比”、“金银比”等等。但所有这些估值都绕不开一个指标：<em>十年期国债收益率。它代表着市场无风险收益率</em>，是各种资产估值的“锚”。</p><p>➤GDP增速 和 国债收益率：<br>我国的十年国债收益率: 总体判断：如果我国GDP增速维持在6-6.5%的水平，十年期国债收益率就会围绕3.25%左右中值上下波动</p><h2 id="国债收益率在资产配置中的使用"><a href="#国债收益率在资产配置中的使用" class="headerlink" title="国债收益率在资产配置中的使用"></a>国债收益率在资产配置中的使用</h2><p>➤如果投资债券基金, 如何根据十年国债收益率调整 短/中/长期债券的配比?</p><ul><li>投资债券基金只在两种极端情况下有比较高的确定性：十年期国债收益率向上偏离接近4%，和向下偏离接近2.5%。</li><li>接近4%时逐步调升债券基金的久期，增加长久期的债券基金比例；接近2.5%时做反向操作，调降债券基金久期。为什么这样做呢？</li><li>久期越长的债券基金，在利率（收益率）下降过程中涨幅越大，同样，在利率（收益率）上升过程中跌幅也越大 // 应该在低利率(价格高)的时候, 减持?</li></ul><p>➤如果投资股票, 如何根据十年国债收益率调整仓位?<br>针对股市估值，最著名的估值模型就是 <em>股权风险溢价</em> ERP（Equity Risk Premium）了。根据这个模型，有两个公式（PE为全部A股市盈率，r为十年期国债收益率）：</p><p>（1）股权风险溢价:<br>  $$ 股权风险溢价=盈利收益率-市场无风险收益率=1/PE-r $$</p><p>（2）股债比:<br>  $$ 股债比=盈利收益率÷市场无风险收益率=1/PE÷r $$</p><ul><li>第一个公式: <em>股权风险溢价越低, 股市性价比越低,  考虑卖出股票</em> : 韭圈儿给出2021年3月25日的结论是这样的：当前股权风险溢价为1.43%，位于过去十年22.56%的时间，说明目前股市性价比低。</li><li>第二个公式: <em>股债比越低, , 股市性价比越低,  考虑卖出股票</em> : 有人根据近几年A股的历史数据作了回测得出这样的结论：股债比＞2.5，全仓买入；在2.0-2.5之间，只买不卖；1.5-2.0之间，只卖不买；1.5以下，考虑卖出。2021年3月25日万得全A市盈率为21.66，十年期国债收益率为3.217%，根据以上公式得出当前股权风险溢价为1.40%，股债比为1.44。结论：1.5以下，考虑卖出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F32g.商品ETF.期货和大宗</title>
      <link href="/52.Financing/F32g.%E5%95%86%E5%93%81ETF.%E6%9C%9F%E8%B4%A7%E5%92%8C%E5%A4%A7%E5%AE%97/"/>
      <url>/52.Financing/F32g.%E5%95%86%E5%93%81ETF.%E6%9C%9F%E8%B4%A7%E5%92%8C%E5%A4%A7%E5%AE%97/</url>
      
        <content type="html"><![CDATA[<p>@tag: 期货</p><p>@todo:</p><ul><li><a href="/52.Financing/F44.周期股/" title="F44.周期股">F44.周期股</a></li></ul><hr><ul><li><p><a href="https://www.zhihu.com/question/27376963/answer/36442797" target="_blank" rel="noopener">中国目前有商品指数基金吗？如果有，都有哪些？风险是什么？ - 知乎</a></p></li><li><p>“期货ETF的风险有换仓的耗损”: <a href="https://mp.weixin.qq.com/s?__biz=MzIyMjMwMDk2MQ==&amp;mid=2247483798&amp;idx=1&amp;sn=90d486b03b40674b5a704bad12911be3&amp;chksm=e82edfd8df5956ce0f88ed505c156eaeb606cc9f1304fc643d16a3d9f497d98e27b0f4fd093d" target="_blank" rel="noopener">交割制度与中行“原油宝”穿仓</a></p></li></ul><hr><p>银华抗通胀主题(QDII-FOF-LOF)，业绩比较基准-标普高盛商品总指数收益率 （S&amp;P GSCI Commodity Total Return Index） </p><p> 在全球范围内精选跟踪单个或大类商品价格的ETF，业绩比较基准90%以上是商品指数的共同基金，以及主要投资于通货膨胀挂钩债券的ETF或债券型基金的主题投资基金；</p><p> 本基金的投资组合比例为：投资于基金的资产合计不低于本基金基金资产的60%，其中不低于80%投资于抗通胀主题的基金，现金或者一年以内的政府债券投合计不低于基金资产净值的5%； </p><p>本基金所投资的商品类基金以跟踪商品指数或商品价格为投资目标，通常情况下不采用卖空策略，也不使用资金杠杆；</p><p> 一季度发布的持仓前三：<br>    • 15% Powershares DB Commodity INDEX（景顺DB商品ETF）<br>    • 15% iShares GSCI Commodity（标普高盛商品指数ETF ）<br>    • 15% United States Brent Oil Fund（布伦特原油基金）</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F32b.行业ETF</title>
      <link href="/52.Financing/F32b.%E8%A1%8C%E4%B8%9AETF/"/>
      <url>/52.Financing/F32b.%E8%A1%8C%E4%B8%9AETF/</url>
      
        <content type="html"><![CDATA[<h2 id="消费ETF"><a href="#消费ETF" class="headerlink" title="消费ETF"></a>消费ETF</h2><p><a href="https://zhuanlan.zhihu.com/p/59848715" target="_blank" rel="noopener">必须消费行业，指数基金如何选 - 知乎</a></p><p>必须消费类指数：</p><ul><li><p>上证消费（000036）选择上海证券市场主要消费行业股票组成，以反映该行业公司股票的整体表现。该指数成分股为30只，前十大权重占比71.63%，其中贵州茅台、伊利股份、海天味业三只个股的权重占比超过43%，典型的食品饮料蓝筹属性。该指数权重集中，龙头汇集，缺点是没有涵盖深市龙头。</p></li><li><p>中证消费（000932）中证主要消费指数由中证800指数样本股中的主要消费行业股票组成，成分股为41只，代表A股市场中大市值消费类股票指数，白酒板块个股占比较高，龙头股集中。业绩上不分伯仲，建议投资者选择汇添富中证主要消费ETF(159928)，嘉实中证主要消费ETF（512600）这只产品的规模只有600万，存在清盘风险。</p></li><li><p>全指消费(000990) 全指消费指数从中证全指样本股主要消费行业内选择流动性和市场代表性较好的股票构成指数样本股，由134只个股组成，主要权重集中食品饮料行业。广发基金管理的中证全指共有3只基金产品（001458、002976、159946），由于产品规模持续下滑，已经停止申购，被清盘的概率很大，非常可惜。</p></li></ul><p>可选消费指数：</p><ul><li>中证可选消费指数 (000989) 目前全市场可选消费指数只有中证可选消费指数一只 ，包含432只成份股，前十大权重中家电、汽车占比较高，其中美的和格力占比超过20%。</li></ul><p>消费主题（消费主题指数编制规则没有主要消费和可选消费之分，只要符合条件即可选入）：</p><ul><li>上证消费80成份股由沪市规模靠前的80只主要消费+可选消费+医药卫生组成，主要消费占比39.5%，可选消费占比27.1%，医药占比33.3%，相当于是沪市消费+医药大蓝筹集合。</li><li>中证消费龙头和中证消费50两者的编制思路较为接近，都是选消费龙头。他俩的主要区别在于消费50剔除了汽车和传媒两大可选消费，因此同样是选龙头，消费龙头在可选消费/主要消费方面没有偏向，而消费50偏向主要消费。</li></ul><p>消费细分：</p><ul><li>CS食品饮料：中证主要消费指数，它和CS食品饮料指数接近，食品占比较高，两者的主要区别在于中证主要消费生猪养殖企业占比更高。</li><li>细分食品：细分食品和国证食品中酒占比较高，比分别是64%、63%，食品占比大约是35%</li><li>国证食品：</li><li>中证白酒：</li></ul><h2 id="医疗ETF"><a href="#医疗ETF" class="headerlink" title="医疗ETF"></a>医疗ETF</h2><p>@ref: <a href="https://zhuanlan.zhihu.com/p/135926833" target="_blank" rel="noopener">生物医药行业，ETF如何选 - 知乎</a></p><p>下面这幅图是对行业的划分，并标记整个产业链相关龙头企业，建议保存好。<br><img src="/images/20220409150801.png" alt=""></p><ul><li>药械可以理解为产业上游企业，主要是研发、生产环节，包含：中药、化学药、生物药、器械；</li><li>服务分为两方面，一方面是医疗服务机构，比如民营医院、体检机构；另一方面是医药研发相关的服务机构（外包服务），比如CRO、CMO、CSO等等。</li></ul><p>相关指数：</p><ul><li>医药50（931140）：   沪深两市医药卫生行业规模最大的50个公司</li><li>300医药（000913）： 以沪深300指数样本股…</li><li><p>中证医药（000933）：以中证800指数样本股中的医药卫生行业公司组成（中证800=300+500）</p></li><li><p>CS创新药（931152）：以中证全指指数为样本，主营创新药研发的公司</p></li><li><p>CS生药（930726）：以中证全指指数为样本，主营基因、疫苗、血液制品等的公司</p></li><li><p>中证医疗（399989）：沪深A股中涉及医疗器械、医疗服务的公司</p></li></ul><p>比较近7年收益：CS创新药&gt;300医药&gt;CS生药&gt;中证医疗&gt;中证医药<br><img src="/images/20220409150915.png" alt=""></p><hr><ul><li>医疗ETF（512170）：中证医疗指数(399989)，选取沪深A股中涉及医疗器械、医疗服务的公司股票作为指数样本股。</li><li>医药ETF（512010）：沪深300医药卫生指数(000913)，选取沪深300指数样本股中的医药卫生行业公司股票作为指数样本股。</li></ul><h2 id="制造业ETF"><a href="#制造业ETF" class="headerlink" title="制造业ETF"></a>制造业ETF</h2><p>@ref: <a href="https://zhuanlan.zhihu.com/p/427858760" target="_blank" rel="noopener">一文看懂新能源出题ETF - 知乎</a></p><ul><li><p>新能源主题一键打包:</p><ul><li>中证新能源（399808）<ul><li>南方中证新能源ETF（516160）</li></ul></li><li>新能源（000941）</li></ul></li><li><p>新能源车指数:</p><ul><li>智能电车（H11052）</li><li>新能源车（930997）<ul><li>平安中证新能源汽车产业ETF（515700）</li></ul></li><li>CS新能车（399976）<ul><li>华夏中证新能源汽车ETF（515030</li></ul></li><li>国证新能源车（399417）</li></ul></li><li>电池指数:<ul><li>新能源电池（980032）<ul><li>广发国证新能源车电池ETF（159755）</li></ul></li><li>CS电池（931719）</li></ul></li><li>光伏指数:<ul><li>光伏产业（931151）指数<ul><li>华泰柏瑞的中证光伏产业ETF（515790）</li></ul></li></ul></li><li>环保+碳中和指数:<ul><li>中证内地低碳经济主题指数（000977）<ul><li>易方达碳中和50ETF（516070）</li></ul></li><li>中证环保产业50指数（930614）</li></ul></li></ul><p><img src="/images/20220409152245.png" alt=""></p><h2 id="半导体ETF"><a href="#半导体ETF" class="headerlink" title="半导体ETF"></a>半导体ETF</h2><p><a href="https://zhuanlan.zhihu.com/p/115506253" target="_blank" rel="noopener">投半导体ETF前，还是仔细看看半导体指数有什么差 - 知乎</a></p><p><a href="https://xueqiu.com/5941996397/164441366" target="_blank" rel="noopener">半导体芯片基金哪家强！ - 雪球</a><br>总结一下三个指数：</p><p>①把三个指数的全部成分股列出来，其实成分股高度的相似，特别是中证全指半导体，几乎所有的成分股在中华半导体以及国证芯片里都能找到</p><ul><li>指数编制的行业选择上，中华半导体以及国证芯片都是选择了芯片产业链上的材料、设备、设计、制造、封装和测试等</li><li>而中证半导体则是细分产品以及设备，稍微跟上面的不一样，我理解是这个指数认为半导体产业里面，更重要的是产品以及设备？</li></ul><p>②指数编制上，三者都是在日均成交金额以及市值的基础上进行挑选。</p><p>中华半导体跟国证芯片很相似，但国证芯片的条件要更加苛刻</p><p>③三个指数估值，国证芯片综合来看，各项数据都是最优</p><p>④我们经常说，目前是少数个股的结构性牛市，成分股指数更少的基金往往表现的更好。而成分股更少，侧面说明指数编制的时候要更加严格，更加精选。</p><p><a href="https://finance.sina.com.cn/money/fund/jjcl/2020-01-09/doc-iihnzhha1211973.shtml" target="_blank" rel="noopener">介绍一个热门的指数：国证芯片指数投资价值分析|产业链<em>新浪财经</em>新浪网</a></p><p>➤ 国证芯片指数:<br>为反映A股市场芯片产业相关上市公司的市场表现，丰富指数化投资工具，深证信息公司于2015年编制并发布了国证半导体芯片指数(8502.587, 116.75, 1.39%)。该指数从芯片产业中材料、设备、设计、制造、封装和测试等A股上市公司中选取样本股，并以2002年12月31日为基日，1000点为基点。截至2019年12月31日，国证芯片指数成份股个数为25只，总市值8289亿元，个股平均市值332亿元。</p><p>从指数成份股来看，国证芯片指数囊括了A股芯片产业链上的龙头企业。从产业链细分环节来看，国证芯片指数成份股在芯片设计、芯片制造领域的累计权重最高，分别为39.74%、28.61%，在芯片封测、芯片材料、芯片设备领域的权重分别为13.10%、10.14%、8.41%</p><p>前十大成份股合计占比71.89%，其中5家属于芯片设计公司，合计权重34.53%。</p><ul><li>第一大成份股三安光电(20.820, -0.62, -2.89%)占比为10.63%，是LED芯片龙头企业，具有强大的技术壁垒，在专利、客户和产品方面远远领先于其他国内厂商，本轮LED芯片行业洗牌后，龙头集中度有望持续提升；同时公司的砷化镓射频产品已与100多家客户有业务接触，氮化镓射频已实现客户送样，电力电子产品已进入量产阶段，化合物半导体业务成长可期。</li><li>第二大成份股兆易创新(127.090, 3.51, 2.84%)占比9.82%，是中国存储芯片设计领先公司，存储业务包括NOR Flash、NAND Flash和DRAM，是内资唯一一个存储全产业布局的企业，并迅速在多个领域做大做强，成为中国存储行业的领先企业。同时公司业务不断向MCU、传感器等领域渗透，在物联网领域的布局已经形成闭环，未来众多业务将共同拉动公司业绩增长。根据网易援引自CINNO RESEARCH的数据，19Q2 NOR FLASH市场，公司市场份额为13.9%，超越Micron，位居全球第四。</li></ul><p>➤ 中华半导体指数追踪中国A股市场半导体行业上市公司的股价表现，相关公司经营范围涵盖半导体材料、设备、设计、制造、封装和测试，成份股个数为50只；</p><p>➤ 中证全指半导体指数选取中证全指样本股中的半导体产品与设备行业股票组成，成份股个数为32</p><h2 id="互联网ETF"><a href="#互联网ETF" class="headerlink" title="互联网ETF"></a>互联网ETF</h2><ul><li>易方达中概互联ETF(513050)：追踪中证海外互联网50指数，单样本权重不超过30%；</li><li>广发中概互联ETF(159605)：追踪中证海外互联网30指数，单样本权重不超过15%，前五大样本权重合计不超过60%</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F32.宽基ETF</title>
      <link href="/52.Financing/F32a.%E5%AE%BD%E5%9F%BAETF/"/>
      <url>/52.Financing/F32a.%E5%AE%BD%E5%9F%BAETF/</url>
      
        <content type="html"><![CDATA[<p>@tag: #基金 #ETF</p><h2 id="选择宽基指数"><a href="#选择宽基指数" class="headerlink" title="选择宽基指数"></a>选择宽基指数</h2><p>选择宽基指数，需要注意指数构成是否有过大的调整。比如今年5月，中证100这个很重要的宽基指数，就发生了一次指数编制机制的修改。加大了对ESG因子的参考权重，从权重指数变成了ESG指数。</p><p>以及指数的估值中枢近几年是否有较大的变化： 例如中证500，如果看的是十年PE百分位，会把2015年也包括进去。2015年的中证500还是小盘成长指数，指数估值在2015的爆炒中泡沫很大，中证500的估值中枢从2017年以来就一直处于一个下行的阶段。会使现在的估值百分位看起来“很低”但实际上并不低。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NjU2ODMzNw==&amp;mid=2247487964&amp;idx=1&amp;sn=e534d7c8a245afe58e363a7567f5e169&amp;chksm=ec4302a2db348bb489db053e5a38ce39732b26f7301be8217d0090820c560e65932233ccf7cb&amp;token=1924071754&amp;lang=zh_CN#rd" target="_blank" rel="noopener">定投宽基指数，除了估值的历史分位数，还应该注意什么？</a></p><h2 id="MSCI-A50"><a href="#MSCI-A50" class="headerlink" title="MSCI A50"></a>MSCI A50</h2><p><a href="https://www.msci.com/cn/indexes/china-a-50-connect" target="_blank" rel="noopener">https://www.msci.com/cn/indexes/china-a-50-connect</a><br>MSCI中国A50互联互通指数于 2021年8月20日推出。</p><p>MSCI中国A50互联互通指数采用创新的方法，从满足互联互通条件的最大市值股票中选取50支，确保分散化的板块配置，均衡代表广泛的中国A股市场。该指数旨在使国际和国内投资者能够追踪中国行业领头羊，包括关键行业板块的领先股票，并且作为指数挂钩的ETF和ETN以及其它金融产品的基础。</p><p>MSCI中国A50互联互通指数采用行业中性的方法，旨在代表50只大盘中国A股的表现。该指数基于我们的旗舰MSCI中国A股指数（母指数），满足我们所有的可投资性要求（请参阅MSCI全球可投资市场指数方法论），并且符合互联互通要求，代表包括中国的新经济的整体市场机会。该指数在每个行业至少纳入两只股票，使配置分散遍及整个中国经济领域。该指数以实现优于简单50强方法的行业均衡敞口为目标，避免对金融或日常消费品行业的超配。</p><h2 id="历史数据：300-vs-500-vs-创业板"><a href="#历史数据：300-vs-500-vs-创业板" class="headerlink" title="历史数据：300 vs 500 vs 创业板"></a>历史数据：300 vs 500 vs 创业板</h2><p>@Onenote 《宽基指数基金》</p><h2 id="创业板、科创、双创"><a href="#创业板、科创、双创" class="headerlink" title="创业板、科创、双创"></a>创业板、科创、双创</h2><p>2020~今，创业板50 &gt; 创业板 &gt; 科创50 ≈ 科创创业(双创)</p><p><img src="/images/20220409150456.png" alt=""></p><p>近3年:<br><img src="/images/20220409150553.png" alt=""></p><hr><p><a href="https://caifuhao.eastmoney.com/news/20200317204106792522210" target="_blank" rel="noopener">跟踪创业板 ：一图看懂创业板指数家族<em>财富号</em>东方财富网</a></p><ul><li>创业板指（399006）由创业板中市值大、流动性好的100只股票组成，反映创业板市场的运行情况；</li><li>创业板综（399102）选取在深圳证券交易所创业板上市的全部股票，反映创业板市场的总体趋势；</li><li>创业板50（399673）由创业板市场中日均成交额较大的50只股票组成，反映了创业板市场内知名度高、市值规模大、流量性好的企业整体表现。</li><li>创业蓝筹（399295）即创业板低波蓝筹指数，从盈利、会计稳健、投资稳健、违约风险和低波动五个维度综合选取50只创业板股票，反映创业板中具备良好盈利能力、具有稳健财务质量、且波动率较低的上市公司整体运行情况。</li><li>创成长（399296）即创业板动量成长指数，由创业板市场中具有良好成长能力和动量效应的50只股票组成，反映创业板中成长能力好、动量效应显著的上市公司整体运行情况；</li><li>创业成长（000958）即中证创业成长指数，由具备创业和高成长特征的100只股票组成，旨在刻画沪深两市创业和成长特征较为显著的中小型上市股票群体的整体表现；</li><li>创业价值（000838）即中证创业价值指数，由在创业板、中小板以及主板市场上市的具备创业和价值特征的100只股票组成，旨在刻画沪深证券市场内创业和价值较为显著的中小型上市股票群体整体表现。</li></ul><p><a href="https://www.zhihu.com/question/466070312/answer/1975276732" target="_blank" rel="noopener">科创50和创业板50哪个性价比高？ - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/371954065" target="_blank" rel="noopener">创业板指数ETF机会 - 知乎</a></p><ul><li>2020年创业板指涨幅约为64.96%，上证综指、深证成指涨幅分别约为13.87%和38.73%</li><li>易方达创业ETF(159915）：创业板指数（在剔除创业板上市所有股票最近半年日均成交总额后10%后，选取日均总市值前100名的股票构成样本股）【126亿，0.50%，0.10%】</li><li>天弘创业板ETF（159977）：创业板指数【36亿，0.50%，0.10%】</li><li><p>南方创业板ETF（159948）：创业板指数【23亿，0.15%，0.05%】</p></li><li><p>华安创业50ETF(159949）：创业板50指数（在创业板指的100只股票中，选取最近半年日均成交额排名靠前的50只股票作为创业板50的样本股）【104亿，0.15%，0.05%】</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/297062606" target="_blank" rel="noopener">四家科创板50ETF哪家强？ - 知乎</a></p><ul><li>华夏科创50ETF（588000）：上证科创板50指数收益率【200亿，0.50%，0.10%】</li><li>易方达科创板50ETF（588080）：上证科创板50指数收益率【110亿，0.50%，0.10%】</li><li>工银瑞信科创ETF（588050）：上证科创板50指数收益率【48亿，0.50%，0.10%】</li><li>华泰科创板ETF（588090）：上证科创板50指数收益率【29亿，0.50%，0.10%】</li></ul><p><a href="https://www.zhihu.com/question/466070312/answer/1975276732" target="_blank" rel="noopener">科创50和创业板50哪个性价比高？ - 知乎</a></p><ul><li>科创50：半导体、信息科技</li><li>创业板50：医疗、新能源、电子</li><li>基日至今，科创50指数年化波动率为41.60%，创50指数年化波动率为31.44%。综合来看，年初至今，创50指数在收益风险比上表现更佳，夏普比率接近科创50指数的两倍。</li><li>从ROE角度看，去年年报科创50较优，今年三季报创50更优。</li><li>科创50指数与创50指数的自由流通市值分布差异较大。科创50指数目前大多数成分股的自由流通市值都较小，42只成分股自由流通市值在100亿元以下，占指数权重的84%，这里面也有解禁的问题。创50指数汇集了创业板的头部公司，大多都是成熟期的新兴科技企业，成分股自由流通市值在100亿元以上的企业居多，其中48%的权重在100至300亿元之间，18%的权重在500亿元以上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F32.指数基金smartBeta策略</title>
      <link href="/52.Financing/F32.%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91smartBeta%E7%AD%96%E7%95%A5/"/>
      <url>/52.Financing/F32.%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91smartBeta%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>@tag: #基金 #ETF</p><p>Smart Beta 策略常见因子：</p><ul><li>质量因子：通过企业基本面筛选优质的成份股，倾向于选择具有稳定收入和盈利能力的公司，常见的质量因子包括净资产收益率、总资产收益率等。</li><li>成长因子：侧重公司未来的盈利，选择中长期业绩增长较快的公司进行投资，可以使用营业收入增长率、净利润增长率等指标。成长因子是进攻之王，在流动性宽松、估值扩张这样的环境下往往表现优异。</li><li>价值因子：以一系列指标衡量公司股价是否相对其价值低估，常见的价值因子相关指标包括市净率、市现率、市销率等。</li><li>红利因子：主要以股息率为选股标准，目的在于选取分红较高的股票。红利因子可以获得超额收益的逻辑在于，分红的基础是盈利，而高分红的基础是高的累计盈余，这些体现的是一个企业良好的经营状况。</li><li>低波动因子：通过降低波动率，倾向于选择成熟的公司，这类公司往往表现出更好的风险调整收益。</li></ul><p>值得注意的是，红利因子的使用最为久远。长年稳定分红的公司，盈利能力和财务状况都比较好，是成熟的机构投资者最喜欢的标的。当市场处于熊市时，分红率高的公司一般被视为防御属性标的，相对表现会更为稳健；当市场处于牛市时，随着股价的上涨，股票的股息率就会减少，股息率低的股票会自动剔除出组合，因此，在市场上涨的过程中，红利因子往往也表现不错。</p><p>因子策略既可单独使用，即单因子策略，也可组合使用，形成多因子策略。随着市场的发展和研究的深入，因子策略仍在不断完善。近年来，越来越多的Smart Beta指数是以复合因子来实现，比如质量因子和价值因子混搭的复合策略，比如红利因子与低波动因子混搭的复合策略，中证东方红红利低波动指数(简称：东证红利低波，代码931446)就是具有复合策略的Smart Beta指数，值得关注。</p><p>Smart Beta指数基金让投资者了解可能提供超额回报的源头，并且让投资者能够以比较方便的途径去进行投资，获得这些因子回报。</p><hr><p>系列： <a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNzUwMQ==&amp;mid=2247495406&amp;idx=1&amp;sn=4e5aeab504f77e623a8bd55fc2ba2c33" target="_blank" rel="noopener">Smart beta策略研究和指数基金分析</a></p><ul><li>Smart beta策略研究和指数基金分析①——价值(低估值)</li><li>Smart beta策略研究和指数基金分析②——质量(高ROE)</li><li>Smart beta策略研究和指数基金分析③——红利</li><li>Smart beta策略研究和指数基金分析④——低波动</li><li>Smart beta策略研究和指数基金分析⑤——成长</li><li>Smart beta策略研究和指数基金分析⑥——动量</li><li>Smart beta策略研究和指数基金分析⑦——市值（规模&amp;大小盘）</li><li>Smart beta策略研究和指数基金分析⑧——基本面</li><li>Smart beta策略研究和指数基金分析⑨——等权重</li><li>Smart beta策略研究和指数基金分析⑩——多因子</li></ul><p>作者：零城逆影<br>链接：<a href="https://xueqiu.com/9290769077/122476700?page=3" target="_blank" rel="noopener">https://xueqiu.com/9290769077/122476700?page=3</a><br>来源：雪球<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>风险提示：本文所提到的观点仅代表个人的意见，所涉及标的不作推荐，据此买卖，风险自负。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F32.ETF索引</title>
      <link href="/52.Financing/F32.ETF%E4%BA%A7%E5%93%81%E7%B4%A2%E5%BC%95/"/>
      <url>/52.Financing/F32.ETF%E4%BA%A7%E5%93%81%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ETF分类索引"><a href="#ETF分类索引" class="headerlink" title="ETF分类索引"></a>ETF分类索引</h1><p>@tag: #基金 #ETF</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 宽基ETF：&#123;% post_link 52.Financing/F32a.宽基ETF &apos;F32a.宽基ETF&apos; %&#125;</span><br><span class="line">* 行业ETF：</span><br><span class="line">* 商品ETF：&#123;% post_link 52.Financing/F32g.商品ETF.期货和大宗 &apos;F32g.商品ETF.期货和大宗&apos; %&#125;</span><br><span class="line">* 货币/债券ETF:</span><br></pre></td></tr></table></figure><h1 id="ETF交易指南（2021最新版）zz"><a href="#ETF交易指南（2021最新版）zz" class="headerlink" title="ETF交易指南（2021最新版）zz"></a>ETF交易指南（2021最新版）zz</h1><p> @ref: <a href="https://zhuanlan.zhihu.com/p/340812618" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/340812618</a></p><p>1975年，先锋基金（Vanguard）发行全球第一只指数投资信托 ，跟踪标普500指数，起初被动投资策略并不被市场所接受，指数投资发展非常缓慢。</p><p>1993年，美国证券交易所推出了全球第一只跟踪S&amp;P500指数的ETF——标准普尔存托凭证SPDR。自此，以ETF为代表的指数基金在美国蓬勃发展。</p><p>2004年，国内第一只ETF基金——华夏上证50ETF（510050）诞生。它的到来不仅仅是填补了市场的空白，并以低费率、高效率的优势在指数基中占主要市场份额，此后ETF产品在国内盛行。</p><p>截至2020年12月30日，已上市ETF多达341只，总规模8193.72亿元（统计数据剔除货币ETF，产品数量27只，基金规模2650.85亿元）。</p><p>相比2019年，ETF基金规模大增2493亿，产品新增数量115只，ETF基金成为全市场发展最快的指数产品。当下，ETF基金产品已形成全方位的投资阵型：类固收性质的货币ETF、债券ETF，为投资者提供便捷的场内现金理财需求。</p><h2 id="ETF产品线架构图"><a href="#ETF产品线架构图" class="headerlink" title="ETF产品线架构图"></a>ETF产品线架构图</h2><p><img src="/images/20220328003603.png" alt="../_images/20220328003603.png"></p><h2 id="权益类ETF"><a href="#权益类ETF" class="headerlink" title="权益类ETF"></a>权益类ETF</h2><p>权益类ETF也可以称为股票ETF，在ETF家族中占比最大，所跟踪指数也最为丰富。</p><p>由于产品多达286只容易混淆，因此ETF之家将权益类ETF又划分为四类，分别是宽基、行业、主题、策略（Smart Beta）。</p><p><img src="/images/20220328003620.png" alt=""></p><h2 id="跨境ETF"><a href="#跨境ETF" class="headerlink" title="跨境ETF"></a>跨境ETF</h2><p>跨境ETF是指全部或者部分资产投资于中国内地以外的证券指数所对应组合证券的开放式基金。简单而言，跨境ETF就是“跟踪境外指数，在境内上市交易”的ETF产品。</p><p><img src="/images/20220328003736.png" alt=""></p><h2 id="债券ETF"><a href="#债券ETF" class="headerlink" title="债券ETF"></a>债券ETF</h2><p>当前市场上的债券ETF按债券资产细分可分为三类，分别是：利率债、信用债、可转债。// @link: <a href="/52.Financing/F33.债券/" title="F33.债券">F33.债券</a></p><p><img src="/images/20220328003830.png" alt=""></p><p>利率债分为国债和地方政府债，利率债的价格主要受利率变动影响。利率债ETF产品：5年地方债ETF（511060）、国债ETF（511020）。</p><p>信用债ETF则包含公司债和企业债两类，公司债ETF主要发行方为上市公司，相对数量较多，企业债主要由长周期央企项目建设和城投债组成。举例信用债ETF：公司债ETF（511030）。</p><p>可转债指数：中证转债及可交换债指数（931078.CSI），指数样本券由沪深交易所上市的可转换公司债券和可交换公司债券组成。</p><p>债券ETF产品市场成交量较小，购买此类产品的投资者切记选择流动性好的产品入手。</p><h2 id="商品ETF"><a href="#商品ETF" class="headerlink" title="商品ETF"></a>商品ETF</h2><p>商品ETF由10只黄金ETF、3只商品期货ETF组成。</p><p><img src="/images/20220328003916.png" alt=""></p><h2 id="货币ETF"><a href="#货币ETF" class="headerlink" title="货币ETF"></a>货币ETF</h2><p>截至当前，市场上共有27只货币ETF，其中华宝添益（511990）和银华日利（511880）资金规模有优势、流动性好</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F31.投资的α和β系数</title>
      <link href="/52.Financing/F31.%E6%8A%95%E8%B5%84%E7%9A%84%CE%B1%E5%92%8C%CE%B2%E7%B3%BB%E6%95%B0/"/>
      <url>/52.Financing/F31.%E6%8A%95%E8%B5%84%E7%9A%84%CE%B1%E5%92%8C%CE%B2%E7%B3%BB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是α-β系数"><a href="#什么是α-β系数" class="headerlink" title="什么是α / β系数"></a>什么是α / β系数</h1><blockquote><p>在投资领域中，收益分为阿尔法(α)收益和贝塔(β)收益，其中，α指主动投资收益，来源于选股和择时，超越市场收益；β指被动投资收益，来源于组合和市场相关的收益，跟随市场收益。</p></blockquote><p>衡量一个基金（or 投资品）的表现：</p><p>$$ Y = α + βX + u $$</p><ul><li>Y： 股票或基金的表现</li><li>α： 阿尔法，基金收益减去基准的波动率，获得的超额收益</li><li>β：贝塔，是相对于“基准”的波动率，可能带来收益也可能带来亏损</li><li>X： 基准，例如可以使用沪深300指数</li><li>u：残差，这是一年中无法解释的随机表现部分</li></ul><h2 id="➤-关于α"><a href="#➤-关于α" class="headerlink" title="➤ 关于α"></a>➤ 关于α</h2><p>这些股票型基金如果取得超越沪深300指数的收益率，那么多出来的部分就叫超额收益“α”。举个例子，假设沪深300指数过去一年的时间盈利为10%，B基金在同样的时间里盈利为15%，市场的无风险利率为零，那么B基金取得的超额收益α值就是5%。</p><p>对冲基金的策略就是「去掉β，保留α」</p><h2 id="➤-关于β"><a href="#➤-关于β" class="headerlink" title="➤ 关于β"></a>➤ 关于β</h2><p>贝塔策略是指被动跟踪指数的策略。从长期来讲，贝塔策略是可能盈利的，但由于股票市场波动比较大，在某段特定时间内往往会出现亏损或被套住的状况。该策略在上涨趋势和下跌趋势中都好于对冲策略。比如上涨趋势中，要么只做多股票，要么只做多期指；在下跌趋势中，要么只做空期指，要么只融券卖出。当然，这要求对于行情中长期的趋势要有个准备的判断。</p><p>举例：假设沪深300指数在过去一年的时间里下跌了20%，A基金在相同的时间里下跌了18%，那么A基金的β系数就是0.9 （大部分成长型企业的β系数是大于1的）</p><p>Smart Beta strategy（聪明贝塔策略）：<br>以“Smart Beta”为策略的基金本质上追求的不再是对指数的紧密跟踪，而是希望通过在指数编制过程中对选股和权重安排的优化，获得跑赢传统市值加权指数的超额收益。</p><p>Smart Beta指数相当于把优秀的主动管理人的管理理念和管理方法提炼出来，形成指数标准化的投资框架，用指数方法表达出来。Smart Beta指数通过将股票的回报分解到因子层面，揭示出股票获得超额收益的源头。经过国外长期的理论与实践发现，价值、质量、成长、红利、低波动等因子是最有长期获取超额收益能力的因子。</p><p>详细参考： <a href="/52.Financing/F32.指数基金smartBeta策略/" title="F32.指数基金smartBeta策略">F32.指数基金smartBeta策略</a></p><hr><p>@ref: </p><ul><li><a href="http://abcexchange.io/articles/investing/092115/alpha-and-beta-beginners.asp" target="_blank" rel="noopener">初学者的Alpha和Beta</a></li><li><a href="https://zhuanlan.zhihu.com/p/358388935" target="_blank" rel="noopener">聊聊对冲策略（一）：α（alpha）和β（beta） - 知乎</a></li><li><a href="https://www.zhihu.com/question/34726812/answer/608442310" target="_blank" rel="noopener">smart beta 是什么？为什么最近如此受追捧？ - 伍治坚的回答 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F30.可投资的金融产品Index</title>
      <link href="/52.Financing/F30.%E5%8F%AF%E6%8A%95%E8%B5%84%E7%9A%84%E9%87%91%E8%9E%8D%E4%BA%A7%E5%93%81Index/"/>
      <url>/52.Financing/F30.%E5%8F%AF%E6%8A%95%E8%B5%84%E7%9A%84%E9%87%91%E8%9E%8D%E4%BA%A7%E5%93%81Index/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 多头基金：[[F31.基金101]]</span><br><span class="line">* 债券大类：&#123;% post_link 52.Financing/F33.债券 &apos;F33.债券&apos; %&#125;</span><br><span class="line">* 期货：&#123;% post_link 52.Financing/F34.期货 &apos;F34.期货&apos; %&#125; 和 ETF</span><br><span class="line">* REITs：[[F35.REITs]]</span><br><span class="line">* 固收+：@Onenote</span><br><span class="line">* 衍生品：&#123;% post_link 52.Financing/F35.金融衍生品 &apos;F35.金融衍生品&apos; %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>金融衍生品（derivatives)，是指一种基于基础金融工具的金融合约，其价值取决于一种或多种基础资产或指数，合约的基本种类包括远期合约、期货、掉期（互换）和期权。 金融衍生品还包括具有远期、期货、掉期（互换）和期权中一种或多种特征的混合金融工具。 这种合约可以是标准化的，也可以是非标准化的</p></blockquote><p><a href="https://xueqiu.com/u/9322843818" target="_blank" rel="noopener">南十里 - 雪球</a>很多有关股指期货的文章：想要真正了解衍生品世界，比如期权和期货市场，有时需要用不同方式去思考，而且这些方式通常都会让我们脱离自己的思维舒适地带。爱因斯坦曾说过：“任何一个聪明的傻瓜都可以把问题搞得更大、更复杂、更激烈。而朝相反方向前进，则需要一点点天分以及很大的勇气。”</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> _Index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F29.蒙代尔不可能三角</title>
      <link href="/52.Financing/F29.%E8%92%99%E4%BB%A3%E5%B0%94%E4%B8%8D%E5%8F%AF%E8%83%BD%E4%B8%89%E8%A7%92/"/>
      <url>/52.Financing/F29.%E8%92%99%E4%BB%A3%E5%B0%94%E4%B8%8D%E5%8F%AF%E8%83%BD%E4%B8%89%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<p>蒙代尔不可能三角：一个国家不可能同时实现<em>货币政策独立性</em>、<em>汇率稳定</em>以及<em>资本自由流动</em>三大金融目标，只能同时选择其中的两个。</p><p><img src="/images/蒙代尔不可能三角.png" alt=""></p><p>其他：<a href="https://zhuanlan.zhihu.com/p/362624382" target="_blank" rel="noopener">“蒙代尔不可能三角”还适用吗？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F29.费雪公式</title>
      <link href="/52.Financing/F29.%E8%B4%B9%E9%9B%AA%E5%85%AC%E5%BC%8F/"/>
      <url>/52.Financing/F29.%E8%B4%B9%E9%9B%AA%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>费雪公式：</p><p>   $$ MV = PT $$</p><p>其中，M=一定时期货币数量，V=货币流通速度，P=各类商品价格的加权平均数，T=各类商品的交易数量。<br>放水意味着M ↑，但P一定也↑吗？ 不一定，因为有V和T，如何解释“货币流通速度”  以及如何衡量 “各类商品交易数量”？</p><p>V可以看作银行贷款流动性（不够准确）：当经济不景气的时候，大众消费信心下降、企业减少贷款，导致V（流动性）不足；<br>进一步解释V：</p><blockquote><p>我们期望的美好情形是这样的：银行贷给A企业100万，A企业用这笔贷款中的30万发放工资、70万向B企业采购原材料，工人拿到工资后会用这30万购买C企业的产品，B企业用这70万转而支付欠D企业的账款……而不论哪一个环节，支付大都是通过银行进行的，每一个环节都会导致收款银行的存款增加，这样银行就有更多的钱再贷出去。</p></blockquote><p>再看T（各类商品交易数量）：正常的市场经济国家，全球化的大市场，绝大多数商品的现状都是过剩。</p><p>@ref: <a href="https://xueqiu.com/2356382715/179273735" target="_blank" rel="noopener">大放水不一定引起大通胀，但一定会让不投资的人更穷 - 雪球</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F27d.贴现率</title>
      <link href="/52.Financing/F27d.%E8%B4%B4%E7%8E%B0%E7%8E%87/"/>
      <url>/52.Financing/F27d.%E8%B4%B4%E7%8E%B0%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<ul><li>什么是贴现: 贴现，也称为折现或票据贴现（英语：Discounting），是指将未来的货币转换成当前货币的实际价值，与累积恰好是相反的概念和过程。贴现也就是折合成现在的价值。</li><li>贴现率 <code>r = 无风险利率 + 风险补偿 + 通货膨胀率</code></li></ul><p><img src="/images/20220327180740.png" alt=""></p><p>通过贴现率衡量股票/债券的价值: </p><p>例子1: 中国银行发行一个永久债券, 利率4.5%, 不复利, 每股100元  // 计算模型: 债券价值= 每年产生利率相加求和  (每年的利率都要贴现)， 这种方法叫 <em>股利贴现</em></p><ul><li>计算: 每年产生的分红(D = 4.5元), 贴现率(r = 3% + 1% + 4%), 最终计算价值 (P=56.25)</li></ul><p>例子2: 计算股票价值,  设某公司股票, 每年都分红, D元/股, 贴现率设为r , 股票产生的价值分为… 如果只用股息产生的价值来计算股票现在的价值, 也即下面的”股利贴现模型”  (不考虑股价上涨带来的收益, 只考虑股票分红) .<br>以工商银行股票为例,  分红D = 0.25￥/股, r = 3%无风险 + 5%风险补偿 = 8% (此处没考虑通货膨胀)</p><ul><li>模型1, 每股分红D是静态:  D = 3.125￥</li><li>模型2, 如果考虑到每股分红是动态的(D每年增加g), D = 6.25￥</li></ul><p>另外一种计算股票价值：<em>自由现金流贴现</em> ， 这种模型，只需要把 $$P = D/(r-g)$$ 中的股息(D)换成自由现金流,  查到工商银行的自由现金流 = 1.6元/股, 设g = 4%, r=8% , 计算P=40￥</p><hr><a href="/52.Financing/F27.LPR和利率/" title="F27.LPR和利率">F27.LPR和利率</a>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F27c.等额本息 vs 等额本金</title>
      <link href="/52.Financing/F27c.%E7%AD%89%E9%A2%9D%E6%9C%AC%E6%81%AF-vs-%E7%AD%89%E9%A2%9D%E6%9C%AC%E9%87%91/"/>
      <url>/52.Financing/F27c.%E7%AD%89%E9%A2%9D%E6%9C%AC%E6%81%AF-vs-%E7%AD%89%E9%A2%9D%E6%9C%AC%E9%87%91/</url>
      
        <content type="html"><![CDATA[<h2 id="贷款利息（等额本息-vs-等额本金）"><a href="#贷款利息（等额本息-vs-等额本金）" class="headerlink" title="贷款利息（等额本息 vs 等额本金）"></a>贷款利息（等额本息 vs 等额本金）</h2><p><img src="/images/20220327180648.png" alt=""></p><hr><p>➤ 等额本息:<br>指在还款期内，每月偿还同等数额的贷款(包括本金和利息)。</p><p>如何计算月还款数:</p><blockquote><p>P:贷款本金<br>R:月利率<br>N:还款期数<br>附：月利率 = 年利率/12</p></blockquote><p><img src="/images/等额本息.png" alt="等额本息"></p><blockquote><p>假定借款人从银行获得一笔20万元的个人住房贷款，贷款期限20年，贷款年利率4.2%，每月还本付息。按照上述公式计算，每月应偿还本息和为1233.14元。<br>上述结果只给出了每月应付的本息和，因此需要对这个本息和进行分解。仍以上例为基础，一个月为一期，第一期贷款余额20万元，应支付利息700元（200000×4.2%/12），支付本金533.14元，仍欠银行贷款199466.86元；第二期应支付利息（199466.86×4.2%/12)元。</p></blockquote><p>➤ 等额本金:<br>是在还款期内把贷款数总额等分，每月偿还同等数额的本金和剩余贷款在该月所产生的利息，<br>这样由于每月的还款本金额固定，而利息越来越少，借款人起初还款压力较大，但是随时间的推移每月还款数也越来越少。</p><p>每月还款金额= （贷款本金/还款月数）+（本金—已归还本金累计额）×每月利率</p><p>➤ 等额本息 vs 等额本金</p><ul><li>等额本息：一般的银行贷款均可使用等额本息。等额本息是指：把贷款时间内的所有本金以及对应产生的利息，均匀的分配在每一个月中。这种还款方式的特点是：每个月还款金额相同。但每个月还款额中，前面是还利息多，后期是还本金多。</li><li><p>等额本金：一般的银行贷款均可使用等额本金。等额本金是指：把贷款时间内的所有本金均匀分配在每个月中，同时每个月配上未还款及当月本金对应的利息。这种还款方式的特点：每个月还款的金额不同，第一个月最多，后续越来越少。</p></li><li><p>等额本息还款法特点： 月还款数不变；该方法每月的还款额固定，可以有计划地控制家庭收入的支出，也便于每个家庭根据自己的收入情况，确定还贷能力。</p></li><li>等额本金还款法特点：月还款数递减；由于每月的还款本金额固定，而利息越来越少，贷款人起初还款压力较大，但是随时间的推移每月还款数也越来越少。</li><li>二者相比，在贷款期限、金额和利率相同的情况下，在还款初期，等额本金还款方式每月归还的金额要大于等额本息，但在后期每月归还的金额要小于等额本息。即按照整个还款期计算，等额本金还款方式会节省贷款利息的支出。</li><li>总体来讲，等额本金还款方式适合有一定经济基础，能承担前期较大还款压力，且有提前还款计划的借款人。等额本息还款方式因每月归还相同的款项，方便安排收支，适合经济条件不允许前期还款投入过大，收入处于较稳定状态的借款人。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F27b.同业拆借利率(Shibor)</title>
      <link href="/52.Financing/F27b.%E5%90%8C%E4%B8%9A%E6%8B%86%E5%80%9F%E5%88%A9%E7%8E%87%EF%BC%88Shibor%EF%BC%89/"/>
      <url>/52.Financing/F27b.%E5%90%8C%E4%B8%9A%E6%8B%86%E5%80%9F%E5%88%A9%E7%8E%87%EF%BC%88Shibor%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Shibor"><a href="#Shibor" class="headerlink" title="Shibor"></a>Shibor</h2><p>（一）定义<br>Shibor是Shanghai InterBank Offered Rate的缩写，即上海银行间同业拆放利率。目前，对社会公布的Shibor品种包括隔夜、1周、2周、1个月、3个月、6个月、9个月及1年。Shibor其实就是银行之间的借钱行为引发的利率。<br>银行除上缴或留存一部分存款准备金外，部分银行账面上会留有超额准备金，同时一部分银行的账面上会出现准备金短缺的现象。此外，受到流动性以及头寸调剂等因素影响，此时就需要向其他银行借入资金。因此，Shibor便应运而生了。</p><p>（二）定价模式<br>Shibor报价银行现由18家商业银行组成。报价银行是公开市场一级交易商或外汇市场做市商，属于在中国货币市场上人民币交易相对活跃、信息披露比较充分的银行。<br>每个交易日根据各报价行的报价，剔除最高、最低各4家报价，对其余报价进行算术平均计算后，得出每一期限品种的Shibor，并于11:00对外发布。</p><p>（三）意义<br>Shibor是一个了解银行资金是否充足的晴雨表：每当央行上调存准率或者有上调预期时，Shibor会有一定幅度的上升。而一旦Shibor下行，意味着银行资金充足，市场偏宽松即有可能是央行进行公开市场操作的结果。这就为投资者在进行市场资金面分析时提供了一个重要的指标。<br>譬如当Shibor持续上升时，说明银行间资金趋紧，市场资金面偏紧缩，这时持有现金的保值能力较强。当Shibor持续下降时，表明银行间资金偏宽松，说明此时市场资金较多，现金保值能力不强，此时可进行投资或消费。</p><p>@ref: <a href="https://www.poly.com.cn/blcw/s/1429-4870-19844.html" target="_blank" rel="noopener">https://www.poly.com.cn/blcw/s/1429-4870-19844.html</a></p><h2 id="R007"><a href="#R007" class="headerlink" title="R007"></a>R007</h2><p>（一）定义<br>R007即七天回购利率，是指全市场机构的加权平均回购利率，包括银行间市场所有的质押式回购交易，不限定交易机构和标底资产。<br>做个通俗的比方，A作为一家机构，目前资金短缺需要融资，于是，A可以通过质押手中信用债或者利率债等债券的方式进行融资，并且规定好一定期限后，再进行回购，而在回购时A需要支付给借款机构一定的利息，所以，这就产生了回购利率。<br>为何采用的是7而不是2、3、4等这些数字呢？R007实际覆盖了回购期限为2、3、4、5、6、7天的质押式回购交易。</p><p>（二）意义<br>7天回购利率是当前最具有市场均衡意义的利率。由于其参与机构广，交易量大，不易被个别机构操纵；此外，七天回购率反应灵敏，连续性和弹性好，所以，它成为了货币市场的关键利率指标。</p><h2 id="DR007"><a href="#DR007" class="headerlink" title="DR007"></a>DR007</h2><p>（一）定义<br>DR007，为银行间存款类机构以利率债为质押的7天期回购利率。<br>1997 年，中国人民银行制定了《银行间债券回购业务暂行规定》。根据规定，质押式回购全市场的交易主体为“具有债券交易资格的商业银行及其授权分支机构、农村信用联 社、城市信用社等存款类金融机构，保险公司、证券公司、基金管理公司及其管理的基金、资产管理组合、保险产品、财务公司等非银行 金融机构，以及经营人民币业务的外资金融机构”</p><p>（二）DR007和R007的区别<br>DR007与R007的区别主要有两点：<br>首先，DR007的参与者主要是银行，而R007的参与者除了银行之外，还包括非金融性机构等，它的参与者的范围更加广泛。换言之，R007所代表的是整个银行间的质押式回购加权平均利率，而 DR 007是代表存款类机构的质押式回购加权平均利率。（是不是反了？）<br>其次，DR007的质押品是以利率债等作为标的，实际上降低了信用风险溢价，同时也由于参与者和质押品的范围较窄，所以大大降低了DR007的便利性。</p><p>（三）DR007和Shibor的区别<br>DR007与Shibor的最大区别在于：是否为真实成交利率。DR007是中国外汇交易中心根据银行间质押式回购市场所有存款类机构之间开展的质押式回购交易形成的回购市场加权利率，是真实成交利率；而Shibor是基于报价行报价计算得到的利率，并非真实成交利率</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F27.利率</title>
      <link href="/52.Financing/F27.LPR%E5%92%8C%E5%88%A9%E7%8E%87/"/>
      <url>/52.Financing/F27.LPR%E5%92%8C%E5%88%A9%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>在宏观经济学的有关模型中（比如IS-LM）不必区分存款利率和贷款利率，因为存贷款利率是同方向移动的，不影响对模型的理解。</p><h2 id="基准利率和LPR"><a href="#基准利率和LPR" class="headerlink" title="基准利率和LPR"></a>基准利率和LPR</h2><ul><li>基准利率: 是人民银行公布的商业银行存款、贷款、贴现等业务的指导性利率, 各金融机构的存款利率目前可以在基准利率基础上下浮10%, 贷款利率可以在基准利率基础上下浮20%.<ul><li>存款利率分为 活期, 定期</li><li>贷款利率, 一年, 一年至五年</li></ul></li><li>2019前的贷款利率使用“基准利率”形式，新（2019后）的贷款都使用LPR计算方式</li><li>LPR也即“贷款市场报价”（Loan Prime Rate），由18家银行向同业拆借中心提交报价，去头去尾平均得到LPR，每月公布 LPR = avg（18家银行的“MLF利率+浮动点”）</li><li>浮动贷款实际放贷利率 = avg（MLF + 报价浮点） + 银行放贷加点<ul><li>央行决定MLF</li><li>银行自己决定自己的报价浮点</li><li>银行自己决定实际放贷加点，但央行可以通过政策影响这部分加点 </li></ul></li><li>LPR分1年和5年LPR，对应不同期限的贷款使用</li><li>无论固定利率贷款还是浮动利率贷款，利率都是按照“ LPR+点数”计算出的，不同的是前者一旦签订利率不变，后者每年都根据LPR做调整，但点数不变（点数取决于不同银行，不同地区也不同）</li><li>住房贷款部分，新签订的住房贷款采用最近一次公布的5年LPR，再加点，点数取决于地区和银行。合同签订后，住房贷款每年调整一次（按照合同里的重定价周期），一般是1月1</li></ul><p>以上参考:  &lt;<a href="https://av.sc.com/cn/content/docs/cn-question-and-answer-of-loan-market-quotation-rate.pdf" target="_blank" rel="noopener">https://av.sc.com/cn/content/docs/cn-question-and-answer-of-loan-market-quotation-rate.pdf</a> &gt;</p><p>➤ 同业拆借利率：<br>    Ø <a href="/52.Financing/F27b.同业拆借利率（Shibor）/" title="F27b.同业拆借利率（Shibor）">F27b.同业拆借利率（Shibor）</a>采用报价制度，以拆借利率为基础，即参与银行每天对各个期限的拆借品种进行报价，对报价进行加权平均处理后，公布各个期限的平均拆借利率即为SHIBOR利率。<br>    Ø 若当前SHIBOR利率低，意味着银行不缺钱<br>    Ø SHIBOR和MLF的关系？ 是否 SHIBOR＝MLF+点？  @todo</p><h2 id="贷款利率"><a href="#贷款利率" class="headerlink" title="贷款利率"></a>贷款利率</h2><p>=&gt; <a href="/52.Financing/F27c.等额本息-vs-等额本金/" title="F27c.等额本息-vs-等额本金">F27c.等额本息-vs-等额本金</a></p><h2 id="存款利率"><a href="#存款利率" class="headerlink" title="存款利率"></a>存款利率</h2><p>名义利率 &amp; 实际利率</p><ul><li>利率: 利率是指借款、存入或借入金额（称为本金总额）中 每个期间到期的 利息金额 与 票面价值 的比率</li><li>名义利率:</li><li>实际利率:</li></ul><p>费雪效应：$$（1+名义利率）=（1+实际利率）*（1+通胀率）$$</p><p>解释:</p><ul><li>储蓄100元，储蓄时约定利率为10%。则一年后获得本金+利息总计110元。如果该年内通胀率为0，那么名义利率=实际利率=10%     </li><li>同样的100元，储蓄时约定利率为10%。但该区域内通胀率为4%，即一年前某物品需要100元，则现在该产品需要104元才能购买。在这种情况下进行储蓄，一年后获得本金+利息=100+10=110元。     </li><li>根据（1+名义利率）=（1+实际利率）*（1+通胀率）（名义利率=10%，通胀率=4%）     </li><li>实际利率=（1+10%）/（1+4%）-1=5.76%     </li><li>即：我们储蓄的利率随着通货膨胀（紧缩）而相应的减少（增加）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F23b.几个有用的市场估值指标</title>
      <link href="/52.Financing/F23b.%E5%B8%82%E5%9C%BA%E4%BC%B0%E5%80%BC%E6%8C%87%E6%A0%87/"/>
      <url>/52.Financing/F23b.%E5%B8%82%E5%9C%BA%E4%BC%B0%E5%80%BC%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="股债利差"><a href="#股债利差" class="headerlink" title="股债利差"></a>股债利差</h2><p>股债利差/股债收益差，等于 <code>宽基指数E/P - 10y国债收益率</code>，不考虑股票的低买高卖，只考虑股票的股息（这里用宽基指数的EP，也即A股的股息收益的平均数）和无风险利率的比较（利差越高意味着股市的性价比越高）</p><p>↓股债利差（蓝色）和沪深300指数（红色）走势负相关：<br><img src="/images/沪深300股债利差.png" alt="沪深300股债利差"></p><p>统计历次股市低点，也即股债利差达到最大值的位置，利差约为6.7%，<br>  • 2016：6.7%<br>  • 2018：6.6%<br>  • 2020：6.5%<br>  • 2022：7%<br>历次股市最高点的利差在3%左右</p><p>在哪儿看股债利差：</p><ul><li><a href="https://danjuanfunds.com/valuation-table/jiucai" target="_blank" rel="noopener">蛋卷</a></li><li><a href="https://mp.weixin.qq.com/s/HjrFjaGDL0nPWM5FYIwi-w" target="_blank" rel="noopener">公众号-指盈汇</a></li><li>乐咕：<a href="https://legulegu.com/stockdata/equity-bond-spread" target="_blank" rel="noopener">https://legulegu.com/stockdata/equity-bond-spread</a></li></ul><hr><p><a href="https://xueqiu.com/4778574435/231817263" target="_blank" rel="noopener">股债性价比择时失效了吗？ - 雪球</a></p><ul><li>这里股的EP用沪深300，债的收益率用美国10Y国债（近一年内美国国债价格下跌，收益率↑）国债价格下跌的原因是？ 可能流出到美元资产避险，或者是对长期国债不看好。这样的股债利差表明，现在不是买入的时机</li><li>作为全球资产定价的核心：美国10年期国债收益率的快速上升，确实干扰到了沪深300股债性价比的有效</li></ul><h2 id="格雷厄姆指数"><a href="#格雷厄姆指数" class="headerlink" title="格雷厄姆指数"></a>格雷厄姆指数</h2><blockquote><p>比较与股债利差的异同：都是股市整体股息收益和无风险利率的比较，前者用比值，后者用差值</p></blockquote><p><a href="https://m.gelonghui.com/p/511088" target="_blank" rel="noopener">市场红绿灯指数：格雷厄姆指数</a><br>格雷厄姆指数定义：假设某只股票的盈利收益率是10%，此时十年期国债收益率为5%，那么这只股票的格雷厄姆指数为2（10%÷5%=2）；其中 <em>盈利收益率=E/P</em>，也就是市盈率的倒数。</p><p>20年的历史数据显示，</p><pre><code>- 当股市的盈利收益率是十年期国债收益率2倍时（格雷厄姆指数&gt;=2），是比较好的投资机会。- 格雷厄姆指数 = 1.5，中位- 格雷厄姆指数 &lt;=1，这时候股市EP是小于国债的，相对危险</code></pre><p>格雷厄姆指数计算持仓：</p><pre><code>- graham &gt; 2.2，权益：固收=10：0- graham = 2， 权益：固收=8:2- graham = 1.8，权益：固收=5：5- graham = 1， 权益：固收=0：10</code></pre><p>在哪看格雷厄姆指数：<a href="https://www.touzid.com/model/graham.html#/" target="_blank" rel="noopener">市场-格雷厄姆指数-投资数据网</a></p><h2 id="证券化率（GNP）"><a href="#证券化率（GNP）" class="headerlink" title="证券化率（GNP）"></a>证券化率（GNP）</h2><p>用 <em>GNP</em> （证券化率） 估算买入时机  @ref： <a href="https://m.gelonghui.com/p/178503" target="_blank" rel="noopener">巴菲特最爱用的估值指标</a></p><ul><li>巴菲特认为，在美国证券化率在70%-80%之间适合持有股票，在证券化率低于60%，可以大举买入股票，而当该指标大于100%时，市场就开始值得警惕，而当该指标超过120%，市场就进入了疯狂的状态。</li><li>标普500指数具有非常高的相关性。在90年代前，该指标从40%稳步提升至80%，之后该指标在80-150%的区间范围内大幅度震荡。在2000年左右美国的证券化率一度超过150%。随着当时一众互联网公司的市值泡沫破裂，该指标急剧下降，反弹后遇到08年金融危机，再度大幅下挫。</li><li>A股 从07年~今：分别是2007年7月（对应后期证券化率高点及时间：2007/12/27、146.60%）、2009年8月（2009/8/4、81.14%）、2015年4月（2015/6/12、113.26%）以及最近一次发生在18年1月（2018/1/26、81.67%）。但是我们也可以清晰地看到，在10年11月到14年3月期间，该指标没有任何作用。而指数也一路阴跌，期间产生了最大的回撤超过40%。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F23a.社融和M2</title>
      <link href="/52.Financing/F23a.%E7%A4%BE%E8%9E%8D%E5%92%8CM2/"/>
      <url>/52.Financing/F23a.%E7%A4%BE%E8%9E%8D%E5%92%8CM2/</url>
      
        <content type="html"><![CDATA[<p> @Onenote 待整理</p><ul><li>货币供应指标（M0、M1、M2）分别指什么</li><li><p>什么是社融？社融看哪些指标？ </p></li><li><p>M2和社融的使用：</p><ul><li>“社融-M2”增速差 &amp; 债市的关系</li><li>新增社融增速 &amp; 股市的关系</li><li>M1-M2同比增速差 &amp; 经济增长水平的关系</li></ul></li></ul><hr><p>➤ 什么是M0、M1、M2的：</p><ul><li>货币（M0）= 流通中的现金，即流通于银行体系之外的现金。</li><li>狭义货币（M1）= M0 +活期存款；</li><li>广义货币（M2）= M1+定期存款（准货币）<ul><li>其中准货币包括：单位定期存款+居民定期存款+其他存款+证券公司客户保证金+住房公积金中心存款+非存款类金融机构在存款类金融机构的存款</li></ul></li></ul><p>➤ 什么是社融：社会融资规模，一定时期实体经济从金融体系获得的资金总额。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F23.常用宏观统计指标</title>
      <link href="/52.Financing/F23.%E5%AE%8F%E8%A7%82%E7%BB%9F%E8%AE%A1%E6%8C%87%E6%A0%87/"/>
      <url>/52.Financing/F23.%E5%AE%8F%E8%A7%82%E7%BB%9F%E8%AE%A1%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="宏观指标"><a href="#宏观指标" class="headerlink" title="宏观指标"></a>宏观指标</h2><ul><li>GDP: 国内生产总值</li><li>CPI: 消费者物价指数, 是反映一定时期内城乡居民所购买的生活消费品和服务项目价格变动趋势和程度的相对数，是对城市居民消费价格指数和农村居民消费价格指数进行综合汇总计算的结果。通过该指数可以观察和分析消费品的零售价格和服务项目价格变动对城乡居民实际生活费支出的影响程度。</li><li>PPI: 生产者价格指数</li></ul><blockquote><p>CPI反映消费价格变化情况，是一个相对数。GDP反映国民经济生产总量，是一个绝对数。CPI的变动反映经济运行过程中物价变动情况，是观察通货膨胀程度的重要指标，GDP的变化则反映经济的增长情况。经济增长与通货膨胀的关系存在以下四种情形：高增长低通胀，高增长高通胀，低增长低通胀，低增长高通胀。</p></blockquote><ul><li>PMI: 采购经理人指数, PMI是衡量制造业的体检表，为领先指标中一项重要数据，可衡量制造业在生产、新订单、商品价格、存货、雇员、订单交货、新出口订单和进口等状况。PMI是以百分比来表示,常以50%作为经济强弱的分界点：当指数高于50%时，则被解释为经济扩张的讯号。当指数低于50%，尤其是非常接近40%时，则有经济萧条的忧虑。一般在40~~50之间时，说明制造业处于衰退，但整体经济还在扩张。 @ref: <a href="https://zh.m.wikipedia.org/zh-hans/%E9%87%87%E8%B4%AD%E7%BB%8F%E7%90%86%E6%8C%87%E6%95%B0" target="_blank" rel="noopener">https://zh.m.wikipedia.org/zh-hans/%E9%87%87%E8%B4%AD%E7%BB%8F%E7%90%86%E6%8C%87%E6%95%B0</a></li></ul><ul><li>社融 &amp; 两融： 关于社融更多在 @Onenote<ul><li>融资融券余额查询：<a href="http://data.10jqka.com.cn/market/rzrq/" target="_blank" rel="noopener">http://data.10jqka.com.cn/market/rzrq/</a> 这可以查询还有多少杠杆资金留在场内，杠杆的使用量是一个十分有效的情绪指标</li><li>“我认为，最近的大跌与融资盘爆仓脱不开干系。市场里有不少资金是借钱上了杠杆的，那就会有一条警戒线。当快要跌到警戒线时，券商就会要求我们追加现金。假如没有现金补充，那就会被券商强制卖出仓位。因此类推，就会形成爆仓浪潮。看数据就会看到，融资余额快速下降” <a href="https://mp.weixin.qq.com/s/VtmcXiWb9yiv0NQ52zdgbA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/VtmcXiWb9yiv0NQ52zdgbA</a></li></ul></li></ul><p>其他：</p><ul><li>汇率：<a href="/52.Financing/F29.蒙代尔不可能三角/" title="F29.蒙代尔不可能三角">F29.蒙代尔不可能三角</a></li><li>外汇储备</li><li>利率：参考《LPR和利率》</li><li>准备金率：</li><li>十年国债收益： 参考 《中美国债利差倒挂》</li></ul><h2 id="历史数据"><a href="#历史数据" class="headerlink" title="历史数据"></a>历史数据</h2><p>来源: <a href="https://data.eastmoney.com/cjsj/gdp.html" target="_blank" rel="noopener">数据中心_东方财富</a></p><p>GDP：纵轴是GDP同比增长率，单位是%<br><img src="/images/20220402153719.png" alt=""></p><p>PMI：可以看到20年2月 &amp; 22年4月都跌破了50荣枯线，PMI需要连续扩张（高于50%）才表示经济上行<br><img src="/images/20220614175047.png" alt=""></p><p>PPI：<br><img src="/images/20220402153855.png" alt=""></p><p>CPI:<br><img src="/images/20220402153820.png" alt=""></p><p>外汇储备:<br><img src="/images/20220402154057.png" alt=""></p><p>利率：15年之前的基准利率%变化，15年后改用LPR利率，关于LPR参考《LPR》<br><img src="/images/20220402154133.png" alt=""></p><p>准备金率：<br><img src="/images/20220402154155.png" alt=""></p><p>新房价指数：<br><img src="/images/20220402153938.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F22.美联储-宏观调控手段</title>
      <link href="/52.Financing/F22.%E7%BE%8E%E8%81%94%E5%82%A8-%E5%AE%8F%E8%A7%82%E8%B0%83%E6%8E%A7%E6%89%8B%E6%AE%B5/"/>
      <url>/52.Financing/F22.%E7%BE%8E%E8%81%94%E5%82%A8-%E5%AE%8F%E8%A7%82%E8%B0%83%E6%8E%A7%E6%89%8B%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>名词：</p><p>QT：量化紧缩，英文Quantitative Tightening，简称QT；<br>QE：量化宽松，英文名Quantitative Easing，简称QE；</p><hr><p>美联储常规的货币政策工具有三：存款准备金制度、再贴现政策和公开市场业务。<br>这里提到的公开市场业务，即美联储在公开市场上买卖有价证券（一般是美国国债）的做法。当宣布联邦基金利率目标区间上调后，美联储会开始在公开市场上抛售国债换取美元，大量资金回到央行，市场上的货币总量减少。货币总量的减少导致银行间市场的资金流动性开始紧张。这个时候再有其他银行来借钱，借款利率（联邦基金利率）会自然提高，因为地主家也没有余粮了。<br>所以说，美联储只需要控制抛售国债的力度，就可以将利率稳定在它制定的目标区间内。</p><p>这里提到的公开市场业务，即美联储在公开市场上买卖有价证券（一般是美国国债）的做法。// 参考“缩表”<br>当宣布联邦基金利率目标区间上调后（加息），美联储会开始在公开市场上抛售国债换取美元，大量资金回到央行，市场上的货币总量减少。由于国债被持续抛售，导致其价格走低，收益率升高。</p><h2 id="美联储资产负债表"><a href="#美联储资产负债表" class="headerlink" title="美联储资产负债表"></a>美联储资产负债表</h2><p>右边红色=资产端，左边绿色=负债端：<br><img src="/images/IMG20220930-7.png" alt="../_images/IMG20220930-7.png"></p><p><strong>资产端</strong><br>（1）资产端变化的主要分项是美联储持有的国债和MBS。两者共经历了两次攀升，分别是2008年金融危机后与2020年新冠疫情爆发后。从2020年年初，国债规模为23289亿美元，8月26日规模达到43586亿美元，扩大近一倍；MBS则分别为14087亿美元、19492亿美元，增长近38.4%<br>（2）资产端CPFF、CCF、MSF、MLF、TALF逐步铺开。截至8月26日，上述工具规模分别为85.88亿美元、446亿美元、383.71亿美元、165.41亿美元、107.71亿美元。</p><p><strong>负债端</strong><br>（1）负债端变化的主要分项是财政存款、存款机构其他存款和联储票据、联储银行持有净额。两者同样经历了两次攀升，分别是2008年金融危机后与2020年新冠疫情爆发后。以财政存款为例，多轮次QE后，财政存款上涨幅度接近20倍；2020年疫情爆发后，财政存款增长幅度则接近4倍。<br>（2）超额存款准备金则大幅下降。其中，金融危机后超额存款准备金率从1%降至0.25%；2020年年初疫情爆发后，从1.55%降至0.1%。</p><h2 id="加息"><a href="#加息" class="headerlink" title="加息"></a>加息</h2><blockquote><p>加息xx点, 100个基点相当于1%，一个基点就是0.01%。所以说兑美元基点，美联储降息25基点意思就是把利率下调25个基点，那也就是说下调后，利率降低了0.25%</p></blockquote><p>美联储加息：不是存款利息和贷款利息,<br>美联储加息调整的是「美国联邦基金利率」,商业银行在日常经营过程中，不管是因为放贷或者大额支取，常会遇到暂时性的流动性短缺。流动资金不够了怎么办？找手头有富余资金的银行借钱，支付一定的利息就可以了。<br>这个利率，中国叫做银行间同业拆借利率，在美国叫做联邦基金利率（Federal funds rate）。<br>联邦基金利率是最重要的短期利率，能很大程度上决定官方贴现率、商业银行存贷利率等各项参数。不过要记住，这是银行和银行之间商量的事情，央行是不能轻易插手的。所以美联储设置的是联邦基金利率目标区间（Target range for the federal funds rate）。</p><p>// 对比中国央行调整的是LPR，但也不是央行直接操控，而是18家银行向同业拆解中心的报价，参考 《LPR》</p><p>联邦基金利率是最重要的短期利率，能很大程度上决定官方贴现率、商业银行存贷利率等各项参数。<br>不过要记住，这是银行和银行之间商量的事情，央行是不能轻易插手的。所以美联储设置的是联邦基金利率<em>目标区间</em>（Target range for the federal funds rate）。也即一个范围值。</p><p>以今年六月中旬美联储第二次加息为例：在六月份的声明中，FOMC宣布将联邦基金利率目标区间上调25个基点至1.75%~2%</p><p>FOMC是联邦公开市场委员会（Federal Open Market Committee），由政府和美联储银行的12名委员组成，他们每6周在华盛顿开一次会（议息会议），做出关于利率的决策。=&gt; [[#看懂点阵图]]</p><h2 id="缩表"><a href="#缩表" class="headerlink" title="缩表"></a>缩表</h2><p><a href="https://www.zhihu.com/question/296257077/answer/500019181" target="_blank" rel="noopener">什么是美联储缩表？ - 知乎</a></p><p>“缩表”是指美联储缩减自身资产负债表规模。是中央银行减少资产负债表规模的行为。说白了就是卖出自己的资产，目前美国的资产主要是国债和MBS（一种证券），两者高峰时达到4.46万亿。缩表就是卖出国债和MBS，最后市场上的美元被美联储回收，达到收紧货币的目的，同时美联储的资产负债表也会减少。<br>“缩表”从经济体中抽走货币，货币减少，相应货币价值增加。</p><p>美联储通过直接抛售所持债券或停止到期债券再投资的方式（抛售债券使市场上债券增加，债券变得便宜，收益率提高）可实现对基础货币的直接回收，相当于变相提高利率，是更为严厉的紧缩政策。</p><p>除了抛售债券，缩表的手段还有“停止债券再投资”，债券再投资意味着，美联储持续购入更多债券，如果停止再投资，意味着不会再增持债券，也是缩表的手段之一。</p><p>综上，美联储调控手段（这里仅讨论紧缩政策）：</p><ul><li>直接加息xx BP；</li><li>停止所持债券的再投资，手里的债券不再增持；</li><li>直接抛售债券（市场上债券变多，债券贬值，收益率↑），如上所说，是比加前两种息更严格的紧缩；</li></ul><p>美联储宽松调控手段：</p><ul><li>降息xx BP；</li><li>债券再投资（不断增持债券）</li><li>购入债券（市场上债券变少，债券升值，收益率↓）；</li></ul><p><a href="https://wallstreetcn.com/articles/3658355" target="_blank" rel="noopener">硬核科普： 美联储缩表是怎么缩的？ - 华尔街见闻</a> // 更硬核的科普，没看懂</p><h3 id="美联储缩表，会导致市场缺钱么？"><a href="#美联储缩表，会导致市场缺钱么？" class="headerlink" title="美联储缩表，会导致市场缺钱么？"></a>美联储缩表，会导致市场缺钱么？</h3><p>@ref: <a href="https://mp.weixin.qq.com/s/vn9J9AnVl01oSqzlq7JL2A" target="_blank" rel="noopener">美联储缩表，会导致市场缺钱么？</a></p><p>美联储『资产』构成中：国债为5.77万亿美元，占比为64.5%；MBS（房地产抵押债券）为2.72万亿美元，占比为30.4%。两项合计高达8.48万亿美元，占了资产总规模的95%，美联储所谓的缩表，就是减少国债和MBS的持有量。</p><p>当前阶段美联储负债的主要类别是哪些呢？<br>答案是： 商业银行准备金、财政部账户（TGA）现金、流通现金、逆回购账户资金。在以上四个大项负债中，对金融市场影响较大的，是商业银行准备金规模和流通现金额度，而TGA和逆回购账户资金波动，基本不会影响市场上的资金状况。</p><p>这里说明一下，美联储逆回购账户与中国央行正好相反，中国央行的逆回购账户持有资产，属于资产端，规模越大，意味着为市场释放资金越多；而美联储的逆回购账户，属于负债端，主要从市场上回笼资金，规模越大，意味着从市场上吸收的资金越多。(@link【MLF、SLO、逆回购】)</p><p>当美联储逆回购账户资金屡创新高，这就意味着，市场上的资金极其充裕，只是因为美联储的加息，导致市场资金涌入逆回购账户，追求绝对安全的收益。明白了美联储资产端和负债端的主要构成之后，我们再来看美联储的缩表。</p><p>不管怎么缩表，理论上说，只要能做到不影响负债端的准备金和流通现金的规模，就不怎么会影响金融市场，因为只有那两个账户的钱，特别是流通中的美元数量，才与市场上所谓的“缺钱”还是“不缺钱”，有密切关系。</p><p>美联储负债端拥有高达2.1万亿美元的逆回购资金，缩表根本不用抽走准备金。也就是说，如果缩表规模在2万亿美元以内，既不会影响市场流通资金的松紧，也根本涉及不到商业银行准备金的问题。</p><h2 id="看懂点阵图"><a href="#看懂点阵图" class="headerlink" title="看懂点阵图"></a>看懂点阵图</h2><p>@Onenote</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F22.央行-宏观调控手段</title>
      <link href="/52.Financing/F22.%E5%A4%AE%E8%A1%8C-%E5%AE%8F%E8%A7%82%E8%B0%83%E6%8E%A7%E6%89%8B%E6%AE%B5/"/>
      <url>/52.Financing/F22.%E5%A4%AE%E8%A1%8C-%E5%AE%8F%E8%A7%82%E8%B0%83%E6%8E%A7%E6%89%8B%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="央行资产负债表"><a href="#央行资产负债表" class="headerlink" title="央行资产负债表"></a>央行资产负债表</h2><p>右边红色=资产端，左边绿色=负债端：<br><img src="/images/IMG20220930-6.png" alt="../_images/IMG20220930-6.png"></p><p><strong>资产端</strong>：</p><p>（1）“国外资产”包括外汇、黄金和其他国外资产。其中外汇占比高达96.95%（截至2020年7月）。“国外资产”中的外汇项即俗称的央行口径外汇占款。由于人民币是非自由兑换货币，外资引入后需兑换成人民币才能进入流通使用，国家为了外资换汇要投入大量的资金，需要国家用本国货币购买外汇，因此增加了负债端的“储备货币”，从而形成了外汇占款。</p><p>（2）“对其他存款性公司债权”指央行通过公开市场操作、创新工具和其它工具（再贴现、再贷款）向其他存款性公司投放的基础货币。“对其他存款性公司债权”主要投放方式：<br>    • 公开市场操作（传统型）：<br>        ○ 逆回购<br>        ○ 短期流动性调节工具（SLO)<br>        ○ 中央国库现金管理商业银行定期存款<br>    • 创新工具：<br>        ○ 常备借贷便利（SLF)<br>        ○ 中期借贷便利(MLF)<br>        ○ ….<br>    • 其他工具：<br>        ○ 再贴现、再贷款</p><p><strong>负债端</strong>：</p><p>负债端中占比最大的项目是“储备货币”和“政府存款”。<br>（1）从储备货币内部结构来看，其主要分为货币发行（占比28.66%）、其它存款性公司存款（占比65.98%）和非金融机构存款（占比5.37%）。<br>（2）政府存款：季初上缴、季末投放，加剧了储备货币的波动<br>（3）央行发行债券又称中央银行票据，这是外汇流入阶段为回收基础货币的产物。是中央银行为调节商业银行超额准备金而向商业银行发行的短期债务凭证，其实质是中央银行债券。央行票据与金融市场各发债主体发行的债券具有根本区别：各发债主体发行的债券是一种筹集资金的手段，其目的是为了增加可用资金；而央行发行的央行票据是央行调节基础货币的一项货币政策工具，目的是减少商业银行可贷资金量。</p><h2 id="央行调控手段"><a href="#央行调控手段" class="headerlink" title="央行调控手段"></a>央行调控手段</h2><p>@ref: <a href="https://zhuanlan.zhihu.com/p/380829224" target="_blank" rel="noopener">【经济指标解读专栏】货币政策框架分析1—货币政策工具体系 - 知乎</a></p><p>货币政策框架包括三个部分，即货币政策目标体系、货币政策工具体系、货币政策传导机制。这三部分的关系是，央行运用自己创建的各类货币政策工具，去实现自己事先规定好的操作目标，并借助现有的传导机制来实现最终目标的一个过程。具体可梳理为两个框架：</p><ul><li>数量型框架： 再贷款、法定存款准备金率等</li><li>价格型框架：如MLF利率、OMO利率等<br>为了实现上述的最终目标，央行创设了越来越多便利、精准的货币政策工具，包括逆回购、MLF、TMLF、SLF、PSL等等，其既有数量型工具，也有价格型工具，既有总量型工具，也有结构型工具。</li></ul><ol><li>法定存款准备金率（总量/结构、数量型）</li><li>逆回购（总量型、数量/价格型）</li><li>中期借贷便利（MLF）和定向中期借贷便利（TMLF）（总量/结构型、数量/价格型）</li><li>再贷款、再贴现（总量型+数量型）</li><li>常备借贷便利（SLF）（结构型+数量型）</li><li>超额存款准备金利率（总量型+价格型）</li><li>直达实体经济的货币政策工具（结构型+数量型）</li></ol><p>下图参考：<a href="https://www.zhihu.com/question/46135259/answer/2435824216" target="_blank" rel="noopener">如何建立自己的宏观经济分析框架？ - 知乎</a><br>![[../_images/央行货币政策工具.png]]</p><h2 id="何为放水"><a href="#何为放水" class="headerlink" title="何为放水"></a>何为放水</h2><p>央行放水的表现形式，包括但不限于如下几种：一是降低准备金存款率；二是增加贷款储备、贷款途径；三是促进银行存款；四是发放国债、地方债。</p><h2 id="准备金"><a href="#准备金" class="headerlink" title="准备金"></a>准备金</h2><p>准备金（reserve）: 是商业银行库存的现金按比例存放在中央银行的存款. 实行准备金的目的是为了确保商业银行在遇到突然大量提取银行存款时, 能有相当充足的清偿能力.</p><p>for example： 假设商业银行吸收了100亿存款，但是为了应付平时的支付和防止挤兑风险，会被国家法定截流10％作为“存款准备金”，银行只允许释放最多90亿的贷款资金。</p><p>降准：央行通过降低准备金率，增加银行可放贷金额，从而增加市场上货币总量的一种手段。</p><ul><li>降准有利于商业银行释放资金，调用更多的资金投向收益更高的地方，增加银行的利润。这时候投资者也可以瞄准机会投资于银行股，银行指数基金等。</li></ul><h2 id="MLF"><a href="#MLF" class="headerlink" title="MLF"></a>MLF</h2><p>MLF是中期借贷便利（Medium-term Lending Facility）的英文缩写，也俗称“麻辣粉”，是中央银行提供中期基础货币的货币政策工具。其发放对象是符合监管要求的商业银行和政策性银行，发放方式为质押方式。</p><ul><li>MLF操作过程为，人民银行通过招标方式，选择合适的商业银行，按中标利率给商业银行借钱，同时商业银行将优质的债券作为质押品的过程；说简单点，就是央行借钱给商业银行。</li><li>以引导（商业银行）向符合国家政策导向的实体经济部门提供低成本资金，促进降低社会融资成本</li></ul><blockquote><p>“X月X日，央行进行9500亿元历史最高MLF超额操作”。</p></blockquote><p>解释：<br>期限1年就是央行把钱借给参与MLF投标的银行1年，1年后相关银行要还钱。<br>操作量9500亿元就是央行借给符合条件的银行9500亿。<br>中标利率2.95%就是利息，即央行把钱借给相关银行的利息。</p><p>央行可以通过控制MLF的投放量和利率来影响市场的货币供应和市场利率，所以在一定程度上，MLF通过调节向金融机构中期融资的成本来对金融机构的资产负债表和市场预期产生影响，促进降低社会融资成本。</p><p>例如小微企业往往达不到银行的风控标准，银行不愿放贷，但是如果银行以国债、央行票据、政策性金融债、高等级信用债等优质债券 或 不低于AA级的小微、绿色和“三农”金融债券作为质押品，那么央行愿意以较低的利率借给银行一笔资金。</p><h2 id="国债逆回购"><a href="#国债逆回购" class="headerlink" title="国债逆回购"></a>国债逆回购</h2><blockquote><p>“央行进行350亿7天期逆回购”</p></blockquote><p>央行向银行购买350亿的有价证券（一般是国债），把之前卖给银行的国债再“买回来”，同时向银行释放资金（等于向市场释放资金），7天后央行收回资金+利息，同时把国债还给银行。</p><p>相比较MLF是中期放水，国债逆回购是短期放水。</p><h2 id="加息-amp-降息"><a href="#加息-amp-降息" class="headerlink" title="加息&amp; 降息"></a>加息&amp; 降息</h2><p>降息途径：央行控制MLF利率 =&gt; 影响 LPR =&gt; 影响银行的浮动利率（？不确定） // @link： <a href="/52.Financing/F27.LPR和利率/" title="F27.LPR和利率">F27.LPR和利率</a></p><p><a href="https://m.21jingji.com/article/20210209/herald/9871e9dfa66758a1063867caae771263.html" target="_blank" rel="noopener">央行亲自划重点：加息降息主要看DR007加权平均利率 - 21财经</a>：</p><blockquote><p>2月8日，央行发布《2020年第四季度货币政策执行报告》指出，判断短期利率走势首先要看政策利率是否发生变化，主要是央行公开市场7天期逆回购操作利率是否变化，而不应过度关注公开市场操作数量。公开市场操作数量会根据财政、现金等多种临时性因素以及市场需求情况灵活调整，其变化并不完全反映市场利率走势，也不代表央行政策利率变化。<br>其次，在观察市场利率时重点看市场主要利率指标（DR007）的加权平均利率水平，以及 DR007 在一段时期的平均值，而不是个别机构的成交利率或受短期因素扰动的时点值。</p></blockquote><p>@link: <a href="/52.Financing/F27b.同业拆借利率（Shibor）/" title="F27b.同业拆借利率（Shibor）">F27b.同业拆借利率（Shibor）</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F21d.货币-信用周期</title>
      <link href="/52.Financing/F21d.%E8%B4%A7%E5%B8%81%E4%BF%A1%E7%94%A8%E5%91%A8%E6%9C%9F/"/>
      <url>/52.Financing/F21d.%E8%B4%A7%E5%B8%81%E4%BF%A1%E7%94%A8%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>货币宽松：资金流入金融体系；<br>信用（信贷）宽松：资金流入实体经济，所谓“宽信用”指的是企业和个人的贷款意愿提升。二者发生的顺序是宽货币先行，再出现宽信用；</p><p>货币-信用（信贷）周期： 分为四个周期，货币在信用之前:</p><ol><li>宽货币+紧信用：在经济下行时，央行会释放流动性，经济触底之前，企业和个人信心不足，贷款意愿不高，因此衰退阶段大体上是宽货币、紧信用特征。</li><li>宽货币+宽信用：经济触底成功增加了企业和个人的信心，贷款意愿增加，信贷上升；同时经济增长不够强劲，央行会继续净投放。因此经济复苏阶段大体上是宽货币、宽信用特征。</li><li>紧货币+宽信用：经济强劲增长，通胀苗头显现，央行开始收缩流动性，但企业和个人信心十足，贷款意愿依然高企。过热阶段大体对应着紧货币、宽信用周期。</li><li>紧货币+紧信用：经济增速见顶回落，物价依然高企，央行继续收缩流动性，同时企业和个人信心丧失，贷款意愿下降。因此滞胀阶段大体对应着紧货币、紧信用周期</li></ol><blockquote><p>货币-信用周期与美林时钟（衰退、复苏、过热和滞胀）四周期有交叉和跨越，但也有大体上的对应关系。// @link <a href="/52.Financing/F21a.美林时钟/" title="F21a.美林时钟">F21a.美林时钟</a></p></blockquote><p>货币-信用（信贷）周期中，每个周期最优资产：</p><ul><li>1、宽货币紧信用周期，股票震荡市，债券强牛市；// 衰退</li><li>2、宽货币宽信用周期，股票强牛市，债券震荡市；// 复苏</li><li>3、紧货币宽信用周期，股票弱牛市，债券熊市； // 过热</li><li>4、紧货币紧信用周期，股票强熊市，债券震荡市 // 滞胀</li></ul><blockquote><p>也对比  Ray Dalio 提到的“债务周期” ，这里把影响周期的要素分为了二个（货币和信用），也加入了更适合中国国情的观测指标（见下）</p></blockquote><p>如何判断<em>货币</em>的松紧？// 也即“剩余流动性”</p><ul><li>（1）看央行怎么说：央行每个季度的《货币政策执行报告》会对下一阶段的货币政策作出展望：模糊的表达有宽松的货币政策，适度宽松的货币政策，稳健的货币政策，适度从紧的货币政策，从紧的货币政策</li><li>（2）看央行怎么做：大的动作是调整存款准备金比率，往往几年一次，最近一次全面降准0.5个百分点直接释放1万亿流动性；常规动作是公开市场操作、SLF、MLF、SLO等等。关注央行网站或财经频道，可以及时了解到最短一周内央行是净回笼还是净投放资金。如果是宽货币政策中连续出现较大幅度净回笼资金，就要观察货币政策会不会转向</li></ul><p>如何判断<em>信用</em>的松紧？</p><ul><li>（1）宏观定调：“去杠杆”就是信用收缩，2018年就是一个典型的紧信用周期；“加杠杆”就是信用扩张。</li><li>（2）信用松紧可以用 <em>“社会融资总额同比增速”</em> 结合 <em>“广义货币供应量M2同比增速”</em> 来判定，但以前者为主要指标，即“社融总额同比增速”稳定或上行为宽松，反之则为紧缩。// @link  <a href="/52.Financing/F23a.社融和M2/" title="F23a.社融和M2">F23a.社融和M2</a></li><li>（3）观察信用利差，即“企业债利率”与“国债同期利率”的差值，信用利差收窄，表明处于宽信用周期；反之则处于紧信用周期</li></ul><p>@ref：</p><ul><li><a href="https://xueqiu.com/2356382715/190505707" target="_blank" rel="noopener">雕虫小技之：看懂货币信用周期与股债基金配置逻辑 - 雪球</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODMyMTY0Ng==&amp;mid=2650618660&amp;idx=1&amp;sn=f5f197002995d9cad9d65c6aeb6e4ae8" target="_blank" rel="noopener">为啥央妈放水也救不了股市</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F21c.经济机器是如何运行的（Ray Dalio）</title>
      <link href="/52.Financing/F21c.%E7%BB%8F%E6%B5%8E%E6%9C%BA%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/52.Financing/F21c.%E7%BB%8F%E6%B5%8E%E6%9C%BA%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Ray Dalio在2008年美国金融危机之后，在Youtube上的分享的一个30分钟的视频，介绍生产效果、短期债务周期、长期债务周期的起源。这个视频对于没有任何经济学基础的人都是便于理解的。比尔盖茨对这个视频的推荐语是这样的：”This knowledge would help everyone as investors and citizens. Watching it for 30 minutes is a worthwhile investment.” 这些知识对每个人都有帮助，无论是投资者还是普通人；看三十分钟本身就是一个值得的投资。</p></blockquote><h2 id="01-经济运行的三股动力"><a href="#01-经济运行的三股动力" class="headerlink" title="01 经济运行的三股动力"></a>01 经济运行的三股动力</h2><p>经济就像一部简单的机器那样运行，但很多人没有看到这一点。<br>经济虽然看起来很复杂，但其实是以简单和机械的方式运行。经济有几个简单的零部件和无数次重复的简单交易组成。这些交易首先是由人的天性所驱动，因而形成三股主要的经济动力：<br>1、生产率的提高；<br>2、短期债务周期；<br>3、长期债务周期。<br>下面我们谈一下这三股动力，并介绍如何把它们组合在一起形成良好的模型，便于我们跟踪经济的走势，并理解当前正在发生的事情。</p><p><img src="/images/IMG20220916.png" alt="../_images/IMG20220916.png"></p><p>上面提到的三个周期，叠加起来如何影响经济<br><img src="/images/IMG20220916-1.png" alt="../_images/IMG20220916-1.png"></p><h2 id="02-经济中的交易"><a href="#02-经济中的交易" class="headerlink" title="02 经济中的交易"></a>02 经济中的交易</h2><p>我们先来看一下经济中最简单的部分——交易。<br>经济不过是无数交易的总和，而交易是一件非常简单的事情。交易时刻都在发生，你每次买东西都是进行一笔交易。在每次交易中，买方使用货币或信用向卖方交换产品、服务或金融资产。<br>信用在使用时和货币一样，因此把花费的货币和信用加在一起，就可以得出支出总额。支出总额，是经济的驱动力。<br>如果用支出金额除以销量，就得出价格。就是这么简单，这就是交易。交易是经济的基本零件，所有的经济周期和动力，都是交易造成的。所以，理解了交易，就理解了整个经济。<br>一个市场，由买卖同一种商品的所有买方和卖方组成，比如小麦市场、汽车市场、股票市场，和千百万种其他市场。经济就是由所有市场内的全部交易构成的。把全部市场的总支出和销量加在一起，就得到了了解经济运行所需要的全部信息。<br>就这么简单。<br><strong>个人、企业、银行和政府，都在以上述方式从事交易，用货币和信用，交换产品、服务和金融资产。</strong> 政府是最大的买方和卖方。政府由两个部分组成，即收税和花钱的中央政府和中央银行。<br>央行控制着经济中的货币和信贷数量，因此不同于其他买方和卖方。央行通过影响利率和发行更多货币，来实行这种控制。正因如此，央行在信贷流通过程当中发挥着重要作用。</p><h2 id="03-信贷"><a href="#03-信贷" class="headerlink" title="03 信贷"></a>03 信贷</h2><p>001<br>请诸位注意信贷！信贷是经济中最重要的组成部分，但也许是人们最不了解的部分。它之所以最重要，是因为它是经济中最大且最为变幻莫测的部分。<br>贷款人和借款人，与在市场中进行交易的买方和卖方没有两样。通常，贷款人希望自己的钱生出更多的钱，而借款人则想购买当前无法负担的东西，比如房子、汽车，或是进行投资开办企业。借贷可以同时满足贷款人和借款人的要求。<br>借款人保证偿还借款（称为本金），并支付额外的款额（称为利息）。利率高时，借款就会减少，因为贷款变得昂贵；当利率低时，借贷就会变得增加，因为贷款变得便宜。<br>如果借款人保证偿还债务，而且贷款人相信这一承诺，信贷就产生了。任何两个人都可以通过协定，凭空产生信贷。<br>信贷看似简单，实则复杂。因为信贷还有其他的名称，信贷一旦产生，立即成为债务。债务是贷款人的资产，是借款人的负债。等到借款人今后偿还了贷款，并支付了利息，这些资产和负债将消失，交易得以完成。</p><p>002<br>那么，为什么信贷如此重要？<br><strong>这是因为，借款人一旦获得信贷，就可以增加自己的支出。不要忘记，支出是经济的驱动力。</strong> 这是因为，一个人的支出，是另一个人的收入。想想看，你每花一块钱，另一个人就收入了一块钱，而你每挣一块钱，必定有别人花了一块钱。所以，你花的越多，别人挣的就越多。<br>如果某人的收入增加，其信用度就会提高，贷款人就更愿意把钱借给他。信用良好的借款人具备两个条件：偿还能力和抵押物。收入/债务比率高，借款人就具备偿还能力，如果无法偿还，借款人还可以用有价值、可以出售的资产作为抵押物。这样，贷款人可以放心地把钱借给他们。所以收入增加使得借贷也增加，从而能够增加支出。由于一个人的支出是另一个人的收入，这将导致借贷进一步增加，并不断循环。<strong>这一自我驱动的模式导致经济增长，也正因为如此，才产生了经济周期。</strong></p><p>003<br>在一项交易中，你为了获得某样东西，必须付出另一样东西。长期来看，你得到多少取决于你生产多少。我们的知识随时间而增多，知识的积累会提高我们的生活水平，我们将此称为生产率的提高。一个善于创新和勤奋的人，将比那些自满和懒惰的人更快地提高生产率和生活水平。<br>但在短期内，不一定能体现出来。<br><strong>生产率在长期内最关键，但信贷在短期内最重要。</strong> 这是因为，生产率的提高不会剧烈波动，因此不是经济起伏的重要动力。但债务是这种动力！因为我们能够通过借债，让消费超过产出，但是在还债时，不得不让消费低于产出。<br><strong>债务量的波动有两大周期，其中一个周期持续大约5-8年，另一个则持续75-100年。</strong> 大部分人虽然能够感受到波动，但由于距离波动太近，每天每周都身临其境，通常并不认为这是周期。我们将考察这三股动力，并观察它们如何相互作用，以及它们在日常经济中的表现。<br>如上所述，<strong>经济的上下起伏，不是取决于人们多么善于创新或勤奋工作，而是主要看信贷的总量。</strong></p><p>第三部分 @tldr:</p><blockquote><p>在这部分，达里奥阐述了经济的“长短周期”理论，“生产率在长期内最关键，但信贷在短期内最重要”</p><ul><li>长周期即生产率周期，受社会生产率的提高，周期约75-100年，参考 <a href="/52.Financing/F21.经济的周期性/" title="F21.经济的周期性">F21.经济的周期性</a></li><li>短周期则是信贷周期，受信贷影响，周期约5-8年</li></ul></blockquote><blockquote><p>那么信贷如何影响经济活动？<code>交易中的支出= 货币支出 + 信贷支出</code><br>前者在短时间内不会大幅变化（可以理解为受限于个人的生产率提高带来的收入提高，短期变化不大），而后者是个可变量，利率宽松的时候后者大幅提高。<br>而交易中的支出总量，是经济的主要驱动力 =&gt; 增加信贷=短期内经济增长的驱动力</p></blockquote><h2 id="04-信贷与经济周期"><a href="#04-信贷与经济周期" class="headerlink" title="04 信贷与经济周期"></a>04 信贷与经济周期</h2><p>001<br>我们先想象一个没有信贷的经济运行：<br>在这样的一个经济运行中，增加支出的唯一办法是增加收入，因此需要提高生产率和工作量。提高生产率是经济增长的唯一途径。由于我的支出是另一个人的收入，当我或者另一个人提高生产率的时候，经济就会增长。如果我们观察各种交易加以总结，就会发现一条类似生产率增长轨迹的渐近线。<br>但是由于我们借债，于是产生了周期。原因并不是任何法规，而是人的天性和信贷的运作方式。借债不过是提前消费，为了购买现在买不起的东西，你的支出必定超过收入，因此，你需要借钱。实质上，是向未来的自己借钱。你给自己设定了一个未来的时间，到那个时候，你的支出必须少于收入，以便偿还债务，这样马上就形成了一个周期。<br>通常，一旦你借钱，你就制造了一个周期。对于个人是这样，对于整个经济运行也是这样。<br>这就是为什么必须理解信贷。因为信贷触发了一系列机械和可以预料的、将在未来发生的事件。这就是信贷不同于货币的地方。<br>完成交易需要使用货币。当你在酒吧买一瓶啤酒，交易立即完成。但是如果你用信用来买一瓶啤酒，比如赊账，你相当于承诺今后为这瓶啤酒付钱。你和酒吧一起创造了一笔资产和一笔负债，你们凭空制造出了信贷。只有在你今后清偿了这笔赊账之后，上述资产和负债才会消失。债务才会还清，交易才会了结。</p><p>002<br>现实生活中，大部分所谓的“钱”，实际上是信贷。美国国内的信贷总额大约为50万亿美元（当时），而货币总额只有大约3万亿美元。<br>不要忘记，在没有信贷的经济运行中，增加支出的唯一办法是增加生产。<strong>但是在有信贷的经济运行中，还可以通过借债来增加支出。因此，有信贷的经济运行能增加支出，使得收入的增长速度在短期内超过生产率的增长。</strong> 但在长期内，并非如此。<br>但是请不要误解我的意思，信贷不一定是坏事，只是会导致周期性变化。信贷如果造成超出偿还能力的过度消费，就是不良信贷；但是，信贷如果高效率地分配资源和产生收入，让你能偿还债务，就是良性的。<br>例如，你如果借钱买一台大彩电，电视机不会带来任何收入让你偿还债务；但你如果借钱买一台拖拉机，用它来收获更多的庄稼，赚更多的钱，你就能够偿还债务，提高生活水平。<br>在有信贷的经济运行中，我们可以跟踪各种交易，观察信贷如何带来经济增长。我举一个例子。<br>假设你每年挣10万美元，没有任何债务，你有不错的信用，可以借1万美元（例如用信用卡借），因此你每年可以花11万美元（即使你的收入只有10万美元）。由于你的支出是别人的收入，另一个因此挣了11万美元。这个挣了11万美元的人如果没有任何债务，可以借1.1万美元，他可以消费12.1万美元（即使他的年收入只有11万美元）。由于他的支出是另一个人的收入，而我们通过跟踪交易可以看到这个过程不断自我强化。<br>但不要忘记，借债形成周期。周期会上升，最终也会下降。</p><h2 id="05-短期债务周期"><a href="#05-短期债务周期" class="headerlink" title="05 短期债务周期"></a>05 短期债务周期</h2><p>下面我们谈谈短期债务周期。<br>001<br>随着经济活动的增加，出现了扩张，这是短期债务周期的第一阶段。支出继续增加，价格开始上涨。原因是，导致支出增加的是信贷，而信贷可以即刻凭空产生。如果支出和收入的增长速度超过出售的商品的生产速度，价格就会上涨。我们把价格的上涨称为通货膨胀。<br>央行不希望通货膨胀过高，因为这会导致许多问题。央行在看到价格上涨时就会提高利率。随着利率的上升，有能力借钱的人会减少，同时，现有的债务成本也会上升，就等于你每个月的信用卡还款额会增加。由于人们减少借债，还款额度增长，剩下来用于支出的额度将减少，因此，支出速度放慢。而由于一个人的支出是另一个人的收入，环环相扣，人们的收入将下降。由于支出减少，价格将下跌，我们称之为通货紧缩。<br>经济活动减少，经济便进入衰退。如果衰退过于严重，而且通货膨胀不再成为问题，央行将降低利率，使经济活动重新加速。随着利率降低，偿债成本下降，借债和支出增加，出现另一次经济扩张。<br>可见，经济像一部机器一样运行。</p><p>002<br><strong>在短期债务周期中，限制支出的唯一因素，是贷款人和借款人的贷款和借款意愿。</strong> 如果信贷易于获得，经济就会扩张；如果信贷不易获得，经济就会衰退。请注意，这个周期主要由央行控制。短期债务周期通常持续5-8年，在几十年里不断重复。<br>但是请注意，<strong>在每个周期的低谷和高峰后，经济增长和债务都超过前一个周期。</strong> 为什么会这样？是人促成的。人具有借更多钱和花更多钱的倾向，而不喜欢偿还债务，这是人的天性。因此在长期内，债务增加的速度超过收入，从而形成长期债务周期。</p><p>003<br>尽管人们债务增加，但贷款人会提供更宽松的信贷条件。这是为什么？<br>这是因为大家都以为形势一片大好，人们仅注意最近出现的情况。最近的情况是什么呢？——收入一直在增加，资产价值不断上涨，股票市场欣欣向荣，现在是繁荣时期。用借来的钱购买商品、服务和资产很划算。<br>当人们过度借贷消费时，泡沫就产生了。因此，尽管债务一直增加，但收入也以相应的速度增加，从而抵消了债务。我们把债务与收入比率称为债务负担。只要收入继续上升，债务负担就可以承受。与此同时，资产价值迅速上升，人们大量借钱来购买资产。因为投资促使资产价格日益上升，人们感觉自己很富有。因此尽管积累了大量债务，收入和资产价值的上升帮助借债人在长期内保持良好的信用度。</p><p>//第五部分的 @tldr:</p><blockquote><ul><li>短期债务周期中经济阶段参考 <a href="/52.Financing/F21a.美林时钟/" title="F21a.美林时钟">F21a.美林时钟</a> ，这些阶段受政府和央行对信贷的调控、以及人们影响</li><li>每次短债务周期（信贷出现低谷和高峰）后，经济增长（近似等于GDP总量）和债务（信贷的债务）都超过前一个短周期，也就是说，经济总量越来越偏离“实际”，也就是生产率决定的那个经济总量</li><li>当经济总量高于均值太多，按均值回归理论，经济总量会回落，至于回落的原因，也就是下一部分要讲的，去杠杆化。去杠杆化的表现可能有：人们减少消费，同时也减少了贷款，信贷总量也会下降。</li><li>在去杠杆化的过程中，每次短债务周期，经济增长和债务都下降，最终低于经济总量的“均值”</li></ul></blockquote><h2 id="06-去杠杆化"><a href="#06-去杠杆化" class="headerlink" title="06 去杠杆化"></a>06 去杠杆化</h2><p>但是这种情况显然无法永久持续下去，也确实没有持续下去。</p><p>001<br>几十年来，债务负担缓慢增加，使偿债成本越来越高。到了一定程度，偿债成本超过了收入，迫使人们削减支出。<br>由于一个人的支出是另一个人的收入，收入开始下降，人们的信用因此降低，致使借贷减少，偿债成本继续增加，使得支出进一步减少，周期开始逆转，这时到达长期债务的顶峰，债务负担变得过重。<br>美国、欧洲和世界上很多其他地区在2008年即发生了这一情况，日本在1989年和美国在1929年因同样的原因也发生了这一情况。</p><p>002<br>现在，经济进入去杠杆化时期。// 视频是Dialo在2008之后发布的<br>在去杠杆化过程中，人们削减支出，收入下降，信贷消失，资产价格下跌，银行发生挤兑，股票市场暴跌，社会紧张加剧，整个过程开始下滑，并形成恶性循环。<br>随着收入下降和偿债成本增加，借款人倍感拮据。随着信用消失，信贷枯竭，借款人再也无法借到足够的钱来偿还债务。借款人竭力填补这个窟窿，不得不出售资产，在支出下降的同时，出售热潮使市场充斥待售资产。这时股票市场暴跌，不动产市场一蹶不振，银行陷入困境。<br>随着资产价格下跌，借款人能够提供的抵押物的价值下降，这进一步降低了借款人的信用。人们觉得自己很穷，信贷迅速消失。支出减少，收入减少，财富减少，信贷减少，借债等等随之减少，这是一个恶性循环。</p><p>003<br>它看起来与衰退相似，但不同之处是它无法通过降低利率来挽回局面。在衰退中，银行可以通过降低利率来刺激借贷；但在去杠杆化过程中，由于利率已经很低，接近零，从而丧失刺激功能，因此降低利率不起作用。美国在1930年代的去杠杆化期间下降到零，2008年也是如此。<br>衰退与去杠杆化之间的区别在于，在去杠杆化的过程中，借款人的债务变得过重，无法通过降低利率来减轻。贷款人意识到，债务过于庞大，根本无法足额偿还。借款人失去了偿债能力，其抵押物失去价值，他们觉得受到债务的极大伤害，不想再借入更多债务。贷款人停止放贷，借款人停止借贷，整个经济体与个人一样，都失去了信用度。</p><p>004<br>那么应该怎样应对去杠杆化？<br>问题在于债务负担过重，必须减轻。为此可以采用四种办法：<br>1、个人、企业和政府削减支出；<br>2、通过债务违约和重组来减少债务；<br>3、财富再分配，将财富从富人转给穷人；<br>4、央行发行更多货币。<br>这四种办法被用于现代历史上的每一个去杠杆化过程。// 2015年我们是如何去杠杆化的？</p><p>005<br>通常第一个措施是削减支出。我们刚才看到，个人、企业和政府都勒紧裤腰带，削减支出，我们把这称为紧缩。当借款人不再借入新债务，并开始减少旧债务的时候，你会以为债务负担会减轻。<br>但情况正好相反！<br>支出减少了，而一个人的支出是另一个人的收入，这就导致收入下降。收入下降速度超过还债的速度，因此债务负担实际上更为沉重。我们已经看到，这种削减支出的做法引起通货紧缩，令人痛苦。企业不得不削减成本，这意味着工作机会减少，失业率上升，这导致下一个步骤，即必须减少债务。很多借款人无法偿还贷款，而借款人的债务是贷款人的资产，如果借款人不偿还银行贷款，人们会担心无法返还其存款，因此纷纷从银行取出存款，银行受到挤兑，而个人、企业和银行出现债务违约。<br>这种严重的经济收缩就是萧条。萧条的一个重要特征，是人们发现原来以为属于自己的财富中，有很大一部分实际上并不存在。<br>我们仍以酒吧为例：<br>当你以赊账的方式购买一瓶啤酒时，是在承诺今后偿还酒吧的赊账。你的承诺成为酒吧的一项资产。但是若你不兑现承诺，实际上是债务违约，那么酒吧的这项资产实际上一钱不值，它实际上是消失了。</p><p>006<br>很多贷款人不希望自己的资产消失，同意债务重组。债务重组，意味着贷款人得到的还款减少，或偿还期延长，或利率低于当初商定的水平，无论如何，合约被破坏，结果是债务减少。贷款人希望多少收回一些贷款，这强过血本无归。债务重组让债务消失，但由于它导致收入和资产价值以更快的速度消失，债务在日趋沉重。<br>削减债务与减少支出一样，令人痛苦和导致通货紧缩。所有这些都对中央政府产生影响，因为收入降低和就业减少，意味着政府的税收减少。<br>与此同时，由于失业率上升，中央政府需要增加支出；很多失业者储蓄不足，需要政府的财务资助；此外，政府制定刺激计划和增加支出，以弥补经济活动的减少。在去杠杆化过程中，政府的预算赤字飙升，原因是政府的支出超过税收。你在新闻中所听到的预算赤字，正是这种情况。政府必须加税或者举债，以填补赤字。</p><p>007<br>但是在收入下降和很多人失业的时候，应该向谁融资呢？富人。由于政府需要更多的钱，而且大量财富集中在少数人的手中，政府自然而然的增加对富人的征税，以帮助经济中的财富再分配，把财富从富人那里转给穷人。<br>正在困苦之中的穷人开始怨恨富人，承受经济疲弱、资产贬值和增税压力的富人也开始怨恨穷人。如果萧条继续下去，就会爆发社会动荡，不仅国家内部的紧张加剧，而且国家之间也会这样，债务国和债权国之间尤其如此。<br>这种局势可以导致政治变革，有时甚至是极端的变革。1930年代，这种局势导致希特勒掌权，欧洲爆发战争和美国的大萧条。要求采取行动来结束萧条的压力越来越大。</p><p>008<br>不要忘记，人们心目中的货币，实际上大部分是信贷，因此信贷一旦消失，人们的钱会不够花。人们迫切需要钱，而你一定记得，谁可以发行货币——中央银行可以。央行已经将利率降到接近零的水平，现在不得不发行更多货币。<br>发行货币与减少支出、债务重组和财富再分配不同，会引起通货膨胀和刺激经济。中央银行不可避免地会凭空发行更多货币，并使用这些货币购买金融资产和政府债券。这种情况发生于1930年代美国大萧条期间，并于2008年再次爆发。当时美国的中央银行即美联储增加发行了2万多亿美元，世界其他各国能够这样做的央行也增发了很多货币。<br>央行通过用这些货币购买金融资产，推升了资产价格，提高了人们的信用。但是，这仅仅有助于那些拥有金融资产的人。<br>你看，央行能够发行货币，但是只能购买金融资产；但另一方面，中央政府可以购买商品和服务，可以向人民送钱，但是无法印钞票。因此，央行和政府必须合作。央行通过购买债券，其实是把钱借给政府，使其能够运行赤字预算，并通过刺激计划和失业救济金，来增加购买商品和服务的支出，这增加了人们的收入，也增加了政府的债务。但这个办法将降低经济中的总债务负担。</p><p>009<br>这是一个风险很大的时刻。决策者需要平衡考虑降低债务负担的四种办法，必须平衡兼顾通货紧缩的办法和通货膨胀的办法，以便保持稳定。如果取成适当平衡，会带来和谐的去杠杆化。所以，去杠杆化可以是痛苦的，也可以是和谐的。<br>怎样才能实现和谐的去杠杆化？<br>尽管去杠杆化是艰难的，但以尽可能好的办法来处理艰难的局势却是一件好事。这比杠杆化时期大量举债产生过度失衡现象要好得多。在和谐的去杠杆化过程中，债务收入比率下降，经济实际上是正增长。同时，通货膨胀并不是一个问题。这是通过适当的平衡所取得的。为了取得适当的平衡，需要结合削减支出、减少债务、转移财富和发行货币的办法，以保持经济和社会稳定。<br>有人问，发行货币是否会加剧通货膨胀。如果增发的货币抵销信贷的降幅，就不会引发通货膨胀。不要忘记，重要的是支出。每一块钱的支出（无论货币还是信用），对价格的影响都是一样的。央行可以增加货币发行量来弥补消失的信贷。</p><p>010<br>央行为了扭转局面，不仅需要推动收入的增长，而且要让收入的增长率超过所积累债务的利率。这是什么意思？<br>主要的意思是，收入一定要比债务增长得快。例如，我们有个国家正在经历去杠杆化，其债务收入比例是100%，这意味着债务量是整个国家一年的收入。假设这些债务的利率是2%，如果债务以2%利率的速度增加，而收入的增长率仅有大约1%，那么债务负担永远不会减轻，必须发行更多货币，使收入增长率超过利率。<br>然而发行货币太容易了，而且又比其他办法受欢迎，因此这个办法很容易被滥用。关键是避免像1920年代去杠杆化的德国那样，发行过多的货币，从而导致恶性通货膨胀。如果决策层取得适当的平衡，去杠杆化过程就不会那样激烈，经济增长速度缓慢但债务负担会下降，这就是和谐的去杠杆化。<br>当收入上升的时候，借款人的信用就会提高，借款人一旦显得更有信用，贷款人就会恢复贷款，债务负担终于开始下降，人们可以借到钱，就可以增加消费，经济终于开始恢复增长，长期债务周期从而进入通货再膨胀阶段。<br>去杠杆化过程中如果处理不当，会非常可怕。但如果处理得当，最终将解决问题。为了使债务负担下降和经济恢复正常，大约需要7-10年或更长的时间，因此有“失去的十年”这种说法。</p><h2 id="07-尾声"><a href="#07-尾声" class="headerlink" title="07 尾声"></a>07 尾声</h2><p>综上所述，经济当然要比这种模式复杂一点，然而把短期债务周期、长期债务周期和生产率增长轨迹结合起来分析，我们会得到一个不错的模式，可以看清我们在过去和当前的处境，以及未来可能的发展方向。<br>最后，我希望大家学到三条经验法则：<br>第一，不要让债务的增长速度超过收入，因为债务负担最终将把你压垮；<br>第二，不要让收入的增长速度超过生产率，因为这最终将使你失去竞争力；<br>第三，尽一切努力提高生产率，因为生产率在长期内起着最关键的作用。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宏观经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F21b.普林格周期</title>
      <link href="/52.Financing/F21b.%E6%99%AE%E6%9E%97%E6%A0%BC%E5%91%A8%E6%9C%9F/"/>
      <url>/52.Financing/F21b.%E6%99%AE%E6%9E%97%E6%A0%BC%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>美林时钟vs普林格周期：<a href="https://pdf.dfcfw.com/pdf/H3_AP202106081496680732_1.pdf?1623144928000.pdf" target="_blank" rel="noopener">德邦证券-策略专题：大类资产配置框架，基于普林格经济周期六段论-210608.pdf - H3_AP202106081496680732_1.pdf</a></p><p>传统美林时钟框架的不足</p><ul><li>美林投资时钟忽视了央行们的逆周期调控，央行们试图通过政策调控来降低经济运行中过度的周期性波动：当经济持续上行时，央行收紧货币政策避免经济过热；在经济持续下行时，央行放宽货币政策阻止经济陷入萧条。<br>央行逆周期调控会让经济周期出现逆时针转动或跨阶段现象。2019年年末，新冠疫情在全球爆发，美国同步指标和滞后指标共振下行，3月底美联储为了刺激经济开始了逆周期调节，包括开放式的资产购买计划及降息至0-0.25%。一系列极度宽松的货币政策有效地缓解了市场的恐慌情绪并增加了市场的流动性，从2020年6月开始美国同步指标和滞后指标共振上行，美国经济周期直接从衰退期进入了过热期。</li><li>美林时钟框架把CPI当作滞后指标并以此来观察美国的通胀变化，观察美国近6年来CPI同比的变化趋势可以发现美国通胀迟迟处于低位，通胀同比增速从2015年以来均未超过3%，甚至在2015年4月跌入负值区间。拉平的通胀周期导致市场无法释放相对比较明显的上行或下行信号，2015年1月至2021年2月CPI同比增速上下浮动的绝对平均值只有0.27%，CPI同比增速的历史平均百分位在此阶段为25%。宏观指标上下波动相对较小且增速普遍处于历史低位，使得投资者在近几年使用美林时钟框架时无法有效地对经济周期进行正确划分，也使得其解释力与预测力较弱。<br>而且在中国应用时出现了2013-2015无法解释的偏差（需要用框架外的因素解释）；对于美国而言，美林时钟无法解释2009-2018年（甚至不排除2019-2020年）美国的长期复苏，低失业率、正向产出缺口叠加通胀迟迟处于低位的经济状况。</li></ul><p>普林格经济周期六阶段对于美林时钟的改进</p><ul><li>普林格周期中加入了先行指标（信贷周期），更好适应了货币主义时代。与美林投资时钟框架不同，普林格经济周期在已有的同步指标和滞后指标基础上，加入了先行指标并以此来更好的适应货币主义时代。先行指标M1/M2。</li><li>周期阶段划分更为清晰：美林时钟下的周期划分基于库存周期及通胀，并列出每一阶段最好的大类资产，但其过于粗糙的周期划分使得周期阶段并不连续。相比之下，普林格经济周期六阶段在美林时钟的基础下考虑了政府对经济的干涉与调控，从而更准确地划分了经济周期阶段。</li></ul><p><img src="/images/Pring-Turner-six-business-cycle-stages.png" alt="../_images/Pring-Turner-six-business-cycle-stages.png"></p><p>我们将可跟踪的经济指标分为先行指标（信贷周期，典型指标为M1/M2）、同步指标（生产周期，典型的有GDP）以及滞后指标（价格指标，制造国为PPI，消费国为CPI）。 // 不再使用美林时钟的GDP+CPI</p><p>于是经济周期出现六个阶段：</p><ul><li>阶段1、先行指标上行，同步指标及滞后指标下行（经济失速，政府开始逆周期调节）// 债券表现最好</li><li>阶段2、先行指标与同步指标上行，滞后指标下行（复苏阶段，上行拐点出现）// 股票表现最好</li><li>阶段3、共振上行（复苏与过热的中间阶段）</li><li>阶段4、先行指标下行，同步指标及滞后指标上行（经济过热）// 股票和商品</li><li>阶段5、先行指标下行，同步指标下行，滞后指标上行（滞胀，下行拐点出现）// 贵金属</li><li>阶段6、共振下行（萧条）// 债券与贵金属表现良好？</li></ul><blockquote><p>需要注意的是，在实践中，经济由于各种原因可能出现重启（例如疫情/战争等黑天鹅），投资者更需要重视的是数据的验证（判断当前处于哪个阶段）而非接下来将进入哪个阶段（例如，阶段4并不一定直接通往阶段5或阶段6，而是可能由于政府的调控节奏而回到阶段3）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宏观经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F21a.美林时钟</title>
      <link href="/52.Financing/F21a.%E7%BE%8E%E6%9E%97%E6%97%B6%E9%92%9F/"/>
      <url>/52.Financing/F21a.%E7%BE%8E%E6%9E%97%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="美林时钟"><a href="#美林时钟" class="headerlink" title="美林时钟"></a>美林时钟</h2><p>美林时钟是美国投行美林证券提出的一个The Investment Clock资产配置理论。美林时钟用经济增长率（GDP）和通货膨胀率（CPI）这两个宏观指标的高和低，将经济周期分成了四个阶段:</p><ul><li>复苏期（高GDP+低CPI）；</li><li>过热期（高GDP+高CPI）；</li><li>滞胀期（低GDP+高CPI）；</li><li>衰退期（低GDP+低CPI）；</li></ul><p><img src="/images/20220614202907.png" alt=""></p><blockquote><p>GDP &amp; CPI =&gt; <a href="/52.Financing/F23.宏观统计指标/" title="F23.宏观统计指标">F23.宏观统计指标</a></p></blockquote><p>➤ 美林时钟的资产配置方法：</p><ul><li>在复苏中，经济增长开始加速。在复苏中，宽松的政策逐步开始奏效，经济增长开始加速。然而，通货膨胀继续下降，因为多余的产能还没有完全被利用起来，周期性生产力的增长强劲，利润也开始边际修复。中央银行仍然保持政策松动，债券收益率曲线仍在较低位置。 此时，<strong>股票</strong>表现最好。</li><li>在经济过热中，通货膨胀上升。在经济过热中，生产率增长放缓，产能受限，通货膨胀上升。中央银行加息使过热的经济回到可持续增长路径。GDP增长仍保持在较高水平。 债券表现较差，因为收益率曲线向上移动和并平坦化。 股票回报如何取决于利润增长导致估值上升和利率上升导致的估值下降两方面。<strong>大宗商品</strong>表现最好。</li><li>在滞胀中，通胀率持续上升。在滞胀中，GDP增长率低于潜在经济增长，但是通货膨胀率持续上升（通常部分来自于石油价格冲击等）。生产力下降，工资、价格螺旋式上升，公司提高价格以保护其利润边际。只有急速上升的失业率可以打破这种恶性循环。通胀太高，央行也不愿意放松货币政策，债券表现较差（收益率曲线下降？）。股票由于企业利润糟糕表现也很差。此时，<strong>现金</strong>是最好的投资资产。</li><li>在衰退中，GDP增长缓慢。产能过剩和大宗商品价格下跌使得通胀率也较低。 利润微弱，实际收益率下降。收益率曲线向下移动并陡峭，因为央行会降低短期利率，试图使经济回到其可持续增长道路。此时，<strong>债券</strong>是最好的投资配置。 /<em>是指公司债收益率下降？收益率下降意味着债券价格下跌。 问题：衰退过程中央行降息，是如何影响到债券收益率下降的？</em>/</li></ul><p><img src="/images/20220614202249.png" alt=""></p><p>如果考虑到利率，名义利率和实际利率在整个周期中的介入如下：<br><img src="/images/IMG20220916-2.png" alt="../_images/IMG20220916-2.png"></p><p>➤ 当前处于哪个阶段? 通过哪些指标来判断?<br>通过监控宏观经济指标来判断将要来临的经济周期，并确定相应的投资时钟时段。通常可以考虑的指标有 CPI 增速、PMI 指数、工业增加值等。</p><p>➤ 美林时钟配置模式:<br>一般的配置原则为超配处于投资时钟周期内的品种。初始阶段是均衡配置：债券、股票、商品、货币基金各 25% 为基准，<br>处于投资时钟周期内的品种超配至 50%～70% ，其他三类各配置 10%～15%。<br>比如衰退期，债券基金的配置比例为 70%，其他三类各 10%。具体配置比例以对宏观的判断可靠性为准，可靠性高一些则超配比例高一些。</p><h2 id="美林时钟的实际应用"><a href="#美林时钟的实际应用" class="headerlink" title="美林时钟的实际应用"></a>美林时钟的实际应用</h2><p>实际上美林时钟并不好用，缺陷包括：<br>观测指标使用了GDP/CPI（数据滞后，GDP这种总量型数据过于宏观，可观测性差），<br>没考虑现代经济体中的宏观调控（放水、逆周期调节、去杠杆等），这些调控可能会直接影响周期（见下）<br>以及现在的经济全球化后，单一经济体的周期性更容易受到外部经济环境的影响，比如2022现在的情况：经济开始衰退后，zf开始通过宏观调控放水，但是外部状况很差（国外都在加息，出口预期不会好），同时内部状况也不好（疫情带来的消费意愿下降，内需不足）..</p><p>综上，现在的美林时钟不太会给个人的资产配置有直接指导性作用，更多的是帮助理解经济的周期性</p><h2 id="中国经济的美林时钟周期"><a href="#中国经济的美林时钟周期" class="headerlink" title="中国经济的美林时钟周期"></a>中国经济的美林时钟周期</h2><p><a href="https://xueqiu.com/2356382715/189797931" target="_blank" rel="noopener">美林时钟、经济周期与基金投资 - 雪球</a><br>但从2008年以后，美国进入了较长时间的股债双牛模式，日本经济周期好像也没有清晰的规律可行。于是美林时钟理论短期失效。</p><p>随着各主要经济体宏观调控的的不断升级，经济周期发生了“变形”：<br>成熟经济体近十年来主要面对的问题是通缩，我在《大放水不一定带来大通胀，但一定会使不投资的人更穷》一文有过详细分析。为了应对通缩，货币宽松几乎是近十年成熟经济体的常态，货币宽松的直接后果是利率水平长期下行，直至趋近于零利率，甚至负利率。而利率长期下行趋势正是美国股债长期双牛的底层逻辑。但是，“水”不能一直放下去，美国现在就迎来了多年难得一见的通胀威胁，缩表和加息是早晚的事。<br>这就意味着，原来意义上的经济周期发生了变形，从时间上看拉长了。</p><p><a href="https://www.zhihu.com/question/23117153/answer/765993624" target="_blank" rel="noopener">如何理解美林的投资时钟？ - 知乎</a></p><p>基于上述模型，我们观察中国经济。2001 年末正式加入世界贸易组织以来，中国经济经历了两个较明显的完整时钟周期：</p><ul><li>第一个时钟周期是从 2002 年到 2008 年。<ul><li>2002 年开始，中国 GDP 名义增长率迅速跳升至两位数，CPI 在整个 2002 年仍为负，这是衰退周期。</li><li>2003 年下半年开始迅速上升，2004 年开始担忧经济过热，在宏观调控政策的作用下，2005 年 CPI 有所下降，这是复苏周期。</li><li>但随着中国入世后全球经济一体化，中国周期与全球同步，2006 年经济增长再一次加速，2007 年 CPI 也开始快速上升，这是繁荣周期。</li><li>2008 年次贷危机爆发，中国经济迅速下降通道，这是滞涨周期，四个阶段的美林时钟很完整。</li></ul></li><li>2009 年到 2018 年是第二个时钟周期。<ul><li>随着 2009 年中国政府刺激政策的启动，CPI 在 2010 年开始急剧攀升，复苏开始。// CPI数据见 《F23.常用宏观统计指标》</li><li>CPI 在 2011 年达到顶峰；到了 2013 年通胀开始冒头，这时候央行还并没有启动加息，繁荣周期开始，一直到 2015 年底，那时候宏观经济很好，各种创业创新活动层出不穷。</li><li>2016 年开始，央行保持利率稳定，但是外部环境的变化引发了国内通胀开始抬头，进入了衰退周期。</li><li>从 2018 年开始，美国不断加息的压力下，中国无法继续放松银根，属于被动更随。这时候滞涨周期。</li></ul></li></ul><p>根据这个周期，我们也发现中国的股票市场随着周期而波动，例如 2009 年股票市场启动，代表成长股的中小板指数这一年涨幅超过 20%。同时大宗商品开始上涨，上涨持续到 2011 年初。2011 年下半年开始，债券大幅上涨，到 2015 这一轮债券牛市结束。从 2016 年开始大宗商品启动了一轮大涨。所以可以明显的看出美林时钟周期和股票、债券、大宗商品之间的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宏观经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F21.经济的周期性</title>
      <link href="/52.Financing/F21.%E7%BB%8F%E6%B5%8E%E7%9A%84%E5%91%A8%E6%9C%9F%E6%80%A7/"/>
      <url>/52.Financing/F21.%E7%BB%8F%E6%B5%8E%E7%9A%84%E5%91%A8%E6%9C%9F%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“万物皆周期”</p></blockquote><p>宏观经济的周期理论：<br>• 美林时钟周期：<a href="/52.Financing/F21a.美林时钟/" title="F21a.美林时钟">F21a.美林时钟</a><br>• 普林格周期：<a href="/52.Financing/F21b.普林格周期/" title="F21b.普林格周期">F21b.普林格周期</a><br>• Ray Dailo提出的长短期债务周期 <a href="/52.Financing/F21c.经济机器是如何运行的/" title="F21c.经济机器是如何运行的">F21c.经济机器是如何运行的</a></p><p>此外，根据不同的投资波动，还可划分出几大经济周期：</p><p>• 农产品周期（蛛网周期）：农产品价格对产能的迟滞作用，周期长度1~12M<br>• 库存周期（基钦周期）：增长与通胀周期，周期长度2~4Y<br>• 设备周期（朱格拉周期）：经济景气度、设备寿命，周期长度6~11Y<br>• 地产周期（库兹涅茨周期）：人口增长周期，周期长度24~40Y<br>• 康波周期（康德拉季耶夫周期）：科技创新周期，周期长度50~70Y，周天王“人生发财靠康波”</p><p><img src="/images/IMG20220930-3.png" alt="../_images/IMG20220930-3.png"></p><hr><h2 id="库存周期（基钦周期）"><a href="#库存周期（基钦周期）" class="headerlink" title="库存周期（基钦周期）"></a>库存周期（基钦周期）</h2><p>@todo</p><h2 id="设备周期（朱格拉周期）"><a href="#设备周期（朱格拉周期）" class="headerlink" title="设备周期（朱格拉周期）"></a>设备周期（朱格拉周期）</h2><p>影响朱格拉周期的因素：</p><ul><li>供求关系的反应速度，在市场条件下，供需关系总是不同步</li><li>企业家心态：朱格拉周期体现的是企业家对产能的投资，在繁荣-萧条不同周期心态是不同的</li></ul><p>历史上我们观察到的朱格拉周期是6-11年，1987年前后中国一共经历了4个：</p><p><img src="/images/IMG20220930-5.png" alt="../_images/IMG20220930-5.png"></p><h2 id="地产周期（库兹涅茨周期）"><a href="#地产周期（库兹涅茨周期）" class="headerlink" title="地产周期（库兹涅茨周期）"></a>地产周期（库兹涅茨周期）</h2><p>@todo</p><h2 id="康波周期（康德拉季耶夫周期）"><a href="#康波周期（康德拉季耶夫周期）" class="headerlink" title="康波周期（康德拉季耶夫周期）"></a>康波周期（康德拉季耶夫周期）</h2><ul><li><a href="https://m.gelonghui.com/p/330433" target="_blank" rel="noopener">周金涛的“2019大预言”，为何落空了？</a></li><li><a href="https://zhuanlan.zhihu.com/p/393231620" target="_blank" rel="noopener">重温周期天王周金涛：对2025年之前的经济预测。周金涛-中信建投首席经济学家-2016年3月16日演讲 - 知乎</a></li></ul><h2 id="周期叠加，会发生什么？"><a href="#周期叠加，会发生什么？" class="headerlink" title="周期叠加，会发生什么？"></a>周期叠加，会发生什么？</h2><p><img src="/images/IMG20220930-4.png" alt="../_images/IMG20220930-4.png"></p><p>@ref： <a href="https://mp.weixin.qq.com/s/ceteHbtKvKr7V7EQfKAvBQ" target="_blank" rel="noopener">人生发财靠康波？周期论真的靠谱吗？</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> _Index </tag>
            
            <tag> 宏观经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F20.宏观经济框架</title>
      <link href="/52.Financing/F20.%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E6%A1%86%E6%9E%B6/"/>
      <url>/52.Financing/F20.%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>@todo</p><ul><li>如何建立自己的宏观经济分析框架？ - 张涔子沐的回答 - 知乎 <a href="https://www.zhihu.com/question/46135259/answer/2367963781" target="_blank" rel="noopener">https://www.zhihu.com/question/46135259/answer/2367963781</a></li></ul><p><img src="/images/IMG20220930-1.png" alt="../_images/IMG20220930-1.png"></p><p>在此基础上，扩展如下:</p><p><img src="/images/IMG20220930-2.png" alt="../_images/IMG20220930-2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F19.股市大盘历史数据</title>
      <link href="/52.Financing/F19.%E8%82%A1%E5%B8%82%E5%A4%A7%E7%9B%98%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE/"/>
      <url>/52.Financing/F19.%E8%82%A1%E5%B8%82%E5%A4%A7%E7%9B%98%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="A股指数（10年、20年走势）"><a href="#A股指数（10年、20年走势）" class="headerlink" title="A股指数（10年、20年走势）"></a>A股指数（10年、20年走势）</h2><p>历次大跌归因：<a href="/52.Financing/F18.金融大事记/" title="F18.金融大事记">F18.金融大事记</a></p><p>➤ 【十年】上证指数：2012~2022<br><img src="/images/20220328031619.png" alt=""></p><p>➤ 【二十年】上证指数：2002~2022<br><img src="/images/20220328023705.png" alt=""></p><h2 id="美股指数（10年走势）"><a href="#美股指数（10年走势）" class="headerlink" title="美股指数（10年走势）"></a>美股指数（10年走势）</h2><p>➤ 【十年】纳指综合 (2012~2022)<br><img src="/images/20220227011627.png" alt=""></p><h2 id="A股宽基指数比较"><a href="#A股宽基指数比较" class="headerlink" title="A股宽基指数比较"></a>A股宽基指数比较</h2><p>红：创业板指<br>橙：中证500<br>绿：沪深300<br>蓝：上证50<br>灰：富时A50<br>紫：恒生指数</p><p><img src="/images/20220505160812.png" alt=""></p><p>2015：创业板🟥 &gt; 中证500🟧 &gt; 沪深300🟩<br>2018：富时A50(灰) &gt; 沪深300🟩 &gt; 创业板🟥 &gt; 中证500🟧<br>2021：富时A50(灰)&gt;创业板🟥 &gt; 沪深300🟩 &gt; 中证500🟧</p><h2 id="A股行业基金比较"><a href="#A股行业基金比较" class="headerlink" title="A股行业基金比较"></a>A股行业基金比较</h2><p>➤ 2019~2022 行业主题基金净值</p><p>新能源车&gt;芯片&gt;医疗&gt;消费≈创业板<br><img src="/images/20220505155451.png" alt=""><br>@ref: <a href="https://www.howbuy.com/fundtool/compare.htm?codes=007531,512760,161028,162412,000248" target="_blank" rel="noopener">基金对比 - 工具 - 好买基金网</a></p><h2 id="A股宽基指数与行业统计数据"><a href="#A股宽基指数与行业统计数据" class="headerlink" title="A股宽基指数与行业统计数据"></a>A股宽基指数与行业统计数据</h2><p>A股回报率:<br><img src="/images/20220327190737.png" alt="A股 宽基指数 vs 行业指数回报率"></p><ul><li>创业板跑赢了29/31个行业；沪深300跑赢了17/31个行业；上证50跑赢了14/31个行业；</li><li>近十五年回报排名前三的是：家用电器、食品饮料、生物医药；</li><li>近十年回报排名前三的是：社会服务（中国中免）、食品饮料、电子（芯片）</li><li>近五年回报排名前三的是：食品饮料、电力设备（宁德时代、隆基股份）、社会服务（中国中免）</li></ul><p>@ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDQ1Nzk0OA==&amp;mid=2247500357&amp;idx=1&amp;sn=36e719467ca2f292de7947b8a3105f90&amp;chksm=f9e899f6ce9f10e0dbd4e450d73469386c1f79888f4638e8d9d2745cd8b95dd76063026c5640&amp;mpshare=1&amp;scene=1&amp;srcid=0324dTZlLY9E9i9FCaxTqyNS&amp;sharer_sharetime=1648091378042&amp;sharer_shareid=14b53f38afdfea7d2ddf5cf94750a409#rd" target="_blank" rel="noopener">望京博格 - 宽基和行业基金，哪一种更好？</a></p><hr><p>➤ 申万31个行业年度涨跌幅:</p><p><img src="/images/20220401221717.png" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F18.金融大事记</title>
      <link href="/52.Financing/F18.%E9%87%91%E8%9E%8D%E5%A4%A7%E4%BA%8B%E8%AE%B0/"/>
      <url>/52.Financing/F18.%E9%87%91%E8%9E%8D%E5%A4%A7%E4%BA%8B%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/20220331223347.png" alt="F19.金融大事记-题图"></p><h2 id="1992-黑色星期三"><a href="#1992-黑色星期三" class="headerlink" title="1992-黑色星期三"></a>1992-黑色星期三</h2><p>Black Wednesday:<br>是指1992年9月16日英国保守党政府因无力维持英镑的汇率下限而被迫退出欧洲汇率体系（ERM）。著名投资经理人乔治·索罗斯通过大量做空英镑而获利超过10亿美元。据英国财政部于1997年的估计，英国为此付出了34亿美元的代价.</p><p>背景:<br>英国最初于1990年加入欧洲汇率体系。根据规定，各成员国有责任使本国货币汇率的波动稳定在一定范围之内。两德统一之后，德国为缓解通货膨胀压力而提升利率，给包括英国在内的许多为刺激经济增长而实行低利率的国家造成了很大压力。英镑对马克间的汇率开始大跌，汇率逐渐逼近欧洲汇率体系规定的下限2.778。1992年9月16日上午，英国政府决定将利率由10%提升至15%，但无力缓解英镑下跌之势。当天晚上，英国最终决定退出欧洲汇率体系，并将利率下调至12%。次日，又降回原先的10%。</p><ul><li>索罗斯和他的助手们卖空了大约70亿美元的英镑，买入了约60亿美元的德国马克，并买入了一定的法国法郎。作为平行交易，他们还在做空英镑的时候，就买入了价值高达5亿美元的英国股票，预期股市通常会在货币贬值后上涨。</li><li>索罗斯还做多了德国和法国债券，同时做空这些国家的股票。对于在法国和德国市场的操作，索罗斯的理由是：估值上升在股票是坏事，但在债券是好事，因为它会导致利率走低。</li><li>我们在来看看他当时的杠杆头寸是如何奏效的：英镑下跌10%，马克和法郎均上涨约7%，伦敦股市上涨7%，德国和法国债券各上涨3%左右，德国和法国股市短暂反弹，但基本持平。</li></ul><p>英镑贬值导致马克升值的逻辑是?</p><ol><li>欧洲国家汇率联动（锚点为德国马克）// 为什么汇率联动？ 方便结算</li><li>所以各国要维持自己对马克的汇率稳定</li><li>德国通胀，需要加息，英国通缩，需要降息，但这样会引起市场上卖出英镑换马克，英镑贬值，如果英国无法维持英镑对马克汇率，会被迫退出.. 进一步打击经济</li><li>索罗斯已经开始大量抛售（前期借来的）英镑，进一步加剧英国国对于英镑贬值的内恐慌情绪</li><li>英格兰银行动用外汇储备接盘索罗斯抛售的英镑，同时宣布加息（加息可以在一定程度让英镑回流，但在通缩周期加息emmm）</li><li>最后的结果是</li></ol><p>待整理:  </p><ul><li><a href="https://new.qq.com/omn/20200714/20200714A0WECI00.html" target="_blank" rel="noopener">“索罗斯”如何狙击英镑？干倒英格兰银行？_腾讯新闻</a></li><li><a href="https://wiki.mbalib.com/wiki/索罗斯狙击英镑" target="_blank" rel="noopener">索罗斯狙击英镑</a></li></ul><h2 id="1997-亚洲金融危机"><a href="#1997-亚洲金融危机" class="headerlink" title="1997-亚洲金融危机"></a>1997-亚洲金融危机</h2><p><a href="https://baike.baidu.com/item/1997%E5%B9%B4%E4%BA%9A%E6%B4%B2%E9%87%91%E8%9E%8D%E5%8D%B1%E6%9C%BA/23187113" target="_blank" rel="noopener">1997年亚洲金融危机_百度百科</a></p><h2 id="1998-香港金融保卫战"><a href="#1998-香港金融保卫战" class="headerlink" title="1998-香港金融保卫战"></a>1998-香港金融保卫战</h2><p><a href="https://baike.baidu.com/item/%E9%A6%99%E6%B8%AF%E9%87%91%E8%9E%8D%E4%BF%9D%E5%8D%AB%E6%88%98/6222732" target="_blank" rel="noopener">香港金融保卫战_百度百科</a></p><p>link: <a href="/52.Financing/F13b.港股/" title="F13b.港股">F13b.港股</a></p><h2 id="2000-互联网泡沫破裂"><a href="#2000-互联网泡沫破裂" class="headerlink" title="2000-互联网泡沫破裂"></a>2000-互联网泡沫破裂</h2><p>@todo</p><h2 id="2007-次贷危机"><a href="#2007-次贷危机" class="headerlink" title="2007-次贷危机"></a>2007-次贷危机</h2><p>@ref: <a href="https://www.zhihu.com/question/303151833/answer/2325297322" target="_blank" rel="noopener">什么是“做空”？“做空”是如何赚钱的？ - 叶泊枫的回答 - 知乎</a></p><p>次贷危机: “次级贷款市场危机”，次级贷=信用资质不太好的贷款.</p><p>MBS——房屋抵押贷款债券。房屋抵押贷款即房贷，债券就是借条。打包在一起，就是……一堆借条。所以这个 MBS，往简单了说，就是一堆房贷合同打包在一起的，可以交易的债券<br>CDO可以看成各种债券反复打包的套娃产品。CDO 里可能有房贷，也可能有消费贷等其他各种贷，甚至 CDO 里还有 CDO。</p><p>理论上，MBS 模式可以形成一个无限的放贷循环：放贷 ➜ 打包 ➜ 售出 ➜ 再放贷 ➜ 再打包……</p><p>如何做空MBS 和 CDO?</p><ul><li>(美国楼市存在大量泡沫), 当次级贷违约率上升， MBS 和 CDO 就会暴雷，MBS 和 CDO 将会跌得一文不值</li><li>第一种做空, (借钱)从券商那里大量买入CDO,  然后抛售, 等CDO暴跌, 再以便宜的价格买入等量的CDO还给, 但是看涨的投资人，通常会买下一整期的 CDO，且拒绝向外借出，不给你做空的机会</li><li>CDS出场: CDS 是一种保险，专门为债券资产提供保护。例如买了A公司债券, 又担心无法兑现, 就买对应的CDS, 当A公司爆雷, 保险公司就赔偿给你损失. 但实际上, 你无需购买债券, 也可以买对应的CDS, 华尔街的伟大发明!</li></ul><h2 id="2015-A股创业板崩盘"><a href="#2015-A股创业板崩盘" class="headerlink" title="2015-A股创业板崩盘"></a>2015-A股创业板崩盘</h2><p>@todo</p><h2 id="2000-2022-A股大事记"><a href="#2000-2022-A股大事记" class="headerlink" title="2000~2022-A股大事记"></a>2000~2022-A股大事记</h2><ul><li>2000.2: 美联储大幅加息</li><li>2000.4: 纳指跌超25%</li><li>2001.11: 911</li><li>2001: 纳指跌至巅峰时期的1/4不到</li><li>…</li><li>2007.10: 上证新高6100点</li><li>2007: 05~07年我国贸易顺差扩大, 人民币升值, 经济过热, 为抑制经济过热, 07年开始连续加息, 提高准备金率, 导致08年经济降温, 叠加泡沫严重, 大小非接近高峰</li><li>2008.5 中国出口同比增速见顶于28%</li><li>2008下半年: 美国次贷危机开始</li><li>2008.9: 雷曼兄弟破产, 美国次贷危机升级为全球危机</li><li>2008.10: 上证跌至1660点</li><li>2008.11: 上证指数跌幅73%, 沪深300指数跌至1600</li><li>2009.1: 中国出口同比增速下滑到-17%, 一季度GDP累积同比下滑到6%</li><li>2009: 4万亿计划ing</li><li>…</li><li>2014年后, 宽松经济政策, 连续降准降息</li><li>2015: 房地产调控加强, 投资股市进一步升温</li><li>2015: 沪深300涨至5300点, 历史新高</li><li>2015.6: 上证指数新高5100点</li><li>2015: 开始去杠杆 @ref <a href="https://opinion.caixin.com/2019-06-11/101425410.html" target="_blank" rel="noopener">资本市场去杠杆系列（1）：投资端杠杆与2015年“股灾”</a></li><li>2015.6~ 2016.2 : “股灾”, 沪指跌至2700点, 创业板-70%</li><li>…</li><li>2018: 贸易争端 中概互联大跌48%</li><li>2019整年的走势参考: ![[../_images/川普推文-A股走势.png]]</li><li>2020: 创业板大涨65%, 牛冠全球</li><li>2021.7: 创业板指最高涨至3576点, 涨幅超200% // 宁德时代等</li><li>2021.11: 纳指新高16000点, 是2002.10的14倍</li><li>2021.2: 中概互联新高</li><li>2021.2~年底:  监管层密集的动作——从2021年1月对电子烟的限制，到3月以来对K12教育持续加码的监管政策，以及对阿里、腾讯和美团的反垄断处罚，和对滴滴、BOSS直聘、满帮的审查等等，</li><li>2022.3: 百济神州等5家在美上市的中国公司被列入美国证监会(SEC)的可能摘牌名单</li><li>2022.3.10: 美股收盘，热门中概股集体大跌，30多只股票跌幅超过10%，贝壳跌近24%、爱奇艺跌21%、拼多多跌17%、京东跌15%、哔哩哔哩跌14%，创下2008年10月以来最大跌幅</li><li>2022.4.25 <a href="/52.Financing/F71.202204-A股见底了吗/" title="F71.202204-A股见底了吗">F71.202204-A股见底了吗</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F13c.美股</title>
      <link href="/52.Financing/F13c.%E7%BE%8E%E8%82%A1/"/>
      <url>/52.Financing/F13c.%E7%BE%8E%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<p>@tag: #入门101 #美股</p><p>@todo:</p><ul><li><a href="http://pdf.dfcfw.com/pdf/H3_AP201711091026104041_1.PDF" target="_blank" rel="noopener">川财证券-多角度评估美股的估值</a></li><li><a href="https://m.gelonghui.com/p/55640" target="_blank" rel="noopener">美股估值的三种常用方法，一看就懂</a></li><li><a href="https://xueqiu.com/5760078642/224136545" target="_blank" rel="noopener">抄底美股的三种方法和思路 - 雪球</a></li></ul><h2 id="主要指数"><a href="#主要指数" class="headerlink" title="主要指数"></a>主要指数</h2><ul><li>纳斯达克指数-百度百科<ul><li>平均指数, 基本指数为100. 纳斯达克的上市公司涵盖所有新技术行业, 包括软件和计算机、电信、生物技术、零售和批发贸易等.</li><li>纳斯达克”综合指数”(IXIC): 相比标准普尔500指数、道·琼斯工业指数（它仅包括30个著名大工商业公司, 20家运输业公司和15家公用事业大公司）更具有综合性. 纳斯达克综合指数包括5000多家公司, 超过其他任何单一证券市场. 因为它有如此广泛的基础, 已成为最有影响力的证券市场指数之一.</li></ul></li><li>标普500指(S&amp;P 500 Index): 当中囊括了美国500 家主要公司，占美国股市约八成的可投资市值。标普500 代表了美国市场，占美国股市的80%-85%, 几乎所有标准普尔中的公司都是全美最高金额买卖的500只股票。这个股票指数由标准普尔公司创建并维护。</li><li>道琼斯工业平均指数(DJIA): 道琼斯工业平均指数不是加权算术平均值，并不代表其组成公司的市值，而是每个组成公司的一股股票价格总和后的平均值。是在美国证券交易所上市的 30 家著名公司的价格加权衡量股票市场指数。// 不少专业人士认为，与标准普尔 500 指数或罗素 3000 指数等等，更广泛的市场指数相比，道琼斯工业平均指数仅包括 30 家大公司，不足以代表整个美国股市。此外，道琼斯工业平均指数也不使用加权算术平均值。</li></ul><h2 id="粉单（pink-sheet）"><a href="#粉单（pink-sheet）" class="headerlink" title="粉单（pink sheet）"></a>粉单（pink sheet）</h2><p><a href="https://www.zhihu.com/question/22409430" target="_blank" rel="noopener">https://www.zhihu.com/question/22409430</a><br>粉单市场的功能就是为那些选择不在美国证券交易所或NASDAQ挂牌上市、或者不满足挂牌上市条件的股票提供交易流通的报价服务。</p><p>今天的粉单交易市场，已纳入纳斯达克最底层的一级报价系统，是美国柜台交易(OTC)的初级报价形式。广义的美国OTC市场包括NASDAQ、OTCBB和粉单市场，按其上市报价要求高低依次为：NASDAQ→OTCBB→粉单。</p><p><img src="/images/IMG20221003.png" alt="../_images/IMG20221003.png"></p><p>粉单市场不是一个股票交易所，它不受证券监管当局的监管，只要每天交易结束时公布挂牌公司的报价即可。但是NASD监管当局(NASDR)和SEC会对粉红单市场和黄单市场上证券的所有做市商进行严格的监管。</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F13b.港股</title>
      <link href="/52.Financing/F13b.%E6%B8%AF%E8%82%A1/"/>
      <url>/52.Financing/F13b.%E6%B8%AF%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<p>@todo：</p><ul><li>港股流动性问题：<ul><li><a href="https://finance.sina.com.cn/stock/stockzmt/2022-08-12/doc-imizmscv5868418.shtml" target="_blank" rel="noopener">【策略】当谈及港股流动性时，我们在讨论什么？——策论海外系列报告之二（张宇生/巩健/刘芳）|港股<em>新浪财经</em>新浪网</a></li><li>对于美元汇率的敏感度很高</li></ul></li><li>港股的红利税问题：投资者通过港股账户投资H股有10％的红利税，但是通过港股通投资H股，有20％红利税</li></ul><h2 id="港股指数"><a href="#港股指数" class="headerlink" title="港股指数"></a>港股指数</h2><ul><li>恒生指数(HSI): 指数由64只恒指成份股的市值计算出来的，代表了香港交易所所有上市公司的十二个月平均市值涵盖率的63%。恒生指数成份股，即是香港的蓝筹股。恒生指数由恒生指数有限公司负责计算及按季检讨，公布成份股调整。</li></ul><h2 id="港股通、沪股通"><a href="#港股通、沪股通" class="headerlink" title="港股通、沪股通"></a>港股通、沪股通</h2><ul><li>港股指在香港联合交易所上市的股票。相比起来，港股市场比A股要更加成熟理智一点，若是我国的股票同时在国内及香港上市，形成“A+H”模式，则能够依照其在香港股市的情况对A股的走势进行预测。</li><li>港股通: 上海证券交易所和香港联合交易所将允许两地投资者通过当地证券公司(或经纪商)买卖规定范围内的对方交易所上市的股票。港股通，是指投资者委托内地证券公司，经由上海证券交易所设立的证券交易服务公司，向香港联合交易所进行申报(买卖盘传递)，买卖规定范围内的香港联合交易所上市的股票。</li><li>沪股通，是指投资者委托香港经纪商，经由香港联合交易所设立的证券交易服务公司，向上海证券交易所进行申报(买卖盘传递)，买卖规定范围内的上海证券交易所上市的股票；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F13a.A股</title>
      <link href="/52.Financing/F13a.A%E8%82%A1/"/>
      <url>/52.Financing/F13a.A%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="A股-and-B股"><a href="#A股-and-B股" class="headerlink" title="A股 and B股"></a>A股 and B股</h2><ul><li>A股: 在我国境内由境内公司发行,由境内投资者购买的,在境内交易的人民币普通股票。</li><li>B股: 公司在境内发行和上市,以人民币表明面值,由外国人/境内外的中国公民,以外币认购</li></ul><h2 id="A股主要指数"><a href="#A股主要指数" class="headerlink" title="A股主要指数"></a>A股主要指数</h2><blockquote><p>沪深300是选取市值最大的300只股票，中证500是选取市值排名301-800的500只股票，中证1000是选取市值排名801-1800的1000只股票</p></blockquote><ul><li>上证50（000001）：挑选上海证券市场规模大、流动性好的最具代表性的50 只股票组成样本股。这个金融地产占比较多。<ul><li>金融服务行业占比50%+</li></ul></li><li>沪深300（000300）：这个是最能够代表A股表现的指数，并且一般软件都会跟沪深300比较业绩。沪深300指数以规模和流动性作为选样的两个根本标准，并赋予流动性更大的权重，算是国内股市规模最大的300只股票。<ul><li>金融服务行业占比30%+</li></ul></li><li>中证500（CSI 500）：其样本空间内股票是由全部A股中剔除沪深300指数成份股及总市值排名前300名的股票后，总市值排名靠前的500只股票组成，综合反映中国A股市场中一批中小市值公司的股票价格表现。其实中证500只能算是中盘股。<ul><li>各行业占比均衡</li></ul></li><li>中证800：A股最大的800（中证800=沪深300+中证500）</li><li>中证1000：A股第801-1800</li><li>上证红利指：挑选在上证所上市的现金股息率高、分红比较稳定、具有一定规模及流动性的50只股票作为样本，以反映上海证券市场高红利股票的整体状况和走势。</li></ul><p><img src="/images/20220226113933.png" alt=""></p><p>@ref: <a href="https://zhuanlan.zhihu.com/p/111336040" target="_blank" rel="noopener">关于上证50，沪深300，中证500的区别，用一篇说透。 - 知乎</a></p><h2 id="A股上证指数为什么失真"><a href="#A股上证指数为什么失真" class="headerlink" title="A股上证指数为什么失真"></a>A股上证指数为什么失真</h2><p><img src="/images/20220705173226.png" alt=""></p><p><img src="/images/20220705173342.png" alt=""></p><p>为什么近十年股指没有很好反映中国经济运行情况?</p><ul><li>第一，很长时间上证指数包含了ST及*ST股，严重扭曲了资本市场“优胜劣汰”的信号，影响指数代表性和合理性。</li><li>第二，以总市值加权的方法编制，没有设置权重上限，导致总股本大、流动股少的公司影响过大。一方面，难以客观反映市场真实结构和供需，低估了新兴行业对市场总体的贡献，导致市场信号失真；另一方面，较少的资金就能起到拉抬或打压权重股进而影响股指的效果，这与国家队拉抬两桶油救市的逻辑一致。</li><li>第三，成分股未能充分反映市场结构变化，没有考虑行业平衡，没有纳入科创板股票。长期以来，上证指数以金融、交运、化工、地产等传统行业为主，相应的垄断性行业由于缺乏成长性，难以真实体现经济结构的变化情况，价格波动区间窄，即“涨不动”。而多数医疗保健、信息技术、消费服务等新经济行业的企业选择在深交所上市并成长。2018年科创板横空出世，大量面向科技前沿、突破关键核心技术的科创企业登陆科创板，优化了沪市股票整体的行业结构，然而上证指数并没有将科创板股票纳入</li><li>第四，成分股纳入时间的问题。2020年前，上证指数执行的是新股第11个交易日开始计入指数的规则。然而过去很长一段时间，市场普遍存在新股不败神话，新股上市初期存在“连续涨停”及高波动现象。2014年至2019年，沪市共上市新股563只，上市后平均连续涨停天数为9天，217只新股连续涨停天数超过10天。这意味着新股被纳入成分股的时候恰好处于高位或次高位，没有经历充分的市场定价博弈，随后相当一部分股票的股价持续回落，拖累指数表现。</li></ul><p>2020年6月19日，上证指数迎来了创立近30年来的首次修订（7月22日生效）。修订内容包括剔除ST、*ST个股，将科创板CDR及股票纳入样本空间，以及延长新股纳入期限三个方面。可以看到，导致股指与经济运行背离的很多技术面障碍已经打破，上证指数的市场代表性与稳定性正逐步提高。</p><p><img src="/images/20220705172926.png" alt=""></p><p>@ref《粤开宏观-A股走势与宏观经济一致与背离的原因.pdf》</p><h2 id="A股交易规则-amp-费率"><a href="#A股交易规则-amp-费率" class="headerlink" title="A股交易规则&amp;费率"></a>A股交易规则&amp;费率</h2><ul><li>T+0：今天买了就能卖；T+1：今天买了第二天才能卖, 我国股市实行’T＋1’交易制度，即当日买进的股票，必须要到下一个交易日才能卖出。</li><li>交易时间：周一到周五上午9：30到11：30，下午1：00到3：00，周末以及法定节假日休市。</li></ul><p>▷ 股票交易中产生的主要费用： @ref: <a href="https://mp.weixin.qq.com/s/d0VGzS3jnO6a3NmDdEEBsw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/d0VGzS3jnO6a3NmDdEEBsw</a></p><ol><li>印花税：收费主体为财税部门，卖出的时候向卖方收取，0.1% （<em>注：ETF无印花税</em>）</li><li>过户费：收费主体为中国结算，买卖双方收取，0.001%</li><li>券商佣金：收费主体为券商，买卖双方收取，比如0.0015（万1.5）, 不满1w按5块计</li></ol><p>举个例子，假设一个人买入然后又卖出10万元的股票，他需要支付的税费是多少呢？</p><ul><li>买入时：佣金15 + 过户费1</li><li>卖出时：佣金15 + 过户费1 + 印花税100</li></ul><h2 id="A股行业指数开头编码"><a href="#A股行业指数开头编码" class="headerlink" title="A股行业指数开头编码"></a>A股行业指数开头编码</h2><ul><li>H开头的一般都是二级、三级行业指数，同时一级行业全指指数在000986-000995之间</li><li>上交所编的指数名称一般前两个字是上证，代码000开头</li><li>深交所编的指数名称一般前两个字是深证、国证，代码399开头</li><li>中证指数公司的指数名称一般前两个字是中证，代码同时有000和399开头，比如最著名的中证500指数，399905和000905两个代码都是该指数。</li></ul><h2 id="中小板、创业板、科创板、新三板"><a href="#中小板、创业板、科创板、新三板" class="headerlink" title="中小板、创业板、科创板、新三板"></a>中小板、创业板、科创板、新三板</h2><p>场内市场，包括上海证券交易所和深圳证券交易所。主板(沪深主板, 也叫一板)、中小板、创业板都是场内交易所市场，对应的企业均为上市公司。<br>场外市场（otc），包括新三板（全称叫全国中小企业股份转让系统）、区域性股权交易市场、券商otc市场，对应的企业均为非上市公司</p><p><img src="/images/20220403012224.png" alt=""></p><ul><li>中小板：2004年创立，主要针对发展成熟，盈利稳定的中小企业。中小板跟沪深主板一样，同属一板市场(Main-Board Market)。<ul><li>代码为002打头的股票。</li></ul></li><li>创业板：2009年创立，创业板的上市标准比主板和中小板都要低一些，而且创业板企业的融资量的需求也没有中小板大，主要针对高科技高成长的中小企业。创业板是对主板市场的重要补充，属于二板市场(Second-board Market)<ul><li>代码为300打头的股票</li></ul></li><li>科创板：2019年创立，是上交所在主板外单独设立，主要针对符合国家战略、突破关键核心技术、市场认可度高的科技创新企业。<ul><li>代码为688打头的股票</li></ul></li><li>新三板：2012，即全国中小微企业(不是上市公司)股份转让系统，主要针对创新型、创业型、成长型的中小微企业。新三板，是独立于沪深股市之外的证券交易场所，属于三板市场，Over the Counter Market。新三板内不是上市公司，但是可以在新三板买卖交易公司企业股份的板块系统</li></ul><p>各个板板投资风险从高到低是：新三板&gt;科创板&gt;创业板&gt;中小板&gt;主板</p><p><a href="https://baike.eastmoney.com/item/%e7%a7%91%e5%88%9b%e6%9d%bf%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" target="_blank" rel="noopener">科创板基础知识_东方财富网</a></p><h2 id="大小非解禁"><a href="#大小非解禁" class="headerlink" title="大小非解禁"></a>大小非解禁</h2><p>非=非流通股，当初股权分置改革时，限制了一些上市企业的部分股票上市流通的日期。也就是说，有许多企业的部分股票暂时是不能上市流通的。这就是非流通股（也叫限售股）。</p><p>其中的小部分就叫小非。大部分叫“大非”。解禁就是允许上 市流通。“大小非”解禁就是限售非流通股允许上市。</p><p>“小非”是指持股量在5%以下的非流通股东所持股份，这就是“小非”的由来。与“小非”相对应，“大非”则是指持股量5%以上非流通股东所持股份。</p><p>大小非解禁减持将给市场带来急剧的扩容压力，使流通股股东的信心受挫，股价不断下跌。</p><p>大小非减持：非流通股可以流通后，会有股东抛售套现，就叫减持。因为大非一般都是企业的大股东，战略投入者，一般不会抛，小非则是许多年的不流通，一但流通，又有很大获利，很多都会套现</p><p>@ref: <a href="https://baike.eastmoney.com/item/%e5%a4%a7%e5%b0%8f%e9%9d%9e%e8%a7%a3%e7%a6%81" target="_blank" rel="noopener">https://baike.eastmoney.com/item/%e5%a4%a7%e5%b0%8f%e9%9d%9e%e8%a7%a3%e7%a6%81</a></p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F13.股市101</title>
      <link href="/52.Financing/F13.%E8%82%A1%E5%B8%82101/"/>
      <url>/52.Financing/F13.%E8%82%A1%E5%B8%82101/</url>
      
        <content type="html"><![CDATA[<p>@tag: #入门101</p><h2 id="一级市场、二级市场"><a href="#一级市场、二级市场" class="headerlink" title="一级市场、二级市场"></a>一级市场、二级市场</h2><ul><li>一级市场(发行市场): 公司上市需要证监会批准, 根据公司净值定发行价, 股民投资者可以从证券公司申购, 申购成功则以发行价买入 (券商=&gt;投资者)</li><li>二级市场(交易市场): 在上述过程之后，公司到二级市场(也即证券交易市场, 故二级市场是’场内’)上市流通, 股民之间的转手/交易</li></ul><h2 id="融资-融券"><a href="#融资-融券" class="headerlink" title="融资/融券"></a>融资/融券</h2><ul><li><a href="https://www.zhihu.com/question/20763639/answer/2367194502" target="_blank" rel="noopener">融资融券账户与普通账户相比有哪些区别和限制？（除了融资融券的特性以外） - 双牛做的木子星 的回答 - 知乎</a></li><li><a href="https://xueqiu.com/7410397739/115067709" target="_blank" rel="noopener">图文说明：融资（做多）与融券（做空）- 雪球</a></li></ul><p>两融余额: 融资-融券的差值，如果上涨意味着市场看多（融资余额↑ 或者 融券余额↓） // 一般融资绝对大于融券一个数量级，如果反映短期市场的多空情绪，也可以比较二者增速差</p><h2 id="公募-私募"><a href="#公募-私募" class="headerlink" title="公募/私募"></a>公募/私募</h2><p>公募又称公开发行，是指发行人通过中介机构向不特定的社会公众广泛地发售证券，通过公开营销等方式向没有特定限制的对象募集资金的业务模式。为适应更广大投入者的需求，公募没有合同份数和起点金额的限制。因为涉及众多中小投入人的利益，监管当局对公募资金的使用方向、信息披露内容、危机防范要求都非常高。而私募是面向少量的、特定的投入者募集资金的方式。参加人一般应具备一定的经济实力、危机识别和危机承担能力。</p><h2 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h2><p>开盘前，不需要按照时间优先和价格优先的原则交易，而是按最大成交量的原则来定出股票的开盘价，</p><p>使它同时能满足以下3个条件：</p><ul><li>成交量最大。</li><li>高于基准价格的买入申报和低于基准价格的卖出申报全部满足（成交）。</li><li>与基准价格相同的买卖双方中有一方申报全部满足（成交）。</li></ul><h2 id="对冲"><a href="#对冲" class="headerlink" title="对冲"></a>对冲</h2><ul><li>对冲: 一般对冲是同时进行两笔行情相关、方向相反、数量相当、盈亏相抵的交易</li><li>对冲基金 <a href="https://wiki.mbalib.com/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91" target="_blank" rel="noopener">https://wiki.mbalib.com/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91</a></li></ul><h2 id="做空"><a href="#做空" class="headerlink" title="做空"></a>做空</h2><p>可以做空的品种包括股票、股指期货、某国货币</p><blockquote><p>股票市场是通过融资融券“做空”的，融券卖出，即借来股票现值卖掉，等待价格下跌，再以低价买回股票归还，实现差价收益。<br>实际操作中，做空是先借入标的资产（有专门出借方如证券公司），然后卖出获得现金，这段时间内如果标的资产价格下跌，再以低价买入标的等量资产归还(证券公司), 获取差价利润<br>为什么出借方愿意出借标的的资产呢？通常出借方出借资产的利率是远高于贷款利率的，而且会不断浮动（根据市场情绪及下跌的可能性浮动，下跌可能性大，利率高；下跌可能性小，利率低），因此如果资产价格没有下跌，出借方就可以获得远超市场利率的收益，这也是出借方愿意出借的原因。</p></blockquote><ul><li><a href="https://www.zhihu.com/question/303151833/answer/1239497921" target="_blank" rel="noopener">什么是“做空”？“做空”是如何赚钱的？ - 飞翔的勇士的回答 - 知乎</a></li><li><a href="https://www.zhitongcaijing.com/content/detail/56980.html" target="_blank" rel="noopener">详解港股做空机制之一：做空到底怎么玩?</a></li><li>索罗斯做空英镑： <a href="/52.Financing/F18.金融大事记/" title="F18.金融大事记">F18.金融大事记</a></li><li>索罗斯做空港元：<a href="/52.Financing/F18.金融大事记/" title="F18.金融大事记">F18.金融大事记</a></li></ul><p>做空失败的案例:</p><ul><li><a href="https://xw.qq.com/cmsid/20210128A0F0SW00?f=newdc" target="_blank" rel="noopener">游戏驿站GameStop是做什么的？机构为何做空它？为何遭到散户毒打？|游戏|gamestop</a></li><li><a href="https://www.youtube.com/watch?v=KIe1MyD1m_o" target="_blank" rel="noopener">李永乐：游戏驿站GME股票为何暴涨？美国散户如何血洗华尔街？ - YouTube</a></li><li><a href="https://zhuanlan.zhihu.com/p/374931559" target="_blank" rel="noopener">Gamestop 美国散户逼空机构的“华尔街暴徒”事件是怎么一回事儿？ - 知乎</a></li></ul><h2 id="爆仓、平仓"><a href="#爆仓、平仓" class="headerlink" title="爆仓、平仓"></a>爆仓、平仓</h2><ul><li>爆仓：期货市场 or 有融资情况下的股市，当市场行情发生较大变化时，如果投资者保证金账户中资金的绝大部分都被交易保证金占用，而且交易方向又与市场走势相反时，由于保证金交易的杠杆效应，就很容易出现爆仓。//@ref : <a href="https://www.sohu.com/a/311450813_104543" target="_blank" rel="noopener">股市里的“爆仓”是什么意思？_股票</a></li><li>平仓: 可分为对冲平仓和强制平仓。<ul><li>对冲平仓是期货投入企业在同一期货交易所内通过买入卖出相同交割月份的期货合约，用以了结先前卖出或买入的期货合约。</li><li>强制平仓是指仓位持有者以外的第三人(期货交易所或期货经纪企业)强行了结仓位持有者的仓位，又称被斩仓或被砍仓。</li></ul></li></ul><p>在期货交易中发生强行平仓的原因较多，譬如客户未及时追加交易保证金、违反交易头寸限制等违规行为、政策或交易规则临时发生变化等。而在规范的期货市场上，最为常见的当属因客户交易保证金不足而发生的强行平仓。具体而言，是指在客户持仓合约所需的交易保证金不足，而其又未能按照期货企业的通知及时追加相应保证金或者主动减仓，且市场行情仍朝持仓不利的方向进展时，期货企业为避免损失扩大而强行平掉客户部分或者全部仓位，将所得资金填补保证金缺口的行为。</p><h2 id="ROE"><a href="#ROE" class="headerlink" title="ROE"></a>ROE</h2><p>净资产收益率 (Return on equity):</p><p><em>净资产收益率</em>又称股东权益报酬率/净值报酬率/权益报酬率/权益利润率/净资产利润率，它表明一家公司对股东投入的资本管理得有多好。</p><p>$$ ROE = 税后盈余/ 股东权益 $$</p><ul><li>税后盈余： 也称税后净利，就是公司本期赚的获利，税后盈余/股数就等于EPS每股盈余</li><li>股东权益（Shareholders Equity）： 总资产扣除负债，代表还完负债后公司的净值。最主要是股本+保留盈余+资本公积(初始股东出的钱加上保留在公司的获利或股本)</li></ul><h2 id="PB、PE"><a href="#PB、PE" class="headerlink" title="PB、PE"></a>PB、PE</h2><ul><li>PB(市净率)： <code>总市值/净资产</code> , PB越高，表示股票被高估</li><li>PE(市盈率)： <code>总市值/净利润</code>, PE越高, 表示盈利能力越低,  “比如股价50元，每股收益2元，pe就是25倍，你需要25年收回投资”，所以pe是用来评估股票价格贵不贵的主要指标。</li></ul><blockquote><p>净资产简单的理解是总资产减去总负债得出净资产。若是要再严格要求，则可以考虑总资产减去总负债的基础上再减去无形资产。因为无形资产这东西估值多少，很多时候全凭企业说了算,市净率更适合用于重资产而言。那么重资产行业有哪些？核心包括资金型的行业，比如，银行，券商，房地产等。</p></blockquote><p>市盈率根据采样周期的不同, 还分为:</p><ul><li>静态PE: <code>当前总市值/过去一年</code></li><li>动态PE:  <code>当前总市值/上季度盈利*4</code> = <code>当前总市值/上半年盈利*2</code></li><li>PE-TTM(滚动PE)，代表滚动市盈率的意思，它会运用最新的(最近四个季度的窗口)净利润指标，使得市盈率的值更有时效性。<ul><li>蛋卷 &amp; 支付宝等都是用的滚动，天天、蛋卷、支付宝都是PE-TTM，但为什么和中证指数公司的不一样？ // 中证的去掉了亏损 @ref: <a href="https://zhuanlan.zhihu.com/p/74414529" target="_blank" rel="noopener">哪里的PE估值比较准？ - 知乎</a></li></ul></li></ul><p>PB/PE百分位: 比当前值低的时间的百分比, 如果当前百分位很高, 意思是现在的PE/PB在历史上很高, 投资价值低</p><pre><code>* 一般情况下，当PE,PB百分位均低于30%时，就开始具备投资价值，当PE,PB百分位均高于80%时，考虑卖出。* Ref: [指数基金PE,PB百分位详解 - 知乎](https://zhuanlan.zhihu.com/p/109878408)* Ref: [投资指数基金不得不知的估值百分位](https://xueqiu.com/1468358080/126428641)</code></pre><p>如果不是计算一个公司的PE, 而是某个行业指数的PE, 还有两种情况:</p><ul><li>市值加权: 高市值公司有更大权重</li><li>等权: 无论市值大小相同权重, 避免PE收到大市值股票影响不能很好的反应市场整体的估值水平</li></ul><p>大盘PE vs 成长PE：</p><ul><li>宽基价值指数（大盘、红利）的PE估值范围：<ul><li>🟩：0~9</li><li>🟨：10~16</li><li>🟥：16+</li></ul></li><li>创业板的PE估值范围：<ul><li>🟩：0~50</li><li>🟨：50~64</li><li>🟥：64+</li></ul></li></ul><p>不同行业的PE：一般来说，宽基指数、周期性不强的（消费、医药）才适合用PE进行估值，钢铁、有色、银行证券、保险不适合使用PE作为估值标准。<br>以下行业不适用PE估值方法：</p><ul><li>1、强周期行业，如传统能源、有色、钢铁、原材料等行业，在景气周期顶点PE很低，却往往是可能需要卖出的时候；而景气低点盈利很少或者亏损，PE很高，最悲观的时候反而可能逐步迎来布局时机。所以强周期行业股票或指数基金主要靠判别周期进行投资，而不能用PE进行估值。</li><li>2、银行业，带有明显周期属性，不适用PE估值，常用PB（市净率）进行估值，一般在五大行PB达到0.7以下达到低估。</li><li>3、保险业，不适用PE估值，常用PEV（内含价值）估值，一个专属保险企业的估值方法。PEV=股价/EV，EV一般会在保险企业年报里公布。</li><li>4、证券行业，该行业具有明显的反身性，业绩波动巨大，股市越好，业绩越好，PE甚至PB可能越低；股市越差，业绩越差，PE甚至PB越高。不适用PE或PB估值，只能靠判断股市周期进行投资或进行右侧趋势投资。</li><li>5、房地产行业具有明显的周期特征，不适用PE估值。</li><li>6、正在攻城掠地的互联网企业，一般用PS（市销率）估值。</li><li>7、高科技企业在走向成功途中“每天都面临着破产”，也不适用PE估值</li></ul><p>更多有关PE参考=&gt;  [[../_attachments/你以为你真的搞懂了市盈率？.pdf]]</p><h2 id="PE-Band"><a href="#PE-Band" class="headerlink" title="PE Band"></a>PE Band</h2><p>X轴是时间，Y周左边是市盈率（PE）,右边是股价，</p><blockquote><p>上轨是将该股在一段时期所有最高的市盈率乘以每一个时点的每股收益计算对应的股价连接而成，<br>下轨则是将该股在一段时期所有最低的市盈率乘以每一个时点的每股收益计算对应的股价连接而成，</p></blockquote><p>中间几条轨线，是最高和最低PE二者求差值，再4等分，这样一共5条轨线</p><p>假设A公司历史最高PE = 40倍（黄色），最低13倍（粉色），得到5个PE：40x、33x 、27x..<br>把历史的EPS分别乘以上面5个PE，连起来形成5条线。<br>最上面一条虚拟股价线表示，“假如A公司一直都能保持40倍的估值，股价是多少”，</p><p>真实股价（红色）会触到最高的那条轨线，也即是那个时间产生了最高的PE，那个时候市场对A公司的预期达到最高</p><p><img src="/images/IMG20221003-1.png" alt="../_images/IMG20221003-1.png"></p><h2 id="PEG"><a href="#PEG" class="headerlink" title="PEG"></a>PEG</h2><p>G即Growth, 预估公司未来3~5年的<em>利润增长率</em></p><p>$$ PEG = PE/G $$</p><ul><li>PEG&gt; 1 表示企业被高估</li><li>PEG&lt; 1 表示企业被低估</li><li>美国投资大师彼得·林奇的努力下发扬光大，他曾指出，最理想的投资对象PEG应该小于0.5</li><li>PEG估值的适用对象是成长性公司或指数，这类公司的特点是利润增速很快，市盈率通常也高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F12.基金101</title>
      <link href="/52.Financing/F12.%E5%9F%BA%E9%87%91101/"/>
      <url>/52.Financing/F12.%E5%9F%BA%E9%87%91101/</url>
      
        <content type="html"><![CDATA[<p>@tag: #入门101 #基金</p><h1 id="基金分类"><a href="#基金分类" class="headerlink" title="基金分类"></a>基金分类</h1><p>➤ 主动/被动</p><ul><li>主动型基金: 基金经理通过自身分析（包括技术分析和基本面分析）来选股和择时以取得市场超额收益的一类基金</li><li>被动型基金（指数基金）: 被动的跟踪指数，复制指数的涨跌。</li></ul><p>➤ 场内/场外</p><ul><li>什么是场内基金？场内就是股票市场，也就是通常说的二级市场，场内基金就是通过证券账号购买的二级市场基金，它没有申购赎回费，只有券商的佣金费，一般现在都在万1.5到万5之间<ul><li>场内基金是在证券交易所内买卖的基金，所以需要有股票账户才能买卖，我们通常说的ETF就是场内基金的典型代表。除了ETF，场内还可以买LOF和封闭式基金，需要注意的一点是，场内基金不可以做基金定投（不能自动扣款，需手动扣款），也不能转换。</li></ul></li><li>什么是场外基金？场外基金就是指在银行、基金公司或者天天基金网、蚂蚁财富等第三方平台上购买基金，有申购/赎回费。</li><li>场内基金的投资特点是以份额定金额，而场外刚好相反，是以金额定份额。场内基金一般不提供定投</li></ul><p>场内vs场外:</p><ul><li>分红方式不同。场外基金分红有现金分红和红利再投资两种方式。场内基金的分红方式只有现金分红，不能红利再投资。</li><li>交易费用：<ul><li>参考 =&gt; [[#购买基金的费用]]</li><li>现在的券商佣金公开就是万分之三（3‱）的佣金，很多已经低至万分之一（1‱），ETF一买一卖，也就是万分之二（2‱）的费用。 也就是说，你买进￥1W的ETF，再卖出，总的费用也就￥2 // 上面提到的万一佣金: @ref: <a href="https://www.zhihu.com/question/416537872/answer/2259935154" target="_blank" rel="noopener">万一手续费的券商有哪些？看到有些大V在推万一的券商，到底可靠不？ - 知乎</a></li><li>而场外ETF联接基金定投申购费是1.2%，通常打一折，就是0.12%，也就是万分之十二（12‱）。 同样的￥1W买成ETF联接基金，光申购费就要￥12  </li><li>场内ETF的买入卖出一共也就 2‱ 的费用，而场外的ETF联接基金单是买入就要 12‱，赎回还要等两年后才能免赎回费，期间赎回的份额，持有不足7天，赎回费要1.5%，￥1W就要￥150，7天以上一年以内的持有期，要0.5%的赎回费（￥50），一年以上两年以内要0.25%（￥25）。  </li></ul></li><li>便利程度：<ul><li>场外ETF联接基金，由于定投起来操作傻瓜化，申购时间24小时无休，也比较受投资者的欢迎。  </li><li>场内ETF对交易时间有要求，比如只能是在交易日的盘中进行交易，上午下午各两小时。其他时间都是休市，无法交易。</li></ul></li></ul><p>➤ <a href="https://mp.weixin.qq.com/s/bSST74cSVSqOJRMbE_j8-A" target="_blank" rel="noopener">再论科学的基金分类- 微积分量化价投</a>：<br><img src="/images/IMG20220930.png" alt=""></p><h2 id="ETF-amp-LOF"><a href="#ETF-amp-LOF" class="headerlink" title="ETF &amp; LOF"></a>ETF &amp; LOF</h2><p>以下参考 <a href="https://www.zhihu.com/question/30549213/answer/1023907763" target="_blank" rel="noopener">分别区分一下ETF，开放式基金，封闭式基金，LOF基金, 分级基金都是些啥，有何异同点？ - 知乎</a></p><p>关于ETF基金, ETF又称“交易型开放式指数证券投资基金”(Exchange Traded Fund的缩写)，简称“交易型开放式指数基金”，又称“交易所交易基金”。<br>ETF的一个特点是’跟踪指数’, 可以是: 宽指 / 行业指数(消费,能源,医药,金融) / 主题指数(人工智能,5G,元宇宙) / 策略指数(成长型,价值型)  @link <a href="/52.Financing/F32.ETF产品索引/" title="F32.ETF产品索引">F32.ETF产品索引</a></p><p>区分 ‘ETF基金’ 和 ‘ETF连接基金’ :</p><ul><li>场内(二级市场): 交易的是’ETF基金’, 需要有’证券账户’才可以交易, 一般场内的没有定投功能</li><li>场外, 交易的是’ETF连接基金’, 需要在银行/券商/三方销售开’基金账户’购买, 一般提供定投功能</li></ul><p>LOF基金，英文全称是“Listed Open-Ended Fund”,汉语称为“上市型开放式基金”英语缩写为LOF。也就是上市型开放式基金发行结束后,投资者既可以在指定网点申购与赎回基金份额,也可以在交易所买卖该基金。</p><ul><li>上市开放式基金本质上仍是开放式基金，基金份额总额不固定，基金份额可以在基金合同约定的时间和场所申购、赎回。</li><li>上市开放式基金获准在证交所上市交易后，投资者既可以选择在银行等代销机构按当日收市的基金份额净值申购、赎回基金份额，也可以选择在证交所各会员证券营业部按撮合成交价买卖基金份额。基金在银行等代销机构的申购、赎回操作程序与普通开放式基金相同。上市开放式基金在证交所的交易方式和程序则与封闭式基金基本一致。</li></ul><p>ETF vs LOF:</p><ul><li>ETF是指数基金, 基金经理很少干预, LOF可能是指数, 也可能是主动</li><li>都可以在场内/外购买:</li><li>ETF可以在场内(股票市场)和场外(银行/券商/三方销售)购买,<ul><li>场内的叫ETF基金, 场外的叫ETF连接基金, 购买’ETF连接基金’实际类似从代购手里购买的.</li></ul></li><li>LOF同上同时可以在场内/场外购买, 且在场外购买LOF不需要”代购”, 所以 LOF在购买场所上比ETF更方便</li></ul><h2 id="封闭基金-vs-开放基金"><a href="#封闭基金-vs-开放基金" class="headerlink" title="封闭基金 vs 开放基金"></a>封闭基金 vs 开放基金</h2><ul><li><a href="https://wiki.mbalib.com/wiki/%E5%BC%80%E6%94%BE%E5%BC%8F%E5%9F%BA%E9%87%91" target="_blank" rel="noopener">开放式基金</a></li><li><a href="https://wiki.mbalib.com/wiki/%E5%B0%81%E9%97%AD%E5%BC%8F%E5%9F%BA%E9%87%91" target="_blank" rel="noopener">封闭式基金</a><ul><li>封闭式基金(Closed-end Funds),是指基金发行总额和发行期在设立时已确定，在发行完毕后的规定期限内发行总额固定不变的证券投资基金。封闭式基金的典型特征之一就是有一定的封闭期限，在这个期限内，虽然不能申购赎回，但是由于封闭式基金可以像普通上市公司的股票一样在证券交易市场挂牌交易，你便可以通过二级市场买卖封闭式基金</li><li>在封闭期内，就可以避免散户投资者陷入追涨杀跌的困境，避免由于二级市场的波动，而影响散户投资者的投资信心和策略。</li></ul></li></ul><h1 id="如何选基"><a href="#如何选基" class="headerlink" title="如何选基"></a>如何选基</h1><p>@ref:</p><ul><li><a href="https://xueqiu.com/3179670287/216260490" target="_blank" rel="noopener">三步选基：一种简单、方便、有效的基金选择方法 - 雪球</a></li><li><a href="https://zhuanlan.zhihu.com/p/152610715" target="_blank" rel="noopener">史上最便捷“4433”选基法了解一下？ - 知乎</a></li><li><a href="https://sspai.com/post/66816" target="_blank" rel="noopener">如何选择一支好基金 05 | 掌握了这 9 个数学概念，选好基金不再难 - 少数派</a></li></ul><hr><p>➤ 根据收益成绩选基金:</p><ul><li>第一步：选择长期业绩优秀的基金<ul><li>从十年业绩排行榜中找出所有十年年化回报超过20%的基金</li><li>从五年业绩排行榜中找出所有五年年化回报超过25%的基金</li></ul></li><li>第二步：匹配长期业绩优秀的基金经理<ul><li>从十年年化回报超过20%的基金中，筛选出现任基金经理任职天数超过6年的基金</li><li>从五年年化回报超过25%的基金中，筛选出现任基金经理任职天数超过3年的基金</li></ul></li><li>第三步、建立备选优秀基金池<ul><li>排行榜业绩期限和任职天数匹配度一致的基金</li><li>选择业绩期限内回报最好的（各）三只基金</li><li>选择现任基金经理任职回报最高的基金</li><li>选择行业基金</li><li>选择最大回撤小的基金</li><li>优中选优基金：本节前面5种选择方案中入选3次以上的基金</li></ul></li></ul><blockquote><p>4333选基：</p><ul><li>业绩筛选条件：最近2、3、5年前1/4，最近1年前1/4，最近6个月前1/3，最近3个月前1/3</li><li>问题：短期业绩高也会拉高长期业绩，还要看基金经理管理时间</li></ul></blockquote><hr><p>➤ 指数基金 &amp; 主动基金选择指标：</p><ul><li>基金公司: 晨星5基金最多的公司</li><li>基金规模: 2亿以上的(一般建议规模在10~100亿), 绝对不要选择5000万以下或者超过100亿</li><li>晨星评级: 排除差的, 3星or以下不考虑 // 同类基金中前10%是五星，前10%~32.5%是四星</li><li>整个周期历史业绩, 贯穿牛市和熊市</li><li>持有人结构:  机构/内部/个人<ul><li>基金经理本人也持有自己管理的基金，对于基金而言是绝对的加分项</li><li>管理人从业人员，指的是基金公司中的工作人员</li><li>机构投资者的占比也值得考察</li></ul></li><li>基金购买费用: 管理/运作/托管费</li><li>基金指标: 大盘和行业ETF不用过多考虑夏普率、最大回撤等等，看PE、ROE即可<ul><li>最大回撤率:</li><li>标准差: 用来衡量过去一段时间内基金的波动大小。数字越小，则基金的波动就越小，收益曲线就越平稳</li><li>夏普比率: 高于1,越高越好(2的很少) // <code>夏普比率 = (基金报酬率– 无风险利率)/标准差</code></li><li>R平方</li><li>阿尔法系数, 贝塔系数 <a href="https://sspai.com/post/66816" target="_blank" rel="noopener">https://sspai.com/post/66816</a></li></ul></li></ul><h1 id="从十年赌约看指数基金"><a href="#从十年赌约看指数基金" class="headerlink" title="从十年赌约看指数基金"></a>从十年赌约看指数基金</h1><blockquote><p>2007年12月的一天，一个叫Protege Partners的对冲基金给巴菲特打来电话，他们提出了一个有趣的想法：一个十年的赌约。巴菲特坚信战胜指数是一个几乎不可能的任务，而Protege partners认为专业的对冲基金能够战胜市场。于是他们在美国的Long Bet网站上定下来十年赌约，巴菲特选择标普500指数，Protege Parterns选择五家对冲基金的基金（FOF）。赌注100万美元。</p></blockquote><p><strong>市场有效假说</strong>理论认为，在法律健全、功能良好、透明度高、充分竞争的股票市场，一切有价值的信息已经及时、准确、充分地反映在股价走势里，其中包括企业当前和未来的价值，除非存在市场操纵，否则投资者不可能通过分析以往价格获得高于市场平均水平的超额收益。</p><p>结论：如果市场有效，倾向于选指数基金，获取市场平均收益（β收益）且费率低；如果市场无效，也可以选主动基金，因为它可以带来超额收益（α收益）。</p><h1 id="买入策略（定投）"><a href="#买入策略（定投）" class="headerlink" title="买入策略（定投）"></a>买入策略（定投）</h1><p>1）慧定投:</p><ul><li>不过截至2019年5月，支付宝的慧定投，只能参考沪深300、中证500、创业板这三个主要宽基指数的历史数据。这个缺陷并不难解决，后续如果支付宝了解更多的细分指数基金品种，增加对应指数的历史数据和均线选择即可。</li></ul><blockquote><p>【整理】支付宝使用的智能定投是如何计算定投金额的:</p><ul><li>(1)均线模式, 参考500日内的均线计算出扣款率(60%~210%), <code>实际定投价格=基础定投金额x扣款率</code> ;<ul><li>银河创新成长: 参考创业板指, 500日均线;</li><li>中欧医疗健康: 参考创业板指, 500日均线;</li><li>中证红利ETF: 参考中证500, 180日均线;</li><li>汇添富消费: 参考创业板指, 500日均线;</li></ul></li><li>(2)估值模式: PE百分位<ul><li>华宝券商ETF: 按中证券商指数的PE百分位</li><li>易方达上证50增强: 指数不明, PE百分位</li></ul></li></ul></blockquote><p>2）价值平均策略</p><ul><li>比如说，设定的目标是：保证让手里的指数基金市值，每个月增长1000元。</li><li>不过这种策略也有一个缺点：如果遇到股市大跌，需要短期内拿出比较多的资金来补仓。</li><li>从1926年到2006年，如果用定期定额的定投方法，年化收益率大约是10.85%。而如果用价值平均策略来定投，年化收益率大约是12.39%。平均每年有1.54%的超额收益</li></ul><p>3）基于均线</p><ul><li>参考均线，当价格低于均线的时候多买一点，当价格高于均线的时候少买一点，实现低买高卖。</li></ul><p>4）基于估值：</p><ul><li>PE的倒数 = E/P = 盈利收益率</li><li>每月定投金额 = $$ 首次低估时的定投金额 * (当月EP/首次定投时EP)^n $$</li><li>其中 n是放大器， 可以取1、2</li><li>缺点： 比如说2008年金融危机时，美股标普500指数中很多公司的盈利大幅下滑。但是标500指数因为公司盈利下滑，导致市盈率反而被动提升到了八九十倍。这就是短期原因导致的市盈率失效。</li></ul><p>比较ETF网格交易策略, 相同点是股价越高买的越少,<br>这种方法的不便之处: 用PE计算系数是有些麻烦的(每月定投的时候算一次),<br>上面还是每月固定时间的定投, ETF网格则不固定间隔, 一旦股价碰到网格即触发, 然后这两个方法的上下限选择不同: 网格是选一高一低两个价格作为标的, 这里的定投是以PE高低为标的</p><blockquote><p>关于 盈利收益率：<br><a href="https://xueqiu.com/1979859041/130030216" target="_blank" rel="noopener">指数投资进阶利器——盈利收益率＆博格公式</a></p></blockquote><h1 id="止盈策略"><a href="#止盈策略" class="headerlink" title="止盈策略"></a>止盈策略</h1><ul><li>目标收益率止盈：一般是30%止盈，为什么是30%？ 每个可转债的上限都是130%吗？</li><li>估值止盈：<ul><li>如果是一个指数基金，可以用PE估值</li><li>或者通过股债收益差/格雷厄姆指数/证券化率..等等判断整个大盘的状态： <a href="/52.Financing/F23b.市场估值指标/" title="F23b.市场估值指标">F23b.市场估值指标</a></li></ul></li><li>回撤止盈法：就是比如你现在收益率40%，但是不知道卖不卖。利用回撤止盈法，这时就可以随便躺着等回调。设置一个比如回调10%时候止盈。</li><li>外围情绪止盈法</li><li>技术指标止盈法：量价背离、MACD顶背离、MACD死叉、布林带触碰上轨压力位、长上影线、高位破位大阴线、向上跳空高开等等的适合中短线 <a href="/52.Financing/F41.K线图及指标/" title="F41.K线图及指标">F41.K线图及指标</a></li></ul><p>@ref：<a href="https://www.zhihu.com/question/28930738/answer/1334772730" target="_blank" rel="noopener">如果做基金定投的话，什么时候应该卖出呢？ - TopView 的回答 - 知乎</a></p><h1 id="主动基金的风格"><a href="#主动基金的风格" class="headerlink" title="主动基金的风格"></a>主动基金的风格</h1><ul><li>先从股票的风格说起：从“成长-价值”、“小盘-大盘”两个维度衡量，构成一个四宫格，四种不同风格的个股</li><li>市场风格的形成：牛市时，资金对某个赛道看好而开始抱团，但熊市时往往容易分歧</li><li>基金的风格：根据重仓股的风格构成基金风格，晨星用的是九宫格“晨星风格箱”</li></ul><p><img src="/images/20220505161105.png" alt="基金-价值vs成长"></p><p><a href="https://xueqiu.com/8687456694/217239110" target="_blank" rel="noopener">5种“基金风格”，哪个最适合A股？ - 雪球</a></p><ul><li>1、价值风格：通常用企业未来现金流的折现值来估算。因此，能比较容易和比较准确估算出来内在价值的企业，通常商业模式都比较简单易懂，盈利比较稳定，赚多赚少都在可预计的范围内，几乎没有大爆发的可能。价值风格的基金持仓以低估值的股票为主，强调安全边际。持有的行业通常有2种（周期股: 化工、煤炭、钢铁）和（传统行业：银行、地产、基建、轻工业、纺织业）。价值风格基金经理，基本不做宏观经济和行情走势的判断，不在意行业景气度；更看重股价是否足够便宜，企业是否具有竞争力。更看重安全边际和确定性</li><li>2、成长风格：成长股一定是处于未成熟的阶段，行业有着巨大的成长空间。成长风格基金经理极度看重企业和行业“未来发展空间”和“业绩增速”，其次看企业在同业中的竞争力。他们对估值的容忍度较高，宁愿买贵，也不愿意错过成长爆发期；他们不太控制回撤和波动，更专注于挖掘导入期和成长期的行业和个股。</li><li>3、价值成长风格：“价值成长风格”的投资者更看重企业的基本面，致力于投资他们所认为的真正的好公司（有护城河、商业模式好、有现金流等等）“价值成长风格”基金经理更加看重企业的“盈利能力”和“现金流”的持续性。重视ROE、自由现金流这2个财务指标，持仓以垄断性强、品牌力强的行业龙头为主。“价值成长风格”投资者认为：买入优秀的企业，最重要的价值就是“赚取复利”，只有好的公司才能通过持续增长提供这种复利</li><li>4、均衡风格：均衡风格一般主要是指“行业的分散均衡”，而极致一点的均衡风格基金，还会做到风格（成长、价值），股票市值（大盘、小盘）的均衡。均衡风格基金经理，非常在意“风险控制”，因此，他们基金的最大回撤&amp;波动率相对更低。基金业绩表现特征为：中短期的业绩不是最突出的，但是长期来看业绩往往很不错。因此均衡风格基金持有体验相对较好，比较适合普通投资者做底仓基金。</li><li>5、趋势风格：行业趋势投资者擅长根据宏观环境，政策、市场变化、行业景气度、行业周期、市场情绪等变化，优选他们认为的“最强”行业。他们的持仓不限行业，不限风格，重在选择“当前阶段，业绩增速最快”的行业和企业，只看该行业有没有政策支撑或经济逻辑支撑</li></ul><blockquote><p>“价值成长风格”又叫做“GARP”，即：Growth at reasonable price，用合理的价格买入有成长性的好公司 （巴菲特）</p></blockquote><h1 id="基金的费用"><a href="#基金的费用" class="headerlink" title="基金的费用"></a>基金的费用</h1><p>@ref: <a href="https://zhuanlan.zhihu.com/p/67508213" target="_blank" rel="noopener">理财省钱：基金费用是怎么算的 - 知乎</a></p><p>购买基金的费用构成:<br><img src="/images/20220407210219.png" alt=""></p><blockquote><p>Example: 假定小明计划今年投入10万元配置股票基金，持仓时间为一年，到期赎回。下面分别是基金三方销售机构推荐的A基金产品和某银行推荐的B基金产品，两只产品为同一类型基金产品。<br><img src="/images/20220407210310.png" alt=""></p></blockquote><h1 id="基金的收益-amp-分红如何计算"><a href="#基金的收益-amp-分红如何计算" class="headerlink" title="基金的收益 &amp; 分红如何计算"></a>基金的收益 &amp; 分红如何计算</h1><p>基金成立以来的收益率 =<code>（现在的净值 - 成立时净值）/1×100%</code></p><p>假设我在10月19日下午3：00前用1万元买入农银新能源主题基金，当天单位净值是2.1048，申购费率是0.15%；<br>在11月2日下午三点前赎回农银新能源主题基金，当天单位净值为2.198，赎回费率为0.75%。</p><ul><li>申购手续费＝10000.00×0.15％＝15 (元)</li><li>申购份额＝(10000.00－15)÷2.1048＝4743.919(份)</li><li>赎回总额＝4743.919×2.198＝10427.13(元)</li><li>赎回手续费＝10427.13×0.75%＝78.2(元)</li><li>赎回净额＝10427.13－78.2＝10348.93(元)</li><li>净收益＝10348.93－10000.00＝348.93(元)</li><li>所以，在我投资的11天里头，我一共赚到了348.93元。</li></ul><p>@ref:</p><ul><li><a href="https://www.zhihu.com/question/22971046/answer/1560030633" target="_blank" rel="noopener">基金的收益是怎么计算的？ - 知乎</a></li><li><a href="https://leetcode-cn.com/circle/article/kvwd0R/" target="_blank" rel="noopener">量化交易入门指南 - 力扣（LeetCode）</a></li></ul><p>➤ 基金分红: 基金分红后，单位净值里要扣除分红的部分。假设A、B两只基金成立时间完全相同，都是刚成立1年，当下的单位净值也相同，都是2元，基金A这一年中有分红，而基金B没有分红，那么，有分红的基金A显然业绩要好于未分红的基金B。</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzkyOTA4MA==&amp;mid=2247483811&amp;idx=1&amp;sn=8719e72d811042fddac5e8656704c7cf&amp;" target="_blank" rel="noopener">基金分红一文搞懂</a></li><li><a href="https://xueqiu.com/7245734636/164289613" target="_blank" rel="noopener">股票分红还要除权，那分红还有意义吗？ 欢迎关注公众号：大马哈投资 - 雪球</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F11.理财101</title>
      <link href="/52.Financing/F11.%E7%90%86%E8%B4%A2101/"/>
      <url>/52.Financing/F11.%E7%90%86%E8%B4%A2101/</url>
      
        <content type="html"><![CDATA[<p>@tag: #入门101</p><h1 id="资产配置方法"><a href="#资产配置方法" class="headerlink" title="资产配置方法"></a>资产配置方法</h1><p>➤ 大类资产配置：根据经济的周期性（普林格 or 美林时钟）配置不同时期的资产 @ref: <a href="/52.Financing/F21.经济的周期性/" title="F21.经济的周期性">F21.经济的周期性</a></p><ul><li><a href="https://mp.weixin.qq.com/s/fbfyRfnFb8RXsVVN0bKeMg" target="_blank" rel="noopener">美国滞胀预期与股债双杀的演变</a>公众号新全球资产配置很久没更新了</li></ul><p>➤ 股债比例如何配置：</p><ul><li>根据市场估值： =&gt; <a href="/52.Financing/F23b.市场估值指标/" title="F23b.市场估值指标">F23b.市场估值指标</a></li><li>100-年龄</li><li>偏债基金的“核心+卫星”：核心（比例70-80%）包括成长、价值、均衡等多元布局，卫星包括医药、消费、制造、科技等赛道 @ref: 蚂蚁金选建议的配置 <a href="https://zhuanlan.zhihu.com/p/523676715" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/523676715</a></li><li>股债再平衡：<a href="https://xueqiu.com/2356382715/182672654" target="_blank" rel="noopener">股债动态再平衡增厚长期收益是真的吗？ - 雪球</a></li><li>从凯利公式看仓位配置： <a href="/52.Financing/F59.凯利公式/" title="F59.凯利公式">F59.凯利公式</a></li></ul><p>➤ 增量部分如何分配：《小狗钱钱》- 吉娅是“把50%的收入变成我的‘鹅’，40%放入梦想储蓄罐，剩下的10%用来花。”  </p><blockquote><p>ref: <a href="https://zhuanlan.zhihu.com/p/256911126" target="_blank" rel="noopener">积累财务自由的第一桶金 - 尼基的梦 -知乎</a> 提到的更简单的分配方式<code>x + ½ +½</code>，适用于不知道该如何分配的入门玩家：<br>x + ½ +½ = 必要支出+消费基金+投资基金 = 基本生活费+梦想储蓄+金鹅</p></blockquote><p>➤ 目前我用的家庭资产配置（只涉及存量部分，增量不考虑）：<br><img src="/images/IMG20221005.png" alt=""></p><ol><li>用于应急：活期（货币基金-余额宝这类T+0产品），不按家庭资产的百分比计算，取值为大约2-3个月生活费开销，或 4-5w（取高的那一个）</li><li>用于未来消费：这部分是未来可能消费掉的钱(车房首付/旅游/教育/全家保费)，主要是固收类、稳健类，可以选风险等级 R2-R3的银行理财，ps不要选久期太长的，除非你精确知道什么时候要花这部分钱；</li><li>用于增值的部分：“金鹅”，生钱的钱，投资的钱，主要基金/股票，根据当前风险做股/债的平衡（我用万得全A指数的股债收益差，例如 股债收益差百分位到70%，意味着需要调整偏股:偏债 =7:3 ），对于偏股的部分遵循核心:卫星=7:3的比例（也就是混合类基金占7，行业基金占3。对于行业基金，如果你也不知道现在什么行业是赛道，还是每个行业均分）。<br>对于核心部分，主要主动混合基金，也不都买一个基，按风格做平衡（成长和价值风，大盘和小盘风）<br>此外我在场内有一部分做行业ETF轮动（实验性质，比例不大）</li><li>上面是存量部分，增量部分也用 x + ½ +½，最后那个½需要做了股债平衡，还是参考上面的股债收益差</li></ol><blockquote><p>关于“标普家庭资产配置”：<br> <a href="https://www.zhihu.com/question/25398320" target="_blank" rel="noopener">请问《标准普尔家庭资产象限图》出处在哪里？ - 知乎</a>  ： 结论：大概率是国内保险公司搞出来的概念😆<br> 20%的资产用于买保险emmm….另外短期消费的钱也不合理，这部分应该按金额而不是按比例，生钱的钱这部分占比太低并且是静态的。以及里面提到的%占比也没说是增量or 存量（不考虑增量/存量，这是个大问题）</p></blockquote><blockquote><p>附图-标普家庭资产配置：<img src="/images/标普家庭资产配置.png" alt=""></p></blockquote><h1 id="可投资的金融产品"><a href="#可投资的金融产品" class="headerlink" title="可投资的金融产品"></a>可投资的金融产品</h1><p>参考=&gt; <a href="/52.Financing/F30.可投资的金融产品Index/" title="F30.可投资的金融产品Index">F30.可投资的金融产品Index</a></p><h2 id="银行理财风险等级-R1-R5"><a href="#银行理财风险等级-R1-R5" class="headerlink" title="银行理财风险等级(R1~R5)"></a>银行理财风险等级(R1~R5)</h2><ul><li>R1型产品：代表产品余额宝。同风险等级的产品还有银行的 现金管理产品、储蓄 和 国债等。</li><li>R2型产品：代表产品是 多数的银行理财产品 和 部分债券基金。权益类投资（股票等）的比重不超过20%。</li><li>R3型产品：代表产品是 少部分银行理财产品 和 平衡型基金。这类产品中权益类投资的比重更高，在50%左右。所以亏损的概率更大，历史收益率也更高。</li><li>R4和R5型产品：代表产品是：偏股混合型基金（R4）、灵活配置型基金（R4）和股票型基金（R5），这类产品的权益类投资的比重分别不低于60%和80%，可能在较短的时间内出现较大的亏损。</li></ul><h1 id="七日年化-amp-万份收益"><a href="#七日年化-amp-万份收益" class="headerlink" title="七日年化&amp;万份收益"></a>七日年化&amp;万份收益</h1><p>理财产品的指标: 七日年化/年利率/年化收益率/万份收益</p><p>➤「七日年化收益率」:<br>如果按照最近七天的收益来算，存一年的话得到的收益<br>指将货币基金过去7天所获的总收益进行年化计算之后得出的数据。具体的操作方法是将7天的总收益率除以7，得到过去7天的平均日收益率，再乘上365天，得到七日年化收益率。</p><blockquote><p>90 天的理财产品, 银行称为年化收益4%, 买10w, 问所得利息?<br>实际只有1%的收益率</p></blockquote><ul><li>银行所公布的利率，都是年化利率, =一年的利息/本金, 月利率=年利率/12</li><li>半年期的年化利率是4%，但因为只存了半年，那么半年期的收益率就是2%，或者称半年化利率是2%，<br>不过一般不这么叫，还是称年化收益率是4%，因为银行的理财产品有不同的期限，如果只标出收益率的话，虽说计算起来比较方便，但不利于进行整体统一对比。</li></ul><p>➤ 每万份收益:<br>每一万份货币基金每天产生多少收益，即货币基金持有人每天能够真实得到的收益。<br>举个例子，假如某只货币基金的每万份收益是1元，就是说投资者持有1万份该货币基金，每天能够获取1元的收益，按单日年化其实就是3.65%;</p><h1 id="科学刷-信用-卡"><a href="#科学刷-信用-卡" class="headerlink" title="科学刷(信用)卡"></a>科学刷(信用)卡</h1><p>➤ 招商信用卡如何积分: @ref: <a href="https://zhuanlan.zhihu.com/p/409977265" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/409977265</a></p><ul><li>线下POS刷卡，按每20元1分给永久积分（超市、加油、医院等特殊类型商户或商户被招行拉黑的情况除外）；</li><li>支付宝，招行和支付宝有着非常深厚的PY关系，因此在支付宝用招行付款无脑有分，而且是永久积分，哪怕你在医院付款都有分</li><li>微信，默认情况下微信支付招行是一分不给的，只有每月领取积分资格后才给区区500！！！非永久积分！ 领取路径：掌上生活APP-右上角小招猫图像-我的客服，输入“微信支付领积分”</li><li>云闪付二维码被扫，包括云闪付APP、各个银行APP的付款码都属于这个范畴，注意是被扫，也就是你出示付款码，店员扫你。你主动扫店家的云闪付二维码是没分的</li></ul><p>➤ <a href="https://post.smzdm.com/p/ar675n9x/" target="_blank" rel="noopener">云闪付活动 云闪付大招_什么值得买</a></p><ul><li>云闪付可以把信用卡&amp;移动积分兑换成红包</li></ul><p>➤ 微信 &amp; 支付宝 哪些信用卡有积分: @ref: <a href="https://zhuanlan.zhihu.com/p/29685158" target="_blank" rel="noopener">收藏！微信、支付宝刷信用卡，快速撸积分的方法 - 知乎</a></p><ul><li>微信：有积分的信用卡格外少，只有中信的网购类联名信用卡、浦发信用卡以及兴业Pass卡才有积分。招行、农行等银行，用财付通支付是没有积分的。</li></ul><p>➤ POS机刷卡手续费:</p><ul><li>由 卡组织、发卡行、收单机构、商户合作完成支付的过程称为「四方模式」, 每一方都会收手续费.</li><li>收单机构主要为商户提供安装 POS 机、清算等服务，</li><li>银行卡组织，比如银联、VISA、MasterCard ，它们本身通常不发卡，主要是为成员银行提供信息交换、资金清算等服务。</li></ul><p>POS机刷卡手续费由发卡行服务费、银联网络服务费、收单服务费三部分组成，<br>对于标准类商户而言，信用卡刷卡费率 = 发卡行0.45%+银联清算费率0.065%+收单服务费(市场调节价，一般不低于0.085%) &lt;= 0.6%。</p><p>@ref: <a href="https://zhuanlan.zhihu.com/p/368370993" target="_blank" rel="noopener">最新pos机费率详解 - 知乎</a></p><p>➤ 信用卡分期:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/22920169" target="_blank" rel="noopener">信用卡账单分期的真实年化利率 - 知乎</a><ul><li>假设1.2w, 分12期, 月利率 0.66%,</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/41193293" target="_blank" rel="noopener">告诉你信用卡分期有多坑 - 知乎</a></li><li><a href="https://www.rong360.com/gl/2017/07/24/139745.html" target="_blank" rel="noopener">信用卡利息原来是这么计算的！<em>信用卡攻略</em>信用卡攻略 - 融360</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F10.经济学概念101</title>
      <link href="/52.Financing/F10.%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%A6%82%E5%BF%B5101/"/>
      <url>/52.Financing/F10.%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%A6%82%E5%BF%B5101/</url>
      
        <content type="html"><![CDATA[<p>@tag: #入门101 #宏观 #通胀</p><p>@todo：</p><ul><li>哈耶克vs凯恩斯：<a href="https://zhuanlan.zhihu.com/p/94305265" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94305265</a></li><li><a href="https://www.zhihu.com/question/21140863" target="_blank" rel="noopener">哈耶克与凯恩斯究竟谁对谁错？ - 知乎</a></li><li>IS-LM模型：<a href="https://baike.baidu.com/item/IS-LM%E6%A8%A1%E5%9E%8B/4738960" target="_blank" rel="noopener">https://baike.baidu.com/item/IS-LM%E6%A8%A1%E5%9E%8B/4738960</a></li><li><a href="https://www.zhihu.com/question/20105864" target="_blank" rel="noopener">边际成本是什么？ - 知乎</a></li><li><a href="https://wiki.mbalib.com/wiki/%E8%BE%B9%E9%99%85%E6%88%90%E6%9C%AC%E9%80%92%E5%87%8F" target="_blank" rel="noopener">边际成本递减 - MBA智库百科</a></li></ul><hr><p>宏观经济学是以国民经济总过程的活动为研究对象，着重考察和说明国民收入、就业水平、价格水平等经济总量是如何决定的、如何波动的，故又被称为总量分析或总量经济学。<br>宏观经济学以整个国民经济为考察对象，研究经济中各有关总量的决定及其变动，以解决失业、通货膨胀、经济波动、国际收支等问题，实现长期稳定的发展。// @ref： <a href="/52.Financing/F20.宏观经济框架/" title="F20.宏观经济框架">F20.宏观经济框架</a></p><p>微观经济学（Micro-economics）又称个体经济学，小经济学，是宏观经济学的对称。微观经济学主要以单个经济单位(单个的生产者、单个的消费者、单个市场的经济活动)作为研究对象，分析单个生产者如何将有限的资源分配在各种商品的生产上以取得最大的利润；单个消费者如何将有限的收入分配在各种商品的消费上以获得最大的满足。同时，微观经济学还分析单个生产者的产量、成本、使用的生产要素数量和利润如何确定；生产要素供应者的收入如何决定；单个商品的效用、供给量、需求量和价格如何确定等等。</p><h2 id="通胀（inflation）、滞胀（stagflation）"><a href="#通胀（inflation）、滞胀（stagflation）" class="headerlink" title="通胀（inflation）、滞胀（stagflation）"></a>通胀（inflation）、滞胀（stagflation）</h2><p><strong>通货膨胀</strong>是指一个经济体中各种商品和服务的总价格水平在一段时间内上升的速度。</p><p>什么导致通货膨胀？<br>我们可以相对轻松地定义通胀，但什么导致通胀的问题要复杂得多。<br>凯恩斯主义经济学家认为，通胀源于生产成本增加等经济压力，并将政府干预视为解决办法；货币主义经济学家认为，通胀源于货币供应量的扩张，各国央行应保持货币供应量与GDP相一致的稳定增长。@link： <a href="/52.Financing/F29.费雪公式/" title="F29.费雪公式">F29.费雪公式</a></p><p>温和通胀和恶性通胀：</p><ul><li>温和通胀：各国央行希望维持高达3%的温和通胀，以帮助刺激经济增长，但如果通胀远远超过这一水平，可能导致恶性通胀或滞胀等残酷局面。</li><li>恶性通货膨胀是通货膨胀快速上升的时期；滞胀是通货膨胀急剧上升加上经济增长缓慢和失业率居高不下的时期。</li></ul><p>判断通胀的经济指标：PPI、CPI、进口价格指数 @link：<a href="/52.Financing/F23.宏观统计指标/" title="F23.宏观统计指标">F23.宏观统计指标</a></p><p><strong>滞胀</strong>（停滞性通货膨胀，英文: Stagflation），指的是通货膨胀居高不下的同时，经济放缓甚至停滞的情况。其影响包括失业率攀升、消费疲弱、成本增加等。 滞胀对各国央行构成了特别严峻的挑战：</p><ul><li>中央银行通常加息对抗高通胀，在滞胀时期这样做可能会导致失业率进一步上升。</li><li>同时又无法通过降息刺激经济，因为这样做可能导致通胀进一步上升。</li></ul><p><a href="https://mp.weixin.qq.com/s/CpeiJzKMRfpCQlhByIO82A" target="_blank" rel="noopener">美国1970年代大滞胀的来龙去脉 | 民生策略</a></p><ul><li>当下市场投资者认知中的“滞胀”，似乎总是基于着美林时钟的框架，固化在需求驱动下的“滞胀期”，认为物价的上行最终只是滞后于经济总量的上行而见顶，滞胀期是如此短暂且最终可以走向没有通胀的衰退。我们希望投资者通过1970s的经验认识到，通胀的成因并非只有需求的上升，而滞胀的“梦魇”也可以持续如此之久。</li><li>1970s美国走不出的“滞胀”循环：迟钝的货币政策&amp;无效的价格管制和不断加强的通胀预期,原因主要有三点：<ul><li>（1）过剩货币量是导致滞胀的主要原因；</li><li>（2）价格管制使得价格信号不能正确地反映市场供求，从而导致资源的错误配置，造成供给面的效率损失，进而削弱供给面的活力；</li><li>（3）宽松的货币政策导致通胀预期上升先于供给冲击，使得高通胀不可避免，食品与能源价格冲击只是在其中扮演了并不重要的角色。</li></ul></li><li>如何走出“滞胀”：<ul><li>结合沃尔克紧缩的货币政策与对待工会更为严厉的态度，里根政府与美联储合力打破了“工资—通胀”螺旋的恶性循环，在较短的时间内控制住美国公众对通胀的预期，逐步解决滞胀中“胀”的问题。</li><li>里根政府的新政（大规模减税、放松政策管制）激发经济活力, 也逐步让经济走出了“滞”。</li></ul></li></ul><h2 id="衰退、通缩、萧条"><a href="#衰退、通缩、萧条" class="headerlink" title="衰退、通缩、萧条"></a>衰退、通缩、萧条</h2><p><strong>衰退</strong>表现为普遍性的经济活力下降，和随之产生的大量工人失业。严重的经济衰退会被定义为经济<strong>萧条</strong>。<br>衰退过程可能会导致多项经济指标同时出现下滑，比如就业、投资和公司盈利，其它伴随现象还包括下跌的物价（通货紧缩）。当然，如果经济处于滞胀（Stagflation）的状态下物价也可能快速上涨。</p><p>政府通常会采取扩张性的宏观经济政策应对经济衰退，如增加货币供应量（货币政策）、增加政府支出（英语：government spending）和减少税收（财政政策）。</p><p><strong>通缩</strong>表现为经济衰退过程中导致需求不足、同时货币供应不足导致的物价下跌 // 在有宏观调控的情况下，衰退过程中往往会实行宽松货币政策（放水），所以未必出现这种情况；</p>]]></content>
      
      
      <categories>
          
          <category> 52.Financing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>习惯的力量：富兰克林的自我修养</title>
      <link href="/51.Productivity/%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%EF%BC%9A%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
      <url>/51.Productivity/%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%EF%BC%9A%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://sspai.com/post/65630" target="_blank" rel="noopener">从富兰克林到 2021，他们都在工程化自己的习惯 - 少数派</a></li><li><a href="http://www.tywiki.com/index.php/%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">富兰克林的自我修炼方法 - 通约智库</a></li></ul><h2 id="富兰克林的行为准则和习惯培养"><a href="#富兰克林的行为准则和习惯培养" class="headerlink" title="富兰克林的行为准则和习惯培养"></a>富兰克林的行为准则和习惯培养</h2><p>《本杰明·富兰克林自传》中写到，人的习惯的惰性总是于人不备时乘虚而入，而人们的习性往往强于理智。这是习惯的 2 个特性，既能击败自己又能帮助自己。坏的习惯必须打破，好的习惯必须加以培养。富兰克林的树立目标就是不断增多好的习惯，减少坏的习惯，在更大范围内寻求最佳结果。</p><p>为了实现这一目标，他拟定了方法，给自己设定了 13 个戒律，带着道德层面完善自己的心态出发，制定养成习惯的关键性的行为。他认为培养习惯的时候应该循序渐进，看哪一个习惯是哪一个习惯的基石，一个周期培养一次。</p><ul><li>一、节制。食不过饱；饮酒不醉。</li><li>二、沉默寡言。言必于人于己有益；避免无益的聊天。</li><li>三、生活秩序。每一样东西应有一定的安放的地方；每件日常事务当有一定的时间。</li><li>四、决心。当做必做；决心要做的事应坚持不懈。</li><li>五、俭朴。用钱必须于人或于己有益，换言之，切戒浪费。</li><li>六、勤勉。不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动。</li><li>七、诚恳。不欺骗人；思想要纯洁公正；说话也要如此。</li><li>八、公正。不做不利于人的事，不要忘记履行对人有益而又是你应尽的义务。</li><li>九、中庸适度。避免极端；人若给你应得处罚，你当容忍之。</li><li>十、清洁。身体、衣服和住所力求清洁。</li><li>十一、镇静。勿因小事或普通的不可避免的事故而惊慌失措。</li><li>十二、贞节。除了为了健康或生育后代起见，不常举行房事，切戒房事过度，伤害身体或损害你自己或他人的安宁或名誉。</li><li>十三、谦虚。仿效耶稣和苏格拉底。</li></ul><p>在循序渐进列出习惯的具体方法之后，他又想到毕达哥拉斯《黄金诗篇》里提出的忠告，有必要逐日对自己的行为进行反省，这样才能优化整个系统，就像生物新陈代谢一样能适应环境变化更好的生存下去。于是他想到设计了一个用表格的形式来检查习惯的方法。</p><p><img src="/images/20220228214928.png" alt=""></p><p>每一列是一种塑造美德的习惯，每一行是这个星期的一天。每天检查自己的所作所为，如果违反了哪几项习惯，就在相应的格子中打上小黑点。<br>他决心照此顺序对每一种习惯进行一星期的严密监控。这样，第一周特别注意避免发生任何违反「节制」 的行为，而对另外的只能是一般的关注，只是每天晚上就这一天的错误做上标记。<br>假如第一个星期，能够使标有节制的一行里没有黑点，就认为对这一习惯已经加强，与它相反的陋习已经大为削弱。如果达到这种程度，就将注意力扩展到下面的一项，争取在下一周内两行都没有黑点，直到完成最后一项习惯。<br>顺利的话，每过 13 个星期（一个季度）就可以走完一周期，一年可以循环 4 个周期。</p><h2 id="富兰克林的作息表"><a href="#富兰克林的作息表" class="headerlink" title="富兰克林的作息表"></a>富兰克林的作息表</h2><p><img src="/images/20220228213633.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 习惯 </tag>
            
            <tag> 富兰克林 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可借鉴的资料归类法-图书馆分类系统</title>
      <link href="/51.Productivity/%E5%8F%AF%E5%80%9F%E9%89%B4%E7%9A%84%E8%B5%84%E6%96%99%E5%BD%92%E7%B1%BB%E6%B3%95-%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%88%86%E7%B1%BB%E7%B3%BB%E7%BB%9F/"/>
      <url>/51.Productivity/%E5%8F%AF%E5%80%9F%E9%89%B4%E7%9A%84%E8%B5%84%E6%96%99%E5%BD%92%E7%B1%BB%E6%B3%95-%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%88%86%E7%B1%BB%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>@ref: 世界主要图书馆分类系统概况 - 知乎</p><p>一、杜威十进制图书分类法(Dewey Decimal Classification)</p><p>二、美国国会图书馆图书分类法(Library of Congress Classification)</p>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效学习法（费曼、SQ3R）</title>
      <link href="/51.Productivity/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
      <url>/51.Productivity/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="SQ3R"><a href="#SQ3R" class="headerlink" title="SQ3R"></a>SQ3R</h1><p>SQ3R来自以下五个英语词语的字首，即：综览（Survey）、发问（Question）、阅读（Read）、背诵（Recite）、复习（Review）</p><ul><li><p>综览（Survey，为时约1分钟）：在详读文章之前，先概览文章一番：留意文章内的标题及结构，以控制阅读的目的、方向和注意力。细阅文章的引言、总结及参考，但不要阅读文章的内容，试试能否从所得的资料略知文章的主题。目标为掌握文章主题的3个至6个要点。</p></li><li><p>发问（Question，为时不超过半分钟）：主要利用每个章节的标题和六何法来对要研习的题目自行拟定问题。</p></li><li><p>阅读（Read，不设时限，但以个人步伐）：指专心注意于找出发问问题的答案。阅读者需要逐一章节细阅，而不是一次过细阅整个篇章。阅读时应用主动阅读技巧，尝试在内文中找寻先前拟定问题的答案。</p></li><li><p>“背诵”（Recite）：能够在阅读时利用各种阅读技巧以帮助记忆，例如：做重点画线、口头复诵或笔记摘要。</p></li><li><p>复习（Review）：回忆所记忆的重点。</p></li></ul><p>@ref: <a href="https://zh.wikipedia.org/zh-cn/SQ3R%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/SQ3R%E6%96%B9%E6%B3%95</a></p><h1 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h1><ul><li>获取：即获得并初步吸收自己获得的知识</li><li>教学：向他人讲解你所获得的知识</li><li>回顾：对自己的教学进行评价，并回顾讲的不好的地方和漏洞</li><li>简化：简化知识，成为你自己的话术</li></ul>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化</title>
      <link href="/51.Productivity/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/51.Productivity/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>@todo 待整理</p><p><a href="https://antv-2018.alipay.com/zh-cn/index.html" target="_blank" rel="noopener">AntV</a> 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。</p><p>选择什么图表，需要回答的首要问题是『我有什么数据，需要用图表做什么』，而不是 『图表长成什么样』 。因此我们从数据出发，从功能角度对图表进行分类，如下所示：<br>@ref: <a href="https://antv-2018.alipay.com/zh-cn/vis/chart/index.html" target="_blank" rel="noopener">图表用法 - AntV</a></p><ul><li>比较类<ul><li>柱状图</li><li>直方图</li><li>南丁格尔玫瑰图</li><li>…</li></ul></li><li>分布类<ul><li>热力图</li><li>散点图</li></ul></li><li>…待整理 @todo</li></ul><hr><h1 id="比较类"><a href="#比较类" class="headerlink" title="比较类"></a>比较类</h1><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p><img src="/images/20220227001305.png" alt=""></p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>直方图 vs 柱状图</p><ul><li>柱状图是以矩形的长度表示每一组的频数或数量，其宽度(表示类别)则是固定的，利于较小的数据集分析。</li><li>直方图是以矩形的长度表示每一组的频数或数量，宽度则表示各组的组距，因此其高度与宽度均有意义，利于展示大量数据集的统计结果。</li><li>由于分组数据具有连续性，直方图的各矩形通常是连续排列，而柱状图则是分开排列。</li></ul><p><img src="/images/20220227001220.png" alt=""></p><p>直方图的扩展: 通过变换坐标系，我们能获得极坐标下的直方图、圆环上的直方图、以及翻转的直方图<br><img src="/images/20220227001431.png" alt=""></p><h2 id="堆叠面积图"><a href="#堆叠面积图" class="headerlink" title="堆叠面积图"></a>堆叠面积图</h2><p>堆叠面积图和基本面积图一样，唯一的区别就是图上每一个数据集的起点不同，起点是基于前一个数据集的，用于显示每个数值所占大小随时间或类别变化的趋势线，展示的是部分与整体的关系。</p><p>堆叠面积图上的最大的面积代表了所有的数据量的总和，是一个整体。各个叠起来的面积表示各个数据量的大小，这些堆叠起来的面积图在表现大数据的总量分量的变化情况时格外有用，所以堆叠面积图不适用于表示带有负值的数据集。非常适用于对比多变量随时间变化的情况。</p><p><img src="/images/20220227001606.png" alt=""></p><h2 id="矩形树图"><a href="#矩形树图" class="headerlink" title="矩形树图"></a>矩形树图</h2><p>没有权重关系，且需要明显展示层级关系，用分叉树图更合适</p><p><img src="/images/20220227001112.png" alt=""></p><h2 id="南丁格尔玫瑰图"><a href="#南丁格尔玫瑰图" class="headerlink" title="南丁格尔玫瑰图"></a>南丁格尔玫瑰图</h2><p><img src="/images/20220226145347.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何记笔记</title>
      <link href="/51.Productivity/%E5%A6%82%E4%BD%95%E8%AE%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/51.Productivity/%E5%A6%82%E4%BD%95%E8%AE%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="康奈尔笔记法"><a href="#康奈尔笔记法" class="headerlink" title="康奈尔笔记法"></a>康奈尔笔记法</h2><p>5R笔记法，又叫做康奈尔笔记法，特别适用于听课笔记</p><p>5R记录法：</p><ol><li>记录（Record）。在听讲或阅读过程中，在主栏（将笔记本的一页分为左小右大两部分，右侧为主栏，左侧为副栏）内尽量多记有意义的论据、概念等讲课内容。</li><li>简化（Reduce）。下课以后，尽可能及早将这些论据、概念简明扼要地概括（简化）在回忆栏，即副栏。</li><li>背诵（Recite）。把主栏遮住，只用回忆栏中的摘记提示，尽量完满地叙述课堂上讲过的内容。</li><li>思考（Reflect）。将自己的听课随感、意见、经验体会之类的内容，与讲课内容区分开，写在卡片或笔记本的某一单独部分，加上标题和索引，编制成提纲、摘要，分成类目。并随时归档。</li><li>复习（Review）每周花十分钟左右时间，快速复习笔记，主要是先看回忆栏，适当看主栏。<br>这种做笔记的方法初用时，可以以一科为例进行训练。在这一科不断熟练的基础上，然后再用于其他科目。</li></ol><p>康奈尔笔记系统把一页纸分成了三部分：<br><img src="/images/Cornell-Notes%20.png" alt="../_images/Cornell-Notes .png"></p>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开始使用Obsidian</title>
      <link href="/51.Productivity/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Obsidian/"/>
      <url>/51.Productivity/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Obsidian/</url>
      
        <content type="html"><![CDATA[<h2 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h2><ul><li>特性介绍: <a href="https://obsidian.md/features" target="_blank" rel="noopener">Features - Obsidian</a></li><li>版本发布: <a href="https://forum.obsidian.md/c/announcements/13" target="_blank" rel="noopener">Latest Announcements topics - Obsidian Forum</a></li><li>Feature requests: <a href="https://forum.obsidian.md/c/feature-requests/8" target="_blank" rel="noopener">Latest Feature requests topics - Obsidian Forum</a></li></ul><h2 id="Vault（库）"><a href="#Vault（库）" class="headerlink" title="Vault（库）"></a>Vault（库）</h2><p>每个vault下有单独的.obsidian文件夹:</p><ul><li><code>.obsidian/thems/</code>:   CSS主题目录</li><li><code>.obsidian/snippets/</code>: CSS代码片段目录</li><li><code>.obsidian/config</code>:</li><li><code>.obsidian/workspace</code>:</li></ul><blockquote><p>For example YourOwnVault/.obsidian/.trash is the trash folder<br>YourOwnVault/.obsidian/config stores things like your own custom hotkeys<br>YourOwnVault/.obsidian/workspace saves things like the most recent files, and the window layout (I think).</p></blockquote><p>App系统文件夹:</p><ul><li>macOS: <code>~/Library/Application\ Support/obsidian</code>, 文件缓存在<code>ObsidianCache/</code> 和 <code>IndexedDB/</code></li><li>Win: <code>%APPDATA%\Obsidian\</code></li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li><a href="https://github.com/shichongrui/obsidian-reveal-active-file" target="_blank" rel="noopener">obsidian-reveal-active-file</a>: 打开一个mkd时, 自动在文件树导航到这个文件</li><li><a href="https://github.com/darlal/obsidian-switcher-plus" target="_blank" rel="noopener">obsidian-switcher-plus</a>: 类似Sublime的Symbol搜索, 自定义快捷键<code>Cmd</code>+<code>R</code>, 呼出搜索框，直接是文件名模糊搜索， 输入<code>@</code>触发当前文件内搜索Heading, 输入<code>#</code>触发全库内搜索Heading</li><li><a href="https://github.com/lynchjames/obsidian-mind-map" target="_blank" rel="noopener">obsidian-mind-map</a>: 为当前笔记生成 mind map</li><li><a href="https://github.com/tgrosinger/advanced-tables-obsidian" target="_blank" rel="noopener">advanced-tables-obsidian</a>: 表格编辑, 输入<code>|</code>就可以进入表格编辑, 按<code>Tab</code>编辑下一个表格的内容</li><li><a href="https://github.com/platers/obsidian-linter" target="_blank" rel="noopener">obsidian-linter</a>: 格式化md文件, 更新yaml头</li><li><a href="https://github.com/OliverBalfour/obsidian-pandoc" target="_blank" rel="noopener">OliverBalfour/obsidian-pandoc: Pandoc document export plugin for Obsidian (https://obsidian.md)</a>: 导出为pdf、doc、html等格式</li><li><a href="https://github.com/obsidian-html/obsidian-html" target="_blank" rel="noopener">Obsidian-Html</a>: 将Obsidian笔记导出为网站html, 网站样例: <a href="https://obsidian-html.github.io/?path=%2FInstructions%2FUsage.html/" target="_blank" rel="noopener">https://obsidian-html.github.io/?path=%2FInstructions%2FUsage.html/</a></li><li><a href="https://github.com/liamcain/obsidian-calendar-plugin" target="_blank" rel="noopener">obsidian-calendar-plugin</a>: 给Obs增加一个日历widget用以显示每天的笔记, 依赖于Obs的Core插件<code>Daily Note</code>, 是按照mkd的文件名区分日期的, 对于我来说大部分mkd文件都不是日期命名所以也没多大用处, 希望能改成通过yaml头或者文件modify属性识别日期</li><li><a href="https://silentvoid13.github.io/Templater/introduction.html" target="_blank" rel="noopener">Templater</a>： 更好的模板管理</li></ul><h2 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h2><ul><li><a href="https://github.com/whyt-byte/Blue-Topaz_Obsidian-css" target="_blank" rel="noopener">whyt-byte/Blue-Topaz_Obsidian-css: A blue theme for Obsidian.</a></li><li><a href="https://github.com/mediapathic/obsidian-arsmagna-theme" target="_blank" rel="noopener">mediapathic/obsidian-arsmagna-theme: A theme for Obsidian, inspired by the works of Athanasius Kircher</a></li><li><a href="https://github.com/kepano/obsidian-minimal" target="_blank" rel="noopener">kepano/obsidian-minimal: Minimal theme for Obsidian</a></li></ul><h2 id="CSS-Snippets"><a href="#CSS-Snippets" class="headerlink" title="CSS Snippets"></a>CSS Snippets</h2><p>CSS Snippets 可以载入自定义CSS， 自定义 Obsidian 的外观，例如自定 Heading 的显示样式..</p><p>在 <code>设置 =&gt; 外观 =&gt; CSS 代码片段</code> 管理，</p><p>更多可用的 Snippet可以在这里找到： <a href="https://github.com/deathau/obsidian-snippets" target="_blank" rel="noopener">https://github.com/deathau/obsidian-snippets</a></p><h2 id="YAML-front-matter"><a href="#YAML-front-matter" class="headerlink" title="YAML front matter"></a>YAML front matter</h2><p>由于 Markdown 官方标准不支持存储 metadata（例如笔记更新日期、分类等），所以 Obsidian 通过支持 YAML front matter 来解决，目前受 Obsidian 支持的有：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aliases:</span> <span class="string">[别名1,</span> <span class="string">别名2]</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">publish:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>title</code>不是官方支持的属性…</li><li><code>aliases</code> 必须在第一行，</li></ul><p>@ref: <a href="https://help.obsidian.md/Advanced+topics/YAML+front+matter" target="_blank" rel="noopener">https://help.obsidian.md/Advanced+topics/YAML+front+matter</a></p><h2 id="快捷键（含自定义）"><a href="#快捷键（含自定义）" class="headerlink" title="快捷键（含自定义）"></a>快捷键（含自定义）</h2><ul><li>快速打开：<code>cmd + O</code></li><li>命令面板：<code>cmd + P</code></li><li>编辑/预览: <code>cmd + E</code></li><li>插件-Advanced Tables插入表格： 按<code>|</code>，再按<code>Tab</code></li><li>插件-Linter 格式化当前文件： <code>cmd + alt + L</code></li><li>插件-Quick Switcher： <code>cmd + R</code>，再按<code>#</code>进入 Heading 搜索</li><li>插件-Templater 插入YAML（自定义）：<code>cmd + shift + Y</code></li><li>返回：<code>cmd + alt + ←</code></li><li>访问光标处的链接： <code>alt + Enter</code></li><li>播放关系图谱生长动画： <code>cmd + shift + P</code></li><li>查看关系图谱： <code>cmd + G</code></li><li>查看局部关系图谱： <code>cmd + shift + G</code></li></ul><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><p>进入调试模式快捷键： <code>option-cmd-i</code>（或 <code>Ctrl+shift+I</code> for Win）</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li><a href="https://help.obsidian.md/Advanced+topics/Using+obsidian+URI" target="_blank" rel="noopener">Using obsidian URI</a></li><li><a href="https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter" target="_blank" rel="noopener">YAML front matter</a></li><li><a href="https://help.obsidian.md/How+to/Add+aliases+to+note" target="_blank" rel="noopener">Add aliases to note</a></li><li><a href="https://help.obsidian.md/How+to/Link+to+blocks" target="_blank" rel="noopener">Link to blocks</a></li><li><a href="https://help.obsidian.md/How+to/Internal+link" target="_blank" rel="noopener">Link to headings</a></li><li><a href="https://help.obsidian.md/Plugins/Workspaces" target="_blank" rel="noopener">Workspace</a></li><li><a href="https://help.obsidian.md/How+to/Add+custom+styles" target="_blank" rel="noopener">添加自定义CSS</a></li></ul><h2 id="问题-amp-feature-requests"><a href="#问题-amp-feature-requests" class="headerlink" title="问题 &amp; feature requests"></a>问题 &amp; feature requests</h2><ul><li>在 Graph View使用H1标题替代 filename<ul><li><a href="https://forum.obsidian.md/t/show-title-of-zettelkasten-notes-in-graph-view/683" target="_blank" rel="noopener">https://forum.obsidian.md/t/show-title-of-zettelkasten-notes-in-graph-view/683</a></li><li><a href="https://forum.obsidian.md/t/use-h1-or-front-matter-title-instead-of-or-in-addition-to-filename-as-display-name/687" target="_blank" rel="noopener">https://forum.obsidian.md/t/use-h1-or-front-matter-title-instead-of-or-in-addition-to-filename-as-display-name/687</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PKM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看板（Kanban）</title>
      <link href="/51.Productivity/%E7%9C%8B%E6%9D%BF%EF%BC%88Kanban%EF%BC%89/"/>
      <url>/51.Productivity/%E7%9C%8B%E6%9D%BF%EF%BC%88Kanban%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用看板（Trello）"><a href="#如何使用看板（Trello）" class="headerlink" title="如何使用看板（Trello）"></a>如何使用看板（Trello）</h1><p>@tag:  #方法论 #看板</p><ul><li>看板历史历史：<br>  丰田生产模式，解决生产线不同车间（流式生产线）库存和消耗量对齐的问题。<br>  例子: 车间1 → 车间2 → 车间3 …</li><li>看板例子（流式任务）：参考 <a href="https://www.zhihu.com/question/20339647" target="_blank" rel="noopener">Trello 等任务管理工具体验如何？ - 知乎</a><ul><li>bug处理： bug汇集池 → bug处理（Tips 用标签区分不同产品）</li><li>待办： 收集箱 → Doing → Done（Tips 用标签作为优先级标识）</li><li>项目： 需求TODO → 开发ing → 测试ing → 已完成/被阻塞</li><li>里程碑/周报： 第一周 → 第二周 （完成的留在本周，未完成流向下一周）</li><li>追踪多个项目：</li></ul></li><li>除了解决“任务流转”，看板还可以： 解决<code>列表</code>结构的局限性： <code>列表</code>是单线结构，并单向生长。如果需要关注多个并行的<code>列表</code> &amp; 某个列表过长..</li></ul><h1 id="模板整理"><a href="#模板整理" class="headerlink" title="模板整理"></a>模板整理</h1><ul><li><a href="https://trello.com/templates/project-management/it-project-workflow-TcQNw7nZ" target="_blank" rel="noopener">IT Project Workflow</a>: TODO、IN PROGRESS、BLOCKING</li><li><a href="https://trello.com/templates/personal/4-ls-exercise-Bay7DwxN" target="_blank" rel="noopener">4 L’s exercise</a>： 此看板包括四个列表，记录发生的事情：里程碑，喜欢的，想做的，不喜欢的</li><li><a href="https://trello.com/templates/personal/book-clubs-tP0ROvp8" target="_blank" rel="noopener">Books Club</a>：列表1=好书待读，列表2=book1，列表3=book2 …</li><li><a href="https://trello.com/templates/productivity/marc-andreesen-productivity-system-VOy8QVlg" target="_blank" rel="noopener">马克安德森生产力体系</a>：此看板用于GTD，TODO、Today、Later…</li><li><a href="https://trello.com/templates/productivity/annual-life-goals-&amp;-planning-ves3wHI2" target="_blank" rel="noopener">Life Goals</a>： 此看板包括几个列表：已计划事件、1月完成、2月完成…</li></ul><h1 id="选型：-Trello-vs-Google-Keep"><a href="#选型：-Trello-vs-Google-Keep" class="headerlink" title="选型： Trello vs Google Keep"></a>选型： Trello vs Google Keep</h1><ul><li>Google Keep：<ul><li>n个笔记组成一个看板，笔记本即“列表”</li><li>笔记本支持颜色</li></ul></li><li>Trello：<ul><li>看板-列表-卡片</li><li>卡片支持标签（例如用来标注优先级）</li><li>卡片支持Due时间</li><li>卡片支持添加Checklist</li><li>卡片支持评论</li></ul></li></ul><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><h2 id="案例：用看板作为-Read-it-later"><a href="#案例：用看板作为-Read-it-later" class="headerlink" title="案例：用看板作为 Read-it-later"></a>案例：用看板作为 Read-it-later</h2><p>TODO</p><h2 id="案例：用看板作为-工作管理"><a href="#案例：用看板作为-工作管理" class="headerlink" title="案例：用看板作为 工作管理"></a>案例：用看板作为 工作管理</h2><ul><li>看板1（里程碑或周报）： 第一周、第二周…</li><li>看板2（多项目追踪）：项目1、项目2…</li></ul><h2 id="案例：用看板作为-个人目标管理"><a href="#案例：用看板作为-个人目标管理" class="headerlink" title="案例：用看板作为 个人目标管理"></a>案例：用看板作为 个人目标管理</h2><p>参考 “Life Goals”模板</p>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKM.什么是卡片盒笔记法</title>
      <link href="/51.Productivity/PKM.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%A1%E7%89%87%E7%9B%92%E7%AC%94%E8%AE%B0%E6%B3%95/"/>
      <url>/51.Productivity/PKM.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%A1%E7%89%87%E7%9B%92%E7%AC%94%E8%AE%B0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>@tag: #Zettelkasten #卡片盒笔记法 #Luhmann</p><p>这里只讨论什么是 “符合原旨主义的卡片盒笔记法”？ 换句话是卢曼怎么做的。从以下几个方面评估：</p><ol><li>单篇笔记格式：Atomicity，遵循原子笔记（Anatomy of Zettel）</li><li>笔记间互相引用</li><li>以带序号的文件名，表示笔记之间的层级关系、生长关系：<ul><li>“第一条笔记的地址为数字1。如果你想添加一个与第一条笔记无关的笔记，那么将新笔记的地址设为数字2”</li><li>“如果你想写一条与笔记1有关的新笔记，那么你应该以笔记1为起点产生一条分支，此时新笔记的地址被设为1a”</li><li>卢曼的 <a href="https://luhmann.surge.sh/communicating-with-slip-boxes" target="_blank" rel="noopener">Communicating with Slip Boxes by Niklas Luhmann</a> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>文章里说明了这种命名方式，笔记通过命名组成了虚拟的slip（滑道），实现了 internal growth（内在生长）</li><li>国内介绍的文章，大都把 Zettelkasten 翻译为卡片盒，特性介绍里只保留了“原子笔记”，但丢掉了“slip”</li></ul></li><li>放入哪个盒子？即盒子是如何分类的，以及盒子无法实现“大盒子套小盒子”的情况下，如何应对树形概念？<ul><li>google图片搜索 “Luhmann box Stock Photos”：卢曼的盒子是有纸条的，但也可能是后人加上去的</li></ul></li><li>卡片盒不是双链笔记，只是卢曼的时代很难实现反链</li></ol><p>以上部分概念来自 <a href="https://zettelkasten.de/introduction/zh/" target="_blank" rel="noopener">https://zettelkasten.de/introduction/zh/</a></p><hr><p><a href="https://sspai.com/post/67087" target="_blank" rel="noopener">如何用好 Roam Research ？（三）：Roam 不是卡片盒 - 少数派</a><br>卡片盒为什么这么受到追捧？这和它的提出者社会学家尼古拉斯卢曼分不开。关于卢曼的生平，我在这篇文章里面已经和你谈过了。卢曼的学术发表记录，相信已经给你留下了很深刻的印象。但是，你千万不要把 Roam Research 和卡片盒直接画上等号。不要小瞧概念的力量，一旦画上等号，你就会偏执的以一种「原教旨主义」的方式来记笔记。<br>你会坚定认为每一则笔记(对应 Roam Research 中的一个页面)不应该超过一定的字数限制(比如说200个字)，而且还必须保证它谈论的，必须只有一个主题。另外，还需要根据类别，手动对于页面赋予独特的标记。因为，卢曼就是这样做的啊！</p><p><a href="https://www.zhihu.com/question/384309878" target="_blank" rel="noopener">什么是 Zettelkasten 卡片盒笔记法？ - 知乎</a></p><p><a href="https://www.zhihu.com/question/473841271" target="_blank" rel="noopener">卡片笔记写作法是否被过誉了？ - 知乎</a></p><hr><p><a href="https://book.douban.com/subject/35503571/" target="_blank" rel="noopener">卡片笔记写作法 (豆瓣)</a></p><p><img src="/images/How-to-Take-Smart-Notes.png" alt="../_images/How-to-Take-Smart-Notes.png"></p><p>英文版： <a href="https://www.soenkeahrens.de/en/takesmartnotes#zettelkasten-en" target="_blank" rel="noopener">Take Smart Notes — Sönke Ahrens</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">wiki里也提到了这种slip命名： <a href="https://en.wikipedia.org/wiki/Zettelkasten" target="_blank" rel="noopener">Zettelkasten - Wikipedia</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PKM.资源分类法.PARA-and-IARP</title>
      <link href="/51.Productivity/PKM.%E8%B5%84%E6%BA%90%E5%88%86%E7%B1%BB%E6%B3%95.PARA-and-IARP/"/>
      <url>/51.Productivity/PKM.%E8%B5%84%E6%BA%90%E5%88%86%E7%B1%BB%E6%B3%95.PARA-and-IARP/</url>
      
        <content type="html"><![CDATA[<h2 id="P-A-R-A"><a href="#P-A-R-A" class="headerlink" title="P.A.R.A"></a>P.A.R.A</h2><p><img src="/images/20220311142045.png" alt=""></p><p>一个好的个人知识管理体系，应该可以支持并帮助你的工作，它应该让你在放置信息时准确知道放置的位置，以及在需要信息时能准确查找到信息的位置。</p><p>这个系统应该有如下特点：</p><ul><li>通用，能涵盖任何来源的任何信息</li><li>灵活，能够处理各种现在在做的和将来要做的项目和活动。</li><li>简单，无需超出最低要求的任何耗时维护、编目、标记或重新整理</li><li>可操作，与任务管理和项目管理方法无缝集成</li><li>跨平台，可与任何应用程序一起使用，包括已存应用在或未来的应用</li><li>以结果为导向，以支持交付有价值的工作为目的来构建信息</li><li>模块化，允许根据当前任务的需求隐藏或揭示不同级别的细节</li><li>机会主义，最好能够在已经完成的工作的基础上进行，而不是占用额外时间。</li></ul><p>P.A.R.A. 代表<strong>项目（Projects）— 领域(Areas) — 资源(Resources) — 档案(Archives)</strong>，四个顶级类别， 包括您在工作和生活中可能遇到的每种类型的信息。</p><ul><li>P：Project，有目标、有交付日期、会结束</li><li>A：Area of responsibility，是”需要一直负责和维护的活动领域”, 例如工作中需要持续关注的领域, 或者打算持续发展兴趣（健康/写作/营销等）</li><li>R：Resource，是”持续感兴趣的话题或主题”</li><li>A：Archive，存档，示例包括：已完成或非活动的项目;不再承诺维护的Areas;不再感兴趣的resources</li></ul><p><em>Area与Project</em>：<br>二者的区别是，项目有DDL或明确的结束的日期而Area没有，Project的里更多属于”可操作的”, Area里更多的是”不可操作的信息”。二者的联系：项目总是属于一个领域，例如:</p><ul><li>参加马拉松是一个项目，而健康是一个领域</li><li>出版一本书是一个项目，而写作是一个领域</li></ul><p><em>Area与Resource</em>:<br>Area（注意是 Are of responsibility）, 是您在生活中扮演的角色和您所负责的职位（配偶、母亲/父亲、团队负责人、足球教练）、您承担责任的现行标准（产品开发、公司通讯、法律），以及需要持续关注的事情（锻炼、财务、公寓、宠物）。Area 强调的是需要”负责的领域”，而Resource仅仅是”感兴趣的主题”, 这是二者的主要区分点。Resource 里可以是任何感兴趣的主题的文章、资料甚至代码片段。<br>另外作者还提到自己私人信息也会放入Area，这样可以随时放心的分享Resource，例如体检报告、就诊记录放在名为“健康”的Area中，而Resource中存放的是运动、健康的有趣文章或者推荐的训练方案。</p><p>@ref:</p><ul><li><a href="https://fortelabs.com/blog/para/" target="_blank" rel="noopener">The PARA Method: A Universal System for Organizing Digital Information - Forte Labs</a></li><li><a href="https://fortelabs.com/blog/p-a-r-a-ii-operations-manual/" target="_blank" rel="noopener">PARA Part 2: Operations Manual - Forte Labs</a></li><li><a href="https://sspai.com/post/61459" target="_blank" rel="noopener">P.A.R.A. 是什么及在 Notion 中的应用 - 少数派</a></li></ul><h2 id="I-A-R-P"><a href="#I-A-R-P" class="headerlink" title="I.A.R.P"></a>I.A.R.P</h2><p>I.A.R.P 是一组缩写，即：</p><ul><li>Inbox（收件箱）：我会将所有临时性的，还未消化的内容放置于此，定期来进行归档、整理或者删除。可以当做大脑的缓存，避免记录的时候纠结放在哪里。</li><li>Area（领域）：这是最重要的概念，即日常你需要精进的「领域」，比如健康就是一个领域，而跑步则是项目；写作是一个领域，而写一篇公众号文章则是一个项目；</li><li>Resource（资源）：对应到卢曼的 Zettelkasten 方法中，更像是永久笔记。一般来说是兴趣、主题、资产等内容。注意是自己消化过的内容，而非机械的收藏。</li><li>Project（项目）：是指一个将要发生的独立事件，并且这个事件不是一次性就能完成的，至少需要多个动作才能完成。比如要写一本书，需要整理资料，罗列提纲，撰写内容，联系出版社。类似生活中还有组织一次旅游，录制一期播客等。</li></ul><p>这里面最难的其实是 Area（领域） ，即你最关注的领域是什么。我们的一生中由许多事件构成。只是对于大多数人来说，他们其实并没有一个关于自己生活和工作的完整的项目清单。但是他们却会告诉你，有太多的事情要做。当这样忙忙碌碌多年以后，其实发现自己可能做了许多事，但是却「样样稀松」。这就是只有项目，而缺乏 Area（领域）聚焦带来的问题。</p><p>@ref:</p><ul><li>I.A.R.P: <a href="https://help.flomoapp.com/thinking/iarp.html" target="_blank" rel="noopener">https://help.flomoapp.com/thinking/iarp.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类法 </tag>
            
            <tag> PARA </tag>
            
            <tag> IARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKM.数字花园</title>
      <link href="/51.Productivity/PKM.%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/"/>
      <url>/51.Productivity/PKM.%E6%95%B0%E5%AD%97%E8%8A%B1%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="何谓数字花园"><a href="#何谓数字花园" class="headerlink" title="何谓数字花园"></a>何谓数字花园</h2><blockquote><p>数字花园 是介于笔记应用和博客应用之间的半公开数字展览馆，半公开指的不是读者没有权限阅览，而是很多想法只是相互关联的半成品，令他人难以轻易看懂。<br>因为数字花园降低了对内容的要求，不强求作者将所有内容都打磨成文章级的成果，数字花园就会鼓励作者产出更多的内容，不拘一格降笔记。</p></blockquote><h2 id="菲尔德的隐喻：花园、溪流和篝火"><a href="#菲尔德的隐喻：花园、溪流和篝火" class="headerlink" title="菲尔德的隐喻：花园、溪流和篝火"></a>菲尔德的隐喻：花园、溪流和篝火</h2><blockquote><p>在2015年数字学习研究网络上，迈克·考菲尔德（Mike Caufield）发表了关于《花园与溪流：技术田园》的主题演讲。它后来成为一篇重要的文章，为我们现在对这个词语的理解奠定了基础。如果说有谁应该被认为是最早提出了数字花园的话，那就是考菲尔德。他是第一个用诗意的、连贯的文字来阐述整个想法的人。</p></blockquote><p>麦克·考菲尔德认为，互联网有两种形态，一种是“花园”，一种是“溪流”。花园（Garden）是说，互联网就像一块土地，上面有小路，有花草树木，它们皆有所指。小路就是超链接，让我们在不同网页穿梭，花花草草则是不同的网站。这的确和早期的互联网形态很像，和上面提到的1998年的超文本花园联系上了。</p><p>溪流（Stream）指的就是线性的信息流，各种关注、算法推荐、通知产生的信息流，就像一条条小溪不停流淌。溪流里的信息，上一条和下一条可能并不相关，只是被聚合到了一起。甚至社交网络号称是网络，但呈现在大家面前的还是一条条的信息流。</p><p>考菲尔德得出结论：在溪流模式中，无法承载系统化的知识。<br>如果互联网只剩下溪流模式，那么它迟早会变成充斥知识碎片的混沌之地。如果每一个人都只投身于溪流当中，也无法收获真正的成长。考菲尔德认为，我们应该像园丁维护花园一样去学习和探索知识。</p><p>2018年，一个叫汤姆·克里奇洛的软件工程师写了一篇博客《数字溪流、篝火与花园》，在继承了考菲尔德所提出的两种意象之外，还创造了一个新的意象：数字篝火（Digital Campfire）<br>克里奇洛说，数字溪流的例子就像推特，数字花园的例子有维基百科，而数字篝火介于两者之间：像是博客、一些slack社群。博客中的知识之光就像篝火一样，随时间逐渐熄灭，社群中的讨论也随时间消逝，但在写博客、参与社群的过程中，他自己获得了成长。</p><hr><p>Digital Garden 的特点：</p><ul><li>不断生长：数字花园里的文章需要不断打磨和更新（就像打理花园），也意味着数字花园里的文章可以是半成品</li><li>数字花园有“小径”：文章是有关联的，双链or传统的目录</li><li>数字花园同博客的区别：博文一旦发布很少会再更新/打磨内容（不是说功能上不能够，而是用户的使用的习惯），对于文章的索引，博客更强调时间序，数字花园似乎是不喜欢“timeline”式的（时间序的更像是 Stream的特征），并且强调文章之间的引用关联</li></ul><h2 id="搭建自己的数字花园"><a href="#搭建自己的数字花园" class="headerlink" title="搭建自己的数字花园"></a>搭建自己的数字花园</h2><p>@toc：</p><ul><li>Hexo:</li><li>Hugo:</li><li>TiddlyWiki:</li></ul><h2 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a>使用 Hexo</h2><p>Hexo默认主题和 NexT是按照修改时间排序，如果要实现 order by Name：参考 <a href="https://beefyheisenberg.github.io/50.Farbox-Blog/%E3%80%90Markdown%E3%80%91Hexo%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/">Hexo部署和使用指北(Windows) | 扔掉笔记 ᐛ</a>/自定义post排序</p><h2 id="使用-Hugo"><a href="#使用-Hugo" class="headerlink" title="使用 Hugo"></a>使用 Hugo</h2><p>@todo</p><h2 id="使用-TiddlyWiki"><a href="#使用-TiddlyWiki" class="headerlink" title="使用 TiddlyWiki"></a>使用 TiddlyWiki</h2><p><a href="https://nesslabs.com/digital-garden-tiddlywiki" target="_blank" rel="noopener">How to build a digital garden with TiddlyWiki - Ness Labs</a></p><h2 id="ref"><a href="#ref" class="headerlink" title="@ref"></a>@ref</h2><ul><li><a href="https://coolshell.me/articles/digital-garden.html" target="_blank" rel="noopener">什么是数字花园（Digital Garden）？ – 酷 壳 – CoolShell 3F</a></li><li><a href="https://www.zhihu.com/question/400660802" target="_blank" rel="noopener">什么是数字花园（Digital Garden）？ - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PKM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKM.01.我的笔记系统实践</title>
      <link href="/51.Productivity/PKM.01.%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/"/>
      <url>/51.Productivity/PKM.01.%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>@tag: #PKM #知识管理 #Zettelkasten #卡片盒笔记法 #Luhmann</p><p>@ref <a href="/51.Productivity/PKM.什么是卡片盒笔记法/" title="PKM.什么是卡片盒笔记法">PKM.什么是卡片盒笔记法</a></p><hr><h2 id="01-从这里开始"><a href="#01-从这里开始" class="headerlink" title="01.从这里开始"></a>01.从这里开始</h2><p>目前我在用的笔记系统，用一句很简单的话概括就是：本地markdown文件 +Dropbox网盘同步，同时用 Vscode 项目把整个笔记目录管理起来。</p><p>大概几年前，我正在 Evernote 、有道云笔记、OneNote之间反复横跳。当时还没有 Notion，也没有RoamResearch，甚至PKM（个人知识管理）都很少有人提及。</p><p>最后还是选择了本地 Markdown这种“看似不便”的方式，毕竟原生的 Markdown有种种缺点（图片管理、没有 Metadata、不支持复杂排版），本地文件的方式摆脱不了树状文件夹的笔记结构… 甚至在当时缺少非常顺手的编辑器。但这些年修修补补也一直用下来了，上面提到的种种缺点也都改善或规避，期间也尝试过 Notion、RoamResearch、Logseq，但这种 “基于本地 Markdown”的笔记一直都是我的笔记系统基本盘。</p><p><img src="/images/PKM-Notes-Header.png" alt=""></p><p>这种方案的好处是：</p><ul><li>数据完全属于自己，Dropbox网盘 + 自己写的定时脚本备份到 Git ，双重措施可以确保笔记不会丢失，也能通过 Git的历史追溯修改历史、查看笔记系统的生长过程；</li><li>最好的同步体验（Dropbox） + 最好的现代编辑器（Vscode）：Dropbox的多设备同步近乎实时，并且增量同步非常适合 Markdown 这种轻量文本，如果上网不便可以用坚果等其他同步盘替代，如果你用 苹果全家桶且能忍受 iCloud Drive的同步<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，它也是可以的 。至于最好的编辑器…. 还是看个人习惯吧，现代的编辑器诸如 Sublime、Atom，以及 编辑器原旨主义宗教继承人 NeoVim、Spacemacs… 它们都非常棒，这些 「Code Editor」 功能大同小异，看自己习惯和信仰；</li><li>除了传统编辑器，笔记文件库还可以用多种软件打开：如果要书写体验可以用 Typora（我现在正用 Typora 写这篇文章），如果需要双链的鸟瞰图可以用 Obsidian（借助 Obsidian的双链实现网状结构），同时也有基于文件夹的树形结构。<br>在网状结构笔记大行其道的今日，树形结构依然是人类的对知识的最佳认知结构<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</li><li>Markdown是一种“源文件”，可以转换为各种格式输出。我会把笔记通过 Hexo生成博客（需要一些脚本做 Markdown的转换，例如修改图片路径适应Hexo的目录<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，从而实现 笔记到博客的一键发布），这种“笔记即发布为博客”也是一种 <a href="https://www.quora.com/What-is-a-digital-garden" target="_blank" rel="noopener">数字花园</a><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>的实践，我的笔记公开部分放在了<a href="https://gitee.com/beefyheisenberg/dropworkspace-public" target="_blank" rel="noopener">gitee</a>上。此外，使用 pandoc 将 Markdown 导出为PDF、PPT、DOC等等格式应付各种场合，「一处写作，多处发布」。</li></ul><p>当然 “本地 Markdown 文件”这种方案也有一些不便：</p><ul><li>块引用：Vscode 和 Obsidian都已经支持了使用<code>#</code>标题作为块引用的最小单元（例如<code>[[笔记名字#标题名]]</code>这样 ） ，但不能支持更细粒度的块了， 相比较 Logseq 和 RoamResearch等等都支持的“行级别的块引用”；</li><li>缺少好用的移动端（iOS/Android），不过我在手机上很少直接编辑笔记，如果有突然的想法我会记录到 Drafts，所以对于手机端的要求是方便查/阅：<ul><li>如果你用 Dropbox同步，1Writer（Android ） 、MWeb（iOS）、Editorial（iOS） 都可以；</li><li>如果你用 Git同步，Working Copy （iOS）是我的第一选择，Noteshub作为替补（iOS）</li></ul></li><li>图片管理：早年的 Markdown编辑器贴图很麻烦， 但借助插件和更新的编辑器，无论 Vscode 或者 Obsidian 都支持使用<code>Ctrl+v</code>的傻瓜方式贴图，和富文本编辑器相比，对图片的使用已经不那么麻烦了。我把图片存储在项目下的image文件夹，用dropbox一起同步。好处是笔记无论搬到 Git 还是 Hexo博客，这些都能很好的支持本地图片，也不担心图床失效的问题。</li><li>Markdown的表达能力的缺陷：<ul><li>没有Metadata：比如 Evernote的笔记里还记录了 创建位置、修改时间等等Metadata的， 虽然说修改时间也能从文件属性里读出来，但如果换新电脑or 移动一下文件夹这个时间戳就失灵了。Markdown 的话只能通过 YAML Front Matter 存储这类信息，但这玩意不属于原生语法，各家App 的支持也不尽相同，会造成显示的混乱。</li><li>不支持复杂排版，例如双列、图文混排等等样式。公平的说，复杂排版本来就不是 Markdown 该做的事情，Markdown 实现的是易记且便于书写的标记语言，换个角度说，支持复杂排版的标记语言写起来一定不方便（诸如 LaTex、HTML等等）。当然实现图片排版可以通过往 Markdown 里加一些 HTML 来支持，例如 Obsidian的主题 <a href="https://github.com/whyt-byte/Blue-Topaz_Obsidian-css" target="_blank" rel="noopener">Blue-Topaz</a> 提供了类似的功能，但我不用，这些不是原生的 Markdown 语法，可能这个 App 里支持但换另一个 App 就不识别了</li></ul></li></ul><p>关于云笔记服务的数据安全多说几句，大厂的笔记产品，虽然有靠谱的技术保证服务稳定性，但也有潜在的不便：</p><ul><li>内容审核：国内大厂头上的<strong>达摩克利斯之剑</strong>，具体可以参考金山删除用户文档的事儿，以及早年的坊间传闻“百度云和谐了我的正常视频！”，为什么是传闻，因为没人能拿出证据证明视频的清白🤓</li><li>产品生命周期：我也在BAT工作过，了解一个产品的出生到下线整个过程和决策，大厂产品也会有下线的那一天。当然下线前会给用户充分的迁移时间，but， <strong>迁移也是成本！</strong>。此外，国外大厂也好不到哪儿去，比如Google 关闭过的一众服务（<a href="https://zhuanlan.zhihu.com/p/318575838" target="_blank" rel="noopener">Reader、Picasa、Wave等等…</a>），以及因为服务条款变更而关闭国内服务等等（Yahoo就是你！）</li></ul><h2 id="02-笔记的目录结构"><a href="#02-笔记的目录结构" class="headerlink" title="02.笔记的目录结构"></a>02.笔记的目录结构</h2><p><img src="/images/PKM-Notes-Directory.png" alt=""></p><p>我的笔记系统有6个目录（如上图），分别存储不同的笔记：</p><ul><li>① Inbox/：临时笔记，很多情况下一篇笔记不会立刻写完，可能需要几天的酝酿和资料收集，在这一阶段的笔记存储在这里，进一步组装和成型。每天我只需要关注这里就可以想起最近在学哪些东西；</li><li>② Project/：项目笔记，“<strong>万事皆可当项目！</strong>”，除了我们的工作，其他的个人事务也可以用项目管理的方式：有最终目标、有最终完成时间（DDL）、有阶段性时间和关键成果（KP）。项目笔记的特点是：没有过多的知识性信息，大都是时间点和具体操作；</li><li>③ Personal/：带有个人信息的笔记，例如一些账单、体检报告、会员卡号、甚至旅行箱密码等等… 这里存储的更像是“备忘录”而非“知识性笔记”。把这部分单独存放的好处是，当要分享自己的笔记时，我可以很放心的分享另外几个笔记目录，这是一种信息隔离的思想；</li><li>④ Code Primer/： 永久笔记1（专业知识的笔记放这里）。题主是一个程序员，从编程语言、架构设计、中间件、大数据等等都有涉及，这个目录下的笔记数量是最多的，子分类也是最多的。后面会说这部分如何分类；</li><li>⑤ Scriptorium/：永久笔记2（专业知识之外的关注），比如作为一个喜欢文史哲的码农，这个文件夹下面有生产力工具、财经、摄影、流行文化、心理学和哲学等等..</li><li>⑥ Archive/： 归档，对于上面1/2/3/4不再感兴趣的、长期用不到 或者不再维护的，都丢这里；</li></ul><p>▷ 关于 <strong>2.Project</strong> 和 <strong>6.Archive</strong> 的分类：是参考了 P.A.R.A 分类法<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>，但没有完全照搬，只采用了两个原则，1有时间节点的是项目，应该独立出来，2不再有兴趣不再维护的资料放入归档。另外，P.A.R.A 的提出者还提到自己私人信息也会放入Area，这样可以随时放心的分享Resource，“例如体检报告、就诊记录放在名为“健康”的Area中，而Resource中存放的是运动、健康的有趣文章或者推荐的训练方案”。</p><p>▷ 对于“闪念笔记”，我是不放入这套笔记里的，我会在手机上用 <a href="https://getdrafts.com/" target="_blank" rel="noopener">Drafts</a> 记录下来，然后 闪念笔记 要每天清空一次，有保留价值的会稍加整合放在 “①Inbox”文件夹下继续组装和完善，无保留价值的闪念笔记直接删除（像一些无价值的呓语和仅仅带有情绪抒发的碎碎念，是无继续写的价值的）；用完的闪念笔记也可以不删而是归档，这样在 Drafts的归档里还是可以保留时间序的碎片的。</p><p>▷ 上面提到的 ④ 和 ⑤ 都是一个独立的 Obsidian库，为什么作为知识积累的永久笔记，不放在一个文件夹而是分开？ 原因一是 如果合并，子目录就会太多，不便管理；并且 ④ 和 ⑤ 中的笔记几乎没有互相引用，所以分为两个库（ Obsidian 管理引用链接的范围是库，库外的文件无法引用，属于不同库的笔记是“引用隔离”的 ）</p><p>▷ 关于临时笔记（Fleeting notes）、永久笔记（Permanent notes）的概念：参考了Luhmann 的笔记分类 。但我的笔记里没有“文献笔记（Literature notes<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>）”这一类， 对于文献的记录和总结，我习惯都放永久笔记。这个视个人分类习惯而定，有时候把类型分的太细致反而阻碍写作的积极性。</p><p>▷ 永久笔记并不“永久”：永久笔记也在一直被更新和完善，拆成小文件、合并成大文件、增加引用链接等等。这也正是 Andy Matuschak 在常青笔记中的描述：“常青笔记的编写和组织是为了随着时间的推移不断进化、贡献和积累”，卢曼提到他的卡片盒笔记是内生长(internal growth)<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>的。</p><p>▷ 关于永久笔记奇怪的命名：<br>  “Code Primer” 来自于我的编程启蒙书《C++ Primer》，<br>  “Scriptorium”意为缮写室，中世纪制作书籍的地方<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></p><h2 id="03-永久笔记的结构"><a href="#03-永久笔记的结构" class="headerlink" title="03.永久笔记的结构"></a>03.永久笔记的结构</h2><p>上面提到了两个永久笔记目录，如下图，左边是专业知识的笔记，右边是兴趣爱好的笔记：<br><img src="/images/PKM-Permanent-notes-Directory.png" alt="PKM-Permanent-notes-Directory"></p><p><strong>笔记结构和格式有一套守则</strong>：</p><ul><li>每篇笔记的格式，遵循“原子笔记”：即一篇笔记说明白一件事情。<ul><li>但是不强制要求每篇笔记都是“原子”的。 当我们刚涉及一个领域时，可以只从一篇记录开始，这时候笔记中各种信息可能混杂在一起，并不“原子”。随着对这个了领域的深入，笔记的内容也会不断增加，同时对这个领域也有了初步了解，知道大概如何归类了，那这篇可能会被拆分开。</li><li>常青笔记<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>中提到，笔记是生长的，一篇笔记不仅可以添加内容、当然也可以再拆分、以及与其他笔记建立引用，总之让笔记体系变成更充实、更合理的形态，这样的笔记是具<strong>有生长性</strong>的。</li><li>一篇完整的原子笔记应该包括：唯一标识、正文（自己的理解，避免复制粘贴）、参考文献列表<br><img src="/images/PKM-Anatomy-note.png" alt="PKM-Anatomy-note"></li></ul></li></ul><ul><li>分类文件夹只有一级，不建立二级分类文件夹：如果某个文件夹下的笔记非常多，不得不建立二级分类的时候，我的选择是仍旧新建一级文件夹，例如 <code>📂 11.Programming-Language</code> 文件夹下是编程语言的笔记，因为我一直都在用Java，所以Java相关笔记的积累也非常多了，这时并不在 <code>📂 11.Programming-Language</code> 的下层再建立子文件夹，而是与之平级建立了<code>📂 12.Java</code>文件夹。 虽然听起来不符合“分类的层级”的常识，但是好处也很明显：<ul><li>可以避免树状结构太深，笔记被藏在很深的文件夹里容易被遗忘。对于树形的层级结构，思考 “我应该把笔记放在哪个层级下面？” 也是一种思维消耗，分类强迫症患者们会因此陷入到不停的分类工作里；</li><li>文件夹带数字前缀，让显示顺序符合自己的需求，同时也方便目录的扩展，父类别的子类可以从1a扩充到1a、1b… 它们依然有序</li><li>这套带序号的文件夹分类参照自杜威十进制分类法<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>，同样可以套用到 Evernote、Cubox、Zotero等等其他软件中，包括知乎收藏夹、浏览器收藏夹等等，这样自己所有的资料都用一套命名体系，很方便；</li><li>这种平铺单层文件夹更像卢曼的卡片盒，没见过卢曼用大盒套小盒吧，小盒套小小盒吧？</li><li>但是如果确实需要树形结构怎么办？看下面的文件命名规则</li></ul></li></ul><ul><li><p>笔记文件的命名：文件名加类别前缀，例如<code>Java.03b.GC案例分析.md</code> 这样一个文件名。可能有人会问，父文件夹名字叫<code>12.Java</code>，文件名里就不用以“Java”开头了吧？这样文件名里的“Java”是冗余信息啊。其实这里是特意而为，有个具体操作案例：Vscode里有个“文件名模糊搜索”功能，快捷键“Cmd + P”，我只需要搜索“Java  GC”，这样文件名里带“Java”和“GC”的所有笔记都会被搜出来，当然 Obsidian里也有类似功能，快捷键 Cmd + O。<br><img src="/images/PKM-Notes-Vscode-File-Fuzzy-Search.png" alt="Vscode文件名模糊搜索"><br>文件名的构成里除了表意的前缀，接下来还有序号，作用也是为了让相关联的笔记排序能凑在一起，同时递也方便笔记的“生长”，例如一个笔记内容太大需要拆分成2个笔记，新笔记的序号从1递增到1a即可，如果1a笔记又变大需要拆分，增加1b笔记即可。这些从一个笔记拆出来的众多子笔记，依然是保持有序的；</p><p>图： 左边是 卢曼的笔记编号系统说明（笔记是如何通过前缀保持有序增长的），右边是我的笔记编号：<br><img src="/images/PKM-Notes-Folgezettel-Sequence.png" alt="PKM-Notes-Folgezettel-Sequence.png"><br>上图说明了通过卢曼的编号体系，如何在同一层笔记中表示不同的层级关系：</p><ul><li>第一层概念：0 → 1 → 2 → 3， 这几个笔记是平级的概念</li><li>当“笔记1”有了子类别：1 → 1a → 1b，其中1a、1b都“笔记1”的子笔记，若1a也有了子笔记，就用1a1、1a2继续。</li></ul><p>通过这种命名方式组织笔记，文件夹下面的所有笔记看起来都“平铺”了，但仍可以通过文件名表达出分层的关系，也不会出现“深藏在某个子子子文件夹中的笔记”这种问题了。wiki百科里详细说明的这种方式 <a href="https://en.wikipedia.org/wiki/Zettelkasten" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Zettelkasten</a>, 卢曼的 <a href="https://luhmann.surge.sh/communicating-with-slip-boxes" target="_blank" rel="noopener">Communicating with Slip Boxes by Niklas Luhmann</a> 卢曼把上面的编号构成的“层” 成为slip（滑道）</p><p>“不过早对知识进行分类”，这也符合学习的习惯，刚开始接触某个领域可能只有一篇笔记，我们也不知道这个领域改如何分类，所以开始就不要想“刚开始就把笔记放在合适的分类层级上”，当随着学习的深入，笔记逐渐变大，这时候自然会拆分出新的子类别，让笔记“自然的生长”。</p></li></ul><ul><li>Markdown 中的章节是用<code>#</code> Heading来划分的，对于 Heading 的命名也有技巧，Vscode 里支持一种“Symbol 搜索”，Symbol 是什么呢？ 对于代码，Symbol 可以理解为函数名字，这个功能可以方便的在一个大的代码工程里快速搜索某个函数。Vscode里把 Markdown 的 Heading（标题） 当做 Symbol，所以在 Vscode里 按 “Cmd + T”，也可以进入 Markdown 标题的模糊搜索，快速定位 Heading。相对于上面的“文件名模糊搜索”，“标题模糊搜索”提供了比文件级别更细粒度的检索。至于如何用好这个功能，这就要求我们在书写笔记的时候，对 Heading的命名用一些心思了，要“言之有物”。<br><img src="/images/PKM-Notes-Vscode-Symbol-Fuzzy-Search.png" alt="Vscode Heading模糊搜索"><br>除了Vscode，像Atom、Sublime 等一众现代编辑器都有这个功能（标配），而 Obsidian 则需要通过插件 <a href="https://github.com/darlal/obsidian-switcher-plus" target="_blank" rel="noopener">obsidian-switcher-plus</a><sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup> 来实现。</li></ul><ul><li><p>双链引用：笔记的引用我用Obsidian 提供的<code>[[ ]]</code> ，Obsidian 默认是用 文件名作为链接名的，同时也提供对文件内的 Heading作为引用块，例如 <code>[[文件名.md#标题名]]</code>，如果修改文件名、或者拆分合并笔记，我就不用Vscode了，而是在 Obsidian里操作，让Obsidian 帮我自动更新引用。</p></li><li><p>笔记建立引用要克制，只有「笔记A」真的需要引用到「笔记B」的时候才建立两篇笔记的连接，“必要时”才链接，这也符合笔记“自然生长”的概念。<br>本来网状结构也是一种 MOC（map of content），帮自己理清思路的，胡乱建立双链是在毁掉自己的笔记系统，就像无章法的标签体系——最后只能废弃。这不叫自然生长，这叫胡乱配对；</p></li><li><p>标签：我不太用标签，也不强制标签的规则。但有个原则：如果通过文件夹已经是“明确的一个类别”，就不需要用这个类再建立标签了，这属于冗余信息。例如上面提到的，已经有了<code>Java</code>文件夹，就没必要再建立“Java”标签了，但“Java”表示不了的子分类，例如 Java下面还有更细的子类别：JVM、ClassLoader等等，这些倒是可以建标签</p></li><li><p>枢纽笔记：“除了索引表，卢曼还有另外一种非常重要的笔记：枢纽笔记(hub notes)<sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup>。枢纽笔记中列出了许多其他同属于某个主题的其他笔记”。说白了枢纽笔记就是一个索引，指向一组某主题的笔记。在 Obsidian 的 关系图谱里，枢纽笔记是一个中心化的节点，它本身没多少信息，只起一个索引的作用。但文件夹分类默认已经起到相同的作用了，每个文件夹下自然就是一个专题，所以对于这种情况就没必要建枢纽笔记，除非笔记跨了文件夹。<br>对于这类枢纽笔记，我都放在<code>📂 _index</code>文件夹中，在 Obsidian 的 关系图谱中，枢纽笔记向外的连线会很多，让整个图谱显得杂乱，这时候可以在图谱设置里排除掉这个 <code>📂 _index</code>文件夹（语法<code>-path:_index</code>），让关系图谱清爽一些。<br><img src="/images/PKM-Obs-Exclude-Index-Dir.png" alt="在 Obsidian 关系谱图中排除index目录"><br>除了按“某个主题”索引的枢纽笔记，也可以有按“时间线”索引的枢纽笔记，可以方便的看“我这个月记了什么”，当然这种笔记也不是一定要有的，看自己需求，同样也是放在<code>📂 _index</code>文件夹；</p></li></ul><p>至此，我的笔记体系的规则说完了，为什么要给自己的笔记格式立那么多规矩？ 不累么…<br>无论树状结构、网状结构、或者标签体系，如果管理不好最终都变垃圾场。还记得当年第一个笔记 App里加过的标签吗？ 现在看都不会再看一眼吧。</p><h3 id="03a-为什么用这样的笔记结构"><a href="#03a-为什么用这样的笔记结构" class="headerlink" title="03a.为什么用这样的笔记结构"></a>03a.为什么用这样的笔记结构</h3><p>综上，我的永久笔记的结构是：“<strong>单层目录的矮树状结构，同时使用双链构成稀疏的网状</strong>”。</p><p>至于为什么用这样的结构，还是要从传统的树状结构 和最近时兴的网状结构比较说起。</p><h4 id="03a1-网状结构-vs-树状结构"><a href="#03a1-网状结构-vs-树状结构" class="headerlink" title="03a1.网状结构 vs 树状结构"></a>03a1.网状结构 vs 树状结构</h4><p>像 RoamResearch、Logseq 这些笔记似乎已经完全放弃了目录，完全采取完全平铺的方式，通过网状结构展示各个笔记的关系，在笔记系统中，网状结构的特点：</p><ul><li>便于发现不同知识点的潜在联系，可以打破固有的树形概念结构，跨领域寻找联系；</li><li>创造和寻找灵感，发现新的研究方向；</li><li>劣势1，在树型层级中，我们很清楚知道两个节点表示上下级关系，但是在网状结构里，无法表示这种父子关系，仅仅知道二者“有关系”，这是纯网装结构在表达上的一种语义丢失。</li></ul><p>Notion、OneNote、Evernote、Trilium依然采用传统的属性结构，不同的是 EverNote的“文件夹”就是个“真文件夹”，什么信息都不能存储，而 Notion 的无限层级结构里，每个节点都是可以存储信息的。除了笔记之外还有<a href="https://zh.wikipedia.org/zh-cn/%E5%BF%83%E6%99%BA%E5%9B%BE" target="_blank" rel="noopener">思维导图</a>，也算是树状拓扑结构，总结一下树状结构的特点：</p><ul><li>在学习过程中，树状层级有利于理清概念，通过层级关系，我知道概念A是上义或整体性概念，概念B则是下义或更细小的概念；</li><li>树状分类方便检索，树状的生长方向是单向的，总是从“更上层的父级概念” =&gt; “子概念”，这种单向也方便概念的回溯（相比较而言，网状的方向的可能性就太多了）</li><li>树状结构的劣势1，所有新建的笔记都要思考一个问题：我要把它放哪个概念层才更合理？尤其对于刚刚开始入门的领域，上来就思考怎么分类是本末倒置的，当对这个领域逐渐掌握和熟悉，自然会知道“它属于哪儿”</li><li>树形结构的劣势2：严格的树形目录无法表示“一个笔记同时属于多个主题文件夹”的情况，如下图，这样用引用可以解决：“笔记1a”还是在“类别1”下面，但从“类别2”到“笔记1a”建立一个引用<br><img src="/images/PKM-Notes-Semilattice-Structure.png" alt=""></li></ul><p>不好的例子1：过于繁杂的树形结构，笔记很容易被遗忘在很深的目录中（试想这种情况下，当我们回顾笔记的时候，需要一层层打开目录，也不知道下一层还有什么），另外“分类再分类”也是一种心智负担：<br><img src="/images/PKM-Notes-Tree-Form-Badcase.png" alt="树形结构的坏例子"></p><p>不好的例子2：这样的网状结构，不是有效的MOC（Map of Content），这是细菌培养皿：<br><img src="/images/PKM-Notes-Grid-Form-Badcase.png" alt="网状结构的坏例子"></p><h4 id="03a2-结论是：两种结构我都要"><a href="#03a2-结论是：两种结构我都要" class="headerlink" title="03a2.结论是：两种结构我都要"></a>03a2.结论是：两种结构我都要</h4><p>树状结构便于检索和理清概念层级，很像我们理解知识的过程；<br>网状结构可以打破固有的层级结构，发现不同领域和层次知识间的联系，同时网状拓扑的建立也像新学习某个知识的过程。<br>这两种结构对于笔记体系都是有帮助的，所以都要。</p><p>同时通过上面不好的案例，我们发现，树状和网状的劣势都始于 <strong>用力过猛</strong>：比如过深的树状文件夹，比如迷宫一样的网状链接。所以，回到 03a这一章节的开始：我的永久笔记这部分的结构是 “<strong>单层目录的矮树状结构，同时使用双链构成稀疏的网状</strong>”</p><p><img src="/images/PKM-Notes.png" alt="../_images/PKM-Notes.png"></p><h2 id="04-其他使用技巧"><a href="#04-其他使用技巧" class="headerlink" title="04.其他使用技巧"></a>04.其他使用技巧</h2><ul><li><p>笔记除了书写，更多的使用场景是阅读，如果是在电脑上，我会用 Chrome 直接打开笔记目录，这里还需要一个 Chrome扩展：<a href="https://chrome.google.com/webstore/detail/markdown-preview-plus/febilkbfcbhebfnokafefeacimjdckgl" target="_blank" rel="noopener">Markdown Preview Plus</a>，可以把 Markdown 预览出来，支持多种主题。还支持 TOC 大纲，笔记的结构一目了然<br>  <img src="/images/PKM-Notes-Chrome-Reader.png" alt="Chrome 预览 Markdown"></p></li><li><p>笔记里我还会用一些“注解”，就是一些特殊语法，来帮助检索，比如如果我引用到了其他网页，会加 <code>@ref</code>标注一下，<br>例如 <code>@ref: [巧用分类法解决使用卡片笔记时遇到的困境](https://sspai.com/post/71274)</code>，<br>这样有什么好处呢，比如我想统计我的整个笔记库有多少网页引是来自sspai的文章，可以用 Shell命令行，在笔记根目录执行<code>grep -irn &quot;@ref&quot; **/*.md | grep &#39;sspai&#39; | wc -l</code>：<br><img src="/images/PKM-Notes-Annotation-for-Statistics.png" alt="Annotation-for-Statistics"></p></li><li><p>同样双链的<code>[[ ]]</code>也可以这样搜索：<code>egrep -irn &quot;\\[\\[.+\\]\\]&quot; **/*.md</code></p></li><li>此外，我会用其他的注解，例如 <code>@todo</code> =待办，<code>@toc</code> =内容大纲，<code>@tldr</code>=笔记精要… 等等，这些注解都不是标准的 Markdown 语法，这样写只是为了让自己的笔记有统一的格式，以及检索方便，因为 Vscode 的搜索都是基于单行的。</li></ul><h2 id="05-最后"><a href="#05-最后" class="headerlink" title="05.最后"></a>05.最后</h2><p>关于 #PKM (个人知识管理)，这个话题很大也很难用几篇文章说清楚，个人的知识管理体系可能终生都在更新迭代。除了笔记还包括工作流、文献管理等等太多的话题，这里只写一点跟“笔记”相关的，抛砖引玉。</p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">iCloud Drive的同步问题：如果发生了同步冲突，iCloud Drive的默认做法是存为一个快照，但并不通知用户发生了冲突，这会导致冲突的内容被吞掉了。对比 Dropbox的做法是生成一个“xxx的冲突版本”文件，提示让用户自己合并。显然 Dropbox的做法更适合做严格的文档同步器</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">MIT 认知科学家<em>Joshua</em> B. Tenenbaum 发表在<em>PNAS</em> 的论文中，比较了抽象知识的不同表征结构，如星形结构、聚类结构、环形结构等等，最终还是意识到人类的最佳知识结构是树形结构： <a href="https://www.pnas.org/doi/10.1073/pnas.0802631105" target="_blank" rel="noopener">The discovery of structural form | PNAS</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Hexo要求引用图片路径是绝对路径<code><img src="/image/example.png" alt=""></code>，我的笔记中引用图片用了相对路径<code><img src="/images/example.png" alt=""></code>，需要通过sed进行批处理转换：这是脚本 Gist：<a href="https://gitee.com/beefyheisenberg/codes/6oetg9d8mu3qh45fnvwzl79" target="_blank" rel="noopener">https://gitee.com/beefyheisenberg/codes/6oetg9d8mu3qh45fnvwzl79</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.zhihu.com/question/400660802/answer/1474845176" target="_blank" rel="noopener">什么是数字花园（Digital Garden）？ - 知乎</a> 对数字花园做了很好的诠释：“数字花园是介于笔记应用和博客应用之间的半公开数字展览馆，半公开指的不是读者没有权限阅览，而是很多想法只是相互关联的半成品，令他人难以轻易看懂。因为数字花园降低了对内容的要求，不强求作者将所有内容都打磨成文章级的成果，数字花园就会鼓励作者产出更多的内容，不拘一格降笔记”。</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">P.A.R.A. 四个字母分别代表 <strong>项目（Projects）— 领域(Areas) — 资源(Resources) — 档案(Archives)</strong> 四个顶级类别， 包括您在工作和生活中可能遇到的每种类型的信息。例如 Project类别的特点是有目标、有交付日期、会结束；Area 类别则是&quot;需要一直负责和维护的活动领域&quot;，例如工作中需要持续关注的领域，或者打算持续发展兴趣（健康/写作/营销等）。Forte上的原文链接：<a href="https://fortelabs.com/blog/para/" target="_blank" rel="noopener">The PARA Method: A Universal System for Organizing Digital Information - Forte Labs</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">卢曼的文献笔记样例和使用： <a href="https://forum.zettelkasten.de/discussion/1386/luhmanns-literatur-note-examples" target="_blank" rel="noopener">Luhmann’s Literatur Note Examples — Zettelkasten Forum</a></span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">卢曼提到卡片盒笔记是内增长的（internal growth）：<a href="https://luhmann.surge.sh/communicating-with-slip-boxes" target="_blank" rel="noopener">Communicating with Slip Boxes by Niklas Luhmann</a></span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">赫尔博斯说：“天堂是图书馆的模样”， <a href="https://www.amazon.com/%E7%BC%AE%E5%86%99%E5%AE%A4-%E5%8C%85%E6%85%A7%E6%80%A1/dp/B07G2WPF88" target="_blank" rel="noopener">《缮写室》</a>中说 “天堂是缮写室的模样” ，作者在外公那阴暗、并不宽绰的书房里遇到了各类文学作品。她将这里比喻为生命中的第一个缮写室（缮写室是欧洲中世纪制作书籍的场所）</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;">常青笔记 的概念来自Andy Matuschak的笔记： <a href="https://notes.andymatuschak.org/Evergreen_notes" target="_blank" rel="noopener">Evergreen notes</a> ，Andy本人可能在Obsidian上发布了常青笔记，将上面的笔记转为了 Obsidian库：<a href="https://publish.obsidian.md/andymatuschak/_Start+Here" target="_blank" rel="noopener">https://publish.obsidian.md/andymatuschak/<em>Start+Here</em></a>, 也可能是Anthony Gold获得授权后转置的</span><a href="#fnref:9" rev="footnote"> ↩</a></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">10.</span><span style="display: inline-block; vertical-align: top;"><a href="https://baike.baidu.com/item/%E6%9D%9C%E5%A8%81%E5%8D%81%E8%BF%9B%E5%88%B6%E5%9B%BE%E4%B9%A6%E5%88%86%E7%B1%BB%E6%B3%95/6273918" target="_blank" rel="noopener">杜威十进制图书分类法百度百科</a></span><a href="#fnref:10" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;">使用Obsidian 插件 switcher++实现 Vscode的符号搜索： 我给了快捷键 Cmd + R，呼出搜索框，直接是文件名模糊搜索， 输入<code>@</code>触发当前文件内搜索Heading, 输入<code>#</code>触发全库内搜索Heading</span><a href="#fnref:11" rev="footnote"> ↩</a></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">12.</span><span style="display: inline-block; vertical-align: top;">对卢曼的“枢纽笔记”的说明： <a href="https://zettelkasten.de/posts/zettelkasten-hubs/" target="_blank" rel="noopener">The Money Is in the Hubs: Johannes Schmidt on Luhmann’s Zettelkasten • Zettelkasten Method</a></span><a href="#fnref:12" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Logseq简单试用</title>
      <link href="/51.Productivity/Logseq%E7%AE%80%E5%8D%95%E8%AF%95%E7%94%A8/"/>
      <url>/51.Productivity/Logseq%E7%AE%80%E5%8D%95%E8%AF%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>Logseq书写方式类似于 <a href="https://workflowy.com/" target="_blank" rel="noopener">WorkFlowy</a>，一种可以无限缩进的、且支持折叠的列表作为书写方式 <a href="https://zhuanlan.zhihu.com/p/503704174" target="_blank" rel="noopener">大纲笔记软件 Workflowy 综合评测</a>；</li><li>Logseq同时支持 Markdown 以及 <a href="https://orgmode.org/" target="_blank" rel="noopener">Org-mode</a>；</li><li>Logseq把一个“笔记本库”叫Graph（图谱），Obsidian里则是“Vault”；</li><li>块（Block）是一段文字，也是 Logseq 的最小内容单位，可以认为 Markdown语法的 “列表”的一行就是一个 Block ，按<code>回车键</code>会自动创建一个新块</li><li>页（Page）包含许多块，一个页对应“pages”文件夹下的一个md文件；<ul><li>Logseq似乎完全放弃了文件夹层级这种结构，上面的操作只能创建一个<code>一个新页面%2F一个子页面</code>为名的md文件，在“全部页面”里二者是并列的，也没有显示上的层级性</li><li>如果想用 Logseq但又不想放弃树状文件夹层级，可以建一个索引页，用 list 和 sub-list模拟树状关系</li></ul></li><li>Card（记忆卡片） 和 Journals（日志）是两个内置功能，可以选择开启或关闭</li><li>如何使用 Logseq 的卡片功能：<ul><li>这是一个卡片的例子，带有<code>#card</code>标签的块，会变成一个卡片</li><li>卡片支持完形填空（cloze）的功能，输入<code>/cloze</code>即可进入</li><li>从左侧导航栏里的“卡片”可以列出所有的卡片</li></ul></li><li>如何使用 Logseq 的日志功能：<ul><li>每天自动生成一个新日志页面，点击左侧的“日志”即可开始书写，日志存储在 “journals”文件夹下，每天的日志对应一个md文件，例如“2022_09_15.md”</li></ul></li><li>其他功能：<ul><li>同步：<ul><li>Logseq 不包括云端服务，全部笔记都存储在本地库文件夹，可以使用 Dropbox、Git对笔记文件夹进行同步</li><li>Logseq（桌面版）还提供了周期 git commit 的功能</li><li>Logseq 有 iOS客户端，如果要同步数据，目前只能用 iCloud Drive（2022-09-15）</li></ul></li><li>页面引用：  Logseq 使用<code>[[wikilink]]</code>的方式来引用另一个页</li><li>块引用： 输入 <code>((</code>括号，然后输入以关联某块，例如 ((6322ef12-1529-4939-af2a-7840675787df))，可以看到<code>(())</code>里是一段类似uuid的代码，同时 Logseq会在被引用的块下面增加一行 <code>id:: 6322ef12-1529-4939-af2a-7840675787df</code>用以标注该块的唯一ID</li><li>标签：<ul><li>在 Logseq 中使用<code>#tag</code>来增加一个标签，与 Mkd 语法一致，例如： #Markdown</li><li>在创建一个标签后，Logseq 自动在“全部页面”里增加一个该标签为名的页面</li></ul></li><li>测试 Markdown 中的标题<code>#</code> ：<ul><li><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1></li><li>Markdown中的层级可以理解为一级标题 &gt; 二级标题 &gt; n级标题，内容的容器（包括列表块、代码块、普通文字块）都隶属于标题之下。但 Logseq的页面里，列表才是第一层级的容器</li></ul></li><li>测试贴图：默认图片附件在库的根目录下的assets文件夹</li></ul></li></ul><hr><p>@ref:</p><ul><li><a href="https://github.com/logseq/logseq" target="_blank" rel="noopener">GitHub - logseq/logseq: A privacy-first, open-source platform for knowledge management and collaboration. Desktop app download link: https://github.com/logseq/logseq/releases, roadmap: https://trello.com/b/8txSM12G/roadmap</a></li><li><a href="https://sspai.com/post/69503" target="_blank" rel="noopener">双链笔记软件推荐：Logseq 和它的五种用法 - 少数派</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PKM </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源项目源代码阅读指北</title>
      <link href="/41.Uncategorized/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E6%8C%87%E5%8C%97/"/>
      <url>/41.Uncategorized/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考 @ref: <a href="http://www.nosqlnotes.com/techpoints/how-to-read-opensource-code/" target="_blank" rel="noopener">Jaison - 阅读开源项目源码的建议姿势</a> </p></blockquote><h1 id="先选择合适的源码版本"><a href="#先选择合适的源码版本" class="headerlink" title="先选择合适的源码版本"></a>先选择合适的源码版本</h1><p>需要先审视自己的需求：“我阅读源码，是单纯的为了学习？还是希望在业务系统中更好的用好它？”</p><ul><li>如果是前者，那完全可以选择最新发布或待发布的稳定版本。</li><li>如果是后者，则需要选择自己业务系统中正在使用的版本。</li></ul><h1 id="快速了解架构和关键特性"><a href="#快速了解架构和关键特性" class="headerlink" title="快速了解架构和关键特性"></a>快速了解架构和关键特性</h1><p>如果有介绍原理的书籍，可以先快速浏览一遍，粗略了解整体架构、关键特性，同类、相似产品性能比较。<br>这些信息也可以从官方资料中一探究竟，尤其是架构介绍相关的章节。</p><h1 id="快速试用"><a href="#快速试用" class="headerlink" title="快速试用"></a>快速试用</h1><p>官方资料中的“Quick Start”章节，先学习如何使用，加强自己对于整体项目的感性认识。<br>基本能摸清楚利用该项目“<strong>能做什么</strong>”，以及“<strong>如何做</strong>”。当然，这里仅仅涉及了最基础的功能。<br>学习一个特性要从了解配置和如何使用着手，同时建议阅读相关特性的设计文档或网上已有的源码解析文章，这样可以在阅读源码时避免分散精力去看无关紧要的部分。</p><h1 id="开始阅读"><a href="#开始阅读" class="headerlink" title="开始阅读"></a>开始阅读</h1><h2 id="简单了解代码模块结构"><a href="#简单了解代码模块结构" class="headerlink" title="简单了解代码模块结构"></a>简单了解代码模块结构</h2><p>快速了解源码的模块组成结构，以及每一个模块的主要作用。这样有助于从源码结构上把握整体项目的结构，而后选择最基本的流程入手。</p><h2 id="避免过早陷入旁枝末节"><a href="#避免过早陷入旁枝末节" class="headerlink" title="避免过早陷入旁枝末节"></a>避免过早陷入旁枝末节</h2><p>摸清主线，避免过早陷入一些旁枝末节，我们在刚开始阅读源码时，会遇到很多”好奇点”：</p><blockquote><ul><li>这个算法居然实现的如此神奇？</li><li>这个数据结构怎么没有见过？</li><li>这个参数是干嘛的？</li></ul></blockquote><p>我自己也时常经不起这些”诱惑”，陷于对这些细节的考究中，常常”离题”半天以后，才被拉回到主线中。<br>在阅读源码的时候，能遇到一些感兴趣的细节是好事，但建议先将这些细节点记录下来，等过完整体流程以后再回头看这些细节，避免过早陷入。</p><h2 id="工具、时序图、日志和Debug"><a href="#工具、时序图、日志和Debug" class="headerlink" title="工具、时序图、日志和Debug"></a>工具、时序图、日志和Debug</h2><ol><li>借助合理工具。阅读源码过程中，通常需要动手做一些测试，此时，可以借助<code>jstack</code>工具(针对Java项目)，它能为你提供如下有价值的信息：<ul><li>线程模型</li><li>调用栈: 调用栈信息可以帮你理清整体调用流程(另外，在定位问题时，jstack打印出的信息也时常可以发挥重要作用)。</li></ul></li><li>重视阅读日志信息: 在进程启动或运行过程中，一些关键的操作或处理，都会记录日志信息，因此，阅读日志往往是一条有助于理清流程主线的捷径。</li><li>阅读源码过程中，同步绘制时序图，固化对流程的理解。好不容易摸清的主线，建议及时用时序图的方式固化下来，这样可以帮助自己快速回顾整个流程。</li><li>阅读源码过程中，不断发现或提出疑问，并且记下来。但不要当时就尝试去解决这些疑问，因为当时对代码的理解还不足以去解释这些疑问，结果很可能是费时费力但没成效，建议理清代码主线后再回头去解决这些疑问。</li><li>对于一些”莫名其妙“或”匪夷所思“的设计，请一定要对照参考社区问题单中的描述信息、设计文档或Comments信息。比如JDK源码里<code>HashMap</code>的默认负载因子为什么是0.75的注释。</li><li>阅读源码过程中，遇到晦涩难懂的细节，如何应对？此时，建议开启Debug模式，详细跟踪每一步的调用流程，</li><li>重视阅读测试用例源码，很多人并不习惯于阅读HBase的测试用例源码，其实，阅读测试用例的源码，可以帮你理解一些正确的行为应该是怎样的。</li><li>能力进阶：开始关注社区动态，或尝试为社区贡献Patch。关注社区动态，可以及时获知一些重要的Bugs或社区正在开发的大的Features。关注的方式包括但不限于：<ul><li>订阅社区的Mail List</li><li>关注社区的问题单</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 如何阅读源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式-RegExp</title>
      <link href="/41.Uncategorized/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-RegExp/"/>
      <url>/41.Uncategorized/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-RegExp/</url>
      
        <content type="html"><![CDATA[<p><img src="images/others/regexp.png" alt="RegEXp"></p><h1 id="正则表达式的流派"><a href="#正则表达式的流派" class="headerlink" title="正则表达式的流派"></a>正则表达式的流派</h1><p>正则的两个标准： Perl 和 POSIX 标准</p><ol><li>Perl标准(PCRE)： 标准概述： <a href="http://perldoc.perl.org/perlre.html#Regular-Expressions" target="_blank" rel="noopener">perlre - perldoc.perl.org</a>，只关注[The Basics] 和[Metacharacters] （元字符）这两节即可.<ul><li>正则表达式在线检测： <a href="https：//www.debuggex.com/">Debuggex</a></li></ul></li><li>Posix标准，包括两个流派：BRE（基本型正则表达式）和ERE（扩展型正则表达式）<ul><li>BRE： grep，sed，vi</li><li>ERE： egrep，awk，grep -E，</li></ul></li></ol><h1 id="Perl正则"><a href="#Perl正则" class="headerlink" title="Perl正则"></a>Perl正则</h1><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><pre><code>^表示行首，例如 ^abc 表示abc号开头的行; 或者不匹配 [^abc] 任意不是abc的$表示行尾，例如 333$ 表示已字符&quot;333&quot;结束的行;</code></pre><h2 id="次数"><a href="#次数" class="headerlink" title="次数"></a>次数</h2><pre><code>* 星号表示出现0次或N次，相当于{0,}，比如\$*b可以匹配&quot;b&quot;或者&quot;$$$b&quot;;? 表示出现0次~1次，相当于{0,1}+ 表示出现大于等于1次，相当于{1,}. 点号表示任何单个字符，换行符(\n)除外，点号可以与上面的次数符号组合，比如.*表示任何字符或没有字符</code></pre><h2 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h2><pre><code>例如 [AaEeIiOoUu] 表示一个表示所有元音字符的字符簇[a-z] // 匹配所有的小写字母[a-zA-Z] // 匹配所有的字母[0-9\.\-] // 匹配所有的数字，句号和减号注意： 前面曾经提到^表示字符串的开头，但它在字符簇里使用时，它表示&quot;非&quot;或&quot;排除&quot;的意思，[^0-9]指非数字</code></pre><h2 id="分组和其他"><a href="#分组和其他" class="headerlink" title="分组和其他"></a>分组和其他</h2><pre><code>小括号()表示分组， 例如 gr(a|e)y 匹配 &quot;gray&quot; 和 &quot;grey&quot;， (A\d){2} 匹配 &quot;A数字A数字&quot;；中括号[]表示匹配其中一个字符，例如 [Aa]匹配A或a，[3A-Z]匹配3或A~Z; [1-3a-f] 匹配1~3或a~f任意一个字符，[^0-9]表示非数字.大括号{m}表示出现m次，例如a{3}表示aaa，{n,m} 表示最少n次，最多m次；A|B 表示可能匹配A表达式或B表达式</code></pre><h2 id="字符类型-amp-特殊转义字符"><a href="#字符类型-amp-特殊转义字符" class="headerlink" title="字符类型 &amp; 特殊转义字符"></a>字符类型 &amp; 特殊转义字符</h2><pre><code>\w表示一个字母或数字，相当于[a-zA-Z|0-9]\W表示非一个字符或数字\b表示一个单词，位于\w和\W之间的东西\d表示数字，相当于[0-9]\D表示非数字，相当于[^0-9]\s表示空格\S表示非空格\l表示小写字符，\u表示大写字符\L表示非小写字符，\U表示非大写字符\n 换行符\t 制表符</code></pre><h1 id="POSIX正则"><a href="#POSIX正则" class="headerlink" title="POSIX正则"></a>POSIX正则</h1><p>Posix正则标准分为BRE和ERE，vi/grep/sed属于前者，awk属于后者，BRE与Perlb正则标准(PCRE)相差的更多一点，ERE与Perl标准相差比较小.<br>这里只记住几个例子就可以：</p><h2 id="vi-grep-sed中的正则："><a href="#vi-grep-sed中的正则：" class="headerlink" title="vi/grep/sed中的正则："></a>vi/grep/sed中的正则：</h2><pre><code>[0-9]\{1,3\}   表示数字0-9出现1-3次，注意 表示次数的大括号要转义，这点与Perl标准不同^[0-9]\+       表示数字至少出现一次，注意 这里的+号要加转义符 (星号，问号这些表示数量的符号，在POSIX也要转义)^[0-9].*[a-z]$ 表示数字开头并且小写字母结尾\&lt;ngx          表示ngx开头的单词，注意 perl里没有\&lt;的语法arg\&gt;          表示arg结尾的单词，注意 perl里没有\&gt;的语法\(int\|char\)  表示匹配&quot;int&quot;或&quot;char&quot;字符串，等效于perl标准的(int|char)，posix标准里的左右括号和|都要加转义</code></pre><blockquote><p>注： 上面用 <code>[]</code>中括号括起来的叫字符簇，参考 [[#字符簇]]</p></blockquote><p>从上面的几个例子可以看出，posix标准比perl标准的语法更繁琐，posix正则标准里的()|{}这些符号前要加转义符(吐槽下，这也是为什么POSIX正则不如Perl流行的原因吧)，</p><p>例如： 在vim里想用<code>^[0-9]+</code>搜索数字开头是搜不出来的，因为+号前面要加转义.</p><hr><h1 id="Java中的正则表达式"><a href="#Java中的正则表达式" class="headerlink" title="Java中的正则表达式"></a>Java中的正则表达式</h1><p>Java的正则语法与Perl标准基本一致，参考<a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">Pattern (Java Platform SE 7 )</a></p><h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><ol><li>常见的有<code>\n</code>，<code>\t</code>，<code>\&quot;</code>，<code>\\</code>，这些转义字符占1Char;</li><li>“ab\n”.length()返回3;</li><li>java字面表达式的写法和”编译器看到的”不一样，<code>a\\b</code> 在Java编译器看来是”a\b”;</li></ol><p>用Java字符串来写正则表达式，需要注意的转义符的使用：</p><ol><li>如果要匹配点，中小括号，星号等等，正则要加双转义符， <code>\\.</code>匹配点  <code>\\[</code>匹配左中括号</li><li>如果要匹配斜杠，要写成四个转义符<code>\\\\</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"a\\b"</span>; <span class="comment">// 实际字符串是'a\b',</span></span><br><span class="line">s1.replaceAll(<span class="string">"\\\\"</span>，<span class="string">""</span>); <span class="comment">// 要用正则匹配斜杠，正则表达式是双斜杠'\\' ，但如果写双斜杠，会被编译器认为是单斜杠，正则编译器并不认识单斜杠</span></span><br></pre></td></tr></table></figure><p>@ref <a href="http://unmi.cc/understand-java-regex-backslash/" target="_blank" rel="noopener">理解 Java 正则表达式怪异的 \ 和 \\，让您见怪不怪</a></p><h2 id="Pattern-amp-Matcher"><a href="#Pattern-amp-Matcher" class="headerlink" title="Pattern &amp; Matcher"></a>Pattern &amp; Matcher</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">Matcher m=p.matcher(<span class="string">"ICQ：456456 Tel：6710 Mail：aaa123@aaa.com"</span>);</span><br><span class="line"><span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">     System.out.println(m.group());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">456456</span></span><br><span class="line"><span class="comment">6710</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">maskEmoji</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern</span><br><span class="line">                .compile(<span class="string">"[^(\u2E80-\u9FFF\\w\\s`~!@#\\$%\\^&amp;\\*\\(\\)_+-？（）——=\\[\\]&#123;&#125;\\|;。，、《》”：；“！……’：‘\"&lt;,&gt;\\.?/\\\\*')]"</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            matcher.appendReplacement(sb，<span class="string">"[emoji："</span> + getUnicode(matcher.group(<span class="number">0</span>)) + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        matcher.appendTail(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Pattern捕获组"><a href="#Pattern捕获组" class="headerlink" title="Pattern捕获组"></a>Pattern捕获组</h3><p>Pattern用小括号包含的部分叫一个捕获组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String source = <span class="string">"http：//a.changyan.com/api/2/config/get/cy7hcbyIb?callback=383768658"</span>;</span><br><span class="line">String regex = <span class="string">"(http：//)(.*)/(config/get)/(\\w+\\?)(.*)"</span>; <span class="comment">// 5个捕获组</span></span><br><span class="line"></span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(source);</span><br><span class="line">System.out.println(<span class="string">"groupCount()="</span> + matcher.groupCount());</span><br><span class="line"><span class="keyword">if</span>(matcher.find() &amp;&amp; matcher.groupCount()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt;= matcher.groupCount(); i++) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"gounp[%d] = %s\n"</span>，i，matcher.group(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">groupCount()=5</span></span><br><span class="line"><span class="comment">group[0] = http：//a.changyan.com/api/2/config/get/cy7hcbyIb?callback=383768658</span></span><br><span class="line"><span class="comment">group[1] = http：//</span></span><br><span class="line"><span class="comment">group[2] = a.changyan.com/api/2</span></span><br><span class="line"><span class="comment">group[3] = config/get</span></span><br><span class="line"><span class="comment">group[4] = cy7hcbyIb?</span></span><br><span class="line"><span class="comment">group[5] = callback=383768658</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>捕获组可以递归的使用，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String reg = <span class="string">"((A)(B(C)))"</span>;  <span class="comment">// 包括4个捕获组，</span></span><br><span class="line">Pattern p = Pattern.compile(reg);</span><br><span class="line">Matcher matcher = pattern.matcher(string);</span><br><span class="line"><span class="comment">// 如果匹配，那么：</span></span><br><span class="line">matcher.group(<span class="number">1</span>) = ((A)(B(C)))</span><br><span class="line">matcher.group(<span class="number">2</span>) = (A)</span><br><span class="line">matcher.group(<span class="number">3</span>) = (B(C))</span><br><span class="line">matcher.group(<span class="number">4</span>) = (C)</span><br></pre></td></tr></table></figure><h3 id="appendReplacement"><a href="#appendReplacement" class="headerlink" title="appendReplacement"></a>appendReplacement</h3><ul><li>matcher.find();</li><li>matcher.appendReplacement(stringBuff，”xxx”); // 把当前匹配替换为param2，并append到param1字符串后面.</li></ul><h1 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h1><p>测试地址 <a href="https://www.debuggex.com/" target="_blank" rel="noopener">Debuggex： Online visual regex tester. JavaScript，Python，and PCRE.</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数字：    ^\d*$</span><br><span class="line">N位数字： ^\d&#123;N&#125;$</span><br><span class="line">IP地址： \d+\.\d+\.\d+\.\d+</span><br><span class="line">匹配/attachments目录下所有&quot;php&quot;结尾的行： /attachments/.*\.(php|php5)$</span><br><span class="line">邮箱，邮箱名可以出现.-符号： ^\w+([-_.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： ^[a-zA-Z]\w&#123;4,15&#125;$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全笔记</title>
      <link href="/41.Uncategorized/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/41.Uncategorized/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p><a href="../30MinsToturial/Java Tutorials.md">参考 Java Tutorials.md - (十七)安全</a></p><blockquote><p>Blowfish是1993年布鲁斯·施奈尔(Bruce Schneier)开发的对称密钥区块加密算法，区块长为64位，密钥为1至448位的可变长度。与DES等算法相比，其处理速度较快。因为其无须授权即可使用，作为一种自由授权的加密方式在SSH、文件加密软件等被广泛地使用</p></blockquote><p>bcrypt是根据Blowfish加密算法所设计的密码散列函数</p><h1 id="Salt"><a href="#Salt" class="headerlink" title="Salt"></a>Salt</h1><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>全称(Cross Site Scripting) 跨站脚本攻击</p><h1 id="安全-工具"><a href="#安全-工具" class="headerlink" title="安全/工具:"></a>安全/工具:</h1><ul><li>minidwep/aircrack: 破解WEP and WPA-PSK无线密码;  </li><li>ssltrip ssltrip;  </li></ul><h1 id="碰撞库"><a href="#碰撞库" class="headerlink" title="碰撞库"></a>碰撞库</h1><ul><li>cmd5.com</li></ul><h1 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h1><h2 id="OpenSSL心脏出血"><a href="#OpenSSL心脏出血" class="headerlink" title="OpenSSL心脏出血"></a>OpenSSL心脏出血</h2><p>SSL协议可以看作是一个理论，OpenSSL库用代码实现了这个”理论”。  </p><h2 id="Goagent的证书是否安全"><a href="#Goagent的证书是否安全" class="headerlink" title="Goagent的证书是否安全?"></a>Goagent的证书是否安全?</h2><h2 id="SSL如何防范中间人攻击"><a href="#SSL如何防范中间人攻击" class="headerlink" title="SSL如何防范中间人攻击?"></a>SSL如何防范中间人攻击?</h2><h1 id="社工"><a href="#社工" class="headerlink" title="社工"></a>社工</h1><h2 id="长尾关键词"><a href="#长尾关键词" class="headerlink" title="长尾关键词"></a>长尾关键词</h2><ul><li><a href="http://blog.jobbole.com/76714/" target="_blank" rel="noopener">http://blog.jobbole.com/76714/</a><ul><li><a href="http://www.pageadmin.net/seo/px/336.html" target="_blank" rel="noopener">在谷歌中如何挖掘长尾关键词-SEO学堂</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记</title>
      <link href="/41.Uncategorized/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
      <url>/41.Uncategorized/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h1><ul><li>Javascript绝对简明教程 <a href="http://wiki.woodpecker.org.cn/moin/jsInAWord" target="_blank" rel="noopener">http://wiki.woodpecker.org.cn/moin/jsInAWord</a></li><li>对Web标准的理解, 浏览器差异</li><li>HTML / CSS / JavaScript(基础, JS面向对象实现原理/闭包机制/作用域)</li><li>AngularJS / Ember.js / jQuery</li><li>Jade / Swig / Handlebars / Mustache 或者其它模板引擎</li><li>SASS 或者其它 CSS 预处理器</li><li>Js代码混淆 grunt/uglify</li></ul><h1 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h1><ul><li>各浏览器对常用或者错误的 Content-Type 类型处理方式 <a href="http://w3help.org/zh-cn/causes/CH9001" target="_blank" rel="noopener">http://w3help.org/zh-cn/causes/CH9001</a> or <a href="http://www.w3help.org/zh-cn/causes/CH9002" target="_blank" rel="noopener">http://www.w3help.org/zh-cn/causes/CH9002</a></li></ul><h1 id="P3P-Cookie"><a href="#P3P-Cookie" class="headerlink" title="P3P Cookie"></a>P3P Cookie</h1><p>假设这样的情况, 访问网页 a.com, 网页 a.com 通过 jsonp或 iframe访问了 &lt;b.com/set-cookie.php&gt;, 这个php里会set &lt;b.com&gt; 的 cookie.<br>如果 &lt;b.com/set-cookie.php&gt;里没有把 response设置 P3P头, 那么&lt;b.com/set-cookie.php&gt; 种cookie将会不成功 @ref <a href="http://www.lovelucy.info/ie-accept-third-party-cookie.html" target="_blank" rel="noopener">http://www.lovelucy.info/ie-accept-third-party-cookie.html</a></p><p>正确的做法, 如果&lt;b.com/set-cookie.php&gt;是一个(为第三方页面)种cookie的页面, 那么&lt;set-cookie.php&gt;要增加P3P头:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">header(<span class="string">'P3P:CP="IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT"'</span>);</span><br></pre></td></tr></table></figure><p>Java版本的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">"P3P"</span>,<span class="string">"CP='IDC DSP COR CURa ADMa OUR IND PHY ONL COM STA'"</span>);</span><br></pre></td></tr></table></figure><h1 id="CSP-Content-Security-Policy"><a href="#CSP-Content-Security-Policy" class="headerlink" title="CSP(Content Security Policy)"></a>CSP(Content Security Policy)</h1><ul><li>CSP可以防止什么: XSS(跨域脚本攻击)</li><li><p>如何启用CSP:</p><ul><li><p>返回的resp里带header “Content-Security-Policy”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: script-src &apos;self&apos;; object-src &apos;none&apos;;</span><br><span class="line">style-src cdn.example.org third-party.org; child-src https:</span><br></pre></td></tr></table></figure></li><li><p>网页的meta标签:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>@ref: Content Security Policy 入门教程 - 阮一峰的网络日志：<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/csp.html</a></p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>浏览器的同源策略 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><ul><li>a.com/1/xx.html | a.com/2/xx.html 同源</li><li><a href="https://a.com" target="_blank" rel="noopener">https://a.com</a>   | <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a>    不同源(协议不同)</li><li><a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a>       | cdn.a.com       不同源(子域不同)</li><li><a href="http://www.a.com:8080" target="_blank" rel="noopener">www.a.com:8080</a>  | <a href="http://www.a.com:80" target="_blank" rel="noopener">www.a.com:80</a>    不同源(端口不同)</li></ul><p>跨域资源共享 CORS 详解 - 阮一峰的网络日志：<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h2 id="资源加载跨域"><a href="#资源加载跨域" class="headerlink" title="资源加载跨域"></a>资源加载跨域</h2><p>原理：所有具有src属性的HTML标签都是可以跨域的<br>限制：需要创建一个DOM对象，只能用于GET方法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 常用的可以跨域的标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"..."</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="document-domain-iframe跨域"><a href="#document-domain-iframe跨域" class="headerlink" title="document.domain + iframe跨域"></a>document.domain + iframe跨域</h2><p>这种方式只针对相同主域名不同子域名下的页面才有效,<br>以(<a href="http://a.com/foo.html)和(http://cdn.a.com/bar.html)为例" target="_blank" rel="noopener">http://a.com/foo.html)和(http://cdn.a.com/bar.html)为例</a>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// URL http://a.com/foo.html</span></span><br><span class="line"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">ifr.src = <span class="string">'http://cdn.a.com/bar.html'</span>;  <span class="comment">// 这里跨域访问了cdn.a.com/bar</span></span><br><span class="line">ifr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ifrdoc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    ifrdoc.getElementsById(<span class="string">"foo"</span>).innerHTML);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ifr);</span><br></pre></td></tr></table></figure><p>只要在(<a href="http://cdn.a.com/bar.html)里加入声明" target="_blank" rel="noopener">http://cdn.a.com/bar.html)里加入声明</a>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.domain = &apos;a.com&apos; // 往上提了一级域名</span><br></pre></td></tr></table></figure></p><h2 id="ajax使用jsonp跨域"><a href="#ajax使用jsonp跨域" class="headerlink" title="ajax使用jsonp跨域"></a>ajax使用jsonp跨域</h2><p>jsonp 全称是JSON with Padding, 原理是客户端依靠<code>&lt;script src=&quot;...&quot;\&gt;</code>标签的src发起跨域请求, 远端服务器返回给客户端一段js代码, 这段js代码自动调用客户端的函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBooks</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type:<span class="string">'get'</span>,</span><br><span class="line">                url:<span class="string">'http://test.com/bookservice.php'</span>,</span><br><span class="line">                dataType:<span class="string">'jsonp'</span>,</span><br><span class="line">                jsonp:<span class="string">'callback'</span>,</span><br><span class="line">                jsonpCallback:<span class="string">'displayBooks'</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>参考: <a href="http://www.cnblogs.com/2050/p/3191744.html" target="_blank" rel="noopener">js中几种实用的跨域方法原理详解</a></p><h1 id="HTML简明参考"><a href="#HTML简明参考" class="headerlink" title="HTML简明参考"></a>HTML简明参考</h1><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>在一个页面上画一个按钮，有四种办法：</p><ul><li><code>&lt;input type=&quot;button&quot; /&gt;</code> 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。</li><li><code>&lt;input type=&quot;submit&quot; /&gt;</code> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。</li><li><code>&lt;button&gt;</code> 这个按钮放在 form 中也会点击自动提交，比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 value 值不同；可能还有其他的浏览器兼容问题。请始终为<code>&lt;button&gt;</code>规定 <code>type</code> 属性。Internet Explorer 的默认类型是 “button”，而其他浏览器中（包括 W3C 规范）的默认值是 “submit”。</li><li>其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。</li><li>参考<code>&lt;button&gt;和&lt;input type=&quot;button&quot;</code>的区别 (<a href="http://www.cnblogs.com/purediy/archive/2012/06/10/2544184.html" target="_blank" rel="noopener">http://www.cnblogs.com/purediy/archive/2012/06/10/2544184.html</a>)</li></ul><h1 id="JavaScript简明参考"><a href="#JavaScript简明参考" class="headerlink" title="JavaScript简明参考"></a>JavaScript简明参考</h1><p>参考: <a href="">JavaScript权威指南(第6版)</a></p><h2 id="匿名"><a href="#匿名" class="headerlink" title="匿名"></a>匿名</h2><ul><li>定义并执行 <code>(function(){})()</code>, function的小括号是必须的</li><li>定义: <code>var fnB = function(){ }</code></li></ul><h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><p>点击事件: <code>onclick</code></p><p>当用户进入或离开页面时，会触发 <code>onload</code> 和 <code>onunload</code> 事件.</p><ul><li>onload 事件可用于检查访客的浏览器类型和版本，以便基于这些信息来加载不同版本的网页。</li><li>onload 和 onunload 事件可用于处理 cookies。</li></ul><p>下面的例子展示了如何使用 onchange。当用户改变输入字段的内容时，将调用 upperCase() 函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;upperCase()&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><code>onmouseover</code> 和 <code>onmouseout</code> 事件可用于在鼠标指针移动到或离开元素时触发函数。</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS的「空格」和「-gt-」"><a href="#CSS的「空格」和「-gt-」" class="headerlink" title="CSS的「空格」和「&gt;」"></a>CSS的「空格」和「&gt;」</h2><ul><li>「&gt;」代表的是css3特有的子元素选择器（element&gt;element ）,「&gt;」是直接子元素</li><li>「空格」空格隔开表示从属包含关系，是当前的元素子元素,「空格」是所有子元素</li><li>「逗号」逗号隔开表示两个不同类的样式类名用同一个样式,</li></ul><h2 id="CSS的「点」和「-」"><a href="#CSS的「点」和「-」" class="headerlink" title="CSS的「点」和「#」"></a>CSS的「点」和「#」</h2><ul><li><p>「点」对应class</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.card &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>「井号」对应id :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Kard &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不加 对应html标签比如 ul,img,p</p></li></ul><p>Class与ID的区别:</p><ul><li>Class: Class是用来根据用户定义的标准对一个或多个元素进行定义的</li><li>ID: ID是定义页面上一个仅出现一次的标记</li></ul><h1 id="AJAX（Asynchronous-JavaScript-And-XML）"><a href="#AJAX（Asynchronous-JavaScript-And-XML）" class="headerlink" title="AJAX（Asynchronous JavaScript And XML）"></a>AJAX（Asynchronous JavaScript And XML）</h1><h2 id="chrome-dev-tool"><a href="#chrome-dev-tool" class="headerlink" title="chrome dev tool:"></a>chrome dev tool:</h2><ul><li>console : 输入<code>$</code> 判断是否有jquery (prototype)</li><li>console : 输入<code>$(&#39;#user_name&#39;)</code> 判断</li><li><code>$(&#39;#ABC #list_&#39;)</code> 寻找id=ABC, 再在子节点寻找id=list_</li><li><code>$(&#39;.ABC .list_&#39;)</code> 寻找class=ABC</li></ul><h1 id="前端调试"><a href="#前端调试" class="headerlink" title="前端调试"></a>前端调试</h1><ul><li><p>chrome调试工具:</p><ul><li>c-p：打开资源</li><li>fiddler替代chrome调试</li><li>通过chrome审核元素找div</li><li>chrome的console交互命令，找jQuery，找各种资源</li><li>把js保存位chrome书签</li></ul></li><li><p>conslole:</p><ol><li>console : 输入<code>$</code> 判断是否有jquery</li><li>console : 输入<code>$(&#39;#user_name&#39;)</code> 判断</li></ol></li><li><p>js断点：</p><ol><li>在chrome设置断点，要求这个js是可以缓存的</li><li>debugger</li><li>console.log(123)</li></ol></li><li><p>对于压缩的js如何处理</p></li><li><p>用finddle让浏览器解析本地js</p></li><li><p>补充: 五个你必须知道的javascript和web-debug技术</p></li></ul><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><ul><li><a href="http://www.zhihu.com/question/20790576" target="_blank" rel="noopener">如何用工程手段解决前端开发和部署优化的综合问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Html </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用NVM管理Node</title>
      <link href="/41.Uncategorized/%E4%BD%BF%E7%94%A8NVM%E7%AE%A1%E7%90%86Node/"/>
      <url>/41.Uncategorized/%E4%BD%BF%E7%94%A8NVM%E7%AE%A1%E7%90%86Node/</url>
      
        <content type="html"><![CDATA[<p>NVM = <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">Node Version Manager</a></p><p>安装NVM（zsh）参考： <a href="https://gist.github.com/mike-casas/6d489bebf48d89f5109cd1395aabe150" target="_blank" rel="noopener">install nvm on mac with zsh shell</a></p><p>输入<code>nvm v</code>查看当前 NVM 版本号，如果成功出现版本号，则代表安装成功</p><p>输入<code>nvm ls available</code>查看可以安装的 Node 版本</p><p>如果返回结果为N/A，解决办法：<a href="https://stackoverflow.com/questions/26476744/nvm-ls-remote-command-results-in-n-a" target="_blank" rel="noopener">https://stackoverflow.com/questions/26476744/nvm-ls-remote-command-results-in-n-a</a></p><p>安装指定版本 Node：<code>nvm install 12.17.0</code></p><p>切换到指定版本 Node：<code>nvm use 12.17.0</code></p><p>查看 Node版本：<code>node -v</code></p><p>查看已安装的 Node版本： <code>nvm ls</code></p>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hugo搭建博客</title>
      <link href="/41.Uncategorized/%E4%BD%BF%E7%94%A8Hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/41.Uncategorized/%E4%BD%BF%E7%94%A8Hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<ul><li>安装参考<br>  <a href="https://www.docsy.dev/docs/get-started/other-options/" target="_blank" rel="noopener">https://www.docsy.dev/docs/get-started/other-options/</a><br>  <a href="https://geekdocs.de/usage/getting-started/" target="_blank" rel="noopener">https://geekdocs.de/usage/getting-started/</a></li></ul><h2 id="1）首先安装-nvm"><a href="#1）首先安装-nvm" class="headerlink" title="1）首先安装 nvm"></a>1）首先安装 nvm</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">After install zsh</span><br><span class="line"></span><br><span class="line">- brew update</span><br><span class="line">- brew install nvm</span><br><span class="line">- mkdir ~/.nvm</span><br><span class="line"></span><br><span class="line">after in your ~/.zshrc or in .bash_profile if your use bash shell:</span><br><span class="line"></span><br><span class="line">    export NVM_DIR=~/.nvm</span><br><span class="line">    source $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure><h2 id="2）通过-NVM安装-Node-Lts稳定版"><a href="#2）通过-NVM安装-Node-Lts稳定版" class="headerlink" title="2）通过 NVM安装 Node Lts稳定版"></a>2）通过 NVM安装 Node Lts稳定版</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install --lts</span><br></pre></td></tr></table></figure><h2 id="3）安装-Hogo（使用docsy主题）"><a href="#3）安装-Hogo（使用docsy主题）" class="headerlink" title="3）安装 Hogo（使用docsy主题）"></a>3）安装 Hogo（使用docsy主题）</h2><ol><li><p>前置：需要安装一些 npm包，推荐切换到国内的 npm镜像：<a href="https://cnodejs.org/topic/4f9904f9407edba21468f31e" target="_blank" rel="noopener">https://cnodejs.org/topic/4f9904f9407edba21468f31e</a></p></li><li><p>前置：安装 hugo + npm（PostCSS等..）：<a href="https://www.docsy.dev/docs/get-started/docsy-as-module/installation-prerequisites/" target="_blank" rel="noopener">Before you begin | Docsy</a></p></li><li><p>docsy提供了几种安装方式，”Use Docsy as a Hugo Module”这种最简单：<a href="https://www.docsy.dev/docs/get-started/docsy-as-module/start-from-scratch/" target="_blank" rel="noopener">Create a new site: Start a new site from scratch | Docsy</a></p></li><li><p>docsy 配置，样例网站参考 <a href="https://www.docsy.dev/docs/examples/" target="_blank" rel="noopener">https://www.docsy.dev/docs/examples/</a>，选了一个最简洁的，也就是 Docsy自己的文档网站，config.yaml 等配置直接从 <a href="https://github.com/google/docsy" target="_blank" rel="noopener">https://github.com/google/docsy</a>上复制过来</p></li></ol><h2 id="Hugo命令参数说明"><a href="#Hugo命令参数说明" class="headerlink" title="Hugo命令参数说明"></a>Hugo命令参数说明</h2><p>hugo通用命令参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-h –help</span><br><span class="line">查看特定命令的帮助信息.</span><br><span class="line"></span><br><span class="line">-D –buildDrafts</span><br><span class="line">在生成静态网站, 或预览网站时, 草稿内容也会被展示出来.</span><br><span class="line"></span><br><span class="line">–config string</span><br><span class="line">指定新的配置文件, 在网站骨架根目录下面有一个默认的配置文件config.yaml|json|toml. hugo默认加载这个配置文件, 通过--config 配置文件路径可以指定新的配置文件.</span><br><span class="line"></span><br><span class="line">-c, –contentDir string</span><br><span class="line">hugo默认的存放内容文件的目录为content目录, -c 新的存放内容文件的目录路径 用于修改默认的存放路径. 也可以用新的内容文件目录生成网站.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开发工具（git, svn, screen, tmux）、IDE快捷键（Vim, Jetbrains, etc.）速查手册</title>
      <link href="/41.Uncategorized/Tools-and-IDE/"/>
      <url>/41.Uncategorized/Tools-and-IDE/</url>
      
        <content type="html"><![CDATA[<h1 id="值得尝试的新工具"><a href="#值得尝试的新工具" class="headerlink" title="值得尝试的新工具"></a>值得尝试的新工具</h1><ul><li>ag: 比grep、ack更快的递归搜索文件内容。</li><li>mycli: mysql客户端，支持语法高亮和命令补全，效果类似ipython，可以替代mysql命令。</li><li>shellcheck: shell脚本静态检查工具，能够识别语法错误以及不规范的写法。</li><li>cloc: 代码统计工具，能够统计代码的空行数、注释行、编程语言。</li></ul><h1 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h1><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>移动/跳转光标:</p><ul><li><code>H</code> <code>J</code> <code>K</code> <code>L</code>: ← ↓ ↑ →</li><li><code>0</code> : 移动光标至本行开头</li><li><code>$</code> : 移动光标至本行结尾</li><li><code>w</code> : 移动到下个单词( a.Properties算两个单词)</li><li><code>W</code> : 移动到下个单词(空格分隔的单词)</li><li><code>3w</code> : 光标向前移动3个单词</li><li><code>b</code> : 移动到上个单词, 如同w</li><li><code>B</code> : 移动到上个单词, 如同W</li><li><code>gg</code> : 移动到第一行</li><li><code>G</code> : 移动到最后一行</li><li><code>:133</code> : 跳到第133行</li><li><code>g;</code> 在最近所有修改处跳转</li><li><code>&#39;.</code> 跳转到最后修改的那一行</li></ul><p>编辑:</p><ul><li><code>i</code> : 在当前光标前面插入</li><li><code>I</code> : 在当前单词开头插入</li><li><code>a</code> : 在当前光标后面插入</li><li><code>A</code> : 在当前单词尾部插入</li><li><code>x</code> : 删除光标处字母</li><li><code>d0</code> : 删除到行首</li><li><code>d$</code> : 删除到行尾</li><li><code>dd</code> : 删除光标所在行</li><li><code>dw</code> : 删除光标所在单词</li><li><code>&gt;&gt;</code> : 增加缩进</li><li><code>&lt;&lt;</code> : 减少缩进</li></ul><p>搜索:</p><ul><li><code>fX</code> : 在本行搜索X</li><li><code>FX</code> : 在本行搜索X(向后搜索)</li><li><code>/Word</code> : 全文搜索</li><li><code>?Word</code> : 全文搜索(向后)</li></ul><p>粘贴/复制:</p><ul><li><code>y</code> :  复制选中的</li><li><code>yy</code> : 复制整行</li><li><code>p</code> : 粘贴</li><li><code>&quot;+y</code> : 复制到+寄存器</li><li><code>&quot;+p</code>: 粘贴+寄存器的内容</li></ul><p>补全:</p><ul><li><code>CTRL + N</code>: 智能补全</li><li><code>CTRL + X</code> , <code>CTRL + K</code> : 根据字典补全</li><li><code>CTRL + X</code> , <code>CTRL + U</code> : 用户自定义补全</li><li><code>CTRL + X</code> , <code>CTRL + F</code> : 文件名补全</li></ul><p>其他:</p><ul><li><code>v</code> : 进入选择模式</li><li><code>Shift + v</code> : 进入选择模式(行)</li><li><code>Ctrl + v</code> : 进入选择模式(列)</li></ul><p>vimdiff:</p><ul><li>启动: <code>vimdiff file1 file2</code></li><li>前一个: <code>[ + C</code></li><li>后一个: <code>] + C</code></li><li>在窗口间切换: <code>CTRL + W</code> <code>W</code></li><li>将当前复制到另一个: <code>dp</code>, dp 意为 diff “put” , 也可以使用命令<code>:diffput</code></li><li>将另一个复制到当前: <code>do</code>, do 意为 diff “obtain” , 也可以使用命令<code>:diffget</code>, 之所以不用dg，是因为dg已经被另一个命令占用了</li><li>重新比较: <code>:diffupdate</code></li></ul><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><ul><li>列模式: <code>shift + option + ↕️</code></li><li>快速打开: <code>⌘ + P</code></li><li>连续选中光标所在的单词: <code>⌘ + D</code></li></ul><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><p><strong>Shortcut key:</strong></p><ul><li><code>⌘ + P</code>: 快速打开文件</li><li><code>⌘ + R</code>: 打开纲要列表</li><li><code>⌘ + D/G</code>: 同步编辑/类似vim <code>#</code> and <code>*</code></li><li><code>⌘ + M</code>: 括号跳转</li><li><code>⌘ + F</code>: Enter查找下一个,<code>Shift + Enter</code>查找上一个</li><li><code>⌘ + X</code>: 删除当前行</li><li><code>⌘ + L</code>: 选择整行, 按住⌘继续按L则持续选择</li><li><code>⌘ + Shift + L</code>: 多行选中后, 同时编辑这些行</li><li><code>⌘ + 左键点击</code>: 多处同时编辑</li><li><code>Ctrl + G</code>: 跳转到行</li><li><code>Shift + Tab</code>: 折叠, 在看很长的Markdown文档时有用</li></ul><p><strong>Plugin:</strong></p><ul><li>Encoding: GBK Encoding Support, CovertToUTF8</li><li>Syntax Checker:<ul><li>Phpcs for sublime2 (<a href="http://alfred-long.iteye.com/blog/1668074" target="_blank" rel="noopener">http://alfred-long.iteye.com/blog/1668074</a>)</li><li>SublimeLinter(<a href="https://github.com/SublimeLinter" target="_blank" rel="noopener">https://github.com/SublimeLinter</a>) 检测代码语法错误,支持C/Java/Python:<ul><li>sublimelinter-php</li><li>sublimelinter-py</li><li>sublimelinter-json</li><li>sublimelinter-jscs</li><li>sublimelinter-cppcheck</li></ul></li></ul></li><li>SublimeCodeIntel(<a href="https://github.com/SublimeCodeIntel/SublimeCodeIntel" target="_blank" rel="noopener">https://github.com/SublimeCodeIntel/SublimeCodeIntel</a>) 代码补全, 定义跳转;</li><li>Alignment:格式化代码Ctrl+Alt+A;</li><li>SublimeCodeIntel:<ul><li>Jump to definition = Alt+Click</li><li>Jump to definition = Control+Super+Alt+Up</li><li>Go back = Control+Super+Alt+Left</li><li>Manual Code Intelligence = Control+Shift+space</li></ul></li></ul><h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><h2 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h2><p><strong>Editing（编辑）</strong></p><ul><li><code>Alt + Enter</code> : 显示建议/导入包 ⭐️</li><li><code>Control + Space</code> : 基本的代码补全（补全任何类、方法、变量） ⭐️</li><li><code>⌘ + J</code> : 插入自定义动态代码模板</li><li><code>⌘ + Alt + J</code> : 弹出模板选择窗口，将选定的代码使用动态模板包住</li><li><code>⌘ + Alt + T</code> : 把代码用if, for等代码块包起来(当前行或选定的行)</li><li><code>Ctrl + Alt + O</code> : 优化import ⭐️</li><li><code>⌘ + Alt + L</code> : 格式化代码 ⭐️</li><li><code>⌘ + /</code> : 注释/取消注释与行注释</li><li><code>⌘ + 加号</code> : 展开当前代码块</li><li><code>⌘ + 减号</code> : 折叠当前代码块</li><li><code>⌘ + Shift + 加号</code> : 展开所有代码块</li><li><code>⌘ + Shift + 减号</code> : 折叠所有代码块</li></ul><p><strong>Search/Replace（查询/替换）</strong></p><ul><li><code>Shift + Shift</code>: Search anywhere ⭐️</li><li><code>Ctrl + N</code>, <code>Ctrl + Shift + N</code>: 查找类, 查找文件</li><li><code>Ctrl + F</code>, <code>Ctrl + Shift + F</code>: search</li><li><code>F2</code> 或 <code>Shift+F2</code>: 上个/下个错误</li><li><code>F3</code> 或 <code>Shift+F3</code>: 上个/下个查找</li><li><code>Alt + F7</code>: find usage</li></ul><p><strong>Navigation（导航）</strong></p><ul><li><code>⌘  +  Alt + ←/→</code>:  Navigate back/forward</li><li><code>⌘ + E</code> : 显示最近打开的文件记录列表</li><li><code>⌘ + F12</code>: 弹出当前文件结构</li><li><code>Ctrl + H</code> : 显示类的继承层级（列出上下继承结构） ⭐️</li><li><code>⌘ + Shift + H</code>: 显示方法继承层级（例如显示某个抽象类的所有实现） ⭐️</li><li><code>Ctrl +  Alt + H</code>: 显示调用层次结构 ⭐️</li></ul><p><strong>VCS/Local History（版本控制/本地历史记录）</strong></p><ul><li><code>Command + K</code> : 提交代码到版本控制器 ⭐️</li></ul><p><strong>Refactoring（重构）</strong></p><ul><li><code>Shift + F6</code>: 重构</li></ul><p><strong>UI（界面）</strong></p><ul><li><code>⌘ + 1</code> : Project</li><li><code>⌘ + 7</code> : Structure</li><li><code>⌘ + 8</code> : Hierarchy</li><li><code>⌘ + 9</code> : Version Control</li></ul><p><strong>Plugins（插件）</strong></p><ul><li>Lombok</li></ul><ul><li>Code iris: 显示类的Diagrams</li><li>mongo4idea</li></ul><h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><ul><li>格式化代码 <code>⌘ + Option + L</code>  <code>Ctrl + Alt + L</code></li><li>删除行 <code>⌘ + Delete</code>  <code>Ctrl + Y</code></li><li>快捷生成结构体 <code>⌘ + Option + T</code>  <code>Ctrl + Alt + T</code></li><li>快捷覆写方法  <code>⌘ + O</code> <code>Ctrl + O</code></li><li>快捷定位到行首/尾 <code>⌘ + Left/Right</code>  <code>Ctrl + Left/Right</code></li><li>文件方法结构  <code>⌘ + F12</code> <code>Ctrl + F12</code></li><li>查找调用的位置 <code>Ctrl + Option + H</code> <code>Ctrl + Alt + H</code></li></ul><h2 id="PHPStorm（Win）"><a href="#PHPStorm（Win）" class="headerlink" title="PHPStorm（Win）"></a>PHPStorm（Win）</h2><ul><li><code>Ctrl + j</code> 常用的代码片段</li><li><code>Ctrl + Alt + 左右方向键</code>，定位到上一次编辑的位置</li><li><code>Ctrl + F12</code>，快速查看当前文件的所有方法</li><li><code>Ctrl + Alt + L</code>，格式化代码</li><li><code>Ctrl + N</code>，根据类名称查找</li><li><code>Ctrl + Shift + N</code>，根据文件名查找</li></ul><h2 id="Eclipse（Win）"><a href="#Eclipse（Win）" class="headerlink" title="Eclipse（Win）"></a>Eclipse（Win）</h2><p><strong>快捷键:</strong></p><ul><li><code>Alt+/</code>:  补全</li><li><code>Ctrl+1</code>: 快速修复建议</li><li><code>Ctrl+D</code>: 删除当前行</li><li><code>Ctrl+Del</code>: 删单词, 类似VIm的<code>daw</code></li><li><code>Ctrl+E</code>: 打开的标签之间切换</li><li><code>Ctrl+M</code>: 最大化当前的Edit或View, 配合F12(编辑窗口获得焦点), 可以立刻最大化代码编辑栏</li><li><code>Ctrl+L</code>: 定位在某行</li><li><code>Ctrl+K</code>: 选中的单词, 相当于Vim的<code>#</code>, 反向Ctrl+Shift+K</li><li><code>Ctrl+Q</code>: 定位到最后编辑的地方</li><li><code>Ctrl+O</code>: 快速显示 OutLine</li><li><code>Ctrl+T</code>: 快速显示当前类的继承结构</li><li><code>Ctrl+Shift+P</code>: 匹配括号</li><li><code>Ctrl+Shift+G</code>: 查找调用</li><li><code>F2</code>: 显示提示</li><li><code>F3</code>: 跳转定义</li><li><code>F4/Ctrl+O</code>: 打开继承, 只能看extends, 不能看implements</li><li><code>Ctrl+H</code>: 搜索</li><li><code>Ctrl+Alt+H</code>:   调用</li><li><code>Ctrl+Shift+R</code>: 搜索工程中的资源文件</li><li><code>Ctrl+Shift+T</code>: 搜索类（包括工程和关联的第三jar包）</li><li><code>Alt+Shift+R</code>: 自动的重命名一个类</li><li><code>Alt+Shift+I</code>: 自动内联选中的属性/方法</li><li><code>Alt+Shift+j</code>: 插入当前类/方法的注释</li><li><code>Ctrl+/</code> :     对选中的部分进行注释</li><li><code>Ctrl+Shift+/</code>: 对选中的部分块状注释</li><li><code>Ctrl+Shift+F</code>: 格式化代码</li><li><code>Ctrl+Shift+P</code>: 匹配括号</li></ul><p><strong>插件:</strong></p><ul><li>m2e</li><li>Egit</li></ul><h1 id="terminal-终端"><a href="#terminal-终端" class="headerlink" title="terminal(终端)"></a>terminal(终端)</h1><ul><li><code>Ctrl – a</code> ：移到行首</li><li><code>Ctrl – e</code> ：移到行尾</li></ul><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>Screen一个”会话”包括若干Windows, 每个Windows可被分割, 每个分割的区域可再创建新的Window</p><h3 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h3><ul><li><code>screen -ls</code> 查看已有的session</li><li><code>screen -r id</code> 连接已有的session</li><li><code>screen -S xx</code> 创建xxx为名字的session</li><li><code>c-a</code> <code>&quot;</code> 查看已打开的shell</li><li><code>c-a</code> <code>S</code> 上下分割当前Window, 分割出来的新Window没有运行任何Shell</li><li><code>c-a</code> <code>Tab</code> 切换到新Windows</li><li><code>c-a</code> <code>c</code> 创建新shell</li><li><code>c-a</code> <code>&quot;</code> 查看&amp;切换已经打开的shell</li><li><code>c-a</code> <code>d</code> 保存session并退出</li><li><code>c-a</code> <code>k</code> 杀死Window, 不可恢复</li></ul><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><ul><li><code>c-a</code> <code>c</code>: 创建一个window</li><li><code>c-a</code> <code>&quot;</code>: 查看已创建的windows列表</li><li><code>c-a</code> <code>d</code>: deattach 整个会话, 所有Windows</li><li><code>c-a</code> <code>k</code>: 关闭当前windos</li><li><code>c-a</code> <code>Tab</code>: 切换</li><li><code>c-a</code> <code>n/p</code>: switch</li><li><code>c-a</code> <code>0~9</code>: 按序号切换到window</li></ul><h3 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h3><ul><li><code>c-a</code> <code>S</code>  : 上下分割, c-a tab移动到下面的窗口, 然后c-a c创建新的</li><li><code>c-a</code> <code>|</code>  : 垂直分割</li></ul><h3 id="翻页-amp-复制"><a href="#翻页-amp-复制" class="headerlink" title="翻页&amp;复制"></a>翻页&amp;复制</h3><ul><li><code>c-a</code> <code>[</code>: 进入复制模式, 之后可以像vim里一样操作<code>h</code> <code>j</code> <code>k</code> <code>l</code>, <code>ctrl-b</code>, <code>ctrl-f</code>, 翻页</li><li>进入复制模式后, 空格开始选择, 空格结束</li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li><code>screen -S test1</code> : 创建名为test1的会话</li><li><code>screen -ls</code> ： 查看deattach的会话</li><li><code>screen -r id</code> ： 重新连接</li><li><code>screen -d -r id</code> : 如果上面的命令提示已经attach, 可以加-d参数先<code>deattach</code>再<code>attach</code></li><li><code>screem -X -S session_id quit</code> : 退出session, -X参数是执行的意思,执行quit命令.</li><li><code>rm -rf /var/run/screen/S-xxx</code> : 删除会话</li></ul><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><ul><li>`tmux new-session -s “sessionX” 创建会话</li><li>`tmux attach -t sessionX 恢复会话</li><li><code>c-b d</code> : 再输入tmux attach可以恢复会话</li><li><code>c-b &quot;</code> : 上下新建一个面板</li><li><code>c-b %</code>: 左右新建一个面板</li><li><code>c-b 方向</code>: 面板切换</li><li><code>c-b Page</code>: 进入翻页模式，此模式下可以用翻页键，q是退出翻页模式</li><li><code>c-b :</code>   : 输入<code>setw mode-mouse on</code> 设置鼠标滚轮</li><li><code>[</code> 复制模式</li><li><code>]</code> 粘贴模式</li></ul><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ul><li><code>git stash</code>: 暂存没有add的修改</li><li><code>git stash list</code>: 查看已经暂存的</li><li><code>git stash apply</code>: 应用暂存的修改到当前分支</li></ul><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">Git 工作流程 - 阮一峰的网络日志</a><ul><li>Git flow</li><li>Github flow</li></ul></li></ul><h2 id="checkout-amp-merge"><a href="#checkout-amp-merge" class="headerlink" title="checkout &amp; merge"></a>checkout &amp; merge</h2><p>1) <code>git clone</code> 检出代码:</p><ul><li>显示remote:(origin是远程库的名字)</li><li><code>git remote -v</code> 查看可以抓取和推送的origin的地址</li><li><code>git remote show origin</code>, 比上面的更详细, 可以看到git pull/push到的默认是哪个分支.</li></ul><p>2) <code>git checkout -b issue3 origin/master</code>, 从远端的master分支创建一个自己的分支issue3</p><ul><li>创建新分支并立即切换到新分支： <code>git checkout -b [name]</code><ul><li>如果这时候<code>git pull</code>从服务器拉新代码, 会失败并提示服务端的分支没有和新分支对应: <code>git branch --set-upstream-to=origin/master [分支名]</code></li></ul></li></ul><p>3) 合并源分支(issue3) 到远程目标分支(master)：</p><ul><li><code>git pull --rebase origin master</code>   // 在issue3分支pull最新的master代码</li><li><code>git checkout master</code>     // 切换到目标分支</li><li><code>git merge --no-ff issue3</code> // <code>--no-ff</code> 禁用 Fast forward模式, 这样删除分支后也不会丢掉分支信息</li><li><code>git push origin master</code></li><li>如果merge时出现冲突:<ul><li>修改冲突文件, 然后重新<code>git add confilct_file</code>(重新staged), 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域）。因为一旦暂存，就表示冲突已经解决。</li><li>然后不要忘了: <code>git commit -m &quot;conflict fixed&quot;</code></li><li>解决完冲突, push上去<code>git push origin master</code></li></ul></li></ul><p>4) 合并完成后, 删除开发分支：</p><ul><li><code>git branch -d &lt;branch_name&gt;</code> # 如果这个分支没有被merge,git会提示</li><li><code>git branch -D &lt;branch_name&gt;</code> # -D就是强行删除</li><li><code>git push origin --delete &lt;branch_name&gt;</code>如需要删除远程分支:</li></ul><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>➤ 用rebase 合并commit记录:</p><ul><li>使用<code>git rebase</code>有两种:<ul><li><code>git rebase -i HEAD~4</code> // 从HEAD开始往前4次commit合并成一个</li><li><code>git rebase -i star_commit end_commit</code> // 前开后闭区间, 合并范围不包括<code>start_commit</code>, 如果不写<code>end_commit</code>则默认是HEAD</li></ul></li><li><p>进入vi模式(for example: 第一个commit标记为pick, 后面几个commit标记为squash, 这样会把后几个commit合并到第一个), wq保存退出, git会合并commit历史<br><img src="git-rebase.png" alt="git-rebase.png"></p></li><li><p><code>git log --graph --pretty=oneline --abbrev-commit</code> 查看结果</p></li><li>如果发生冲突, 修改后 <code>git add .</code>, 然后 <code>git rebase --continue</code> ..</li><li>rebase完, <code>git log</code>查看一下合并结果, 然后推到远端分支 <code>git push -f origin &lt;branch&gt;</code></li></ul><p>➤ merge之前使用<code>git rebase</code>:</p><ul><li>切换到私有分支, 然后 <code>git rebase origin master</code> // 与<code>pull --rebase master</code>的区别?</li><li>如果有有冲突:<ul><li>修改冲突的文件, 然后 <code>git add file</code></li><li>修改完后, 不commit而是 <code>git rebase --continue</code></li><li>撤销此次Merge : <code>git rebase --skip</code> (可能多次)</li></ul></li><li><code>git checkout master</code></li><li><code>git merge issue3</code></li></ul><p>➤ <code>git rebase master</code>发生了什么?</p><ul><li>把issue3分支每个commit取消掉, 并把这些commit保存到.git/rebase下作为临时patch)</li><li>把当前分支(issue3)更新到最新的master</li><li>把步骤1的patch应用到当前分支</li><li>ps: 解决冲突后继续<code>git rebase --continue</code> // 继续应用剩下的patch</li></ul><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><ul><li><code>git cherry-pick &lt;commit_hash&gt;</code> // 把这次commit应用到 当前分支, ps支持多个提交(空格分隔)</li><li><code>git cherry-pick &lt;branch&gt;</code> // 把这个分支所有commit应用到 当前分支</li><li>如果 cherry-pick 出现冲突, 修改完冲突需要再执行:<ul><li><code>git add confilct_file</code></li><li><code>git commit -m &quot;conflict fix&quot;</code></li></ul></li></ul><h2 id="撤销和回滚"><a href="#撤销和回滚" class="headerlink" title="撤销和回滚"></a>撤销和回滚</h2><ul><li>修改了文件, 但还没有git add:  输入<code>git status</code>, 会提示用<code>git checkout -- file</code>丢弃工作区, 文件回到服务器状态;</li><li>修改并add了README.md, 还没有commit: 输入<code>git status</code>, 提示use <code>git reset HEAD filename</code> to unstage;</li><li>如果已commit/已merge: <code>git log -p -n 3</code> 查看最近3次历史, 记录下commit的哈希值, 然后执行 <code>git reset --hard commit_hashid</code></li><li><p>如果已push:</p><ul><li><code>git reflog</code> 查看 commit_hashid</li><li><code>git reset --hard commit_hashid</code></li><li><code>git push -f</code> // 把本地的修改强制推送到远程分支上</li><li><p>强制推送到mster可能会报错，意思是没有权限之类的错误，报错如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: GitLab: You don&apos;t have permission</span><br><span class="line">To git@10.255.223.213:code-ddreader/media-hapi.git</span><br><span class="line">! [remote rejected] master (pre-receive hook declined)</span><br></pre></td></tr></table></figure></li><li><p>是因为master分支一般会成为保护分支，所以我们首先要去除master为保护分支，才可以强推。</p></li></ul></li></ul><h2 id="有用的alias设置"><a href="#有用的alias设置" class="headerlink" title="有用的alias设置"></a>有用的alias设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.hist &quot;log --pretty=format:&apos;%h %ad | %s%d [%an]&apos; --graph --date=short&quot;</span><br></pre></td></tr></table></figure><p>以及: <code>git config --global core.autocrlf false</code> 使用LR而不是Win系统的CRLF</p><h2 id="当你把git弄的一团糟时"><a href="#当你把git弄的一团糟时" class="headerlink" title="当你把git弄的一团糟时"></a>当你把git弄的一团糟时</h2><p><img src="/images/others/git-pretty.png" alt=""></p><h1 id="svn"><a href="#svn" class="headerlink" title="svn"></a>svn</h1><ul><li><code>svn add file</code></li><li><code>svn commit -m &quot;xxx&quot;</code> : 提交修改</li><li><code>svn up</code>: 更新到最新版本</li><li><code>svn revert file</code>: 没commit时的撤销</li><li><code>svn log</code></li><li><code>svn merge -r 28:25 file</code>: 从当前28回滚到25</li></ul><h1 id="neovim-on-windows"><a href="#neovim-on-windows" class="headerlink" title="neovim on windows"></a>neovim on windows</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">choco sources add -source https://www.myget.org/F/equalsraf/ -name equalsraf</span><br><span class="line">choco install -pre neovim-qt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> IDE </tag>
            
            <tag> Vim </tag>
            
            <tag> Vimdiff </tag>
            
            <tag> IDEA </tag>
            
            <tag> Jetbrains </tag>
            
            <tag> Git </tag>
            
            <tag> svn </tag>
            
            <tag> screen </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM命令速查</title>
      <link href="/41.Uncategorized/NPM%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
      <url>/41.Uncategorized/NPM%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-install安装目录"><a href="#npm-install安装目录" class="headerlink" title="npm install安装目录"></a>npm install安装目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install xx  # 局部安装到当前目录node_moduels/</span><br><span class="line"></span><br><span class="line">npm install -g xx # 全局安装到全局目录，见“npm安装路径说明”</span><br></pre></td></tr></table></figure><p>npm安装路径说明：</p><p>默认的，npm 全局安装路径默认是： /usr/local/lib/node_modules</p><p>如果用NVM安装的Node，安装路径是 ~/.nvm/versions/node/v16.17.1/lib/node_modules</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看全局安装路径</span><br><span class="line">npm root -g</span><br><span class="line"></span><br><span class="line"># 查看npm的基础设置</span><br><span class="line">npm config ls</span><br><span class="line"></span><br><span class="line"># 查看安装目录路径</span><br><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm uninstall xxx</span><br><span class="line"></span><br><span class="line">npm update xxx</span><br><span class="line"></span><br><span class="line">npm cache clear #清空NPM本地缓存</span><br><span class="line"></span><br><span class="line"># 查看某个模块的版本号</span><br><span class="line">$ npm list grunt</span><br><span class="line"></span><br><span class="line"># 查看所有全局安装的模块</span><br><span class="line">npm list -g</span><br></pre></td></tr></table></figure><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>方案1：走代理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set proxy socks5://127.0.0.1:7892 &amp;&amp; npm config set https-proxy http://127.0.0.1:7892</span><br></pre></td></tr></table></figure></p><p>需要<code>npm get config registry</code> 确认不是用的国内源.. </p><p>使用国内镜像（3选1）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.通过config命令</span><br><span class="line"></span><br><span class="line">npm config set registry https://registry.npm.taobao.org </span><br><span class="line">npm info underscore （如果上面配置正确这个命令会有字符串response）</span><br><span class="line"></span><br><span class="line">2.命令行指定</span><br><span class="line"></span><br><span class="line">npm --registry https://registry.npm.taobao.org info underscore </span><br><span class="line"></span><br><span class="line">3.编辑 ~/.npmrc 加入下面内容</span><br><span class="line"></span><br><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github-Repo-Starred</title>
      <link href="/41.Uncategorized/Github-Repo-Starred/"/>
      <url>/41.Uncategorized/Github-Repo-Starred/</url>
      
        <content type="html"><![CDATA[<p>@todo</p><ul><li>High-performance event loop : such as libev;</li><li>PHP Framework;</li><li>Python mvc;</li></ul><h1 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h1><p><a href="https://github.com/WhatsDJGPP/STL" target="_blank" rel="noopener">STL</a> : STL笔记;</p><p><a href="http://git.oschina.net/whatsdjgpp/protothreads-port" target="_blank" rel="noopener">Protothreads</a> : 针对C语言封装后的宏函数库, 为C语言模拟了一种无堆栈的轻量线程环境, 能够实现模拟线程的条件阻塞、信号量操作等操作系统中特有的机制, 从而使程序实现多线程操作.</p><p><a href="https://github.com/google/leveldb" target="_blank" rel="noopener">LevelDB</a> : 由Google公司所研发的键／值对（Key/Value Pair）嵌入式数据库管理系统编程库.</p><p><a href="http://www.lua.org/download.html" target="_blank" rel="noopener">Lua</a> : Lua是一种轻量语言, 它的官方版本只包括一个精简的核心和最基本的库.</p><p><a href="https://github.com/nginx/nginx" target="_blank" rel="noopener">Nginx</a> : HTTP和反向代理服务器, 另外它也可以作为邮件代理服务器. 多进程模型、epoll异步, timer红黑树.</p><p><a href="https://github.com/michaelmior/libev" target="_blank" rel="noopener">Libev</a>  : Libev是一个C语言写的, 只支持linux系统的轻量级网络库. 阅读源码参考(<a href="http://dirlt.com/libev.html)" target="_blank" rel="noopener">http://dirlt.com/libev.html)</a>;</p><p><a href="https://github.com/libevent/libevent" target="_blank" rel="noopener">Libevent</a> :  An event notification library. libevent是一个事件触发的网络库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制。著名分布式缓存软件memcached也是libevent based.</p><p><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis</a> : 基于内存、键值对存储数据库, 使用ANSI C编写.</p><p><a href="https://github.com/memcached/memcached" target="_blank" rel="noopener">memcached</a> : C++ with C style, 多线程网络编程;</p><p><a href="https://github.com/lpereira/lwan" target="_blank" rel="noopener">lpereira/lwan</a> : C实现的Http服务器</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><a href="https://github.com/WhatsDJGPP/spring-framework" target="_blank" rel="noopener">Spring Framework</a> : Java EE全功能栈（full-stack）的应用程序框架；</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a href="https://github.com/python-git/python" target="_blank" rel="noopener">Python源码</a> 推荐几个模块:</p><ul><li>SocketServer(Lib/SocketServer.py)</li><li>SimpleHTTPServer(Lib/SimpleHTTPServer.py)</li><li>BaseHTTPServer(Lib/BaseHTTPServer.py)</li></ul><p><a href="https://github.com/goagent/goagent" target="_blank" rel="noopener">GoAgent</a> : a gae proxy;<br><a href="http://xlambda.com/gevent-tutorial/" target="_blank" rel="noopener">Gevent</a> : 基于libev的高性能Python并发库,为各种并发和网络相关任务提供了整洁的API;<br><a href="http://git.oschina.net/mktime/python-learn.git" target="_blank" rel="noopener">Py-Learn</a> : Fork it and Build your Python-Learning repos;<br><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">Requests</a> : Http库.</p><h2 id="Python-Web框架"><a href="#Python-Web框架" class="headerlink" title="Python Web框架"></a>Python Web框架</h2><p><a href="https://github.com/django/django" target="_blank" rel="noopener">Django</a>: Web应用框架,采用了MVC的软件设计模式.<br><a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">Tornado</a>: 可扩展的非阻塞式 web 服务器.<br><a href="https://github.com/mitsuhiko/flask" target="_blank" rel="noopener">flask</a></p><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><p><a href="https://github.com/scrapy/scrapy" target="_blank" rel="noopener">scrapy</a></p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p><a href="https://github.com/fabric/fabric" target="_blank" rel="noopener">fabric</a></p><h2 id="Python-微信"><a href="#Python-微信" class="headerlink" title="Python 微信"></a>Python 微信</h2><p><a href="https://github.com/whtsky/WeRoBot" target="_blank" rel="noopener">WeRoBot</a></p><h2 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h2><p><a href="https://github.com/kennethreitz/requests" target="_blank" rel="noopener">requests</a><br><a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="noopener">httpie</a></p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><pre><code>https://github.com/yiisoft/yii2https://github.com/laruence/php-yafhttps://github.com/WordPress/WordPress</code></pre><h1 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h1><pre><code>https://github.com/xicilion/fibjshttps://github.com/jquery/jquery</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://gitcafe.com/riku/Markdown-Syntax-CN" target="_blank" rel="noopener">Markdown语法</a><br><a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">简历模板</a></p>]]></content>
      
      
      <categories>
          
          <category> 41.Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能和神经网络101</title>
      <link href="/34.Machine-Learning/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%92%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C101/"/>
      <url>/34.Machine-Learning/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%92%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C101/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="https://www.youtube.com/watch?v=5A9bmW1qTpk" target="_blank" rel="noopener">机器能像人一样思考吗？人工智能（一）机器学习和神经网络 - YouTube</a></p><p><img src="/images/20220419220023.png" alt=""></p><h3 id="人工智能发展史"><a href="#人工智能发展史" class="headerlink" title="人工智能发展史"></a>人工智能发展史</h3><ul><li>1950：图灵测试提出（直到2014年才出现第一台通过图灵测试的程序）</li><li>1956：马文丶明斯基，约翰丶麦卡锡，香农 =&gt; 达特茅斯会议，第一次提出“AI”</li><li>1997：IBM深蓝战胜卡斯帕罗夫</li><li>辛顿（BP反向传播算法），杨立昆（CNN卷积神经网络），本吉奥获得2018年图灵奖</li></ul><p><img src="/images/20220419231717.png" alt=""></p><h3 id="线性拟合-amp-梯度下降算法"><a href="#线性拟合-amp-梯度下降算法" class="headerlink" title="线性拟合 &amp; 梯度下降算法"></a>线性拟合 &amp; 梯度下降算法</h3><p>先看一个例子：  给出m组数据（x1,y1）~（xm,ym）, 需要预测出y和x的函数关系.</p><p>线性拟合：「曲线拟合就是通过x,y的观测值来寻求参数b的最佳估计值，及寻求最佳的理论曲线y=f(x; b)。当函数y=f(x; b)为关于b的i线性函数时，称这种曲线拟合为线性拟合」<br>$$ y = wx +b $$</p><p><img src="/images/20220419231828.png" alt=""></p><p>拟合曲线和实际的y的差值是Δy_i，由此给出损失函数J（m是样本个数）：<br>$$ J = 1/2m ∑(Δy_i^2) = 1/2m ∑[y_i - (wx_i + b)]^2 $$</p><p>线性拟合的最优解, 即找到w（这里暂不考虑参数b）使J最小 ，<br>上例中只有2个参数，最小二乘可以解决，但是参数非常多就不适合了，这里需要<em>梯度下降算法</em></p><p>求偏导数:  $$  ∂y/∂w =&gt; w_{n+1} = w_n - η ∂y/∂w $$</p><p>通过多次迭代（从w0 →w1 →w2），找到到J最小时的w， 即<em>梯度下降是算法</em><br><img src="/images/20220419221501.png" alt=""><br>寻找参数最优值，使这也是模型训练的过程</p><blockquote><ul><li><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88/5511930" target="_blank" rel="noopener">线性拟合_百度百科</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="noopener">最小二乘法 - 维基百科，自由的百科全书</a><br><a href="https://www.zhihu.com/question/22470793" target="_blank" rel="noopener">微积分中，符号 d 与符号 ∂ 的区别是什么？ - 知乎</a></li></ul></blockquote><h3 id="神经网络-Neural-Network"><a href="#神经网络-Neural-Network" class="headerlink" title="神经网络(Neural Network)"></a>神经网络(Neural Network)</h3><p>典型神经元结构<br><img src="/images/20220423220706.png" alt=""></p><p>M-P模型：每个神经元都有多个输入端（X1~Xn），W1j~Wnj是每个输入的参数，一个输出端Oj（但可以输出给多个刺激）<br><img src="/images/20220419231401.png" alt=""></p><p>上图f即为激活函数（Sigmoid），决定是否向下一层输出，常用的如下：<br><img src="/images/20220423221008.png" alt=""></p><p>多个M-P模型的神经元组合为简单神经网络, 以及包含有更多隐层的多层神经网络(DNN):<br><img src="/images/20220423221116.png" alt=""></p><p>为了解决DNN调参复杂度(每层的链接对应的参数都需要调), 辛顿提出的反向传播(BP)算法:<br>从最后一层参数开始调, 然后调前一层的参数</p><blockquote><ul><li><a href="https://finance.sina.com.cn/tech/2021-02-24/doc-ikftssap8455930.shtml" target="_blank" rel="noopener">深度学习领域最常用的10个激活函数，一文详解数学原理及优缺点</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">卷积神经网络 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">反向传播算法 - 维基百科，自由的百科全书</a></li><li><a href="https://www.zhihu.com/question/27239198" target="_blank" rel="noopener">如何直观地解释 backpropagation 算法？ - 知乎</a></li></ul></blockquote><h3 id="卷积神经网络如何识别简单字母"><a href="#卷积神经网络如何识别简单字母" class="headerlink" title="卷积神经网络如何识别简单字母"></a>卷积神经网络如何识别简单字母</h3><p>卷积神经网络Convolutional Neural Networks</p><p>步骤1：卷积<br>    • 卷积核：通常是3x3 or 5x5<br>    • 原图像，对卷积核做卷积运算（每个位置相乘再相加，得到一个数）<br>    • 最终得到“特征图”</p><p><img src="/images/20220423222115.png" alt=""></p><p>步骤2：池化、激活<br>这里用最大池化法，四个为一组（左上角2-0-0-3），选出最大的3，作为新的特征图的一个点：<br><img src="/images/20220423222150.png" alt=""></p><p>对池化后的特征图，做激活处理：<br><img src="/images/20220423222254.png" alt=""></p><p><img src="/images/20220423222308.png" alt=""><br>    • 如果第一次卷积运算用了3个卷积核，那么会得到3个特征图（X-Y-Z）<br>    • 3个特征图做池化处理，进一步减少数据量<br>    • 3个特征图再次卷积运算(这次用了4个卷积核)，那么得到4个特征图</p><p>下图是第二次卷积 （输入=3个特征图，4个卷积核，每个核都是3维，输出=4个特征图）<br><img src="/images/20220423222329.png" alt=""></p><p>经过多次卷积，可以找到多种特征（线条、颜色等），输入到全连接网络进行训练<br><img src="/images/20220423222344.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 34.Machine-Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统</title>
      <link href="/34.Machine-Learning/RecommenderSystem-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/34.Machine-Learning/RecommenderSystem-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p><img src="/images/machine_learning/Recom-System-Arch.png" alt=""></p><h1 id="效果评估"><a href="#效果评估" class="headerlink" title="效果评估"></a>效果评估</h1><p>先了解一个概念: <strong>混淆矩阵</strong></p><p>混淆矩阵是用来总结一个分类器结果的矩阵。对于k元分类，其实它就是一个k x k的表格，用来记录分类器的预测结果。<br>对于最常见的二元分类来说，它的混淆矩阵是2乘2的，如下</p><p><img src="/images/machine_learning/recom-confusion-matrix.png" alt=""></p><p>TP = True Postive = 真阳性； FP = False Positive = 假阳性<br>FN = False Negative = 假阴性； TN = True Negative = 真阴性</p><p><strong>一般来说, 推荐效果的指标有:</strong></p><ul><li>准确率（Precision）和召回率（Recall）<br>设R(u)是根据用户在训练集上的行为给用户作出的推荐列表，而T(u)是用户在测试集上的行为列表。<br>对用户u推荐N个物品（记为R(u)），令用户u在测试集上喜欢的物品集合为T(u)，然后可以通过准确率/召回率评测推荐算法的精度：<br><img src="/images/machine_learning/recom-precision-recall.png" alt=""></li><li>F-score/F-measure<br>这是一种同时考虑准确率和召回率的指标。公式如下：<br><img src="/images/machine_learning/recom-f-score.png" alt=""><br>可以看出F的取值范围从0到1。另外还有一种F的变体如下所示：<br><img src="/images/machine_learning/recom-f-score2.png" alt=""><br>常用的两种设置是和，前者中recall重要程度是precision的两倍，后者则相反，precision重要程度是recall的两倍。</li><li>CTR（点击率）: CTR（Click-Through-Rate）即点击通过率，是互联网广告常用的术语，指网络广告（图片广告/文字广告/关键词广告/排名广告/视频广告等）的点击到达率，即该广告的实际点击次数（严格的来说，可以是到达目标页面的数量）除以广告的展现量（Show content）。</li><li>CVR（转化率）: CVR (Conversion Rate)即转化率。是一个衡量CPA广告效果的指标，简言之就是用户点击广告到成为一个有效激活或者注册甚至付费用户的转化率。<code>CVR=(转化量/点击量)*100%</code></li><li>停留时间(Duration)</li></ul><blockquote><p>@ref: <a href="https://www.cnblogs.com/shenxiaolin/p/9309749.html" target="_blank" rel="noopener">推荐系统排序（Ranking）评价指标 - CuriousZero - 博客园</a></p></blockquote><h1 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h1><p>推荐算法大致可以分为以下几类：</p><ul><li><p>①基于流行度的算法: 简单粗暴，类似于各大新闻、微博热榜等，根据PV、UV、日均PV或分享率等数据来按某种热度排序来推荐给用户。</p></li><li><p>②协同过滤算法(Collaborative Filtering, CF):</p><ul><li>Memory-based推荐：这两种方法都是将用户的所有数据读入到内存中进行运算的，因此成为Memory-based Collaborative Filtering。<br>Memory-based推荐方法通过执行最近邻搜索，把每一个Item或者User看成一个向量，计算其他所有Item或者User与它的相似度。有了Item或者User之间的两两相似度之后，就可以进行预测与推荐了。<br>CF算法简单原理是User喜欢那些具有相似兴趣的Users喜欢过的Items。包括：<ul><li>Item-based方法：基于用户的协同过滤算法（user-based collaboratIve filtering）；</li><li>User-based方法：基于Item的协同过滤算法（item-based collaborative filtering）；</li></ul></li><li>Model-based推荐（Model-based collaborative filtering）包括Aspect Model，pLSA，LDA，聚类，SVD，Matrix Factorization等，这种方法训练过程比较长，但是训练完成后，推荐过程比较快。<ul><li>Model-based推荐最常见的方法为Matrix factorization.</li><li>矩阵分解通过把原始的评分矩阵R分解为两个矩阵相乘，并且只考虑有评分的值，训练时不考虑missing项的值。R矩阵分解成为U与V两个矩阵后，评分矩阵R中missing的值就可以通过U矩阵中的某列和V矩阵的某行相乘得到</li><li>矩阵分解的目标函数: U矩阵与V矩阵的可以通过梯度下降(gradient descent)算法求得，通过交替更新u与v多次迭代收敛之后可求出U与V。</li><li>矩阵分解背后的核心思想，找到两个矩阵，它们相乘之后得到的那个矩阵的值，与评分矩阵R中有值的位置中的值尽可能接近。这样一来，分解出来的两个矩阵相乘就尽可能还原了评分矩阵R，因为有值的地方，值都相差得尽可能地小，那么missing的值通过这样的方式计算得到，比较符合趋势。</li></ul></li></ul></li></ul><blockquote><p>协同过滤中主要存在如下两个问题：稀疏性与冷启动问题。已有的方案通常会通过引入多个不同的数据源或者辅助信息(Side information)来解决这些问题，<br>用户的Side information可以是用户的基本个人信息、用户画像信息等，<br>而Item的Side information可以是物品的content信息等。</p></blockquote><ul><li><p>③基于内容的算法: 推荐用户有兴趣的Item在内容上类似的Item。利用word2vec一类工具，可以将文本的关键词聚类，然后根据topic将文本向量化。<br>这种方法可以避免Item的冷启动问题（冷启动：如果一个Item从没有被关注过，其他推荐算法则很少会去推荐，但是基于内容的推荐算法可以分析Item之间的关系，实现推荐），<br>弊端在于推荐的Item可能会重复，典型的就是新闻推荐</p></li><li><p>④基于模型的算法: LR, FM, DNN, CNN, RNN</p><ul><li>逻辑回归（Logistic Regression）是机器学习中的一种分类模型，由于算法的简单和高效，在实际中应用非常广泛。</li><li>因子分解机(Factorization Machine) 以下简称FM，是由Steffen Rendle在2010年提出的，模型主要通过特征组合来解决大规模稀疏数据的分类问题。</li><li>基于卷积神经网络（CNN）的推荐系统：此种系统中的卷积神经网络大多是用于特征提取（feature extraction）的；</li><li>基于循环神经网络（RNN）的推荐系统：循环神经网络特别适用于处理推荐系统中的评级和序列特征的时序动态；</li><li>基于深度语义相似性模型（Deep Semantic Similarity Model）的推荐系统：深度语义相似性模型（DSSM）是一种广泛应用于信息检索领域的深度神经网络。它非常适用于排行榜（top-n）推荐。基础型DSSM由MLP组成，更高级的神经层比如卷积层和最大池化（max-pooling）层可以被很容易地添加进去；</li></ul><blockquote><p>上面的FM, FFM, Deep FM都是基于CTR预估算法的</p></blockquote><p>下图总结了基于深度学习的推荐系统分类的二维体系，左侧部分对神经网络模型进行了说明，右侧部分则说明了整合模型。<br><img src="/images/machine_learning/Recom-System-Model.png" alt=""></p></li><li><p>⑤基于知识的推荐（Knowledge-based Recommendation）在某种程度是可以看成是一种推理（Inference）技术，它不是建立在用户需要和偏好基础上推荐的。<br>基于知识的方法因它们所用的功能知识不同而有明显区别。<br>效用知识（Functional Knowledge）是一种关于一个项目如何满足某一特定用户的知识，因此能解释需要和推荐的关系，<br>所以用户资料可以是任何能支持推理的知识结构，它可以是用户已经规范化的查询，也可以是一个更详细的用户需要的表示。<br><img src="/images/machine_learning/Recom-System-Knowledge-Based.png" alt=""></p></li></ul><h1 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h1><p>召回(recall): 推荐系统往往只推荐有限个（如k个）物品给某个用户。真正相匹配的物品我们称之为 <em>相关物品</em> （也就是二元分类中的阳性）。</p><ul><li>召回率(recall) = 所推荐的k个物品中相关物品的个数 ÷ 所有相关物品的个数</li><li>精度(precision) = 所推荐的k个物品中相关物品的个数 ÷ k<blockquote><p>比如说，根据你的喜好我们推荐了10个商品，其中真正相关的是5个商品。在所有商品当中，相关的商品一共有20个，那么：<br>召回率 = 5 / 20<br>精度 = 5 / 10</p></blockquote></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>推荐系统技能树:<br><img src="/images/machine_learning/AI-推荐系统技能树.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 34.Machine-Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Recommend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记：机器学习</title>
      <link href="/34.Machine-Learning/MachineLearning-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/34.Machine-Learning/MachineLearning-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/machine_learning/Machine-Learning-Title.png" alt=""></p><h1 id="机器学习入门"><a href="#机器学习入门" class="headerlink" title="机器学习入门"></a>机器学习入门</h1><ul><li><a href="https://developers.google.com/machine-learning/crash-course/prereqs-and-prework?hl=zh-cn" target="_blank" rel="noopener">Google机器学习速成课程</a></li><li><a href="https://github.com/MLEveryday/100-Days-Of-ML-Code" target="_blank" rel="noopener">机器学习100天</a></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>@ref: <a href="https://developers.google.com/machine-learning/glossary/?hl=zh-cn#f" target="_blank" rel="noopener">机器学习术语表  |  Google Developers</a> </p></blockquote><h3 id="基本-feature-label"><a href="#基本-feature-label" class="headerlink" title="基本(feature/label)"></a>基本(feature/label)</h3><ul><li>特征 (feature) : 在进行预测时使用的输入变量。特征是事物固有属性。</li><li>标签 (label): 标签是根据固有属性产生的认知，并不一定是事物本身所具有的属性。<br>在监督式学习中，标签指样本的“答案”或“结果”部分。有标签数据集中的每个样本都包含一个或多个特征以及一个标签。例如，在房屋数据集中，特征可能包括卧室数、卫生间数以及房龄，而标签则可能是房价。在垃圾邮件检测数据集中，特征可能包括主题行、发件人以及电子邮件本身，而标签则可能是“垃圾邮件”或“非垃圾邮件”。</li><li>权重 (weight):<br>线性模型中特征的系数，或深度网络中的边。训练线性模型的目标是确定每个特征的理想权重。如果权重为 0，则相应的特征对模型来说没有任何贡献。</li></ul><blockquote><p>标签是一个主观归纳性描述；特征则是一个客观的细节性描述。</p></blockquote><h3 id="监督-非监督-supervised-unsupervised"><a href="#监督-非监督-supervised-unsupervised" class="headerlink" title="监督/非监督(supervised/unsupervised)"></a>监督/非监督(supervised/unsupervised)</h3><ul><li>监督式机器学习 (supervised machine learning):<br>根据输入数据及其对应的标签来训练模型。监督式机器学习类似于学生通过研究一系列问题及其对应的答案来学习某个主题。在掌握了问题和答案之间的对应关系后，学生便可以回答关于同一主题的新问题（以前从未见过的问题）。请与非监督式机器学习进行比较。</li><li>非监督式机器学习 (unsupervised machine learning): 训练模型，以找出数据集（通常是无标签数据集）中的规律。<br>  非监督式机器学习最常见的用途是将数据分为不同的聚类，使相似的样本位于同一组中。例如，非监督式机器学习算法可以根据音乐的各种属性将歌曲分为不同的聚类。所得聚类可以作为其他机器学习算法（例如音乐推荐服务）的输入。在很难获取真标签的领域，聚类可能会非常有用。例如，在反滥用和反欺诈等领域，聚类有助于人们更好地了解相关数据。</li><li>半监督式学习 (semi-supervised learning):<br>训练模型时采用的数据中，某些训练样本有标签，而其他样本则没有标签。半监督式学习采用的一种技术是推断无标签样本的标签，然后使用推断出的标签进行训练，以创建新模型。如果获得有标签样本需要高昂的成本，而无标签样本则有很多，那么半监督式学习将非常有用。</li></ul><blockquote><p>监督式机器学习 vs 非监督式机器学习<br>最简单也最普遍的一类机器学习算法就是分类（classification）。对于分类，输入的训练数据有特征（feature），有标签（label）。所谓的学习，其本质就是找到特征和标签间的关系（mapping）。<br>这样当有特征而无标签的未知数据输入时，我们就可以通过已有的关系得到未知数据标签。<br>在上述的分类过程中，如果所有训练数据都有标签，则为有监督学习（supervised learning）。<br>如果数据没有标签，显然就是无监督学习（unsupervised learning）了，也即聚类（clustering）。<br>目前分类算法的效果还是不错的，但相对来讲，聚类算法就有些惨不忍睹了。确实，无监督学习本身的特点使其难以得到如分类一样近乎完美的结果。</p></blockquote><h3 id="特征-feature"><a href="#特征-feature" class="headerlink" title="特征(feature)"></a>特征(feature)</h3><ul><li>离散特征 (discrete feature)<br>一种特征，包含有限个可能值。例如，某个值只能是“动物”、“蔬菜”或“矿物”的特征便是一个离散特征（或分类特征）。与连续特征相对。</li><li>连续特征 (continuous feature)<br>一种浮点特征，可能值的区间不受限制。与离散特征相对。</li><li>稀疏特征 (sparse feature):<br>一种特征向量，其中的大多数值都为 0 或为空。例如，某个向量包含一个为 1 的值和一百万个为 0 的值，则该向量就属于稀疏向量。再举一个例子，搜索查询中的单词也可能属于稀疏特征 - 在某种指定语言中有很多可能的单词，但在某个指定的查询中仅包含其中几个。</li><li>密集特征 (dense feature)<br>一种大部分值是非零值的特征，通常是浮点值张量。与稀疏特征相对。</li></ul><h3 id="样本-example"><a href="#样本-example" class="headerlink" title="样本(example)"></a>样本(example)</h3><ul><li>有标签样本 (labeled example):<br>包含特征和标签的样本。在监督式训练中，模型从有标签样本中学习规律</li><li>无标签样本 (unlabeled example):<br>包含特征但没有标签的样本。无标签样本是用于进行推断的输入内容。在半监督式和非监督式学习中，在训练期间会使用无标签样本。</li></ul><h3 id="集-set"><a href="#集-set" class="headerlink" title="集(set)"></a>集(set)</h3><ul><li>训练集 (training set):<br>数据集的子集，用于训练模型。与验证集和测试集相对。</li><li>测试集 (test set):<br>数据集的子集，用于在模型经由验证集的初步验证之后测试模型。</li><li>验证集 (validation set):<br>数据集的一个子集，从训练集分离而来，用于调整超参数。</li></ul><h3 id="模型-model"><a href="#模型-model" class="headerlink" title="模型(model)"></a>模型(model)</h3><ul><li><p>模型 (model): 机器学习系统从训练数据学到的内容的表示形式。多含义术语，可以理解为下列两种相关含义之一：</p><ul><li>一种 TensorFlow 图，用于表示预测的计算结构。</li><li>该 TensorFlow 图的特定权重和偏差，通过训练决定。</li></ul></li><li><p>分类模型 (classification model):<br>一种机器学习模型，用于区分两种或多种离散类别。例如，某个自然语言处理分类模型可以确定输入的句子是法语、西班牙语还是意大利语。请与回归模型进行比较。</p></li><li><p>回归模型 (regression model):<br>一种模型，能够输出连续的值（通常为浮点值）。请与分类模型进行比较，分类模型会输出离散值。</p></li><li><p>广义线性模型 (generalized linear model)<br>最小二乘回归模型（基于高斯噪声）向其他类型的模型（基于其他类型的噪声，例如泊松噪声或分类噪声）进行的一种泛化。<br>广义线性模型的功能受其特征的限制。与深度模型不同，广义线性模型无法“学习新特征”。<br>广义线性模型具有以下特性：</p><ul><li>最优的最小二乘回归模型的平均预测结果等于训练数据的平均标签。</li><li>最优的逻辑回归模型预测的平均概率等于训练数据的平均标签。<br>广义线性模型的示例包括：</li><li>逻辑回归 /LR (logistic regression): 一种模型，通过将 S 型函数应用于线性预测，生成分类问题中每个可能的离散标签值的概率。虽然逻辑回归经常用于二元分类问题，但也可用于多类别分类问题（其叫法变为多类别逻辑回归或多项回归）。</li><li>多类别回归:</li><li>最小二乘回归:</li></ul></li><li><p>宽度模型 (wide model)<br>一种线性模型，通常有很多稀疏输入特征。我们之所以称之为“宽度模型”，是因为这是一种特殊类型的神经网络，其大量输入均直接与输出节点相连。与深度模型相比，宽度模型通常更易于调试和检查。虽然宽度模型无法通过隐藏层来表示非线性关系，但可以利用特征组合、分桶等转换以不同的方式为非线性关系建模。</p></li><li><p>深度模型 (deep model)<br>一种神经网络，其中包含多个隐藏层。深度模型依赖于可训练的非线性关系。</p></li></ul><h3 id="模型训练-model-training"><a href="#模型训练-model-training" class="headerlink" title="模型训练(model training)"></a>模型训练(model training)</h3><ul><li>模型训练 (model training):<br>确定最佳模型的过程。</li><li>迭代 (iteration):<br>模型的权重在训练期间的一次更新。迭代包含计算参数在单批次数据上的梯度损失。</li><li>批次 (batch):<br>模型训练的一次迭代（即一次梯度更新）中使用的样本集。</li><li>批次大小 (batch size):<br> 一个批次中的样本数。例如，SGD 的批次大小为 1，而小批次的大小通常介于 10 到 1000 之间。批次大小在训练和推断期间通常是固定的；不过，TensorFlow 允许使用动态批次大小。</li></ul><h3 id="函数-function"><a href="#函数-function" class="headerlink" title="函数(function)"></a>函数(function)</h3><ul><li>激活函数 (activation function):<br>一种函数（例如 ReLU 或 S 型函数），用于对上一层的所有输入求加权和，然后生成一个输出值（通常为非线性值），并将其传递给下一层。</li><li>S 型函数 (sigmoid function):<br>一种函数，可将逻辑回归输出或多项回归输出（对数几率）映射到概率，以返回介于 0 到 1 之间的值。S 型函数的公式如下：<br><img src="/images/machine_learning/ML-Glossary-SFunc.png" alt=""><br>在逻辑回归问题中， σ 非常简单：<br><img src="/images/machine_learning/ML-Glossary-LR-SFunc.png" alt=""><br>换句话说，S 型函数可将  转换为介于 0 到 1 之间的概率。在某些神经网络中，S 型函数可作为激活函数使用。</li><li>修正线性单元 (ReLU, Rectified Linear Unit):<br>一种激活函数，其规则如下：<ul><li>如果输入为负数或 0，则输出 0。</li><li>如果输入为正数，则输出等于输入。</li></ul></li></ul><h3 id="正反-positive-negative"><a href="#正反-positive-negative" class="headerlink" title="正反(positive/negative)"></a>正反(positive/negative)</h3><ul><li>正类别 (positive class):<br>在二元分类中，两种可能的类别分别被标记为正类别和负类别。正类别结果是我们要测试的对象。（不可否认的是，我们会同时测试这两种结果，但只关注正类别结果。）例如，在电子邮件分类器中，正类别可以是“垃圾邮件”。</li><li><p>负类别 (negative class):<br>在二元分类中，一种类别称为正类别，另一种类别称为负类别。正类别是我们要寻找的类别，负类别则是另一种可能性。例如，在医学检查中，负类别可以是“非肿瘤”。在电子邮件分类器中，负类别可以是“非垃圾邮件”。另请参阅正类别。</p></li><li><p>正例 (TP, true positive):<br>被模型正确地预测为正类别的样本。例如，模型推断出某封电子邮件是垃圾邮件，而该电子邮件确实是垃圾邮件。</p></li><li>负例 (TN, true negative):<br>被模型正确地预测为负类别的样本。例如，模型推断出某封电子邮件不是垃圾邮件，而该电子邮件确实不是垃圾邮件。</li><li>假正例 (FP, false positive):<br>被模型错误地预测为正类别的样本。例如，模型推断出某封电子邮件是垃圾邮件（正类别），但该电子邮件其实不是垃圾邮件。</li><li><p>假负例 (FN, false negative):<br>被模型错误地预测为负类别的样本。例如，模型推断出某封电子邮件不是垃圾邮件（负类别），但该电子邮件其实是垃圾邮件。</p></li><li><p>混淆矩阵 (confusion matrix):<br>一种 NxN 表格，用于总结分类模型的预测效果；即标签和模型预测的分类之间的关联。在混淆矩阵中，一个轴表示模型预测的标签，另一个轴表示实际标签。N 表示类别个数。在二元分类问题中，N=2。</p></li><li>精确率 (precision):<br>一种分类模型指标。精确率指模型正确预测正类别的频率，即：<br>正例数 / 正例数 + 假正例数</li><li>召回率 (recall): 用于回答以下问题：在所有可能的正类别标签中，模型正确地识别出了多少个？即<br>召回率 = 正例数 / (正例数 + 假负例数)</li></ul><h3 id="未分类概念"><a href="#未分类概念" class="headerlink" title="未分类概念"></a>未分类概念</h3><ul><li><p>协同过滤 (collaborative filtering): 根据很多其他用户的兴趣来预测某位用户的兴趣。协同过滤通常用在推荐系统中。<br>协同过滤推荐是目前业界常用的推荐算法之一。协同过滤推荐是利用users和items的关系矩阵来对user和item进行建模，从而进行推荐的一类算法。其主要分为两种：基于user的协同过滤推荐和基于item的协同过滤推荐。</p></li><li><p>DAG: 在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。<br><img src="https://zh.wikipedia.org/wiki/File:Directed_acyclic_graph_3.svg" alt="ML-Glossary-DAG"></p></li><li><p>反向传播算法 (backpropagation)<br>在神经网络上执行梯度下降法的主要算法。该算法会先按前向传播方式计算（并缓存）每个节点的输出值，然后再按反向传播遍历图的方式计算损失函数值相对于每个参数的偏导数。</p></li></ul><h2 id="机器学习系统分类"><a href="#机器学习系统分类" class="headerlink" title="机器学习系统分类"></a>机器学习系统分类</h2><p>机器学习有多种类型，可以根据如下规则进行分类：</p><ul><li>是否在人类监督下进行训练（监督，非监督，半监督和强化学习）</li><li>是否可以动态渐进学习（在线学习 vs批量学习）</li><li>它们是否只是通过简单地比较新的数据点和已知的数据点，或者在训练数据中进行模式识别，以建立一个预测模型，就像科学家所做的那样（基于实例学习 vs基于模型学习）</li></ul><h3 id="监督-非监督学习"><a href="#监督-非监督学习" class="headerlink" title="监督/非监督学习"></a>监督/非监督学习</h3><p>监督学习主要有两个常见的典型的任务–分类和回归。</p><h4 id="a-监督学习"><a href="#a-监督学习" class="headerlink" title="a.监督学习"></a>a.监督学习</h4><h5 id="分类-classification"><a href="#分类-classification" class="headerlink" title="分类(classification)"></a>分类(classification)</h5><p>分类问题主要就是预测新数据的类别问题。<br>例如上文提到的垃圾邮件过滤器就是一个二分类问题，将邮件分为垃圾邮件还是正常的邮件，如下图所示。</p><p><img src="/images/machine_learning/ml_classification_example.png" alt=""></p><h5 id="回归-regression"><a href="#回归-regression" class="headerlink" title="回归(regression)"></a>回归(regression)</h5><p>回归问题主要是预测目标数值。<br>比如给定预测房价的问题，给定一些特征，如房子大小、房间数量、地理位置等等，然后预测房子的价格。如下图所示：</p><p><img src="/images/machine_learning/ml_regression_example.png" alt=""></p><h4 id="b-非监督学习"><a href="#b-非监督学习" class="headerlink" title="b.非监督学习"></a>b.非监督学习</h4><p>非监督主要有四个典型的任务，分别是聚类、降维、异常检测和关联规则学习。</p><h5 id="聚类-clustering"><a href="#聚类-clustering" class="headerlink" title="聚类 (clustering)"></a>聚类 (clustering)</h5><p>聚类就是将数据根据一定的规则分成多个类，通常是采用相似性。<br>比如对于博客访客的聚类，通过聚类算法，检测相似性访客的分组，如下图所示。不需要告诉算法访客是哪个类别，它会自动根据访客的属性找到相互间的关系</p><p><img src="/images/machine_learning/ml_clustering_example.png" alt=""></p><h5 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h5><p>降维的目的是简化数据、但是不能失去大部分信息。做法之一是合并若干相关的特征。<br>例如，汽车的里程数与车龄高度相关，降维算法就会将它们合并成一个，表示汽车的磨损。这叫做特征提取。</p><p>此外，在采用机器学习算法训练的时候，可以对训练集进行降维，这样有助于提高训练速度，降低占用的硬盘和内存空间，有时候也能提高算法的性能，但必须选择合适的降维算法，否则性能实际上是很有可能会下降的。</p><h5 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h5><p>另一个重要的非监督任务是异常检测（anomaly detection）。例如，检测异常的信用卡转账以防欺诈，检测制造缺陷，或者在训练之前自动从训练数据集去除异常值。异常检测的系统使用正常值训练的，当它碰到一个新实例，它可以判断这个新实例是像正常值还是异常值。</p><p><img src="/images/machine_learning/ml_anomaly_example.png" alt=""></p><h5 id="关联规则学习"><a href="#关联规则学习" class="headerlink" title="关联规则学习"></a>关联规则学习</h5><p>最后，另一个常见的非监督任务是关联规则学习，它的目标是挖掘大量数据以发现属性间有趣的关系。<br>例如，假设你拥有一个超市。在销售日志上运行关联规则，可能发现买了烧烤酱和薯片的人也会买牛排。因此，你可以将这些商品放在一起。</p><h4 id="c-半监督学习"><a href="#c-半监督学习" class="headerlink" title="c.半监督学习"></a>c.半监督学习</h4><p>一些算法可以处理部分带标签的训练数据，通常是大量不带标签数据加上小部分带标签数据。这称作半监督学习。<br>如下图所示，图中灰色圆点表示没有标签的数据，仅有几个三角形和正方形点表示带标签的数据。</p><p> <img src="/images/machine_learning/ml_semi-supervised-learning_example.png" alt=""></p><p>多数半监督学习算法是非监督和监督算法的结合。</p><ul><li>例如，深度信念网络（deep belief networks）是基于被称为互相叠加的受限玻尔兹曼机（restricted Boltzmann machines，RBM）的非监督组件。RBM 是先用非监督方法进行训练，再用监督学习方法进行整个系统微调。</li><li>如一些图片存储服务，比如 Google Photos，是半监督学习的好例子。一旦你上传了所有家庭相片，它就能自动识别相同的人 A 出现了相片1、5、11 中，另一个人 B 出现在了相片 2、5、7 中。这是算法的非监督部分（聚类）。现在系统需要的就是你告诉这两个人是谁。只要给每个人一个标签，算法就可以命名每张照片中的每个人，特别适合搜索照片。</li></ul><h4 id="d-强化学习"><a href="#d-强化学习" class="headerlink" title="d.强化学习"></a>d.强化学习</h4><p>强化学习和上述三种学习问题是非常不同的。学习系统在这里被称为智能体（ agent），可以对环境进行观察，选择和执行动作，获得奖励（负奖励是惩罚，见下图）。<br>然后它必须自己学习哪个是最佳方法（称为策略，policy），以得到长久的最大奖励。策略决定了智能体在给定情况下应该采取的行动 。</p><p>目前强化学习的应用还不算非常广，特别是结合了深度学习的强化学习，主要是应用在机器人方面，当然最著名的一个应用就是 DeepMind 的 AlphaGo 了，它是通过分析数百万盘棋局学习制胜策略，然后自己和自己下棋。要注意，在比赛中机器学习是关闭的；AlphaGo 只是使用它学会的策略。</p><h3 id="批量-在线学习"><a href="#批量-在线学习" class="headerlink" title="批量/在线学习"></a>批量/在线学习</h3><p>第二种分类机器学习的准则是，它是否能从导入的数据流进行持续学习。也就是如果导入的是持续的数据流，机器学习算法能否在不断采用新数据来训练已经训练好的模型，并且新的模型对新旧数据都还有很好的性能。</p><h4 id="a-批量学习"><a href="#a-批量学习" class="headerlink" title="a.批量学习"></a>a.批量学习</h4><p>在批量学习中，系统不能进行持续学习：必须用所有可用数据进行训练。这通常会占用大量时间和计算资源，所以一般是线下做的。<br>首先是进行训练，然后部署在生产环境且停止学习，它只是使用已经学到的策略。这称为离线学习。</p><p>对于批量学习算法来说，当获取到新数据的时候，就需要重新重头训练整个数据集，然后更新模型，如果是应用该算法系统，那就相当于需要更新系统，需要停掉旧版本的系统，重新上线新版本的系统。<br>当然，一般训练、评估、部署一套机器学习的系统的整个过程可以自动进行，所以即便是批量学习也可以适应改变。只要有需要，就可以方便地更新数据、训练一个新版本。并且对于更新周期，可以选择每 24 小时或者每周更新一次。</p><p>但是，批量学习还是存在下面的缺点：</p><ul><li>实时性差，即对于需要快速适应变化的系统，比如预测股票变化、电商推荐系统等，就不适合采用批量学习算法；</li><li>耗费大量计算资源，用全部数据训练需要大量计算资源（CPU、内存空间、磁盘空间、磁盘 I/O、网络 I/O 等等），特别是训练集特别大的情况，更加凸显这个问题的严峻性；</li><li>无法应用在资源有限的设备上，比如需要自动学习的系统，但是如果采用智能手机，每次采用大量训练数据重新训练几个小时是非常不实际的。</li></ul><h4 id="b-在线学习"><a href="#b-在线学习" class="headerlink" title="b.在线学习"></a>b.在线学习</h4><p>批量学习的缺陷和问题可以通过采用在线学习算法来解决。</p><p>在在线学习中，是用数据实例持续地进行训练，可以一次一个或一次几个实例（称为小批量）。每个学习步骤都很快且廉价，所以系统可以动态地学习到达的新数据。<br>在线学习虽然名字带着在线两个字，但是实际上它的训练过程也是离线的，因此应该说是持续学习或者增量学习。</p><h3 id="基于实例-基于模型学习"><a href="#基于实例-基于模型学习" class="headerlink" title="基于实例/基于模型学习"></a>基于实例/基于模型学习</h3><p>第三种分类机器学习的方法是判断它们是如何进行归纳推广的。大多机器学习任务是关于预测的。这意味着给定一定数量的训练样本，系统需要能推广到之前没见到过的样本。对训练数据集有很好的性能还不够，真正的目标是对新实例预测的性能。<br>有两种主要的归纳方法：基于实例学习和基于模型学习。</p><h4 id="a-基于实例学习"><a href="#a-基于实例学习" class="headerlink" title="a.基于实例学习"></a>a.基于实例学习</h4><p>基于实例学习是系统先用记忆学习案例，然后使用相似度测量推广到新的例子，如下图所示：</p><p><img src="/images/machine_learning/ml_base-on-instance-learning_example.png" alt=""></p><p>这种学习算法可以说是机器学习中最简单的算法了，它实际上就是采用存储的数据集进行分类或者回归，典型的算法就是 KNN 算法，即 K 近邻算法，它就是将新的输入数据和已经保存的训练数据采用相似性度量（一般采用欧式距离）得到最近的 K 个训练样本，并采用 K 个训练样本中类别出现次数最多的类别作为预测的结果。</p><p>所以，这种算法的缺点就比较明显了：</p><ul><li>一是对存储空间的需求很大，需要占用的空间直接取决于实例数量的大小；</li><li>二是运行时间比较慢，因为需要需要与已知的实例进行比对。</li></ul><h4 id="b-基于模型学习"><a href="#b-基于模型学习" class="headerlink" title="b.基于模型学习"></a>b.基于模型学习</h4><p>和基于实例学习相反的就是基于模型学习：建立这些样本的模型，然后使用这个模型进行预测。如下图所示：</p><p><img src="/images/machine_learning/ml_base-on-model-learning_example.png" alt=""></p><p>基于模型学习算法的流程一般如下所示：</p><ul><li>研究数据。先对数据进行分析，这可能包含清洗数据、特征筛选、特征组合等等</li><li>选择模型。选择合适的模型，从简单的线性回归、逻辑回归，到慢慢复杂的随机森林、集成学习，甚至深度学习的卷积神经网络模型等等</li><li>用训练数据进行训练。也就是寻找最适合算法模型的参数，使得代价函数取得最小值。</li><li>使用模型对新案例进行预测（这称作推断）。预测结果非常好，就能上线系统；如果不好，就需要进行错误分析，问题出现在哪里，是数据问题还是模型问题，找到问题，然后继续重复这个流程。</li></ul><h2 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h2><p><img src="/images/machine_learning/ml_training.png" alt=""></p><h2 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h2><p><img src="/images/machine_learning/ml_algorithm.png" alt=""></p><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><p><img src="/images/machine_learning/ml_process.png" alt=""></p><p>开发过程:</p><ul><li>收集数据: 收集样本数据</li><li>准备数据: 注意数据的格式</li><li>分析数据: 为了确保数据集中没有垃圾数据；<ul><li>如果是算法可以处理的数据格式或可信任的数据源，则可以跳过该步骤；</li><li>另外该步骤需要人工干预，会降低自动化系统的价值。</li></ul></li><li>训练算法: 如果使用无监督学习算法，由于不存在目标变量值，则可以跳过该步骤</li><li>测试算法: 评估算法效果</li><li>使用算法: 将机器学习算法转为应用程序</li></ul><hr><h1 id="算法理论"><a href="#算法理论" class="headerlink" title="算法理论"></a>算法理论</h1><ul><li><a href="https://blog.csdn.net/u011067360/article/details/24735415" target="_blank" rel="noopener">机器学习中的有监督学习，无监督学习，半监督学习</a></li><li><a href="https://zhuanlan.zhihu.com/p/25140821" target="_blank" rel="noopener">通俗易懂说数据挖掘十大经典算法 - 知乎</a></li><li><a href="https://cloud.tencent.com/developer/article/1330139" target="_blank" rel="noopener">数据挖掘10大算法详细介绍 - 云+社区</a></li></ul><p>机器学习 Algorithm Cheat Sheet：<br><img src="/images/machine_learning/ML-Algorithm-Model.png" alt=""></p><h2 id="有监督学习算法"><a href="#有监督学习算法" class="headerlink" title="有监督学习算法"></a>有监督学习算法</h2><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><blockquote><p>逻辑回归(Logistics Regression)</p></blockquote><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/74398043" target="_blank" rel="noopener">线性回归及梯度下降算法详解</a></li></ul><h3 id="kNN"><a href="#kNN" class="headerlink" title="kNN"></a>kNN</h3><blockquote><p>k-近邻算法</p></blockquote><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/73612440" target="_blank" rel="noopener">KNN算法（有监督学习算法）</a></li></ul><h3 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h3><blockquote><p>因子分解机(Factorization Machine) 因子分解机(Factorization Machine, FM) 是由Steffen Rendle提出的一种基于矩阵分解的机器学习算法。目前，被广泛的应用于广告预估模型中</p></blockquote><ul><li><a href="https://blog.csdn.net/bitcarmanlee/article/details/52143909" target="_blank" rel="noopener">FM算法详解</a></li></ul><h3 id="FFM"><a href="#FFM" class="headerlink" title="FFM"></a>FFM</h3><blockquote><p>Field-aware Factorization Machines(FFM)</p></blockquote><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><blockquote><p>Naive Bayes</p></blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/26262151" target="_blank" rel="noopener">带你理解朴素贝叶斯分类算法 - 知乎</a></li></ul><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><blockquote><p>支持向量机（Support Vector Machine）</p></blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/41331635" target="_blank" rel="noopener">聊聊SVM - 知乎</a></li></ul><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><blockquote><p>决策树（Decision Tree）</p></blockquote><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/73658239" target="_blank" rel="noopener">决策树算法（有监督学习算法）</a></li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><blockquote><p>Random Forest</p></blockquote><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/73670473" target="_blank" rel="noopener">随机森林算法（有监督学习）</a></li></ul><h3 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h3><blockquote><p>集成学习的两个流派，bagging  &amp; boosting派系</p></blockquote><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/73692347" target="_blank" rel="noopener">bagging和boosting算法（集成学习算法）</a></li></ul><h2 id="无监督学习算法"><a href="#无监督学习算法" class="headerlink" title="无监督学习算法"></a>无监督学习算法</h2><h3 id="k-均值"><a href="#k-均值" class="headerlink" title="k-均值"></a>k-均值</h3><blockquote><p>k-means 算法</p></blockquote><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/73609112" target="_blank" rel="noopener">K-means聚类算法（无监督学习算法）</a></li></ul><h3 id="分层聚类"><a href="#分层聚类" class="headerlink" title="分层聚类"></a>分层聚类</h3><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><blockquote><p>主成分分析（Principal Component Analysis）</p></blockquote><h3 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h3><blockquote><p>DBSCAN，英文全写为Density-based spatial clustering of applications with noise ，是在 1996 年由Martin Ester, Hans-Peter Kriegel, Jörg Sander 及 Xiaowei Xu 提出的聚类分析算法， 这个算法是以密度为本的：给定某空间里的一个点集合，这算法能把附近的点分成一组（有很多相邻点的点），并标记出位于低密度区域的局外点（最接近它的点也十分远），DBSCAN 是其中一个最常用的聚类分析算法</p></blockquote><h1 id="机器学习框架"><a href="#机器学习框架" class="headerlink" title="机器学习框架"></a>机器学习框架</h1><ul><li><a href="https://blog.csdn.net/zuochao_2013/article/details/77852442" target="_blank" rel="noopener">13种主流机器学习的框架</a></li></ul><h2 id="Spark-MLlib"><a href="#Spark-MLlib" class="headerlink" title="Spark MLlib"></a>Spark MLlib</h2><p>MLib是主要面向数学和统计用户的平台，它允许 通过持久化管道特性将Spark机器学习工作挂起和恢复。2016年发布的Spark2.0，对Tungsten高速内存管理系统和新的DataFrames流媒体API 进行了改进，这两点都会提升机器学习应用的性能。</p><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p>一个大型的分布式机器学习平台。该术语还指 TensorFlow 堆栈中的基本 API 层，该层支持对数据流图进行一般计算。<br>虽然 TensorFlow 主要应用于机器学习领域，但也可用于需要使用数据流图进行数值计算的非机器学习任务。</p><ul><li>ensorFlow Playground:<br>一款用于直观呈现不同的超参数对模型（主要是神经网络）训练的影响的程序。要试用 TensorFlow Playground，请前往 <a href="http://playground.tensorflow.org。" target="_blank" rel="noopener">http://playground.tensorflow.org。</a></li></ul><ul><li><p>TensorFlow Serving:<br>一个平台，用于将训练过的模型部署到生产环境。</p></li><li><p>张量 (Tensor):<br>TensorFlow 程序中的主要数据结构。张量是 N 维（其中 N 可能非常大）数据结构，最常见的是标量、向量或矩阵。张量的元素可以包含整数值、浮点值或字符串值。</p></li><li><p>会话 (tf.session):<br>封装了 TensorFlow 运行时状态的对象，用于运行全部或部分图。在使用底层 TensorFlow API 时，您可以直接创建并管理一个或多个 tf.session 对象。在使用 Estimator API 时，Estimator 会为您创建会话对象。</p></li><li><p>输入函数 (input function):<br>在 TensorFlow 中，用于将输入数据返回到 Estimator 的训练、评估或预测方法的函数。例如，训练输入函数会返回训练集中的一批特征和标签。</p></li><li><p>图 (graph):<br>TensorFlow 中的一种计算规范。图中的节点表示操作。边缘具有方向，表示将某项操作的结果（一个张量）作为一个操作数传递给另一项操作。可以使用 TensorBoard 直观呈现图。</p></li><li><p>Layers API (tf.layers):<br>一种 TensorFlow API，用于以层组合的方式构建深度神经网络。通过 Layers API，您可以构建不同类型的层，例如：</p><ul><li>通过 tf.layers.Dense 构建全连接层。</li><li>通过 tf.layers.Conv2D 构建卷积层。</li></ul></li><li><p>Metrics API (tf.metrics):<br>一种用于评估模型的 TensorFlow API。例如，tf.metrics.accuracy 用于确定模型的预测与标签匹配的频率。在编写自定义 Estimator 时，您可以调用 Metrics API 函数来指定应如何评估您的模型。</p></li></ul><h1 id="机器学习相关数学知识"><a href="#机器学习相关数学知识" class="headerlink" title="机器学习相关数学知识"></a>机器学习相关数学知识</h1><h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><ol><li>导数及偏导数，对应机器学习中的梯度，机器学习中学习的参数需要通过梯度下降进行更新；</li><li>复合函数的链式法则，同1一样，目的也是为了求出梯度更新参数，但因为深度学习网络有多层，所以模型的预测函数是个复合函数，我们需要通过链式法则从后往前求出每层参数的梯度，进而更新每层里的参数，这也就是“反向传播法”；</li><li>了解数学中的最优化问题，大概就是目标函数在什么条件下能够取到最值的问题，因为机器学习的问题到最后都是要转化为一个损失函数最优化的问题。</li></ol><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ol><li>标量、向量、矩阵及张量的定义及运算，机器学习的过程其实也就是矩阵计算的过程(GPU在矩阵计算上天然有很大的优势)。</li><li>范数，对应机器学习中正则项，正则项通常会加在已有的损失函数上用来减少训练的过拟合问题；</li><li>常见的距离计算方式：欧式距离、曼哈顿距离、余弦距离等，我们之前说过数据样本可以表示为其特征空间里的点，而距离可以用来衡量他们的相似度。</li></ol><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><ol><li>条件概率、贝叶斯，基于概率论的分类方法经常会用到；</li><li>期望与方差，机器学习里一般都会对数据进行normalized的处理，这个时候很可能会用到期望和方差；</li><li>协方差，能够表征两个变量的相关性，在PCA降维算法中有用到，变量越相关，我们越可能对他们进行降维处理；</li><li>常见分布：0-1分布、二项分布、高斯分布等，高斯分布很重要，数据normalized跟它有关，参数的初始化特跟它有关；</li><li>最大似然估计，在推导逻辑回归的损失函数时会用到。</li></ol><hr><h1 id="附录：机器学习算法技能树"><a href="#附录：机器学习算法技能树" class="headerlink" title="附录：机器学习算法技能树"></a>附录：机器学习算法技能树</h1><p><img src="/images/machine_learning/AI-机器学习算法工程师技能树.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 34.Machine-Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记：深度学习</title>
      <link href="/34.Machine-Learning/DeepLearning-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/34.Machine-Learning/DeepLearning-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/machine_learning/Deep-Learning-Title.png" alt=""></p><h1 id="深度学习入门"><a href="#深度学习入门" class="headerlink" title="深度学习入门"></a>深度学习入门</h1><h2 id="机器学习-vs-深度学习"><a href="#机器学习-vs-深度学习" class="headerlink" title="机器学习 vs 深度学习"></a>机器学习 vs 深度学习</h2><p><strong>机器学习</strong> 通过算法分析数据，从结果中进行学习，然后将「学习后的算法」用来做出决策或进行预测，例子有我们熟悉的聚类、贝叶斯网络和视觉数据映射等等。</p><p><strong>深度学习</strong>，深度学习是机器学习的一个子集，和其它所有机器学习一样都是基于算法。然而它并非像「数据分类」一样根据任务选择的算法，而是模仿人类大脑结构与运算过程——识别非结构化输入的数据，输出精确地行为和决策。<br>机器学习可以是监督的也可以是非监督的，这意味着大型神经网络可以接受「标签化输入」，但并不需要。</p><p>深度学习是机器学习中一种基于对数据进行表征学习的算法。表征学习的目标是寻求更好的表示方法并创建更好的模型来从大规模未标记数据中学习这些表示方法。<br>一部分最成功的深度学习方法涉及到对人工神经网络的运用。“深度”是一个术语。它指的是一个神经网络中的层的数量。浅层神经网络有一个所谓的隐藏层，而深度神经网络则不止一个隐藏层。<br>当一个神经网络处理输入时，它通过输入数据和输出数据创造层，这种级别的深度学习让神经网络从原始数据中「自动抽取特征」而无需人工来贴标签。<br>神经网络由大量被称为神经元的简单处理器构成，处理器用数学公式模仿人类大脑中的神经元。这些人造神经元就是神经网络最基础的「部件」。<br>简而言之，每一个神经元接受两个或更多的输入，处理它们，然后输出一个结果。一些神经元从额外的传感器接收输入，然后其他神经元被其他已激活的神经元激活。神经元可能激活其它的神经元，或者通过触发的行动影响外部环境。所有的行为都是在「自动生成」的隐藏层中发生的，每个连续的图层都会输入前一层的输出。</p><blockquote><p>@ref: <a href="https://cn.udacity.com/blog/post/5" target="_blank" rel="noopener">「机器学习」还是「深度学习」，哪个更适合你？</a> </p></blockquote><h1 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h1><ul><li><a href="https://www.oschina.net/news/81599/frameworks-for-machine-learning-and-deep-learning" target="_blank" rel="noopener">机器学习和深度学习的最佳框架大比拼 - 开源中国</a></li></ul><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p><a href="http://blog.jobbole.com/105602/" target="_blank" rel="noopener">TensorFlow深度学习，一篇文章就够了</a></p><h2 id="Caffe2"><a href="#Caffe2" class="headerlink" title="Caffe2"></a>Caffe2</h2><p>深度学习框架Caffe开发时秉承的理念是“表达、速度和模块化”，最初是源于2013年的机器视觉项目，此后，Caffe还得到扩展吸收了其他的应用，如语音和多媒体。<br>因为速度放在优先位置 ，所以Caffe完全用C+ +实现，并且支持CUDA加速，而且根据需要可以在CPU和GPU处理间进行切换。分发内容包括免费的用于普通分类任务的开源参考模型，以及其他由Caffe用户社区创造和分享的模型。<br>一个新的由Facebook 支持的Caffe迭代版本称为Caffe2，现在正在开发过程中，即将进行1.0发布。其目标是为了简化分布式训练和移动部署，提供对于诸如FPGA等新类型硬件的支持，并且利用先进的如16位浮点数训练的特性。</p><h2 id="MXNet"><a href="#MXNet" class="headerlink" title="MXNet"></a>MXNet</h2><p>MXNet是一个可移植的、可伸缩的深度学习库，是亚马逊的DNN框架的选择，结合了神经网络几何的象征性声明与张量操作的命令性编程。<br>MXNet可跨多个主机扩展到多个GPU，接近线性扩展效率为85％，具有出色的开发速度、可编程性和可移植性。它支持Python，R，Scala，Julia和C ++，支持程度各不相同，它允许你混合符号和命令式编程风格。</p><h2 id="DeepLearning4j"><a href="#DeepLearning4j" class="headerlink" title="DeepLearning4j"></a>DeepLearning4j</h2><p>Java和Scala在Hadoop和Spark之上的深度学习框架。</p><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>神经网络的种类：</p><ul><li>基础神经网络：单层感知器，线性神经网络，BP神经网络，Hopfield神经网络等</li><li>进阶神经网络：玻尔兹曼机，受限玻尔兹曼机，递归神经网络等</li><li>深度神经网络：深度置信网络，卷积神经网络，深度残差网络，LSTM网络等</li></ul><p>神经网络的发展图：</p><p><img src="/images/machine_learning/DL-NN-History.png" alt=""></p><ul><li><a href="http://www.cnblogs.com/pinard/p/6042320.html" target="_blank" rel="noopener">感知机原理小结</a></li><li><a href="https://www.cnblogs.com/pinard/p/6418668.html" target="_blank" rel="noopener">深度神经网络（DNN）模型与前向传播算法</a></li></ul><h2 id="积神经网络（CNN）"><a href="#积神经网络（CNN）" class="headerlink" title="积神经网络（CNN）"></a>积神经网络（CNN）</h2><ul><li><a href="https://my.oschina.net/u/876354/blog/1620906" target="_blank" rel="noopener">大话卷积神经网络（CNN）</a></li></ul><h3 id="CNN经典模型：LeNet"><a href="#CNN经典模型：LeNet" class="headerlink" title="CNN经典模型：LeNet"></a>CNN经典模型：LeNet</h3><ul><li><a href="https://my.oschina.net/u/876354/blog/1632862" target="_blank" rel="noopener">大话CNN经典模型：LeNet</a></li></ul><h3 id="CNN经典模型：AlexNet"><a href="#CNN经典模型：AlexNet" class="headerlink" title="CNN经典模型：AlexNet"></a>CNN经典模型：AlexNet</h3><ul><li><a href="https://my.oschina.net/u/876354/blog/1633143" target="_blank" rel="noopener">大话CNN经典模型：AlexNet</a></li></ul><h3 id="CNN经典模型：VGGNet"><a href="#CNN经典模型：VGGNet" class="headerlink" title="CNN经典模型：VGGNet"></a>CNN经典模型：VGGNet</h3><ul><li><a href="https://my.oschina.net/u/876354/blog/1634322" target="_blank" rel="noopener">大话CNN经典模型：VGGNet</a></li></ul><h3 id="CNN经典模型：GoogLeNet"><a href="#CNN经典模型：GoogLeNet" class="headerlink" title="CNN经典模型：GoogLeNet"></a>CNN经典模型：GoogLeNet</h3><ul><li><a href="https://my.oschina.net/u/876354/blog/1637819" target="_blank" rel="noopener">大话CNN经典模型：GoogLeNet（从Inception v1到v4的演进）</a></li></ul><h2 id="循环神经网络（RNN）"><a href="#循环神经网络（RNN）" class="headerlink" title="循环神经网络（RNN）"></a>循环神经网络（RNN）</h2><ul><li><a href="https://my.oschina.net/u/876354/blog/1621839" target="_blank" rel="noopener">大话循环神经网络（RNN）</a></li></ul><h2 id="度残差网络（DRN）"><a href="#度残差网络（DRN）" class="headerlink" title="度残差网络（DRN）"></a>度残差网络（DRN）</h2><ul><li><a href="https://my.oschina.net/u/876354/blog/1622896" target="_blank" rel="noopener">大话深度残差网络（DRN）ResNet网络原理</a></li></ul><h2 id="度信念网络（DBN）"><a href="#度信念网络（DBN）" class="headerlink" title="度信念网络（DBN）"></a>度信念网络（DBN）</h2><ul><li><a href="https://my.oschina.net/u/876354/blog/1626639" target="_blank" rel="noopener">大话深度信念网络（DBN）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 34.Machine-Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storm</title>
      <link href="/33.Bigdata/Storm/"/>
      <url>/33.Bigdata/Storm/</url>
      
        <content type="html"><![CDATA[<p><img src="http://storm.apache.org/images/logo.png" alt="Storm"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>  Storm是一个开源的分布式实时计算系统，可以简单、可靠的处理大量的数据流。被称作“实时的hadoop”。<br>  Storm有很多使用场景：如实时分析，在线机器学习，持续计算， 分布式RPC，ETL等等。<br>  Storm支持水平扩展，具有高容错性，保证每个消息都会得到处理，而且处理速度很快。<br>  Storm的部署和运维都很便捷，而且更为重要的是可以使用任意编程语言来开发应用。</p><h2 id="Storm的特点"><a href="#Storm的特点" class="headerlink" title="Storm的特点"></a>Storm的特点</h2><ul><li>简单的编程模型:<br>在大数据处理方面相信大家对 hadoop已经耳熟能详，基于 Google Map/Reduce来实现的 Hadoop为开发者提供了map、reduce原语，使并行批处理程序变得非常地简单。<br>同样，Storm也为大数据 的实时计算提供了一些简单优美的原语，这大大降低了开发并行实时处理的任务的复杂性，帮助你快速、高效的开发应用。</li><li>水平扩展:<br>在 Storm集群中真正运行 topology的主要有三个实体：工作进程、线程和任务。Storm集群中的每台机器上都可以运行多个工作进程，每个工作进程又可创建多个线程，每个线程可以执行多个任务，任务是真正进行数据处理的实体，我们开发的 spout、bolt就是作为一个或者多个任务的方式执行的。<br>计算任务在多个线程、进程和服务器之间并行进行，支持灵活的水平扩展。</li><li>支持多种编程语言:<br>你可以在Storm之上使用各种编程语言。默认支持 Clojure、Java、Ruby和 Python。要增加对其他语言的支持，只需实现一个简单的 Storm通信协议即可。</li><li>高可靠性:<br>Storm保证每个消息至少能得到一次完整处理。任务失败时，它会负责从消息源重试消息。<br>spout发出的消息后续可能会触发产生成千上万条消息，可以形象的理解为一棵消息树，其中 spout发出的消息为树根，Storm会跟踪这棵消息树的处理情况，只有当这棵消息树中的所有消息都被处理了，Storm才会认为 spout发出的这个消息已经被“完全处理”。如果这棵消息树中的任何一个消息处理失败了，或者整棵消息树在限定的时间内没有“完全处理”，那么 spout发出的消息就会重发。</li><li>高容错性:<br>Storm会管理工作进程和节点的故障。<br>如果在消息处理过程中出了一些异常，Storm会重新安排这个出问题的处理单元。Storm保证一个处理单元永远运行（除非你显式杀掉这个处理单元）。<br>当然，如果处理单元中存储了中间状态，那么当处理单元重新被Storm启动的时候，需要应用自己处理中间状态的恢复。</li><li>本地模式:<br>Storm有一个“本地模式”，可以在处理过程中完全模拟Storm集群。这让你可以快速进行开发和单元测试。</li></ul><h2 id="Storm是如何工作的"><a href="#Storm是如何工作的" class="headerlink" title="Storm是如何工作的"></a>Storm是如何工作的</h2><p>对于一个Storm集群，有两类节点：主节点master node和工作节点worker nodes。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Master Node    ZK Cluster       Worker Node           Topology</span><br><span class="line">    v             v                  v                   v</span><br><span class="line">               +-----+       +---------------------+</span><br><span class="line">               | ZK1 |       |Supervisor |Worker*N | --&gt; Spout -&gt; Bolt</span><br><span class="line">               |     |       +---------------------+</span><br><span class="line">+------+       +-----+ ---&gt;</span><br><span class="line">|Nimbus| ---&gt;  | ZK2 |       +---------------------+</span><br><span class="line">+------+       |     |       |Supervisor |Worker*N |</span><br><span class="line">               +-----+       +---------------------+</span><br><span class="line">               | ZK..| ---&gt;</span><br><span class="line">               |     |       +---------------------+</span><br><span class="line">               +-----+       |Supervisor |Worker*N |</span><br><span class="line">                             +---------------------+</span><br></pre></td></tr></table></figure><ul><li>主节点(master node)运行着一个叫做 Nimbus的守护进程。这个守护进程负责在集群中分发代码，为工作节点分配任务，并监控故障。</li><li>每个工作节(worker nodes)点都运行着一个 Supervisor守护进程, Supervisor作为拓扑的一部分运行在工作节点上。一个 Storm拓扑结构在不同的机器上运行着众多的工作节点。</li><li>每个 Supervisor中运行着多个 Workers进程，每个 Worker进程中运行着多个 Executor线程。每个 Executor线程会循环调用 Task实例(Task是Spout/Bolt的实例)的<code>nextTuple</code>或<code>execute</code>方法。Storm默认是1个(Spout/Bolt)只生成1个 Task。</li><li>数据的分发和处理分别是 Spout和 Bolt, Spout和 Bolt由 Stream Grouping连接起来的节点网络被称为: Topology(拓扑)。</li></ul><p><img src="/images/storm/storm_topology.png" alt="Storm拓扑结构"></p><p>下图是Storm各组件之间的数据交互图，可以看出Nimbus和Supervisor之间没有直接交互。Storm所有元数据信息/状态都是保存在Zookeeper上，<br>Nimbus在Zookeeper上保存所有的集群状态，单个守护进程可以是无状态的而且失效或重启时不会影响整个系统的健康。 如果Supervisor因故障出现问题而无法运行Topology，Nimbus会第一时间感知到，并重新分配Topology到其它可用的Supervisor上运行<br>Worker之间则通过Netty传送数据。</p><p><img src="/images/storm/storm_nimbus_zk.png" alt="Nimbus_Supervisor"></p><h1 id="Storm主要概念"><a href="#Storm主要概念" class="headerlink" title="Storm主要概念"></a>Storm主要概念</h1><p>这些术语的字面意义翻译如下，由于这个工具的名字叫Storm，这些术语一律按照气象名词解释</p><blockquote><p>nimbus 雨云，主节点的守护进程，负责为工作节点分发任务。<br>spout 龙卷，读取原始数据为bolt提供数据<br>bolt 雷电，从spout或其它bolt接收数据，并处理数据，处理结果可作为其它bolt的数据源或最终结果</p></blockquote><p>下面的术语跟气象就没有关系了</p><blockquote><p>topology 拓扑结构，Storm的一个任务单元<br>define field(s) 定义域，由spout或bolt提供，被bolt接收</p></blockquote><p>在服务架构上来看, Storm分为 Master Node(即Nimbus), Zookeeper, Worker Node(Supervisor+Worker)</p><p>在编程逻辑上来看, Storm分为 Spout(分发Tuple流), Bolt(处理Tupe数据), Stream Grouping(前两者的数据分发规则), 以及Topology</p><h2 id="Nimbus-amp-Supervisor"><a href="#Nimbus-amp-Supervisor" class="headerlink" title="Nimbus &amp; Supervisor"></a>Nimbus &amp; Supervisor</h2><p>  Storm集群由一个主节点和多个工作节点组成。主节点运行了一个名为“Nimbus”的守护进程，用于分配代码、布置任务及故障检测。每个工作节点都运行了一个名为“Supervisor”的守护进程，用于监听工作，开始并终止工作进程。Nimbus和Supervisor都能快速失败，而且是无状态的，这样一来它们就变得十分健壮，两者的协调工作是由Apache ZooKeeper来完成的。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream是一个数据流的抽象。这是一个没有边界的 Tuple序列,而这些Tuple序列会以一种分布式的方式并行地创建和处理。</p><p>对消息流的定义主要就是对消息流里面的tuple 进行定义，为了更好地使用tuple，需要给tuple 里的每个字段取一个名字，并且不同的tuple 字段对应的类型要相同，即两个tuple 的第一个字段类型相同，第二个字段类型相同。<br>默认情况下，tuple 的字段类型可以为integer、long、short、byte、string、double、float、boolean 和byte array 等基本类型，也可以自定义类型，只需要实现相应的序列化接口。</p><p>每一个消息流在定义的时候需要被分配一个id，最常见的消息流是单向的消息流，在Storm 中OutputFieldsDeclarer 定义了一些方法，让你可以定义一个Stream 而不用指定这个id。在这种情况下，这个Stream 会有个默认的id: 1。</p><h2 id="Topologies"><a href="#Topologies" class="headerlink" title="Topologies"></a>Topologies</h2><p>Topology是由Stream Grouping连接起来的Spout和Bolt节点网络。<br>在 Storm 中，一个实时计算应用程序的逻辑被封装在一个称为Topology 的对象中，也称为计算拓扑。<br>Topology 有点类似于Hadoop 中的MapReduce Job，但是它们之间的关键区别在于，一个MapReduce Job 最终总是会结束的，然而一个Storm 的Topology 会一直运行。<br>在逻辑上，一个Topology 是由一些Spout（消息的发送者）和Bolt（消息的处理者）组成图状结构，而链接Spouts 和Bolts 的则是Stream Groupings。</p><p><img src="/images/storm/storm_grouping.png" alt=""></p><h2 id="Spouts"><a href="#Spouts" class="headerlink" title="Spouts"></a>Spouts</h2><p>Spout 是一个 topology（拓扑）中 streams 的源头. 通常 Spout 会从外部数据源读取 Tuple，然后把他们发送到拓扑中（如 Kestel 队列, 或者 Twitter API）. Spout 可以是 可靠的 或 不可靠的. 可靠的 Spout 在 Storm 处理失败的时候能够重新发送(emit)失败的 Tuple, 不可靠的 Spout 一旦把一个 Tuple 发送出去就撒手不管了.</p><p>Spout 可以发送多个流. 可以使用 OutputFieldsDeclarer 的 declareStream 方法定义多个流,<br>在 SpoutOutputCollector 对象的 emit 方法中指定要发送到的 stream .</p><p>Spout 中的最主要的方法是 <code>nextTuple()</code>:<br>nextTuple 要么向 topology（拓扑）中发送一个新的 Tuple,<br>要么在没有 Tuple 需要发送的情况下直接返回.<br>对于任何 Spout 实现, nextTuple 方法都必须非阻塞的, 因为 Storm 在一个线程中调用所有的 Spout 方法.</p><p>Spout 的另外几个重要的方法是 <code>ack()</code> 和 <code>fail()</code>.<br>这些方法在 Storm 检测到 Spout 发送出去的 Tuple 被成功处理或者处理失败的时候调用.</p><h2 id="Bolts"><a href="#Bolts" class="headerlink" title="Bolts"></a>Bolts</h2><p>所有消息处理的逻辑都在Bolt 中完成，在Bolt 中可以完成如过滤、分类、聚集、计算、查询数据库等操作。<br>Bolt 可以做简单的消息处理操作，例如，Bolt 可以不做任何操作，只是将接收到的消息转发给其他的Bolt。<br>Bolt 也可以做复杂的消息流的处理，这需要很多个Bolt。<br>在实际使用中，一条消息往往需要经过多个处理步骤，例如，计算一个点击数在前十的广告，首先需要对所有同学的成绩进行排序，然后在排序过的成绩中选出前十名的<br>成绩的同学。所以在一个Topology 中，往往有很多个Bolt，从而形成了复杂的流处理网络。</p><ul><li>使用<code>OutputFieldsDeclarer.declareStream</code>定义Stream。</li><li>使用<code>OutputCollector.emit</code>来选择要发射的Stream。</li></ul><p>Bolts的主要方法是<code>execute()</code>。在该方法里，Bolts以Tuple作为输入, 使用OutputCollector来发送Tuple, 通过调用<code>OutputCollector.ack()</code>通知这个Tuple的发射者Spout。<br>Bolts可以发射多条消息流。</p><h2 id="Stream-Groupings"><a href="#Stream-Groupings" class="headerlink" title="Stream Groupings"></a>Stream Groupings</h2><p>Stream Grouping 就是用来定义一个Stream 应该如何分配给 Bolts  上面的多个Tasks。Storm里有7种类型的Stream Grouping：</p><ul><li>Shuffle Grouping 随机分组,随机派发Stream里面的 Tuple ,保证每个Bolt接收到的 Tuple 数量大致相同。</li><li>Fields Grouping 按字段分组,以id举例。具有相同id的 Tuple 会被分到相同的Bolt中的一个Task,而不同id的 Tuple 会被分到不同的Bolt中的Task。</li><li>Direct Grouping 直接分组,这是一种比较特别的分组方法,用这种分组意味着消息的发送者指定由消息接收者的哪个Task处理这个消息。<br>只有被声明为Direct Stream的消息流可以声明这种分组方法。而且这种消息 Tuple 必须使用emitDirect方法来发射。消息处理者可以通过TopologyContext来获取处理它的消息的Task的id(OutputCollector.emit方法也会返回Task的id)。</li><li>All Grouping 广播,对于每一个 Tuple ,所有的 Bolts 都会收到。</li><li>Global Grouping 全局分组,这个 Tuple 被分配到Storm中的一个Bolt的其中一个 Task。具体一点就是分配给id值最低的那个 Task。</li><li>Non Grouping 不分组,Stream不关心到底谁会收到它的 Tuple 。目前这种分组和Shuffle Grouping是一样的效果,有一点不同的是Storm会把这个Bolt放到这个Bolt的订阅者同一个线程中去执行。</li><li>Local or Shuffle Grouping 如果目标Bolt有一个或者多个Task在同一个工作进程中, Tuple 将会被随机发射给这些Tasks。否则,和普通的Shuffle Grouping行为一致。</li></ul><p>上面几种Streaming Group的内置实现中，最常用的应该是 Shuffle Grouping、Fields Grouping、Direct Grouping这三种，<br>使用其它的也能满足特定的应用需求。</p><p>另外，Storm还提供了用户自定义 Streaming Grouping 接口，如果上述 Streaming Grouping 都无法满足实际业务需求，也可以自己实现，只需要实现<code>backtype.storm.grouping.CustomStreamGrouping</code>接口，该接口定义了如下方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">chooseTasks</span><span class="params">(<span class="keyword">int</span> taskId, List&lt;Object&gt; values)</span></span></span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="Spout"><a href="#Spout" class="headerlink" title="Spout"></a>Spout</h2><p>WordReader类实现了IRichSpout接口。我们将在第四章看到更多细节。<br>WordReader负责从文件按行读取文本，并把文本行提供给第一个bolt。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordReader</span> <span class="keyword">implements</span> <span class="title">IRichSpout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpoutOutputCollector collector;</span><br><span class="line">    <span class="keyword">private</span> FileReader fileReader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> completed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> TopologyContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDistributed</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功会调用ack</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object msgId)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OK:"</span>+msgId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败会调用fail</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object msgId)</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"FAIL:"</span>+msgId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* open是第一个被调用的spout方法</span></span><br><span class="line"><span class="comment">      * TopologyContext context: 拓扑的上下文</span></span><br><span class="line"><span class="comment">      * SpoutOutputCollector collector: 向Bolt发布数据</span></span><br><span class="line"><span class="comment">      * 在这里我们创建了一个FileReader对象，用来读取文件</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">this</span>.context = context;</span><br><span class="line">                 <span class="keyword">this</span>.fileReader = <span class="keyword">new</span> FileReader(conf.get(<span class="string">"wordsFile"</span>).toString());</span><br><span class="line">             &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error reading file ["</span>+conf.get(<span class="string">"wordFile"</span>)+<span class="string">"]"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">this</span>.collector = collector;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* nextTuple()会在同一个循环内被ack()和fail()周期性的调用。没有任务时它必须释放对线程的控制，其它方法才有机会得以执行。</span></span><br><span class="line"><span class="comment">     * 读取文件每一行, 调用collector.emit() 向bolts发布待处理的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法会不断的被调用，直到整个文件都读完了，我们将等待并返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">         <span class="keyword">if</span>(completed)&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 <span class="comment">//什么也不做</span></span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         String str;</span><br><span class="line">         <span class="comment">//创建reader</span></span><br><span class="line">         BufferedReader reader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="comment">//读所有文本行</span></span><br><span class="line">            <span class="keyword">while</span>((str = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="comment">// 按行发布一个新值</span></span><br><span class="line">                 <span class="keyword">this</span>.collector.emit(<span class="keyword">new</span> Values(str),str);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error reading tuple"</span>,e);</span><br><span class="line">         &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">             completed = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 声明输入域"word"</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">         declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"line"</span>));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bolt"><a href="#Bolt" class="headerlink" title="Bolt"></a>Bolt</h2><p>下面的WordNormalizer实现了接口backtype.storm.topology.IRichBolt，该Bolt负责得到并标准化每行文本。<br>它把文本行切分成单词，大写转化成小写，去掉头尾空白符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordNormalizer</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputCollector collector;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个spout结束时（集群关闭的时候）,调用此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 声明: 这个bolt只会发布“word”域</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * collector用来向Bolt发布数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector=collector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 具体的处理方法</span></span><br><span class="line"><span class="comment">      * bolt从单词文件接收到文本行，全部转化成小写，并切分它，从中得到所有单词。</span></span><br><span class="line"><span class="comment">      * 最后，每次都调用collector.ack()确认已经处理</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span></span>&#123;</span><br><span class="line">        String sentence = input.getString(<span class="number">0</span>);</span><br><span class="line">        String[] words = sentence.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            word = word.trim();</span><br><span class="line">            <span class="keyword">if</span>(!word.isEmpty())&#123;</span><br><span class="line">                word=word.toLowerCase();</span><br><span class="line">                <span class="comment">//发布这个单词</span></span><br><span class="line">                List a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                a.add(input);</span><br><span class="line">                collector.emit(a,<span class="keyword">new</span> Values(word));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对collector做出应答</span></span><br><span class="line">        collector.ack(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologyMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Topology definition</span></span><br><span class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">builder.setSpout(<span class="string">"word-reader"</span>,<span class="keyword">new</span> WordReader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在spout和bolts之间通过shuffleGrouping方法连接:</span></span><br><span class="line">builder.setBolt(<span class="string">"word-normalizer"</span>, <span class="keyword">new</span> WordNormalizer())</span><br><span class="line">.shuffleGrouping(<span class="string">"word-reader"</span>);</span><br><span class="line">builder.setBolt(<span class="string">"word-counter"</span>, <span class="keyword">new</span> WordCounter(),<span class="number">1</span>)</span><br><span class="line">.fieldsGrouping(<span class="string">"word-normalizer"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Configuration</span></span><br><span class="line">Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">conf.put(<span class="string">"wordsFile"</span>, args[<span class="number">0</span>]);</span><br><span class="line">conf.setDebug(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Topology run</span></span><br><span class="line"><span class="comment">         * 在生产环境中，拓扑会持续运行，</span></span><br><span class="line"><span class="comment">         * 这里用LocalCluster创建本地调试运行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">conf.put(Config.TOPOLOGY_MAX_SPOUT_PENDING, <span class="number">1</span>);</span><br><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">        <span class="comment">// create and submit:</span></span><br><span class="line">cluster.submitTopology(<span class="string">"Getting-Started-Toplogie"</span>, conf, builder.createTopology());</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">cluster.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Worker-amp-Executor-amp-Task"><a href="#Worker-amp-Executor-amp-Task" class="headerlink" title="Worker &amp; Executor &amp; Task"></a>Worker &amp; Executor &amp; Task</h2><ul><li>每个 Worker Node 有一个 Supervisor, Supervisor 管理着N个 Worker 进程, 每个 Worker 进程是一个JVM进程, 有自己的端口号。</li><li>一个 Topology 可能会在一个或者多个 Worker 进程里面执行，每个工作进程执行整个 Topology 的一部分</li><li>每个 Worker进程中运行着多个 Executor 线程。</li><li>每个 Executor线程中运行着若干个相同的 Task (可以理解为Spout/Bolt), Executor线程会执行Task 。</li></ul><p>用代码说明:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Topology的配置</span></span><br><span class="line">Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">conf.setNumWorkers(<span class="number">2</span>); <span class="comment">// 改Topology使用2个worker进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Spout/Bolt的并行度(parallelism), 也即每个Spout/Bolt需要几个Executor线程来跑</span></span><br><span class="line">topologyBuilder.setSpout(“blue-spout”, <span class="keyword">new</span> BlueSpout(), <span class="number">2</span>); <span class="comment">// parallelism hint为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 Bolt除了设置并行度=2, 还设置了Task数量=4 (这个Bolt生成4个Task对象)</span></span><br><span class="line">topologyBuilder.setBolt(“green-bolt”, <span class="keyword">new</span> GreenBolt(), <span class="number">2</span>) .setNumTasks(<span class="number">4</span>) .shuffleGrouping(“blue-spout”);</span><br><span class="line"></span><br><span class="line">topologyBuilder.setBolt(“yellow-bolt”, <span class="keyword">new</span> YellowBolt(), <span class="number">6</span>) .shuffleGrouping(“green-bolt”);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交配置</span></span><br><span class="line">StormSubmitter.submitTopology( “mytopology”, conf, topologyBuilder.createTopology() );</span><br></pre></td></tr></table></figure></p><p>说明:</p><ul><li>上面定义了一个 拥有两个Worker进程的 Topology</li><li>上面定义了3个Component: 1个spout叫做<code>BlueSpout</code>，2个bolt分别叫 <code>GreenBolt</code>和<code>YellowBolt</code>。<code>BlueSpout</code>发送它的输出到<code>GreenBolt</code>，<code>GreenBolt</code>又把它的输出发到 <code>YellowBolt</code>。</li><li>上面3个Component的并行度(线程数)分别是 2 + 2 + 6 = 10, 每个worker进程产生10 / 2 = 5条线程。</li><li><code>GreenBolt</code>特别指定了生成4个Task</li></ul><blockquote><p>下图中可以看到Topology的两个Worker进程平均分配任务;<br>黄/绿/蓝色Task的数量分别是6, 4, 2, 也就是总共12个Task对象;<br>Task外面灰色轮廓是Executor线程, 注意2个绿色Task由一个Executor执行;</p></blockquote><p><img src="/images/storm/Storm_Worker_Executor_Task.png" alt=""></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>准备jdk, zookeeper集群</li><li>修改storm.yaml配置文件<ul><li><code>storm.zookeeper.servers</code>: Storm集群使用的Zookeeper集群地址。</li><li>如果Zookeeper没有使用默认端口,那么还需要修改<code>storm.zookeeper.port</code>。</li><li><code>storm.local.dir</code>: Nimbus和Supervisor进程用于存储少量状态,如jars、confs等的本地磁盘目录,需要提前创建该目录并给予足够的访问权限。</li></ul></li></ul><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><ul><li>启动Nimbus: <code>storm nimbus</code></li><li>启动Supervisor: <code>storm supervisor</code></li><li>启动UI: <code>storm ui</code></li><li>提交Topologies: <code>storm jar [jar路径] [拓扑包名.拓扑类名] [storm IP地址] [storm端口] [拓扑名称] [参数]</code></li><li>停止Topologies: <code>storm kill [拓扑名称]</code></li></ul><hr><p>参考:</p><ul><li><a href="https://github.com/weyo/Storm-Documents" target="_blank" rel="noopener">weyo/Storm-Documents: Apache Storm 官方文档翻译</a> @ref</li><li><a href="https://www.kancloud.cn/kancloud/getting-started-with-storm/66495" target="_blank" rel="noopener">https://www.kancloud.cn/kancloud/getting-started-with-storm/66495</a> @ref</li><li><a href="https://sylvanassun.github.io/2016/07/19/2016-07-19-Hadoop06-Storm/" target="_blank" rel="noopener">https://sylvanassun.github.io/2016/07/19/2016-07-19-Hadoop06-Storm/</a> @ref</li></ul>]]></content>
      
      
      <categories>
          
          <category> 33.Bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 流式计算 </tag>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark</title>
      <link href="/33.Bigdata/Spark/"/>
      <url>/33.Bigdata/Spark/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/spark/Stream-Processing-Analitics-and-Machine-Learning.jpg" alt=""></p><h1 id="什么是Spark"><a href="#什么是Spark" class="headerlink" title="什么是Spark"></a>什么是Spark</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现如今在大规模数据处理分析的技术领域中，Hadoop及其生态内的各功能组件占据了绝对的统治地位。<br>Hadoop原生的MapReduce计算框架由于任务抽象简单、计算流程固定、计算的中间结果写入磁盘引起大量读写开销等短板，正逐步的被基于内存的分布式计算框架Spark代替，应用于各类大规模数据处理分析的场景中，其优势主要体现在以下5个方面：</p><ul><li>1、更快的计算速度。采用计算中间结果的内存缓存机制和基于DAG的数据处理过程优化策略，进一步提升数据处理速率。</li><li>2、简单易用的分布式计算。将大规模数据处理任务，抽象为RDD的处理变换操作，将并行实现的分布式计算任务拆分为各自独立的串行计算过程。</li><li>3、适合丰富的应用场景。Spark内部集成了SQL、机器学习、流计算、图运算等多种类型计算模型，满足多种大规模数据分析的场景需求。</li><li>4、兼容多样的存储系统。满足对包括HDFS、HBase、Hive、S3等多种大规模数据存储系统的高效读写需求，轻松处理TB级以上规模以上的数据。</li><li>5、资源管理与高可靠性。结合Yarn、Mesos等多种类型的资源管理器，监控协调各计算子任务的运行状态，失败重启机制确保分布式作业的可靠性。</li></ul><h2 id="RDD计算模型原理"><a href="#RDD计算模型原理" class="headerlink" title="RDD计算模型原理"></a>RDD计算模型原理</h2><p>Spark将数据处理过程抽象为对内存中RDD（弹性分布式数据集）的操作，RDD的可以通过从数据源直接读取和集合数据类型封装两种方式创建。<br>针对RDD的操作，根据其结果主要分为如map、flatMap、mapPartition、filter等生成新的RDD的transformation（转换）操作和collect、reduce、foreach等生成集合数据类型或结果写入的action（行为）操作两大类。</p><p>下图描述了一个典型的Spark作业基于RDD实现数据的处理过程。其中，Spark对RDD的处理过程是惰性的，只有调用对RDD的action操作才能启动对RDD的计算过程，连续的调用多个transformation操作是无法使数据处理过程真正的执行。<br>在触发RDD计算过程后，根据Spark内置的DAG（有向无环图）引擎将多个对RDD的操作执行策略进行优化。<br>为满足对大规模数据的处理需要，Spark将RDD划分为多个partition（分区），以partition为单位将数据分散到集群上的各个节点中。<br>针对RDD的action操作和transformation操作间的本质区别就是生成的结果是否为RDD。</p><p><img src="/images/spark/Spark-RDD-Process.png" alt=""></p><h2 id="基于Yarn实现资源管理"><a href="#基于Yarn实现资源管理" class="headerlink" title="基于Yarn实现资源管理"></a>基于Yarn实现资源管理</h2><p>由于Hadoop的HDFS与Spark的RDD抽象读写具有较为完备的兼容性，各版本Spark均提供对应当前Hadoop版本的安装包。<br>同样，Spark也可以使用Hadoop中的Yarn作为自身的资源管理器，用以完成对Spark集群中是作业管理和任务计算资源调度分配等工作。</p><p>在Spark作业的执行过程中，Yarn将在集群中的物理节点上的Executor的JVM进程封装为独立的Container，并提供独立的临时文件目录以及内存和CPU资源。<br>同时，Spark还提供了共享文件依赖的机制将Spark作业执行过程中，各Executor所需的如jar包、.so动态库、py文件及其他格式类型的文件依赖资源与Spark作业自身的执行文件分发到各Container中，使得Spark作业能够具备更为灵活的拓展性。</p><p><img src="/images/spark/Spark-Yarn.png" alt=""></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>现如今，Spark作业支持Java、Scala、Python以及R四种语言编写，Spark自身提供了SQL、机器学习、流计算以及图运算四种类型的计算功能组件，开发人员可根据实际的应用需求和相应组件的功能特性完成Spark作业的开发。<br>但是，其中如GraphX等部分功能组件仅支持Java及Scala语言的调用。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>核心组件如下:<br><img src="/images/spark/Spark-Tech-Stack.png" alt=""></p><ul><li>Spark Core：包含Spark的基本功能；尤其是定义RDD的API、操作以及这两者上的动作。其他Spark的库都是构建在RDD和Spark Core之上的。</li><li>Spark SQL：提供通过Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API。每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。<br>基于对内存中RDD操作和DAG引擎优化，Spark能够实现比基于原生MapReduce的Hive SQL更高效的计算过程。同时，采用DataFrame封装Spark作业能够以函数调用的方式完成SQL操作。</li><li>MLlib：一个常用机器学习算法库，算法被实现为对RDD的Spark操作。这个库包含可扩展的学习算法，<br>比如分类、回归等需要对大量数据集进行迭代的操作。之前可选的大数据机器学习库Mahout，将会转到Spark并在未来实现。</li><li>Spark Streaming：允许对实时数据流进行处理和控制。很多实时数据库（如Apache Store）可以处理实时数据。Spark Streaming允许程序能够像普通RDD一样处理实时数据。<br>Spark Streaming将数据源抽象为DStream，将各时间窗内持续产生的实时数据切分为不同的RDD，以RDD为单位完成对时间窗内实时数据的处理，但其计算模式仍存在批处理的特性。</li><li>GraphX：控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作。<br>Spark中自带的图运算引擎GraphX采用由并行超步与全局同步组成的Bulk Synchronous Parallell（整体同步并行）模式，将图运算过程抽象为各步的迭代直至符合收敛停止条件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 33.Bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 流式计算 </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce</title>
      <link href="/33.Bigdata/MapReduce/"/>
      <url>/33.Bigdata/MapReduce/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/hadoop/MapReduce-Shuffle.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 33.Bigdata </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hive</title>
      <link href="/33.Bigdata/Hive/"/>
      <url>/33.Bigdata/Hive/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>  Hive是建立在Hadoop上的数据仓库基础架构。它提供了一系列的工具，用来进行数据提取、转换、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据机制。可以把Hadoop下结构化数据文件映射为一张成Hive中的表，并提供类sql查询功能，除了不支持更新、索引和事务，sql其它功能都支持。可以将sql语句转换为MapReduce任务进行运行，作为sql到MapReduce的映射器。提供shell、JDBC/ODBC、Thrift、Web等接口。</p><p>  Hive 并不适合那些需要低延迟的应用，例如，联机事务处理（OLTP）。Hive 查询操作过程严格遵守Hadoop MapReduce 的作业执行模型，Hive 将用户的HiveQL 语句通过解释器转换为MapReduce 作业提交到Hadoop 集群上，Hadoop 监控作业执行过程，然后返回作业执行结果给用户。Hive 并非为联机事务处理而设计，Hive 并不提供实时的查询和基于行级的数据更新操作。Hive 的最佳使用场合是大数据集的批处理作业，例如，网络日志分析。</p><h1 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h1><p>  Hive将元数据存储在RDBMS中，有三种方式可以连接到数据库。</p><ul><li>内嵌模式：元数据保持在内嵌数据库的Derby，一般用于单元测试，只允许一个会话连接。</li><li>多用户模式：在本地安装Mysql，把元数据放到Mysql内。</li><li>远程模式：元数据放置在远程的Mysql数据库。</li></ul><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>  Hive没有专门的数据存储格式，也没有为数据建立索引，用于可以非常自由的组织Hive中的表，只需要在创建表的时候告诉Hive数据中的列分隔符和行分隔符。<br>  Hive中所有的数据都存储在HDFS中，Hive中包含4中数据模型：Tabel、ExternalTable、Partition、Bucket。</p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><p>  类似与传统数据库中的Table，每一个Table在Hive中都有一个相应的目录来存储数据。例如：一个表zz，它在HDFS中的路径为：/wh/zz，其中wh是在hive-site.xml中由${hive.metastore.warehouse.dir}指定的数据仓库的目录，所有的Table数据（不含External Table）都保存在这个目录中。</p><h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p>  类似于传统数据库中划分列的索引。在Hive中，表中的一个Partition对应于表下的一个目录，所有的Partition数据都存储在对应的目录中。例如：zz表中包含ds和city两个Partition，则对应于ds=20140214，city=beijing的HDFS子目录为：/wh/zz/ds=20140214/city=Beijing。</p><h2 id="ExternalTable"><a href="#ExternalTable" class="headerlink" title="ExternalTable"></a>ExternalTable</h2><p>  指向已存在HDFS中的数据，可创建Partition。和Table在元数据组织结构相同，在实际存储上有较大差异。Table创建和数据加载过程，可以用统一语句实现，实际数据被转移到数据仓库目录中，之后对数据的访问将会直接在数据仓库的目录中完成。删除表时，表中的数据和元数据都会删除。ExternalTable只有一个过程，因为加载数据和创建表是同时完成。时间数据是存储在Location后面指定的HDFS路径中的，并不会移动到数据仓库中。</p><h2 id="Bcuket"><a href="#Bcuket" class="headerlink" title="Bcuket"></a>Bcuket</h2><p>  对指定列计算的hash，根据hash值切分数据，目的是为了便于并行，每一个Buckets对应一个文件。将user列分数至32个Bucket上，首先对user列的值计算hash，比如，对应hash=0的HDFS目录为：/wh/zz/ds=20140214/city=Beijing/part-00000;对应hash=20的，目录为：/wh/zz/ds=20140214/city=Beijing/part-00020。</p><h1 id="Hive-QL"><a href="#Hive-QL" class="headerlink" title="Hive QL"></a>Hive QL</h1><ul><li><p>create table</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_user(id int,name string) </span><br><span class="line">    // 注释</span><br><span class="line">    comment &apos;This is the test table&apos;</span><br><span class="line">    row format delimited</span><br><span class="line">    // 指定切分格式规则</span><br><span class="line">    fields terminated by &apos;,&apos;</span><br><span class="line">    // 指定文件格式</span><br><span class="line">    stored as textfile;</span><br></pre></td></tr></table></figure></li><li><p>insert select</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用select语句来批量插入数据</span><br><span class="line">insert overwrite table test_user select * from tab_user;</span><br></pre></td></tr></table></figure></li><li><p>load data</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//从本地导入数据到hive的表中（实质就是将文件上传到hdfs中hive管理目录下）</span><br><span class="line">load data local inpath &apos;/home/hadoop/test.txt&apos; into table test_user;</span><br><span class="line">//从hdfs上导入数据到hive表中（实质就是将文件从原始目录移动到hive管理的目录下）</span><br><span class="line">load data inpath &apos;hdfs://ns1/data.log&apos; into table test_user;</span><br></pre></td></tr></table></figure></li><li><p>external table</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//LOCATION指定的是hdfs路径</span><br><span class="line">//如果LOCATION路径有数据,则可以直接映射数据建表</span><br><span class="line">CREATE EXTERNAL TABLE test_user_external(id int, name string)</span><br><span class="line"> ROW FORMAT DELIMITED</span><br><span class="line"> FIELDS TERMINATED BY &apos;,&apos;</span><br><span class="line"> STORED AS TEXTFILE</span><br><span class="line"> LOCATION &apos;/external/user&apos;;</span><br></pre></td></tr></table></figure></li><li><p>CTAS</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//CTAS是通过查询,然后根据查询的结果来建立表格的一种方式。</span><br><span class="line">//CTAS会根据SELECT语句创建表结构,并把数据一并复制过来。</span><br><span class="line">CREATE TABLE test_user_ctas</span><br><span class="line">   AS</span><br><span class="line">SELECT id new_id, name new_name</span><br><span class="line">FROM test_user</span><br><span class="line">SORT BY new_id;</span><br></pre></td></tr></table></figure></li><li><p>Partition</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建一个分区表,以year年份作为分区字段</span><br><span class="line">create table test_user_part(id int,name string) </span><br><span class="line">    partitioned by (year string)</span><br><span class="line">    row format delimited fields terminated by &apos;,&apos;;</span><br><span class="line">//将data.log导入到test_user_part表中,并设置分区为1990    </span><br><span class="line">load data local inpath &apos;/home/hadoop/data.log&apos; overwrite into table test_user_part</span><br><span class="line">     partition(year=&apos;1990&apos;);</span><br><span class="line">    </span><br><span class="line">load data local inpath &apos;/home/hadoop/data2.log&apos; overwrite into table test_user_part</span><br><span class="line">     partition(year=&apos;2000&apos;);</span><br></pre></td></tr></table></figure></li><li><p>Array&amp;&amp;Map:<br>hive中的列支持使用struct、map和array集合数据类型。大多数关系型数据库中不支持这些集合数据类型，因为它们会破坏标准格式。关系型数据库中为实现集合数据类型是由多个表之间建立合适的外键关联来实现。在大数据系统中，使用集合类型的数据的好处在于提高数据的吞吐量，减少寻址次数来提高查询速度。</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//array </span><br><span class="line">create table tab_array(a array&lt;int&gt;,b array&lt;string&gt;)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &apos;\t&apos;</span><br><span class="line">collection items terminated by &apos;,&apos;;</span><br><span class="line">select a[0] from tab_array;</span><br><span class="line">select * from tab_array where array_contains(b,&apos;word&apos;);</span><br><span class="line">insert into table tab_array select array(0),array(name,ip) from tab_ext t; </span><br><span class="line"></span><br><span class="line">//map</span><br><span class="line">create table tab_map(name string,info map&lt;string,string&gt;)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &apos;\t&apos;</span><br><span class="line">collection items terminated by &apos;,&apos;</span><br><span class="line">map keys terminated by &apos;:&apos;;</span><br><span class="line">load data local inpath &apos;/home/hadoop/hivetemp/tab_map.txt&apos; overwrite into table tab_map;</span><br><span class="line">insert into table tab_map select name,map(&apos;name&apos;,name,&apos;ip&apos;,ip) from tab_ext;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Hive常用优化方法"><a href="#Hive常用优化方法" class="headerlink" title="Hive常用优化方法"></a>Hive常用优化方法</h1><ul><li>join连接时的优化：当三个或多个以上的表进行join操作时，如果每个on使用相同的字段连接时只会产生一个mapreduce。</li><li>join连接时的优化：当多个表进行查询时，从左到右表的大小顺序应该是从小到大。原因：hive在对每行记录操作时会把其他表先缓存起来，直到扫描最后的表进行计算。</li><li>在where字句中增加分区过滤器。</li><li>当可以使用left semi join 语法时不要使用inner join，前者效率更高。原因：对于左表中指定的一条记录，一旦在右表中找到立即停止扫描。</li><li>如果所有表中有一张表足够小，则可置于内存中，这样在和其他表进行连接的时候就能完成匹配，省略掉reduce过程。设置属性即可实现，set hive.auto.covert.join=true; * 用户可以配置希望被优化的小表的大小 set hive.mapjoin.smalltable.size=2500000; 如果需要使用这两个配置可置入$HOME/.hiverc文件中。</li><li>同一种数据的多种处理：从一个数据源产生的多个数据聚合，无需每次聚合都需要重新扫描一次。</li><li>例如:insert overwrite table student select 　from employee; insert overwrite table person select from employee;</li><li>可以优化成 from employee insert overwrite table student select insert overwrite table person select</li><li>limit调优：limit语句通常是执行整个语句后返回部分结果。set hive.limit.optimize.enable=true;</li><li>开启并发执行。某个job任务中可能包含众多的阶段，其中某些阶段没有依赖关系可以并发执行，开启并发执行后job任务可以更快的完成。设置属性：set * hive.exec.parallel=true;</li><li>hive提供的严格模式，禁止3种情况下的查询模式。<ul><li>当表为分区表时，where字句后没有分区字段和限制时，不允许执行。</li><li>当使用order by语句时，必须使用limit字段，因为order by 只会产生一个reduce任务。</li><li>限制笛卡尔积的查询。</li></ul></li><li>合理的设置map和reduce数量。</li><li>jvm重用。可在hadoop的mapred-site.xml中设置jvm被重用的次数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 33.Bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/33.Bigdata/Hadoop/"/>
      <url>/33.Bigdata/Hadoop/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0e/Hadoop_logo.svg/2000px-Hadoop_logo.svg.png" alt="Hadoop"></p><h1 id="Hadoop-安装-amp-配置"><a href="#Hadoop-安装-amp-配置" class="headerlink" title="Hadoop 安装 &amp; 配置"></a>Hadoop 安装 &amp; 配置</h1><h2 id="Hadoop-amp-Yarn安装步骤"><a href="#Hadoop-amp-Yarn安装步骤" class="headerlink" title="Hadoop &amp; Yarn安装步骤"></a>Hadoop &amp; Yarn安装步骤</h2><p>参考: <a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html" target="_blank" rel="noopener">Apache Hadoop 2.9.2 – Hadoop Cluster Setup</a></p><ol><li>/etc/hosts, ssh登录 // 使slave可以ssh到master<ul><li>/etc/hosts: 所有slave可互相ping hostname</li><li>authorized_keys : master可以ssh任意slave</li></ul></li><li>hadoop配置文件<ul><li>hadoop-env.sh : <code>HADOOP_CONF_DIR</code> 指定加载哪个目录下的配置文件</li><li>slaves: 只有namenode需配置</li><li>core-site.xml:(<a href="https://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-common/core-default.xml</a>)<ul><li>fs.defaultFS : hdfs://namenode:9000 ## hdfs文件端口</li><li>hadoop.tmp.dir : /opt/data/hadoop/tmp 其它目录会基于此路径</li></ul></li><li>hdfs-site.xml:(<a href="https://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml</a>)<ul><li>dfs.namenode.secondary.http-address :  第二NameNode web管理端口</li><li>dfs.replication : 3 ## 数据需要备份的数量, 默认是3, 如果此数大于集群的机器数会出错</li><li>dfs.namenode.name.dir : /opt/data/hadoop/namenode ## NameNode持久存储名字空间及事务日志的本地文件系统路径</li><li>dfs.datanode.data.dir : /opt/data/hadoop/datenode ## DataNode存放块数据的本地文件系统路径</li><li>dfs.namenode.http-address : namenode:50070  ## 浏览器可访问管理页面</li><li>dfs.webhdfs.enabled : 开启WebHDFS (REST API)功能</li></ul></li><li>mapred-site.xml:<ul><li>mapreduce.framework.name: yarn</li><li>mapreduce.jobhistory.address: 10020</li><li>mapreduce.jobhistory.webapp.address: 19888</li></ul></li><li>yarn-site.xml<ul><li>yarn.resourcemanager.webapp.address: 8088 ## yarn框架中各个 task 的资源调度及运行状况通过通过该web界面访问</li></ul></li></ul></li><li>格式化namenode: <code>hdfs namenode -format</code></li><li>启动HDFS NameNode: <code>sbin/hadoop-daemon.sh start namenode</code></li><li>启动HDFS DateNode: <code>sbin/hadoop-daemons.sh start datanode</code><ul><li><strong>或者在namenode上直接一个脚本启动: <code>sbin/start-dfs.sh</code> namenode和datanode的所有hdfs</strong></li></ul></li><li>启动yarn: <code>sbin/start-yarn.sh</code>脚本一次启动ResourceManager和NodeManager, 如果要分别启动:<ul><li><code>yarn-daemon.sh --config /opt/conf/hadoop start nodemanager</code></li><li><code>yarn-daemon.sh --config /opt/conf/hadoop start resourcemanager</code></li></ul></li><li>查看集群状态: <code>bin/hdfs dfsadmin -report</code></li><li>测试hdfs写: <code>echo &quot;hello world&quot; | hadoop fs -put - /dir/hadoop/hello_world.txt &amp;&amp; hadoop fs -cat  /dir/hadoop/hello_world.txt</code></li><li>一些web ui:<ul><li>查看nameNode: <a href="http://namenode:50070/" target="_blank" rel="noopener">http://namenode:50070/</a></li><li>查看yarn resourcemanager: <a href="http://namenode:8088/" target="_blank" rel="noopener">http://namenode:8088/</a></li><li>MapReduce JobHistory: <a href="http://namenode:19888" target="_blank" rel="noopener">http://namenode:19888</a></li></ul></li></ol><h2 id="一些重要参数"><a href="#一些重要参数" class="headerlink" title="一些重要参数"></a>一些重要参数</h2><p>@todo</p><h1 id="客户端-API-amp-命令行"><a href="#客户端-API-amp-命令行" class="headerlink" title="客户端 API &amp; 命令行"></a>客户端 API &amp; 命令行</h1><h2 id="Hadoop命令"><a href="#Hadoop命令" class="headerlink" title="Hadoop命令"></a>Hadoop命令</h2><ul><li>参考: <a href="https://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-common/CommandsManual.html" target="_blank" rel="noopener">Apache Hadoop 2.7.3 – Hadoop Commands Guide</a></li><li>hadoop dfs: 针对dfs的命令, 已经Deprecated, 推荐使用<code>hdfs dfs</code></li><li>hadoop fs: 本地与dfs交互的命令<ul><li>hadoop fs -cat file:///file3 /user/hadoop/file4</li><li>hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2</li><li>hadoop dfs -df /user/hadoop/dir1</li><li>hadoop fs -du -h /user/hadoop/dir1 hdfs://nn.example.com/user/hadoop/dir1</li><li>hadoop fs -put <localsrc> … <dst></dst></localsrc></li></ul></li><li>hadoop version</li><li>hadoop jar <jar> [mainClass] arg</jar></li></ul><h2 id="HDFS命令"><a href="#HDFS命令" class="headerlink" title="HDFS命令"></a>HDFS命令</h2><ul><li>参考: <a href="https://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-hdfs/HDFSCommands.html" target="_blank" rel="noopener">Apache Hadoop 2.7.3 – HDFS Commands Guide</a></li></ul><h2 id="Yarn命令"><a href="#Yarn命令" class="headerlink" title="Yarn命令"></a>Yarn命令</h2><p>*　参考: <a href="https://hadoop.apache.org/docs/r2.7.3/hadoop-yarn/hadoop-yarn-site/YarnCommands.html" target="_blank" rel="noopener">Apache Hadoop 2.7.3 – YARN Commands</a></p><h1 id="HDFS文件系统解析"><a href="#HDFS文件系统解析" class="headerlink" title="HDFS文件系统解析"></a>HDFS文件系统解析</h1><ul><li><a href="http://flyingdutchman.iteye.com/blog/1874518" target="_blank" rel="noopener">Hadoop深入学习：HDFS分布式文件系统的体系结构</a></li></ul><blockquote><p>NameNode的FSImage和Edit log工作方式: FSImage中保存着某一时刻的HDFS文件目录树、元数据和数据块索引等信息，而后续的对这信息系的修改则保存在Edit log中<br>Secondary NameNode和NameNode的区别在于他不接受或记录HDFS的任何实时变化，只是根据集群配置的时间间隔不停的获取HDFS的某一个时间节点的FSImage和编辑日志，合并得到一个新的命名空间镜像FSImage，然后该镜像会上传到NameNode，替换原有的镜像文件，并清空编辑日志。<br>DataNode: 客户端操作文件块Block时，先由NameNode节点告知客户端诗句块所在的节点的位置，然后客户端直接与DataNode节点通信，处理与数据块对应的Linux上的本地文件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 33.Bigdata </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 批处理计算 </tag>
            
            <tag> Apache </tag>
            
            <tag> Hadoop </tag>
            
            <tag> HDFS </tag>
            
            <tag> MapReduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-05架构-高性能和高可用</title>
      <link href="/32.Database/MySQL-05%E6%9E%B6%E6%9E%84-%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/32.Database/MySQL-05%E6%9E%B6%E6%9E%84-%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>@toc</p><ul><li>主从同步</li><li>分库分表</li></ul><a href="/32.Database/MySQL-05架构-日志/" title="MySQL-05架构-日志">MySQL-05架构-日志</a>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-05架构-日志</title>
      <link href="/32.Database/MySQL-05%E6%9E%B6%E6%9E%84-%E6%97%A5%E5%BF%97/"/>
      <url>/32.Database/MySQL-05%E6%9E%B6%E6%9E%84-%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>三种日志的作用分别是什么?</li><li>三种日志数据格式有何不同?</li><li>分别在MySQL架构哪一层实现;</li></ul><p>比较 Redo log/Undo log/Binlog:</p><ul><li>作用不同:<ul><li>Redo log是WAL机制的日志, 更新数据先落日志, 防止Crash;</li><li>Undo log是实现事务回滚和MVCC的;</li><li>Binlog 是 server层实现的;</li></ul></li><li>数据格式: Redo log是物理日志 …</li><li>实现的层级不同: Redo/Undo 是引擎层实现, Binlog是server层实现</li><li>写入时机:</li></ul><p>@ref: </p>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-04事务-特性和实现原理</title>
      <link href="/32.Database/MySQL-04%E4%BA%8B%E5%8A%A1-%E7%89%B9%E6%80%A7%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/32.Database/MySQL-04%E4%BA%8B%E5%8A%A1-%E7%89%B9%E6%80%A7%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><p>什么是ACID: 如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性（事务的特性）：</p><ul><li><strong>原子性 Atomicity</strong>：原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</li><li><strong>一致性 Consistency</strong>：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。 假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。一致性是通过AID特性共同实现的</li><li><strong>隔离性 Isolation</strong>：数据库允许多个并发事务同时对其数据进行读写和修改，规定并发事务之间的数据互不影响，隔离性用于控制多个事务并发执行结果的可见性。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性 Durability</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h2 id="MySQL如何实现ACID"><a href="#MySQL如何实现ACID" class="headerlink" title="MySQL如何实现ACID"></a>MySQL如何实现ACID</h2><ul><li>事务原子性的实现:<ul><li>Undo log 记录了每次数据修改的记录, 当事务失败时需要回滚, 会根据 Undo log, 如果是log记录的是insert 则回滚执行 delete, 如果log里是 delete, 则执行insert, 如果log里是update, 则执行一次相反的update, 所以叫 Undo log</li><li>@ref: <a href="/32.Database/MySQL-05架构-日志/" title="MySQL-05架构-日志">MySQL-05架构-日志</a></li></ul></li><li>事务持久性的实现:<ul><li>Redo log(重做日志) 当数据修改时，除了修改Buffer Pool中的数据，还会在Redo log记录这次操作；Redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</li></ul></li><li>事务隔离性的实现:<ul><li>这部分参考→<a href="/32.Database/MySQL-04事务-特性和实现原理/" title="MySQL-04事务-特性和实现原理">MySQL-04事务-特性和实现原理</a></li><li>事务A的写, 对于事务B写操作的影响: 通过「基于锁的并发控制」(LBCC), 写操作加写锁(X锁, 即排它锁)</li><li>事务A的写, 对于事务B读操作的影响: 通过「多版本并发控制」(MVCC), // 读不加锁, 而是采用读视图(活跃事务数组)+ 数据版本(row trx_id) + Undo log实现 // MVCC解决的是RR下的读? // Gap锁?</li></ul></li><li>事务的一致性:<ul><li>定义: 事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</li><li>MySQL事务一致性的实现: 一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。</li><li>如何实现业务数据的一致性: 数据库引擎保证的A(原子性), I(隔离性), D(持久性), 应用层面代码逻辑正确(比如转账过程做了减扣之后, 逻辑错误导致没有执行增加)</li></ul></li></ul><blockquote><p>@ref <a href="https://draveness.me/mysql-transaction/" target="_blank" rel="noopener">『浅入深出』MySQL 中事务的实现 - 面向信仰编程</a><br>@ref <a href="https://www.cnblogs.com/kismetv/p/10331633.html" target="_blank" rel="noopener">深入学习MySQL事务：ACID特性的实现原理 - 编程迷思 - 博客园</a></p></blockquote><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>➤ 什么是脏读、幻读、不可重复读:</p><ul><li>脏读: 就是指当一个事务正在访问数据, 并且对数据进行了修改, 而这种修改还没有提交到数据库中, 同时另外一个事务也访问这个数据, 然后读到了这个数据</li><li>不可重复读：一个事务前后查询 <em>同一行记录</em> 两次, 两次查询到的记录不一致 (期间另外一个事务对 <em>此行数据</em> 进行了修改并提交);</li><li>幻读：一个事务内前后两次查询 (相同的where条件), <del>查询出来记录的数目不一致 (期间有其他事务进行了del/insert),</del>  两次查询到的结果集不一致, 比如多了一行结果, 多出来的被称为”phantoms row”;</li></ul><blockquote><p>@ref: Mysql官网对幻读行的介绍: <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html" target="_blank" rel="noopener">Phantom Rows</a><br>For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.<br>给出的例子是  <code>select * where id &gt; 100</code>执行两次, 第二次查询前, 有另一个事务插入了<code>id=101</code>的行, 然后第二次读…</p></blockquote><p>➤ 事务的隔离级别:</p><ul><li><strong>未提交读(Read Uncommitted)</strong>：允许脏读, 也就是可能读取到其他事务中”未提交事务”修改的数据;</li><li><strong>提交读(Read Committed)</strong>：(Oracle默认级别) 避免了脏读, 仍有”幻读”和”不可重复读”, 即一个事务中能读取到 其他事务提交的数据;</li><li><strong>可重复读(Repeated Read)</strong>：(InnoDB默认级别) 避免了不可重复读, 在同一个事务内的查询都是事务开始时刻一致的, 同时该级别下通过Gap锁机制避免了幻读;</li><li><strong>串行读(Serializable)</strong>：完全串行化的读，<del>~每次读都需要获得表级共享锁</del>~，写锁排斥读写, 读锁排斥写 // 这里是加表级锁还是行锁? 需要根据<code>where</code>条件匹配到的列是主键/唯一/非唯一/非索引几种情况具体分析</li></ul><h2 id="隔离级别的实现"><a href="#隔离级别的实现" class="headerlink" title="隔离级别的实现"></a>隔离级别的实现</h2><p>➤ MVCC是什么: Multiversion Concurrency Control, 多版本并发控制</p><ul><li>MySQL每条记录在更新的时候都会有有一个数据版本号(row trx_id), 所以一条记录可以存在多个版本, 同时每条记录在更新的时候还会记录一条 Undo log;</li><li>MySQL通过可见事务id组成的视图, 以及”版本号+Undo log” 共同实现了事务的MVCC, 每个事务中的读操作可以看到不同的读视图(Read View), 也叫 “快照读” // @ref: <a href="/32.Database/MySQL-04事务-特性和实现原理/" title="MySQL-04事务-特性和实现原理">MySQL-04事务-特性和实现原理</a></li><li>MVCC的特点: 读不加锁, 读与写不冲突. 读写不冲突极大增加了系统并发性能.</li></ul><p>➤ LBCC是什么: Lock Based Concurrency Control, 基于锁的并发控制</p><ul><li>读的时候加S锁(共享锁), 不排斥其他线程读, 但排斥其他线程的写;</li><li>写的时候加x锁(排他锁), 排斥其他线程的读和写;</li><li>LBCC的缺点: 只能读并发, 读写串行化(写会互斥读)，这样就大大降低了数据库的读写性能</li></ul><p>➤ 快照读 vs 当前读:<br>在MySQL实现的并发控制中, 读操作分为两类: 快照读(snapshot read) 和当前读(current read)</p><ul><li><strong>快照读</strong>: 执行<code>select</code>查询的时候, 首先创建读视图, 在读视图中读”当前事务的可见版本”(有可能是历史版本), 不需要加锁; 不是所有<code>select</code>语句都是快照读, 还要看隔离级别<ul><li>如果在 RR/RC 级别则<code>select</code>是基于MVCC的快照读, 不加锁,;</li><li>如果在 Serializable 级别, 没有基于MVCC的快照, 是通过加S锁进行并发控制(也就是LBCC)</li></ul></li><li><strong>当前读</strong>: 执行<code>update</code>,<code>delete</code>, <code>insert</code>, 或<code>select ... for update</code> 的时候, 读出来的是最新的数据版本, 需要加X锁</li></ul><p>➤ 事务的四种隔离级别如何实现:</p><ul><li>Serializable级别(解决脏读 &amp; 幻读):<ul><li>基于锁的并发控制(LBCC) 读加S锁(排斥其他写), 写加X锁(排查其他读写)</li><li>因为读写都加锁, 该级别解决了脏读, 幻读</li></ul></li><li>RC(读提交)级别(解决了脏读, 但没有解决幻读):<ul><li>对于读, RC是’快照读’, 读不加锁, 基于MVCC实现, 在每个语句执行时创建读视图;</li><li>对于读, RC是’当前读”, 在相关的数据行上加’X锁’, where条件列不同(主键/非主键索引/非索引) X锁影响到的行也不同, 详细见→ [[MySQL-04锁-SQL加锁分析]]</li></ul></li><li>RR(可重复读)级别: 通过MVCC实现, 解决幻读现象<ul><li>快照读: MVCC, 读视图在事务开始时创建, 注意这里和RC级别不同, 因为是事务开始时创建, 所以整个事务过程中的读视图都一样</li><li>当前读: 也是通过加X锁实现, 不同之处在于, RR级别为了解决幻读, 还引入了间隙锁(Gap锁);</li></ul></li></ul><p>总结: Serializable级别使用LBCC进行并发控制, RR/RC 级别使用 MVCC进行并发控制, MVCC即通过 “row trx_id” 和 “Undo log”组成一个读视图(Read View), RR级别的读视图在…时创建, RC级别的读视图在…时创建</p>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
            <tag> ACID </tag>
            
            <tag> MVCC </tag>
            
            <tag> LBCC </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-04事务-使用事务</title>
      <link href="/32.Database/MySQL-04%E4%BA%8B%E5%8A%A1-%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1/"/>
      <url>/32.Database/MySQL-04%E4%BA%8B%E5%8A%A1-%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="本机事务-transaction"><a href="#本机事务-transaction" class="headerlink" title="本机事务(transaction)"></a>本机事务(transaction)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction; // 开始一个事务</span><br><span class="line"></span><br><span class="line"># 开始事务后, 表是没有锁的, 因为start transaction会隐式的unlock表</span><br><span class="line">SQL语句...</span><br><span class="line"></span><br><span class="line">savepoint xxx;</span><br><span class="line">SQL语句...</span><br><span class="line"></span><br><span class="line">rollback to savepoint xxx;</span><br><span class="line"></span><br><span class="line">// 在commit 之前, 其他线程可以查询表, 但看不到上面的结果</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">// 在commit 之后, 其他线程才可以看到改变</span><br></pre></td></tr></table></figure><h2 id="分布式事务-xa"><a href="#分布式事务-xa" class="headerlink" title="分布式事务(xa)"></a>分布式事务(xa)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xa start &apos;test&apos;, &apos;db1&apos;;  -- 启动xid=&apos;text&apos;, 分支=&apos;db1&apos;的分布式事务</span><br><span class="line">SQL 语句...</span><br><span class="line">xa end &apos;test&apos;, &apos;db1&apos;;</span><br><span class="line">xa prepare &apos;test&apos;, &apos;db1&apos;; -- 分支db1进入prepare状态</span><br><span class="line">-- 必须xid=&apos;test&apos;的所有分支都commit, 事务才算完成</span><br><span class="line">xa commit &apos;text&apos;, &apos;db1&apos;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>DB1</th><th>DB2</th><th></th></tr></thead><tbody><tr><td>xa start ‘transxxx’ ‘db1’</td><td>xa start ‘transxxx’ ‘db2’</td><td>开始事务</td></tr><tr><td>insert db1 ..</td><td>update db2 …</td><td></td></tr><tr><td>xa end  ‘transxxx’ ‘db1’</td><td>xa end  ‘transxxx’ ‘db2’</td><td></td></tr><tr><td>xa prepare  ‘transxxx’ ‘db1’</td><td>xa prepare  ‘transxxx’ ‘db2’</td><td>进入Prepare阶段</td></tr><tr><td>xa commit  ‘transxxx’ ‘db1’</td><td>xa commit  ‘transxxx’ ‘db2’</td><td>提交事务</td></tr></tbody></table><p>命令说明:</p><ul><li>开始事务: <code>xa start xid</code>, xid是某个分布式事务的唯一id, xid分三部分: 分布式事务标识+事务分支标识+formatid<ul><li>上面的例子只有 “分布式事务标识+事务分支标识”, 后者用db1/db2表示在不同库上的事务分支</li></ul></li><li>xa prepare:</li><li>xa commit:</li></ul><p><img src="../images/mysql-xa-transaction-states.png" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>@todo: MySQL分布式事务XA似乎用的是2PC ? 事务管理器组件 atomikos 的实现? @todo</p><blockquote><p>@ref <a href="https://yq.aliyun.com/articles/283392" target="_blank" rel="noopener">MySQL分布式事务（XA事务）-云栖社区-阿里云</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-04b-SQL加锁分析</title>
      <link href="/32.Database/MySQL-04b-SQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/"/>
      <url>/32.Database/MySQL-04b-SQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。<br>分析SQL语句加锁情况，还要考虑几种情况：当前用什么引擎（InnoDB/MyISAM）？你要当前系统的隔离级别是什么？ id列是不是主键？ id列如果不是主键，那么id列上有索引吗？id列上如果有二级索引，那么这个索引是唯一索引吗？</p></blockquote><p>➤ SQL语句在不同隔离级别的加锁分析:</p><ul><li>如果是 Serializable 级别, 防止了脏读, 读加S锁, 写加X锁;</li><li>如果是RC级别, 当前读允许有幻读, 所以上面的”非唯一索引的情形没有加Gap锁;</li><li>如果是RR级别: (RR级别解决了幻读问题, 事务中两次当前读, 读出来的数目一致), 以 <code>update T1 set id = 100 where name = ‘d’</code> 为例, 下面为了简化分析, 只考虑 <code>where =</code>的更新, 不考虑 <code>where between</code>范围更新 :<ul><li>如果 where条件是<code>=主键</code>: 聚簇索引上加X锁, 由于主键索引的唯一性, 只有一行加X锁;</li><li>如果 where条件是<code>=唯一索引</code>, 但非主键: 普通索引上加X锁(只有一行),  聚簇索引对应的行加X锁;</li><li>如果 where条件是<code>=非唯一索引</code>, 但非主键: 由于where索引是非唯一, where索引上可能有多行符合条件, 每行都需要加X锁, 同时行之间还需要加 <strong>Gap锁</strong> (间隙锁, 解决幻读), 聚簇索引对应的行都要加X锁;</li><li>如果 where条件上没有索引: 会导致聚簇索引上每行都加X锁( <strong>相当于锁住了整个表</strong>), 并且聚簇索引每行之间都加 Gap锁;</li><li>综上, update语句的条件是<code>where=主键</code>时, 需要的锁最少, 如果 update语句的 where条件是无索引列, 会引起整个主键索引树的每行都加X锁, 性能消耗非常大</li></ul></li></ul><p>➤ 锁优化建议</p><ol><li>合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。</li><li>尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。</li><li>尽量控制事务的大小，减少锁定的资源量和锁定时间长度。</li><li>在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。</li></ol><p>@ref:</p><ul><li><a href="http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html" target="_blank" rel="noopener">MySQL innodb中各种SQL语句加锁分析 | | For DBA</a></li><li><a href="http://mysql.taobao.org/monthly/2018/05/04/" target="_blank" rel="noopener">MySQL · 引擎分析 · InnoDB行锁分析</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html" target="_blank" rel="noopener">MySQL 事务隔离级别和锁</a></li><li><a href="https://juejin.im/entry/5aaa3438f265da23853296d4" target="_blank" rel="noopener">MVCC多版本并发控制与Mysql锁 - by 何登成</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 乐观锁 </tag>
            
            <tag> 悲观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-04a-锁概念</title>
      <link href="/32.Database/MySQL-04a-%E9%94%81%E6%A6%82%E5%BF%B5/"/>
      <url>/32.Database/MySQL-04a-%E9%94%81%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h2><p>@toc:</p><ul><li>全局锁/表级锁/行锁;</li><li>共享锁/排他锁;</li><li>意向锁;</li><li>两段锁协议;</li></ul><p>➤ 按锁的范围分: 全局锁(数据库锁), 表级锁(表锁, meta锁), 行锁;</p><ul><li>全局锁: 锁住整个数据库实例, 例如<code>Flush tables with read lock</code> 整个数据库处于只读状态, 常用于全库备份;</li><li>表级锁: 分为 <strong>表锁</strong> 和 <strong>元数据锁</strong><ul><li>表锁需要显式加锁: 例如 <code>lock table t1 write</code> 即给表t1加写锁, 允许读不允许写;</li><li>元数据锁(MDL) 不需要显式加,<ul><li>当增删改查时, 数据库自动给表加MDL读锁, 可以增删改查数据, 但对修改表结构互斥;</li><li>当修改表结构时, 数据库自动给表加MDL写锁;</li></ul></li></ul></li><li>行锁: 行锁分为S锁/X锁 (类似读写锁), 根据数据库当前隔离级别的不同, 以及sql语句的不同, 加的锁也不同;<ul><li>Serializable级别: 读加S锁, 写加X锁</li><li>RR/RC级别: 读不加锁(MVCC), 写可能加 X锁 和 间隙锁</li></ul></li></ul><blockquote><p>MyISAM 不支持行锁, 不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p></blockquote><p>表锁的使用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock table xxx read； // 读锁</span><br><span class="line">// 其他线程只可以对表select查询，查询立刻返回</span><br><span class="line">// 但是无法对update/delete，操作会阻塞</span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>参考:</p><ul><li>表锁/元数据锁 @ref:  [[../00.Course/course.MySQL实战45讲]] 第6节;</li><li>行锁 @ref:  [[../00.Course/course.MySQL实战45讲]] 第7节;</li></ul><p>➤ 按锁的特性分:</p><ul><li>共享锁(S锁): S锁类似读锁, 当线程1持有读锁, 不会排斥其他线程加读锁, 但排斥其他线程加写锁<ul><li>手动加 S 锁: <code>select * from tableName where … lock in share mode</code></li><li>自动加 S 锁: 串行隔离下, <code>select</code>语句加S锁</li></ul></li><li>排他锁(X锁): X锁类似写锁, 当线程1持有写锁, 排斥其他线程加读锁 or 写锁<ul><li>自动加 X 锁: 执行<code>update</code>, <code>select .. for update</code>,</li></ul></li><li>意向锁:<ul><li>IS锁: 意向共享锁, 事务加”S行锁”前, 必须取得该表的 IS锁;</li><li>IX锁: 意向独占锁, 事务加”X行锁”前, 必须取得该表的 IX锁; // IS和IX都是表级锁</li><li>「IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。」</li></ul></li></ul><p>@ref:</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual :: InnoDB Locking</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual ::  LOCK TABLES and UNLOCK TABLES Statements</a></li></ul><h2 id="什么是两段锁协议"><a href="#什么是两段锁协议" class="headerlink" title="什么是两段锁协议"></a>什么是两段锁协议</h2><ul><li>两段锁协议( Two-Phase Locking, 2PL): 事务中, 可以分为加锁阶段 和放锁阶段, 所以叫两段锁协议;</li><li>加锁阶段按照语句顺序进行加锁(例如事务中的 insert, update语句 到执行时才加相应的锁);</li><li>放锁阶段: 解开所有的锁;</li><li>也即行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</li></ul><h2 id="使用MySQL实现乐观锁-amp-悲观锁"><a href="#使用MySQL实现乐观锁-amp-悲观锁" class="headerlink" title="使用MySQL实现乐观锁&amp;悲观锁"></a>使用MySQL实现乐观锁&amp;悲观锁</h2><ul><li>悲观锁: 假定会出现冲突, 首先尝试锁定数据(获得锁), 然后修改数据, 通常使用<code>select .. for update</code>进行加锁, 注意, 加锁是执行加锁语句的时候才加锁, 放锁需要等到事务结束后才能放锁.</li><li>乐观锁: 假定不会出现冲突, 直接更新数据, 在更新数据的同时做判断是否冲突, 常见的MySQL乐观锁方式:<ul><li>使用version或timestamp, 先读取当前数据version/timestamp, 然后<code>update .. where version=x</code>的方式进行更新.</li></ul></li></ul><p>以更新商品库存为例( itemId primary key, count )说明乐观锁和悲观锁:</p><p>悲观锁更新库存:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from T where itemId=1 for update # 锁定</span><br><span class="line">update T set .. where itemId=1</span><br></pre></td></tr></table></figure><p>乐观锁更新库存: <strong>通常使用version 或时间戳</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select itemId, count from T where itemId = 1</span><br><span class="line">update T set count=count-1 where itemId = 1 and count=x</span><br></pre></td></tr></table></figure><blockquote><p>@ref <a href="https://www.jianshu.com/p/f5ff017db62a" target="_blank" rel="noopener">MySQL 乐观锁与悲观锁 - 简书</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 乐观锁 </tag>
            
            <tag> 悲观锁 </tag>
            
            <tag> 两段锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-03b-索引-BTree</title>
      <link href="/32.Database/MySQL-03b-%E7%B4%A2%E5%BC%95-BTree/"/>
      <url>/32.Database/MySQL-03b-%E7%B4%A2%E5%BC%95-BTree/</url>
      
        <content type="html"><![CDATA[<h1 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h1><p>@ref:</p><ul><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">CodingLabs - MySQL索引背后的数据结构及算法原理</a></li><li><a href="http://www.cnblogs.com/kissknife/archive/2009/03/30/1425534.html" target="_blank" rel="noopener">数据库进阶系列之一：漫谈数据库索引 - Morven.Huang - 博客园</a></li></ul><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>B-Tree不是 Binary Tree（二叉树，每个节点最多有两个子树），B的意思是Balance, 一棵M阶的B-Tree满足以下条件：</p><ul><li>每个结点至多有M个子节点；</li><li>根节点至少有 2个子节点；</li><li>除根结点和叶结点外，其它每个结点有至少有M/2个子节点；</li><li>每个非叶子节点由n-1个key和n个指针组成，其中 $M&lt;=n&lt;=2M$, key和指针互相间隔，节点两端是指针。</li><li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li><li>所有叶子结点在同一层（所有叶节点具有相同高度）</li></ul><p>下图是一个M=2的B-Tree:<br><img src="/images/database/mysql-index-b-tree-example1.png" alt="B-Tree"></p><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li><del>每个节点的指针上限为2M而不是2M+1</del></li><li>非叶子节点没有data, 只存储key(关键字) 和key之间的指针;</li><li>叶子节点只存储data和key, 没有key之间的指针;</li><li>相邻的叶子节点之间都有一个链表指针, 指向下一个key, 方便范围查找;</li></ul><p><img src="/images/database/mysql-index-b-tree-example2.png" alt="B+Tree"></p><p>为什不用bst(二叉): 树高, 叶节点多导致随机IO多 @ref [[../01.Algorithm/Alg.01.数据结构#二叉树]]</p><h2 id="B-Tree复杂度分析和比较"><a href="#B-Tree复杂度分析和比较" class="headerlink" title="B-Tree复杂度分析和比较"></a>B-Tree复杂度分析和比较</h2><p>B-Tree的时间复杂度分析(数阶=M, 树的高度=h, 索引了N个key):</p><ul><li>树高h的上限:  $\log_M ((N+1)/2)$</li><li>检索一个key的时间复杂度为: $O\log_M N$</li><li>插入复杂度: 插入会发生结点的分裂操作。分裂操作可以认为是常数级别, 所以插入时间复杂度基本等于 $O\log_M N$, 当然这是B-Tree都在内存中的情况</li><li>实际情况下, 数据库的B-Tree的节点并不都是在内存中, 插入操作会引起磁盘IO, 所以分析MySQL的B-Tree的插入代价还有考虑磁盘IO:<ul><li>当插入操作引起了s个节点的分裂时，磁盘访问的次数为<code>h(读取搜索路径上的节点)＋2s(更新两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）</code>。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。</li></ul></li><li>删除复杂度: 理想情况下$O\log_M N$,</li><li>删除操作的磁盘IO次数:  B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是 3h ＝（找到包含被删除元素需要h次<br>读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）</li></ul><blockquote><p>一般实际应用中，M是非常大的数字，通常超过100，因此h非常小（通常不超过3），业界公认MySQL单表容量在1KW以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。</p></blockquote><h2 id="MySQL如何使用索引"><a href="#MySQL如何使用索引" class="headerlink" title="MySQL如何使用索引"></a>MySQL如何使用索引</h2><p>数据库表中每个索引都可以认为是一个B-Tree</p><ul><li>聚集索引，表数据按照索引的顺序来存储的。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。</li><li>非聚集索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点存储的是内容是主键的值，通过非聚簇索引查询要再回主键的B树查询才能得到数据(回表), 所以也叫二级索引</li></ul><h2 id="MyISAM和InnoDB索引区别"><a href="#MyISAM和InnoDB索引区别" class="headerlink" title="MyISAM和InnoDB索引区别"></a>MyISAM和InnoDB索引区别</h2><ul><li>MyISAM的 主键or非主键索引, 叶子节点存储的都是数据的地址, 因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</li><li>InnoDB: 主键的索引B+Tree, 叶子节点存储的数据即一条完整记录(聚集索引), InnoDB的辅助索引的叶子节点存储的是 <strong>主键的值</strong> (非聚集索引)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-03a-索引-高效使用索引</title>
      <link href="/32.Database/MySQL-03a-%E7%B4%A2%E5%BC%95-%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
      <url>/32.Database/MySQL-03a-%E7%B4%A2%E5%BC%95-%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="创建索引原则"><a href="#创建索引原则" class="headerlink" title="创建索引原则"></a>创建索引原则</h1><ul><li>尽量选择区分度高的列作为索引,区分度的公式是<code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li><li>限制索引的长度, 尤其是 <code>FULLTEXT</code>索引, 比如只在<code>VARCHAR</code>字段的前20字节做索引;</li><li>字符类型和数字类型作为索引的性能差别，肯定是用数字类型索引更好。</li><li>用字符串做索引扫描是否会有性能损耗？两者的主要差别就在于，字符类型有字符集的概念，每次从存储端到展现端之间都有一个字符集编码的过程。而这一过程主要消耗的就是CPU资源；对于In-memory的操作来说，这是一个不可忽视的消耗。如果要固化到具体测试结果，我们这边的经验数据是20%，具体值还是和环境和数据有关系。此外，latin1 和 UTF8 之间也有10%左右的性能差别。</li><li>时间加索引的话，性能上 TIMESTAMP &gt; DATETIME</li></ul><h1 id="高效使用索引"><a href="#高效使用索引" class="headerlink" title="高效使用索引"></a>高效使用索引</h1><ul><li>使用覆盖索引(对于非主键的查询条件), 符合覆盖索引的情况:<ul><li>如果用到了联合索引, 联合索引用到的列, 恰好也是要查询的列( select colA, 且已经在colA创建了联合索引)</li><li>这种也是走覆盖索引: <code>select 主键 where 非主键列=X</code></li></ul></li></ul><p>① <strong>查询尽量使用到索引，避免使用全表扫描</strong></p><p>MySQL中能够使用索引的典型场景:</p><ul><li>匹配全值（Match the full value），Where条件中所有列都有索引, 且使用的是= 或者IN。</li><li>匹配值的范围查询（Match a range of values），Where条件中所有列都有索引, 且使用的是范围条件。例 <code>where id &gt; 10 and id &lt; 25</code></li><li>使用了联合索引, 且匹配最左前缀（Match a left most prefix），仅仅使用联合索引中的最左边列进行查找，比如在 col1+col2+col3 字段上的联合索引能够被包含col1、（col1+col2）、（col1+col2+col3）的等值查询利用到，可是不能够被col2、（col2+col3）的等值查询利用到；</li><li>匹配列前缀（Match a column prefix），仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找。<code>select title from film_text where title like &#39;AFRICAN%&#39;</code>;</li><li>如果列名是索引，那么使用 column_name is null 可以使用索引</li></ul><p>② <strong>注意不同类型的索引对性能有影响</strong></p><ul><li>对于频繁写入的情景, 普通索引比唯一索引更快 // why ?</li><li>对于查询的情况, 非聚簇索引比聚簇索引多一次回表, 如何避免非聚簇索引的回表?</li></ul><p>③ <strong>避免会索引失效的操作</strong></p><ul><li>在索引上使用函数: <code>select * from trade where month(data) = 7</code></li><li>索引的类型转换: 字段定义类型varchar, 但是查询语句用 <code>where id &gt; 7</code>, 相当于给id索引加上了<code>CAST</code>函数(隐式类型转换总是低精度类型→高精度类型)</li><li>以下where 都不会用到索引: <code>&lt;&gt;</code> 、<code>not in</code>、<code>not exist</code>、<code>!=</code></li><li>like, 百分号在前: <code>where col like &quot;%xxxx&quot;</code></li><li>单独引用复合索引里非第一位置的索引列</li><li>不要将空的变量值直接与比较运算符（符号）比较, 应使用 IS NULL 或 IS NOT NULL 进行比较</li></ul><blockquote><p>@todo 待整理: <a href="https://blog.csdn.net/monkey_d_feilong/article/details/52291556" target="_blank" rel="noopener">导致索引失效的可能情况</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-01b-SQL语句-JOIN原理及优化</title>
      <link href="/32.Database/MySQL-01b-SQL%E8%AF%AD%E5%8F%A5-JOIN%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/32.Database/MySQL-01b-SQL%E8%AF%AD%E5%8F%A5-JOIN%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>➤ Join中的驱动表概念:</p><ul><li>left join: 左表为驱动表</li><li>right join: 右表为驱动表</li></ul><p>➤ InnoDB是如何实现Join的?</p><p>Mysql的JOIN是通过 <code>Nested-Loop Join</code> 算法实现的(嵌套循环, 如同名字, 循环外层表也即驱动表, 外层表每一行数据再去内层表查找符合条件的数据 ), 有三种:</p><ul><li>Simple Nested-Loop Join 算法效率最低(Mysql并不使用这种Join算法), 可以认为是: 遍历外层所有符合条件的列, 每一行外层数据都再去遍历内层表, 依次比较, 如果外层表有N行(符合条件的)数据, 内层表有M行数据, 总共需要 <code>N*M</code> 次比较;</li><li>Index Nested-Loop Join (索引嵌套循环): 需要内层表的条件列有索引, 依然循环外层表所有符合条件的行, 但是由于内层表的条件列有索引, 并不需要对内层表进行全表扫描. (当内层表建立了索引, Mysql优先使用这种方式)</li><li>Block Nested-Loop Join (缓存块嵌套循环): 如果内层表没有索引会使用这种方式, 思路就是减少外层循环次数, 具体做法是: 外层表查出多条数据, 放入 join buffer, 然后以 join buff里的多条数据作为条件, 对内层表进行全表扫描. 能有效减少外层表的循环次数(也减少了内层表进行全表扫描的次数)</li></ul><p>➤ 如何让Mysql使用 Block Nested-Loop Join:</p><ul><li>设置 optimizer_switch的值为 <code>block_nested_loop=on</code></li><li>设置 join_buffer_size大小</li></ul><p>➤ How to 优化 Join:</p><ul><li>用小结果集驱动大结果集(减少外循环次数)</li><li>为内层表的条件列增加索引(避免内层全表扫描)</li><li>增大join buffer size的大小（一次缓存的数据越多，那么外层表循环的次数就越少）</li><li>减少不必要的字段查询（字段越少，join buffer 所缓存的数据就越多，外层表的循环次数就越少）</li><li>合理使用覆盖索引, 减少回表次数</li></ul><p>@ref:</p><ul><li><a href="https://www.jianshu.com/p/048d93d3ee54" target="_blank" rel="noopener">MySQL查询优化——连接以及连接原理 - 简书</a></li><li><a href="https://juejin.im/post/5bea59896fb9a049f23c49b8" target="_blank" rel="noopener">MySQL Join的底层实现原理 - 掘金</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-01a-SQL语句-基础和优化</title>
      <link href="/32.Database/MySQL-01a-SQL%E8%AF%AD%E5%8F%A5-%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BC%98%E5%8C%96/"/>
      <url>/32.Database/MySQL-01a-SQL%E8%AF%AD%E5%8F%A5-%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h1><p>MySQL官方文档中提供了一套示例数据库 Employees, MySQL官方文档中说明详见 <a href="http://dev.mysql.com/doc/employee/en/employee.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/employee/en/employee.html</a>。里面详细介绍了此数据库，并提供了下载地址和导入方法。</p><blockquote><p><a href="https://blog.csdn.net/wepe12/article/details/53024400" target="_blank" rel="noopener">mysql测试数据库employees一些sql语句_数据库_wepe12的博客-CSDN博客</a></p></blockquote><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><pre><code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                    <span class="keyword">VALUES</span></span><br><span class="line">                    ( value1, value2,...valueN ), // 插入多行</span><br><span class="line">                    ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure></code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure></code></pre><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><pre><code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1=<span class="keyword">new</span>-value1, field2=<span class="keyword">new</span>-value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure></code></pre><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><pre><code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[<span class="keyword">LIMIT</span> N][ <span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure></code></pre><h3 id="子句-WHERE-HAVING-GROUP-BY-ORDER-BY-LIMIT"><a href="#子句-WHERE-HAVING-GROUP-BY-ORDER-BY-LIMIT" class="headerlink" title="子句: WHERE, HAVING, GROUP BY, ORDER BY, LIMIT"></a>子句: WHERE, HAVING, GROUP BY, ORDER BY, LIMIT</h3><p>按照被执行的顺序: from、where、group by、having、select、order by、limit</p><ul><li>WHERE: 是唯一一个是直接从磁盘获取数据的时候就开始判断的条件, 从磁盘取出一条记录, 开始进行where判断:判断的结果如果成立就保存到内存中, 如果失败则直接放弃</li><li>GROUP BY: 根据一个或多个列, 对结果集进行分组, 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。<ul><li>支持的聚集函数：<code>SUM()</code> 统计求和, <code>COUNT()</code> 统计分组后每一组有多少个记录, <code>AVG()</code> 统计平均值</li><li>示例: 可以GROUP BY多个字段: <code>SELECT user_name, SUM(order_price) FROM ORDER_TAB GROUP BY user_name, order_data</code></li><li>示例: GROUP BY的回溯统计<code>WITH ROLLUP</code> 可以实现在分组统计数据基础上再进行相同的统计: <code>SELECT user_name, SUM(order_price) FROM ORDER_TAB GROUP BY user_name WITH ROLLUP</code>, 返回的数据会多一行, 该行的SUM等于<code>GROUP</code>返回结果再做一次求和</li></ul></li><li>HAVING: 对GROUP BY的结果进行条件筛选, HAVING子句一般跟在GROUP BY子句后面。在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。<ul><li>HAVING与WHERE的区别: <code>WHERE</code>是直接从磁盘取数据, 查询出的数据放入内存, 然后可以用聚合函数+<code>GROUP BY</code>分组, 分组后的数据用<code>HAVING</code>再筛选</li><li>示例: <code>SELECT user_name, SUM(order_price) FROM ORDERS_TAB GROUP BY user_name HAVING SUM(order_price)&gt;100</code></li></ul></li><li>ORDER BY: 排序<ul><li>示例: <code>SELECT order_id, order_price FROM ORDER_TAB ORDER BY order_data desc</code></li></ul></li><li>LIMIT：限制<ul><li>示例: <code>SELECT * FROM table LIMIT 10</code>   # 取出10条</li><li>示例: <code>SELECT * FROM table LIMIT 95,-1;</code> # 检索记录行 96-last.</li><li>示例: <code>SELECT * FROM table LIMIT 5,10;</code>  # 返回第6-15行数据</li></ul></li></ul><h3 id="列去重"><a href="#列去重" class="headerlink" title="列去重"></a>列去重</h3><ul><li><code>DISTINCT 列名</code>: 根据该列名, 在结果中去重<ul><li><code>SELECT  distinct(task_id), task_name from task</code>;  –带有distinct的列必须在第一个</li><li>但是上面的语句要id和name都相同的情况下才能虑重, 所以用下面的方式: <code>SELECT task_id, count(DISTINCT task_name) FROM table</code> –与其他函数使用时候，没有位置限制</li></ul></li></ul><h3 id="WHERE的比较"><a href="#WHERE的比较" class="headerlink" title="WHERE的比较"></a>WHERE的比较</h3><p>WHERE查询支持的条件:</p><ul><li>逻辑运算符 与或非: <code>AND</code>, <code>OR</code>, <code>NOT</code></li><li>运算符: <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>like</code>, <code>between ... and</code>, <code>in</code>, <code>not in</code></li></ul><p>下面是例子:</p><ul><li>NULL:<ul><li><code>SELECT * FROM 表名 WHERE 字段名 IS NULL</code>;</li><li><code>SELECT * FROM 表名 WHERE 字段名 IS NOT NULL</code>;</li></ul></li><li>LIKE:<ul><li><code>SELECT * FROM 表名 WHERE 字段名 LIKE &#39;%COM&#39;</code> # <code>%</code>多个字符，<code>_</code>单个字符</li></ul></li><li>IN：<ul><li><code>WHERE column_name IN (value1,value2,...)</code></li></ul></li><li>&lt;, &gt;, &gt;=, &lt;=, 可以用于比较时间：<ul><li><code>select count(*) from sometable where datetimecolumn&gt;=&#39;2010-03-01 00:00:00&#39;</code></li><li><code>select count(*) from sometable where datetimecolumn&gt;=UNIX_TIMESTAMP(&#39;2010-03-01 00:00:00&#39;)</code></li></ul></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询包括: 隐性连接和显性连接,<br>WHERE子句中使用的连接语句，在数据库语言中被称为隐性连接。<br>JOIN……ON子句产生的连接称为显性连接。<br>WHERE 和INNER JOIN产生的连接关系，没有本质区别，结果也一样。<br>但是隐性连接随着数据库语言的规范和发展，已经逐渐被淘汰，比较新的数据库语言基本上已经抛弃了隐性连接，全部采用显性连接了。</p><p>隐性连接: <code>SELECT T1.ID, T1.COLA, T2.COL2 FROM TABLE1 AS T1, TABLE2 AS T2 WHERE T1.ID=T2.ID</code></p><h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><ul><li><p>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T1.ID, T1.COLA, T2.COL2</span><br><span class="line"><span class="keyword">FROM</span> TABLE1 <span class="keyword">AS</span> T1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> TABLE2 <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.ID=T2.ID</span><br></pre></td></tr></table></figure></li><li><p>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</p></li><li><p>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p></li><li><p>多次JOIN:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> collum <span class="keyword">from</span> TABLE1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TABLE2 <span class="keyword">ON</span> condition2</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> TABLE3 <span class="keyword">ON</span> condition3</span><br></pre></td></tr></table></figure></li></ul><p>Join 语句的优化 @ref [[MySQL-01-SQL语句-JOIN原理及优化]]</p><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>UNION： 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。UNION会去掉重复的行, 但UNION ALL不会。</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> columnA <span class="keyword">from</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> collumB <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure><p>columnA和columnB必须是同类型</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>用括号<code>()</code>括起来的一个完整查询语句相当于一个Table, 子查询不包含 ORDER BY 子句。对一个 SELECT 语句只能用一个 ORDER BY 子句，并且如果指定了它就必须放在主 SELECT 语句的最后。</p><ul><li><p>子查询作为 查询条件:</p><ul><li><p>如果子查询返回单个结果, 可以用 例如 =，&gt;，&lt;等, 与子查询比较 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customerNumber, checkNumber, amount FROM payments</span><br><span class="line">WHERE amount = (SELECT MAX(amount) FROM payments);</span><br></pre></td></tr></table></figure></li><li><p>如果子查询返回多个结果, 可以用 IN和 NOT IN:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT customerName FROM customers</span><br><span class="line">WHERE customerNumber NOT IN (</span><br><span class="line">    SELECT DISTINCT customerNumber FROM orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>FROM子句 + 子查询:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(items), MIN(items), FLOOR(AVG(items))</span><br><span class="line">FROM (</span><br><span class="line">    SELECT orderNumber, COUNT(orderNumber) AS items FROM orderdetails</span><br><span class="line">    GROUP BY orderNumber</span><br><span class="line">) AS lineitems;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>EXISTS 和 NOT EXISTS: 当子查询与 EXISTS或 NOT EXISTS运算符一起使用时，子查询返回一个布尔值为TRUE或FALSE的值。以下查询说明了与EXISTS运算符一起使用的子查询：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_students_info</span><br><span class="line">WHERE EXISTS (</span><br><span class="line">    SELECT dept_name FROM tb_departments WHERE dept_id=1</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用Explain分析SQL执行"><a href="#使用Explain分析SQL执行" class="headerlink" title="使用Explain分析SQL执行"></a>使用Explain分析SQL执行</h2><p><code>explain</code>显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。使用方法，在select语句前加上<code>explain</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles</span><br><span class="line">WHERE emp_no=&apos;10001&apos;</span><br><span class="line">AND title IN (&apos;Senior Engineer&apos;, &apos;Staff&apos;, &apos;Engineer&apos;, &apos;Senior Staff&apos;, &apos;Assistant Engineer&apos;, &apos;Technique Leader&apos;, &apos;Manager&apos;)</span><br><span class="line">AND from_date=&apos;1986-06-26&apos;;</span><br><span class="line"></span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>➤ 关注的列: possible_keys, key, type, 其中 <strong>type</strong>列表示查询类型, 改列可能的值:</p><ul><li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li><li>const: 针对主键或唯一索引的等值查询, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li><li>eq_ref: 此类型通常出现在多表的查询(例如join), 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询条件通常是 =, 查询效率较高.</li><li>ref:  All rows with matching index values are read from this table for each combination of rows from the previous tables.<ul><li>1) 使用了非唯一或非主键索引, 可能匹配到多行(比较eq_ref)</li><li>2) 使用到了 最左前缀 规则的查询.</li><li>3) 以上两条对多表查询也适用</li></ul></li><li>index_merge: 表示出现了索引合并优化(包括交集，并集以及交集之间的并集)，但不包括跨表和全文索引。这个比较复杂，目前的理解是合并单表的范围索引扫描（如果成本估算比普通的range要更优的话</li><li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.</li><li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据. index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到(覆盖索引), 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.</li><li>all: 表示全表扫描, 这个类型的查询是性能最差的查询之一</li></ul><p>➤ 性能排序: <code>all &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p><p>➤ @ref:</p><ul><li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析 - 后台开发 - SegmentFault 思否</a></li><li><a href="https://mengkang.net/1124.html" target="_blank" rel="noopener">最官方的 mysql explain type 字段解读</a></li></ul><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><ul><li><p>优化select: 优化查询也即”如何高效使用索引”→ [[MySQL-03索引-高效使用索引]]</p></li><li><p>优化count: → [[../00.Course/course.MySQL实战45讲]] 14节</p><ul><li>count的实现: 统计非null行个数,</li><li>推荐使用<code>count(*)</code>, 最差的是<code>count(非索引列)</code></li></ul></li><li><p>优化limit: <code>limit 10000 20</code></p><ul><li>方法1: 记录上次id <code>select * from film where id &gt; LAST_CURSOR limit 10</code></li></ul></li><li><p>优化order by:  → [[../00.Course/course.MySQL实战45讲]] 第16节</p><ul><li><code>SELECT film_id,description FROM film ORDER BY title LIMIT 50,5</code></li><li>Mysql执行这段语句, 会把符合条件的列放入 order buffer, 排序后再 limit, 如果表数据很多排序会很耗时, 优化思路就是减少排序规模(延迟关联):</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT film.film_id,film.description</span><br><span class="line">FROM film INNER JOIN (</span><br><span class="line">SELECT film_id FROM film ORDER BY title LIMIT 50,5</span><br><span class="line">) AS tmp USING(film_id);</span><br></pre></td></tr></table></figure></li><li><p>优化join: 外层表减小数据规模, 内层表尽量走索引 @ref: [[MySQL-01-SQL语句-JOIN原理及优化]]</p></li><li><p>优化union:</p><ul><li>原理: 创建临时表, union左右语句符合条件的行, 逐行填充到临时表, 如果用的是<code>union</code>而不是<code>union all</code>, mysql还需要用distinct做唯一过滤</li><li>优化: 1 尽量使用<code>union all</code>, 如果一定需要去重, 建议在代码里做.  2 每个union子句里尽量用where/limit减小规模</li></ul></li><li><p>优化in:</p><ul><li>原理: in可以使用索引, 优化器是转化成了n*m种组合方式来进行查询，最终将返回值合并，有点类似union但是更高效</li><li>优化: @todo</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-00基础概念</title>
      <link href="/32.Database/MySQL-00%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/32.Database/MySQL-00%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/database/Database-MySQL-Title.png" alt=""></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>参考:《深入浅出MySQL》</p><h2 id="SCHEMA"><a href="#SCHEMA" class="headerlink" title="SCHEMA"></a>SCHEMA</h2><p><strong>schema</strong> 为数据库对象的集合， schema里面包含了各种对象如tables, views, sequences, 可以视作”数据库”, <code>show database</code>可以看到schema.<br>不同数据库产品的schema概念是不同的:</p><ul><li>MySQL: Schema 等同于 Datebase</li><li>SQL Server: schema中包含了数据库的表，字段，数据类型以及主键和外键的名称。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数字:<ul><li>整数:<ul><li>TINYINT 1, SMALLINT 2, INT 4, BIGINT 8</li></ul></li><li>小数:<ul><li>浮点数: float, double</li><li>定点数: decimal, 常用来表示高精度数据, 比如货币</li></ul></li></ul></li><li>字符串:<ul><li>CHAR 255, 定长</li><li>VARCHAR 65535, 变长</li><li>TEXT: 还分为TEXT(65535), MEDIUMTEXT, LONGTEXT</li><li>BOLB: 还分为BOLB(65535), MEDIUMBOLB, LONGBOLB, 与TEXT的区别是, BOLB可以存储二进制数据, 比如图片</li></ul></li><li>日期:<ul><li>DATE: 2017-07-25</li><li>DATETIME: 2017-07-25 21:57</li><li>TIMESTAMP: 字符串的”2017-07-25 21:57”</li></ul></li></ul><p>DATETIME 和 TIMESTAMP类型的区别:</p><ul><li>DATETIM 和 TIMESTAMP类型所占的存储空间不同，前者8个字节，后者4个字节，这样造成的后果是两者能表示的时间范围不同。</li><li>前者范围为 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59，后者范围为 1970-01-01 08:00:01到2038-01-19 11:14:07。所以可以看到TIMESTAMP支持的范围比DATATIME要小,容易出现超出的情况.</li><li>TIMESTAMP类型在默认情况下，insert、update 数据时，TIMESTAMP列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新。@ref: <a href="https://www.jianshu.com/p/cb1560135d50" target="_blank" rel="noopener">MySQL timestamp自动更新时间分享</a></li><li>TIMESTAMP比较受时区timezone的影响以及MYSQL版本和服务器的SQL MODE的影响</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">等于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">></td><td style="text-align:left">大于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">\&lt;</td><td style="text-align:left">小于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于</td><td style="text-align:left">不可比较NULL, 例 1 != NULL也返回NULL</td></tr><tr><td style="text-align:left">&lt;&gt;</td><td style="text-align:left">不等于</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left">&lt;=&gt;</td><td style="text-align:left">等于</td><td style="text-align:left">NULL-Safe的比较, NULL&lt;=&gt;NULL为1, 1&lt;=&gt;NULL为0</td></tr><tr><td style="text-align:left">IS NULL</td><td style="text-align:left">等于NULL</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IS NOT NULL</td><td style="text-align:left">不等于NULL</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">BETWEEN</td><td style="text-align:left">在两值之间</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IN</td><td style="text-align:left">在集合中</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">LIKE</td><td style="text-align:left">模糊匹配</td><td style="text-align:left"></td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>字符串拼接: CONCAT(s1, s2, …)</li><li>LOWER(s1), UPPER(s1)</li><li>FLOOR(a): 返回小于a的最大整数</li><li>MOD(a,b): 返回x/y的模</li></ul><h2 id="字符集-编码"><a href="#字符集-编码" class="headerlink" title="字符集(编码)"></a>字符集(编码)</h2><p>查看数据库使用的字符集:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方式1</span><br><span class="line">mysql&gt; status;</span><br><span class="line"></span><br><span class="line"># 方式2</span><br><span class="line">show variables like &apos;character%&apos;;</span><br></pre></td></tr></table></figure><p><code>GBK</code> vs <code>UTF-8</code></p><ul><li>GBK: 扩展了GB2312标准, 无论英文还是汉字都是2字节</li><li>UTF-8: 英文1字节, 汉字3字节, 同时也兼容ASCII码</li><li>如果数据库只需要支持一般中文，数据量很大，性能要求也很高，那就应该选择双字节定长编码的中文字符集，比如 <strong>GBK</strong>。 相对于UTF-8而言，GBK比较“小”，每个汉字只占2个字节，而 UTF-8汉字编码需要3个字节，这样可以减少磁盘I/O、数据库Cache以及网络传输的时间，从而提高性能。</li><li>如果应用主要处理英文字符，仅有少量汉字数据，那么选择 <strong>UTF-8</strong>更好，因为UTF-8的西文占1字节, 而GBK西文字符编码都是2个字节(汉字3字节)，会造成很多不必要的开销。</li></ul><p><code>utf8</code> vs <code>utf8mb4</code></p><ul><li>utf8 表示西文需2字节, 汉字需3字节, 如果在utf8编码上使用<code>vchar(100)</code>这种类型, Mysql会为该列保留 “一个utf8最大占用空间x100” 也即 300字节.</li><li>utf8 存在的问题: uft8最大能编码的Unicode范围是3字节, 对于超过3字节的无能为力(包括一些汉字, 以及emoji表情)</li><li>utf8mb4 (后缀mb4意思是”most bytes 4”), “4字节 UTF-8 Unicode 编码”, utf8mb4可以最多表示4字节Unicode编码, utf8是utf8mb4的一个子集, utf8mb4使用与utf8相同的编码值和长度, 此外utf8mb4还包括utf8没有的4字节编码, 因此从旧版本的MySQL UTF8 升级数据时 不用担心字符转换或丢失数据</li></ul><p>@ref <a href="https://my.oschina.net/xsh1208/blog/1052781" target="_blank" rel="noopener">全面了解mysql中utf8和utf8mb4的区别 - 谢思华blog - OSCHINA</a></p><h2 id="主键-amp-外键"><a href="#主键-amp-外键" class="headerlink" title="主键 &amp; 外键"></a>主键 &amp; 外键</h2><ul><li><p><strong>主键</strong>: 一个表只能有一个列作为主键, 主键的值不可重复, 不可为空(NULL)</p><ul><li>主键一定是唯一性索引，唯一性索引并不一定就是主键</li></ul></li><li><p><strong>外键</strong>: 一个表中的FOREIGN KEY 指向另一个表中的 PRIMARY KEY。</p><ul><li>FOREIGN KEY 约束用于预防破坏表之间连接的动作。</li><li>FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li></ul></li><li><strong>外键约束</strong>：<ul><li>(1)插入非空值时，如果主键值中没有这个值，则不能插入。</li><li>(2)更新时，不能改为主键表中没有的值。</li><li>(3)删除主键表记录时，可以在建外键时选定外键记录一起联删除还是拒绝删除。</li><li>(4)更新主键记录时，同样有级联更新和拒绝执行的选择。</li></ul></li></ul><p>@ref: <a href="https://www.zhihu.com/question/19600081" target="_blank" rel="noopener">大家设计数据库时使用外键吗？ - 知乎</a></p><blockquote><p>互联网行业应用不推荐使用外键： 用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展；若是把数据一致性的控制放到事务中，也即让应用服务器承担此部分的压力，而引用服务器一般都是可以做到轻松地水平的伸缩；<br>所以<code>Hibernate多对一（many-to-one）/一对多（one-to-many）关联</code>也就很少提及了。</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jparelated/" target="_blank" rel="noopener">Hibernate，JPA 对象关系映射之关联关系映射策略</a></p></blockquote></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>① 按照索引的物理存储来分:</p><ul><li><strong>聚集索引</strong> (clustered index)：聚集索引决定数据在磁盘上的物理排序，一个表只能有一个聚集索引，一般用primary key来约束。主键索引对应的B+树, 叶子节点是一行的完整数据</li><li><strong>非聚集索引</strong> (non-clustered index)：它并不决定数据在磁盘上的物理排序，其叶子节点的数据是主键的值。所以使用普通索引查询的时候，需要先找到对应的主键值，再回主键索引的B+树上找到行数据（回表）</li></ul><p>② 从逻辑角度, MySQL一共有五类索引:</p><ul><li>唯一索引(UNIQUE INDEX), 唯一索引是不允许其中任何两行具有相同索引值的索引。主键是一种唯一性索引，它必须指定为“PRIMARY KEY”</li><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值, 主键索引也是聚簇索引</li><li>普通索引：非主键索引, 最基本的索引类型，没有唯一性之类的限制。</li><li>联合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用联合索引时遵循最左前缀集合<br>注意：建了一个(a,b,c)的联合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，每多一个索引都会增加写操作的开销和磁盘空间的开销。</li><li>候选索引：与主索引一样要求字段值的唯一性，并决定了处理记录的顺序。在数据库和自由表中，可以为每个表建立多个候选索引。</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。</li></ul><p>MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</p><p>③ 从数据结构角度:</p><ol><li>BTREE索引: MyISAM和InnoDB存储引擎默认都是BTREE索引</li><li>HASH索引：<ul><li>仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询</li><li>其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引</li><li>只有Memory存储引擎显示支持hash索引</li></ul></li><li>FULLTEXT索引: 全文索引，在 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。FULLTEXT索引也是按照分词原理建立索引的。</li><li>RTree索引（空间索引）：空间索引是MyISAM的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li></ol><h2 id="MySQL引擎"><a href="#MySQL引擎" class="headerlink" title="MySQL引擎"></a>MySQL引擎</h2><ul><li><strong>InnoDB</strong><ul><li>支持事务</li><li>支持行级锁</li></ul></li><li><strong>MyISAM</strong><ul><li>不支持事务</li><li>支持表锁, 不支持行级锁 // 并发性能差</li><li>设计简单，某些场景下性能很好，例如获取整个表有多少条数据<code>count(*)</code>，性能很高。</li></ul></li><li><strong>Memory</strong><ul><li>不支持事务</li><li>支持哈希索引</li></ul></li></ul><h1 id="MySQL-Commands"><a href="#MySQL-Commands" class="headerlink" title="MySQL Commands"></a>MySQL Commands</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -u xxx -pXXX -P 3306</span><br><span class="line"></span><br><span class="line"># --auto-rehash 启用自动补全(但我试了没用)</span><br><span class="line">mysql -h主机地址 -P端口 -u用户名 -p密码 -D数据库名 --auto-rehash</span><br><span class="line">#　Mysql的`schemas`和`数据库名`是等同的</span><br><span class="line"></span><br><span class="line"># 连接成功后可以输入以下命令, 分号是必须的:</span><br><span class="line">show databases;</span><br><span class="line">use db_name;</span><br><span class="line">show tables;</span><br><span class="line">desc table_name; # 查看表结构</span><br><span class="line">use table_name;</span><br><span class="line"></span><br><span class="line"># 如果输入了一半sql命令想要放弃, 加上&apos;\c&apos;即可</span><br><span class="line">select * from table_name \c</span><br><span class="line"></span><br><span class="line"># 如果忘记了table在那个database 或schema, 表占用大小以及行数:</span><br><span class="line">select * from  information_schema.tables where table_name = &apos;xxx&apos;</span><br></pre></td></tr></table></figure><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><ul><li>导出数据库结构,不带数据: <code>mysqldump -h ip_addr -uxxx -pxxx -d DBName &gt; dump.sql</code></li><li>如果要一并导出数据, 去掉<code>-d</code>参数.</li><li>导出表, 不带数据: <code>mysqldump -h ip_addr -uxxx -pxxx -d DBName TableName &gt; dump.sql</code></li></ul><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><ul><li><code>mysql -u username -p -h localhost DATABASE-NAME &lt; data.sql</code></li></ul><h2 id="mycli"><a href="#mycli" class="headerlink" title="mycli"></a>mycli</h2><p>官网: <a href="https://www.mycli.net/" target="_blank" rel="noopener">https://www.mycli.net/</a></p><p>安装:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install mycli</span><br></pre></td></tr></table></figure><p>或:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew install mycli</span><br></pre></td></tr></table></figure><p>Usage:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取帮助</span><br><span class="line">mycli --help</span><br><span class="line"></span><br><span class="line"># 连接数据库</span><br><span class="line">mycli -h 主机地址 -p 端口 -u 用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/32.Database/MongoDB/"/>
      <url>/32.Database/MongoDB/</url>
      
        <content type="html"><![CDATA[<p><img src="https://webassets.mongodb.com/_com_assets/cms/MongoDB-Logo-5c3a7405a85675366beb3a5ec4c032348c390b3f142f5e6dddf1d78e2df5cb5c.png" alt="MongoDB"></p><p>MongoDB是高性能(得益于内存缓存)、无模式的文档型数据库，支持二级索引，类json格式存储(bson)，非常适合文档化格式的存储及查询。适合用来存放评论等半结构化数据;<br>MongoDB的官方定位是通用数据库，与MySQ类似，但跟传统关系型数据库比较，Mongo在事务、join、复杂查询应用下仍旧无法取代关系型数据库。</p><h1 id="mongo-shell"><a href="#mongo-shell" class="headerlink" title="mongo shell"></a>mongo shell</h1><h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><ul><li>ObjectId: <code>db.getCollection(&#39;activities&#39;).find(ObjectId(&#39;5a9f5e7137c65800015df8d0&#39;))</code></li><li>AND: <code>db.collection.find({ &quot;key&quot; : &quot;value&quot;, &quot;key1&quot; : &quot;value1&quot;})</code> </li><li>OR: </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;    </span><br><span class="line">    $or : [</span><br><span class="line">        &#123;k1:v1&#125;,</span><br><span class="line">        &#123;k2:v2&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>lt, lte, gt, gte: </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.find(&#123;</span><br><span class="line">    &quot;key&quot; : &#123; $gte : 59&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>not null : <code>db.collection.find({&quot;key&quot;: {$exists:true}})</code></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>升序: <code>db.collection.find({}).sort({&quot;key&quot;: 1})</code></li><li>降序: <code>db.collection.find({}).sort({&quot;key&quot;: -1})</code></li></ul><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>格式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &#123;query&#125;,</span><br><span class="line">   &#123;update&#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&apos;activities&apos;).update(</span><br><span class="line">    &#123;&quot;dateStart&quot; : &#123;$gte:1514736000000&#125;&#125;, </span><br><span class="line">    &#123;$set : &#123;&apos;name&apos; : &apos;xxxx&apos;&#125;&#125;,</span><br><span class="line">    &#123;multi : true&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>inc自增:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&apos;activities&apos;).update(</span><br><span class="line">    &#123; &quot;_id&quot; : ObjectId(&quot;5aa86f063dd35a000113401f&quot;) &#125;,</span><br><span class="line">    &#123; $inc : &#123; &quot;score&quot; : 10 &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><ul><li>$push:向文档数组中添加元素，如果没有该数组，则自动添加数组</li><li>$addToSet:功能与$push相同，区别在于，$addToSet把数组看作成一个Set,如果数组中存在相同的元素，不会插入。<code>$addToSet : {&#39;displayAttributes&#39; : &#39;totalPvShow&#39;}</code></li></ul><p>数组操作:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&apos;activities&apos;).update(</span><br><span class="line">    &#123;&quot;dateStart&quot; : &#123;$gte:1514736000000&#125;&#125;, </span><br><span class="line">    &#123;$addToSet : &#123;&apos;displayAttributes&apos; : &apos;totalPvShow&apos;&#125;&#125;,</span><br><span class="line">    &#123;multi : true&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h2><p>设每个数据包括 <code>{ &quot;icq&quot;: &quot;xxx&quot;, &quot;score1&quot; : 1, &quot;score2&quot; : 2 }</code>, 按<code>icq</code>聚合, 求<code>score1</code>和<code>score2</code>的和</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&apos;item&apos;).aggregate([</span><br><span class="line">&#123;$match : &#123; &quot;icq&quot; : &quot;xxxx&quot;&#125; &#125;,  # 匹配条件</span><br><span class="line">&#123;$group : &#123; </span><br><span class="line">        _id : &quot;$icq&quot; ,  # `_id`是固定的语法, 按哪一属性聚合</span><br><span class="line">        score1_sum : &#123; $sum : &quot;$score1&quot; &#125;,  # 自定义结果名: &#123;$操作 : &quot;$属性名&quot;&#125;</span><br><span class="line">        score2_sum : &#123; $sum : &quot;$channel&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h1 id="mongo命令"><a href="#mongo命令" class="headerlink" title="mongo命令"></a>mongo命令</h1><p>启动数据库并开启权限: <code>/opt/apps/mongodb/bin/mongod --config /opt/conf/mongo/mongo.conf --auth</code></p><p>连接mongo并查询</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo 127.0.0.1 -u username -p pwd --port 28015 # 连接数据库</span><br><span class="line">mongo 127.0.0.1 -u username -p pwd --port 28015 --authenticationDatabase "admin" # 指定验证的db</span><br><span class="line">mongo 127.0.0.1:27017/admin -u mongouser -p pwd # 另一种登录格式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show dbs <span class="comment"># 列出所有数据库</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> use db_name</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show collections <span class="comment"># collection类似表</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.collection_name.find() <span class="comment"># 在xxx这个collection里查找</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.collection_name.find(&#123;appid: <span class="string">"total"</span>, time: <span class="string">"20170324"</span>&#125;) <span class="comment"># 在xxx里查找appid=total的项</span></span></span><br></pre></td></tr></table></figure><p>关闭mongo服务:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.shutdownServer();</span><br></pre></td></tr></table></figure><h2 id="mongoexport"><a href="#mongoexport" class="headerlink" title="mongoexport"></a>mongoexport</h2><ul><li><p>mongoexport参数说明:</p><ul><li>-d: database</li><li>/c: collection</li><li>/q: query filter, as a JSON string, e.g., ‘{x:{$gt:1}}’</li><li>/sort: sort order, as a JSON string, e.g. ‘{x:1}’</li><li>—-authenticationDatabase “admin” : 指定验证db</li></ul></li><li><p>将info库中student的id,name信息以json格式导出到student_json.dat数据文件中，并且限定“行数”是1</p><ul><li><code>mongoexport -h 127.0.0.1 -u root -p 12345 -d info -c student --type=json -f id,name --limit=1 -o E:\data\student_json.dat</code></li></ul></li><li>将info库student collections的name=a的信息以cvs格式导出到student_cvs.dat数据文件中<ul><li><code>mongoexport -h 127.0.0.1 -u root -p 12345 -d info -c student --type=cvs -q{&quot;name&quot;:&quot;a&quot;} -o E:\data\student_cvs.dat</code></li></ul></li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul><li>在admin数据库里addUser创建的是管理员用户, 可以访问任何数据库 <code>db.addUser(&quot;admin&quot;,&quot;admin&quot;);</code></li><li><code>use DATABASE_NAME</code> : 如果数据库不存在，则创建数据库，否则切换到指定数据库。</li><li>在某个数据库里addUser创建的用户, 只有对这个数据库的权限 </li><li>创建用户: db.addUser(“user”,”pwd”);</li><li>删除用户: db.removeUser(“xxx”);</li><li>查找用户: db.system.users.find()</li></ul><p>创建具有admin权限的用户:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.addUser(&quot;admin&quot;,&quot;password&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot; : &quot;admin&quot;,</span><br><span class="line">    &quot;readOnly&quot; : false,</span><br><span class="line">    &quot;pwd&quot; : &quot;a254f094f02d3c96f4748175cb4b9403&quot;,</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;595afee766c59f7c02021c99&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用创建的用户登录:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin # 授权admin必须切换到admin库</span><br><span class="line">db.auth(&quot;admin&quot;,&quot;password&quot;)</span><br><span class="line">use db_name  # 切换到要查询的库</span><br><span class="line">show collections</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LevelDB 实现 LSM-Tree</title>
      <link href="/32.Database/LevelDB-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LSM-Tree/"/>
      <url>/32.Database/LevelDB-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LSM-Tree/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/database/LevelDB-LSM-Tree.png" alt="LevelDB实现的LSM-Tree模型"></p><p>有关LSM-Tree基本概念, 参考: <a href="/32.Database/LSM-Tree理论基础/" title="LSM-Tree理论基础">LSM-Tree理论基础</a></p><p>LevelDB 是如何实现 LSM-Tree的:</p><ul><li>LevelDB的 WAL: @todo</li><li>C0层由两部分组成, memtable 和 immutable memtable;</li><li>C1..Ck层 被实现为 上图的 L0..L6, 每层都由数个 SStable （Sorted String Table）组成, 每层的总大小是上一层的10倍;</li><li>WAL的数据首先被写入 memtable, 当 memtable 的数据超过阈值, memtable变为 immutable memtable(不可写入的), 新创建一个memtable用于写入新数据, immutable memtable中的数据写入磁盘的L0层;</li><li>L0..L6层的数据没有使用B+树, 而是使用了SSTable(Sorted String Table), 按Key顺序存储的键值对集合, 当SSTable比较大的时候还可以创建索引来加速查询</li><li>L0层的 SSTable是 memtable 直接刷写进磁盘的文件, L0层允许出现不同 SSTable之间有Key交集的情况, 但L1..L6层不允许SSTable出现Key交集</li><li>SSTable的概念来自 google 《BigTable》的论文,  @todo</li></ul><p><img src="/images/database/LevelDB-SStable-Index.png" alt="SSTable存储结构"></p>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LSM Tree</title>
      <link href="/32.Database/LSM-Tree%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/32.Database/LSM-Tree%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>➤ TOC:</p><ul><li>从 LSM-Tree到 BigTable</li><li>LSM-Tree vs B+Tree;</li><li>LSM-Tree原理;</li></ul><p>➤ Google BigTable → LSM-Tree</p><blockquote><p>作为 Google 的大数据三架马车之一，Bigtable 依托于 Google 的 GFS、Chubby 及 SSTable 而诞生，用于解决 Google 内部不同产品在对数据存储的容量和响应时延需求的差异化，力求在确保能够容纳大量数据的同时减少数据的查询耗时。<br>论文中很多很酷的方面之一就是它所使用的文件组织方式，这个方法更一般的名字叫 Log Structured-Merge Tree。<br>@ref: <a href="https://static.usenix.org/events/osdi06/tech/chang/chang_html/?em_x=22" target="_blank" rel="noopener">Bigtable: A Distributed Storage System for Structured Data - OSDI ‘06 Paper</a></p></blockquote><blockquote><p>在BigTable里， SSTable(Sorted Strings Table)是一个基本的单元。每个Tablet有若干个SSTable。论文里面并没有提到SSTable是怎么样实现的。但是根据对开源的LevelDB的代码，可以看出SSTable是LSM-Tree的一种实现。<br>论文→ [Patrick O’Neil, Edward Cheng, Dieter Gawlick, and Elizabeth (Betty) O’Neil, “The Log-Structured Merge-Tree,” patent granted to Digital Equipment Corporation, December 1993; appeared in ActaInformatica 33, pp. 351-385, June 1996].</p></blockquote><p>➤ LSM-Tree vs B+Tree</p><ul><li>传统数据库使用B-Tree或B+Tree等多叉树实现, 具有较好的随机读, 但是随机写性能比较差(数据在逻辑上相离很近但物理却可能相隔很远), 写耗时远大于读耗时;</li><li>优化写耗时, 一般使用基于日志的顺序存储, 但是这种结构的随机读性能太差, 只适用于WAL, 或者通过offset顺序读(类似kafka)</li></ul><blockquote><p>@ref <a href="https://www.zhihu.com/question/19887265/answer/78839142" target="_blank" rel="noopener">https://www.zhihu.com/question/19887265/answer/78839142</a></p></blockquote><p>➤ LSM（The Log-Structured Merge-Tree） 即 <strong>日志结构合并树</strong>, 有两个特性: 日志结构 + 合并树.  <a href="https://static.usenix.org/events/osdi06/tech/chang/chang_html/" target="_blank" rel="noopener">OSDI ‘06 Paper</a></p><ul><li>日志:<ul><li>数据被插入时, 首先写WAL(Write Ahead Log), WAL是磁盘顺序写, 写入速度很快</li></ul></li><li>合并树:<ul><li>LSM-Tree的树结构分两部分, 存储于内存中的C0层, 以及存储于磁盘的C1..Ck层;</li><li>C0层一般使用 RB-Tree 或 SkipList实现, WAL里的数据首先被写入C0树, C0树按照Key有序存储;</li><li>当C0层的大小超过阈值, 会与下一层的C1层进行合并(Compaction), 成为新的C1层, 同时清空C0层, 合并过程类似归并排序中的”归并”;</li><li>同样C1层超过大小阈值也会与C2树进行合并… 从C0-Ck每层树结构容量逐层增大;</li><li>C1..Ck层可能使用B+Tree实现, 或SortedFile;</li></ul></li><li>写入过程: C0层总是最新写入的数据, Ck层则包含最旧的数据, 当上下两层合并时, 上层的新数据会覆盖掉下次的旧数据, C0…Ck层的数据可能存在重复;</li><li>查询过程: 从C0层开始查询, 如果找不到就在下一层查找, 所以相比较B+Tree, LSM-Tree的读性能会差一些;</li><li>删除过程: 在C0层插入一个带有删除标记的Entry …</li><li>Scan过程: @todo</li></ul><p><img src="/images/database/LSM-Tree-Model.png" alt=""></p><blockquote><p>@ref: <a href="http://www.cse.cuhk.edu.hk/~mcyang/csci5550/2020S/Lec09%20Persistent%20Key-Value%20Stores.pdf" target="_blank" rel="noopener">http://www.cse.cuhk.edu.hk/~mcyang/csci5550/2020S/Lec09%20Persistent%20Key-Value%20Stores.pdf</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase-vs-ES</title>
      <link href="/32.Database/HBase-vs-ES/"/>
      <url>/32.Database/HBase-vs-ES/</url>
      
        <content type="html"><![CDATA[<h2 id="比较elasticsearch-和-hbase"><a href="#比较elasticsearch-和-hbase" class="headerlink" title="比较elasticsearch 和 hbase"></a>比较elasticsearch 和 hbase</h2><p><a href="https://www.zhihu.com/question/41109030" target="_blank" rel="noopener">海量日志数据存储用 elasticsearch 和 hbase 哪个好？ - 知乎</a></p><ul><li>1）两者都可以通过扩展集群来加大可存储的数据量。随着数据量的增加，es的读写性能会有所下降</li><li>2）数据更新es数据更新是对文档进行更新，需要先将es中的数据取出，设置更新字段后再写入es。hbase是列存储的，可以方便地更新任意字段的值。</li><li>3）查询复杂度hbase支持简单的行、列或范围查询，若没有对查询字段做二级索引的话会引发扫全表操作，性能较差。而ES提供了丰富的查询语法，支持对多种类型的精确匹配、模糊匹配、范围查询、聚合等操作，ES对字段做了反向索引，支持全文检索, 即使在亿级数据量下还可以达到秒级的查询响应速度。</li><li>4）字段扩展性hbase和es都对非结构化数据存储提供了良好的支持。es可以通过动态字段方便地对字段进行扩展，而hbase本身就是基于列存储的，可以很方便地添加qualifier来实现字段的扩展</li></ul>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase-05源码</title>
      <link href="/32.Database/HBase-05%E6%BA%90%E7%A0%81/"/>
      <url>/32.Database/HBase-05%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="客户端API源码"><a href="#客户端API源码" class="headerlink" title="客户端API源码"></a>客户端API源码</h2><p>施工中</p><h3 id="createConnection"><a href="#createConnection" class="headerlink" title="createConnection()"></a>createConnection()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">Connection connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">connection.getTable(TableName.valueOf(<span class="string">"tbl_xxx"</span>));</span><br></pre></td></tr></table></figure><p>创建connection过程如下:<br><code>ConnectionFactory.createConnection(Configuration conf)</code>, 返回的是一个HConnectionImplementation的对象, 调用了HConnectionImplementation的构造函数:<br><code>HConnectionImplementation(Configuration conf, boolean managed, ExecutorService pool, User user)</code></p><p>看一下HConnectionImplementation构造都做了哪些初始化:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    this.asyncProcess = this.createAsyncProcess(this.conf);</span><br><span class="line">    this.rpcClient = RpcClientFactory.createClient(this.conf, this.clusterId, this.metrics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getTable"><a href="#getTable" class="headerlink" title="getTable()"></a>getTable()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">connection.getTable(TableName.valueOf(<span class="string">"tbl_xxx"</span>));</span><br></pre></td></tr></table></figure><p><code>Connection.getTable()</code>实际调用到了<code>HConnectionImplementation.getTable()</code><br>返回了一个新对象: <code>new HTable(tableName, this, this.connectionConfig, this.rpcCallerFactory, this.rpcControllerFactory, pool)</code></p><p>HTable有几个重要成员:<br>    connection,<br>    multiAp,<br>    locator</p><p>在HTable初始化时, 上面几个成员按如下顺序初始化:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.multiAp = <span class="keyword">this</span>.connection.getAsyncProcess();</span><br><span class="line"><span class="keyword">this</span>.locator = <span class="keyword">new</span> HRegionLocator(<span class="keyword">this</span>.tableName, <span class="keyword">this</span>.connection);</span><br></pre></td></tr></table></figure></p><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Put put = <span class="keyword">new</span> Put(rowKey.getBytes());</span><br><span class="line">put.addColumn(family.getBytes(), qualifier.getBytes(), val.getBytes());</span><br><span class="line">table.put(put);</span><br></pre></td></tr></table></figure><p><code>HTable.put(Put)</code> 并不会立刻发送RPC请求, 而是等多次请求后再一次backgroundFlushCommits,<br><code>submit(tableName, buffer, true, null, false);</code></p>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase-04应用</title>
      <link href="/32.Database/HBase-04%E5%BA%94%E7%94%A8/"/>
      <url>/32.Database/HBase-04%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="表的设计"><a href="#表的设计" class="headerlink" title="表的设计"></a>表的设计</h2><p>在HBase中表的概念并不是那么重要, 数据的物理存储是基于列族的.</p><h2 id="Row-Key设计"><a href="#Row-Key设计" class="headerlink" title="Row Key设计"></a>Row Key设计</h2><p>设计合理的 Row Key设计可以加速scan操作, 还可以在大量写入数据时让多个RegionServer分担负载.</p><blockquote><p>Region是 HBase中扩展和负载均衡的基本单元, Region本质上是以 Row Key的字典顺序连续存储的, 这种设计优化了 scan的操作，<br>一个 Table最初只有一个 Region, 当一个 Region过大时, 系统会在中间键(middle key)将这个 Region拆分成两个大致相等的子 Region。<br>Row Key设计不好就会造成读写热点问题，造成大量客户端直接访问集群某一个或者极少数的节点，造成节点性能下降或者Region不可用</p></blockquote><p><strong>几种Row key设计方案:</strong></p><ul><li>key长度不宜过长, 否则占用过多存储空间;</li><li>如果有大量的对时间范围的scan查询, 时间戳适合放在 Row key后面, 还有一种常用的设计方式是用<code>Long.MAX - Timestamp</code>, 这样<code>scan()</code>可以先取到时间戳最新的行;</li><li>避免Row key前缀是递增序列 (比如 时间戳 or 递增的user_id) 这样会导致某个Region成为读写热点, 有如下几种解决方案<ul><li>如果 uid这种递增id做 Row key前缀(前几位几乎相同), 可以把uid的字符倒序排列;</li><li>对做 Row key前缀的属性进行哈希, 这种做法可以完全解决 Region读写热点问题, 所有的数据都是均匀写在每个 Region上, 但是 scan几乎不可能;</li><li>哈希和预分区结合使用, 预分区一开始就预建好了 N个region,这些 region都维护着自已的”start-end keys”， 可以使用<code>hash mod N</code>计算出应该属于哪个 region;  但是scan会带来一些额外的操作, 一般用多线程scan每个分区然后汇总结果;</li></ul></li></ul><blockquote><p>对于”哈希+预分区结合使用”的方案, 在上传时，客户端需要跟N个 regionServer保持连接，<br>在查询时，无论是连续区域查询，还是单条查询，都需要访问N个逻辑分区，这意味着与N个 regionServer都要建立连接。<br>当集群规模较大（即N较大）时，连接开销是巨大的。因此，这种方案只适用于小规模集群（N小于20）。<br>在小集群情况下，直接让客户端遍历所有分区时，如果采取多线程查询，启动线程数为k（k小于等于N），不同线程的查询负载会落到不同 regionServer上。<br>也就是说，原本一个regionserver执行一次操作就能完成的查询，采取方案后每个regionserver都要执行一次操作才能完成。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase-03架构和原理</title>
      <link href="/32.Database/HBase-03%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>/32.Database/HBase-03%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h2><p><img src="/images/hbase/hbase_arch.png" alt=""></p><p>HBase包含3个重要组件：Zookeeper、HMaster和 HRegionServer。</p><ul><li>（1）Zookeeper： 为整个 HBase集群提供协助服务，包括：<ul><li>a. 存放整个 HBase集群的元数据以及集群的状态信息。</li><li>b. 实现 HMaster主从节点的 failover。</li></ul></li></ul><blockquote><p>ZooKeeper为 HBase集群提供协调服务，它管理着 HMaster和 HRegionServer的状态(available/alive等)，并且会在它们宕机时通知给 HMaster，从而 HMaster可以实现 HMaster之间的 failover，或对宕机的 HRegionServer中的 HRegion集合的修复(将它们分配给其他的 HRegionServer)。</p></blockquote><ul><li><p>（2）HMaster： 主要用于监控和操作集群中的所有 HRegionServer。HMaster没有单点问题，HBase中可以启动多个HMaster，通过 Zookeeper的 MasterElection机制保证总有一个Master在运行，HMaster 主要负责 Table和 Region的管理工作：</p><ul><li>a. 管理用户对表的增删改查操作</li><li>b. 管理 HRegionServer的负载均衡，调整Region分布</li><li>c. Region Split后，负责新 Region的分布</li><li>d. 在 HRegionServer停机后，负责失效 HRegionServer上Region迁移</li></ul></li><li><p>（3）HRegion Server： HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写数据。</p><ul><li>a. 存放和管理本地 HRegion。</li><li>b. 读写HDFS，管理Table中的数据。</li><li>c. Client直接通过 HRegionServer读写数据（从HMaster中获取元数据，找到RowKey所在的 HRegion/HRegionServer后）。</li></ul></li></ul><h2 id="HMaster"><a href="#HMaster" class="headerlink" title="HMaster"></a>HMaster</h2><p>@todo</p><h2 id="HRegion-Server"><a href="#HRegion-Server" class="headerlink" title="HRegion Server"></a>HRegion Server</h2><p>RegionServer:<br><img src="/images/hbase/HBase-RS-Storage-Machinery.png" alt=""></p><p>➤ 从架构看 HRegion Server:</p><ul><li>一个RS包括: <code>1 * BlockCache</code> + <code>1 * HLog</code> + <code>n * HRegion</code></li><li>BlockCache: Region Server的读缓存。保存使用最频繁的数据，使用 <strong>LRU</strong> 算法换出不需要的数据;</li><li>HLog: WAL(Write-Ahead-Log), 为数据提供 Crash-Safe, 以及读一致性及undo/redo 回滚等数据恢复操作;</li><li>HRegion: 子表, 每个子表都关联一个<code>[StartKey, EndKey]</code>的存储区间, 每个 HRegion Server管理多个”子表”;</li><li>HStore: 每个 Region包括多个 HStore, 每个 HStore由 <code>1 * MemStore</code> + <code>n * StoreFile</code>组成(LSM-Tree的C0..Ck层)<ul><li>MemStore: LSM-Tree的 C0层, 存储于内存的有序K-V结构, 使用<code>ConcurrentSkipList</code>实现, 当 MemStore（默认 64MB）写满之后，会开始 flush 到磁盘上的 StoreFile</li><li>StoreFile: LSM-Tree的Ck层, StoreFile是对 HFile做了一层简单封装</li></ul></li></ul><blockquote><p>LSM-Tree:</p><ul><li>每个 RegionServer都有一个 HLog (WAL)</li><li>每个 Region都有1个 MemStore (C0层) 和 N个 StoreFile (C1..Ck层)</li><li>MemStore: 跳表实现, MemStore的数据超过阈值(默认64MB)后会刷写到磁盘, 生成 StoreFile</li></ul></blockquote><p>有关LSM-Tree, 参考: <a href="/32.Database/LSM-Tree理论基础/" title="LSM-Tree理论基础">LSM-Tree理论基础</a></p><p>➤ 从逻辑存储看 HRegion Server:</p><ul><li>HBase表的逻辑存储: Table, Family, Qualifier</li><li>每个 HRegion存储一张 Table的 某个Key区间 // 问题, 一个RS下所有 HRegion的区间是连续的一个段?</li><li>每个 HStore存储一个 Family(列族)的 某个Key区间</li></ul><h3 id="Region-Server-高可用"><a href="#Region-Server-高可用" class="headerlink" title="Region Server 高可用"></a>Region Server 高可用</h3><p>TODO: 一个HBase集群有多个 RS, 每个RS负责一部分 Key, 当一个 RS宕机 …</p><ul><li>HDFS的大文件被分为多个Block, 每个Block都存在在3台不同机器上, 实现3副本;</li><li>HBase写数据的 WAL机制: 先写 HLog, 再写缓存, 缓存满了一起落盘, HLog可以作为宕机后的恢复依据;</li><li>每个 RegionServer 会周期性给zk发送心跳信息, 当RS断开连接, 超过一定时间(zk的 sessionTimeout), zk认为这台RS宕机, 并将消息通知给 Master,</li><li>Master将这台 RegionServer 上所有的 Region 转移到其他 RS上. 再将 HLog 日志分发给其他RS进行回放. // RS已经宕机, master如何从 RS上获取 Log ?</li></ul><blockquote><p>@ref <a href="https://zhuanlan.zhihu.com/p/28475168" target="_blank" rel="noopener">HBase–RegionServer宕机恢复原理 - 知乎</a></p></blockquote><h2 id="MemStore"><a href="#MemStore" class="headerlink" title="MemStore"></a>MemStore</h2><p>@ref: <a href="http://hbasefly.com/2019/10/18/hbase-memstore-evolution/" target="_blank" rel="noopener">HBase内存管理之MemStore进化论 – 有态度的HBase/Spark/BigData</a></p><p><img src="/images/hbase/hbase-memstore-skiplist-chunck.png" alt="hbase_memstore_skiplist_chunck"></p><h2 id="StoreFile-HFile"><a href="#StoreFile-HFile" class="headerlink" title="StoreFile(HFile)"></a>StoreFile(HFile)</h2><p><img src="/images/hbase/hbase_hfile.png" alt="HFile结构-图1"></p><p>HFile 的文件长度是变长的，仅 FILE INFO/Trailer 部分是定长，Trailer 中有指针指向其他数据块的起始点。而 Index 数据块则记录了每个 Data 块和 Meta 块的起始点。Data 块和 Meta 块都是可有可无的，但对于大多数 HFile，都有 Data 块。</p><p><img src="/images/hbase/hbase_hfile_tree.png" alt="HFile结构-图2"></p><p>图2 的说明: HFile分为trailer，索引块，数据块，bloom过滤器。</p><ul><li>Data Block主要存储用户的key-value数据 // 1个Data Block默认为64kb</li><li>Index Block: 存储了每一个Data Block的索引信息{Offset，Size，FirstKey}, 如上图,Index Block 是三层索引</li><li>Trailer主要记录 Data Index的索引信息{Data Index Offset, Data Block Count}</li><li>Bloom filter主要用来快速定位Key是否在HFile。// Bloom Block 的数据是在启动的时候就已经加载到内存里，除了 Block Cache 和 MemStore 以外，这个也对 HBase 随机读性能的优化起着至关重要的作用。生成 HFile 的时候，会将 key 经过三次 hash 最终落到 Bloom Block 位数组的某三位上，并将其由0更改成1，以此标记该 key 的确存在这个 HFile 文件之中，查询的时候不需要将文件打开并检索，避免了一次 I/O 操作。然而随着 HFile 的膨胀，Bloom Block会越来越大。</li><li>不同管理粒度的”块”: ext3文件系统的 block size=4K, HDFS文件系统的 blockSize=64MB</li><li>参考BigTable的SSTable和Hadoop的TFile实现 @todo</li></ul><h3 id="HFile-的-Data-Index"><a href="#HFile-的-Data-Index" class="headerlink" title="HFile 的 Data Index"></a>HFile 的 Data Index</h3><p><img src="/images/hbase/hbase-hfile-data-index.png" alt="hbase_hfile_data_index"></p><p>图中上面三层为索引层，在数据量不大的时候只有最上面一层，数据量大了之后开始分裂为多层，最多三层，如图所示。最下面一层为数据层，存储用户的实际 keyvalue数据。这个索引树结构类似于 InnoSQL的聚集索引，只是 HBase并没有辅助索引的概念。</p><p>图中红线表示一次查询的索引过程（HBase中相关类为 HFileBlockIndex和 HFileReaderV2），基本流程可以表示为：</p><ol><li>用户输入rowkey为fb，在root index block中通过二分查找定位到fb在’a’和’m’之间，因此需要访问索引’a’指向的中间节点。因为root index block常驻内存，所以这个过程很快。</li><li>将索引’a’指向的中间节点索引块加载到内存，然后通过二分查找定位到fb在index ‘d’和’h’之间，接下来访问索引’d’指向的叶子节点。</li><li>同理，将索引’d’指向的中间节点索引块加载到内存，一样通过二分查找定位找到fb在index ‘f’和’g’之间，最后需要访问索引’f’指向的数据块节点。</li><li>将索引’f’指向的数据块加载到内存，通过遍历的方式找到对应的keyvalue。</li></ol><p>上述流程中因为 <strong>中间节点</strong>、 <strong>叶子节点</strong> 和 <strong>数据块</strong> 都需要加载到内存，所以io次数正常为3次。但是实际上HBase为block提供了缓存机制，可以将频繁使用的block缓存在内存中，可以进一步加快实际读取过程。所以，在HBase中，通常一次随机读请求最多会产生3次io，如果数据量小（只有一层索引），数据已经缓存到了内存，就不会产生io。</p><h2 id="ROOT-amp-META表"><a href="#ROOT-amp-META表" class="headerlink" title="ROOT &amp; META表"></a>ROOT &amp; META表</h2><p>早期的设计（0.96.0）之前是被称之为三层查询架构: <code>ROOT</code>  -&gt; <code>META</code>  -&gt; Region.</p><p><code>-ROOT-</code>和<code>.META.</code>是两个特殊的表。其中<code>.META.</code> 表记录 Region 分区信息，同时，<code>.META.</code> 也可以有多个 Region 分区，同时<code>-ROOT-</code>表又记录<code>.META.</code> 表的 Region 信息，但<code>-ROOT-</code>只有一个 Region，而<code>-ROOT-</code>表的位置由 Hbase 的集群管控框架，即 Zookeeper 记录。</p><ul><li>-ROOT-：记录.META.表的Region信息。</li><li>.META.：记录用户表的Region信息。</li></ul><p>从0.96版本以后，三层架构被改为二层架构，<code>-ROOT-</code>表被去掉了。直接把<code>.META.</code>表所在的RegionServer信息存储到了 zk中的 /hbase/meta-region-server。再后来引入了namespace，<code>.META.</code>表这样别扭的名字被修改成了<code>hbase:meta</code>。</p><h2 id="META表的缓存设计"><a href="#META表的缓存设计" class="headerlink" title="META表的缓存设计"></a>META表的缓存设计</h2><p>@ref: <a href="https://zhuanlan.zhihu.com/p/92103602" target="_blank" rel="noopener">HBase源码：Region的定位与优化 - 知乎</a></p><p>Meta缓存的数据结构设计的很巧妙，首先采用了copy on write的思想，自定义了一个CopyOnWriteArrayMap。copy on write即可以支持并发读，当写的时候采用拷贝引用的方式快速变更。HBase自定义了一个数组Map，其中数组结构第一层为表，数组部分的查询采用二分查找；第二层是startkey；当有RegionLocation信息需要更新时，采用System.arraycopy实现快速拷贝更新。</p><p>图: 通过table和rowkey快速定位到对应的Region(复杂度是多少?):<br><img src="/images/hbase/hbase-memstore-cache.png" alt="hbase_memstore_cache"></p><h2 id="Minor-amp-Major-Compact"><a href="#Minor-amp-Major-Compact" class="headerlink" title="Minor &amp; Major Compact"></a>Minor &amp; Major Compact</h2><p>当一个Store中的StoreFile达到一定的阈值后，就会进行一次合并(major compact)，将对同一个key的修改合并到一起，形成一个大的StoreFile，当StoreFile的大小达到一定阈值后，又会对 StoreFile进行分割(split)，等分为两个StoreFile。</p><p>其中，minor compaction是自动将相关的小文件做一些适当的紧凑，但不彻底；<br>而major compaction则是放在午夜跑的定时任务，将文件做最大化的紧凑。这时候LSM树的磁盘树数量很少, 被并入一个大的树</p><p><img src="/images/hbase/hbase-compaction.png" alt="hbase_compaction"></p><h2 id="Region拆分策略"><a href="#Region拆分策略" class="headerlink" title="Region拆分策略"></a>Region拆分策略</h2><p>HBase的表由多个子表(Regions)组成，这些 Regions分布在多个 Region Server上面。<br>Region的拆分逻辑是通过CompactSplitThread线程的requestSplit方法来触发的，每当执行MemstoreFlush操作时都会调用该方法进行判断，看是否有必要对目标Region进行拆分。Region的拆分有三种策略：</p><ol><li>ConstantSizeRegionSplitPolicy：在0.94之前只有这个策略。当region中的一个store（对应一个columnfamily的一个storefile）超过了配置参数hbase.hregion.max.filesize时拆分成两个，该配置参数默认为10GB。region拆分线是最大storefile的中间rowkey。</li><li>IncreasingToUpperBoundRegionSplitPolicy：0.94默认策略。拆分阈值是<code>Min (R^2 * “hbase.hregion.memstore.flush.size”, “hbase.hregion.max.filesize”)</code>，其中R是一张表中位于同一个regionserver的region的数目。<code>hbase.hregion.memstore.flush.size</code>默认是128MB，后一个参数默认是10GB。因此，如果region没有预拆分，默认的行为是，表的第一个region会位于一个regionserver上，然后当达到<code>1^2*128MB=128MB</code>，region被拆分成2个，它们仍然位于同一个regionserver上，因此，随着region的增加，拆分阈值也增加：128MB、512MB、1152MB、2GB、3.2GB、4.6GB、6.2GB，依次类推，直至达到9个region之后，拆分阈值就恒定为10GB。这可以控制一个regionserver拥有的region个数在小数据量的时候不会太少，在大的数据量时候不会太多。region拆分线是最大storefile的中间rowkey。</li><li>KeyPrefixRegionSplitPolicy：你可以配置用来对你的rowkey进行分组所依赖的前缀长度，然后该策略保证region的拆分线不会在一组拥有相同前缀的rowkey的中间，也就是说，拆分后的region中，相同前缀的rowkey会一直位于同一个region上。其他的拆分策略与IncreasingToUpperBoundRegionSplitPolicy是一样的。</li></ol><p><strong>如何配置策略？</strong><br>通过配置参数<code>hbase.regionserver.region.split.policy</code>来配置，这是全局的。可以针对单独的表进行配置，用表的API<code>HTableDescriptor.setValue()</code>可以配置。另外，后一种配置还可以使用自定义的拆分策略类。</p><h2 id="HBase读取流程解析"><a href="#HBase读取流程解析" class="headerlink" title="HBase读取流程解析"></a>HBase读取流程解析</h2><ul><li>Client 发送请求给Zk, 获取 hbase:meta表在哪个 RegionServer;</li><li>hbase:meta存储了 每个表在每个 Region 上的 start/end Key</li><li>Client 向该 RegionServer发送请求, 查询 meta 表, 获取Key在哪个 Region上, 同时也确定了 RegionServer;</li><li>Client 可以缓存 meta表, 每次不必去查 Zk</li></ul><blockquote><p>@ref <a href="https://zhuanlan.zhihu.com/p/92103602" target="_blank" rel="noopener">HBase源码：Region的定位与优化 - 知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase-02运维和部署</title>
      <link href="/32.Database/HBase-02%E8%BF%90%E7%BB%B4%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>/32.Database/HBase-02%E8%BF%90%E7%BB%B4%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-amp-部署"><a href="#安装-amp-部署" class="headerlink" title="安装 &amp; 部署"></a>安装 &amp; 部署</h2><ul><li>Hadoop &amp; HBase<ul><li>Hadoop集群: 1x NameNode, 2x DataNode, 共7T</li><li>HBase集群: 1x Master, 2x RegionServer</li></ul></li><li>服务分布情况:<ul><li>ip6 : hbase master, hadoop name_node, Zookeeper</li><li>ip7 : hbase region</li><li>ip8 : hbase region</li></ul></li></ul><h3 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h3><p>ssh ip6, 执行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /data1 &amp;&amp; mkdir -p hadoop/tmp &amp;&amp; mkdir -p hadoop/hdf/data &amp;&amp; mkdir -p hadoop/hdf/name</span><br></pre></td></tr></table></figure><p>编辑 /etc/profile:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/data0/hadoop-2.8.3</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</span><br><span class="line">export HADOOP_LOG_DIR=$HADOOP_HOME/logs</span><br><span class="line">export YARN_LOG_DIR=$HADOOP_LOG_DIR</span><br></pre></td></tr></table></figure><p>并执行 <code>source /etc/profile</code></p><p>停止:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /data0/hbase-1.3.2/bin &amp;&amp; sh stop-hbase.sh</span><br><span class="line">cd /data0/hadoop-2.8.3/sbin &amp;&amp; sh stop-dfs.sh &amp;&amp; sh stop-yarn.sh</span><br></pre></td></tr></table></figure><p>启动:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /data0/hadoop-2.8.3/sbin &amp;&amp; start-dfs.sh &amp;&amp; start-yarn.sh</span><br><span class="line">cd /data0/hbase-1.3.2/bin &amp;&amp; start-hbase.sh</span><br></pre></td></tr></table></figure><h3 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch /data1/zookeeper/myid &amp;&amp; echo 1 &gt; /data1/zookeeper/myid</span><br><span class="line">/data0/zookeeper-3.4.12/bin/zkServer.sh start</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><strong>① Server端优化:</strong></p><ul><li>JVM内存优化: <code>export HBASE_REGIONSERVER_OPT=&quot;-Xmx8g -Xms8g -Xmn128m -XX:+UseParNewGC -XX:UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 -verbose:gc -XX:+printGCDetails -XX:+PrintGCTimeStamps -Xloggc:${HBASE_HOME}/logs/gc-${hostname}-hbase.log&quot;</code></li><li>使用压缩: GZIP, LZO, Zippy/Snappy, 创建表的时候指定列族的压缩格式：<code>create &#39;testtable&#39;,{NAME =&gt; &#39;colfam1&#39;,COMPRESSION =&gt; &#39;GZ&#39;}</code></li><li>预分Region: 在建表的时候预先创建多个Region, 并规定好每个Region存储的Rowkey范围, 通过对数据的特性进行分析预先创建分区可以有效的解决HBase中的数据倾斜问题</li><li>防止拆分/合并风暴:<ul><li>考虑这种情况：拆分之后的两个子region都已恒定的速率增大，导致在同一时刻进行拆分，但是如果两个region拆分之后继续以恒定的速率增长导致子子region又一起拆分，这种情况被称为拆分/合并风暴，这将导致磁盘IO的飙升。这种情况下，与其依赖HBase的自动拆分，用户不如手动使用split和major_compact命令来管理，因为手动管理的话可以将这些region的拆分/合并时机分割开来，尽量分散IO负载。</li><li>碰到这种情况的时候不要忘记把配置文件中的<code>hbase.hregion.max.filesize</code>设置为非常大（但是major_compat时会耗时很长, 尽量在维护期间做major_compat）</li></ul></li><li><p>region热点问题: 通过合理设计row key解决;</p><p>  Major Compaction是指将所有的StoreFile合并成一个StoreFile，这个过程还会清理三类无意义数据：被删除的数据、TTL过期数据、版本号超过设定版本号的数据。<br>  另外，一般情况下，Major Compaction时间会持续比较长，整个过程会消耗大量系统资源，对上层业务有比较大的影响。因此线上业务都会将关闭自动触发Major Compaction功能，改为手动在业务低峰期触发。</p></li></ul><p><strong>② 客户端API优化:</strong></p><ul><li>禁用自动刷写 <code>Table.setAutoFlush(false)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase-02API简介</title>
      <link href="/32.Database/HBase-02API%E7%AE%80%E4%BB%8B/"/>
      <url>/32.Database/HBase-02API%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="客户端API-基础"><a href="#客户端API-基础" class="headerlink" title="客户端API: 基础"></a>客户端API: 基础</h1><p>包括hbase shell命令行 和Java API</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><ul><li><code>hbase shell</code>: 进入hbase shell, 然后可以用以下的hbase命令行</li><li><code>list</code> : list all table</li><li><code>help &#39;list&#39;</code> : 查看帮助</li><li><code>status</code> : 查看状态</li><li><code>create &#39;table1&#39;,&#39;col_family1&#39;,&#39;col_family2&#39;</code> : 创建表, 并包含两个列族</li><li><code>alter &#39;table1&#39;, NAME =&gt; &#39;col_family1&#39;, TTL =&gt; &#39;604800&#39;</code> : 修改列族的TTL(秒)</li><li><code>describe &#39;table1&#39;</code> : 查看表描述</li><li><code>put &#39;table1&#39;, &#39;rowkey1&#39;, &#39;col_family1:col111&#39;, &#39;value&#39;</code> : 插入一条数据, 格式为<code>put 表名, 行键, 列族:列, 值</code></li><li><code>get &#39;table1&#39;, &#39;rowkey1&#39;</code> : 查询记录, 格式为<code>get 表名, 行键</code></li><li><code>get &#39;table1&#39;, &#39;rowkey1&#39;, &#39;col_family1:col111&#39;</code> : 查询记录, 格式为<code>get 表名, 行键, 列族:列</code></li><li><code>get &#39;table1&#39;, &#39;rowkey1&#39;, { COLUMN =&gt; &#39;col_family1:col111&#39;, VERSIONS=&gt;1}</code>: 查询记录, 格式为<code>get 表名, 行键, {条件}</code>, 其中<code>COLUMN</code>和<code>VERSIONS</code>是预定义的, 分别表示列和版本号</li><li><code>count &#39;table1&#39;</code> : 统计表的行数</li><li><code>scan &#39;table1&#39; , {&#39;LIMIT&#39; =&gt; 5}</code> : 扫描一个表, <code>{&#39;LIMIT&#39; =&gt; 5}</code>是可选的</li><li><code>scan &#39;table1&#39;, {COLUMNS =&gt; &#39;fam:col&#39;, STARTROW =&gt; &#39;executed|1530226272&#39;, STOPROW =&gt; &#39;executed|1530233472&#39;}</code> : 带条件的扫描</li><li><code>scan &#39;hbase:meta&#39;</code> 扫描 hbase:meta 表, 旧的HBase版本里该表叫: <code>.META.</code></li><li><code>scan &#39;hbase:meta&#39;, {COLUMNS =&gt; &#39;info:regioninfo&#39;}</code> 参考 # META表</li><li><code>deleteall &#39;table1&#39;, &#39;rowkey1&#39;, &#39;column&#39;</code> : 删除该行键下”column”列的数据</li><li><code>deleteall &#39;table1&#39;, &#39;rowkey1&#39;</code> : 删除所有该行键下的数据</li><li><code>truncate &#39;table1&#39;</code> 清空表</li><li><code>disable &#39;table1&#39;</code> 然后<code>drop &#39;table1&#39;</code> : 删除表</li></ul><h2 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h2><p>@todo</p><h3 id="批处理-bacth"><a href="#批处理-bacth" class="headerlink" title="批处理(bacth)"></a>批处理(bacth)</h3><p>批量处理操作：可以批量处理跨多行的不同操作,<br>许多基于列表的操作，如delete、get的列表操作都是基于batch 方法实现的.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration conf = HBaseConfiguration.create();</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf,<span class="string">"test_table"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Row&gt; batch = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Put put = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"row_key1"</span>));</span><br><span class="line">put.addColumn(Bytes.toBytes(<span class="string">"col_fam1"</span>), Bytes.toBytes(<span class="string">"col_qual3"</span>), Bytes.toBytes(<span class="string">"test_data3"</span>));</span><br><span class="line">batch.add(put);</span><br><span class="line"><span class="comment">// 添加更多...</span></span><br><span class="line"></span><br><span class="line">Object[] results = <span class="keyword">new</span> Object[batch.size()];</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    table.batch(batch, results);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.err.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;results.length;i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">"result"</span>+<span class="string">"["</span>+i+<span class="string">"]:"</span>+results[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table-vs-BufferedMutator"><a href="#Table-vs-BufferedMutator" class="headerlink" title="Table vs BufferedMutator"></a>Table vs BufferedMutator</h3><p>In the new API, <code>BufferedMutator</code> is used.<br>You could change <code>Table t = connection.getTable(TableName.valueOf(&quot;foo&quot;))</code> to <code>BufferedMutator t = connection.getBufferedMutator(TableName.valueOf(&quot;foo&quot;))</code>. And then change <code>t.put(p)</code> to <code>t.mutate(p)</code></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁 在客户端 API中仍然存在， 但是不鼓励使用，因为管理不好，会锁定整个RegionServer.</p><h1 id="客户端API-高级特性"><a href="#客户端API-高级特性" class="headerlink" title="客户端API: 高级特性"></a>客户端API: 高级特性</h1><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Get 和 Scan 实例可以用 filters 配置，以应用于 RegionServer.<br>所有的过滤器都在服务端生效, 叫做”谓词下推”（ predicate push down）。这样可以保证过滤掉的数据不会被传送到客户端.<br>过滤器在客户端被创建, 通过RPC传送到服务器端, 然后在服务器端执行.</p><p>Hbase客户端api提供了几种过滤器:</p><ul><li>SingleColumnValueFilter : 列值过滤, 用于测试值的情况（相等，不等，范围 、、、）</li><li>RegexStringComparator: 支持正则表达式的值比较</li><li>SubstringComparator: 用于检测一个子串是否存在于值中。大小写不敏感。</li><li>FamilyFilter: 用于过滤列族。 通常，在Scan中选择ColumnFamilie优于在过滤器中做。</li><li>QualifierFilter: 用于基于列名(即 Qualifier)过滤.</li><li>ColumnPrefixFilter: 可基于列名(即Qualifier)前缀过滤。</li><li>RowFilter: 通常认为行选择时Scan采用 startRow/stopRow 方法比较好。然而 RowFilter 也可以用。</li></ul><p>下面是列值过滤器的一个例子:</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SingleColumnValueFilter filter = <span class="keyword">new</span> SingleColumnValueFilter(</span><br><span class="line">    cf,</span><br><span class="line">    column,</span><br><span class="line">    CompareOp.EQUAL,</span><br><span class="line">    Bytes.toBytes(<span class="string">"my value"</span>)</span><br><span class="line">    );</span><br><span class="line">scan.setFilter(filter);</span><br></pre></td></tr></table></figure></code></pre><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>一种支持的数据类型，值得一提的是“计数器”(如, 具有原子递增能力的数值)。参考 HTable的 Increment .<br>同步计数器在区域服务器中完成，不是客户端。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">incr '&lt;table&gt;', '&lt;row&gt;', '&lt;column&gt;', |&lt;increment-value&gt;|</span><br></pre></td></tr></table></figure><h2 id="协处理器"><a href="#协处理器" class="headerlink" title="协处理器"></a>协处理器</h2><ul><li>写数据:<ul><li>rowKey开头加salt, 如果有10个Region, 每个region 的startKey= 0, 1, ..9</li><li>salt = <code>hash%10</code></li><li>rowKey = <code>salt + &quot;_&quot; + rowKey</code></li></ul></li><li>Scan数据:<ul><li>client -&gt;startKey,endKey -&gt; Region</li><li>协处理器(在每个 RegionServer 执行): 获取当前Region 的StartKey, 拼接查询的 startKey</li></ul></li></ul><blockquote><p>@ref <a href="https://blog.csdn.net/b6ecl1k7BS8O/article/details/87927729" target="_blank" rel="noopener">HBase 中加盐之后的表如何读取：协处理器篇_大数据_Hadoop技术博文-CSDN博客</a></p></blockquote><h2 id="批处理客户端"><a href="#批处理客户端" class="headerlink" title="批处理客户端"></a>批处理客户端</h2><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><p>Hive+HBase: 使用Hive读取Hbase中的数据。<br>我们可以使用HQL语句在HBase表上进行查询、插入操作；甚至是进行Join和Union等复杂查询。此功能是从Hive 0.6.0开始引入的，详情可以参见HIVE-705。Hive与HBase整合的实现是利用两者本身对外的API接口互相进行通信，相互通信主要是依靠hive-hbase-handler-1.2.0.jar工具里面的类实现的。</p><p>参考: <a href="https://www.iteblog.com/archives/1718.html" target="_blank" rel="noopener">Hive和HBase整合用户指南</a></p><h3 id="Apache-Pig"><a href="#Apache-Pig" class="headerlink" title="Apache Pig"></a>Apache Pig</h3><p>如果不满足Hvie提供的HQL查询, 还可以用Pig Latin脚本实现更复杂的MapReduce Job,<br>Pig支持对Hbase表的读写, Hbase表中的”列”可以映射到Pig的元组</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>与Hadoop MapReduce Java API的整合</p><p>参考: <a href="https://www.evernote.com/shard/s120/nl/12825969/ea4dc0a2-0d89-4f2e-a0c2-21501fc3e0d8/" target="_blank" rel="noopener">使用MapReduce APIs读写HBase</a></p>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase-00基础概念</title>
      <link href="/32.Database/HBase-00%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/32.Database/HBase-00%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://hbase.apache.org/images/hbase_logo_with_orca_large.png" alt="HBase"></p><p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。<br>与FUJITSU Cliq等商用大数据产品不同，HBase是Google Bigtable的开源实现，类似Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。</p><ul><li>HBase适用于简单数据写入（如“消息类”应用）和海量、结构简单数据的查询（如“详单类”应用），适合稀疏表；</li><li>作为大数据MapReduce的后台数据源，以支撑离线分析型应用；</li><li>基于HDFS分布式文件系统, 可扩展性+；</li><li>Facebook的消息类应用，包括Messages、Chats、Emails和SMS系统，用的都是HBase；</li></ul><h2 id="概念-表-行-列族-列-版本"><a href="#概念-表-行-列族-列-版本" class="headerlink" title="概念: 表, 行, 列族, 列, 版本"></a>概念: 表, 行, 列族, 列, 版本</h2><ul><li>行（Row）: HBase 中的一行包含一个行键和一个或多个与其相关的值的列。在存储行时，行按字母顺序排序。<br>出于这个原因，行键的设计非常重要。目标是以相关行相互靠近的方式存储数据。常用的行键模式是网站域。如果你的行键是域名，则你可能应该将它们存储在相反的位置（org.apache.www，org.apache.mail，org.apache.jira）。这样，表中的所有 Apache 域都彼此靠近，而不是根据子域的第一个字母分布。</li><li>列（Column）: HBase 中的列由一个列族和一个列限定符组成，它们由<code>:</code>字符分隔。<ul><li>列族（Column Family）: 出于性能原因，列族在物理上共同存在一组列和它们的值。在 HBase 中每个列族都有一组存储属性，例如其值是否应缓存在内存中，数据如何压缩或其行编码是如何编码的等等。表中的每一行都有相同的列族，但给定的行可能不会在给定的列族中存储任何内容。列族一旦确定后，就不能轻易修改，因为它会影响到 HBase 真实的物理存储结构，但是列族中的列标识(Column Qualifier)以及其对应的值可以动态增删。</li><li>列限定符（Column Qualifier）: 列限定符被添加到列族中，以提供给定数据段的索引。鉴于列族的content，列限定符可能是content:html，而另一个可能是content:pdf。虽然列族在创建表时是固定的，但列限定符是可变的，并且在行之间可能差别很大。</li></ul></li><li>单元格（Cell） 单元格是行、列族和列限定符的组合，并且包含值和时间戳，它表示值的版本。</li><li>时间戳（Timestamp） 时间戳与每个值一起编写，并且是给定版本的值的标识符。默认情况下，时间戳表示写入数据时 RegionServer 上的时间，但可以在将数据放入单元格时指定不同的时间戳值。</li></ul><h2 id="概念视图"><a href="#概念视图" class="headerlink" title="概念视图"></a>概念视图</h2><p><img src="/images/hbase/hbase_conceptual_view.png" alt=""></p><p>上面的数据有相同的Row key = “com.cnn.www”, 每行表示一个数据版本, 共有5个版本(Time Stamp表示),<br>有两个列族 contents 和 anchor, 两个列族下分别有contents:html, anchor:cnnsi.com, anchor:my.look.ca三个列,</p><p>用json格式表示概念视图:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;com.cnn.www&quot;: [   // 行键</span><br><span class="line">  &quot;t9&quot; : &#123;         // 版本=9</span><br><span class="line">      &quot;contents:html&quot;    : &quot;&lt;html&gt;...&quot;, // 列1 : value</span><br><span class="line">      &quot;anchor:cnnsi.com&quot; : &quot;CNN...&quot;,    // 列2 : value</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;t8&quot; : &#123;         // 版本=8</span><br><span class="line">      &quot;contents:html&quot;    : &quot;&lt;html&gt;...&quot;, // 列1 : value</span><br><span class="line">      &quot;anchor:cnnsi.com&quot; : &quot;CNN...&quot;,    // 列2 : value</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h2><p><img src="/images/hbase/hbase_physical_view.png" alt=""><br>物理存储是按照列族(family)分布的, 相同的列族在连续的物理空间存储.</p><p>如下图, 一张表里有不同的列族 CF1, CF2, 每个列族下面有自己的qualifier, 可以看到一张表的数据被按照列族分布在不同的物理位置。<br><img src="/images/hbase/hbase_column_family.png" alt=""></p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>HBase的生存时间(TTL)是针对列族设置的, 一旦达到到期时间，HBase 将自动删除行。修改一个列族的TTL如下:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disable 'table1'  #先禁用表</span><br><span class="line">alter 'table1', &#123;NAME=&gt;'col_family1', TTL =&gt; '100'&#125; #指明修改哪个列族, 100的单位是秒</span><br><span class="line">enable 'table1'</span><br></pre></td></tr></table></figure></p><p>从上面可以看到, TTL虽然是针对列族的参数, 但是给某个列族修改/增加TTL需要暂时disable表, 所以在生产环境里最好还是在建表的时候就给每个列族指定好TTL</p>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DB.01-数据库分类 - OLTP、OLAP、TSDB</title>
      <link href="/32.Database/DB.01-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB/"/>
      <url>/32.Database/DB.01-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="OLTP-vs-OLAP"><a href="#OLTP-vs-OLAP" class="headerlink" title="OLTP vs OLAP"></a>OLTP vs OLAP</h1><p>OLTP(online transcation processing)联机事务处理:</p><ul><li>多用来解决业务中的事务(ACID: 原子性,一致性,…)问题, 随机读写, 频繁的更改/删除;</li><li>不适合数据分析场景: 场景特点(数据量大), 分析和计算能力(OLTP没有, 只能查询到业务层再处理) // 关系型数据库, count/max/group by的实现?</li></ul><p>OLAP(online analytical processing)联机分析处理:</p><ul><li>OLAP不关数据的事务特性, 也不关注数据的频繁删改, 而是关注大量数据的多维度/复杂分析和计算</li><li>OLAP的分类:<ul><li>多维度OLAP（Multi-Dimensional OLAP，简称MOLAP）:<br>对数据需要分析的维度预先建模, 在数据存储的物理层面使用cube的结构进行存储(?) 缺点是数据需要预先建模, 优点比下面的关系型OLAP分析计算更快</li><li>关系型OLAP（Relational OLAP，简称ROLAP）:<br>使用类似关系型数据库的存储模型(例如用label取代column), 使用类似SQL的语句进行分析查询, 分析计算更自由(相比多维度OLAP预先建模的方式), 但是海量数据下计分析算速度不如多维度OLAP</li></ul></li></ul><h1 id="TSDB-时序数据库"><a href="#TSDB-时序数据库" class="headerlink" title="TSDB(时序数据库)"></a>TSDB(时序数据库)</h1><p>➤ TSDB适用哪些业务场景</p><ul><li>持续产生海量数据的业务: 持续(每秒都产生,没有突增热点)和海量(每秒千万/亿条)<ul><li>比如监控系统产生的日志</li><li>比如可穿戴设备+物联网设备产生的日志</li></ul></li><li>几乎全都是写入, update/delete操作极少</li><li>近期数据价值更高, 久远的数据极少被访问, 所以数据以流式处理居多</li><li>没有关系型数据库的列, 一条数据不同维度的数据用标签区别, 可以以标签聚合查询(例如查询监控系统中,统计某API几天内访问量)</li></ul><p>➤ TSDB核心技术</p><ul><li>写入量大:<ul><li>方便的集群扩容(水平扩展), 业务对存储层的扩容无感知</li><li>存储结构使用LSM(HBase or Druid), LSM是用来保证单机体系的写入效率</li></ul></li><li>数据分级存储/数据TTL: x小时内的使用内存, x天内使用SSD, 更久远的使用HDD, 或者根据TTL删除</li><li>多标签查询: 多使用位图索引 or 倒排索引</li><li>聚合查询: 预聚合</li></ul><p>@ref: <a href="http://hbasefly.com/2017/11/19/timeseries-database-1/?rulkna=n0cfu1" target="_blank" rel="noopener">http://hbasefly.com/2017/11/19/timeseries-database-1/?rulkna=n0cfu1</a></p>]]></content>
      
      
      <categories>
          
          <category> 32.Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OLTP </tag>
            
            <tag> OLAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何画架构图</title>
      <link href="/31.Backend/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
      <url>/31.Backend/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<ol><li>图是给什么角色看的(客户 运维/实施 &amp; 开发), 即决定了用途, 要表达什么? 对方关注什么, 应该给对方看什么</li><li>组件(实体)是什么: 物理硬件、实际集群、中间件（服务）、业务服务 （考虑架构是基于SaaS or PasS平台？ 来决定图中的每个实体是什么）</li><li>..</li></ol><h1 id="➤-逻辑视图1-业务向"><a href="#➤-逻辑视图1-业务向" class="headerlink" title="➤ 逻辑视图1(业务向)"></a>➤ 逻辑视图1(业务向)</h1><p><img src="/images/diagram-逻辑视图-业务向.png" alt="diagram-逻辑视图-业务向"></p><h1 id="➤-逻辑视图2-技术向"><a href="#➤-逻辑视图2-技术向" class="headerlink" title="➤ 逻辑视图2(技术向)"></a>➤ 逻辑视图2(技术向)</h1><p><img src="/images/diagram-逻辑视图1.png" alt="diagram-逻辑视图1"></p><p><img src="/images/diagram-逻辑视图2.png" alt="diagram-逻辑视图2"></p><h1 id="➤-物理视图"><a href="#➤-物理视图" class="headerlink" title="➤ 物理视图"></a>➤ 物理视图</h1><ul><li>运维 &amp; 实施</li><li>软件到硬件的映射关系</li></ul><p><img src="/images/diagram-物理视图.png" alt="diagram-物理视图"></p><h1 id="➤-时序图"><a href="#➤-时序图" class="headerlink" title="➤ 时序图"></a>➤ 时序图</h1><p><img src="/images/diagram-时序图.png" alt="diagram-时序图"></p><h1 id="➤-场景视图（业务）"><a href="#➤-场景视图（业务）" class="headerlink" title="➤ 场景视图（业务）"></a>➤ 场景视图（业务）</h1><ul><li>非架构、更像业务流程图</li></ul><p><img src="/images/diagram-场景视图.png" alt="diagram-场景视图"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coolshell.me/articles/architecture-graph-create-overall-architecture.html" target="_blank" rel="noopener">架构师必备技能：架构图的构图 – 酷 壳 – CoolShell 3F</a></li><li><a href="https://www.zhihu.com/question/27440059" target="_blank" rel="noopener">如何画架构图？ - 知乎</a></li><li><a href="https://github.com/phodal/articles/issues/18" target="_blank" rel="noopener">程序员必知的七个图形工具</a></li><li><a href="https://online.visual-paradigm.com/cn/diagrams/features/aws-architecture-diagram-tool/" target="_blank" rel="noopener">亚马逊AWS在线架构图软件</a></li><li><a href="https://aws.amazon.com/cn/architecture/icons/" target="_blank" rel="noopener">AWS简约图标</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统-Consistency</title>
      <link href="/31.Backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-Consistency/"/>
      <url>/31.Backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-Consistency/</url>
      
        <content type="html"><![CDATA[<p>➤ 分布式系统的一致性(概念)：</p><ul><li>分布式系统中, 每个节点(或者副本)的数据保持一致;</li><li>「数据一致性其实是数据库系统中的概念。我们可以简单的把一致性理解为正确性或者完整性，那么数据一致性通常指关联数据之间的逻辑关系是否正确和完整」</li></ul><p>➤ 强一致性、弱一致性、最终一致性：</p><ul><li>强一致性: 当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。但是这种实现对性能影响较大，因为这意味着，只要上次的操作没有处理完，就不能让用户读取数据。</li><li>弱一致性: 系统并不保证进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。</li><li>最终一致性: 弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS是一个典型的最终一致性系统。</li><li>最终一致性模型的变种:<ul><li>因果一致性：如果A进程在更新之后向B进程通知更新的完成，那么B的访问操作将会返回更新的值。如果没有因果关系的C进程将会遵循最终一致性的规则。</li><li>读己所写一致性：因果一致性的特定形式。一个进程总可以读到自己更新的数据。</li><li>会话一致性：读己所写一致性的特定形式。进程在访问存储系统同一个会话内，系统保证该进程读己之所写。</li><li>单调读一致性：如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。</li><li>单调写一致性：系统保证对同一个进程的写操作串行化。</li></ul></li></ul><p>@ref:</p><ul><li><a href="https://www.hollischuang.com/archives/663" target="_blank" rel="noopener">关于分布式一致性的探究-HollisChuang’s Blog</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统-CAP理论</title>
      <link href="/31.Backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-CAP%E7%90%86%E8%AE%BA/"/>
      <url>/31.Backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-CAP%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>分布式系统的指标: CAP</p><ul><li>C(Consistency): 一致性 // 分布式系统中多个节点(或多个副本)的数据保持一致, 一致性又分强一致性/弱一致性/最终一致性, CAP里的一致性指强一致性 <a href="/31.Backend/分布式系统-Consistency/" title="分布式系统-Consistency">分布式系统-Consistency</a></li><li>A(Availability): 可用性 // 当用户请求节点A, 节点A一定会回应 </li><li>P(Partition tolerance): 分区容错, 在分布式节点之间网络断开时, 仍旧提供一致性和可用性。// 一般来说，分区容错无法避免，因此可以假定 CAP 的 P 总是成立, 剩下的是选择 AP 还是 CP的问题 (三个指标无法同时做到)</li></ul><p>Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p><p>分布式系统只能满足CAP中的两个, 为什么?<br>假设P总是成立, 当写入新数据到node1, 为了实现一致性, 不得不锁定node2 直到数据同步完成, 那么此时node2就不满足可用性 … </p><p>CAP如何取舍: </p><ul><li>CA without P: 单机系统 // 所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了</li><li>CP without A: 其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。</li><li>AP without C:  如果对可用性要求极高(N个9).. 但也并非完全舍弃C, 退而求其次保证最终一致性即可</li></ul><hr><p>@ref:</p><ul><li><a href="http://www.hollischuang.com/archives/666" target="_blank" rel="noopener">分布式系统的CAP理论-HollisChuang’s Blog</a></li><li><a href="https://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">CAP 定理的含义 - 阮一峰的网络日志</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务-2PC-and-3PC协议解析</title>
      <link href="/31.Backend/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-2PC-and-3PC%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/31.Backend/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-2PC-and-3PC%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>分布式事务 → 2PC、3PC协议</li><li>2PC协议实现;</li><li>3PC协议实现;</li><li>2PC &amp; 3PC比较</li></ul><h2 id="分布式事务→-2PC、3PC协议"><a href="#分布式事务→-2PC、3PC协议" class="headerlink" title="分布式事务→ 2PC、3PC协议"></a>分布式事务→ 2PC、3PC协议</h2><ul><li>事务的特性: ACID （👉🏻[[../32.Database/MySQL-04事务-特性和实现原理#ACID特性]]）</li><li>分布式事务解决分布式数据的一致性(Consistency)问题  </li><li>数据库系统保证一致性是「提供正确的增/删/改/查等语义」的基础, 分布式系统一致性问题来自于:<ul><li>数据多副本存储(每个副本在不同物理机) 需要保证多副本数据一致性;</li><li>一个完整事务涉及多个数据库的多表(例如银行转账问题, a和b账户不在一个数据库)</li></ul></li><li>解决分布式一致性的协议和算法:  2PC、3PC、Paxos</li><li>分布式事务对比分布式锁: 分布式锁是「多client抢占一个公共资源」, 分布式事务是「一个client操作多个资源, 并保证一致性」</li></ul><p>相关阅读:</p><ul><li>分布式系统一致性: <a href="/31.Backend/分布式系统-Consistency/" title="分布式系统-Consistency">分布式系统-Consistency</a></li><li>MySQL的ACID如何实现: [[../32.Database/MySQL-04事务-特性和实现原理]]</li><li>Raft: <a href="/31.Backend/Redis-03Raft实现/" title="Redis-03Raft实现">Redis-03Raft实现</a></li><li>Paxos: [[分布式系统-Consistency-Paxos]]</li></ul><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC(Two Phase Commitment Protocol, 2阶段提交协议)概述:</p><p>分布式事务中的角色:</p><ul><li>协调者, 事务管理器(TM)</li><li>参与者, 资源管理器(RM), 在分布式事务中可能是多个数据库</li></ul><p>执行步骤:</p><ul><li>1)准备阶段:     <ul><li>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息;</li><li>每个参与者(资源管理器)要么直接返回失败，要么写本地的redo和undo日志并返回成功;</li></ul></li><li>2)提交阶段:<ul><li>如果协调者(TM)收到了参与者(在第一阶段返回的)失败, 或者超时, 协调者(TM)发送 rollback 消息 给每个参与者;</li><li>如果协调者(TM)收到了每个参与者返回的成功消息, 协调者(TM)发送 commit 消息 给每个参与者;</li><li>参与者正式完成操作(commit 或 rollback), 释放事务期间占用资源, 并向协调者发布完成消息;</li><li>协调者(TM)收到所有参与者的完成消息, 最终完成事务</li></ul></li></ul><p>2PC的问题:</p><ul><li>协调者故障: 每个参与者的状态没有超时机制, 在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，这种状态一直阻塞下去;</li><li>数据不一致: 当协调者(TM)向参与者(RM)发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。 </li><li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ul><h1 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h1><p>3PC协议概述:</p><p>步骤:</p><ul><li>1)CanCommit:<ul><li>协调者(TM)向参与者发送 CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li><li>参与者(RM)接到 CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</li></ul></li><li>2)PreCommit:<ul><li>协调者TM 向参与者发送 PreCommit请求;</li><li>参与者RM 接收到 PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。并向协调者返回成功;</li><li>协调者TM 未收到某个参与者的确认请求，或者有参与者超时未返回, 协调者向所有参与者发送 abort</li></ul></li><li>3)DoCommit:<ul><li>协调者(TM)收到了所有参与者的确认请求，且没有参与者超时未返回，协调者向所有参与者发送doCommit请求;</li><li>参与者接收到 doCommit请求之后, 执行正式的事务提交. 完成后向协调者发送响应</li><li>协调者(TM)接收到所有参与者的确认响应之后，完成事务</li><li>协调者(TM)未收到某个参与者的确认请求，或者有参与者超时未返回, 协调者向所有参与者发送abort</li><li>在这一阶段, 如果参与者(RM)无法及时接收到来自协调者(TM)的 doCommit或者 rebort请求时, 会在等待超时之后，会继续进行事务的提交。</li></ul></li></ul><p>可能出现的问题:<br>参与者(RM)无法及时收到来自协调者(TM)的信息之后，会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><p>➤ 2PC &amp; 3PC 比较:</p><ul><li>2PC: 协调者只在 Prepare阶段可能发送 rollback指令, </li><li><p>3PC: 协调者在 preCommit 和 doCommit阶段, 都会根据参与者返回决定是否发生abord指令</p></li><li><p>3PC: 在参与者收到 preCommit指令后, 如果等待协调者超时, 参与者会自动提交commit</p></li><li>2PC: 在参与者收到 Prepare 指令后, 如果等待协调者超时, 参与者会一直等待下去(阻塞)</li></ul><p>@ref:</p><ul><li><a href="https://timyang.net/distributed/time-to-move-on-from-two-phase/" target="_blank" rel="noopener">2PC之踵？是时候升级二阶段提交协议了 – 后端技术 by Tim Yang</a></li><li><a href="http://www.hollischuang.com/archives/681" target="_blank" rel="noopener">关于分布式事务、两阶段提交协议、三阶提交协议-HollisChuang’s Blog</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>架构案例-混沌工程</title>
      <link href="/31.Backend/%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B-%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B/"/>
      <url>/31.Backend/%E6%9E%B6%E6%9E%84%E6%A1%88%E4%BE%8B-%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="https://www.sohu.com/a/376252845_185201" target="_blank" rel="noopener">混沌工程：苏宁系统稳定性之道_实验</a></p><ul><li>混沌工程是Netflix在 《chaos engineing》提出的，目的是在分布式系统中..</li><li>混沌工程vs故障注入测试:</li><li>故障注入测试:<ul><li>单机: CPU/内存/网卡资源被抢占, 单机进程挂掉</li><li>数据库(DB/Redis等): 分库挂掉, 整库挂掉</li><li>整个IDC机房故障, 核心网故障</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列 | Kafka vs RabbitMQ</title>
      <link href="/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83(Kafka-vs-RabbitMQ)/"/>
      <url>/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E9%80%89%E5%9E%8B%E6%AF%94%E8%BE%83(Kafka-vs-RabbitMQ)/</url>
      
        <content type="html"><![CDATA[<h2 id="➤-Kafka"><a href="#➤-Kafka" class="headerlink" title="➤ Kafka"></a>➤ Kafka</h2><ul><li>模型: 订阅/发布, 生产者和消费者是多对多</li><li>存储: 磁盘</li><li>吞吐量/延迟: 10W, 毫秒级</li><li>架构: 参考 <a href="/31.Backend/消息队列-Kafka/" title="消息队列-Kafka">消息队列-Kafka</a></li><li>高可用机制: 参考 <a href="/31.Backend/消息队列-Kafka-特性实现/" title="消息队列-Kafka-特性实现">消息队列-Kafka-特性实现</a></li><li>如何保证顺序性: 顺序性指 生产者的(带有顺序性的)消息, 如何保证消费者也按照该顺序消费<ul><li>生产者: 因为kafka 的topic 存储于多个分区, 为了防止一组顺序消息被投放到不同分区, 可以指定消息的key, 相同k的消息一定被发送到相同分区;</li><li>消费者: @todo</li></ul></li><li>防重复消费: 消费者在消费掉某条数据后, 把该条数据的offset提交给zk, 下次消费者请求数据, kafka 从 offset处开始</li><li>防消息丢失机制: 因为kafka partition 的多副本机制, 要考虑 如果发生leader-follower切换的情况下, 如何不丢数据<ul><li>生产者丢数据: 设置<code>acks=all</code>, 生产者投递消息, leader 保证所有 partition 都同步了数据才发送 ack 给生产者, 否则生产者会一直重试投递;</li><li>消费者丢数据: 关闭消费者的自动提交offet, 需要消费者业务代码手动的提交offset</li></ul></li></ul><h2 id="➤-RabbitMQ"><a href="#➤-RabbitMQ" class="headerlink" title="➤ RabbitMQ"></a>➤ RabbitMQ</h2><ul><li>模型: PTP, 生产者消费者1对1</li><li>存储: 非持久化的消息一般只存在于内存中，在内存紧张的时候会被换入到磁盘中，以节省内存。</li><li>吞吐量/延迟*: 1W, 微秒级</li><li>架构: 基于队列实现, 可以”不同业务使用不同MQ实例”来做MQ的垂直切分, 同时RabbitMQ还提供了镜像模式, 即一个队列有多个镜像, 写入队列的数据会被同步到其他镜像队列上去( RbMQ如何实现主队列失效, 切换镜像队列的? )</li><li>高可用机制: 镜像模式, 每个RabbitMQ节点上都一个queue的镜像</li><li>如何保证顺序性机制: 队列的FIFO, 消费者多线程的情况下如何保证顺序?</li><li>防重复消费:</li><li>防消息丢失机制:<ul><li>生产者防丢: confirm 模式, MQ Server 收到生产者发送的消息, 会返一个ack</li><li>MQ Server防丢: 持久化</li><li>消费者防丢: 关闭自动ack, 消费者取到消息, 业务代码处理完后, 再调用 ack api通知 MQ Server</li></ul></li></ul><blockquote><p>@ref <a href="https://juejin.im/post/5db6ad39f265da4cfd2957d7#heading-8" target="_blank" rel="noopener">Java高频面试集-消息队列MQ - 掘金</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>资源调度 | YARN vs Mesos vs k8s</title>
      <link href="/31.Backend/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6-Yarn-Mesos-k8s/"/>
      <url>/31.Backend/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6-Yarn-Mesos-k8s/</url>
      
        <content type="html"><![CDATA[<h1 id="Mesos"><a href="#Mesos" class="headerlink" title="Mesos"></a>Mesos</h1><p>![[../_images/mesos-arch.png]]</p><p>➤ Mesos + Docker:<br>![[../_images/mesos-docker.png]]</p><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><p>Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，<br>它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p><h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><p>YARN的基本思想是将JobTracker的两个主要功能（资源管理和作业调度/监控）分离，<br>主要方法是创建一个全局的ResourceManager（RM）和若干个针对应用程序的ApplicationMaster（AM）。<br>这里的应用程序是指传统的MapReduce作业或作业的DAG（有向无环图）。</p><p>YARN 分层结构的本质是 ResourceManager。<br>这个实体控制整个集群并管理应用程序向基础计算资源的分配。<br>ResourceManager 将各个资源部分（计算、内存、带宽等）精心安排给基础 NodeManager（YARN 的每节点代理）。<br>ResourceManager 还与 ApplicationMaster 一起分配资源，与 NodeManager 一起启动和监视它们的基础应用程序。在此上下文中，ApplicationMaster 承担了以前的 TaskTracker 的一些角色，ResourceManager 承担了 JobTracker 的角色。</p><p>ApplicationMaster 管理一个在 YARN 内运行的应用程序的每个实例。<br>ApplicationMaster 负责协调来自 ResourceManager 的资源，并通过 NodeManager 监视容器的执行和资源使用（CPU、内存等的资源分配）。<br>请注意，尽管目前的资源更加传统（CPU 核心、内存），但未来会带来基于手头任务的新资源类型（比如图形处理单元或专用处理设备）。从 YARN 角度讲，ApplicationMaster 是用户代码，因此存在潜在的安全问题。YARN 假设 ApplicationMaster 存在错误或者甚至是恶意的，因此将它们当作无特权的代码对待。</p><p>NodeManager 管理一个 YARN 集群中的每个节点。NodeManager 提供针对集群中每个节点的服务，从监督对一个容器的终生管理到监视资源和跟踪节点健康。<br>MRv1 通过插槽管理 Map 和 Reduce 任务的执行，而 NodeManager 管理抽象容器，这些容器代表着可供一个特定应用程序使用的针对每个节点的资源。<br>YARN 继续使用 HDFS 层。它的主要 NameNode 用于元数据服务，而 DataNode 用于分散在一个集群中的复制存储服务。</p><p>要使用一个 YARN 集群，首先需要来自包含一个应用程序的客户的请求。ResourceManager 协商一个容器的必要资源，启动一个 ApplicationMaster 来表示已提交的应用程序。<br>通过使用一个资源请求协议，ApplicationMaster 协商每个节点上供应用程序使用的资源容器。<br>执行应用程序时，ApplicationMaster 监视容器直到完成。当应用程序完成时，ApplicationMaster 从 ResourceManager 注销其容器，执行周期就完成了。</p><h2 id="主要架构"><a href="#主要架构" class="headerlink" title="主要架构"></a>主要架构</h2><p>@todo</p><h1 id="Kubernetes-k8s"><a href="#Kubernetes-k8s" class="headerlink" title="Kubernetes(k8s)"></a>Kubernetes(k8s)</h1><a href="/31.Backend/容器编排-K8s/" title="容器编排-K8s">容器编排-K8s</a>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 资源调度 </tag>
            
            <tag> YARN </tag>
            
            <tag> Mesos </tag>
            
            <tag> k8s </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向代理-Nginx</title>
      <link href="/31.Backend/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-Nginx/"/>
      <url>/31.Backend/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-Nginx/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn-1.wp.nginx.com/wp-content/uploads/2015/04/NGINX_logo_rgb-01.png" alt=""></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Nginx是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。</p><h2 id="与Apache相比"><a href="#与Apache相比" class="headerlink" title="与Apache相比"></a>与Apache相比</h2><p>Nginx 的编写有一个明确目标就是超越 Apache Web 服务器的性能。Nginx 提供开箱即用的静态文件，使用的内存比 Apache 少得多，每秒可以处理大约四倍于 Apache 的请求。低并发下性能与 Apache 相当，有时候还低于，但是在高并发下 Nginx 能保持低资源低消耗高性能。还有高度模块化的设计，模块编写简单。配置文件简洁。</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动example: </span><br><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line"># 测试配置文件</span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line"># 平滑重启</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如何shutdown</span><br><span class="line"># 查询 master process主进程号</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line"># 从容停止</span><br><span class="line">kill -QUIT 3266</span><br></pre></td></tr></table></figure><p>Nginx支持的几种信号: </p><blockquote><ul><li>TERM,INT 快速关闭</li><li>QUIT 从容关闭</li><li>HUP 平滑重启，重新加载配置文件</li><li>USR1 重新打开日志文件，在切割日志时用途较大</li><li>USR2 平滑升级可执行程序</li><li>WINCH 从容关闭工作进程</li></ul></blockquote><h1 id="nginx-conf配置"><a href="#nginx-conf配置" class="headerlink" title="nginx.conf配置"></a>nginx.conf配置</h1><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>@ref: </p><ul><li>Full Example Configuration | NGINX：<a href="https://www.nginx.com/resources/wiki/start/topics/examples/full/" target="_blank" rel="noopener">https://www.nginx.com/resources/wiki/start/topics/examples/full/</a> </li></ul><p>cat nginx.conf : </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user       www www;  ## Default: nobody</span><br><span class="line">worker_processes  5;  ## Default: 1</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line">worker_rlimit_nofile 8192;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    multi_accept        on;</span><br><span class="line">    worker_connections  10240;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types; # 设定mime类型</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    access_log    /var/log/nginx/access.log; # 设定日志格式</span><br><span class="line">    include upstream-servers.conf; # 建议把upstream设置放在单独的文件</span><br><span class="line"></span><br><span class="line">    # 虚拟服务器, 可以有多个server</span><br><span class="line">    server&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  s1.xxx.com;</span><br><span class="line">        index index.shtml index.html index.htm;</span><br><span class="line">        root /opt/xxx;</span><br><span class="line"></span><br><span class="line">        # upstream定义，下面会引用：</span><br><span class="line">        upstream resin-labs &#123;</span><br><span class="line">            server 192.168.1.100 weight=3;</span><br><span class="line">            server 192.168.1.101;</span><br><span class="line">        &#125;</span><br><span class="line">        upstream resin-admin &#123;</span><br><span class="line">            server 192.168.1.109;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 一些rewrite：</span><br><span class="line">        rewrite ^/help$ /help/ redirect;</span><br><span class="line"></span><br><span class="line">        # location定义，建议顺序：精确匹配=, 前缀匹配^~, 正则匹配~, 普通匹配</span><br><span class="line">        location ~ ^/api/labs &#123;</span><br><span class="line">            access_log /opt/logs/nginx/labs_stat.log labs_stat;</span><br><span class="line">            # 反向代理到‘resin-labs’的 upstream</span><br><span class="line">            proxy_pass http://resin-labs;</span><br><span class="line">        &#125;</span><br><span class="line">        location /&#123;</span><br><span class="line">            # 反向代理到‘resin-admin’的 upstream</span><br><span class="line">            proxy_pass http://resin-admin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http下的Keepalive设置, 是Nginx与客户端（一般为浏览器、APP等）保持的长连接进行限制管理: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keepalive_timeout  120s 120s; // </span><br><span class="line">keepalive_requests 100; //</span><br></pre></td></tr></table></figure><ul><li>keepalive_timeout： 第一个参数：客户端连接在服务器端空闲状态下保持的超时值（默认75s）；值为0会禁用keep-alive，也就是说默认不启用长连接；第二个参数：响应的header域中设置“Keep-Alive: timeout=time”；告知浏览器对长连接的维持时间；官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_timeout" target="_blank" rel="noopener">Module ngx_http_core_module</a></li><li>keepalive_requests：默认100，某个长连接连续处理请求次数限制，超过次数则该长连接被关闭；如果需要释放某个连接占用的内存，必须关闭该链接，内存不大的情况下，不建议开大该配置；在QPS较高的场景，则有必要加大这个参数；官方文档：<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_requests" target="_blank" rel="noopener">Module ngx_http_core_module</a></li></ul><h2 id="http-server"><a href="#http-server" class="headerlink" title="http/server"></a>http/server</h2><p>一个<code>server{}</code> 对应一个port</p><h2 id="server-location"><a href="#server-location" class="headerlink" title="server/location"></a>server/location</h2><p>参考 (<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_core_module.html#location</a>)<br>优先级:</p><ol><li>精确匹配: <code>location = /xxx</code>  URL完全匹配”/xxx”</li><li>前缀匹配: <code>location ^~ /xxx</code>  URL”/xxx”开头的前缀, 比如”a.com/xxx/1”</li><li>正则匹配: <code>location ~ ^*.php$</code></li><li>正则(不区分大小写): <code>location ~* ^*.php$</code></li><li>普通匹配: <code>location /</code>  这样写一般用作其他条件都不符合, 最后的default行为</li></ol><p>for Example: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一个必选规则</span><br><span class="line">#直接匹配网站根, 如果首页访问量很大, 应该首先匹配</span><br><span class="line">location = / &#123;</span><br><span class="line">    root /var/www/;</span><br><span class="line">    index index.htm index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二个必选规则是处理静态文件请求</span><br><span class="line"># 前缀匹配&quot;^~&quot;优先级仅次于精确匹配&quot;=&quot;, 可以用来</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">    root /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line"># 如果使用memcached作为缓存, 也可以使用前缀匹配</span><br><span class="line">location ^~ /api/services/topic/load &#123;</span><br><span class="line">    memcached_pass memcached-cluster;</span><br><span class="line">&#125;</span><br><span class="line"># 前缀匹配^~也可以是转发到应用服务, 但不推荐, 应该让静态文件访问处于更高的优先级</span><br><span class="line"></span><br><span class="line"># 正则匹配也可以用来处理静态文件</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 正则匹配用来转发到后端应用服务</span><br><span class="line">location ~ ^/api/v2 &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 最后普通字符匹配, 用来向后端应用转发</span><br><span class="line"># 毕竟目前的一些RESTFUL框架的流行, 带.php,.jsp后缀的情况很少了</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://tomcat:8080/</span><br></pre></td></tr></table></figure><h2 id="location-proxy-pass"><a href="#location-proxy-pass" class="headerlink" title="location/proxy_pass"></a>location/proxy_pass</h2><blockquote><p>注意区分 ngx_stream_proxy_module 模块的 proxy_pass指令:  指令只能在server段使用使用, 只需要提供域名或ip地址和端口。可以理解为端口转发，可以是tcp端口，也可以是udp端口</p></blockquote><p>这里介绍 ngx_http_proxy_module 模块的 proxy_pass指令, 只能出现在 server/location下, 可以理解为端口转发，可以是tcp端口，也可以是udp端口.<br>proxy_pass 把请求向下一个服务转发, 不影响用户浏览器地址栏的URL  // 比如遇到跨域问题，而且客户端无法支持 CORS 时, 最好的办法就是让服务器来做代理. </p><p>格式 <code>proxy_pass URL</code>,  其中<code>URL</code>可以是另一个服务的Http地址, 也可以是定义的<code>upstream</code>,<br>需要注意<code>URL</code>后面是否带<code>/</code>, 表示的含义不同: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL后面没有`/`</span><br><span class="line"># proxy_pass相对路径, 将会代理到(http://127.0.0.1:8080/api/**)</span><br><span class="line"></span><br><span class="line">location /api &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080  # 结尾没有/, 表示相对路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL后面有`/`</span><br><span class="line"># 将会跳转到(http://127.0.0.1:8080/**), 没有&quot;/api&quot;</span><br><span class="line"></span><br><span class="line">location /api &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080/ # 结尾有/, 表示绝对路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="location-allow-deny"><a href="#location-allow-deny" class="headerlink" title="location/allow,deny"></a>location/allow,deny</h2><p>allow,deny 是 ngx_http_access_module 模块提供的,<br>一般用在 <code>location</code>下, 允许/拒绝某些客户端访问location, 示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow 192.168.1.0/24</span><br><span class="line">deny all;</span><br></pre></td></tr></table></figure></p><p>子网掩码的表示,  使用CIDR ( 参考 [[../22.Network-Protocol/网络协议-IP]] ) 表示法: </p><ul><li><code>/24</code>: 255.255.255.0</li><li><code>/16</code>: 255.255.0.0</li><li><code>/8</code>: 255.0.0.0</li></ul><p>deny 和 <code>return 403</code>的区别:<br><a href="https://stackoverflow.com/questions/38231423/nginx-difference-between-deny-all-and-return-403" target="_blank" rel="noopener">webserver - Nginx: Difference between deny all; and return 403; - Stack Overflow</a></p><h2 id="server-rewrite"><a href="#server-rewrite" class="headerlink" title="server/rewrite"></a>server/rewrite</h2><p>rewrite用来更改location, 实现跳转到其他location.<br>rewrite只能放在<code>server{}</code>,<code>location{}</code>,<code>if{}</code>中, 语法为<code>rewrite regex replacement [flag];</code>, 例如:</p><ul><li><code>rewrite ^/help(.*) /static/help$1 last;</code></li><li><code>rewrite (.*) http://a.changyan.com$1 last;</code></li></ul><h3 id="rewrite的flag标记"><a href="#rewrite的flag标记" class="headerlink" title="rewrite的flag标记"></a>rewrite的flag标记</h3><ul><li>last : rewrite之后, 跳出当前location, 并重新走一遍当前server的流程, 浏览器地址栏看起来仍是rewrite之前的URL;</li><li>break : 请求在这个location终结, 不再重新走server;</li><li>redirect : 返回302临时重定向, 浏览器地址栏会显示跳转后的地址;</li><li>permanent : 返回301永久重定向, 浏览器地址栏会显示跳转后的地址;</li></ul><p>如果rewrite在location之外, last和break不会有任何区别, 都会跳过后面的rewrite直接进入location:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^/AAA/.*  /BBB/$1  last; // 如果命中^AAA规则, 直接进入location, 下面的所有rewrite被跳过;</span><br><span class="line">    rewrite ^/XXX/.*  /ZZZ/$1  last;</span><br><span class="line">    location ~ /BBB &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="server-upstream"><a href="#server-upstream" class="headerlink" title="server/upstream"></a>server/upstream</h2><p>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_pass http://webapp</span><br><span class="line">...</span><br><span class="line">upstream webapp &#123;</span><br><span class="line">    // [均衡方式]</span><br><span class="line">    server 192.168.1.9:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="负载均衡方式"><a href="#负载均衡方式" class="headerlink" title="负载均衡方式"></a>负载均衡方式</h4><ul><li>轮询(默认):</li><li>带weight的轮询: 访问后端比例和weight成正比, 用于解决后端服务器性能不均衡</li><li>ip_hash: 来访ip hash, 用于解决session问题</li><li>url_hash: 后端服务器为缓存时</li></ul><p>参考 <a href="/31.Backend/SystemDesign-负载均衡-Nginx/" title="SystemDesign-负载均衡-Nginx">SystemDesign-负载均衡-Nginx</a></p><h2 id="log-access-error"><a href="#log-access-error" class="headerlink" title="log(access,error)"></a>log(access,error)</h2><p>log 由 <code>ngx_http_log_module</code> 模块支持. </p><p>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># log_format 可以在任何位置定义?</span><br><span class="line">log_format  myLog  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; $host $request_time&apos;;</span><br><span class="line">                      </span><br><span class="line"># 可以出现在 http，server，location，limit_except 作用域</span><br><span class="line">access_log   /opt/logs/nginx/access.log  myLog; ## 使用上面定义的format</span><br><span class="line"></span><br><span class="line"># 可以出现在 main， http, mail, stream, server, location 作用域</span><br><span class="line">error_log   /opt/logs/nginx/error.log notice;</span><br></pre></td></tr></table></figure></p><p>➤ access_log</p><p>格式: <code>access_log path [format]</code></p><ul><li>path 指定日志的存放位置。</li><li>format 指定日志的格式。格式可以用<code>log_format</code>自定义, 也可以不写, 不写则使用默认使用预定义的”combined”。</li></ul><p>access_log作用域:<br>access_log指令的作用域分别有http，server，location，limit_except。也就是说，在这几个作用域外使用该指令，Nginx会报错。</p><p>➤ error_log</p><p>格式: <code>error_log path [level]</code></p><ul><li>level: debug, info, notice, warn, error, crit, alert,emerg中的任意值</li></ul><p>error_log作用域: main, http, mail, stream, server, location</p><p>@ref: <a href="https://segmentfault.com/a/1190000013377493" target="_blank" rel="noopener">Nginx日志配置详解 - SegmentFault 思否</a></p><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p>include 其他配置文件: <code>include cache.conf;</code></p><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>Nginx模块一般分为三大类: filter, upstream, handler @todo</p><h2 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h2><ul><li>if判断字符串(注意是<code>=</code> 而不是<code>==</code>):<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($arg_client_id = &quot;cxsh9byIb&quot;) &#123;</span><br><span class="line">    return 200 &apos;:)&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Nginx返回502-503-504"><a href="#Nginx返回502-503-504" class="headerlink" title="Nginx返回502, 503, 504"></a>Nginx返回502, 503, 504</h1><p><strong>502: Bad Gateway</strong><br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。可能的原因：</p><ul><li>高并发, 后端服务线程池耗尽[?]</li><li>后端服务(php-fpm/tomcat..)shutdown</li><li>后端程序执行太久，后端服务终止了此次请求的Worker进程，Nginx发现自己与后端服务断开</li></ul><p><strong>503: Service Unavailable</strong><br>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。可能的原因：</p><ul><li>后端服务器当前因为过载无法处理请求，主动拒绝响应，比较少见到</li></ul><p><strong>504: Gateway Timeoua</strong><br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从后端服务器或者辅助服务器（例如DNS）收到响应。可能的原因：</p><ul><li>nginx发起请求，在最大等待时间内没有收到返回</li><li>nginx的timeout是否设置的太短</li><li>查询DNS超时也会504</li></ul><blockquote><p>参考 <a href="https://juejin.im/entry/589148f92f301e00690e863d" target="_blank" rel="noopener">http 502 和 504 的区别 - 后端 - 掘金</a> @ref</p></blockquote><h1 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h1><p>施工中…</p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 反向代理 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-Kafka</title>
      <link href="/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka/"/>
      <url>/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka/</url>
      
        <content type="html"><![CDATA[<p><img src="https://kafka.apache.org/images/logo.png" alt=""></p><h2 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h2><p><img src="/images/kafka/kafka_cluster.png" alt=""></p><p>Kafka存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</p><p>Kafka高效地处理实时流式数据，可以实现与Storm、HBase和Spark的集成。作为群集部署到多台服务器上，Kafka处理它所有的发布和订阅消息系统使用了四个API，即生产者API、消费者API、Stream API和Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如JMS、AMQP等。</p><p>Kafka架构的主要术语包括Topic、Record 和 Broker。Topic 由Record组成，Record持有不同的信息，而Broker则负责复制消息。Kafka有四个主要API：</p><ul><li>生产者API：支持应用程序发布Record流。</li><li>消费者API：支持应用程序订阅Topic和处理Record流。</li><li>Stream API：将输入流转换为输出流，并产生结果。</li><li>Connector API：执行可重用的生产者和消费者API，可将Topic链接到现有应用程序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端技术 </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 流式计算 </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-Kafka-选举机制</title>
      <link href="/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka-%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka-%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Kafka的”选举”包括: Kafka Controller的选举, Partition Leader的选举, Consumer Group Coordinator(消费组协调者)的选举;</p><h2 id="➤-Controller的选举"><a href="#➤-Controller的选举" class="headerlink" title="➤ Controller的选举"></a>➤ Controller的选举</h2><ul><li>Controller的作用: 运行 Partition的节点叫 Broker, 其中一个Broker将会被选为Controller, 它负责整个集群中所有分区和副本的管理工作, 其主要职责有: Partition leader的选举, ISR的维护等;</li><li>选举触发: Controller(Leader角色)在zk上创建临时节点, 当Leader宕机, 这个临时节点因为心跳检测失败而被删除, 同时zk将消息发送给所有Broker;</li><li>选举过程: 收到消息的Broker在zk上创建<code>/controller</code>临时节点, 利用zk的强一致性, 只有一个 Broker能创建成功, 这个节点成为新的Controller;</li></ul><h2 id="➤-Partition-leader的选举"><a href="#➤-Partition-leader的选举" class="headerlink" title="➤ Partition leader的选举"></a>➤ Partition leader的选举</h2><ul><li>Partition leader的作用: 每个 Partition都有数个副本(replica), 但消息的读写都是在 Leader Partition上完成的, 然后批量同步到副本;</li><li>选举触发: 当有Broker宕机, 这个Broker在zk上的临时节点(znode)也会被删除, zk会通知正在watch的 Controller进行处理;</li><li>选举过程: Controller接到通知后, 先选出 set_p(该集合包括了宕机的Broker上包含的所有 Partition), 然后Controller从zk读取 set_p中每一个分区的 ISR, 然后从ISR中选出一个副本作为该Partition的新 Leader, 然后将{新Leader/leader_epoch/controller_epoch} 写入 <code>/brokers/topics/[topic]/partitions/[partition]/state</code> // epoch是需要记录进选举结果的, 任期(term)的概念;</li><li>为什么不采用少数服从多数(majority)的选举? (少数服从多数, 类似 Redis Sentinel Leader的选举, 不少于quorum且选票高于一半). Kafka的分区选举, 使用的是 “从ISR中选举”, 而 ISR的可以最多容忍总数“f+1个节点有f个失败”,也即至少有1个在ISR即可. 可以看出, majority的方式(总数2f+1个, 最大容忍f个失败)需要更高的冗余度, 例如能容忍2台机器宕机, 那么majority方式至少需要5台机器. 另外, majority的方式也要求更多的replica “能跟上Partition Leader的写入进度”, 吞吐量也会下降(详见消息的commit机制).</li></ul><h2 id="➤-Consumer-Group-Coordinator的选举"><a href="#➤-Consumer-Group-Coordinator的选举" class="headerlink" title="➤ Consumer Group Coordinator的选举"></a>➤ Consumer Group Coordinator的选举</h2><ul><li>Coordinator的职责: 负责所在的 Consumer Group 的 Rebalance</li><li>选举过程: @todo</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5cdec305f265da1b7c60e71c" target="_blank" rel="noopener">Kafka科普系列 | 原来Kafka中的选举有这么多？ - 掘金</a></li><li><a href="https://www.maiyewang.com/archives/30873" target="_blank" rel="noopener">kafka：leader选举（broker /分区） – Programming language</a></li><li><a href="https://blog.csdn.net/yanshu2012/article/details/54894629" target="_blank" rel="noopener">kafka leader选举机制原理_RangeYan-CSDN博客_kafka选主</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-Kafka-特性实现</title>
      <link href="/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka-%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0/"/>
      <url>/31.Backend/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka-%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>Kafka高吞吐量的实现?</li><li>消息顺序性如何保证?</li><li>Consumer Group如何防止重复消费?</li><li>Partition多副本选举机制的实现?</li></ul><p>➤ Kafka特性解析:</p><blockquote><p>每个 partition 存于不同的 broker 机器上，一个partition可以有副本存在于多个 broker;<br>每个partition都有一个唯一的leader， 其他的 partition 作为folower, 所有的读写操作都在leader上完成， follower定期从 leader partition 同步数据;<br>每个partition的leader和follower都与zk建立长连接, 如果 leader partition 挂掉, 从 follower上选举出新的 leader;</p></blockquote><ul><li><strong>吞吐量</strong>: 因为每条消息都被append到该partition中，是顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）。</li><li><strong>水平扩展</strong>: 每一条消息被发送到broker时，会根据paritition规则选择被存储到哪一个 partition。如果 partition规则设置的合理，所有消息可以均匀分布到不同的partition里，这样就实现了水平扩展。</li><li><strong>顺序性</strong>: 在发送一条消息时，还可以指定这条消息的key，producer根据这个key和partition机制来判断将这条消息发送到哪个parition。业务上, 多条相关的有顺序的消息, 可以指定同一个Key, 就可以保证都发送到同一个partition并有序;</li><li><strong>删除策略</strong>: 对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略去删除旧数据。一是基于时间(固定时间点清理)，二是基于partition文件大小</li><li><strong>Consumer Group概念</strong>:<ul><li>一个Consumer Group 可以订阅多个Topic</li><li>一个Consumer Group 有唯一的 GroupID, 可以包含多个 Consumer 实例, Topic下某条消息只能给这个Consumer Group其中一个Consumer实例消费( 某 Topic下的一条消息,只能被某个 Consumer Group 消费一次, 但可以被多个 Consumer Group 消费)</li></ul></li><li><strong>Consumer Group防重复消费</strong>:<ul><li>Consumer Group 中一个实例只能消费某Topic下面的一个分区 (当然其他 Group也可以消费这个分区), 所以记录下这个Group对于某个Topic的某个Partition的消费offset即可, offset的存储是在Zk的节点下 <code>/consumers/&lt;group.id&gt;/offsets/&lt;topic&gt;/&lt;partitionId&gt;</code>;</li><li>offset的提交: 在旧版本kfk中, 每个Consumer Group的 offset数据是提交到 Zookeeper的, 但是zk并不适合大量写入操作, 所以kafka提供了另一种方案: 额外创建一个叫<code>__consumer_offsets</code>的Topic, 将offset写入这个Topic, 摆脱对Zk的依赖. 由于这个Topic使用了 Compact策略, 该Topic保存的总是最新的offset, 存储格式是顺序的: <code>| GroupId1:Parttion1:offset | GroupId1:Parttion2:offset | ... |</code></li></ul></li><li><strong>Rebalance</strong>:<ul><li>什么是Rebalance? 例如 Consumer Group A下有 20个消费者, 它订阅了一个有 100个分区的 Topic, 每个消费者分配一部分分区, 当这个 Consumer Group中新增或删除了消费者, 就需要给现有的消费者重新分配分区, 这个过程叫做 Rebalance</li><li>consumer rebalance算法  @ref: ![[../_attachments/Kafka- a Distributed Messaging System for Log Processing.pdf]]</li></ul></li></ul><p><img src="/images/kafka/Kafka-Consumer-Rebalance.png" alt=""></p><p>➤ Kafka高可用实现:</p><ul><li><strong>HA:partition多副本同步机制</strong>:<ul><li>方式1: 同步复制, leader要保证所有follower都写入后, 才把这条消息确认为commit, 影响吞吐</li><li>方式2: 异步复制, 只需要leader写入完成, 消息就算commit了. 如果leader partition宕机, 可能丢失一部分数据</li><li>kafka的多副本同步机制不同于1和2, Kafka在Zookeeper中动态维护了一个ISR（in-sync replicas）列表, 一条消息只有被 in sync列表里所有follower都同步了, 这条消息才算commit.落后太多的follower从ISR列表剔除</li></ul></li><li><strong>HA:partition选举机制</strong>: <ul><li>只有 in sync 列表里的成员才有被选举为leader的可能。在这种模式下，对于f+1个replica，一个Kafka topic能在保证不丢失已经commit的消息的前提下容忍f个replica的失败。ISR可以看成是吞吐量和冗余度的一个平衡.</li><li>分区选举机制见: <a href="/31.Backend/消息队列-Kafka-选举机制/" title="消息队列-Kafka-选举机制">消息队列-Kafka-选举机制</a></li></ul></li></ul><p>@ref <a href="https://www.cnblogs.com/huxi2b/p/6223228.html" target="_blank" rel="noopener">Kafka消费组(consumer group) - huxihx - 博客园</a><br>@ref <a href="https://blog.csdn.net/allthesametome/article/details/47362451" target="_blank" rel="noopener">各消息队列对比，Kafka深度解析，众人推荐，精彩好文！<em>大数据</em>一切依旧的专栏-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>容器编排-K8s</title>
      <link href="/31.Backend/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92-K8s/"/>
      <url>/31.Backend/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92-K8s/</url>
      
        <content type="html"><![CDATA[<p>➤ 什么是Kubernetes:</p><p>Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。<br>使用Kubernetes可以：</p><ul><li>自动化容器的部署和复制</li><li>随时扩展或收缩容器规模</li><li>将容器组织成组，并且提供容器间的负载均衡</li><li>很容易地升级应用程序容器的新版本</li><li>提供容器弹性，如果容器失效就替换它，等等..</li></ul><h1 id="K8s架构"><a href="#K8s架构" class="headerlink" title="K8s架构"></a>K8s架构</h1><p><img src="/images/k8s-cluster.png" alt="k8s-cluster"></p><p>上图可以看到如下组件，使用特别的图标表示Service和Label：</p><ul><li>Kubernetes Master（Kubernetes主节点）</li><li>Replication Controller（复制控制器）</li><li>Node（节点）</li><li>Label: 标签🏷</li><li>Service: 服务, 图中红色Service指向带有相同 Label的 Pod</li></ul><p>➤ Kubernetes Master:<br>组件包括: Kubernetes API Server/ Replication Controller 等..</p><p>➤ Node:<br>节点（上图橘色方框）是物理或者虚拟机器，作为 Kubernetes worker，通常称为 Minion。每个节点都运行如下 Kubernetes关键组件：</p><ul><li>Kubelet：是主节点代理, 每个Node运行一个, 作为 Node和 Kubernetes master之间的代理</li><li>Kube-proxy：Service使用其将链接路由到Pod</li><li>Container: Docker 或 Rocket, Kubernetes使用的容器技术来创建容器</li></ul><p>➤ Lable:<br>Label是attach到Pod的一对键/值对，用来传递用户定义的属性。例如通过Label（tier=frontend, app=myapp）来标记前端Pod容器,<br>在deployment描述文件中, 使用<code>Selector:  tier=frontend, app=myapp</code> 指定用哪些Pods</p><p>➤ Service:<br>Service是将一组Pod公开为网络服务的抽象, Kubernetes 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡。<br>当访问一个Service时，通过 Node上运行的代理（kube-proxy），对 Pod进行负载均衡</p><p>➤ Pod:<br>Pod（上图绿色方框）安排在节点上, 一个Pod内可以包含多个容器和卷, 这些容器共享网络地址和文件系统;<br>Kubernetes 提供了几种资源来管理众多的Pods:</p><ul><li>Deployment 和 ReplicaSet （替换原来的资源 ReplicationController）。 Deployment 很适合用来管理你的集群上的<em>无状态应用</em></li><li>StatefulSet 让你能够运行一个或者多个以某种方式跟踪应用状态的 Pods。 例如，如果你的负载会将数据作持久存储，你可以运行一个 StatefulSet，将每个 Pod 与某个 PersistentVolume 对应起来</li><li>DaemonSet 定义提供节点本地支撑设施的 Pods, 例如作为网络链接的辅助工具或者作为网络 插件 的一部分等等。每次你向集群中添加一个新节点时，如果该节点与某 DaemonSet 的规约匹配，则控制面会为该 DaemonSet 调度一个 Pod 到该新节点上运行。</li><li>Job 和 CronJob。 定义一些一直运行到结束并停止的任务。Job 用来表达的是一次性的任务，而 CronJob 会根据其时间规划反复运行。</li></ul><h1 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h1><p>@ref: <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments | Kubernetes</a></p><h1 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h1><p>@ref: <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSet | Kubernetes</a></p><h1 id="StatefulSets"><a href="#StatefulSets" class="headerlink" title="StatefulSets"></a>StatefulSets</h1><p>@ref: <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">StatefulSets | Kubernetes</a></p><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>@ref: <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener">服务 | Kubernetes</a></p><h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>@ref: <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Ingress | Kubernetes</a></p><h1 id="K8s命令"><a href="#K8s命令" class="headerlink" title="K8s命令"></a>K8s命令</h1><p>➤ K8s命令模式: <code>kubectl [command] [TYPE] [NAME] [flags]</code></p><ul><li>command: for example <code>create</code>, <code>get</code>, <code>describe</code>, <code>delete</code></li><li>TYPE: 描述 resource type, for example <code>pod</code>, <code>pods</code>, <code>app</code>, <code>service</code>, resource type不区分大小写/复数单数/缩写形式</li><li>NAME: 描述 resource name, for example <code>kubectl get pod example-pod1 example-pod2</code></li><li>flags: 描述 optional flags, for example <code>-s</code>, <code>--server</code></li></ul><blockquote><p>kubectrl 操作的常用 Resource type, 及缩写形式:</p><ul><li>cm: configMaps  </li><li>ns: namespaces  </li><li>po: pods  </li><li>rs: replicaSets  </li><li>svc: services  </li><li>sts: statefulSets  </li><li>ing: ingresses  </li><li>deploy: deployments<br>@ref: <a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">kubectl 概述 资源类型</a>  </li></ul></blockquote><p>➤ 常用命令:</p><ul><li>列出资源:<ul><li><code>kubectl get pods -o wide</code>: 列出全部Pods</li><li><code>kubectl get pods -l app=nginx</code>: 列出具有某label的Pods</li><li><code>kubectl get rc,service</code>:  列出全部 rc(replicationControllers) &amp; service</li><li><code>kubectl get sts</code>: 列出所有stateful</li></ul></li><li>获取资源描述:<ul><li><code>kubectl describe nodes</code>: 显示所有Node的详细信息</li><li><code>kubectl describe pods</code>:  显示所有Pod的详细信息</li><li><code>kubectl describe pod ${podname}</code>:  显示某个Pod的详细信息</li></ul></li><li>编辑资源:<ul><li><code>kubectl delete pod ${podname}</code>: 删除后自动重启pod</li><li><code>kubectl edit sts ${stsname}</code>:  // edit后不会回写yaml文件</li><li><code>kubectl edit app ${appname}</code>:</li></ul></li><li>发布:<ul><li>kubectl apply -f deployment.yaml</li><li>kubectl apply -f deployment-update.yaml // 执行后会应用新的yaml配置</li></ul></li><li>对Pod中的容器执行命令:<ul><li><code>kubectl exec -it ${podname} bash</code></li></ul></li></ul><h1 id="K8s-amp-Docker"><a href="#K8s-amp-Docker" class="headerlink" title="K8s &amp; Docker"></a>K8s &amp; Docker</h1><p>@ref: <a href="https://www.zhihu.com/column/p/337280265" target="_blank" rel="noopener">容器技术之容器引擎与江湖门派 - 知乎</a></p><p>容器管理系统分为三层：</p><ol><li>High-level Container Management：容器管控的UI层。直接实现容器的管控和使用界面，也是用户最熟悉的子系统。</li><li>High-level Container Runtime：容器状态及资源供给。包括镜像管理、网络接入、容器状态、调用Low Level Runtime执行容器等功能。习惯上这层称之为容器引擎（Container Engine）。</li><li>Low-level Container Runtime：容器执行层。负责具体构建容器运行环境并执行容器进程。习惯上这层直接简称为容器运行时（Container Runtime）。</li></ol><p>High-level Container Management和Container Engine之间的接口规范是CRI，Container Engine和Container Runtime之间的接口规范是OCI。支持CRI接口的容器引擎主要有docker、rkt、pouch、containerd和cri-o等<br><img src="/images/container-level.png" alt="container-level"></p><p>@ref: <a href="https://www.infoq.cn/article/7ZHDVX6RoDl9tYMhQkSH" target="_blank" rel="noopener">为什么 Kubernetes 要替换 Docker-InfoQ</a></p><blockquote><p>Kubernetes 引入容器运行时接口（Container Runtime Interface、CRI）隔离不同容器运行时的实现机制，容器编排系统不应该依赖于某个具体的运行时实现；<br>Docker 没有支持也不打算支持 Kubernetes 的 CRI 接口，需要 Kubernetes 社区在仓库中维护 Dockershim；</p></blockquote><h1 id="Deployment-yaml文件解析"><a href="#Deployment-yaml文件解析" class="headerlink" title="Deployment.yaml文件解析"></a>Deployment.yaml文件解析</h1><p><img src="/images/k8s-deployment-yaml.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>容器化-Docker-02容器隔离实现原理</title>
      <link href="/31.Backend/%E5%AE%B9%E5%99%A8%E5%8C%96-Docker-02%E5%AE%B9%E5%99%A8%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/31.Backend/%E5%AE%B9%E5%99%A8%E5%8C%96-Docker-02%E5%AE%B9%E5%99%A8%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器隔离的实现原理"><a href="#Docker容器隔离的实现原理" class="headerlink" title="Docker容器隔离的实现原理"></a>Docker容器隔离的实现原理</h1><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>先认识Linux 提供的Namespace机制: Linux的 Namespace 提供了7种不同的命名空间:</p><ul><li>PID namespace: 隔离进程ID,每个容器有自己的pid命名空间</li><li>UTS namespace: 隔离主机名 &amp; 域名, ….有自己的主机名和NIS域名</li><li>IPC namespace: 隔离进程间通信, 相同IPC Ns的进程之间才可以使用(共享内存/信号量/消息队列)通讯</li><li>MNT namespace: 隔离文件系统挂载点</li><li>…</li></ul><p>Docker 如何实现进程隔离 (宿主机进程 &amp; 容器内进程的隔离) ?</p><ul><li>调用<code>clone</code>创建进程时传入 <code>CLONE_NEWPID</code>, 这样创建出的进程PID和宿主机是隔离的</li><li>下图中, docker containterd 进程就是在clone时指定<code>CLONE_NEWPID</code>创建的, 所以其子进程和宿主机是隔离的: </li></ul><p><img src="/images/docker-container-process.png" alt="docker-container-process"></p><blockquote><p>Linux 两个重要进程: pid=1的init(使用命令<code>ps -p 1</code>可以看到) &amp; pid=2的 kthreadd进程, 前者用于执行一部分内核的初始化和系统配置, 后者负责管理和调度其他内核进程;</p></blockquote><ul><li>Docker 的挂载点隔离的实现:<ul><li>一个容器需要一个rootfs才可以正常启动 (rootfs, 包括/proc, /dev等等..)</li><li>调用<code>clone</code>创建进程时传入 <code>CLONE_NEWNS</code>, 这样子进程就能得到父进程挂载点的拷贝, 如果不传入<code>CLONE_NEWNS</code>这个参数, 子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统</li></ul></li></ul><ul><li>Docker 的网络隔离的实现:<ul><li>Docker 提供了四种网络模式(Host、Container、None 和 Bridge)</li><li>如果是网桥模式, 除了分配网络的Namespace, 还会给容器分配虚拟网卡, 在宿主机安装虚拟网桥, 虚拟网卡和网桥通过iptables连接;</li><li>例如<code>docker run -d -p 6379:6379 redis</code>启动一个容器, 查看 iptables 的 NAT 配置就会看到在 DOCKER 的链中出现了一条新的规则</li></ul></li></ul><p>以上, Docker通过Linux 提供的 Namespace为新创建的进程隔离了 进程ID/网络/文件系统…</p><p>@ref: </p><ul><li>Clone()函数: [[../21.Operating-System/Linux.31.Posix接口#clone]]</li><li>Namespace: [[../21.Operating-System/Linux.31.Posix接口#Namespace]]</li></ul><h2 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h2><ul><li><p>Docker 对容器的资源使用限额(CPU/RAM..)是通过 Controll Group (简称 CGroup)实现的:</p><ul><li>创建一个CGroup 并指定其(CPU/RAM等)限额, 实现不同CGroup 之间资源隔离</li><li>进程可以随时加入一个CGroup or 退出</li><li><p>查看当前系统中的CGroup: <code>lssubsys -m</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lssubsys -m</span><br><span class="line">cpuset /sys/fs/cgroup/cpuset</span><br><span class="line">cpu /sys/fs/cgroup/cpu</span><br><span class="line">cpuacct /sys/fs/cgroup/cpuacct</span><br><span class="line">memory /sys/fs/cgroup/memory</span><br></pre></td></tr></table></figure></li><li><p>继续查看 /sys/fs/cgroup/cpu/目录, 下面有个名为docker的文件夹, 再向下层是docker container id命名的目录 </p></li><li>创建一个Docker容器并指定配额: <code>docker run -it -d --cpu-quota=50000 image_tag</code></li></ul></li></ul><p><img src="/images/docker-cgroup.png" alt="docker-cgroup"></p><h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>综上所述, Namespace解决了…, CGroup解决了… , 还有一个文件系统的隔离问题, 是通过UnionFS实现的 (是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务)</p><ul><li>Dockerfile里每一个命令都会创建一个只读层, 当使用<code>docker run</code>命令启动一个容器时, 会在镜像最上层添加一个可写的层(也就是容器层), 容器运行时对容器的修改都是对这个层的修改; </li><li>docker镜像的每一个层, 都对应宿主机/var/lib/docker/ 下面的一个目录</li><li>通过AUFS(Advanced UnionFS) , 把多个文件目录”联合”到同一个挂载点;</li><li>除了AUFS之外, Docker 还支持aufs、devicemapper、overlay2、zfs 和 vfs 等等不同驱动</li><li>通过这种层(layer)    的设计, 不同tag的docker镜像, 可以公用同一个层, 减少了镜像的磁盘占用</li></ul><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Docker 的隔离技术实现的基础: Namespace/CGroup/UnionFS</p><p><img src="/images/docker-fs-layer.png" alt="../_images/docker-fs-layer"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>@ref: </p><ul><li><a href="https://draveness.me/docker/" target="_blank" rel="noopener">Docker 核心技术与实现原理 - 面向信仰编程</a></li></ul><h1 id="Docker运行性能分析"><a href="#Docker运行性能分析" class="headerlink" title="Docker运行性能分析"></a>Docker运行性能分析</h1><ul><li>与虚拟机技术不同, Docker使用Ns和CGroup实现隔离和资源配额控制, 不需要用额外的性能消耗运行vm</li><li>Docker启动的进程和宿主机共享一个内核.</li><li>对Docker容器内进程的优化(内核参数优化), 也可以在容器内执行<code>sysctl</code>命令更改, 或者在Docker启动时: <code>docker run --sysctl key=value IMAGE:TAG CMD</code></li><li>Docker有一个白名单, 定义哪些sysctl参数可以在<code>docker run</code>时更改, 不在白名单内的参数, 在docker容器内<code>sysctl -a</code>也看不到</li><li>有些参数可以在容器内使用sysctl更改(如kernel.pid_max), 但是容器内更改后会影响到主机, 原因是这类参数没有Namespace隔离(大部分kernel开头的), docker和宿主机共享内核. 这类参数也不建议通过容器更改</li><li>所以针对docker的内核类优化:<ul><li>最好是在宿主机内修改, 然后作用于docker进程;</li><li>如果需要针对docker修改, 可以通过<code>docker run</code>传入参数, 并注意这些参数会不会影响到宿主机</li></ul></li></ul><p>@ref: </p><ul><li>[[../21.Operating-System/Linux.04.Sysctl]]</li><li><a href="https://zhuanlan.zhihu.com/p/82488569" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82488569</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/31.Backend/%E5%AE%B9%E5%99%A8%E5%8C%96-Docker-01%E5%9F%BA%E7%A1%80/"/>
      <url>/31.Backend/%E5%AE%B9%E5%99%A8%E5%8C%96-Docker-01%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/2000px-Docker_%28container_engine%29_logo.svg.png" alt="Docker"></p><h1 id="安装-amp-启动"><a href="#安装-amp-启动" class="headerlink" title="安装 &amp; 启动"></a>安装 &amp; 启动</h1><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure></li><li><p>装完之后需要在 /etc/docker/daemon.json 修改image注册地址 &amp; 存储目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;insecure-registries&quot; : [&quot;registry.xxx.com&quot;]</span><br><span class="line">  &quot;graph&quot;: &quot;/data0/docker&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后启动 dockerd:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker命令参考"><a href="#Docker命令参考" class="headerlink" title="Docker命令参考"></a>Docker命令参考</h1><h2 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h2><ul><li>容器生命周期管理 — docker [run|start|stop|restart|kill|rm|pause|unpause]</li><li>容器操作运维 — docker [ps|inspect|top|attach|events|logs|wait|export|port]</li><li>容器rootfs命令 — docker [commit|cp|diff]</li><li>镜像仓库 — docker [login|pull|push|search]</li><li>本地镜像管理 — docker [images|rmi|tag|build|history|save|import]</li><li>其他命令 — docker [info|version]</li></ul><p>参考: <a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker 命令大全</a> @ref</p><h2 id="pull镜像"><a href="#pull镜像" class="headerlink" title="pull镜像"></a>pull镜像</h2><p>获取镜像: <code>docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</code></p><blockquote><p>可能需要先执行 <code>docker login</code></p></blockquote><h2 id="管理本地镜像"><a href="#管理本地镜像" class="headerlink" title="管理本地镜像"></a>管理本地镜像</h2><ul><li>列出已经下载下来的镜像: <code>docker images -a</code> # 列表包含了仓库名(REPOSITORY)、标签(TAG)、镜像ID(IMAGE ID)、创建时间以及所占用的空间<ul><li>无标签的镜像很多都是”中间层镜像”</li><li>根据仓库名列出镜像: <code>docker images 仓库名</code></li></ul></li><li>删除镜像: <code>docker rmi 仓库:Tag</code></li></ul><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><ul><li><code>docker run --name webserver -d -p 80:80 repoName:tag</code> # 启动镜像<ul><li>-p host_port:container_port // 端口映射</li><li>-v host_path:container_path // 绑定主机目录到…</li><li>-d: 容器在后台运行, 并不立即进入容器终端</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用</li></ul></li></ul><p>示例:</p><ul><li><code>docker run -d repoName:tag</code>: 后台启动容器(执行后不立刻进入容器)</li><li><code>docker run -it repoName:tag /bin/bash</code>: 交互模式启动容器</li></ul><h2 id="登录-退出容器"><a href="#登录-退出容器" class="headerlink" title="登录/退出容器"></a>登录/退出容器</h2><ul><li><code>docker exec -it 容器ID /bin/bash</code> : 进入镜像的bash命令行, <code>-i</code>保持STDIN 打开, <code>-t</code>分配一个伪终端</li><li><code>docker attach 容器ID</code>: 如果<code>docker run -d</code>在后台运行的镜像, 需要这样连接上容器</li><li><code>exit</code> 退出容器</li></ul><h2 id="镜像修改和提交"><a href="#镜像修改和提交" class="headerlink" title="镜像修改和提交"></a>镜像修改和提交</h2><p><code>docker attach</code> or <code>docker exec -it</code> 进入容器后, 可以对正在运行的镜像进行修改,</p><ul><li><code>docker cp /Users/xx/xxx/ 容器ID:/tmp</code> : 本地文件拷贝到docker 容器内</li></ul><p>然后 <code>exit</code> 退出 ..</p><ul><li><code>docker diff</code> # 显示对 docker 镜像做了哪些修改</li><li><code>docker commit --author &quot;xx&quot; --message &quot;xxx&quot; 容器ID 仓库名:TAG</code> # 提交对容器的修改到镜像</li><li><code>docker history 仓库名:TAG</code> # 列出改动历史</li><li><code>docker push 仓库名:TAG</code>   # 上传</li></ul><h2 id="管理容器"><a href="#管理容器" class="headerlink" title="管理容器"></a>管理容器</h2><p>运行镜像之后:</p><ul><li><code>docker ps -a</code>: 列出容器(不是镜像!)<ul><li>列出正在运行的 容器ID(CONTAINER ID), 镜像(IMAGE), 状态(STATUS)</li></ul></li><li><code>docker top 容器ID</code> : 显示一个运行的容器里面的进程信息</li><li><code>docker stop 容器ID</code> : 停止容器, 先发送SIGTERM, 再发送SIGKILL, docker内的应用程序可以接收到SIGTERM做处理</li><li><code>docker kill 容器ID</code> : 直接发送SIGKILL</li><li><code>docker restart 容器ID</code> : 重启</li><li><code>docker rm 容器ID</code>: 删除容器, 如果加了<code>-f</code>参数则是直接发送SIGKILL</li></ul><h2 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h2><ul><li><code>docker logs -f 容器ID</code>: 查看log, 类似tailf</li><li><code>docker logs --since 30m CONTAINER_ID</code> : 查看近30分钟的日志</li></ul><h1 id="创建镜像-amp-编译镜像"><a href="#创建镜像-amp-编译镜像" class="headerlink" title="创建镜像 &amp; 编译镜像"></a>创建镜像 &amp; 编译镜像</h1><ul><li>准备Dockerfile</li><li>执行: <code>docker build --build-arg xArg1=$ARG1 -t &lt;image_name&gt;:&lt;tag&gt; .</code><ul><li><code>--build-arg xArg1=$ARG1</code>: 把外界参数传入Dockerfile, 在Dockerfile里可以<code>$xArg1</code>取到</li><li><code>-t &lt;image_name&gt;:&lt;tag&gt;</code>: 设置tag</li></ul></li></ul><h2 id="Dockerfile-说明"><a href="#Dockerfile-说明" class="headerlink" title="Dockerfile 说明"></a>Dockerfile 说明</h2><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM xxx.com/REPOSITORY:latest</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /data/remotedump-controller</span><br><span class="line"></span><br><span class="line">COPY remotedump-controller/* /data/remotedump-controller</span><br><span class="line"></span><br><span class="line"># 创建两个ARG变量, 只在dockerfile内有效</span><br><span class="line">ARG Arg1</span><br><span class="line">ARG Arg2</span><br><span class="line"></span><br><span class="line"># ENV创建的变量可以在docker运行环境使用</span><br><span class="line">ENV Arg1=$Arg1</span><br><span class="line">ENV Arg2=$Arg2</span><br><span class="line"></span><br><span class="line">COPY remotedump-controller/start.sh /etc/kickStart.d/</span><br><span class="line">RUN chmod +x /etc/kickStart.d/start.sh</span><br><span class="line"></span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure><blockquote><p>参考: <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a>:</p></blockquote><ul><li>Dockerfile 中每一个指令都会建立一层, 新建立一层, 在其上执行这些命令, 执行结束后, commit 这一层的修改, 构成新的镜像.<ul><li>Union FS 是有最大层数限制的, 比如 AUFS, 曾经是最大不得超过 42 层, 现在是不得超过 127 层.</li></ul></li><li>RUN: 后面跟shell命令, 在镜像里执行</li><li>WORKDIR 指定工作目录, 对后面的RUN都有效</li><li>ARG: 指令是定义参数名称, 以及定义其默认值.该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</li><li>ENV: <code>ENV Arg2=$Arg2</code>, 在运行时容器中就可以使用<code>$Arg2</code>这个环境变量了. 用ENV赋值之前, 必须要用ARG声明变量<code>ARG Arg2</code></li><li>COPY: <code>COPY ./package.json /app/</code> # 拷贝资源</li><li>ADD 类似COPY, 但ADD源地址可以是URL</li><li>EXPOSE: <code>EXPOSE 3306</code> 声明镜像的3306端口要暴露给外面, 仅仅是声明, 真正映射还是在<code>docker run -p 宿主端口:容器端口</code></li><li>CMD:<ul><li><code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</code> : 执行sh, 执行完后sh会退出, 容器也退出了</li><li><code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code> : CMD的可执行程序必须在前台执行! 否则容器自动退出</li></ul></li><li>ENTRYPOINT: <code>ENTRYPOINT command param1 param2</code></li></ul><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><ul><li>编译命令:  <code>docker build --build-arg env=${env} -t repository_name:tag_name -f Dockerfile .</code><ul><li>注: 最后的<code>.</code>和<code>tar cvzf xxx.tar.gz .</code>类似, 表示打包哪个目录</li><li><code>--build-arg k=v</code>会把参数传入dockerfile, 在dockerfile里</li><li><code>-t repository_name:tag_name</code>: 冒号前面部分是仓库名, 后面是TAG</li></ul></li><li>删除镜像: <code>docker rm IMAGE_ID</code>, 或者 <code>docker rmi repository_name:tag_name</code>注意这样会删除该tag下所有镜像</li></ul><h1 id="核心技术与实现原理"><a href="#核心技术与实现原理" class="headerlink" title="核心技术与实现原理"></a>核心技术与实现原理</h1><p>参考:</p><ul><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">Docker 核心技术与实现原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 容器化 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存-Memcache</title>
      <link href="/31.Backend/%E7%BC%93%E5%AD%98-Memcache/"/>
      <url>/31.Backend/%E7%BC%93%E5%AD%98-Memcache/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>Memcached默认情况下采用了名为 Slab Allocator的机制分配来避免内存碎片</p><ul><li>chunks: 每个chunk中都保存了一个item结构体、一对key和value</li><li>slab: 一个slab由若干个大小相等的chunk组成</li><li>page:</li></ul><h1 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="headerlink" title="缓存淘汰算法:"></a>缓存淘汰算法:</h1><ul><li>LRU: Least Recently Used, 最近最不常访问的被淘汰, 访问时间距离现在最久远的被淘汰(较常用)</li><li>LFU: Least Frequently Used, 在一段时间内访问次数最少( 访问频率最少)的被淘汰</li><li>FIFO:</li></ul><h1 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h1><ul><li>stats: 命中率</li><li>stats items: LRU</li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> Memcached </tag>
            
            <tag> LRU </tag>
            
            <tag> LFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper-04应用-分布式锁</title>
      <link href="/31.Backend/Zookeeper-04%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/31.Backend/Zookeeper-04%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>分布式锁需要具备哪些特性?</li><li>如何使用Zookeeper实现分布式锁?</li><li>比较Redis分布式锁方案;</li></ul><p>➤ 分布式锁特性: 互斥性, 超时放锁</p><p>➤ 使用Zk实现分布式锁: Zk实现分布式锁利用了Zk的诸多特性: 节点有序性, 临时节点, Watch ..</p><ul><li>加锁: client 在/lock节点下创建”有序”Znode , 节点id递增由父节点维护, 例如 /lock/node00000 , 如果client的节点是最小的, 则获得锁;<br>获得锁失败的client, 监听 /lock 节点, 当/lock下面节点结构发生变化, zk会通知/lock下全部的node的Client (此处可以改进性能, node00001 只监听 node00000, node00002只监听 node0001 …);</li><li>解锁: Client删除自己的节点, zk Watch进行通知</li><li>超时: 似乎只能等临时Znode被删除(Client的回话结束, Znode被删除)</li></ul><p>@ref <a href="https://blog.csdn.net/qiangcuo6087/article/details/79067136" target="_blank" rel="noopener">10分钟看懂！基于Zookeeper的分布式锁_qiangcuo6087的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper-03一致性</title>
      <link href="/31.Backend/Zookeeper-03%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/31.Backend/Zookeeper-03%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>➤ Zk实现的一致性:</p><ul><li>Zk实现的是顺序一致性: A/B事务依次被提交, 如果客户端看到了B版本的数据, 一定不会再看到A版本的数据;</li><li>Zk并不保证强一致性, 如果一个Zk集群有10个节点, 向Leader更新一项数据, 如果有6个节点写入成功则Zk认为此次写入成功, 但如果客户端刚好从另外4个节点读取数据, 读到的还是旧版本数据.</li><li>考虑两个客户端A和B的场景。如果客户端A将znode /a的值从0设置为1，此时客户端B读取/a，有可能读取旧值0，读到新值or旧值取决于连接到的服务器。如果客户端A和客户端B读取相同的值很重要，则客户端B应该在执行读取之前调用 ZooKeeper API的 <code>sync()</code> 方法。</li></ul><p>➤ Zk的写入过程:</p><ol><li>Client向Leader发出写请求。</li><li>Leader将数据写入到本节点，并将数据发送到所有的Follower节点；</li><li>等待Follower节点返回；</li><li>当Leader接收到一半以上节点(包含自己)返回写成功的信息之后，返回写入成功消息给client;</li></ol><p>如果第一步, Client连接上的是Follower端, 则由Follower把写请求转发给Leader, Leader进行正常的写流程, 超半数节点写成功后, Leader把结果返回给Follower, Follower把写入成功的结果发送给Client</p><p>➤ @ref:</p><ul><li><a href="https://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html" target="_blank" rel="noopener">ZooKeeper Programmer’s Guide</a></li><li><a href="https://www.jianshu.com/p/5300f1f454e8" target="_blank" rel="noopener">Zookeeper 读写数据流程 - 简书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper-02部署和运维</title>
      <link href="/31.Backend/Zookeeper-02%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%90%E7%BB%B4/"/>
      <url>/31.Backend/Zookeeper-02%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="zookeeper部署"><a href="#zookeeper部署" class="headerlink" title="zookeeper部署"></a>zookeeper部署</h1><p>@todo</p><h1 id="zookeeper命令"><a href="#zookeeper命令" class="headerlink" title="zookeeper命令"></a>zookeeper命令</h1><ul><li><p>连接Zk Server:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 连接 zk Server:</span><br><span class="line">bin/zkCli.sh -server 127.0.0.1:2181</span><br><span class="line"># 进入zk命令行 ...</span><br></pre></td></tr></table></figure></li><li><p>列出节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看根目录下节点列表</span><br><span class="line">ls /</span><br></pre></td></tr></table></figure></li><li><p>创建节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建节点/zk1, 节点存储值为aaa</span><br><span class="line">create /zk1 &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line"># -s 顺序节点</span><br><span class="line">create -s /zk2 &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line"># -e 临时节点</span><br><span class="line">create -e /zk3 &quot;ccc&quot;</span><br></pre></td></tr></table></figure></li><li><p>get &amp; set</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置node的值</span><br><span class="line">set /zk &quot;ddd&quot;</span><br><span class="line"></span><br><span class="line"># 获取node的值, 同时返回 mtime/zxid/dataversion等</span><br><span class="line">get /zk1</span><br><span class="line"></span><br><span class="line"># 带版本set, 版本号需要与当前的版本号一致才能设置成功</span><br><span class="line"># 命令格式: set &lt;path&gt; &lt;val&gt; [ver]</span><br><span class="line">set /zk1 &quot;eee&quot; 2</span><br></pre></td></tr></table></figure></li></ul><p>或者使用socket:</p><ul><li><code>echo stat|nc 127.0.0.1 2181</code> 查看哪个节点被选择作为follower或者leader</li><li><code>echo ruok|nc 127.0.0.1 2181</code> 测试是否启动了该Server，若回复imok表示已经启动。</li><li><code>echo dump| nc 127.0.0.1 2181</code> 列出未经处理的会话和临时节点。</li><li><code>echo kill | nc 127.0.0.1 2181</code> ,关掉server</li><li><code>echo conf | nc 127.0.0.1 2181</code> ,输出相关服务配置的详细信息。</li><li><code>echo cons | nc 127.0.0.1 2181</code> ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。</li><li><code>echo envi |nc 127.0.0.1 2181</code> ,输出关于服务环境的详细信息（区别于 conf 命令）。</li><li><code>echo reqs | nc 127.0.0.1 2181</code> ,列出未经处理的请求。</li><li><code>echo wchs | nc 127.0.0.1 2181</code> ,列出服务器 watch 的详细信息。</li><li><code>echo wchc | nc 127.0.0.1 2181</code> ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。</li><li><code>echo wchp | nc 127.0.0.1 2181</code> ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。</li></ul><p>@ref:</p><ul><li><a href="https://cloud.tencent.com/developer/article/1781289" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1781289</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> Apache </tag>
            
            <tag> 分布式 </tag>
            
            <tag> Zookeeper </tag>
            
            <tag> Paxos </tag>
            
            <tag> ZAB </tag>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper-01基础概念</title>
      <link href="/31.Backend/Zookeeper-01%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/31.Backend/Zookeeper-01%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>Session;</li><li>临时Znode;</li><li>持久Znode;</li><li>Watcher;</li><li>Leader/Follower/Observer;</li><li>zxid;</li><li>ZAB;</li></ul><p>➤ Zk中的重要概念:</p><ul><li>Session(会话): Session 是客户端和Zk的一个长连接, 每个客户端的Session 都有一个 唯一id, 客户端定时向zk发送heart_beat , Session在创建的时候可以指定一个<code>sessionTimeout</code>, 如果超时则会断开该Session;</li><li>ZNode是zk存储数据的节点, ZNode 分为永久节点和临时节点<ul><li>持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。</li><li>临时节点的生命周期和客户端会话(Session)绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</li><li>创建节点时可以指定 SEQUENTIAL 属性, zk会在创建这个节点的时候加上递增整形序号, 序号递增是由父节点维护的</li></ul></li><li>Watcher（事件监听器）: ，是Zookeeper中的一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。</li><li>Zxid (Zookeeper Transaction Id): Zookeeper给每次更新操作都分配一个全局唯一递增编号, 这个编号反映了所有操作的先后顺序, 可以实现更高层次的同步原语;</li><li>Zk集群中的节点的角色: Leader, Follower, Observer:<ul><li>Leader 可以提供读/写服务;</li><li>Follower 和 Observer 都只提供读服务, 不同的是Follower 参与Leader的选举, Observer不参与选举, 也不参与写的时候”超过半数节点写成功则写入成功”的策略, 可以认为 Obverser的作用是提高集群的读性能, 且不影响写入性能;</li></ul></li><li>ZAB(Zookeeper Atomic Broadcast): Zookeeper通过ZAB协议实现了分布式数据的一致性(顺序一致性), 另外ZAB还提供了崩溃恢复(Leader选举);</li><li>Paxos算法 和 Zab协议: 「ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。」</li><li>Zab协议中定义的两种集群状态:<ul><li>崩溃恢复: 当集群在启动过程/Leader网络断开/异常重启时, ZAB协议进入崩溃恢复模式, 进行leader选举, 然后Folower节点与Leader节点进行数据同步, <strong>当过半的Folower节点都同步完成</strong>, ZAB协议退出崩溃恢复模式, 进入消息广播状态;</li><li>消息广播: 在此状态下, 只允许一台 Leader服务器进行事务请求的处理, 如果Follower节点接收到客户端的事务请求也应当转发给 Leader. Leader收到事务请求后, 会对事务进行提案并进行一轮新的广播</li></ul></li></ul><p>➤ Zk的以下特性使得其可以作为 1集群管理(Znode watch集群节点状态), 2分布式存储(Zk的数据一致性) 3分布式锁(操作的原子性, Watch特性), 具体使用场景有:</p><ul><li>Kafka的 Broker节点状态监控利用了 Znode和 Watch;</li><li>Kafka的 Controller选举利用了Zk实现的分布式锁;</li><li>Kafka的 Consumer Group对某个 Topic的消费offset记录利用了Zk的一致性存储;</li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000016349824" target="_blank" rel="noopener">可能是全网把 ZooKeeper 概念讲的最清楚的一篇文章 - JavaGuide - SegmentFault 思否</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 秒杀系统</title>
      <link href="/31.Backend/SystemDesign-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9/"/>
      <url>/31.Backend/SystemDesign-%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>高性能:静动分离/热点优化/系统优化;</li><li>高可用:削峰/兜底, 库存数据一致性;</li><li>一致性;</li></ul><p>➤ 高性能:</p><ul><li>静动分离: 数据拆分, 数据缓存, 数据整合;</li><li>热点优化:<ul><li>热点识别: 通过链路各节点收集热点key, 识别热点商品, 发送到各订阅模块, 各模块采取各自措施(缓存或限流或熔断)</li><li>热点隔离:<ul><li>系统隔离(怎么做?): 负载均衡层做(热点key如何更新到配置?) 或者端上存储特定cookie,</li><li>数据隔离: 热点数据使用单独的Cache/DB</li></ul></li><li>热点优化: 系统层(业务代码)对热点做优化, 本机缓存/ 限流等</li></ul></li><li>系统优化(代码):<ul><li>减少序列化(多在RPC阶段)</li><li>字符串优化: 涉及到字符串的IO, OutputStream() 类函数从而减少数据的编码转换 (由于字符串每个字符需要转字节, 这个过程需要查编码表)</li><li>去除不必要组件: 去掉MVC (因为MVC的 Chain)</li><li>剪裁异常日志堆栈大小</li></ul></li></ul><p>➤ 一致性: 库存数据的一致性</p><ul><li>减库存<ul><li>在业务层面, 何时减库存? 两种方案 1下单 , 2支付 (两种方案优劣?) 在实际中使用 下单减库存, 下单后有支付超时, 超时后释放库存</li><li>如何防止库存为负: 1事务,发现数据为负则回滚, 2数据库字段设置为unsigned, 3 是使用 CASE WHEN 判断语句</li></ul></li><li>一致性的性能优化<ul><li>读性能: 读链路上可以做”不影响性能”的校验, 一般不在读链路上做一致性校验, 只在写链路做一致性校验</li><li>写性能: 1数据库选型(如果不需要事务,或者复杂的减扣逻辑, 可以换内存型KV数据库), 2排队减扣(例如分布式锁) 3专用数据库</li></ul></li></ul><p>➤ 高可用:</p><ul><li>流量削峰:<ul><li>客户端通过校验等手段, 减少请求</li><li>服务端通过 限流 or 消息队列(如何解决积压?)</li></ul></li><li>Plan B: 兜底</li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000020970562" target="_blank" rel="noopener">从0到1设计一个秒杀系统</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 分布式唯一ID方案</title>
      <link href="/31.Backend/SystemDesign-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID/"/>
      <url>/31.Backend/SystemDesign-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID/</url>
      
        <content type="html"><![CDATA[<ul><li>UUID:<ul><li>版本1: Mac地址+时间戳</li><li>版本4: 基于随机数, 可能是伪随机, 例如 <code>java.util.UUID.randomUUID()</code>是版本4的一个实现</li></ul></li><li>Snowflake(Twitter方案):<ul><li>实现: 64位 = 1位符号 + 41位毫秒时间戳 + 10位机器id + 12序列号<ul><li>缺陷: 非严格递增, 机器上有多个线程, 如何保证1ms内每个线程生成的序列号不重复? // 可以使用随机数, 时间戳做seed, 多线程使用同一个seed(有没有并发互斥问题?)</li></ul></li><li>实现2: 64位 = 1位符号 + 41位毫秒时间戳 + 10位机器id + 10位进程id + 2位序号<ul><li>缺陷: 每个线程每毫秒只能生成4个id的限制</li></ul></li></ul></li><li>mysql自增(Flickr方案):<ul><li>实现: 8台Mysql, 第一台起始seq=1, 第二台起始seq=2, 每次seq+=8</li><li>缺陷: 不是严格递增</li></ul></li></ul><p>@ref:</p><ul><li>[[SystemDesign-随机数]]</li><li><a href="https://soulmachine.gitbooks.io/system-design/content/cn/distributed-id-generator.html" target="_blank" rel="noopener">分布式ID生成器 · 系统设计(System Design)</a></li><li><a href="https://juejin.im/post/5d9fe5006fb9a04de7734b9e#heading-1" target="_blank" rel="noopener">基于Twitter的雪花算法改造，分布式全局唯一ID生成器 - 掘金</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 短网址方案</title>
      <link href="/31.Backend/SystemDesign-%E7%9F%AD%E7%BD%91%E5%9D%80%E6%96%B9%E6%A1%88/"/>
      <url>/31.Backend/SystemDesign-%E7%9F%AD%E7%BD%91%E5%9D%80%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<ul><li>5个字符的短网址, 能表示多少个URL ?<ul><li>短网址的构成是大写+小写+数字 = 26+26+10 = 72, 也就是一个字节有72种选择, 假设短网址是5位, 那么能表示多少种网址? $72^5$</li></ul></li><li>生成方案:<ul><li>哈希: 缺点冲突</li><li>UUID, 存储使用K-v, 短网址是K</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 接口幂等性</title>
      <link href="/31.Backend/SystemDesign-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/31.Backend/SystemDesign-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<ul><li>接口幂等性: 多次调用接口, 与调用一次接口最终结果一致(或者说产生相同的作用)</li><li>RESTful标准的 Http接口 （ =&gt; <a href="/31.Backend/SystemDesign-RESTful/" title="SystemDesign-RESTful">SystemDesign-RESTful</a>）:<ul><li>GET: 查询, 符合幂等</li><li>POST: 创建, 不应设计为幂等</li><li>PUT:  更新, 应设计为幂等</li><li>DELETE: 删除, 应设计为幂等</li></ul></li><li>工程如何实现:<ul><li>如果是余额减扣（防止客户端误点击产生重复扣款）: 第一次请求从server端取得唯一id, 第二次请求带着唯一id进行减扣, 服务端可以存Redis或者通过Mysql唯一索引对这个id去重 （或者每次本地动作都用uuid生成一次）</li><li>如果订单支付这种有唯一id的场景, 可以使用订单id去重, 或者通过订单的状态机</li></ul></li></ul><p>@ref</p><ul><li><a href="https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html" target="_blank" rel="noopener">理解HTTP幂等性 - Todd Wei - 博客园</a></li><li><a href="/31.Backend/SystemDesign-RESTful/" title="SystemDesign-RESTful">SystemDesign-RESTful</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 缓存</title>
      <link href="/31.Backend/SystemDesign-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
      <url>/31.Backend/SystemDesign-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>缓存穿透: 布隆过滤器, 写null数据,</li><li>缓存雪崩: 加随机过期时间</li><li>缓存击穿: 某条缓存失效的时候, 正好有大量并发读这个key, 访问量都落在了数据库// 解决: 准备load db时, 先 Setnx k,</li></ul><blockquote><p>@ref <a href="https://zhuanlan.zhihu.com/p/75588064" target="_blank" rel="noopener">redis缓存穿透，缓存击穿，缓存雪崩原因+解决方案 - 知乎</a></p></blockquote><p>➤ 缓存的一致性问题, 指的是Cache/DB出现不一致数据，其根本原因是 “读写Cache” 和”读写DB”不是原子的.</p><p>➤ 解决缓存一致性方案:</p><ul><li>方案1:<ul><li>读: 先读cache, 读不到则查db, 然后把db查询结果写入cache;</li><li>更新: 更新db, 删除cache;</li><li>可能存在的问题: 两个读线程, A读到了V1数据然后休眠, 这时候B线程修改了数据, 版本为V2, 线程A醒来, 把先前读到的V1写入Cache</li></ul></li><li>方案2: 方式1的更新操作改为延迟双删: updateDB, delCache, sleep(1s), delCache</li><li>方案3: cache订阅DB的binlog</li></ul><blockquote><p>@ref <a href="https://blog.csdn.net/hjm4702192/article/details/80518922" target="_blank" rel="noopener">redis 双写一致性 看一篇成高手系列1_数据库_hjm4702192的专栏-CSDN博客</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 延迟队列方案</title>
      <link href="/31.Backend/SystemDesign-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
      <url>/31.Backend/SystemDesign-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>为什么需要延迟队列? </p><ul><li>单机延迟队列:<ul><li>优先队列 // 该方式, 或者 Redis Zset这种方式的问题? 轮询线程Sleep后, 插入了一个需要马上处理的任务</li><li>DelayQueue: @todo</li><li>HashedWheelTimer(时间轮算法): 环形数组共n个元素, 每个元素表示一个单位时间(例如1s), 同时每个元素是一个”桶”, 指向一个链表, 链表里保存的是该秒要执行的任务. 如果放入一个x秒后执行的新任务, x大于n, 当前运行指针指向第3个元素, 那么放入数组第几个桶里呢? <code>index = x%n + 3</code>, 同时链表中的每个任务都保存圈数这个字段,每次指针经过这个桶, 桶中所有任务的圈数都-1, 如果圈数=0则表示要执行;</li></ul></li><li>分布式延迟队列:<ul><li>Redis : blpop/brpop</li><li>RabbitMQ : Dead Letter Exchange</li></ul></li></ul><blockquote><p>关于 <em>HashedWheelTimer</em>:<br>根据 George Varghese 和 Tony Lauck 1996 年的论文《Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility》提出了一种定时轮的方式来管理和维护大量的 timer 调度。Netty 的定时任务调度就是基于时间轮算法调度 … @ref: <a href="https://www.infoq.cn/article/netty-threading-model" target="_blank" rel="noopener">https://www.infoq.cn/article/netty-threading-model</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 负载均衡 | 总结：方案及算法</title>
      <link href="/31.Backend/SystemDesign-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-%E7%AE%97%E6%B3%95/"/>
      <url>/31.Backend/SystemDesign-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>➤ 常用LB方案:</p><ul><li>DNS 负载均衡</li><li>四层(传输层)负载均衡: <a href="/31.Backend/SystemDesign-负载均衡-LVS/" title="SystemDesign-负载均衡-LVS">SystemDesign-负载均衡-LVS</a></li><li>七层(应用层)负载均衡: <a href="/31.Backend/SystemDesign-负载均衡-Nginx/" title="SystemDesign-负载均衡-Nginx">SystemDesign-负载均衡-Nginx</a>]</li><li>硬件负载均衡: F5, A10</li></ul><p>➤ 常用LB算法:</p><ul><li>静态LB算法 (基于算法, 不考虑后端服务器状态)<ul><li>随机: Random</li><li>轮询: Round Robin</li><li>加权轮询: Weighted Round Robin</li><li>哈希: HASH, 包括源地址哈希, 目标地址哈希, 应用层LB也可以使用URL或者自定义Key进行哈希</li></ul></li><li>动态LB算法 (基于后端服务器状态动态调整)<ul><li>最小连接:</li><li>最小耗时:</li></ul></li></ul><p>➤ 代码:</p><ul><li>加权轮询: → Nginx 平滑基于权重的轮询算法实现 <a href="/31.Backend/SystemDesign-负载均衡-Nginx/" title="SystemDesign-负载均衡-Nginx">SystemDesign-负载均衡-Nginx</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 负载均衡 | Nginx</title>
      <link href="/31.Backend/SystemDesign-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Nginx/"/>
      <url>/31.Backend/SystemDesign-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Nginx/</url>
      
        <content type="html"><![CDATA[<p>➤ Nginx(7层反向代理)提供的几种负载均衡算法实现:</p><ul><li>随机 :</li><li>轮询 :</li><li>加权轮询 :</li><li>源ip哈希 <code>ip_hash</code> : 使用Client端的IP进行Hash</li><li>通用哈希 <code>hash $key</code> : 使用自定义的key进行Hash, 也支持一致性哈希<code>hash $key consistent</code>, 一致性哈希一般用于后端服务器是缓存时, 例如使用请求URL进行一致性Hash: <code>hash $request_uri consistent</code>,</li><li>最小连接 <code>least_conn</code> : 请求将被发送给 活动连接数最小的后端服务器</li><li>最小耗时 <code>least_time</code> : 请求将被发送给 平均耗时最小的后端服务器, 平均耗时有两种计算方式: 从后端服务器收到第一个字节<code>least_time header</code>, 或从后端服务器收到完整请求<code>least_time last_byte</code></li></ul><blockquote><p>@ref <a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/#" target="_blank" rel="noopener">NGINX Docs | HTTP Load Balancing</a></p></blockquote><p>➤ Nginx 平滑基于权重的轮询算法实现</p><ul><li>初始化: 每个节点当前权重 = 初始权重;</li><li>第一轮选择节点, 选择当前权重最大的, 被选择的节点的”当前权重”发生变化 = 当前权重-权重总和, 未选中节点的”当前权重”不变;</li><li>第二轮选择节点, 每个节点的权重 = 每个节点初始权重+ 上一轮的最终权重;</li><li>综上, 每次节点被选中, 它的当前权重会减少(-总权重), 进入下一轮后, 每个节点都把上轮权重+自己的初始权重, 然后开始选择;</li></ul><blockquote><p>@ref <a href="https://tenfy.cn/2018/11/12/smooth-weighted-round-robin/" target="_blank" rel="noopener">nginx平滑的基于权重轮询算法分析 | tenfy’ blog</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 负载均衡 | LVS</title>
      <link href="/31.Backend/SystemDesign-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/"/>
      <url>/31.Backend/SystemDesign-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-LVS/</url>
      
        <content type="html"><![CDATA[<p>➤ LVS, Linux Virtual Server, 即Linux虚拟服务器:</p><ul><li>LVS是工作于 ISO网络模型第四层的反向代理, 核心功能「IPVS」是 Linux Kernel的一个模块;</li><li>LVS由 「IPVS」和「IPVSADM」组成, 前者工作在内核态负责数据路由, 后者工作在用户态负责选项的设置;</li><li>LVS工作在 「Director Server」, Director Server对外提供虚拟IP(Virtual IP, 简称VIP), 客户端的请求发往VIP, 请求数据经过 Director Server的内核态, 通过IPVSADM设置的路由规则, 最终被发送给真实服务器IP(Real IP, 简称RIP);</li><li>附图: LVS工作原理 &amp; LVS内核模型如下</li></ul><p><img src="/images/LVS-Kernel-Processor.png" alt="LVS-Kernel-Processor"></p><blockquote><p>1.当客户端的请求到达负载均衡器的内核空间时，首先会到达PREROUTING链。<br>2.当内核发现请求数据包的目的地址是本机时，将数据包送往INPUT链。<br>3.LVS由用户空间的ipvsadm和内核空间的IPVS组成，ipvsadm用来定义规则，IPVS利用ipvsadm定义的规则工作，IPVS工作在INPUT链上,当数据包到达INPUT链时，首先会被IPVS检查，如果数据包里面的目的地址及端口没有在规则里面，那么这条数据包将被放行至用户空间。<br>4.如果数据包里面的目的地址及端口在规则里面，那么这条数据报文将被修改目的地址为事先定义好的后端服务器，并送往POSTROUTING链。<br>5.最后经由POSTROUTING链发往后端服务器。</p></blockquote><p>➤ LVS提供如下几种负载均衡调度算法:</p><ul><li>Round Robin</li><li>Weight Round Robin</li><li><p>Destination Hash: 目标ip地址哈希, LVS采用了素数乘法Hash函数, 如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline unsigned hashkey(unsigned int dest_ip)</span><br><span class="line">&#123;</span><br><span class="line">  // 2654435761UL是2到2^32 (4294967296)间接近于黄金分割的素数</span><br><span class="line">  return (dest_ip* 2654435761UL) &amp; HASH_TAB_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Source Hash: 请求的来源ip哈希</p></li><li>Least Connections: 最小连接</li><li>Weight Least Connections: 带权重的最小连接 // LVS默认</li><li>Shortest Expected Delay: 最小期望延迟</li><li>locality-Based Least Connections: 基于局部性的最少链接</li><li>Locality-Based Least Connections with Replication: 带复制的基于局部性最少连接</li></ul><p>@ref:</p><ul><li><a href="http://zh.linuxvirtualserver.org/node/40" target="_blank" rel="noopener">基于局部性的最少链接（Locality-Based Least Connections Scheduling） | LVS中文站点</a></li><li><a href="http://zh.linuxvirtualserver.org/node/41" target="_blank" rel="noopener">带复制的基于局部性最少链接（Locality-Based Least Connections with Replication Scheduling） | LVS中文站点</a></li></ul><p>➤ LVS工作模式 @todo</p><blockquote><p>@ref: <a href="https://cloud.tencent.com/developer/article/1115533" target="_blank" rel="noopener">LVS原理知多少？ - 云+社区 - 腾讯云</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign-熔断器-Polaris</title>
      <link href="/31.Backend/SystemDesign-%E7%86%94%E6%96%AD%E5%99%A8-Polaris/"/>
      <url>/31.Backend/SystemDesign-%E7%86%94%E6%96%AD%E5%99%A8-Polaris/</url>
      
        <content type="html"><![CDATA[<p>tldr:</p><ul><li>客户端上报调用服务端的结果(成功,失败,超时..)</li><li>服务端(北极星)为每个提供服务的节点, 维护一个熔断器</li><li>熔断器的状态(关闭, 打开)是根据滑动窗口内的成功率计算的</li></ul><p>很多时候，服务端（provider）本身并不能检测到自身的异常。如主调方（consumer）调用时不断收到错误返回，但服务端仍旧保持工作状态中。这种情况下应该暂时屏蔽掉此实例，以减少错误返回。由此引入了故障熔断功能。</p><p>故障熔断功能主要是为了屏蔽错误实例，防止错误扩散影响整体服务质量。北极星提供的是故障数目的统计与处理，因此强依赖于主调方对调用结果的数据上报。熔断器状态设计参考Martin Fowler提出的熔断器模型，将每一个节点实例与一个熔断器绑定，熔断器状态如下图所示。</p><p>@ref: <a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">https://martinfowler.com/bliki/CircuitBreaker.html</a></p><p><img src="/images/20220416211631.png" alt=""></p><p>熔断器必定处于以下三种状态之一：</p><ul><li>Closed状态：节点正常工作下熔断器的状态，熔断器处于关闭中，不产生任何效果。</li><li>Open状态：当北极星“频繁”接收到主调方上报的调用失败信息后，会将熔断器打开，此时节点已被“熔断”，不再提供服务。频繁的定义取决于下面所介绍的滑桶算法来统计数据。此外，用户主动在北极星上为某个节点实例打开“隔离”选项时，也相当于将熔断器状态设置为Open。</li><li>Half Open状态：中间状态，当熔断器Open一段时间后（主动打开隔离选项的除外），北极星会将熔断器设置为半开状态，处理少量的主调方请求，如果正常工作，则后续转变成Close状态，如果失败，则会依旧将其转变为Open状态，然后重复此过程。</li></ul><p>滑桶算法:<br>算法维持过去一段时间内的服务调用结果，根据每个时间单元（图示桶单元）统计四项数据：Success，Failure，Timeout，Rejection。将此段时间看作一个滑动窗口，窗口的大小是固定的，因此当一个新的时间单元被创建时，最旧的那个时间单元即被废弃。北极星统计每个窗口的调用失败率，超时量等信息，据此决定熔断器状态。</p><p><img src="/images/20220416212133.png" alt="一个有10个单元时间的滑动窗口"></p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 熔断器 | Hystrix</title>
      <link href="/31.Backend/SystemDesign-%E7%86%94%E6%96%AD%E5%99%A8-Hystrix/"/>
      <url>/31.Backend/SystemDesign-%E7%86%94%E6%96%AD%E5%99%A8-Hystrix/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>Hystrix [hɪst’rɪks] 提供了哪些功能?</li><li>使用 Hystrix API创建隔离器的步骤;</li><li>Hystrix 熔断的触发判定, 以及半开状态是怎样的?</li><li>Hystrix 提供的信号量隔离与线程池隔离的比较?</li></ul><p>➤ Hystrix [hɪst’rɪks] 提供了哪些功能?</p><ul><li>提供线程池隔离 // 信号量隔离</li><li>降级: 超时 or 资源不足(线程池,信号量), 降级后可返回降级接口的托底数据</li><li>熔断: 错误率达到阈值进行熔断, 触发快速失败, 以及自动回恢复的功能</li></ul><blockquote><p>@ref 《亿级流量》</p></blockquote><p>➤ 创建Hystrix 隔离/熔断器的 API和步骤?</p><ol><li>创建 一个 HystrixCommand (cmd的参数有: groupKey, commandKey, threadPoolProperties)</li><li>同步调用: HystrixCommand.execute();</li><li>异步调用: Future f = HystrixCommand.queue();</li><li>降级(兜底数据): 覆写 HystrixCommand.getFallback()即可, 返回兜底数据</li><li>熔断: 需要设置的参数: circuitBreakerRequestVolumeThreshold, circuitBreakerErrorThresholdPercentage (触发熔断的最少错误的请求个数, 失败比例)</li><li>线程池属性: 和Java 线程池稍有不同, Hystrix定义了两个参数 maxQueueSize &amp; queueSizeRejectionThreashold, 前者和后者分别是队列最大大小/队列拒绝上限, 后者可以灵活的设定</li></ol><p>➤ Hystrix 熔断的触发判定, 以及半开状态是怎样的?</p><ul><li>使用滑动时间窗口来记录每个时间片内相关熔断计数指标及熔断器状态，时间片段称作为一个bucket，默认维护10个bucket，每1秒一个bucket，随着时间的滚动，最早的bucket抛弃，创建新的bucket到滑动窗口右边。</li><li>每个blucket记录请求总数、成功数、超时数、拒绝数及熔断器状态，默认错误超过50％且10秒内超过20个请求进行中断拦截。</li><li><p>当调用的失败比例高出阈值(可能意味着下游服务出现问题, 如果此时再继续正常流程的retry机制, 会进一步恶化下游服务), 触发熔断后, 熔断器开启并休眠一段时间, 此时再调用 HystrixCommand会返回 failfast , 休眠之后熔断器进入 half-open状态, 试探性放过一部分流量, 如果调用成功则关闭熔断器;</p></li><li><p>@ref <a href="https://www.cnblogs.com/yunpt/p/10060342.html" target="_blank" rel="noopener">微服务熔断隔离机制及注意事项 - 用友云平台 - 博客园</a></p></li><li>@ref <a href="http://kriszhang.com/hystrix_defend_your_webapp/" target="_blank" rel="noopener">使用hystrix保护你的应用 - Kris的博客 | Kris’ Blog</a></li></ul><p>➤ Hystrix 提供的信号量隔离与线程池隔离的比较?</p><ul><li>除了线程池隔离, Hystrix 还提供了<em>信号量隔离</em> : 可以创建一个 HystrixProperties, 并设置 IsolationStrategy=SEMAPHORE, 设置 MaxConcurrentRequest=N(信号量大小);</li><li>调用者线程不会再往 Hystrix线程池提交任务, 而是直接在调用者线程池直接执行, (每调用一次-1, 调用完成+1);</li><li>信号量隔离的作用是限制并发数, 更适合非网络请求;</li><li>信号量隔离没有缓冲队列, 无法很好的应对突发流量的情况;</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign | 限流 | 概述</title>
      <link href="/31.Backend/SystemDesign-%E9%99%90%E6%B5%81-%E7%AE%97%E6%B3%95/"/>
      <url>/31.Backend/SystemDesign-%E9%99%90%E6%B5%81-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>漏桶: 固定速率出桶, 桶满了再进入的流量被抛弃, 缺点: 队列使请求的处理变成单队列, 有大量突发流量时, 就算桶是空的, 仍需要排队</li><li>令牌桶: 固定速率向桶中存放令牌, 如果桶满了令牌会被丢弃, 每个请求到来先从桶里请求令牌</li><li>滑动窗口: 防止突发流量</li></ul><p>[[SystemDesign-限流-分布式限流]]<br>[[SystemDesign-限流-GuavaRateLimiter]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SystemDesign-RESTful</title>
      <link href="/31.Backend/SystemDesign-RESTful/"/>
      <url>/31.Backend/SystemDesign-RESTful/</url>
      
        <content type="html"><![CDATA[<p>REST: 把对外提供的服务抽象为某种资源(User/Order), 通过HTTP的 GET/POST/DELETE/PUT方法对资源对象进行操作, 满足这几个条件的服务, 可以称为 #RESTful 的 (Representional State Transfer)</p><p>@ref:</p><ul><li>RESTful API 设计指南 - 阮一峰的网络日志：<a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C100K系统设计</title>
      <link href="/31.Backend/SystemDesign-C100K/"/>
      <url>/31.Backend/SystemDesign-C100K/</url>
      
        <content type="html"><![CDATA[<p>C100K系统设计: 本篇只讨论<strong>OS级别的并发优化</strong>，不包括<strong>语言层面对并发的支持特性</strong>，C10K / C100K / C1000K 都是指系统能够支持的空闲长连接的数量。</p><p>@ref: <a href="https://www.zhihu.com/question/41740986" target="_blank" rel="noopener">https://www.zhihu.com/question/41740986</a></p><h1 id="有关Linux系统的限制"><a href="#有关Linux系统的限制" class="headerlink" title="有关Linux系统的限制"></a>有关Linux系统的限制</h1><h2 id="系统最大文件数"><a href="#系统最大文件数" class="headerlink" title="系统最大文件数"></a>系统最大文件数</h2><p>使用<code>ulimit</code>设置最多能打开文件数:</p><ul><li>查看所有的限制: <code>ulimit -a</code></li><li>设置最大打开文件句柄数: <code>ulimit -n 65535</code>, 65535 = 2^16 = 0xFFFF</li><li>设置 <strong>每个用户的</strong> 最大进程数: <code>ulimit -u 32768</code></li><li>设置线程栈的大小: <code>ulimit -s 10240</code></li><li>设置最大线程数数: <code>ulimit -T</code> (在Unix上可能不同)</li><li>设置产生core文件大小: <code>ulimit -c xxx</code></li><li>不限制core的大小: <code>ulimit -c unlimited</code></li></ul><p>ulimit起作用的范围是”当前Shell”, 并不是作用于”当前用户”, 如要对”用户”级别做限制, 则需要修改系统文件 <code>/etc/security/limits.conf</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># * 表示所有用户, nofile表示限制文件打开数, 限制在100</span><br><span class="line">* hard nofile 100</span><br></pre></td></tr></table></figure><p>如果是针对整个系统, 则需要使用<code>sysctl</code>修改, 命令格式为: <code>sysctl -w fs.nr_open=10000000</code>, 每个系统参数对应一个/proc下的文件, <code>fs.nr_open</code>对应的文件路径是<code>/proc/sys/fs/nr_open</code><br>系统最大打开文件数相关的参数有两个:</p><ul><li>fs.nr_open，进程级别</li><li>fs.file-max，系统级别</li></ul><p>至此总结一下, “Linux系统最多能打开文件数” 有当前shell, 用户, 系统三个级别,<br>shell级别的更改限制命令是ulimit, 更改系统级别限制的命令是sysctl,<br>限制优先级最大的是fs.file-max, 假如fs.file-max设置为100万, ulimit是不能超过100万的.</p><blockquote><p>cat /proc/sys/fs/file-nr, 输出 9344 0 592026，分别为：1.已经分配的文件句柄数，2.已经分配但没有使用的文件句柄数，3.最大文件句柄数<br>file-nr不是单个进程的限制, 是系统级的, 最后一个数字与<code>file-max</code>相同</p></blockquote><p>@ref:</p><ul><li>Sysctl 命令参考: [[../21.Operating-System/Linux.04.Sysctl]]</li></ul><h3 id="如何查看已创建文件描述符数"><a href="#如何查看已创建文件描述符数" class="headerlink" title="如何查看已创建文件描述符数?"></a>如何查看已创建文件描述符数?</h3><ul><li>某进程打开文件数 <code>ll /proc/1599/fd | wc -l</code></li><li>某进程打开socket的数量: <code>ll /proc/1599/fd | grep socket | wc -l</code>  # nginx一个worker打开了200-300个socket</li><li>系统全部打开的文件数 <code>lsof | wc -l</code></li><li>系统全部打开的TCP连接数 <code>lsof | grep TCP | wc -l</code></li><li>查看tcp不同状态连接数: <code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code><ul><li>注意处于TIME_WAIT的链接, 如果这个数过高会占用大量连接, 应该调整参数尽快的释放time_wait连接</li></ul></li></ul><p>在Nginx机器上测试:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@zw_85_63 ~]# netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br><span class="line">TIME_WAIT 37968</span><br><span class="line">SYN_SENT 1</span><br><span class="line">FIN_WAIT1 5</span><br><span class="line">FIN_WAIT2 4</span><br><span class="line">ESTABLISHED 2725</span><br><span class="line">SYN_RECV 18</span><br><span class="line">LAST_ACK 4</span><br></pre></td></tr></table></figure><h2 id="系统最大进线程数"><a href="#系统最大进线程数" class="headerlink" title="系统最大进线程数"></a>系统最大进线程数</h2><p>某些服务程序(Apache, Tomcat) 采用 “Thread Per Request”, 系统的进线程最大数也会影响并发性能.</p><p>Linux 没有 <strong>直接限制</strong> 每个进程能够创建线程数, 仅限制了系统最大进线程数, 相关的配置有 :</p><ul><li>仅对当前 shell有效: <code>ulimit -u 102400</code>, <code>-u</code>表示 “max user processes”;</li><li>系统级别有效:<ol><li>临时生效: <code>echo 102400 &gt; /proc/sys/kernel/threads-max</code> 或 <code>sysctl -w sys.kernel.threads-max=10240</code> ;</li><li>永久生效: 修改 /etc/sysctl.conf 文件;</li></ol></li></ul><blockquote><p>这里的 threads-max 不是指 进程, 是 “maximum number of threads that can be created using fork()”,<br>@ref <a href="https://www.kernel.org/doc/Documentation/sysctl/kernel.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/sysctl/kernel.txt</a></p></blockquote><p>每个进程能创建的最大线程数, 是由 total virtual memory 和stack size 共同决定的, <code>number of threads = total virtual memory / stack size</code><br>这两个参数分别用 <code>ulimit -v xxx</code> 和 <code>ulimit -s xxx</code>设置</p><p>此外系统能创建最大进程数还受 <code>kernel.pid_max</code>影响:</p><ul><li>方式1 运行时限制,临时生效 <code>echo 999999 &gt; /proc/sys/kernel/pid_max</code></li><li>方式2 修改/etc/sysctl.conf，永久生效 <code>sys.kernel.pid_max = 999999</code></li></ul><h1 id="应用程序的设置"><a href="#应用程序的设置" class="headerlink" title="应用程序的设置"></a>应用程序的设置</h1><p>根据不同程序不同IO模型, 设置的思路也不一样</p><blockquote><p>BIO：Apache/Tomcat, 主要是并发量要求不高的场景<br>NIO：Nginx/Redis, 主要是高并发量要求的场景<br>Redis使用单线程的I/O复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll、kqueue和select。对于单纯只有I/O操作来说，单线程可以将速度优势发挥到最大。<br>但是Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个I/O调度都是被阻塞住的，</p></blockquote><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><ul><li>worker_connections= //每个worker线程能创建的连接数</li><li>upstream可以使用http 1.1的keepalive //与后端服务器创建的连接池大小</li><li>worker_processes 8; // nginx进程数，一般等于cpu core数量</li><li>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000; // 每个进程分配到cpu的core上</li><li>worker_rlimit_nofile 65535; // 一个nginx进程打开的最多文件描述符数目</li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>@todo</p><h2 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h2><p>默认是多进程同步处理request, 所以思路和Nginx每个Core一个进程epoll轮询的方式不同, apache应该增加”系统创建进程数上限”, 并且减小进程栈内存</p><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><ul><li>maxThreads=500 最大线程数，此值限制了bio的最大连接数<ul><li>一般的当一个进程有500个线程在跑的话，那性能已经是很低很低了。Tomcat默认配置的最大请求数是150。当某个应用拥有250个以上并发的时候，应考虑应用服务器的集群。</li></ul></li><li>maxConnection=8192: 使用nio或者apr时，最大连接数受此值影响。</li></ul><p>参考 <a href="http://www.cnblogs.com/zhanjindong/p/concurrent-and-tomcat-threads.html" target="_blank" rel="noopener">聊下并发和Tomcat线程数（Updated） - zhanjindong - 博客园</a> @ref</p><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><ul><li>fastcgi_connect_timeout 300;</li></ul><h1 id="高并发配置-无废话总结"><a href="#高并发配置-无废话总结" class="headerlink" title="高并发配置-无废话总结"></a>高并发配置-无废话总结</h1><ol><li>应用程序的并发设置: 主要是timeout, 进/线程数这几类参数</li><li>操作系统打开文件数量限制:  <code>ulimit -n</code>单个Shell环境的限制, <code>sysctl -w fs.file-max</code>修改系统打开文件限制</li><li>操作系统打开端口数量限制: 最大端口数65535(2^16), 但1024以后的端口是给系统用的</li><li>sysctl修改的TCP协议栈参数</li></ol><h1 id="并发性能测试工具"><a href="#并发性能测试工具" class="headerlink" title="并发性能测试工具"></a>并发性能测试工具</h1><h2 id="ab-Apache-Bench"><a href="#ab-Apache-Bench" class="headerlink" title="ab(Apache Bench)"></a>ab(Apache Bench)</h2><p>1000并发, 总共20000次请求: <code>ab -n 20000 -c 1000 &lt;url&gt;</code></p><h2 id="http-load"><a href="#http-load" class="headerlink" title="http_load"></a>http_load</h2><p>30个并发线程, 共60秒测试: <code>http_load -p 30 -s 60 Url.txt</code></p><h2 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>@todo</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>@todo</p><h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p>在聚合报告中，会显示一行数据，共有10个字段，含义分别如下。</p><ul><li>Label：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值</li><li>Samples：表示你这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100</li><li>Average：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以Transaction 为单位显示平均* 响应时间</li><li>Median：中位数，也就是 50％ 用户的响应时间</li><li>90% Line：90％ 用户的响应时间</li><li>Min：最小响应时间</li><li>Max：最大响应时间</li><li>Error%：本次测试中出现错误的请求的数量/请求的总数</li><li>Throughput：吞吐量——默认情况下表示每秒完成的请求数（Request per Second）</li><li>KB/Sec：每秒从服务器端接收到的数据量，相当于LoadRunner中的Throughput/Sec</li></ul><p>参考: <a href="http://www.importnew.com/13876.html" target="_blank" rel="noopener">使用JMeter进行负载测试——终极指南 - ImportNew</a> @ref</p><h2 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h2><p><a href="https://github.com/wg/wrk" target="_blank" rel="noopener">wg/wrk: Modern HTTP benchmarking tool</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.rowkey.me/blog/2015/09/09/load-analysis/" target="_blank" rel="noopener">系统负载能力浅析</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/" target="_blank" rel="noopener">通过 ulimit 改善系统性能</a> @Archived</li><li><a href="http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/" target="_blank" rel="noopener">怎样增大 Linux 系统的 open file(s) 上限</a></li><li><a href="http://www.cnblogs.com/sxlfybb/archive/2011/09/15/2178160.html" target="_blank" rel="noopener">nginx优化 突破十万并发</a></li><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-libev/" target="_blank" rel="noopener">使用 libevent 和 libev 提高网络应用性能</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 性能测试 </tag>
            
            <tag> C10K </tag>
            
            <tag> C100K </tag>
            
            <tag> ulimit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端架构：System Design</title>
      <link href="/31.Backend/SystemDesign-01-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
      <url>/31.Backend/SystemDesign-01-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一些概念和测试基准"><a href="#一些概念和测试基准" class="headerlink" title="一些概念和测试基准"></a>一些概念和测试基准</h1><p>本章内容包括: 系统可用性的概念和指标, 系统性能的概念和指标, 如何严谨地做性能测试.</p><h2 id="系统可用性的概念和指标"><a href="#系统可用性的概念和指标" class="headerlink" title="系统可用性的概念和指标"></a>系统可用性的概念和指标</h2><p><strong>高可用性</strong>（high availability，缩写为 HA），IT术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行<br>其度量方式，是根据系统损害、无法使用的时间，以及由无法运作恢复到可运作状况的时间，与系统总运作时间的比较。计算公式为:<br><img src="/images/system_design/Arch-HA-Exp.png" alt=""></p><p>A（可用性），MTBF(平均故障间隔)，MDT(平均修复时间)<br>在线系统和执行关键任务的系统通常要求其可用性要达到5个9标准(99.999%)。</p><ul><li>3个9：(1-99.9%) x 365 x 24 =8.76小时，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是8.76小时。</li><li>4个9：(1-99.99%) x 365 x 24 =0.876小时=52.6分钟，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是52.6分钟。</li><li>5个9：(1-99.999%) x 365 x 24 x 60 =5.26分钟，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是5.26分钟。</li></ul><p>那么X个9里的X只代表数字3~5，为什么没有1~2，也没有大于6的呢？我们接着往下计算：</p><ul><li>1个9：(1-90%)x365=36.5天</li><li>2个9：(1-99%)x365=3.65天</li><li>6个9：(1-99.9999%)x365x24x60x60=31秒</li></ul><p>可以看到1个9和、2个9分别表示一年时间内业务可能中断的时间是36.5天、3.65天，这种级别的可靠性或许还不配使用“可靠性”这个词；而6个9则表示一年内业务中断时间最多是31秒，那么这个级别的可靠性并非实现不了，而是要做到从5个9》6个9的可靠性提升的话，后者需要付出比前者几倍的成本，所以在企业里大家都只谈（3~5）个9。</p><h2 id="系统性能的概念和指标"><a href="#系统性能的概念和指标" class="headerlink" title="系统性能的概念和指标"></a>系统性能的概念和指标</h2><p>① 系统延迟(Latency): 系统在处理一个请求或一个任务时的延迟, 有平均值, 中位数, TP 三种衡量指标:</p><ol><li>平均值(Avg): 延迟的评测性能指标原则: <strong>不要用平均值!</strong>  例如测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况</li><li>中位数（Mean）: 可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。</li><li>TP指标(Top Percentile): <strong>这是最为正确的统计做法</strong> ，也就是英文中的 Top Percentile ，Top百分数，是一个统计学里的术语，与平均数、中位数都是一类。<ul><li>TP50：指在一个时间段内（如5分钟），统计该方法每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序，取第50%的那个值作为TP50 值；正确使用TP50做监控: 配置此监控指标对应的报警阀值后，需要保证在这个时间段内该方法所有调用的消耗时间至少有50%的值要小于此阀值，否则系统将会报警。</li><li>TP90: 通过上面的定义, 90%的请求中最长耗时; TP90也即要求 比这个耗时还长的请求次数 比例应该在总次数的10%以下</li><li>TP99: 与TP50/90值计算方式一致，它们分别代表着对方法的不同性能要求，TP50相对较低，TP90则比较高，TP99，TP999则对方法性能要求很高</li></ul></li></ol><blockquote><p>Amazon AWS 定义的 P99: <a href="https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/health-enhanced-metrics.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/health-enhanced-metrics.html</a></p></blockquote><p>② 吞吐量(Throughput): 每秒可处理的请求数/事务数, 等于<code>并发数/平均响应时间</code></p><ul><li><strong>QPS</strong>: Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。可用由PV粗略计算QPS的两种方法:<ul><li>按照每天80%的请求集中在20%的时间, <code>峰值QPS= (PV*80%) / (24*3600*20%)</code></li><li>按照峰值QPS是评价QPS的三倍计算, <code>峰值QPS= (PV*3) / (24*3600)</code></li></ul></li><li><strong>TPS</strong>: Transactions Per Second, 也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。</li></ul><blockquote><p>Java GC回收器的评估指标里也有吞吐量的概念: 系统总运行时间 = 应用程序耗时 + 总GC耗时。</p></blockquote><p>③ 除了 Latency 和 Throughtput , 其他的性能衡量指标还有:</p><ul><li>PV: page view</li><li>UV: user view;</li><li>VU: 并发用户数, 也叫虚拟用户数(VU), 同时请求系统的用户数. 一般情况下, 大型系统（业务量大、机器多）做性能测试 5000 个并发用户就够了, 中小型系统做性能测试 1000 个并发用户就足够了;</li></ul><h2 id="如何严谨地做性能测试"><a href="#如何严谨地做性能测试" class="headerlink" title="如何严谨地做性能测试"></a>如何严谨地做性能测试</h2><p>一般来说，性能测试要统一考虑这么几个因素：Thoughput吞吐量，Latency响应时间，资源利用（CPU/MEM/IO/Bandwidth…），成功率，系统稳定性。</p><ul><li>一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。</li><li>二，在这个响应时间的限制下，找到最高的吞吐量。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。</li><li>三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能</li><li>四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。</li><li>五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。</li><li>六、低吞吐量和网络小包的测试。有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。</li></ul><blockquote><p>@ref  <a href="https://coolshell.cn/articles/17381.html" target="_blank" rel="noopener">性能测试应该怎么做？ | | 酷 壳 - CoolShell</a></p></blockquote><h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><p>本章内容包括: 负载均衡, 限流, 隔离, 降级, 超时与重试, 回滚, 压测与预案.</p><h2 id="负载均衡与反向代理-Nginx"><a href="#负载均衡与反向代理-Nginx" class="headerlink" title="负载均衡与反向代理(Nginx)"></a>负载均衡与反向代理(Nginx)</h2><p>这里不再介绍Nginx的具体配置</p><h3 id="负载均衡-loadbalance"><a href="#负载均衡-loadbalance" class="headerlink" title="负载均衡(loadbalance)"></a>负载均衡(loadbalance)</h3><p>Nginx目前提供了HTTP七层负载均衡(ngx_http_upstream_module), 意思是在OSI第七层应用层的负载均衡, 1.9版本也开始提供TCP四层负载均衡(ngx_stream_upstream_module)</p><h4 id="upstream服务器配置"><a href="#upstream服务器配置" class="headerlink" title="upstream服务器配置"></a>upstream服务器配置</h4><p>略</p><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>几种负载均衡算法:</p><ul><li>轮询（Round Robin）</li><li>加权轮询（Weight Round Robin）</li><li>随机（Random）</li><li>加权随机（Weight Random）</li><li>源地址哈希（Hash）</li><li>一致性哈希（ConsistentHash）</li><li>最小连接数（Least Connections）</li><li>低并发优先（Active Weight）</li></ul><p>Nginx配置中常用的负载均衡:</p><ul><li>round robin(轮询): 默认的</li><li>ip哈希:<code>ip_hash</code>, 根据客户端ip</li><li>哈希:<ul><li><code>hash $uri</code>:根据uri进行哈希</li><li><code>hash $key consistent</code>:一致性哈希</li></ul></li></ul><p><strong>一致性哈希(consistent hashing)</strong>:<br>在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对K/n个关键字重新映射，其中K是哈希关键字的数量(也就是Key)，n是槽位数量(槽位指的是Node的槽位)。<br>然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p><p>一致性哈希vs传统哈希的优势:</p><ul><li>新增/减少节点, 传统哈希需要对全部Key做rehash, 一致性哈希只需…</li><li>新增/减少节点, rehash影响的节点少, 理论上只影响相邻的节点</li></ul><p>一致性哈希过程: </p><ol><li>首先求出服务器（节点）的哈希值，并将其配置到0～2^32的圆（continuum）上。// 为什么哈希范围是2^32?  当服务节点太少时，容易因为节点分部不均匀而造成数据倾斜。这种一般通过增加虚拟节点的方式解决</li><li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li><li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台memcached服务器上。</li></ol><p><img src="/images/system_design/consistent-hash.png" alt="consistent-hash"></p><ol start="4"><li>如果增加一个服务器节点, 如下图, 新增 node5 节点, 只有在圆（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响</li></ol><p><img src="/images/system_design/consistnet-hash-add-node.png" alt="consistnet-hash-add-node"></p><h4 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h4><p>主要针对在Nginx的<code>upstream</code>和<code>proxy_pass</code>进行配置, 作用是实现”多少时间内失败多少次, 则从upstream列表里摘除”</p><h4 id="upstream心跳检查"><a href="#upstream心跳检查" class="headerlink" title="upstream心跳检查"></a>upstream心跳检查</h4><p>失败重试是被动的去摘除upstream无效机器, 心跳检测可以认为是一种主动的检查并摘除无效机器, 主要在<code>upstream</code>的<code>check</code>里, 有http和tcp两种</p><h3 id="长连接-keepalive"><a href="#长连接-keepalive" class="headerlink" title="长连接(keepalive)"></a>长连接(keepalive)</h3><ol><li>client 与 nginx之间的长连接: <code>http</code>里的<code>keepalive_timeout 300s 300s;</code><ul><li>第一个参数: client和nginx建立的长连接, 如果在此时间内没有实际消息发送, nginx将主动关闭此连接（默认是75秒)</li><li>第二个参数: nginx向client发送response的http头, 其中的<code>Keep-Alive: timeout=xx</code></li></ul></li><li>nginx 与 upstream之间的长连接: <code>upstream</code>里的<code>keepalive 100</code>这里的100指的是”每个Worker与upstream服务器可缓存的最大连接数”</li></ol><p>参考: <a href="/31.Backend/反向代理-Nginx/" title="反向代理-Nginx">反向代理-Nginx</a></p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p><h3 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h3><p>即可以降级的功能点, 降级服务需要从服务端链路考虑, 根据用户访问的服务调用链路决定哪里可以降级. 一般情况下可以考虑降级的点有:</p><ul><li>页面降级(整个页面or页面片段):非核心业务的页面, 在紧急情况下可以降级, 可以利用nginx把该页面直接跳转一个静态页</li><li>页面异步请求:比如异步加载的信息, 在紧急情况下可以降级</li><li>非核心功能降级:比如商品详情页的推荐/热销</li><li>读降级:紧急情况下只读缓存, 适用于一致性要求不高的情况</li><li>写降级:在高并发抢购这种情景下, 可以先更新cache, 然后异步写回数据库</li><li>风控降级:识别机器人, 根据用户画像和用户风控等级降级, 需要提前做好用户风控等级的功能</li></ul><blockquote><p>降级后的处理方式一般有:返回默认值, 返回静态页面, 从缓存读数据而不是数据库</p></blockquote><h3 id="自动降级"><a href="#自动降级" class="headerlink" title="自动降级"></a>自动降级</h3><ul><li>超时降级: 访问数据库 或 非本地接口(RPC, HTTP)超时, 需要提前设置合理的超时时间/重试机制/重试次数</li><li>故障降级: 远程调用的接口RPC抛异常, HTTP服务500错误等,</li><li>流量降级: 超过限流阈值时..</li></ul><h3 id="手动开关降级"><a href="#手动开关降级" class="headerlink" title="手动开关降级"></a>手动开关降级</h3><p>开关可以放在Redis, Zookeeper上.</p><h3 id="读写服务降级"><a href="#读写服务降级" class="headerlink" title="读写服务降级"></a>读写服务降级</h3><ul><li>库存扣减案例: 正常情况下扣减Redis, 同步扣减DB, 当流量过大时, 降级为发送一条扣减消息, 然后异步写入DB实现最终一致性</li></ul><h3 id="多级降级"><a href="#多级降级" class="headerlink" title="多级降级"></a>多级降级</h3><p>从用户到系统, 降级离用户越近, 最终落到后端系统的QPS越低, 对后端系统的保护就越好</p><ul><li>页面JS降级开关</li><li>接入层降级开关, 一般是Nginx</li><li>后端应用降级开关</li></ul><h3 id="通过-Hystrix实现熔断降级"><a href="#通过-Hystrix实现熔断降级" class="headerlink" title="通过 Hystrix实现熔断降级"></a>通过 Hystrix实现熔断降级</h3><p>@todo</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>@todo</p><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>几种常用<strong>容错策略</strong>：</p><ul><li>失效转移（failover）: 当出现失败，重试其他服务器，通常用于读操作等幂等行为(保证调用 1 次与 N 次效果相同)，重试会带来更长延迟。</li><li>快速失败（failfast）: 只发起一次调用，失败立即报错，通常用于非幂等性的写操作。</li><li>失效安全（failsafe）: 出现异常时忽略，但记录这一次失败，存入日志中。// 失败安全策略的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。</li><li>失败通知（failback）: 客户端需要能够获取到服务调用失败的具体信息，通过对失败错误码等异常信息的判断，决定后续的执行策略，例如非幂等性的服务调用。// Dubbo中的Failback策略中，如果调用失败，则此次失败相当于Failsafe，将返回一个空结果。而与Failsafe不同的是，Failback策略会将这次调用加入内存中的失败列表中，对于这个列表中的失败调用，会在另一个线程中进行异步重试，重试如果再发生失败，则会忽略，即使重试调用成功，原来的调用方也感知不到了。因此它通常适合于，对于实时性要求不高，且不需要返回值的一些异步操作。</li></ul><h2 id="超时与重试"><a href="#超时与重试" class="headerlink" title="超时与重试"></a>超时与重试</h2><p>在实际开发过程中，笔者见过太多故障是因为没有设置超时或者设置得不对而造成的。而这些故障都是因为没有意识到超时设置的重要性而造成的。如果应用不设置超时，则可能会导致请求响应慢，慢请求累积导致连锁反应，甚至造成应用雪崩。<br>而有些中间件或者框架在超时后会进行重试（如设置超时重试两次），读服务天然适合重试，但写服务大多不能重试（如写订单，如果写服务是幂等的，则重试是允许的），重试次数太多会导致多倍请求流量，即模拟了DDoS攻击，后果可能是灾难，因此，务必设置合理的重试机制，并且应该和熔断、快速失败机制配合。</p><h3 id="Nginx超时设置"><a href="#Nginx超时设置" class="headerlink" title="Nginx超时设置"></a>Nginx超时设置</h3><ol><li>客户端超时设置: 对于客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。<ul><li><code>keepalive_timeout time [header_timeout]</code>：<ul><li>time默认是75s,  表示长连接的超时时间(客户端在75s期间没有任何请求,  Nginx将会主动发送FIN关闭连接);</li><li>header_timeout会通过HTTP头<code>Keep-Alive: timeout=xx</code>告知客户端长连接超时时间,</li></ul></li></ul></li><li>上游服务器(upstream)超时:<ul><li>超时设置:<code>proxy_connect_timeout time</code>：与后端/上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</li><li>重试设置:<ul><li><code>proxy_next_upstream_tries number</code>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</li><li><code>proxy_next_upstream_timeout time</code>：设置重试最大超时时间，默认0表示不限制。</li></ul></li></ul></li><li>DNS解析超时:  @todo</li></ol><h3 id="Web容器超时设置"><a href="#Web容器超时设置" class="headerlink" title="Web容器超时设置"></a>Web容器超时设置</h3><p>以Tomcat为例:</p><ul><li><code>connectionTimeout</code>: 当client与tomcat建立连接之后, 在”connectionTimeout”时间之内, 仍然没有得到client的请求数据, 此时连接将会被断开, connectionTimeout只会在链接建立之后, 得到client发送http-request信息前有效.</li><li><code>socket.soTimeout</code>: 从收到client请求后,  到返回数据, 这段超时时间  @Uncertain</li><li><code>keepAliveTimeout</code>: 当无实际数据交互时，连接被保持的时间，单位：毫秒。在未指定此属性时，将使用connectionTimeout作为keepAliveTimeout。</li></ul><blockquote><p>不过我们通常在tomcat前面还有nginx等代理服务器，我们通常希望链接keepAlive的机制由代理服务器控制，比如nginx来决定链接是否需要“保持活性”（注意，与keep_alive不同），当然nginx服务器只会保留极少的长连接，几乎所有的链接都会在使用结束后主动close；有nginx与client保持，而不再是tomcat与client保持。</p></blockquote><h3 id="Apache-HttpClient-客户端-超时设置"><a href="#Apache-HttpClient-客户端-超时设置" class="headerlink" title="Apache HttpClient(客户端)超时设置"></a>Apache HttpClient(客户端)超时设置</h3><ul><li>connectionTimeout: 建立连接超时时间,  指Client发出请求后,  到建立连接这段超时时间,  如果在该时间仍没有完成连接的建立会抛出connectionTimeout异常;</li><li>socketTimeout: 等待响应超时时间,  指Client对Url发起请求(连接已经建立),  到收到服务端的Response这段超时时间</li></ul><h3 id="数据库客户端连接超时设置"><a href="#数据库客户端连接超时设置" class="headerlink" title="数据库客户端连接超时设置"></a>数据库客户端连接超时设置</h3><p>@todo</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章主要介绍了如何在Web应用访问的整个链路上进行超时时间设置。通过配置合理的超时时间，防止出现某服务的依赖服务超时时间太长且响应慢，以致自己响应慢甚至崩溃。<br>客户端和服务器端都应该设置超时时间，而且客户端根据场景可以设置比服务器端更长的超时时间。如果存在多级依赖关系，如A调用B，B调用C，则超时设置应该是A&gt;B&gt;C，否则可能会一直重试，引起DDoS攻击效果。不过最终如何选择还是要看场景，有时候客户端设置的超时时间就是要比服务器端的短，可以通过在服务器端实施限流/降级等手段防止DDoS攻击。</p><p>超时之后应该有相应的策略来处理，常见的策略有重试（等一会儿再试、尝试其他分组服务、尝试其他机房服务，重试算法可考虑使用如指数退避算法）、摘掉不存活节点（负载均衡/分布式缓存场景下）、托底（返回历史数据/静态数据/缓存数据）、等待页或者错误页。对于非幂等写服务应避免重试，或者可以考虑提前生成唯一流水号来保证写服务操作通过判断流水号来实现幂等操作。<br>在进行数据库/缓存服务器操作时，记得经常检查慢查询，慢查询通常是引起服务出问题的罪魁祸首。也要考虑在超时严重时，直接将该服务降级，待该服务修复后再取消降级。</p><p>对于有负载均衡的中间件，请考虑配置心跳/存活检查，而不是惰性检查。<br>超时重试必然导致请求响应时间增加，最坏情况下的响应时间=重试次数×单次超时时间，这很可能严重影响用户体验，导致用户不断刷新页面来重复请求，最后导致服务接收的请求太多而挂掉，因此除了控制单次超时时间，也要控制好用户能忍受的最长超时时间。<br>超时时间太短会导致服务调用成功率降低，超时时间太长又会导致本应成功的调用却失败了，这也要根据实际场景来选择最适合当前业务的超时时间，甚至是程序动态自动计算超时时间。<br>比如商品详情页的库存状态服务，可以设置较短的超时时间，当超时时降级返回有货，而结算页服务就需要设置稍微长一些的超时时间保证确实有货。在实际开发中，不要轻视超时时间，很多重大事故都是因为超时时间不合理导致的，设置超时时间一定是只有好处没有坏处的，请立即Review你的代码吧。</p><blockquote><p>回顾: TCP协议里的重试机制:<br>Client发给Server端SYN包后, Server端要返给Client一个SYN-ACK, 然后Server要等待Client发过来的ACK,<br>Server发送SYN-ACK并等待ACK的过程是有重试机制的, 重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s。</p></blockquote><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><ul><li>进线程隔离</li><li>集群隔离</li><li>机房隔离</li><li>读写隔离</li><li>动静隔离: 静态资源放CDN</li><li>爬虫隔离</li><li>热点隔离: 诸如秒杀, 抢购做成独立系统</li><li>资源隔离</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><ul><li>令牌桶:</li><li>漏桶:</li></ul><h3 id="应用级限流"><a href="#应用级限流" class="headerlink" title="应用级限流"></a>应用级限流</h3><ul><li>限制总并发数/连接数: Tomcat的几个参数 acceptCount, maxConnections, maxThreads</li><li>限制单个接口的请求数:<ul><li>限制某个时间窗口的请求数:用Guava的Cache, 时间戳做Key, 访问次数AtomicLong做Value. . . 缺点是无法应对突发流量, 瞬时请求可能都被允许</li><li>平滑限流:Guava的RateLimiter提供的令牌桶算法可以对请求进行速率平均化, 比如5request/秒, 每隔200ms处理一个请求</li></ul></li></ul><h3 id="Nginx层限流"><a href="#Nginx层限流" class="headerlink" title="Nginx层限流"></a>Nginx层限流</h3><p>Nginx提供了两个限流模块:</p><ul><li>限制总并发数的<code>ngx_http_limit_conn_module</code></li><li>漏桶算法的<code>ngx_http_limit_req_module</code></li></ul><h1 id="高性能方案"><a href="#高性能方案" class="headerlink" title="高性能方案"></a>高性能方案</h1><p>本章内容: 缓存, 连接池, 异步并发, 数据库拆分, 任务系统拆分, 队列.</p><p>有关C10K、C100K单机系统，参考： <a href="https://whatsrtos.github.io/基础架构/Arch-架构-并发系统-C100K/" target="_blank" rel="noopener">架构-并发系统-C100K</a></p><h2 id="应用级缓存"><a href="#应用级缓存" class="headerlink" title="应用级缓存"></a>应用级缓存</h2><p>本章以Java应用缓存为例.</p><h3 id="缓存回收策略"><a href="#缓存回收策略" class="headerlink" title="缓存回收策略"></a>缓存回收策略</h3><ul><li>基于空间和容量: 超过xx时回收</li><li>基于存活时间(TTL): 缓存数据从创建开始计算, 过期则清除</li><li>基于Java GC:<ul><li>软引用</li><li>弱引用</li></ul></li><li>基于回收算法:<ul><li>FIFO</li><li>LRU: Least Recently Used, 最近最不常访问的被淘汰, 访问时间距离现在最久远的被淘汰(较常用)</li><li>LFU: Least Frequently Used, 在一段时间内访问次数最少的被淘汰, 访问频率最少的被淘汰(可能需要预热)</li></ul></li></ul><h3 id="Java应用级缓存的类型"><a href="#Java应用级缓存的类型" class="headerlink" title="Java应用级缓存的类型"></a>Java应用级缓存的类型</h3><ul><li>堆内缓存: 用Java软引用/弱引用对象作为缓存, 不需要序列化. Guava的Cache, Ehcache3.x</li><li>堆外缓存: 缓存在JVM内存之外, 减少GC次数, 但是需要序列化的时间开销, Ehcache3.x, MapDB</li></ul><h3 id="缓存的设计模式"><a href="#缓存的设计模式" class="headerlink" title="缓存的设计模式"></a>缓存的设计模式</h3><p>首先介绍三个名词:</p><ul><li><strong>SoR</strong>(SystemofRecord): 记录系统, 一般是DB;</li><li><strong>Cache</strong>: Cache的访问速度比SoR要快, 数据放在Cache中可以提升访问速度, 减少回源次数;</li><li><strong>回源</strong>: 缓存没有命中, 需要去SoR取数据, 这叫做回源;</li></ul><h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h4><p>即代码围绕着缓存写, 由业务层的代码读取/更新缓存.</p><ul><li>读:先读Cache, 没有读到再读SoR, 并更新Cache</li><li>写(更新):<ul><li>方案1: 先更新SoR, 再更新Cache</li><li>方案2: 先更新SoR, 再失效Cache, 读取的时候再把SoR的数据写入Cache</li></ul></li></ul><p>CacheAside存在的问题:<br>如果并发更新Cache, 会出现Cache和SoR数据不一致的情况(A更新了SoR, 还没来得及更新Cache, B线程插入进来更新SoR并更新Cache, 之后A线程更新Cache), 这种有两种解决方式:</p><ol><li>用canal订阅数据库(SoR)的 binlog, 增量更新Cache, 缓存的更新会有延迟;</li><li>通过对请求合理的hash, 让同一个读服务落到同一个实例;</li></ol><h4 id="Cache-as-SoR"><a href="#Cache-as-SoR" class="headerlink" title="Cache as SoR"></a>Cache as SoR</h4><p>即Cache和SoR是一个整体, 业务层代码只对Cache进行读写, 然后Cache再委托给SoR进行真实的读写. 有三种实现模式: Read-Throught, Write-Throught, Write-Behind:</p><ul><li>Read-Throught: 读cache, 如果没有读到, 由cache把SoR的数据更新到缓存里. GuavaCache提供了此模式, 创建Cache时需要指定一个CacheLoader, 从Cache未能读到数据时, GuavaCache委托CacheLoader从SoR读取, 用户代码只需要调用<code>cache.get()</code></li><li>Write-Throught: 用户调用<code>cache.set()</code>, 缓存更新后, 同步写到SoR, 不需要用户代码干预</li><li>Write-Behind: 与上面的区别是, Write-Behind是异步批量写SoR</li></ul><h4 id="Copy-Pattern"><a href="#Copy-Pattern" class="headerlink" title="Copy Pattern"></a>Copy Pattern</h4><ul><li>Copy-On-Read: 读时复制</li><li>Copy-On-Write: 写时复制</li></ul><h2 id="数据库拆分-分库分表"><a href="#数据库拆分-分库分表" class="headerlink" title="数据库拆分(分库分表)"></a>数据库拆分(分库分表)</h2><ul><li>垂直切分: 一般根据业务来<ul><li>垂直分表: 通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中</li><li>垂直分库: 按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。</li></ul></li><li>水平切分:<ul><li>哈希分库: 比如根据自增主键对库的总数取余操作, 可以多次哈希, 第一次哈希分库, 第二次分表:<ul><li>例子: UserId后四位mod32分到32个库中，同时再将UserId后四位Div32Mod32将每个库分为32个表，共计分为1024张表。</li></ul></li><li>范围分库: 比如根据自增主键范围切分,<ul><li>优点: 单表大小可控，天然水平扩展。</li><li>缺点: 无法解决集中写入瓶颈的问题。</li></ul></li></ul></li></ul><h3 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h3><ul><li>跨库join的问题解决方案:<ul><li>字段冗余</li><li>Redis存储索引</li></ul></li><li>夸库事务: @todo</li></ul><h2 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h2><ul><li>利用数据库自增ID:<ul><li>优点：最简单。</li><li>缺点：单点风险、单机性能瓶颈。</li></ul></li><li>TwitterSnowflake<ul><li>优点：高性能高可用、易拓展。</li><li>缺点：需要独立的集群以及ZK。</li></ul></li><li>UUID, GUID</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>这里是一些”一句话解决方案”.</p><h2 id="最佳实践list"><a href="#最佳实践list" class="headerlink" title="最佳实践list"></a>最佳实践list</h2><ul><li>LVS/F5/HAProxy负载均衡 -&gt; Nginx/Apache -&gt; Redis/Memcached</li><li>Kafka，ActiveMQ负责解耦的消息队列</li><li>RPC框架Thrift, 序列化Protobuf</li><li>分布式框架Zookeeper</li><li>Mysql分表分库的Cobar</li><li>通用搜索引擎ElasticSearch</li></ul><h2 id="如何存储密码"><a href="#如何存储密码" class="headerlink" title="如何存储密码"></a>如何存储密码</h2><ul><li>bcrypt:带盐的散列算法, 可以指定costfactor, 10表示2^10次方次运算, 返回的散列值包括盐和加密后的文本</li><li><a href="http://www.infoq.com/cn/news/2016/12/How-Dropbox-securely-passwords" target="_blank" rel="noopener">Dropbox是如何安全地存储用户密码的</a> : <code>AES256(bcrypt(SHA512(pwd), salt(10)))</code></li><li><a href="https://www.zhihu.com/question/20299384" target="_blank" rel="noopener">加盐密码保存的最通用方法是？ - 知乎</a> @todo</li></ul><hr><h1 id="附录-名词解释"><a href="#附录-名词解释" class="headerlink" title="附录:名词解释"></a>附录:名词解释</h1><ul><li>高可用High-Availability、高可扩展性(高可伸缩性)High-Scalability</li><li>解耦LooselyCoupled</li><li>吞吐量Throughput（QPS/TPS)、并发量C10K</li><li>冗余Redundancy、分区Partitions、缓存Caches、代理Proxies、索引Indexes、队列Queues</li><li>集群Cluster、主从Master-Slave、水平/垂直切分Sharding</li><li>请求负载均衡LoadBalancing、请求路由Route、状态复制Replication</li><li>故障转移Failover、故障回复Failback、心跳检测Healthcheck/Heartbeat</li><li>纵向扩展Scale-up、横向扩展Scale-out</li><li>自动升降级Auto-upgrade/downgrade</li><li>scaleup:纵向扩展, 指提高单台机器的存储(RAM, HD)上限</li><li>scaleout:横向扩展, 多台主机</li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳</a></li><li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a></li></ul><p><img src="/images/system_design/亿级流量网站架构核心技术.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 架构 </tag>
            
            <tag> System Design </tag>
            
            <tag> 高可用 </tag>
            
            <tag> 高性能 </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> 限流 </tag>
            
            <tag> 分库分表 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Serverless</title>
      <link href="/31.Backend/Serverless/"/>
      <url>/31.Backend/Serverless/</url>
      
        <content type="html"><![CDATA[<h1 id="serverless"><a href="#serverless" class="headerlink" title="serverless"></a>serverless</h1><ul><li>Serverless ≈ BaaS+ FaaS</li><li>区分IaaS、PaaS、SaaS、BaaS、FaaS<ul><li>IaaS(Infrastructure as a Service)：提供服务器/vm等</li><li>PaaS(Platform as a Service)：提供运行平台，与IaaS相比，对用户屏蔽了基础性能监控/维护等，docker是PaaS使用最多的技术</li><li>SaaS(Software as a Service)：提供完成的业务服务</li><li>BaaS：后端即服务，提供如DB/MQ等</li><li>FaaS：函数即服务</li></ul></li><li>架构变迁史： C/S，MVC，SOA，微服务，云原生，Serverless</li><li>使用Serverless架构的优势:<ul><li>降低支出成本: 无需考虑为一个小型服务申请IaaS/PaaS资源</li><li>降低维护/开发成本(开发中无需做devOps, 也无需了解Spring完整服务框架, 仅维护一个function)</li></ul></li></ul><p>@ref</p><ul><li>理解 Serverless · Kubernetes Handbook - Kubernetes 中文指南/云原生应用架构实践手册 · Jimmy Song：<a href="https://jimmysong.io/kubernetes-handbook/usecases/understanding-serverless.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/usecases/understanding-serverless.html</a></li><li>爱奇艺内容中台之Serverless应用与实践：<a href="https://mp.weixin.qq.com/s/v1lEayBx9C_SeQcnh4ek4g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/v1lEayBx9C_SeQcnh4ek4g</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-04应用-消息队列</title>
      <link href="/31.Backend/Redis-04%E5%BA%94%E7%94%A8-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/31.Backend/Redis-04%E5%BA%94%E7%94%A8-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>Redis方案实现延时队列有哪些?</li><li>优缺点比较?</li></ul><ul><li>使用 lpush/rpop 或者 rpush/lpop // 缺点: 循环pop会导致增加无用的qps</li><li>客户端 使用 blpop 或者 brpop // 缺点: 没有消息时超时后断开(超过客户端的soTimeout), 需要保证重连</li><li>zadd k time field , time是消息要被处理的时间, 先 get k判断时间, 然后 zrem 掉这个key, 每个争抢的客户端通过 zrem返回值确认自己是否抢到</li><li>使用zadd 作为消息队列仍然有问题: 多个客户端争用一个消息, 没有消息的确认模式(ack)</li></ul><p>@ref:</p><ul><li><a href="https://blog.csdn.net/qq_34212276/article/details/78455004" target="_blank" rel="noopener">Redis学习笔记之十：Redis用作消息队列_数据库_yamikaze的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/wzbwzh/article/details/82876299" target="_blank" rel="noopener">Redis 异步消息队列与延时队列_数据库_wzbwzh的专栏-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-04应用-分布式锁</title>
      <link href="/31.Backend/Redis-04%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/31.Backend/Redis-04%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>分布式锁的使用场景?</li><li>分布式锁的设计要点?</li><li>如何用Redis实现分布式锁?</li></ul><p>➤ 什么情况需要分布式锁:</p><p>多个Client操作一个资源并保证互斥性, 进程内的锁机制无法实现</p><p>➤ 设计要点:</p><ul><li>互斥性: A/B Client 同时只能有一个抢占到锁;</li><li>锁超时: 如果抢到锁的Client挂掉, 锁仍能在超时后被解锁;</li><li>高可用: Redis节点宕机仍能保证上述特性;</li></ul><p>➤ 方案1:</p><ul><li>加锁: <code>SET k random_val NX PX 3000</code>,</li><li>加锁失败: 失败后休眠一段时间再尝试</li><li>放锁: 释放前先Get, 如果值等于自己的 random_val, 才可以删除K // 避免线程1醒来后, 已经超时的情况, 另一个线程2已经SET了锁, 线程1误删Key的情况<ul><li>释放前为什么要先get, 考虑如下情况, A获取到了锁, 但A处理过程耗时很长(A的锁超时了,但A还在正常运行), A的锁过期并被清理, 线程B抢占到锁, 这时候A处理完任务开始尝试 Del自己的锁…</li></ul></li><li>问题: <code>SET NX PX</code>这种方式也有潜在的问题, 因为是在单Redis上加锁, 如果master上获取了锁, 但slave还没来得及同步锁, master就宕机了, slave成为新master, 这时候其他Client是可以抢到锁的;</li></ul><p>➤ 方案2: // 不推荐</p><ul><li>加锁: <code>SETNX k &lt;timestamp + timeout&gt;</code>, 成功则获得锁;</li><li>超时: 加速的指令可以看到K没有设置过期, 如果获得锁的Client挂掉或者休眠, 需要其他线程来删除K, 具体做法: 其他没抢到锁的客户端, Get K发现已经超时, 则发起 <code>GETSET k &lt;timestamp + timeout&gt;</code> , <code>GETSET</code>会返回K之前的值(上个K的过期时间), 考虑多个线程同时去<code>GETSET</code>的情况:<ul><li><code>GETSET</code> 返回的时间比当前时间更小, 获取锁成功;</li><li>如果已经有另个线程<code>GETSET</code>了Key, <code>GETSET</code> 返回的时间比当前时间更大, 获取锁失败, 继续等待;</li></ul></li><li>放锁: 删除Key</li><li>问题: SETNX 获得锁的线程A因为其他原因阻塞很久, 直到锁已经超时并被其他客户端 GETSET掉, 这时候线程A恢复并del了k</li></ul><p>➤ RedLock方案:</p><ul><li>RedLock为了解决什么: 上面提到的分布式锁是基于单Redis实例, RedLock是在多Redis实例上实现的分布式锁(更可靠)</li><li>RedLock还可保证当大多数Redis节点可用, 就可以正常加锁放锁</li><li>加锁(无锁状态下抢占到锁): 客户端向所有Redis 都发起 <code>SET k client_random_val NX PX 3000</code>, 这个例子里锁的总超时是3秒, 假设这一阶段消耗了x秒, 那么锁的实际可用时间=<code>3-x</code>, 如果大多数(N/2 + 1)实例都返回成功, 并且锁的有效时间大于0, 才算是获取锁成功;</li><li>测锁(尝试去加锁,有没有其他Client已经获取了锁): @todo</li><li>加锁失败: 如果无法在多数实例上获取到锁, 则加锁失败, Client应向已经成功的实例发起 <code>DEL k</code>, 为了防止过多重试, 客户端获取锁失败需要稍等一会才能再次发起锁请求;</li><li>解锁: 向所有Redis发起 DEL …</li><li>问题: 假设5个实例, Client从3个实例都取得了锁, 但这时候某个实例重启了且丢失了锁, 解决方法是:<ul><li>redis开启fsync, 同步到磁盘, 这样重启的时候可以从磁盘备份恢复数据(但一般情况下锁超时时间远小于重启耗时)</li><li>Client尝试抢锁, 如果发现有实例宕机, 则等待一段时间(大于锁的TTL)</li></ul></li></ul><p>➤ @ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/40915772" target="_blank" rel="noopener">基于 Redis 的分布式锁 Redlock - 知乎</a></li><li><a href="https://blog.brickgao.com/2018/05/06/distributed-lock-with-redlock/" target="_blank" rel="noopener">通过 Redlock 实现分布式锁 | Brickgao’s</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-04应用-缓存</title>
      <link href="/31.Backend/Redis-04%E5%BA%94%E7%94%A8-%E7%BC%93%E5%AD%98/"/>
      <url>/31.Backend/Redis-04%E5%BA%94%E7%94%A8-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h1><ul><li><p>使用Redis做为LRU缓存需要同时指定如下参数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory 100mb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure></li><li><p>设置<code>maxmemory</code>为0表示无限制, 这也是64位系统的默认选项, 32位系统使用3GB的默认值</p></li><li><p>内存淘汰策略 <code>maxmemory-policy</code>支持的所有选项:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">noeviction     // 超过maxmemory写入报错</span><br><span class="line">allkeys-lru    // 在所有Key中,LRU方式淘汰</span><br><span class="line">allkeys-random // 在所有Key中,随机淘汰</span><br><span class="line">volatile-lru   // 在设置了过期时间的Key中,LRU淘汰</span><br><span class="line">volatile-random // 在设置了过期时间的Key中,随机淘汰</span><br><span class="line">volatile-ttl    // 在设置了过期时间的Key中,按TTL淘汰</span><br></pre></td></tr></table></figure></li><li><p>Redis如何实现Key的 <strong>淘汰策略</strong>?</p><ul><li>定期(间隔100ms)随机选取N个key, 然后使用<code>maxmemory-policy</code>定义的选项进行淘汰;</li><li>通常使用<code>LinkedHashMap</code>的方式实现LRU缓存(HashMap实现O(1)的get/set, 同时维护链表记录最近访问), 但Redis并没有使用这种方案, 因为每个节点存储链表指针非常耗费空间, Redis选择了 @todo</li></ul></li><li>过期策略(删除超过TTL的Key):<ul><li>惰性删除: 每次get 的时候去检查并删除</li><li>定期删除: 每隔100ms Redis随机抽取一些Key, 检查是否过期, 并删除</li><li>定时删除: 在给Key设定TTL的时候同时设置一个定时器 // Redis不使用这种, 因为需要大量的定时器消耗资源</li></ul></li><li><code>maxmemory-samples</code>的值越大，Redis的近似LRU算法就越接近于严格LRU算法，但是相应消耗也变高，对性能有一定影响，样本值默认为5。</li></ul><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><ul><li>内存淘汰策略(Eviction policies): Redis 内存不足时触发内存淘汰策略(拒绝/清理)</li><li>内存淘汰策略需要配合 maxmemory 参数一起使用:</li></ul><p>@ref:</p><ul><li><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">Using Redis as an LRU cache – Redis</a></li><li><a href="https://juejin.im/post/5d8bf523e51d4577ff0d9e8c" target="_blank" rel="noopener">Redis的过期策略及内存淘汰机制 - 掘金</a></li><li><a href="https://zhuanlan.zhihu.com/p/34133067" target="_blank" rel="noopener">LRU原理和Redis实现——一个今日头条的面试题 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-03主从同步</title>
      <link href="/31.Backend/Redis-03%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
      <url>/31.Backend/Redis-03%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>➤ 2.8版本之前, Redis的主从同步分为”同步”和”命令传播”两个阶段</p><ul><li>当slave实例执行<code>SLAVEOF</code>命令时, 会向master发送<code>SYNC</code>命令</li><li>master收到命令开始执行<code>BGSAVE</code>, 把内存数据存为RDB格式的文件, 同时在一个缓冲区记录从当前以后的所有写命令.</li><li>master把RDB文件发送给slave, 然后再将缓冲区的数据发送给slave.</li><li>Slave写入完成, 主从数据一致, 进入传播阶段, 每当master有数据更新, 把更新的数据传播给Slave</li><li>2.8版本的主从同步存在的问题: 每次从服务器发送<code>SYNC</code>命令都会导致主服务器执行<code>BGSAVE</code>, 主服务器生成和传输RDB文件的消耗巨大;</li></ul><p>➤ 2.8版本之后的同步:</p><ul><li>完整的同步过程仍是分为”同步”和”命令传播”两个状态, 但并不是每次同步过程都会执行’BGSAVE同步’的步骤, 可能直接进入’命令传播’阶段’;</li><li>判断是否执行第一步骤, 是由 “复制偏移量” / “复制积压缓冲区” / runnid 共同决定的<ul><li>master/slave服务器都会存储复制偏移量, master存储的是”向从服务器发送了多少字节”, slave存储的是”从主服务器同步了多少字节”;</li><li>master还有一个默认1MB大小的”复制积压缓冲区”, 每次master有数据更新, 除了向slave传播, 还会向这个缓冲区写入, 缓冲区大小固定,先进先出 缓冲区存储了每个偏移量和偏移量对应的字节;</li><li>slave还会存储已同步的master的 run id;</li></ul></li><li>slave 向 master发送<code>PSYNC</code>开始同步, 同时还将存储的 run id发送给 master, 如果 runid和 master的不一样, 则 master开始完整同步的第一步骤;</li><li>如果 runnid一致, master开始检查 slave发来的偏移量n, 检查n+1是否在缓冲区, 如果n+1不在缓冲区内(主从复制差距大于1MB), 则开始完整同步第一个步骤;</li><li>master/slave同步完成, slave每秒向master发送<code>REPLCONF ACK &lt;replication_offset&gt;</code>, 其中 <code>replication_offset</code> 是从服务器当前的复制偏移量, 这个命令有三个作用<ul><li>作为主从服务器的心跳检查</li><li>同步复制偏移量</li><li>辅助实现 min-slaves 选项: <code>min-slaves-to-write 3</code>, <code>min-slaves-max-lag 10</code>, 这两个配置选项表示: 从服务器数量小于3, 且从服务器写入延迟大于10s, 主拒绝写入</li></ul></li></ul><p><img src="/images/redis/Redis复制积压缓冲区.png" alt="Redis复制积压缓冲区"></p><p>➤ Redis的主从一致性分析:</p><ul><li><p>非强一致性: 向 Master进行写操作, 与”Master向Slave同步数据”操作, 是异步的. 客户端向Master写数据并成功返回时, 不能保证Slave也同步了刚写入的数据, 故非强一致性;</p></li><li><p>符合最终一致性: 即使主从网络断开或从宕机, 当恢复后Slave会采取多种策略追赶主节点的数据.</p></li></ul><blockquote><p>@ref <a href="https://zhuanlan.zhihu.com/p/55532249" target="_blank" rel="noopener">一文让你明白Redis主从同步 - 知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-03集群-Sharding</title>
      <link href="/31.Backend/Redis-03%E9%9B%86%E7%BE%A4-Sharding/"/>
      <url>/31.Backend/Redis-03%E9%9B%86%E7%BE%A4-Sharding/</url>
      
        <content type="html"><![CDATA[<h2 id="分片方案（Redis-Sharding）"><a href="#分片方案（Redis-Sharding）" class="headerlink" title="分片方案（Redis Sharding）"></a>分片方案（Redis Sharding）</h2><p>Redis Sharding是一种客户端Sharding方式。<br>Java redis客户端驱动<code>jedis</code>，已支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool, jedis的特点:</p><ul><li>采用一致性哈希算法(consistent hashing)，将key和节点name同时hashing，采用的算法是MURMUR_HASH。采用一致性哈希而不是采用简单类似哈希求模映射的主要原因是当增加或减少节点时，不会产生由于重新匹配造成的rehashing。一致性哈希只影响相邻节点key分配，影响量小。</li><li>ShardedJedis支持keyTagPattern模式，即抽取key的一部分keyTag做sharding，这样通过合理命名key，可以将一组相关联的key放入同一个Redis节点，这在避免跨节点访问相关数据时很重要。</li></ul><p>➤ Redis Sharding 方案:</p><ul><li>通过客户端进行Sharding, 在Client侧做Sharding,  比如 Jedis 提供的 ShardedJedis:</li><li>ShardedJedis特性:<ul><li>使用虚拟节点, 使Key在Redis节点的分布更均匀, 如果一个节点挂掉, 不再是相邻的节点受影响. 每个实体节点默认有160个虚拟节点, ShardedJedis还支持权重, 虚拟节点个数 = <code>节点权重 x 160</code></li><li>ShardedJedis使用了<code>MurMur Hash</code>做Hash函数, <code>MurMur Hash</code>相比较一般Hash算法, 对于规律性较强的Key随机分布的表现更好.</li><li>支持<code>keyTagPattern</code>模式, 只抽取Key的一部分做Hash, 通过合理命名Key, 可以将相关的Key放入同一个Redis节点.</li></ul></li><li>扩容问题 – presharding:<ul><li>需要扩容时, 实际是把小的Redis实例数据复制到大的Redis实例, 复制完成后, 大的Redis实例替换小的Redis实例;</li><li>需要扩容的Redis设为主, 新Redis设置为从, 完成数据同步后, 原实例的Shard给新实例用</li></ul></li></ul><h3 id="预分片（presharding）"><a href="#预分片（presharding）" class="headerlink" title="预分片（presharding）"></a>预分片（presharding）</h3><p>@todo</p><h2 id="代理中间件（Tair-Codis）"><a href="#代理中间件（Tair-Codis）" class="headerlink" title="代理中间件（Tair/Codis）"></a>代理中间件（Tair/Codis）</h2><p>上面分别介绍了多Redis服务器集群的两种方式，它们是基于客户端sharding的<code>Redis Sharding</code>，和基于服务端sharding的<code>Redis Cluster</code>。</p><p>Pre-Sharding方案实际上可以理解为预先分配一个相当大的集合，对Key哈希的结果落在这个集合中，集合的每个元素又与具体的物理节点存在多对一的路由映射关系，这张路由表由一个配置中心进行维护。<br>回过头来再细想下，一致性哈希中的虚拟节点，实际上也可以归类到Pre-Sharding方案中。换句话说，只要是key经过两次哈希，第一次Hash到虚拟节点，第二次Hash到物理节点，都可以算作Pre-Sharding。只不过区别在于，一致性哈希的第二次Hash其路由表是按照算法固定的，Tair/Codis的第二次Hash其路由表是第三方可配的。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>详见: <a href="http://engineering.xueqiu.com/blog/2014/12/26/redis-capacity-planning/" target="_blank" rel="noopener">Redis集群的数据划分与扩容探讨 - Xueqiu Engineering Blog</a> @Archived</p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-03集群-Cluster</title>
      <link href="/31.Backend/Redis-03%E9%9B%86%E7%BE%A4-Cluster/"/>
      <url>/31.Backend/Redis-03%E9%9B%86%E7%BE%A4-Cluster/</url>
      
        <content type="html"><![CDATA[<p>对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点像浏览器页面的302 redirect跳转。客户端不需要连接集群所有节点,只要连接集群中任意一个节点即可。</p><ul><li>Redis Cluster中，Sharding采用slot(槽)的概念，一共分成16384个槽，这有点类pre sharding思路。</li><li>对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。<code>CRC16(key)%16384</code>计算Key属于哪个槽</li><li>Redis集群中的每个node(节点)负责分摊这16384个slot中的一部分。当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。</li><li>为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。</li><li>如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点。这非常类似前篇文章提到的Redis Sharding场景下服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。</li></ul><p><img src="/images/redis/redis-cluster.png" alt="Redis_Cluster"></p><h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><ul><li>使用redis-trib.rb创建集群<code>redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003</code></li><li>添加主节点: <code>redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001</code></li><li>当添加了一个主节点后,需要重新分配哈希槽: <code>redis-trib.rb reshard 127.0.0.1:7001</code></li><li>添加从节点, 添加一个port为7008的Redis实例做为7007的从节点: <code>redis-trib.rb add-node --slave --master-id cad9f7413ec6842c971dbcc2c48b4ca959eb5db4  127.0.0.1:7008 127.0.0.1:7001</code><ul><li>注: 主节点id可以在client中使用 <code>cluster nodes</code> 命令查询。</li></ul></li><li>删除节点: <code>redis-trib.rb del-node 要删除的节点的ip和端口 节点id</code></li></ul><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>只需要把改变的槽移动到新的节点上</p><h2 id="Redis-Cluster-架构概述"><a href="#Redis-Cluster-架构概述" class="headerlink" title="Redis Cluster 架构概述"></a>Redis Cluster 架构概述</h2><ul><li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽</li><li>节点的fail是通过集群中超过半数的节点检测失效时才生效.</li><li>客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</li><li>cluster 负责维护槽对应哪个节点</li><li>Redis投票机制:<ul><li>Redis集群中每一个节点都会参与投票,如果当半数以上的节点认为一个节点通信超时,则该节点fail。</li><li>当集群中任意节点的master(主机)挂掉,且这个节点没有slave(从机),则整个集群进入fail状态。</li></ul></li><li>将所有数据分为16384个槽(Slot), 每个redis节点分得一部分槽, 每个redis节点都存储了槽和节点的对应关系, 客户端也会缓存槽和节点的对应关系</li><li>槽的编号从<code>0~0x3FFF</code>, 所以槽的总数 = 16384 = 0x3FFF+1</li><li>客户端(以JedisCluster为例)读写时, 首先计算出Key在哪个槽: Slot = <code>crc(Key) &amp; 0x3FFF</code> , 然后根据”槽-节点”的表直接访问Redis节点 // 在JedisClusterInfoCache类中，slots这个Map本地缓存保存的也是slot槽和主节点的连接池;</li><li>如果Redis节点包含查询的Key, 直接返回数据, 如果不包含, 则返回’MOVED’重定向错误</li><li>客户端收到MOVED, 使用 cluster slots命令更新slots 缓存（renewSlotCache方法）</li><li>客户端重复上述过程</li><li>如果是<code>keys</code>这种涉及所有节点的命令, 通过Spring的<code>AsyncTaskExecutor</code>发送命令给所有节点, 然后处理异步返回的结果</li><li>如果是<code>mget</code>这种可能涉及部分节点的命令, 先把所有的key按节点分组, 然后异步执行</li></ul><h2 id="Gossip协议解析"><a href="#Gossip协议解析" class="headerlink" title="Gossip协议解析"></a>Gossip协议解析</h2><p>Gossip 是一个p2p模式的协议, 节点之间不断交换彼此的元数据信息, 元数据信息包括自己和已知其他节点的状态, 交换一段时间后最终每个节点都可以同步到最新的状态数据, Gossip主要有以下4类消息:</p><ul><li>MEET: 类似”握手”, 消息中包括作为发送者的 Redis节点的信息 以及其他已知 Redis节点信息（节点id，负责槽位，节点标识等等）</li><li>PING: 消息中包含内容同MEET消息, PING作为节点之间信息交换 &amp; 心跳检查</li><li>PONG: 接收到MEET/PING后, 需要返回一个PONG, 告知对方自己状态正常</li><li>FAIL: 节点发现另外某节点不可用时(没收到PONG), 会向自己已知的所有节点发送FAIL广播</li></ul><p>考虑到频繁地交换信息会加重带宽（集群节点越多越明显）和计算的负担，<br>Redis Cluster内部的定时任务每秒执行10次，每次遍历本地节点列表，对最近一次接受到pong消息时间大于<code>cluster_node_timeout / 2</code>的节点立马发送ping消息，<br>此外每秒随机找5个节点，选里面最久没有通信的节点发送ping消息。<br>同时 ping 消息的消息投携带自身节点信息，消息体只会携带1/10的其他节点信息，避免消息过大导致通信成本过高。</p><h2 id="故障发现、故障转移"><a href="#故障发现、故障转移" class="headerlink" title="故障发现、故障转移"></a>故障发现、故障转移</h2><ul><li>如果某个主节点宕机, 集群内的其他机器通过PING-PONG很快发现宕机, 并通过广播FAIL消息确认”客观下线”(超半数)</li><li>从节点收到主节点宕机的消息, 发起选举</li><li>选举过程和 Redis Sentinel方式类似 (Raft协议) , 需要注意的是从当选为主节点之后的操作:<ul><li>自己变为主节点, 停止从原主节点复制工作</li><li>让原主的其他从节点变为自己的从</li><li>更新槽-节点的配置, 并广播给其他节点</li></ul></li></ul><p>@ref:</p><ul><li><a href="https://www.shuzhiduo.com/A/ke5jkGwXdr/" target="_blank" rel="noopener">全面剖析Redis Cluster原理和应用</a></li><li><a href="https://juejin.im/post/5d08faeff265da1bce3dd3b2" target="_blank" rel="noopener">你不知道的Redis：RedisCluster与JedisCluster - 掘金</a></li><li><a href="https://my.oschina.net/dabird/blog/1559950" target="_blank" rel="noopener">Jedis cluster命令执行流程剖析 - 大鹏的个人空间 - OSCHINA</a></li><li><a href="https://cloud.tencent.com/developer/article/1187745" target="_blank" rel="noopener">redis架构演变与redis-cluster群集读写方案 - 云+社区 - 腾讯云</a></li><li><a href="https://www.shuzhiduo.com/A/gVdnyNBX5W/" target="_blank" rel="noopener">Redis Cluster原理初步</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-03Sentinel</title>
      <link href="/31.Backend/Redis-03Sentinel/"/>
      <url>/31.Backend/Redis-03Sentinel/</url>
      
        <content type="html"><![CDATA[<p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，可以实现：</p><ul><li>Master宕机时自动切换到从</li><li>如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端);</li></ul><p>运行sentinel有两种方式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p><p><img src="/images/redis/redis-sentinel.png" alt="Redis_Sentinel"></p><h2 id="配置文件解读"><a href="#配置文件解读" class="headerlink" title="配置文件解读"></a>配置文件解读</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义一个&apos;mymaster&apos;, 2表示两个Sentinel认为Master挂掉了才算</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"># 在6000ms内ping不通, 则主观认为该实例下线</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line">#表示如果master重新选出来后，其它slave节点能同时并行从新master同步缓存的台数有多少个</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 当使用了sentinel时，master可能会变成一个slave，slave也可能会变成master ..</span><br><span class="line">sentinel auth-pass &lt;master_name&gt; xxxxx</span><br></pre></td></tr></table></figure><h2 id="Sentinel架构简介"><a href="#Sentinel架构简介" class="headerlink" title="Sentinel架构简介"></a>Sentinel架构简介</h2><ul><li>每个Sentinel可监视多个Redis Master实例, 例如配置文件<code>sentinel monitor mymaster 127.0.0.1 6379 2</code> 最后的2表示quorum, 需要至少 “quorum”个 Sentinel判定某个Redis Master实例宕机, 才能开始fail-over</li><li>Sentinel通过向Redis Master 发送<code>INFO</code> 命令, 获取它所有的Slava</li><li>Sentinel会订阅自己监视的Redis Master的<code>sentilel:hello</code>频道, 同时向该Redis 的频道发送消息, 消息包括Sentinel自己的IP:Port等, 这样其他的正在监视此Redis Master的Sentinel也会收到此消息, Sentinel通过发布/订阅的广播方式感知其他Sentinel的存在</li></ul><h2 id="Sentinel-Leader-执行主从-fail-over"><a href="#Sentinel-Leader-执行主从-fail-over" class="headerlink" title="Sentinel Leader 执行主从 fail-over"></a>Sentinel Leader 执行主从 fail-over</h2><p>Sentinel 发现主节点宕机, 执行主从的fail-over、并通知Client变更:</p><ul><li>发现并判断宕机: Sentinel 每秒向监控的 Redis master实例发送<code>PING</code>命令测试其是否宕机, 如果某个主Redis节点返回了错误结果或者Timeout, Sentinel 认为该节点是”主观下线”（SDOWN）, 如果 quorum个 Sentinel都把这个节点标记为下线, 那么 Sentinel master将把这个 Redis节点的状态则被标记为”客观下线”（ODOWN）, 这时才开始执行fail-over;</li><li>所有 Sentinel选举出一个 Leader节点完成 fail-over故障转移;</li><li>Leader选举完成, 由新的Leader 执行 redis 主节点的 fail-over:<br>首先按照所有 Slave的优先级, 如果优先级相同, 则比较Slave的复制的下标, 哪个 Slave复制进度最接近则选举为 Master, 如果优先级和复制下标都相同, 则选进程ID较小的. 然后 Sentinel向新的Master发送<code>SLAVEOF NO ONE</code>, 然后依次向其他的Slave发送<code>SLAVEOF</code>命令让其跟随新的Master, 然后Slave向新Master发送<code>SYNC</code>指令开始同步数据, 一个Slave完成上述操作后, 开始下一个Slave…</li><li>执行 fail-over的 Sentinel把最新的 Redis配置广播给其他 Sentinel</li><li>Sentinel通知调用方: 调用方如果使用 Jedis, 可以使用<code>JedisSentinelPool()</code>创建连接池, 从这个pool里获取jedis实例</li></ul><h2 id="Sentinel-选举-leader"><a href="#Sentinel-选举-leader" class="headerlink" title="Sentinel 选举 leader"></a>Sentinel 选举 leader</h2><p>➤ Sentinel的选举何时触发:</p><ul><li>在某个 Redis Master节点被认定客观下线后, Sentinel需要选举出一个 Leader, 由 Leader完成 故障转移(从一堆Redis 的Slave节点中选出master, 以及 Slave的重新配置和同步).</li><li>或者当 Leader Sentinel节点失效时, 也会开始一轮选举</li><li>无论哪种选举, 当选举完成后, 配置纪元(configuration epoch)都会增加一次, 表示一轮选举完成</li></ul><p>➤ Sentinel Leader选举步骤:</p><ul><li>当某个 Sentinel节点认为 master客观下线后, 它会做下面几件事情:<ul><li>把故障转移状态设置为true</li><li>自己从 Follower 角色变为 Candidate(候选者)</li><li>给自己投一票</li><li>当前的配置纪元+1, 并向其他 Sentinel节点发送 <code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code> 指令, 解释一下这个指令, <code>&lt;ip&gt; &lt;port&gt;</code> 表示客观下线的 master, <code>&lt;current_epoch&gt;</code>表示配置纪元, 后面的<code>&lt;runid&gt;</code>就是这个Sentinel自己的 runid(唯一标识)</li></ul></li><li>当一个 Sentinel节点收到<code>is-master-down-by-addr</code> 指令后, 会比较指令发来的配置纪元(epoch)和自己保存的配置纪元, 如果发来的配置纪元比自己存储的epoch更大(表示这是一次新的投票纪元), 收到<code>is-master-down-by-addr</code>指令的节点会把自己的选票投给这个发出<code>is-master-down-by-addr</code>指令的 Candidate, 并更新自己的配置纪元, 在一个配置纪元内一个Follower只能投一篇. 然后 Follower给这个 Candidate 回复, 回复内容就是 Candidate的 runid</li><li>Candidate等待来自 Follower的回复, 如果发现回复内容就是自己的runid, 会给本轮选举(当前配置纪元)自己选票+1. 如果自己的选票大于半数(这里应该<code>can-failover</code>的节点数的一半), 并且选票大于 quorum, 则认为自己当选</li></ul><h2 id="ref"><a href="#ref" class="headerlink" title="@ref"></a>@ref</h2><ul><li><a href="https://hoxis.github.io/redis-sentinel-ha.html" target="_blank" rel="noopener">Redis 高可用部署方案 | hoxis’ blog</a></li><li><a href="https://www.cnblogs.com/wy123/p/9929459.html" target="_blank" rel="noopener">Redis 哨兵节点之间相互自动发现机制（自动重写哨兵节点的配置文件） - MSSQL123 - 博客园</a></li><li><a href="https://www.cnblogs.com/ivictor/p/6720481.html" target="_blank" rel="noopener">在Redis Sentinel环境下，jedis该如何配置 - iVictor - 博客园</a></li><li><a href="https://blog.csdn.net/fuyuwei2015/article/details/71106918" target="_blank" rel="noopener">redis实现HA（High Available）的两种实现方式-Sentinel与Keepalived_数据库_路漫漫，水迢迢-CSDN博客</a></li><li><a href="https://hoxis.github.io/redis-sentinel-ha.html" target="_blank" rel="noopener">Redis 高可用部署方案 | hoxis’ blog</a></li><li><a href="https://zhuanlan.zhihu.com/p/60632927" target="_blank" rel="noopener">浅谈Redis Sentinel 哨兵-选举领头Sentinel和故障转移 - 知乎</a></li><li><a href="https://cloud.tencent.com/developer/article/1021467" target="_blank" rel="noopener">Raft协议实战之Redis Sentinel的选举Leader源码解析 - 云+社区 - 腾讯云</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-03Raft实现</title>
      <link href="/31.Backend/Redis-03Raft%E5%AE%9E%E7%8E%B0/"/>
      <url>/31.Backend/Redis-03Raft%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>Raft协议简述(角色, 任期Term, 发起投票);</li><li>Redis中是如何实现的Raft?</li></ul><p>➤ Raft协议简介: Raft协议是用来解决分布式系统一致性的, 协议包括 选举leader/日志复制-提交机制等等,<br>除Raft外还有 Google的 Paxos协议, 但 Paxos协议难以理解, 更难以实现(仅仅有论文),但 Raft协议正好相反, 易于理解且有实际工程的代码实现 (Redis Sentinel的选举 就是通过Raft协议实现的)</p><ul><li>Raft协议中的角色: Leader, Follower, Candidate(候选者), 在系统正常状态下只有 Leader和 Follower两种角色,</li><li>当有 Follower角色发现 Leader下线(心跳异常), 这个 Follower会暂时变为 Candidate, 然后这个Candidate 向其他 Follower发起给自己的投票, 当有超过半数的Follower给这个Candidate投票, 这个Candidate即成为新的Leader.</li><li>在选举过程中, 还有一个需要解决的问题: 选举的时间有效性 (在选举过程中, 除了节点之间交换选举人的信息, 还需要表名这是在进行第几期选举), Raft协议使用 Term(任期)来表示这次选举, 在每次Term中, Follower只有一次投票机会. 当一次选举结束后, 所有节点保存的 Term将会更新, 当下一次某个 Candidate发起选举的时候, 会将 Term + 1</li></ul><p>➤ Redis实现Raft协议:</p><ul><li>Redis实现的Raft协议中, 使用 <strong>configuration epoch</strong> (配置纪元)来表示 Term,</li><li>在Sentinel的配置文件中, 有<code>can-failover</code>参数, 这个参数表示该节点能否参与选举Leader, 也即是否有可能成为Candidate, 如果<code>can-failover</code>是 false, 表示这个节点用于只能作为 Follower , 此外, Redis 配置中的<code>quorum</code>不仅可以控制认为某个节点”SDOWN”时, 最少确认节点的个数, 也表示成为Leader所需的最小选票数.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-02部署和运维</title>
      <link href="/31.Backend/Redis-02%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%90%E7%BB%B4/"/>
      <url>/31.Backend/Redis-02%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="http://download.redis.io/logocontest/82.png" alt="Redis"></p><h1 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h1><ul><li>启动: /opt/apps/redis/bin/redis-server /opt/conf/redis/${port}.conf</li><li>conf文件: <a href="http://yijiebuyi.com/blog/bc2b3d3e010bf87ba55267f95ab3aa71.html" target="_blank" rel="noopener">http://yijiebuyi.com/blog/bc2b3d3e010bf87ba55267f95ab3aa71.html</a></li></ul><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><ul><li>连接本地: <code>redis-cli -p 6379</code></li><li>连接远程: <code>redis-cli -h host -p port -a pwd</code></li></ul><p>以下参考: <a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">http://redisdoc.com/index.html</a></p><h2 id="sys-info类命令"><a href="#sys-info类命令" class="headerlink" title="sys/info类命令"></a>sys/info类命令</h2><ul><li><code>SELECT</code>: 选择数据库, 比如<code>SELECT 0</code>选择0号数据库(默认的)</li><li><code>INFO</code> : 返回信息,  @ref: <a href="http://redisdoc.com/server/info.html" target="_blank" rel="noopener">http://redisdoc.com/server/info.html</a></li><li><code>MONITOR</code> : 可以看到实时的查询信息(查询来源IP.), 注意这个命令对性能有影响</li><li><code>DBSIZE</code> : 返回<code>当前库</code>Key的数量</li><li><code>FLUSHDB</code>/<code>FLUSHALL</code>: 清空<code>当前库</code>, 清空<code>整个Redis</code>的数据</li><li><code>CLIENT LIST</code> : 获取连接到服务器的客户端连接列表</li><li><code>CLIENTKILL [ip:port] [ID client-id]</code> : 关闭客户端连接</li><li><code>CONFIG GET *</code> 获取所有参数</li><li><code>CONFIG SET 参数 值</code></li><li><code>BGSAVE</code>: 异步持久化, 不要用SAVE!</li></ul><h2 id="key类命令"><a href="#key类命令" class="headerlink" title="key类命令"></a>key类命令</h2><ul><li><code>TYPE key</code> 返回 key 所储存的值的类型。</li><li><code>DEL key [key ...]</code>: 删除给定的一个或多个 key 。时间复杂度：O(N)， N 为被删除的 key 的数量</li><li><code>EXISTS key</code>: 检查给定 key 是否存在</li><li><code>RANDOMKEY</code>: 从当前数据库中随机返回(不删除)一个 key 。</li><li><code>KEYS pattern</code>: 查找所有符合给定模式 pattern 的 key（慎用！） 。时间复杂度： O(N)， N 为数据库中 key 的数量。<ul><li><code>KEYS *</code> 匹配数据库中所有 key 。</li><li><code>KEYS h?llo</code> 匹配 hello ， hallo 和 hxllo 等。</li></ul></li><li><code>SCAN 0</code> 增量迭代式获取，返回的游标被用作下一次<code>SCAN X</code>，每次执行都只会返回少量元素， 所以可以用于生产环境</li><li><code>SORT key DESC</code>: 返回键值从大到小排序的结果。</li><li><code>EXPIRE key seconds</code>: 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。<ul><li>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)</li><li>对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。</li></ul></li><li><code>TTL key</code> : 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</li></ul><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><ul><li><code>SLOWLOG GET 1000</code>: 获取1000条慢查询</li><li><code>SLOWLOG RESET</code> 可以清空 slow log</li><li><code>CONFIG GET slowlog-log-slower-than</code> 获取慢查询设置, 单位是微秒, 默认10,000(10毫秒), 超过10毫秒需关注</li><li><code>CONFIG SET slowlog-log-slower-than 10000</code></li></ul><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><ul><li>redis 性能测试的基本命令如下：<code>redis-benchmark [option] [option value]</code></li><li>以下实例同时执行 10000 个请求来检测性能：<code>redis-benchmark -n 10000  -q</code><ul><li>-c: 指定并发连接数</li><li>-n: 指定请求数</li><li>-d: 以字节的形式指定 SET/GET 值的数据大小</li></ul></li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 分别提供了 RDB 和 AOF 两种持久化模式</p><ul><li><p>RDB: <a href="http://redisbook.readthedocs.io/en/latest/internal/rdb.html" target="_blank" rel="noopener">http://redisbook.readthedocs.io/en/latest/internal/rdb.html</a></p><ul><li>在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</li><li>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作，保证性能</li><li>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</li></ul></li><li><p>AOF: <a href="https://redisbook.readthedocs.io/en/latest/internal/aof.html" target="_blank" rel="noopener">https://redisbook.readthedocs.io/en/latest/internal/aof.html</a></p><ul><li>Append Only File，即只允许追加不允许改写的文件</li><li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</li><li>AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li></ul></li><li><p>RDB-AOF混合持久化: <a href="http://blog.huangz.me/2017/redis-rdb-aof-mixed-persistence.html" target="_blank" rel="noopener">Redis 4.0 新功能简介：RDB-AOF 混合持久化 — blog.huangz.me</a></p></li></ul><h1 id="INFO返回信息"><a href="#INFO返回信息" class="headerlink" title="INFO返回信息"></a>INFO返回信息</h1><ul><li><p>server 部分记录了 Redis 服务器的信息，它包含以下域：</p><ul><li>redis_version : Redis 服务器版本</li><li>redis_git_sha1 : Git SHA1</li><li>redis_git_dirty : Git dirty flag</li><li>os : Redis 服务器的宿主操作系统</li><li>arch_bits : 架构（32 或 64 位）</li><li>multiplexing_api : Redis 所使用的事件处理机制</li><li>gcc_version : 编译 Redis 时所使用的 GCC 版本</li><li>process_id : 服务器进程的 PID</li><li>run_id : Redis 服务器的随机标识符（用于 Sentinel 和集群）</li><li>tcp_port : TCP/IP 监听端口</li><li>uptime_in_seconds : 自 Redis 服务器启动以来，经过的秒数</li><li>uptime_in_days : 自 Redis 服务器启动以来，经过的天数</li><li>lru_clock : 以分钟为单位进行自增的时钟，用于 LRU 管理</li></ul></li><li><p>clients 部分记录了已连接客户端的信息，它包含以下域：</p><ul><li>connected_clients : 已连接客户端的数量（不包括通过从属服务器连接的客户端）</li><li>client_longest_output_list : 当前连接的客户端当中，最长的输出列表</li><li>client_longest_input_buf : 当前连接的客户端当中，最大输入缓存</li><li>blocked_clients : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</li></ul></li><li><p>memory 部分记录了服务器的内存信息，它包含以下域：</p><ul><li>used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位</li><li>used_memory_human : 以人类可读的格式返回 Redis 分配的内存总量</li><li>used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</li><li>used_memory_peak : Redis 的内存消耗峰值（以字节为单位）</li><li>used_memory_peak_human : 以人类可读的格式返回 Redis 的内存消耗峰值</li><li>used_memory_lua : Lua 引擎所使用的内存大小（以字节为单位）</li><li>mem_fragmentation_ratio : used_memory_rss 和 used_memory 之间的比率</li><li><p>mem_allocator : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</p><blockquote><p>在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。<br>当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。<br>内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。<br>当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。<br>Because Redis does not have control over how its allocations are mapped to memory pages, high used_memory_rss is often the result of a spike in memory usage.</p></blockquote><blockquote><p>当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。<br>如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。<br>查看 used_memory_peak 的值可以验证这种情况是否发生。</p></blockquote></li></ul></li></ul><ul><li><p>persistence 部分记录了跟 RDB 持久化和 AOF 持久化有关的信息，它包含以下域：</p><ul><li>loading : 一个标志值，记录了服务器是否正在载入持久化文件。</li><li>rdb_changes_since_last_save : 距离最近一次成功创建持久化文件之后，经过了多少秒。</li><li>rdb_bgsave_in_progress : 一个标志值，记录了服务器是否正在创建 RDB 文件。</li><li>rdb_last_save_time : 最近一次成功创建 RDB 文件的 UNIX 时间戳。</li><li>rdb_last_bgsave_status : 一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败。</li><li>rdb_last_bgsave_time_sec : 记录了最近一次创建 RDB 文件耗费的秒数。</li><li>rdb_current_bgsave_time_sec : 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li>aof_enabled : 一个标志值，记录了 AOF 是否处于打开状态。</li><li>aof_rewrite_in_progress : 一个标志值，记录了服务器是否正在创建 AOF 文件。</li><li>aof_rewrite_scheduled : 一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作。</li><li>aof_last_rewrite_time_sec : 最近一次创建 AOF 文件耗费的时长。</li><li>aof_current_rewrite_time_sec : 如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li>aof_last_bgrewrite_status : 一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。</li></ul></li><li><p>如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：</p><ul><li>aof_current_size : AOF 文件目前的大小。</li><li>aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。</li><li>aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。</li><li>aof_buffer_length : AOF 缓冲区的大小。</li><li>aof_rewrite_buffer_length : AOF 重写缓冲区的大小。</li><li>aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。</li><li>aof_delayed_fsync : 被延迟的 fsync 调用数量。</li></ul></li><li><p>stats 部分记录了一般统计信息，它包含以下域：</p><ul><li>total_connections_received : 服务器已接受的连接请求数量。</li><li>total_commands_processed : 服务器已执行的命令数量。</li><li>instantaneous_ops_per_sec : 服务器每秒钟执行的命令数量。</li><li>rejected_connections : 因为最大客户端数量限制而被拒绝的连接请求数量。</li><li>expired_keys : 因为过期而被自动删除的数据库键数量。</li><li>evicted_keys : 因为最大内存容量限制而被驱逐（evict）的键数量。</li><li>keyspace_hits : 查找数据库键成功的次数。</li><li>keyspace_misses : 查找数据库键失败的次数。</li><li>pubsub_channels : 目前被订阅的频道数量。</li><li>pubsub_patterns : 目前被订阅的模式数量。</li><li>latest_fork_usec : 最近一次 fork() 操作耗费的毫秒数。</li></ul></li><li><p>replication : 主/从复制信息</p><ul><li>role : 如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。</li></ul></li><li><p>如果当前服务器是一个从服务器的话，那么这个部分还会加上以下域：</p><ul><li>master_host : 主服务器的 IP 地址。</li><li>master_port : 主服务器的 TCP 监听端口号。</li><li>master_link_status : 复制连接当前的状态， up 表示连接正常， down 表示连接断开。</li><li>master_last_io_seconds_ago : 距离最近一次与主服务器进行通信已经过去了多少秒钟。</li><li>master_sync_in_progress : 一个标志值，记录了主服务器是否正在与这个从服务器进行同步。</li></ul></li><li><p>如果同步操作正在进行，那么这个部分还会加上以下域：</p><ul><li>master_sync_left_bytes : 距离同步完成还缺少多少字节数据。</li><li>master_sync_last_io_seconds_ago : 距离最近一次因为 SYNC 操作而进行 I/O 已经过去了多少秒。</li></ul></li><li><p>如果主从服务器之间的连接处于断线状态，那么这个部分还会加上以下域：</p><ul><li>master_link_down_since_seconds : 主从服务器连接断开了多少秒。</li></ul></li><li><p>cpu 部分记录了 CPU 的计算量统计信息，它包含以下域：</p><ul><li>used_cpu_sys : Redis 服务器耗费的系统 CPU 。</li><li>used_cpu_user : Redis 服务器耗费的用户 CPU 。</li><li>used_cpu_sys_children : 后台进程耗费的系统 CPU 。</li><li>used_cpu_user_children : 后台进程耗费的用户 CPU 。</li></ul></li><li><p>commandstats 部分记录了各种不同类型的命令的执行统计信息，比如命令执行的次数、命令耗费的 CPU 时间、执行每个命令耗费的平均 CPU 时间等等。对于每种类型的命令，这个部分都会添加一行以下格式的信息：</p><ul><li>cmdstat_XXX:calls=XXX,usec=XXX,usecpercall=XXX</li></ul></li><li><p>cluster 部分记录了和集群有关的信息，它包含以下域：</p><ul><li>cluster_enabled : 一个标志值，记录集群功能是否已经开启。</li><li>keyspace 部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。对于每个数据库，这个部分都会添加一行以下格式的信息： dbXXX:keys=XXX,expires=XXX</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://redisbook.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Redis 设计与实现</a></li><li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li><li><a href="http://wiki.jikexueyuan.com/project/redis/" target="_blank" rel="noopener">Redis 源码日志</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> K-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-01数据结构</title>
      <link href="/31.Backend/Redis-01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/31.Backend/Redis-01%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Redis是一个K-V的数据库，“V” 的数据类型分为：String、Hash、List、Set、Sorted Set。</p><p><img src="/images/redis/redis_all_type.png" alt=""></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。</p><blockquote><p>sds是在Redis中被广泛使用的字符串结构，它的全称是Simple Dynamic String。参考 <a href="http：//zhangtielei.com/posts/blog-redis-sds.html">Redis内部数据结构详解(2)——sds</a> @ref</p></blockquote><h3 id="String命令"><a href="#String命令" class="headerlink" title="String命令"></a>String命令</h3><p>String相关命令包括 <code>SET</code>/<code>GET</code>类命令，对字符串的值<code>APPEND</code>/<code>SETRANGE</code>操作，还包括 同时设置值和过期时间的原子操作<code>SETEX</code>，但是其他数据类型没有类似<code>SETEX</code>的原子操作。</p><ul><li><code>SET key value</code>：设置key关联的字符串</li><li><code>GET key</code>：返回key关联的字符串</li><li><code>APPEND key value</code>：在字符串后追加value</li><li><code>STRLEN key</code>： 返回字符串长度</li><li><code>SETRANGE key 0 &quot;xxx&quot;</code>： 把key对应的字符串从0开始，用“xxx”覆盖。时间复杂度O(M)， M 为 value 参数的长度。</li><li><code>INCR key</code>：将 key 中储存的数字值+1，数字范围是有符号long</li><li><code>INCRBY key increment</code>：将 key 所储存的值加上增量 increment</li><li><code>DECR key</code>：将 key 中储存的数字值减一。</li><li><code>DECRBY by decrement</code>：将 key 所储存的值减去减量 decrement 。</li></ul><p>过期时间：</p><ul><li><code>SETEX key seconds value</code>：将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。 SETEX 是一个原子性(atomic)操作</li></ul><p>批量操作：</p><ul><li><code>MGET key1 key2</code>：返回所有(一个或多个)给定 key 的值。时间复杂度O(N) ，N 为给定 key1..key2 的数量。</li><li><code>MSET key1 value2 key1 value2</code>： 设置key1…key2对应的字符串。时间复杂度：O(N)， N 为要设置的 key 数量。</li></ul><p>BIT操作：</p><ul><li><code>SETBIT key offset value</code>：对key所储存的字符串值，设置或清除指定偏移量上的位(bit)，value只能是0或1，offset小于2^32（512MB）</li><li><code>GETBIT key offset</code>：返回offset位上的值（0/1）</li><li><code>BITCOUNT key</code> ： 计算给定字符串中，被设置为 1 的比特位的数量。</li></ul><h3 id="String的实现"><a href="#String的实现" class="headerlink" title="String的实现"></a>String的实现</h3><p>@todo</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>字典实现，key对应的内容是由field-value组成的键值对。</p><h3 id="HashMap命令"><a href="#HashMap命令" class="headerlink" title="HashMap命令"></a>HashMap命令</h3><p>HashMap相关命令常规的字典操作，</p><ul><li><code>HSET key field value</code>：将哈希表 key 中的域 field 的值设为 value，O(1)</li><li><code>HGET key field</code>：返回哈希表 key 中给定域 field 的值。</li><li><code>HKEYS key</code>：返回哈希表 key 中的所有域。时间复杂度：O(N)， N 为哈希表的大小。</li><li><code>HGETALL key</code> ：返回哈希表 key 中所有的域和值。时间复杂度：O(N)， N 为哈希表的大小。</li><li><code>HVALS key</code>：返回哈希表 key 中所有域的值。时间复杂度：O(N)， N 为哈希表的大小。</li><li><code>HEXISTS key field</code>：查看哈希表 key 中，给定域 field 是否存在。</li><li><code>HSCAN key cursor</code>：命令用于迭代哈希键中的键值对。具体信息请参考 SCAN 命令。</li><li><code>HDEL key field [field ...]</code>：删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。时间复杂度：O(N)， N 为要删除的域的数量。</li><li><code>HLEN key</code>： 返回键值对数量</li><li><code>HINCRBY key field increment</code> ：为哈希表 key 中的域 field 的值加上增量 increment 。</li></ul><p>批量操作：</p><ul><li><code>HMSET key field1 value1 field2 value2</code>： 同时将多个 field-value (域-值)对设置到哈希表 key 中。O(N)， N 为 field-value 对的数量。</li><li><code>HMGET field1 field2</code>： 返回哈希表 key 中，一个或多个给定域的值。O(N)， N 为 field-value 对的数量。</li></ul><h3 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h3><p>@todo</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>双端队列</p><h3 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h3><p>队列的L/R端的POP和PUSH操作：</p><ul><li><code>LPOP key</code> ：移除并返回列表 key 的头元素。</li><li><code>LPUSH key value [value ...]</code> ：将一个或多个值 value 插入到列表 key 的表头</li><li><code>RPUSH key value [value ...]</code>：将一个或多个值 value 插入到列表 key 的表尾(最右边)。</li><li><code>RPOP key</code>：移除并返回列表 key 的尾元素。</li><li><code>LLEN key</code> ：返回列表 key 的长度。</li></ul><p>随机查询 &amp; 插入：</p><ul><li><code>LINDEX key index</code> ：返回列表 key 中，下标为 index 的元素。时间复杂度：O(N)， N 为到达下标 index 过程中经过的元素数量。</li><li><code>LINSERT key BEFORE|AFTER pivot value</code> ：将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。时间复杂度：O(N)， N 为寻找 pivot 过程中经过的元素数量。<ul><li><code>LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;</code> ：会先在List寻找”World”，找到后在”World”之前插入”There”</li></ul></li></ul><p>阻塞L/R端弹出：</p><ul><li><code>BLPOP key [key ...] timeout</code> ：BLPOP 是列表的阻塞式(blocking)弹出原语。它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</li><li><code>BRPOP key [key ...] timeout</code> ：参考如上</li></ul><h3 id="List的实现"><a href="#List的实现" class="headerlink" title="List的实现"></a>List的实现</h3><p>@todo</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set（集合）：不重复</p><h3 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h3><ul><li><code>SADD key v1 v2</code> ：添加多个值到集合key之中，时间复杂度：O(N)， N 是被添加的元素的数量。</li><li><code>SPOP key</code> ：移除并返回集合中的一个随机元素。</li><li><code>SMEMBERS key</code>：返回集合 key 中的所有成员。时间复杂度：O(N)， N 为集合的元素数量。</li><li><code>SSREM key member [member ...]</code>：移除集合 key 中的一个或多个 member 元素，时间复杂度：O(N)， N 为给定 member 元素的数量。</li><li><code>SISMEMBER key member</code>：判断 member 元素是否集合 key 的成员。时间复杂度：O(1)</li><li><code>SCARD key</code>：返回集合中元素的数量。时间复杂度：O(1)</li><li><code>SSCAN key cursor</code>：详细信息请参考 SCAN 命令。</li></ul><p>交并集：</p><ul><li><code>SINTER key1 [key ...]</code>：返回交集成员的列表，时间复杂度为O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</li><li><code>SUNION key [key ...]</code> 返回一个集合的全部成员，该集合是所有给定集合的并集。时间复杂度为O(N)， N 是所有给定集合的成员数量之和。</li></ul><h3 id="Set的实现"><a href="#Set的实现" class="headerlink" title="Set的实现"></a>Set的实现</h3><p>@todo</p><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列</p><h3 id="Sorted-Set命令"><a href="#Sorted-Set命令" class="headerlink" title="Sorted Set命令"></a>Sorted Set命令</h3><ul><li><code>ZADD key score member [[score member] [score member] ...]</code>：将一个或多个 member 元素及其 score 值加入到有序集 key 当中。时间复杂度：O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。</li><li><code>ZSCORE key member</code>：返回有序集 key中，成员 member的 score值。时间复杂度：O(1)</li><li><code>ZRANGE key start stop</code>：返回有序集 key中指定区间内的成员。其中成员的位置按 score值递增(从小到大)来排序。复杂度：O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</li><li><code>ZINCRBY key increment member</code>：为有序集 key的成员 member的 score值加上增量 increment。时间复杂度：O(log(N))</li><li><code>ZREVRANK key member</code>：返回有序集 key中成员 member的排名，score 值最大的成员排名为 0 。复杂度O(log(N))</li><li><code>ZCOUNT key min max</code>： 返回有序集 key 中， score值在 min和 max之间(默认包括)的成员的数量。时间复杂度：O(log(N))， N 为有序集的基数。</li><li><code>ZCARD key</code>：返回key对应的集合的长度。</li></ul><h3 id="Sorted-Set的实现"><a href="#Sorted-Set的实现" class="headerlink" title="Sorted Set的实现"></a>Sorted Set的实现</h3><p>简化的 SkipList结构模型(横向每层都是一条链表, 层数从上到下 n-1):<br><img src="/images/redis/redis-skiplist-model.png" alt="Redis_SkipList_Model"></p><p>▶ 插入一个Key, 首先计算在哪一层插入, 层数的计算代码:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32 <span class="comment">//最大层数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25 <span class="comment">//P</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳表最上层(最稀疏)是第1层, 层数初始值=1,<br><code>random()&amp;0xFFFF</code> 表示在 0 ~ 0xFFFF范围内随机数,<br>如果随机数出现在 0 ~ <code>ZSKIPLIST_P * 0xFFFF</code>, 则层数++, 所以每次循环中层数++的概率是 <code>ZSKIPLIST_P</code>, 这里是 0.25,<br>所以, 层数i = 1,2,3,… 的概率分别是 <code>3/4</code>, <code>1/4 * 3/4</code>, <code>1/4 * 1/4 * 3/4</code>, 每加一层, 出现在该层的概率就乘以 0.25,<br>简化一下:</p><ul><li>节点层数恰好等于1的概率为 $ 1-p $</li><li>节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为 $ p(1-p) $</li><li>节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为 $ p^2(1-p) $</li><li>节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为 $ p^3(1-p) $</li></ul><p>▶ 复杂度分析: @todo</p><p>▶ 占用空间分析: @todo</p><p>Redis SkipList实际内存模型: (下面的例子 用Zset 保存”姓名-分数”, 插入样例数据 <code>ZADD Charles 65.5  David 78.0 Alice 87.5</code>, 实际存储如下)<br><img src="/images/redis/redis-skiplist-memory.png" alt="Redis_SkipList_Memory"></p><p>@ref:</p><ul><li><a href="http://oenhan.com/skiplist-principle" target="_blank" rel="noopener">跳表SkipList的原理和C实现 | OenHan</a></li><li><a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">Redis 为什么用跳表而不用平衡树？ - 掘金</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.06-序列化-ProtoBuf</title>
      <link href="/31.Backend/RPC.06-%E5%BA%8F%E5%88%97%E5%8C%96-ProtoBuf/"/>
      <url>/31.Backend/RPC.06-%E5%BA%8F%E5%88%97%E5%8C%96-ProtoBuf/</url>
      
        <content type="html"><![CDATA[<p>ProtoBuf（Protocol Buffers ）是Google的开源的序列化 &amp; 反序列化工具 <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/</a></p><h2 id="ProtoBuf-C-使用"><a href="#ProtoBuf-C-使用" class="headerlink" title="ProtoBuf C++使用"></a>ProtoBuf C++使用</h2><p>使用步骤: </p><ul><li>定义proto文件，文件的内容就是定义我们需要存储或者传输的数据结构，也就是定义我们自己的数据存储或者传输的协议。</li><li>安装protocol buffer编译器来编译自定义的.proto文件，用于生成.pb.h文件（proto文件中自定义类的头文件）和 .pb.cc（proto文件中自定义类的实现文件）。</li><li>使用protocol buffer的C++ API来读写消息</li></ul><p>protocol buffer 生成的函数, 除了getter和setter之外, 还有: </p><p>标准消息函数（Standard Message Methods）<br>每一个消息（message）还包含了其他一系列函数，用来检查或管理整个消息，包括：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool IsInitialized() const; //检查是否全部的required字段都被置（set）了值。</span><br><span class="line"></span><br><span class="line">void CopyFrom(const Person&amp; from); //用外部消息的值，覆写调用者消息内部的值。</span><br><span class="line"></span><br><span class="line">void Clear();   //将所有项复位到空状态（empty state）。</span><br><span class="line"></span><br><span class="line">int ByteSize() const;   //消息字节大小</span><br></pre></td></tr></table></figure><p>Debug的API, 包括: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string DebugString() const; //将消息内容以可读的方式输出</span><br><span class="line"></span><br><span class="line">string ShortDebugString() const; //功能类似于，DebugString(),输出时会有较少的空白</span><br><span class="line"></span><br><span class="line">string Utf8DebugString() const; //Like DebugString(), but do not escape UTF-8 byte sequences.</span><br><span class="line"></span><br><span class="line">void PrintDebugString() const;  //Convenience function useful in GDB. Prints DebugString() to stdout.</span><br></pre></td></tr></table></figure><p>解析&amp;序列化(Parsing and Serialization)函数, 包括:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool SerializeToString(string* output) const; //将消息序列化并储存在指定的string中。注意里面的内容是二进制的，而不是文本；我们只是使用string作为一个很方便的容器。</span><br><span class="line"></span><br><span class="line">bool ParseFromString(const string&amp; data); //从给定的string解析消息。</span><br><span class="line"></span><br><span class="line">bool SerializeToArray(void * data, int size) const  //将消息序列化至数组</span><br><span class="line"></span><br><span class="line">bool ParseFromArray(const void * data, int size)    //从数组解析消息</span><br><span class="line"></span><br><span class="line">bool SerializeToOstream(ostream* output) const; //将消息写入到给定的C++ ostream中。</span><br><span class="line"></span><br><span class="line">bool ParseFromIstream(istream* input); //从给定的C++ istream解析消息。</span><br></pre></td></tr></table></figure><p>使用示例: </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.pb.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    GOOGLE_PROTOBUF_VERIFY_VERSION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建message实例, 并设置属性:</span></span><br><span class="line">    tutorial::Student student;</span><br><span class="line">    student.set_id(<span class="number">201421031059</span>);</span><br><span class="line">    student.set_email(<span class="string">"dablelv@tencent.com"</span>);</span><br><span class="line">    <span class="comment">// 增加 repeated属性</span></span><br><span class="line">    tutorial::Student::PhoneNumber* phone_number1 = student.add_phone();</span><br><span class="line">    phone_number1-&gt;set_number(<span class="string">"13811112222"</span>);</span><br><span class="line">    tutorial::Student::PhoneNumber* phone_number2 = student.add_phone();</span><br><span class="line">    phone_number2-&gt;set_number(<span class="string">"010-1112222"</span>);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化:</span></span><br><span class="line">    <span class="built_in">string</span> serializedStr;</span><br><span class="line">    student.SerializeToString(&amp;serializedStr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"serialization result:"</span>&lt;&lt;serializedStr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"debugString:"</span>&lt;&lt;student.DebugString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化: </span></span><br><span class="line">    tutorial::Student deserializedStudent;</span><br><span class="line">    <span class="keyword">if</span>(!deserializedStudent.ParseFromString(serializedStr))&#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to parse student."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"deserializedStudent debugString:"</span>&lt;&lt;deserializedStudent.DebugString();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"Student ID: "</span> &lt;&lt; deserializedStudent.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 判断有无属性</span></span><br><span class="line">    <span class="keyword">if</span> (deserializedStudent.has_email())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"E-mail address: "</span> &lt;&lt; deserializedStudent.email() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 repeated属性进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; deserializedStudent.phone_size(); j++)&#123;</span><br><span class="line">        <span class="keyword">const</span> tutorial::Student::PhoneNumber&amp; phone_number = deserializedStudent.phone(j);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;phone_number.number()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::ShutdownProtobufLibrary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>@ref: <a href="https://cloud.tencent.com/developer/article/1176660" target="_blank" rel="noopener">Protocol Buffers C++入门教程 - 云+社区 - 腾讯云</a></p><h2 id="varint"><a href="#varint" class="headerlink" title="varint"></a>varint</h2><p>@ref: <a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/" target="_blank" rel="noopener">Protobuf 终极教程</a> @todo</p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.05-腾讯云TSF微服务平台简介</title>
      <link href="/31.Backend/RPC.05-%E8%85%BE%E8%AE%AF%E4%BA%91TSF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/"/>
      <url>/31.Backend/RPC.05-%E8%85%BE%E8%AE%AF%E4%BA%91TSF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>微服务平台（Tencent Service Framework，TSF）是一个围绕着应用和微服务的 PaaS 平台，提供应用全生命周期管理、数据化运营、立体化监控和服务治理等功能。<br>TSF 拥抱 Spring Cloud 、Service Mesh 微服务框架，帮助企业客户解决传统集中式架构转型的困难，打造大规模高可用的分布式系统架构，实现业务、产品的快速落地。针对原生 Spring Cloud 应用与 Mesh 方式零成本接入。</p><p>@ref: <a href="https://cloud.tencent.com/document/product/649" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/649</a></p><ul><li>Spring Cloud 应用接入TSF: <a href="https://cloud.tencent.com/document/product/649/36285" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/649/36285</a></li><li>Dubbo 应用接入TSF: <a href="https://cloud.tencent.com/document/product/649/13947" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/649/13947</a></li><li>TSF Mesh 应用接入TSF: <a href="https://cloud.tencent.com/document/product/649/17928" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/649/17928</a></li></ul><blockquote><p> Dubbo &amp; Spring Cloud 微服务介绍, 参考👉🏻 <a href="/31.Backend/RPC.01-浅谈服务治理-and-微服务(zz)/" title="RPC.01-浅谈服务治理-and-微服务(zz)">RPC.01-浅谈服务治理-and-微服务(zz)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.04-Service Mesh</title>
      <link href="/31.Backend/RPC.04-Service-Mesh/"/>
      <url>/31.Backend/RPC.04-Service-Mesh/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://juejin.im/entry/5b4c0be66fb9a04fb900c3a4" target="_blank" rel="noopener">什么是Service Mesh？ </a></li><li><a href="https://time.geekbang.org/article/2360" target="_blank" rel="noopener">Service Mesh深度解析</a></li><li>腾讯云微服务平台提供的 TSF Mesh: <a href="/31.Backend/RPC.05-腾讯云TSF微服务平台简介/" title="RPC.05-腾讯云TSF微服务平台简介">RPC.05-腾讯云TSF微服务平台简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.03-框架设计概要</title>
      <link href="/31.Backend/RPC.03-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/"/>
      <url>/31.Backend/RPC.03-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><p>早期JDK1.2引入的RMI框架图: （👉🏻[[../@project/Java-RMI]]）</p><h2 id="RPC通用框架"><a href="#RPC通用框架" class="headerlink" title="RPC通用框架"></a>RPC通用框架</h2><p>通用RPC框架图:<br><img src="/images/20220315092643.png" alt="../_images/20220315092643.png"></p><ul><li><p>serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法。类似RMI的stub模块。</p></li><li><p>processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法。类似RMI的skeleton模块。</p></li><li><p>protocol：协议层，一般协议层包括编码/解码，或者说序列化和反序列化工作；有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，Apache avro，G的 protobuf，FB的 Thrift，json系，xml系等等。在RMI中直接使用JDK自身的序列化组件。</p><blockquote><p>Thrift和Protobuf的最大不同，在于Thrift提供了完整的RPC支持，包含了Server/Client，而Protobuf只包括了stub的生成器和格式定义。@ref <a href="https://developer.aliyun.com/article/229886" target="_blank" rel="noopener">Protobuf 和 Thrift对比-阿里云开发者社区</a></p></blockquote></li><li><p>transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。</p></li><li><p>I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。</p></li></ul><p>Dubbo框架图参考:  <a href="/31.Backend/RPC.01-浅谈服务治理-and-微服务(zz)/" title="RPC.01-浅谈服务治理-and-微服务(zz)">RPC.01-浅谈服务治理-and-微服务(zz)</a></p><h2 id="RPC技术要点"><a href="#RPC技术要点" class="headerlink" title="RPC技术要点"></a>RPC技术要点</h2><ul><li>序列化:<ul><li>JDK内置序列化 👉🏻 [[../12.Java/Java-Tutorials.06.序列化]]</li><li>Hessian: 在字节流里为每个field存储了类型信息, 可以不依赖serialVersionUID 进行版本匹配(Java类的UID被更改, 反序列化也没有问题) </li><li>Kryo: “Kryo是一个快速高效的Java对象序列化框架，其在java的序列化上的性能指标甚至优于google著名的序列化框架protobuf，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用”</li><li>Json: </li></ul></li><li><p>编解码: 注意区分序列化的不同, RPC框架基本上都是基于Socket来实现通信层功能，但是在网络传输的数据由于网络链路和协议的问题，会出现半包、分包和粘包情况。这样就需要设计编解码协议头来解码网络流。比如dubbo给出的处理流程，可以清晰的看出序列化和编码之间的区别,  参考[[#Dubbo协议头]]<br>  <img src="/images/20220316000934.png" alt="../_images/20220316000934.png"></p></li><li><p>负载均衡:</p><ul><li>一般通过client维护可用服务列表, client通过同server建立心跳 测试server是否存活, 如果server暂时不可用, client会把server暂时放入不可用列表, 一段时间后再次尝试建立心跳(类似熔断)</li><li>心跳服务可选的有 netty提供的 HashedWheelTimer, 在不要求高精度定时心跳的情况下提供了很高的性能</li><li>Client侧负载均衡算法: 👉🏻 <a href="/31.Backend/SystemDesign-负载均衡-算法/" title="SystemDesign-负载均衡-算法">SystemDesign-负载均衡-算法</a></li></ul></li><li>超时管理: <ul><li>client端的超时处理, 例如 future.get()</li><li>server端的超时处理, 处理完后, 设定的超时参数比较, 如果发现已经超时则可以直接给client返回 err_code, 省去了序列化的时间</li></ul></li><li>服务发现:<ul><li>服务注册: server启动后注册服务信息 , 可选的存储服务有 zk/redis</li><li>服务感知/维护:<ul><li>服务端和客户端与注册中心通过心跳上报运行情况</li><li>服务提供列表发生变化, 可以通过 client pull 或者 register push的方式</li></ul></li></ul></li><li>IO模型: 参考 [[../12.Java/Java-Tutorials.09.NIO##Reactor三种常见线程模型]]</li></ul><h2 id="Dubbo协议头"><a href="#Dubbo协议头" class="headerlink" title="Dubbo协议头"></a>Dubbo协议头</h2><p><img src="/images/20220316001058.png" alt="../_images/20220316001058.png"></p><ul><li>协议头固定长度16个字节</li><li>Magic:  共2字节 <code>static final short MAGIC = (short) 0xdabb</code></li><li>Serialization id: 表示序列化类型ID，Dubbo支持多种序列化工具，比如hessian，jdk，fastjson等</li><li>event表示事件，比如这个请求是heartbeat</li><li>two way表示请求是否是需要交互返回数据的请求</li><li>req/res表示该数据是请求还是响应</li><li>status表示状态位，当响应数据的时候，根据该字段判断是否成功。</li><li>id表示请求id</li><li>data length则表示正文内容的长度</li></ul><hr><p>@ref <a href="https://ketao1989.github.io/2016/12/10/2016-12-10-rpc-theory-in-action/" target="_blank" rel="noopener">深入浅出RPC原理 | 没有期望的分布</a></p>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.02-RMI</title>
      <link href="/31.Backend/RPC.02-RMI/"/>
      <url>/31.Backend/RPC.02-RMI/</url>
      
        <content type="html"><![CDATA[<h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><p>@Ref: <a href="https://ketao1989.github.io/2016/12/10/2016-12-10-rpc-theory-in-action/" target="_blank" rel="noopener">https://ketao1989.github.io/2016/12/10/2016-12-10-rpc-theory-in-action/</a></p><p>RMI，全称是Remote Method Invocation，也就是远程方法调用。在JDK 1.2的时候引入到Java体系。</p><p><img src="/images/20220315142830.png" alt="A typical implementation model of Java-RMI using stub and skeleton objects."></p><p>下面先看看RMI的调用流程:<br><img src="/images/20220314231644.png" alt="../_images/20220314231644.png"></p><p>有些概念需要说明：</p><ul><li>stub(桩)：stub实际上就是在客户端上面的一个proxy。当我们的客户端代码调用API接口提供的方法的时候，RMI生成的stub代码块会将请求数据序列化，交给远程服务端处理，然后将结果反序列化之后返回给客户端的代码。这些处理过程，对于客户端来说，基本是透明无感知的。</li><li>remote：这层就是底层网络处理了，RMI对用户来说，屏蔽了这层细节。stub通过remote来和远程服务端进行通信。</li><li>skeleton(骨架)：和stub相似，skeleton则是服务端生成的一个代理proxy。当客户端通过stub发送请求到服务端，则交给skeleton来处理，其会根据指定的服务方法来反序列化请求，然后调用具体方法执行，最后将结果返回给客户端。</li><li>registry(服务发现)：rmi服务，在服务端实现之后需要注册到rmi server上，然后客户端从指定的rmi地址上lookup服务，调用该服务对应的方法即可完成远程方法调用。registry是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</li></ul><p>RMI Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口必须继承RMI的Remote</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RmiService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有RemoteException，才是RMI方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnicastRemoteObject会生成一个代理proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">RmiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RmiServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端server启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RmiService service = <span class="keyword">new</span> RmiServiceImpl();</span><br><span class="line">            <span class="comment">//在本地创建和暴露一个注册服务实例，端口为9999</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">//注册service服务到上面创建的注册实例上</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://127.0.0.1:9999/service1"</span>,service);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------server start-----------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用rmi服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据注册的服务地址来查找服务，然后就可以调用API对应的方法了</span></span><br><span class="line">            RmiService service = (RmiService)Naming.lookup(<span class="string">"rmi://localhost:9999/service1"</span>);</span><br><span class="line">            System.out.println(service.hello(<span class="string">"RMI"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>@ref:</p><ul><li><a href="https://en.wikipedia.org/wiki/Java_remote_method_invocation" target="_blank" rel="noopener">Java remote method invocation - Wikipedia</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577" target="_blank" rel="noopener">RMI远程调用 - 廖雪峰的官方网站</a></li><li><a href="https://b1ngz.github.io/java-rmi/" target="_blank" rel="noopener">Java RMI 笔记 | b1ngz</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.02-ProtoBuf</title>
      <link href="/31.Backend/RPC.02-ProtoBuf/"/>
      <url>/31.Backend/RPC.02-ProtoBuf/</url>
      
        <content type="html"><![CDATA[<h2 id="ProtoBuf-C-使用"><a href="#ProtoBuf-C-使用" class="headerlink" title="ProtoBuf C++使用"></a>ProtoBuf C++使用</h2><p>ProtoBuf（Protocol Buffers ）是Google的开源的序列化 &amp; 反序列化工具 <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/</a></p><p>使用步骤:</p><ul><li>定义proto文件，文件的内容就是定义我们需要存储或者传输的数据结构，也就是定义我们自己的数据存储或者传输的协议。</li><li>安装protocol buffer编译器来编译自定义的.proto文件，用于生成.pb.h文件（proto文件中自定义类的头文件）和 .pb.cc（proto文件中自定义类的实现文件）。</li><li>使用protocol buffer的C++ API来读写消息</li></ul><p>protocol buffer 生成的函数, 除了getter和setter之外, 还有:</p><p>标准消息函数（Standard Message Methods）<br>每一个消息（message）还包含了其他一系列函数，用来检查或管理整个消息，包括：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool IsInitialized() const; //检查是否全部的required字段都被置（set）了值。</span><br><span class="line"></span><br><span class="line">void CopyFrom(const Person&amp; from); //用外部消息的值，覆写调用者消息内部的值。</span><br><span class="line"></span><br><span class="line">void Clear();   //将所有项复位到空状态（empty state）。</span><br><span class="line"></span><br><span class="line">int ByteSize() const;   //消息字节大小</span><br></pre></td></tr></table></figure><p>Debug的API, 包括:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string DebugString() const; //将消息内容以可读的方式输出</span><br><span class="line"></span><br><span class="line">string ShortDebugString() const; //功能类似于，DebugString(),输出时会有较少的空白</span><br><span class="line"></span><br><span class="line">string Utf8DebugString() const; //Like DebugString(), but do not escape UTF-8 byte sequences.</span><br><span class="line"></span><br><span class="line">void PrintDebugString() const;  //Convenience function useful in GDB. Prints DebugString() to stdout.</span><br></pre></td></tr></table></figure><p>解析&amp;序列化(Parsing and Serialization)函数, 包括:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool SerializeToString(string* output) const; //将消息序列化并储存在指定的string中。注意里面的内容是二进制的，而不是文本；我们只是使用string作为一个很方便的容器。</span><br><span class="line"></span><br><span class="line">bool ParseFromString(const string&amp; data); //从给定的string解析消息。</span><br><span class="line"></span><br><span class="line">bool SerializeToArray(void * data, int size) const  //将消息序列化至数组</span><br><span class="line"></span><br><span class="line">bool ParseFromArray(const void * data, int size)    //从数组解析消息</span><br><span class="line"></span><br><span class="line">bool SerializeToOstream(ostream* output) const; //将消息写入到给定的C++ ostream中。</span><br><span class="line"></span><br><span class="line">bool ParseFromIstream(istream* input); //从给定的C++ istream解析消息。</span><br></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.pb.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    GOOGLE_PROTOBUF_VERIFY_VERSION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建message实例, 并设置属性:</span></span><br><span class="line">    tutorial::Student student;</span><br><span class="line">    student.set_id(<span class="number">201421031059</span>);</span><br><span class="line">    student.set_email(<span class="string">"dablelv@tencent.com"</span>);</span><br><span class="line">    <span class="comment">// 增加 repeated属性</span></span><br><span class="line">    tutorial::Student::PhoneNumber* phone_number1 = student.add_phone();</span><br><span class="line">    phone_number1-&gt;set_number(<span class="string">"13811112222"</span>);</span><br><span class="line">    tutorial::Student::PhoneNumber* phone_number2 = student.add_phone();</span><br><span class="line">    phone_number2-&gt;set_number(<span class="string">"010-1112222"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化:</span></span><br><span class="line">    <span class="built_in">string</span> serializedStr;</span><br><span class="line">    student.SerializeToString(&amp;serializedStr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"serialization result:"</span>&lt;&lt;serializedStr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"debugString:"</span>&lt;&lt;student.DebugString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化:</span></span><br><span class="line">    tutorial::Student deserializedStudent;</span><br><span class="line">    <span class="keyword">if</span>(!deserializedStudent.ParseFromString(serializedStr))&#123;</span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to parse student."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"deserializedStudent debugString:"</span>&lt;&lt;deserializedStudent.DebugString();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"Student ID: "</span> &lt;&lt; deserializedStudent.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 判断有无属性</span></span><br><span class="line">    <span class="keyword">if</span> (deserializedStudent.has_email())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"E-mail address: "</span> &lt;&lt; deserializedStudent.email() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 repeated属性进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; deserializedStudent.phone_size(); j++)&#123;</span><br><span class="line">        <span class="keyword">const</span> tutorial::Student::PhoneNumber&amp; phone_number = deserializedStudent.phone(j);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;phone_number.number()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::ShutdownProtobufLibrary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>@ref: <a href="https://cloud.tencent.com/developer/article/1176660" target="_blank" rel="noopener">Protocol Buffers C++入门教程 - 云+社区 - 腾讯云</a></p><h2 id="varint"><a href="#varint" class="headerlink" title="varint"></a>varint</h2><p>@ref: <a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/" target="_blank" rel="noopener">Protobuf 终极教程</a> @todo</p><h2 id="浅谈服务治理、微服务与Service-Mesh"><a href="#浅谈服务治理、微服务与Service-Mesh" class="headerlink" title="浅谈服务治理、微服务与Service Mesh"></a>浅谈服务治理、微服务与Service Mesh</h2><p><a href="http://dockone.io/article/3294" target="_blank" rel="noopener">浅谈服务治理、微服务与Service Mesh（一）：Dubbo的前世今生 - DockOne.io</a><br><a href="http://dockone.io/article/4142" target="_blank" rel="noopener">浅谈服务治理、微服务与Service Mesh（二）： Spring Cloud从入门到精通到放弃 - DockOne.io</a><br><a href="http://dockone.io/article/8260" target="_blank" rel="noopener">浅谈服务治理、微服务与Service Mesh（三）： Service Mesh与Serverless - DockOne.io</a></p><h2 id="RPC通用框架"><a href="#RPC通用框架" class="headerlink" title="RPC通用框架"></a>RPC通用框架</h2><p>通用RPC框架图:<br><img src="/images/20220315092643.png" alt=""></p><ul><li><p>serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法。类似RMI的stub模块。</p></li><li><p>processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法。类似RMI的skeleton模块。</p></li><li><p>protocol：协议层，一般协议层包括编码/解码，或者说序列化和反序列化工作；有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，Apache avro，G的 protobuf，FB的 Thrift，json系，xml系等等。在RMI中直接使用JDK自身的序列化组件。</p><blockquote><p>Thrift和Protobuf的最大不同，在于Thrift提供了完整的RPC支持，包含了Server/Client，而Protobuf只包括了stub的生成器和格式定义。@ref <a href="https://developer.aliyun.com/article/229886" target="_blank" rel="noopener">Protobuf 和 Thrift对比-阿里云开发者社区</a></p></blockquote></li><li><p>transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。</p></li><li><p>I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。</p></li></ul><p>Dubbo框架图参考: &lt;RPC.01-浅谈服务治理、微服务与Service Mesh(zz)#Dubbo总体架构&gt;</p><h2 id="RPC技术要点"><a href="#RPC技术要点" class="headerlink" title="RPC技术要点"></a>RPC技术要点</h2><p>@ref <a href="https://ketao1989.github.io/2016/12/10/2016-12-10-rpc-theory-in-action/" target="_blank" rel="noopener">深入浅出RPC原理 | 没有期望的分布</a></p><ul><li>序列化:<ul><li>JDK内置序列化</li><li>Hessian: 在字节流里为每个field存储了类型信息, 可以不依赖serialVersionUID 进行版本匹配(Java类的UID被更改, 反序列化也没有问题)</li><li>Kryo: “Kryo是一个快速高效的Java对象序列化框架，其在java的序列化上的性能指标甚至优于google著名的序列化框架protobuf，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用”</li><li>Json:</li></ul></li><li>编解码: 注意区分序列化的不同, RPC框架基本上都是基于Socket来实现通信层功能，但是在网络传输的数据由于网络链路和协议的问题，会出现半包、分包和粘包情况。这样就需要设计编解码协议头来解码网络流。比如dubbo给出的处理流程，可以清晰的看出序列化和编码之间的区别,  参考 Dubbo协议头</li></ul><p><img src="/images/20220316000934.png" alt=""></p><ul><li>负载均衡:<ul><li>一般通过client维护可用服务列表, client通过同server建立心跳 测试server是否存活, 如果server暂时不可用, client会把server暂时放入不可用列表, 一段时间后再次尝试建立心跳(类似熔断)</li><li>心跳服务可选的有 netty提供的 HashedWheelTimer, 在不要求高精度定时心跳的情况下提供了很高的性能</li><li>Client侧负载均衡算法: ==&gt; SystemDesign-负载均衡-算法</li></ul></li><li>超时管理:<ul><li>client端的超时处理, 例如 future.get()</li><li>server端的超时处理, 处理完后, 设定的超时参数比较, 如果发现已经超时则可以直接给client返回 err_code, 省去了序列化的时间</li></ul></li><li>服务发现:<ul><li>服务注册: server启动后注册服务信息 , 可选的存储服务有 zk/redis</li><li>服务感知/维护:<ul><li>服务端和客户端与注册中心通过心跳上报运行情况</li><li>服务提供列表发生变化, 可以通过 client pull 或者 register push的方式</li></ul></li></ul></li><li>IO模型: 参考 =&gt; Java Tutorials-09-NIO##Reactor三种常见线程模型</li></ul><h2 id="Dubbo协议头"><a href="#Dubbo协议头" class="headerlink" title="Dubbo协议头"></a>Dubbo协议头</h2><p><img src="/images/20220316001058.png" alt=""></p><ul><li>协议头固定长度16个字节</li><li>Magic:  共2字节 <code>static final short MAGIC = (short) 0xdabb</code></li><li>Serialization id: 表示序列化类型ID，Dubbo支持多种序列化工具，比如hessian，jdk，fastjson等</li><li>event表示事件，比如这个请求是heartbeat</li><li>two way表示请求是否是需要交互返回数据的请求</li><li>req/res表示该数据是请求还是响应</li><li>status表示状态位，当响应数据的时候，根据该字段判断是否成功。</li><li>id表示请求id</li><li>data length则表示正文内容的长度</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.01-浅谈服务治理、微服务与Service Mesh(zz)</title>
      <link href="/31.Backend/RPC.01-%E6%B5%85%E8%B0%88%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-and-%E5%BE%AE%E6%9C%8D%E5%8A%A1(zz)/"/>
      <url>/31.Backend/RPC.01-%E6%B5%85%E8%B0%88%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-and-%E5%BE%AE%E6%9C%8D%E5%8A%A1(zz)/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈服务治理、微服务与Service-Mesh（一）：Dubbo的前世今生"><a href="#浅谈服务治理、微服务与Service-Mesh（一）：Dubbo的前世今生" class="headerlink" title="浅谈服务治理、微服务与Service Mesh（一）：Dubbo的前世今生"></a>浅谈服务治理、微服务与Service Mesh（一）：Dubbo的前世今生</h1><p>@ref <a href="http://dockone.io/article/3294" target="_blank" rel="noopener">浅谈服务治理、微服务与Service Mesh（一）：Dubbo的前世今生 - DockOne.io</a></p><p>服务治理（Service Governance），也称为SOA治理，是指用来管理SOA的采用和实现的过程。以下是在2006年时IBM对于服务治理要点的总结：  </p><ul><li>服务定义（服务的范围、接口和边界）</li><li>服务部署生命周期（各个生命周期阶段）</li><li>服务版本治理（包括兼容性）</li><li>服务迁移（启用和退役）</li><li>服务注册中心（依赖关系）</li><li>服务消息模型（规范数据模型）</li><li>服务监视（进行问题确定）</li><li>服务所有权（企业组织）</li><li>服务测试（重复测试）</li><li>服务安全（包括可接受的保护范围）</li></ul><p>限于当时的技术发展水平，广大软件设计与开发人员对于SOA和服务治理的技术认知还主要停留在Web Service和ESB总线等技术和规范上，并没有真正在软件开发中得以充分落地。</p><h2 id="Dubbo开源"><a href="#Dubbo开源" class="headerlink" title="Dubbo开源"></a>Dubbo开源</h2><p>直到2011年10月27日，阿里巴巴开源了自己的SOA服务化治理方案的核心框架Dubbo，服务治理和SOA的设计理念开始逐渐在国内软件行业中落地，并被广泛应用。Dubbo作为阿里巴巴内部的SOA服务化治理方案的核心框架，在2012年时已经每天为2000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。</p><h2 id="Dubbo简介"><a href="#Dubbo简介" class="headerlink" title="Dubbo简介"></a>Dubbo简介</h2><p>Dubbo是一个高性能服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案，使得应用可通过高性能RPC实现服务的输出和输入功能，和Spring框架可以无缝集成。</p><p>作为一个分布式服务框架，以及SOA治理方案，Dubbo其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与服务降级等。Dubbo最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。<br><img src="/images/20220313145140.png" alt=""></p><p>Dubbo包含远程通讯、集群容错和自动发现三个核心部分。提供透明化的远程方法调用，实现像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。同时具备软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。可以实现服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p><h2 id="Dubbo总体架构"><a href="#Dubbo总体架构" class="headerlink" title="Dubbo总体架构"></a>Dubbo总体架构</h2><p>Dubbo框架设计共划分了10层，最上面的Service层是留给实际使用Dubbo开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</p><p><img src="/images/20220313145245.png" alt=""></p><h2 id="停止维护"><a href="#停止维护" class="headerlink" title="停止维护"></a>停止维护</h2><p>从2012年10月23日Dubbo 2.5.3发布后，在Dubbo开源将满一周年之际，阿里基本停止了对Dubbo的主要升级。只在之后的2013年和2014年更新过2次对Dubbo 2.4的维护版本，然后停止了所有维护工作。Dubbo对Srping的支持也停留在了Spring 2.5.6版本上。</p><h2 id="重获新生"><a href="#重获新生" class="headerlink" title="重获新生"></a>重获新生</h2><p>经过多年漫长的等待，随着微服务的火热兴起，在国内外开发者对阿里不再升级维护Dubbo的吐槽声中，阿里终于开始重新对Dubbo的升级和维护工作。在2017年9月7日 ，阿里发布了Dubbo的2.5.4版本，距离上一个版本2.5.3发布已经接近快5年时间了。在随后的几个月中，阿里Dubbo开发团队以差不多每月一版本的速度开始快速升级迭代，修补了Dubbo老版本多年来存在的诸多bug，并对Spring等组件的支持进行了全面升级。</p><h2 id="Dubbo与Spring-Cloud"><a href="#Dubbo与Spring-Cloud" class="headerlink" title="Dubbo与Spring Cloud"></a>Dubbo与Spring Cloud</h2><p>阿里巴巴负责主导了 Dubbo 重启维护的研发工程师刘军在接受采访时表示：当前由于 RPC 协议、注册中心元数据不匹配等问题，在面临微服务基础框架选型时Dubbo与Spring Cloud是只能二选一，这也是为什么大家总是拿Dubbo和Spring Cloud做对比的原因之一。</p><hr><h1 id="浅谈服务治理、微服务与Service-Mesh（二）：-Spring-Cloud从入门到精通到放弃"><a href="#浅谈服务治理、微服务与Service-Mesh（二）：-Spring-Cloud从入门到精通到放弃" class="headerlink" title="浅谈服务治理、微服务与Service Mesh（二）： Spring Cloud从入门到精通到放弃"></a>浅谈服务治理、微服务与Service Mesh（二）： Spring Cloud从入门到精通到放弃</h1><p>@ref <a href="http://dockone.io/article/4142" target="_blank" rel="noopener">浅谈服务治理、微服务与Service Mesh（二）： Spring Cloud从入门到精通到放弃 - DockOne.io</a></p><h2 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h2><p>Spring Boot和Spring Cloud都是出自Pivotal公司。</p><p>Spring Cloud作为一个微服务的开发框架，其包括了很多的组件，包括：Spring Cloud Netflix（Eureka、Hystrix、Zuul、Archaius）、Spring Cloud Config、Spring Cloud Bus、Spring Cloud Cluster、Spring Cloud Consul、Spring Cloud Security、Spring Cloud Sleuth、Spring Cloud Data Flow、Spring Cloud Stream、Spring Cloud Task、Spring Cloud ZooKeeper、Spring Cloud Connectors、Spring Cloud Starters、Spring Cloud CLI等。</p><p>在上述组件中，Spring Cloud Netflix是一套微服务的核心框架，由互联网流媒体播放商Netflix开源后并入Spring Cloud大家庭，它提供了的微服务最基础的功能：服务发现（Service Discovery）、动态路由（Dynamic Routing）、负载均衡（Load Balancing）和边缘服务器（Edge Server）等。</p><p>Spring Boot（[[../13.JavaEE-Framework/JavaEE.SpringBoot]]）是Spring的一套快速配置脚手架，可以基于Spring Boot快速开发单个微服务。Spring Boot简化了基于Spring的应用开发，通过少量的代码就能创建一个独立的、生产级别的Spring应用。由于Spring Cloud是基于Spring Boot进行的开发，因此使用Spring Cloud就必须使用到Spring Boot。</p><p>Spring Cloud常用组件：</p><ul><li>Eureka：服务注册中心，一个基于REST的服务，用于定位服务，以实现微服务架构中服务发现和故障转移。</li><li>Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</li><li>Turbine：Turbine是聚合服务器发送事件流数据的一个工具，用来监控集群下Hystrix的Metrics情况。</li><li>Zuul：API网关，Zuul是在微服务中提供动态路由、监控、弹性、安全等边缘服务的框架。</li><li>Ribbon：提供微服务中的负载均衡功能，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</li><li>Feign：Feign是一种声明式、模板化的HTTP客户端。</li><li>Spring Cloud Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。</li><li>Spring Cloud Security：基于Spring Security的安全工具包，为微服务的应用程序添加安全控制。</li><li>Spring Cloud Sleuth：日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</li></ul><p>除了上面介绍的基础组件外，常见的Spring Cloud组件还有非常多种，涉及到了微服务以及应用开发的方方面面：  </p><ul><li>Spring Cloud Starters：Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。</li><li>Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li><li>Consul：封装了Consul操作，Consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</li><li>Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</li><li>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</li><li>Spring Cloud Task：提供云端计划任务管理、任务调度。</li><li>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</li><li>Spring Cloud Data Flow：大数据操作工具，作为Spring XD的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</li><li>Spring Cloud ZooKeeper：操作ZooKeeper的工具包，用于使用ZooKeeper方式的服务发现和配置管理。</li><li>Spring Cloud Connectors：便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。</li></ul><h2 id="Spring-Cloud之“精通”"><a href="#Spring-Cloud之“精通”" class="headerlink" title="Spring Cloud之“精通”"></a>Spring Cloud之“精通”</h2><p>Spring Cloud虽然集成了众多组件，可以构建一个完整的微服务应用，但是其中的各个组件却并非完美无缺，很多组件在实际应用中都存在诸多不足和缺陷。因此，需要我们对其中的一些组件进行替换和修改，方能构建一个强大、灵活、健壮的微服务架构应用。</p><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>Spring Cloud Config可以说是Spring Cloud家族中实现最Low的一个组件，直接采用了本地存储/SVN/Git的方式进行存储。同时，Spring Cloud Config也缺乏一个完整的可视化管理查询后台，当存在比较复杂的权限管理和版本管理需求时，Spring Cloud Config会显得非常力不从心。如果需要在配置修改后，能自动进行配置信息推送的话，使用Spring Cloud Config也无法满足要求，需要自行编写代码进行实现。</p><p>目前开源社区中，已经有了很多的开源配置中心实现方案，同时很多公司也自研了自己的配置中心方案。包括淘宝的统一配置中心Diamond（已经多年未更新）、百度的分布式配置管理平台Disconf、携程的开源分布式配置中心Apollo、360的分布式配置管理工具QConf等等。目前，笔者公司采用的是自己公司自研的配置中心，没有采用开源实现的主要原因是因为需要同时适配Spring Cloud和Dubbo等多种场景的应用。</p><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>作为Spring Cloud的服务注册中心，从分布式CAP理论来看，Eureka采用是AP型设计，强调的是注册中心的高可用性。和Dubbo常用的服务注册中心ZooKeeper相比，ZooKeeper则是采用的CP型设计，强调的是注册中心数据的一致性。</p><p>Eureka的设计确实简单易用，但是默认没有实现对注册中心数据的持久化。同时，在极端场景下，也会出现多个Eureka注册中心节点数据不一致，甚至服务注册数据丢失的情况。当然，从分布式CAP理论来看，理论上是没办法做到同时兼顾CAP三点的。目前也有一些互联网公司对Eureka进行了改造，支持了数据的持久化，但是尚不能完整的支持CAP的全部要求。</p><h3 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h3><p>API网关可以说是微服务需求最多，也是最有难点的一个组件。Spring Cloud中集成的Zuul应该说更多的是实现了服务的路由功能，对于负载均衡等其他功能，需要结合Ribbon等组件来实现。对于很多个性化的需求，需要开发者自己来进行编码实现。</p><p>和大部分基于Java的Web应用类似，Zuul也采用了Servlet架构，因此Zuul处理每个请求的方式是针对每个请求是用一个线程来处理。同时，由于Zuul是基于JVM的实现，因此性能也会在高并发访问场景下成为瓶颈。虽然网上一些文章评测Zuul和Nginx性能接近，但是在性能要求较高的场景下，JVM的内存管理和垃圾回收问题，仍然是一个很大的问题。所以在实际的应用场景中，通常会采用在多个Zuul几点前面再添加一层Nginx或者OpenResty来进行代理。</p><p>为了解决Zuul的性能问题，Netflix将自己的网关服务Zuul进行了升级，新的Zuul 2将HTTP请求的处理方式从同步变成了异步，并且新增诸如HTTP/2、websocket等功能。但是遗憾的是，开源版本的Zuul 2一直处于难产状态中，始终没有和大家正式见面。</p><h3 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h3><p>微服务中对于服务的限流、降级、熔断的需求是多种多样的，需要在API网关和各个具体服务接口中分别进行控制，才能满足复杂场景下微服务架构的应用需求。</p><p>单独使用Spring Cloud中的Hystrix无法完整的满足上述的复杂需求，需要结合API网关，并通过Kubernetes对资源、进程和命名空间来提供隔离，并通过部分自定义编码方能实现对全部服务的限流、降级、熔断等需求。</p><h3 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h3><p>无论是Spring Cloud中集成的Spring Cloud Sleuth，还是集成经典的ELK，都只是对日志级别的追踪和监控。在大中型微服务应用架构中，尤其是基于JVM的项目，还需要添加APM的监控机制，才能保证及时发现各种潜在的性能问题。</p><p>APM整体上主要完成3点功能：1.日志追踪、2.监控报警、3.性能统计。目前，国内外商业版本的APM方案已经有很多，开源版本的APM方案也开始丰富起来。国内开源的APM方案主要有：大众点评的CAT和Apache孵化中的SkyWalking。这里给大家重点推荐下SkyWalking，SkyWalking是针对分布式系统的应用性能监控系统，特别针对微服务、Cloud Native和容器化（Docker、Kubernetes、Mesos）架构，项目的关注度和发展速度都很快，中文文档资料也比较齐全。</p><h2 id="Spring-Cloud之“放弃”"><a href="#Spring-Cloud之“放弃”" class="headerlink" title="Spring Cloud之“放弃”"></a>Spring Cloud之“放弃”</h2><p>Spring Cloud可以说是一个完美的微服务入门框架，如果你是在一个中小型项目中应用Spring Cloud，那么你不需要太多的改造和适配，就可以实现微服务的基本功能。但是如果是在大型项目中实践微服务，可能会发现需要处理的问题还是比较多，尤其是项目中老代码比较多，没办法全部直接升级到Spring Boot框架下开发的话，你会非常希望能有一个侵入性更低的方案来实施微服务架构。在这种场景下，Service Mesh将会成为你的最佳选择 …</p><h3 id="Spring-Cloud-与-Dubbo"><a href="#Spring-Cloud-与-Dubbo" class="headerlink" title="Spring Cloud 与 Dubbo"></a>Spring Cloud 与 Dubbo</h3><p>实际上，Dubbo的关注点在于服务治理，并不能算是一个真正的微服务框架。包括目前在开发中的Dubbo 3.0，也不能完整覆盖微服务的各项功能需求。而Spring Cloud一方面是针对微服务而设计，另外一方面Spring Cloud是通过集成各种组件的方式来实现微服务，因此理论上可以集成目前业内的绝大多数的微服务相关组件，从而实现微服务的全部功能。</p><p>而对Dubbo而言，如果一定要应用到微服务的使用场景中的话，上表中欠缺的大多数功能都可以通过集成第三方应用和组件的方式来实现，跟Spring Cloud相比主要的缺陷在于集成过程中的便利性和兼容性等问题。</p><h3 id="Spring-Cloud-与-Docker"><a href="#Spring-Cloud-与-Docker" class="headerlink" title="Spring Cloud 与 Docker"></a>Spring Cloud 与 Docker</h3><p>在实际上微服务架构中，Spring Cloud和Docker更多的是一种协作的关系，而不是一种竞争的关系。通过Docker容器化技术，可以更好的解决引入Spring Cloud微服务后带来的部署和运维的复杂性。</p><p>Spring Cloud生态圈中的Pivotal Cloud Foundry（PCF）作为PaaS实现，也提供一些类似于Docker的功能支持，但是无论上功能上还是易用性上和Docker还是存在比较大的差异。Pivotal Cloud Foundry和Docker之间的关系更多的是一种兼容关系，而不是竞争关系，Pivotal Cloud Foundry的主要竞争对手是Red Hat的OpenShift。目前，Pivotal Cloud Foundry支持的IaaS包括：AWS、AZURE、GCP、vSphere、OpenStack等。</p><h3 id="Spring-Cloud-与-Kubernetes"><a href="#Spring-Cloud-与-Kubernetes" class="headerlink" title="Spring Cloud 与 Kubernetes"></a>Spring Cloud 与 Kubernetes</h3><p>网上也有一些“Spring Cloud与Kubernetes哪个更好”，“当已经有了Kubernetes之后，还需要使用Spring Cloud么”之类的文章。首先说笔者并不认为Spring Cloud与Kubernetes是竞争关系，但是也不否认二者确实在诸多功能上存在一些重合。下图是对Spring Cloud与Kubernetes在微服务架构中的一些基础功能上的对比：</p><p>通过对比可以看出，Spring Cloud和Kubernetes确实存在一些功能上的重合，但是二者的定位其实差别很大。Spring Cloud是一个基于Java语言的微服务开发框架，而Kubernetes是一个针对容器应用的自动化部署、伸缩和管理的开源系统，它兼容多种语言且提供了创建、运行、伸缩以及管理分布式系统的原语。Spring Cloud更多的是面向有Spring开发经验的Java语言开发者，而Kubernetes不是一个针对开发者的平台，它的目的是供有DevOps思想的IT人员使用。</p><p>为了区分Spring Cloud和Kubernetes两个项目的范围，下面这张图列出了几乎是端到端的微服务架构需求，从最底层的硬件，到最上层的DevOps和自服务经验，并且列出了如何关联到Spring Cloud和Kubernetes平台。<br><img src="/images/20220313152344.png" alt=""></p><hr><h1 id="浅谈服务治理、微服务与Service-Mesh（三）"><a href="#浅谈服务治理、微服务与Service-Mesh（三）" class="headerlink" title="浅谈服务治理、微服务与Service Mesh（三）"></a>浅谈服务治理、微服务与Service Mesh（三）</h1><p>@ref <a href="http://dockone.io/article/8260" target="_blank" rel="noopener">浅谈服务治理、微服务与Service Mesh（三）： Service Mesh与Serverless - DockOne.io</a></p><h2 id="微服务1-0时代"><a href="#微服务1-0时代" class="headerlink" title="微服务1.0时代"></a>微服务1.0时代</h2><ul><li>Dubbo本质上只能算是一个服务治理框架，而不能算是一个微服务框架。虽然在未来的Dubbo 3.0中会提供对Spring Cloud，以及对Service Mesh的支持，但是单凭Dubbo仍然是无法搭建一个完整的微服务体系结构。</li><li>Spring Cloud则是通过集成众多的组件的形式实现了相对完整的微服务技术栈，但是Spring Cloud的实现方式代码侵入性较强，而且只支持Java语言，无法支持其他语言开发的系统。Spring Cloud全家桶包括的内容较多，学习成本也相对较高，对老系统而言，框架升级或者替换的成本较高，导致一些开发团队不愿意担负技术和时间上的风险与成本，使得微服务方案在落地时遇到了诸多的困难。</li></ul><h2 id="微服务2-0时代"><a href="#微服务2-0时代" class="headerlink" title="微服务2.0时代"></a>微服务2.0时代</h2><blockquote><p>Service Mesh目前比较多的翻译为“服务网格”，也有翻译为“服务啮合”。很多人将之称为下一代微服务，或直接称之为微服务2.0。前两篇文章中介绍的Dubbo和Spring Cloud实际上距离真正意义上的微服务还有一定的距离，本文将带你了解在微服务2.0时代，Service Mesh方式是如何实现下一代微服务标准的，并介绍当前比较常见的几种Service Mesh实现方案。</p></blockquote><p>在介绍Service Mesh（<a href="/31.Backend/RPC.04-Service-Mesh/" title="RPC.04-Service-Mesh">RPC.04-Service-Mesh</a>）概念之前，我们先来了解一下Sidecar。Sidecar是Service Mesh中的重要组成部分。<br>在Service Mesh架构中，给每一个微服务实例部署一个Sidecar Proxy。该Sidecar Proxy负责接管对应服务的入流量和出流量，并将微服务架构中的服务订阅、服务发现、熔断、限流、降级、分布式跟踪等功能从服务中抽离到该Proxy中。</p><p>Sidecar以一个独立的进程启动，可以每台宿主机共用同一个Sidecar进程，也可以每个应用独占一个Sidecar进程。所有的服务治理功能，都由Sidecar接管，应用的对外访问仅需要访问Sidecar即可。当该Sidecar在微服务中大量部署时，这些Sidecar节点自然就形成了一个服务网格。</p><p><img src="/images/20220313152939.png" alt=""></p><p>微服务的概念在2014年3月由Martin Fowler首次提出，而Service Mesh的概念则是在2016年左右提出，Service Mesh至今也经历了第二代的发展。</p><ul><li>第一代Service Mesh的代表为Linkerd和Envoy。Linkerd基于Twitter的Fingle，使用Scala编写，是业界第一个开源的Service Mesh方案，在长期的实际生产环境中获得验证。Envoy底层基于C++，性能上优于使用Scala的Linkrd。同时，Envoy社区成熟度较高，商用稳定版本面世时间也较长。这两个开源实现都是以Sidecar为核心，绝大部分关注点都是如何做好Proxy，并完成一些通用控制面的功能。但是当你在容器中大量部署Sidecar以后，如何管理和控制这些Sidecar本身就是一个不小的挑战。</li><li>第二代Service Mesh主要改进集中在更加强大的控制面功能（与之对应的Sidecar Proxy被称之为数据面），典型代表有Istio和Conduit。Istio是Google、IBM和Lyft合作的开源项目，是目前最主流的Service Mesh方案，也是事实上的第二代Service Mesh标准。在Istio中，直接把Envoy作为Sidecar。除了Sidecar，Istio中的控制面组件都是使用Go语言编写。</li></ul><h3 id="stio简介"><a href="#stio简介" class="headerlink" title="stio简介"></a>stio简介</h3><p>根据Istio官方文档的介绍，Istio在服务网络中主要提供了以下关键功能：  </p><ul><li>流量管理：控制服务之间的流量和API调用的流向，使得调用更可靠，并使网络在恶劣情况下更加健壮。</li><li>可观察性：了解服务之间的依赖关系，以及它们之间流量的本质和流向，从而提供快速识别问题的能力。</li><li>策略执行：将组织策略应用于服务之间的互动，确保访问策略得以执行，资源在消费者之间良好分配。策略的更改是通过配置网格而不是修改应用程序代码。</li><li>服务身份和安全：为网格中的服务提供可验证身份，并提供保护服务流量的能力，使其可以在不同可信度的网络上流转。</li><li>平台支持：Istio旨在在各种环境中运行，包括跨云、Kubernetes、Mesos等。最初专注于Kubernetes，但很快将支持其他环境。</li><li>集成和定制：策略执行组件可以扩展和定制，以便与现有的ACL、日志、监控、配额、审核等解决方案集成。</li></ul><p>下图为Istio的架构设计图，主要包括了Envoy、Pilot、Mixer和Istio-Auth等<br><img src="/images/20220313153303.png" alt=""></p><ul><li>Envoy: 扮演Sidecar的功能，协调服务网格中所有服务的出入站流量，并提供服务发现、负载均衡、限流熔断等能力，还可以收集与流量相关的性能指标。</li><li>Pilot: 负责部署在Service Mesh中的Envoy实例的生命周期管理。本质上是负责流量管理和控制，将流量和基础设施扩展解耦，这是Istio的核心。可以把Pilot看做是管理Sidecar的Sidecar, 但是这个特殊的Sidacar并不承载任何业务流量。Pilot让运维人员通过Pilot指定它们希望流量遵循什么规则，而不是哪些特定的pod/VM应该接收流量。有了Pilot这个组件，我们可以非常容易的实现 A/B 测试和金丝雀Canary测试。</li><li>Mixer: Mixer在应用程序代码和基础架构后端之间提供通用中介层。它的设计将策略决策移出应用层，用运维人员能够控制的配置取而代之。应用程序代码不再将应用程序代码与特定后端集成在一起，而是与Mixer进行相当简单的集成，然后Mixer负责与后端系统连接。Mixer可以认为是其他后端基础设施（如数据库、监控、日志、配额等）的Sidecar Proxy。</li><li>Istio-Auth: 提供强大的服务间认证和终端用户认证，使用交互TLS，内置身份和证书管理。可以升级服务网格中的未加密流量，并为运维人员提供基于服务身份而不是网络控制来执行策略的能力。Istio的未来版本将增加细粒度的访问控制和审计，以使用各种访问控制机制（包括基于属性和角色的访问控制以及授权钩子）来控制和监视访问服务、API或资源的访问者。</li></ul><p>目前的Istio大部分能力与Kubernetes是强关联的。而我们在构建微服务的时候往往是希望服务层与容器层是解耦的，服务层在设计上需要能够对接多种容器层平台。 Istio至今未有稳定版本，截至本文编写时为止，Istio的最新版本为0.8版本，预计在2018年内会发布1.0版本。</p><h3 id="Conduit简介"><a href="#Conduit简介" class="headerlink" title="Conduit简介"></a>Conduit简介</h3><p>我们再来看一下Conduit的实现，下图是Conduit的架构设计图，其中重点由Conduit Data Plane和Conduit Control Plane两部分组成：</p><p><img src="/images/20220313153501.png" alt=""></p><p>Conduit各方面的设计理念与Istio非常类似，作者使用Rust语言重新编写了Sidecar, 叫做Conduit Data Plane, 控制面则由Go语言编写的Conduit Control Plane接管。从Conduit的架构看，作者号称Conduit吸取了很多Linkerd的教训，比Linkerd更快、更轻、更简单，控制面功能更强。与Istio比较，Conduit的架构一方面比较简单，另一方面对于要解决的问题足够聚焦。</p><h3 id="Serverless简介"><a href="#Serverless简介" class="headerlink" title="Serverless简介"></a>Serverless简介</h3><p>Serverless（<a href="/31.Backend/Serverless/" title="Serverless">Serverless</a>）被翻译为“无服务器架构”，这个概念在2012年时便已经存在，比微服务和Service Mesh的概念出现都要早，但是直到微服务概念大红大紫之后，Serverless才重新又被人们所关注。</p><p>Serverless（无服务器架构）并不意味着没有任何服务器去运行代码，Serverless是无需管理服务器，只需要关注代码，而提供者将处理其余部分工作。“无服务器架构”也可以指部分服务器端逻辑依然由应用程序开发者来编写的应用程序，但与传统架构的不同之处在于，这些逻辑运行在完全由第三方管理，由事件触发的无状态（Stateless）暂存于计算容器内。</p><p>对于开发者来说，Serverless架构可以将其服务器端应用程序分解成多个执行不同任务的函数，整个应用分为几个独立、松散耦合的组件，这些组件可以在任何规模上运行。</p><p>Serverless架构优势：</p><ul><li>缩短交付时间：Serverless架构允许开发人员在极短时间内（几小时、几天）交付新的应用程序，而不是像以前一样需要几个星期或几个月。在新的应用程序中，依赖于第三方API提供服务的例子很多，如认证(OAuth)、社交、地图、人工智能等。</li><li>增强可伸缩性：所有人都希望自己开发的应用能够快速获取大量的新增用户，但是当活跃用户快速增长的时候，服务器的压力也会激增。使用Serverless架构的体系不再有上述担忧，可以及时、灵活进行扩展来应对快速增长的活跃用户带来的访问压力。</li><li>降低成本：Serverless架构模式可以降低计算能力和人力资源方面的成本，如果不需要服务器，就不用花费时间重新造轮子、风险监测、图像处理，以及基础设施管理，操作成本会直线下降。</li><li>改善用户体验：用户通常不太关心基础设施，而更注重于功能和用户体验。Serverless架构允许团队将资源集中在用户体验上。</li><li>减少延迟及优化地理位置信息：应用规模能力取决于三个方面：用户数量、所在位置及网络延迟。当应用要面向全国甚至全球用户的时候，通常会产生较高的延迟，从而降低用户体验。在Serverless架构下，供应商在每个用户附近都有节点，大幅度降低了访问延迟，因此所有用户的体验都可以得到提升。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC.01-从SOA到微服务</title>
      <link href="/31.Backend/RPC.01-%E4%BB%8ESOA%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/31.Backend/RPC.01-%E4%BB%8ESOA%E5%88%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/rpc/SOA-Microservices-Title.png" alt=""></p><h1 id="从SOA到微服务"><a href="#从SOA到微服务" class="headerlink" title="从SOA到微服务"></a>从SOA到微服务</h1><p>▶ <strong>SOA</strong>: 面向服务的架构（英语：service-oriented architecture）, 即把后台系统按照功能拆分为不同的服务, 这些服务通过统一接口(RPC 或 Http)提供给调用者.<br>比较容易实现SOA的架构是Web Service, 有几种主流的实现SOA的 Web Service: XML-RPC, SOAP, REST, 其中 XML-RPC 和 SOAP都是通过 “HTTP协议传输XML内容”的方式 </p><p>参考: [[RESTful]]</p><blockquote><p>REST: 把对外提供的服务抽象为某种资源(User/Order), 通过HTTP的 GET/POST/DELETE/PUT方法对资源对象进行操作, 满足这几个条件的服务, 可以称为 #RESTful 的 (Representional State Transfer)</p></blockquote><p>▶ <strong>微服务</strong>: 微服务是SOA架构演进的结果。两者都是”对外提供接口的”一种架构设计方式，随着互联网架构的发展，更复杂的平台和业务的出现，导致SOA架构向更细粒度、更通用化发展，就演变成所谓的微服务了。<strong>微服务是SOA发展出来的产物，它是一种比较现代化的细粒度的SOA实现方式，微服务更强调去中心化分布式部署</strong></p><p>SOA与微服务的区别在于如下几个方面：</p><ul><li>微服务相比于SOA更加精细，微服务更多的以独立的进程的方式存在，互相之间并无影响；</li><li>微服务提供的接口方式更加通用化，例如HTTP RESTful方式，各种终端都可以调用，无关语言、平台限制；</li><li>微服务更倾向于分布式去中心化的部署方式，在互联网业务场景下更适合。</li></ul><p>@ref:</p><ul><li><a href="https://www.infoq.cn/article/EvT4qkRopMzQPHx1XzfA" target="_blank" rel="noopener">微服务的定义、优缺点和最佳实践 - InfoQ</a></li><li><a href="https://youzhixueyuan.com/the-difference-between-restful-soap-rpc-soa-and-micro-service.html" target="_blank" rel="noopener">阿里P8架构师谈：Restful、SOAP、RPC、SOA、微服务之间的区别</a></li></ul><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>微服务和RPC的区别: RPC是一种进程远程调用的方式，更强调的是异构平台之间进程通信的机制。SOA是一种产品架构的理念，以服务为中心，松耦合，通过定义严谨明确的接口进行通信。有比较完善的服务管理机制。两者并不是一个层面上的概念，可以说RPC是SOA架构的一种实现。</p><p>RPC用到的技术栈:</p><ul><li>传输协议: RMI（👉🏻[[../@project/Java-RMI]]）、Dubbo、Hessian、Http、JSON</li><li>传输框架：Netty、Mina</li><li>序列化：Hessian、Protobuf、dubbo、JSON、SOAP</li></ul>]]></content>
      
      
      <categories>
          
          <category> 31.Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端架构 </tag>
            
            <tag> RPC </tag>
            
            <tag> SOA </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> Motan </tag>
            
            <tag> IaaS </tag>
            
            <tag> PaaS </tag>
            
            <tag> SaaS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议：TCP/IP</title>
      <link href="/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP/"/>
      <url>/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI七层模型回顾"><a href="#OSI七层模型回顾" class="headerlink" title="OSI七层模型回顾"></a>OSI七层模型回顾</h2><p>参考: <a href="/22.Network-Protocol/网络协议-OSI七层模型/" title="网络协议-OSI七层模型">网络协议-OSI七层模型</a></p><h2 id="TCP报头"><a href="#TCP报头" class="headerlink" title="TCP报头"></a>TCP报头</h2><p><img src="/images/network_protocol/tcp_header.jpg" alt="TCP头"></p><ul><li>Source Port，Destination Port：TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li><li>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。</li><li>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。</li><li>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的，Flag共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：Acknowledgement，确认收到。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：RESET，重置连接；</li><li>SYN：Synchronize Sequence Numbers，一般在发起一个新连接的时候才会同步Seq Num；</li><li>FIN：FINISH，释放一个连接。</li></ul></li><li>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。</li></ul><h2 id="TCP状态机，以及三次握手、四次挥手"><a href="#TCP状态机，以及三次握手、四次挥手" class="headerlink" title="TCP状态机，以及三次握手、四次挥手"></a>TCP状态机，以及三次握手、四次挥手</h2><p>网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p><p>下图是“TCP协议的状态机” 和 “TCP建链接”、“传数据” 、“TCP断链接”的对照图：<br><img src="/images/network_protocol/tcp_state_machine.png" alt="state machie"></p><p>第二张图描述了TCP建立链接，收发数据，关闭链接三个步骤里TCP状态机的状态改变和发送的报文：<br><img src="/images/network_protocol/tcp_open_close.jpg" alt="open and close"></p><h3 id="三次握手、四次挥手"><a href="#三次握手、四次挥手" class="headerlink" title="三次握手、四次挥手"></a>三次握手、四次挥手</h3><ul><li>创建链接：双方交换Sequence Number的过程，服务端初始状态是<code>LISTEN</code><ul><li>客户端 -&gt; 服务端： SYN seq=x，自身状态变为<code>SYN_SENT</code>（这一步是客户端发起的，调用<code>connect()</code>）；</li><li>服务端 -&gt; 客户端： SYN seq=y, ACK=x+1，自身状态变为<code>SYN_RECEIVED</code>，此时TCP连接称为半连接（half-open connect）状态；</li><li>客户端 -&gt; 服务端： ACK=y+1，自身状态<code>ESTABLISHED</code>，服务端收到后状态也变为<code>ESTABLISHED</code>;</li></ul></li><li>收发数据：<ul><li>客户端发送数据： seq=j</li><li>服务端收到后回复：ACK=j+1</li></ul></li><li>关闭链接：由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭。当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭：<ul><li>客户端 -&gt; 服务端： FIN seq=m，表示客户端-服务端方向不再有数据流动，并进入<code>FIN_WAIT_1</code>状态，</li><li>服务端 -&gt; 客户端： ACK=m+1，进入<code>CLOSE_WAIT</code>状态</li><li>服务端 -&gt; 客户端： FIN seq=n，表示服务端-客户端方向不再有数据流动，进入<code>LAST_ACK</code>状态；</li><li>客户端 -&gt; 服务端： ACK=n+1，客户端进入<code>TIME_WAIT</code>状态，服务端收到这个ACK进入<code>CLOSED</code>状态；</li></ul></li></ul><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>SYN攻击： Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包（或者发送完SYN包就立刻下线），正常情况Server回复SYN-ACK，并等待Client的ACK。</p><p>但如果Server端如果在一定时间内没有收到Client的ACK则会重发SYN-ACK。由于CLient源地址是不存在的（或者已经下线），因此Server需要不断重发SYN-ACK，这些无效的SYN-ACK包将长时间占用Server机器的SYN队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p><p>SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了 ： <code>netstat -nat | grep</code></p><p>Linux下给了一个叫<code>tcp_syncookies</code>的参数来应对这个问题 —— 当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使Client不在SYN队列中）。请注意，请先千万别用<code>tcp_syncookies</code>来处理正常的大负载的连接的情况。因为，<code>synccookies</code>是妥协版的TCP协议，并不严谨。</p><p>一般情况下为了防范SYN攻击，有三个TCP参数可供你选择，第一个是：<code>tcp_synack_retries</code>来减少重试次数；第二个是：<code>tcp_max_syn_backlog</code>可以增大SYN连接数；第三个是：<code>tcp_abort_on_overflow</code> 处理不过来干脆就直接拒绝连接了。</p><blockquote><p>在Linux下，默认情况下Server重发SYN-ACK的次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才能知道第5次也超时了，<br>所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s 才会断开这个连接。</p></blockquote><h3 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h3><p>对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）</p><p>RFC793中说，SN会和一个假的时钟绑在一起，这个时钟会在每4微秒对SN做加一操作，直到超过2^32又从0开始。这样，一个连接的Sequence Number重复周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过<code>Maximum Segment Lifetime</code>。所以，只要MSL的值小于4.55小时，那么，我们就不会重用到Sequence Number。<br>没发送一个数据包，Seq Num就增加该次发包的长度，比如三次握手后，来了两个Len:1440的包，第二个包的SeqNum就成了1441。接收端第一个ACK回的是1441，表示第一个1440收到了。</p><h3 id="关闭连接时发起方的TIME-WAIT状态"><a href="#关闭连接时发起方的TIME-WAIT状态" class="headerlink" title="关闭连接时发起方的TIME_WAIT状态"></a>关闭连接时发起方的TIME_WAIT状态</h3><p>根据TCP状态机的图可知，主动发起断开连接的一端，收到对端的FIN+ACK后，会进入TIME_WAIT状态，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 <strong>两个MSL</strong>。为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：</p><ul><li>TIME_WAIT 确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到 ACK，就会触发被动端重发 FIN。如果主动关闭方在 TIME_WAIT 状态不等待一段时间就直接释放连接并进入 CLOSED 状态，那么主动关闭方无法收到来自被动关闭方重发的 FIN+ACK 报文段，也就不会再发送一次确认 ACK 报文段，因此被动关闭方就无法正常进入CLOSED 状态。</li><li>有足够的时间让这个连接不会跟后面的连接混在一起，在连接处于 <code>2*MSL</code> 等待时，任何迟到的报文段将被丢弃，这样就可以使下一个新的连接中不会出现这种旧的连接之前延迟的报文段。（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank" rel="noopener">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li></ul><blockquote><p>MSL = Maximum Segment Lifetime，最长段生存时间，RFC793定义了MSL为2分钟，Linux设置成了30s</p></blockquote><h4 id="TIME-WAIT会占用多少资源？"><a href="#TIME-WAIT会占用多少资源？" class="headerlink" title="TIME_WAIT会占用多少资源？"></a>TIME_WAIT会占用多少资源？</h4><p>入站连接(服务器端)很少会被TIME_WAIT影响。虽然与客户端一样，服务器端主动关闭的连接会进入TIME_WAIT状态，但是服务端监听的端口并不会防止新建的入站连接请求的建立。</p><p>由于本地端口的缺乏，TIME_WAIT的存在影响的是出站连接(客户端)的建立，这些本地端口由操作系统进行自动的分配，因此，优化的方法是增加本地端口的范围。</p><p>但是服务端被占用的资源只有一个“连接描述”，由5个元素组成：（协议，本地IP，本地端口，远程IP，远程端口）所以当同一客户端向服务器建立了大量连接之后，会耗尽可用的五元组导致问题。参考： <a href="https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side/" target="_blank" rel="noopener">tcp - What is the cost of many TIME_WAIT on the server side? - Stack Overflow</a>,<br>尽管如此, 一个连接占用的资源多少, 对于服务端来说, 还是要比客户端小很多.</p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><h3 id="Fast-Retransmit"><a href="#Fast-Retransmit" class="headerlink" title="Fast Retransmit"></a>Fast Retransmit</h3><p>快速重传机制： TCP引入了一种叫<code>Fast Retransmit</code>的算法，不以时间驱动，而以数据驱动重传。也就是说，如果包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p><p>比如：如果发送方发出了1，2，3，4，5份数据，<br>数据1先到送了，于是就接收方ack回2，但数据2因为某些原因没收到，3却到达了，于是接收方还是ack回2，<br>后面的4和5都收到了，接收方还是ack回2，因为数据2仍旧没有收到，于是发送端收到了三个ack=2的确认。<br>发送方便知道2有可能丢了，于是就发送方重发送2。然后接收端收到了2，此时因为3，4，5都收到了，于是ack回6。</p><p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择：是重传之前的一个还是重传所有的问题。对于上面的示例来说，因为发送端并不清楚这连续的3个ack(2)是哪次传回来的？ 这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。</p><h3 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h3><p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。<br>比如发送三分数据：100-299，300-499，500-699，中间一份数据丢失，接收方收到500-699之后，会回复<code>ACK=300，SACK=500-700</code>，<br>这样发送端从SACK就知道500前面的一段数据需要重发。</p><p><img src="/images/network_protocol/tcp_sack_example.jpg" alt="ack_example"></p><h3 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h3><p>施工中</p><hr><h2 id="总结-KeepAlive"><a href="#总结-KeepAlive" class="headerlink" title="总结: KeepAlive"></a>总结: KeepAlive</h2><p>KeepAlive并不是TCP协议规范的一部分，但在几乎所有的TCP/IP协议栈（不管是Linux还是Windows）中，都实现了KeepAlive功能。<br>参考 [RFC1122 #TCP Keep-Alives] @ref</p><p>TCP协议栈与KeepAlive相关的参数有:</p><ul><li>tcp_keepalive_time: KeepAlive的空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2小时）@Uncertain</li><li>tcp_keepalive_intvl: KeepAlive探测包的发送间隔，默认值为75s</li><li>tcp_keepalive_probes: 在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包次数，默认值为9（次）</li></ul><blockquote><p>以上参数都可以通过sysctl命令修改内核参数实现修改:  <code>sysctl -w net.ipv4.tcp_keepalive_time = 7500</code>,<br>更多sysctl使用参考 [[../21.Operating-System/Linux.04.Sysctl]]</p></blockquote><p>KeepAlive默认情况下是关闭的，可以被上层应用开启和关闭, 下面介绍在Java、C语言和Nginx中如何设置KeepAlive</p><h3 id="Java-Netty-设置KeepAlive"><a href="#Java-Netty-设置KeepAlive" class="headerlink" title="Java(Netty)设置KeepAlive"></a>Java(Netty)设置KeepAlive</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">            .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">            .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br></pre></td></tr></table></figure><p>Java程序只能做到设置<code>SO_KEEPALIVE</code>选项，其他配置项只能依赖于sysctl配置，系统进行读取。</p><h3 id="C语言设置KeepAlive"><a href="#C语言设置KeepAlive" class="headerlink" title="C语言设置KeepAlive"></a>C语言设置KeepAlive</h3><p>setsockopt函数原型:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">void</span> *option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure></p><p>How to use:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> (*libc_socket)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> s, optval;</span><br><span class="line">  <span class="keyword">char</span> *env;</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">void</span> **)(&amp;libc_socket) = dlsym(RTLD_NEXT, <span class="string">"socket"</span>);</span><br><span class="line">  <span class="keyword">if</span>(dlerror()) &#123;</span><br><span class="line">    errno = EACCES;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((s = (*libc_socket)(domain, type, protocol)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>((domain == PF_INET) &amp;&amp; (type == SOCK_STREAM)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!(env = getenv(<span class="string">"KEEPALIVE"</span>)) || strcasecmp(env, <span class="string">"off"</span>)) &#123;</span><br><span class="line">        optval = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        optval = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!(env = getenv(<span class="string">"KEEPALIVE"</span>)) || strcasecmp(env, <span class="string">"skip"</span>)) &#123;</span><br><span class="line">        setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码摘取自libkeepalive源码，C语言可以设置更为详细的TCP内核参数</p><h3 id="Nginx配置KeepAlive"><a href="#Nginx配置KeepAlive" class="headerlink" title="Nginx配置KeepAlive"></a>Nginx配置KeepAlive</h3><p>Nginx配置里有两处KeepAlive, 含义不同:</p><ul><li>listen下的<code>so_keepalive=30m::10</code>: 设置<code>TCP_KEEPIDLE</code>为30分钟, <code>TCP_KEEPINTVL</code>默认值, <code>TCP_KEEPCNT</code>设为10 probes</li><li>upstream下的<code>keepalive N</code> 这里的N指的是每个Worker与upstream服务器可缓存的最大连接数,</li></ul><p>常见的几种使用场景：</p><ul><li>检测挂掉的连接（导致连接挂掉的原因很多，如服务停止、网络波动、宕机、应用重启等）</li><li>防止因为网络不活动而断连（使用NAT代理或者防火墙的时候，经常会出现这种问题）</li><li>TCP层面的心跳检测</li></ul><p>通常很多应用程序也有类似KeepAlive的心跳检测, 区别在于:</p><ul><li>TCP的KeepAlive发送的数据包相比应用层心跳检测包更小，仅提供检测连接功能</li><li>应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用</li><li>应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息</li><li>KeepAlive仅代表TCP层连接仍保持着，而心跳包往往还代表客户端可正常工作</li></ul><h4 id="比较Http协议头中Keep-Alive"><a href="#比较Http协议头中Keep-Alive" class="headerlink" title="比较Http协议头中Keep-Alive"></a>比较Http协议头中Keep-Alive</h4><p>在Http Response的http头可以看到下面的字段:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 40026</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p><p>HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p><blockquote><p>http 1.0中默认是关闭的, http 1.1中默认启用Keep-Alive</p></blockquote><p>@ref: <a href="https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html" target="_blank" rel="noopener">https://blog.biezhi.me/2017/08/talk-tcp-keepalive.html</a></p><h2 id="总结-TCP中的Timeout"><a href="#总结-TCP中的Timeout" class="headerlink" title="总结: TCP中的Timeout"></a>总结: TCP中的Timeout</h2><p>在TCP所有状态中大约有7个超时, 分别是:</p><h3 id="Connection-Establishment-Timer"><a href="#Connection-Establishment-Timer" class="headerlink" title="Connection-Establishment Timer"></a>Connection-Establishment Timer</h3><p>在TCP三次握手创建一个连接时，以下两种情况会发生超时：</p><p>client发送SYN后，进入SYN_SENT状态，等待server的SYN+ACK。<br>server收到连接创建的SYN，回应SYN+ACK后，进入SYN_RECD状态，等待client的ACK。<br>当超时发生时，就会重传，一直到75s还没有收到任何回应，便会放弃，终止连接的创建。但是在Linux实现中，并不是依靠超时总时间来判断是否终止连接。而是依赖重传次数：</p><blockquote></blockquote><ul><li>tcp_syn_retries (integer; default: 5; since Linux 2.2)<br>The maximum number of times initial SYNs for an active TCP connection attempt will be retransmitted. This value should not be higher than 255. The default value is 5, which corresponds to approximately 180 seconds.</li><li>tcp_synack_retries (integer; default: 5; since Linux 2.2)<br>The maximum number of times a SYN/ACK segment for a passive TCP connection will be retransmitted. This number should not be higher than 255.</li></ul><h3 id="Retransmission-Timer"><a href="#Retransmission-Timer" class="headerlink" title="Retransmission Timer"></a>Retransmission Timer</h3><p>当三次握手成功，连接建立，发送TCP segment，等待ACK确认。如果在指定时间内，没有得到ACK，就会重传，一直重传到放弃为止。Linux中也有相关变量来设置这里的重传次数的：</p><blockquote></blockquote><ul><li>tcp_retries1 (integer; default: 3; since Linux 2.2)<br>The number of times TCP will attempt to retransmit a packet on an established connection normally, without the extra effort of getting the network layers involved. Once we exceed this number of retransmits, we first have the network layer update the route if possible before each new retransmit. The default is the RFC specified minimum of 3.</li><li>tcp_retries2 (integer; default: 15; since Linux 2.2)<br>The maximum number of times a TCP packet is retransmitted in established state before giving up. The default value is 15, which corresponds to a duration of approxi‐mately between 13 to 30 minutes, depending on the retransmission timeout. The RFC 1122 specified minimum limit of 100 seconds is typically deemed too short.</li></ul><h3 id="Delayed-ACK-Timer"><a href="#Delayed-ACK-Timer" class="headerlink" title="Delayed ACK Timer"></a>Delayed ACK Timer</h3><p>当一方接受到TCP segment，需要回应ACK。但是不需要 立即 发送，而是等上一段时间，看看是否有其他数据可以 捎带 一起发送。这段时间便是 Delayed ACK Timer ，一般为200ms。</p><h3 id="Persist-Timer"><a href="#Persist-Timer" class="headerlink" title="Persist Timer"></a>Persist Timer</h3><p>如果某一时刻，一方发现自己的 socket read buffer 满了，无法接受更多的TCP data，此时就是在接下来的发送包中指定通告窗口的大小为0，这样对方就不能接着发送TCP data了。<br>如果socket read buffer有了空间，可以重设通告窗口的大小在接下来的 TCP segment 中告知对方。<br>可是万一这个 TCP segment 不附带任何data，所以即使这个segment丢失也不会知晓（ACKs are not acknowledged, only data is acknowledged）。对方没有接受到，便不知通告窗口的大小发生了变化，也不会发送TCP data。这样双方便会一直僵持下去。</p><p>TCP协议采用这个机制避免这种问题：对方即使知道当前不能发送TCP data，当有data发送时，过一段时间后，也应该尝试发送一个字节。这段时间便是 Persist Timer 。</p><h3 id="Keepalive-Timer"><a href="#Keepalive-Timer" class="headerlink" title="Keepalive Timer"></a>Keepalive Timer</h3><p>TCP socket 的 SO_KEEPALIVE option，主要适用于这种场景：连接的双方一般情况下没有数据要发送，仅仅就想尝试确认对方是否依然在线。<br>具体实现方法：TCP每隔一段时间（tcp_keepalive_intvl）会发送一个特殊的 Probe Segment，强制对方回应，如果没有在指定的时间内回应，便会重传，一直到重传次数达到 tcp_keepalive_probes 便认为对方已经crash了。</p><blockquote></blockquote><ul><li>tcp_keepalive_intvl (integer; default: 75; since Linux 2.4)<br>The number of seconds between TCP keep-alive probes.<br>tcp_keepalive_probes (integer; default: 9; since Linux 2.2)<br>The maximum number of TCP keep-alive probes to send before giving up and killing the connection if no response is obtained from the other end.</li><li>tcp_keepalive_time (integer; default: 7200; since Linux 2.2)<br>The number of seconds a connection needs to be idle before TCP begins sending out keep-alive probes. Keep-alives are only sent when the SO_KEEPALIVE socket option is enabled. The default value is 7200 seconds (2 hours). An idle connection is terminated after approximately an additional 11 minutes (9 probes an interval of 75 sec‐onds apart) when keep-alive is enabled.<br>Note that underlying connection tracking mechanisms and application timeouts may be much shorter.</li></ul><h3 id="FIN-WAIT-2-Timer"><a href="#FIN-WAIT-2-Timer" class="headerlink" title="FIN_WAIT_2 Timer"></a>FIN_WAIT_2 Timer</h3><p>当主动关闭方想关闭TCP connection，发送FIN并且得到相应ACK，从FIN_WAIT_1状态进入FIN_WAIT_2状态，此时不能发送任何data了，只等待对方发送FIN。可以万一对方一直不发送FIN呢？这样连接就一直处于FIN_WAIT_2状态，也是很经典的一个DoS。因此需要一个Timer，超过这个时间，就放弃这个TCP connection了。</p><blockquote></blockquote><ul><li>tcp_fin_timeout (integer; default: 60; since Linux 2.2)<br>This specifies how many seconds to wait for a final FIN packet before the socket is forcibly closed. This is strictly a violation of the TCP specification, but required to prevent denial-of-service attacks. In Linux 2.2, the default value was 180.</li></ul><h3 id="TIME-WAIT-Timer"><a href="#TIME-WAIT-Timer" class="headerlink" title="TIME_WAIT Timer"></a>TIME_WAIT Timer</h3><p>主动关闭连接的一方收到对方的FIN 和ACK之后会进入TIME_WAIT状态, TIME_WAIT持续两个MSL之后才会进入CLOSED</p><p>@ref: <a href="http://blog.qiusuo.im/blog/2014/03/19/tcp-timeout/" target="_blank" rel="noopener">TCP协议的那些超时 - On the road</a></p><h2 id="参考-ref"><a href="#参考-ref" class="headerlink" title="参考 @ref"></a>参考 @ref</h2><ul><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上） | | 酷 壳 - CoolShell</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下） | | 酷 壳 - CoolShell</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 22.Network-Protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议-OSI七层模型</title>
      <link href="/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>OSI七层模型;</li><li>七层、五层、四层对比;</li></ul><p>➤ 七层模型: 国际标准组织（ISO）定义的网络互联7层框架, 包括:</p><ul><li>7应用层: 该层协议包括 Socket, HTTP, HTTPS, FTP, SSH, POP3,  // WebSocket属于哪一层?</li><li>6表示层: 格式转换, 把数据转换为应用层能兼容的格式 或 适合传输的格式, 比如: 加密/解密, 压缩/解压</li><li>5会话层: 维护和管理数据传输过程中两台计算机之间的连接, 该层协议有: SSL/TLS</li><li>4传输层: 传输控制, 例如TCP协议(传输控制协议, 主要实现了传输的可靠性, 例如超时重传), 该层把「传输表头」TH加入数据形成「报文」Segment, 传输表头包括了传输协议等</li><li>3网络层: 决定数据的路由, 例如IP/ICMP协议, 该层把「网络表头」NH加入数据形成「包」Packet, 网络表头包括: @todo</li><li>2链路层: 负责网络寻找和错误侦测, 该层把「数据链表头」DLH加入数据开头, 以及「数据链表尾」DLT加入数据结尾, 形成「信息框」Data Frame, 数据链表头包括, 该层协议包括WiFi, GPRS(通用分组无线服务)</li><li>1物理层: 在局部局域网上传送「数据帧」Data Frame, 该层定义了网络硬件和网络数据之间的互通, 包括: 针脚/电压/集线器/网卡等</li></ul><p>➤ 7,5,4层网络模型的区别与联系:</p><p><img src="/images/network_protocol/OSI-7-Layer-Model.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 22.Network-Protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议-IP</title>
      <link href="/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP/"/>
      <url>/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP/</url>
      
        <content type="html"><![CDATA[<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ul><li>IPv4地址由4字节(32位)组成, 每个字节范围0-255</li><li>子网掩码（subnet mask）把一个IPv4地址划分为 网络地址 和 主机地址, <code>255.255.255.0</code> 表示前3个字节是网络地址, 第4个字节是主机地址</li><li>子网掩码另一种表示方式 <em>CIDR(Classless Inter-Domain Routing)</em>: <ul><li><code>192.168.1.0/24</code> 其中24表示子网掩码前24位全为1, 同<code>255.255.255.0</code> </li><li><code>172.16.82.0/25</code>表示子网掩码是<code>前25bit都是子网地址，后7bit是主机地址</code>，所以主机数为<code>2^7 -2</code>=126个，表示的范围是172.16.82.1 — 172.16.82.126</li><li><code>10.0.0.0/8</code>表示 10.0.0.1 — 10.255.255.255</li></ul></li><li>广播地址: 主机地址全1</li></ul><h2 id="A-B-C类地址"><a href="#A-B-C类地址" class="headerlink" title="A,B,C类地址"></a>A,B,C类地址</h2><ul><li>A类地址： 网络地址1字节，主机地址3字节，其中网络地址最高1位必须是0<ul><li>网络地址占1位，范围是1 — 126（开区间 0000 0000 — 0111 1111）不包括0000 0000 和 0111 111，前者用于表示未知地址，后者表示回环地址</li><li>主机地址占3位，表示一个网络地址中最大主机数是<code>2^24 - 2</code>（主机地址全0表示网络地址，全1表示广播地址，所以减2）</li><li>A类地址范围： <code>1.0.0.1</code> — <code>126.255.255.254</code></li><li>默认子网掩码255.0.0.0</li><li>在A类地址中，10.0.0.0到10.255.255.255是私有地址（所谓的私有地址=只能在局域网络中使用）</li></ul></li><li>B类地址： 网络地址2字节，主机地址2字节，其中网络地址最高2位必须是10<ul><li>B类地址范围：<code>128.0.0.1</code> — <code>191.255.255.254</code>，每个网络中最大主机数65534</li><li>默认子网掩码255.255.0.0</li><li>在B类地址中，172.16.0.0 — 172.31.255.255是私有地址</li></ul></li><li>C类地址： 网络地址3字节，主机地址1字节，其中网络地址最高3位必须是110<ul><li>C类地址范围：<code>192.0.0.1</code> — <code>223.255.255.254</code>，每个网络中最大主机数254</li><li>默认子网掩码255.255.255.0</li><li>在C类地址中，192.168.0.0 — 192.168.255.255是私有地址</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 22.Network-Protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议：HTTP</title>
      <link href="/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-HTTP/"/>
      <url>/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>HTTP由URL(统一资源定位符)访问资源，一个完整的URL组成如下:</p><blockquote><p><a href="http://user:passwd@www.x.com:80/index.htm?var1=1&amp;var2=2#frag" target="_blank" rel="noopener">http://user:passwd@www.x.com:80/index.htm?var1=1&amp;var2=2#frag</a><br>这个真没什么好解释的… 更多有关URL的信息请参考RFC1808</p></blockquote><h2 id="URL编码-amp-解码"><a href="#URL编码-amp-解码" class="headerlink" title="URL编码 &amp; 解码"></a>URL编码 &amp; 解码</h2><p>URL中的GET参数和POST内容，除字母数字。  常用编程符号(不含双引)之外，都要Encode处理，空格被转换为<code>+</code>号，<code>+</code>号被转换为<code>%2b</code><br>Encode处理过的POST内容，Http头会增加<code>content-type: application/x-www-form-urlencoded</code>，参考Content-Type一节。</p><h1 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h1><p>一个完整的请求分<code>请求头</code>和<code>消息体</code>两部分:</p><ul><li>请求头的每一行都是CRLF结尾，和消息体之间有一个空行分隔开，空行只能是一个CRLF而不能带有空格符。</li><li>消息体则是也包括头部和内容. 头包括Allow、Content-Type、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-Type、Expires等等。</li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>HTTP请求共有8种Method，Method是区分大小写的:</p><ul><li>OPTIONS: 查询服务器支持哪些action。</li><li>HEAD: 请求服务器返回url对应资源的响应头，并不需要服务器返回响应消息体。</li><li>GET: 请求url指定的资源。</li><li>POST: 向url指定的位置增加数据。</li><li>PUT: 上传资源。</li><li>DELETE: 删除资源</li><li>TRACE: 多用于诊断</li><li>CONNECT: 备用</li></ul><blockquote><p>PUT：client对一个URI发送一个Entity，服务器在这个URI下如果已经又了一个Entity，那么此刻服务器应该替换成client重新提交的，也由此保证了PUT的幂等性。如果服务器之前没有Entity ，那么服务器就应该将client提交的放在这个URI上。<br>因为服务器在实现POST是不可预知，所以将其定义为不安全、不幂等的Verb。基本上不能方便的归纳为“增删改”之类的行为，都可以使用POST方法。</p></blockquote><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>怎么理解HTTP幂等性:<br>HTTP幂等方法，是指无论调用多少次返回的结果都相同，对资源没有影响。</p><blockquote><p>HTTP GET方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。<br>HTTP POST方法是一个非幂等方法，因为每次调用都将产生新的资源。<br>HTTP PUT直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。<br>HTTP DELETE方法用于删除资源，会将资源删除。调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p></blockquote><h2 id="Content-type"><a href="#Content-type" class="headerlink" title="Content-type"></a>Content-type</h2><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式</li><li>text/xml ：  XML格式</li><li>image/gif ：gif图片格式</li><li>application/xml     ： XML数据格式</li><li>application/json    ： JSON数据格式</li><li>application/msword  ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li></ul><p>POST提交表单几种常见Content-type</p><ul><li>application/x-www-form-urlencoded: 格式为<code>k=v&amp;k=v</code>, 并且经过encode</li><li>multipart/form-data: 多用来上传数据</li><li>application/json: http的body是json格式</li></ul><h1 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h1><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Response Header第一行是服务器返回的状态码:</p><ul><li>200: OK</li><li>204: No Content</li><li>301: 永久重定向</li><li>302: 临时</li><li>400: Bad Request，比如缺少参数，语法错误</li><li>401: Unauthorized</li><li>403: Forbidden</li><li>404: Not Found</li><li>500: Internal Server Error 服务器内部错误</li><li>502: Bad Gateway 后端服务返回给网关无效响应()</li><li>503: Service Unavailable 后端服务由于维护或者过载，积极拒绝服务</li><li>504: Gateway Timeout 代理从后端服务器获取超时</li></ul><p>[[../31.Backend/反向代理-Nginx#Nginx返回502 503 504]]</p><h2 id="Http-Request和Response的一些常用参数"><a href="#Http-Request和Response的一些常用参数" class="headerlink" title="Http Request和Response的一些常用参数"></a>Http Request和Response的一些常用参数</h2><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type:"></a>Content-Type:</h3><p>常见的Content-Type:</p><ul><li>text/html</li><li>text/plain</li><li>text/css</li><li>text/javascript</li><li>application/x-www-form-urlencoded: 常用的表单发包方式，POST内容做了URLEncode处理会自动加上这个参数</li><li>multipart/form-data</li><li>application/json</li><li>application/xml</li></ul><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control:"></a>Cache-Control:</h3><h3 id="Location"><a href="#Location" class="headerlink" title="Location:"></a>Location:</h3><p>用于将客户端重定向一个新的地址，一般和302状态值相关。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length:"></a>Content-Length:</h4><p>指定response的长度，如果一个response太大服务器无法确定其长度，服务器会在response头部插入一个 <code>Transfer-Encoding: chunked</code>字段，表示需要分块传输. 这个response的<code>消息体</code>包括数个chunk，每个chunk都由<code>本chunk字节数+CRLF</code> + <code>本chunk内容+CRLF</code>组成，最后会带一个长度为0的chunk表示结束。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line">1A</span><br><span class="line">and this is the second one</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS的端口是443，HTTP的端口是80，二者的区别还在于HTTPS是在普通HTTP和TCP之间插入了一个SSL(Secure SocketLaye，基于非对称/对称加密算法的协议)。</p><h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>SSL使用了RSA非对称加密，SSL握手过程:</p><ul><li>客户端发出请求，服务端发送给客户端证书和公钥;</li><li>客户端先验证服务端的证书有效性，然后随机生成<code>预备密码</code>(pre-master secret)，用公钥加密发给服务器;</li><li>服务器用私钥解密出<code>预备密码</code>，然后双方用<code>预备密码</code>商议出<code>主密码</code>(master secret)，SSL握手结束;</li><li>之后C/S端使用<code>主密码</code>做对称加密传输数据。</li></ul><h2 id="SSL的证书"><a href="#SSL的证书" class="headerlink" title="SSL的证书"></a>SSL的证书</h2><p>SSL证书由CA(“证书中心”certificate authority)颁发，CA将网站的的公钥，用CA的私钥加密，生成为<code>数字证书</code>(Digital Certificate). 也就是说网站的数字证书里是含有网站的公钥的，客户端可以从CA处请求验证这个证书是否正确。<br>@ref: <a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">阮一峰:数字签名是什么？</a></p><h1 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h1><h2 id="符合Restful风格"><a href="#符合Restful风格" class="headerlink" title="符合Restful风格"></a>符合Restful风格</h2><ul><li>URI中只有名词, 表示资源</li><li>动词不应该出现在URI中, 而使用HTTP协议里的<code>GET, POST, DELETE, PUT</code>对应查询, 新增, 删除, 更新;</li><li>接口返回JSON, 或者XML</li><li>返回Code用HTTP状态表示</li><li><a href="https://github. com/tianlu1677/filemanager/wiki/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8RESTful%E6%9E%B6%E6%9E%84%EF%BC%9F" target="_blank" rel="noopener">为什么要采用RESTful架构？·tianlu1677/filemanagerWiki·GitHub</a></li></ul><h2 id="Java对Restful的支持"><a href="#Java对Restful的支持" class="headerlink" title="Java对Restful的支持"></a>Java对Restful的支持</h2><ul><li>用Java技术创建RESTfulWeb服务（JAX-RS）:<a href="https://www.ibm.com/developerworks/cn/web/wa-jaxrs/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/wa-jaxrs/</a></li></ul><h2 id="Restful框架"><a href="#Restful框架" class="headerlink" title="Restful框架"></a>Restful框架</h2><ul><li>Jersey, Restx …</li><li>使用Jersey创建RESTful WebService: <a href="http://www.importnew.com/7336.html" target="_blank" rel="noopener">http://www.importnew.com/7336.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 22.Network-Protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> HTTP </tag>
            
            <tag> Restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcpdump</title>
      <link href="/22.Network-Protocol/Tcpdump/"/>
      <url>/22.Network-Protocol/Tcpdump/</url>
      
        <content type="html"><![CDATA[<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tcpdump -i any port 9542 -w file_name.pcap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcpdump -s0 -i any 'udp and (src port 1719 or 18000) and (src host 9.143.243.8 or 9.143.243.18) and udp[0x10:4]=4444' -w file_name.pcap</span><br></pre></td></tr></table></figure><h2 id="Tcpdump支持的滚动参数"><a href="#Tcpdump支持的滚动参数" class="headerlink" title="Tcpdump支持的滚动参数"></a>Tcpdump支持的滚动参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump [ -AdDefIKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ]</span><br><span class="line">[ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -I interface ] [ -m module ] [ -M secret ] [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,... ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ expression ]</span><br></pre></td></tr></table></figure><ul><li><p>-G rotate_seconds:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If specified, rotates the dump file specified with the -w option every rotate_seconds seconds.  Savefiles will have the name specified by -w which should include a time format as defined by strftime(3).  If no time format is specified, each new file will overwrite the previous.</span><br><span class="line"></span><br><span class="line">If used in conjunction with the -C option, filenames will take the form of &apos;file&lt;count&gt;&apos;.</span><br></pre></td></tr></table></figure></li><li><p>-C file_size:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Before writing a raw packet to a savefile, check whether the file is currently larger than file_size and, if so, close the current savefile and open a new one.  Savefiles after the first savefile will have the name specified with the -w flag, with a number after it, starting at 1 and continuing upward.  The units of file_size are millions of bytes (1,000,000 bytes, not 1,048,576 bytes).</span><br></pre></td></tr></table></figure></li><li><p>-W filecount:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Used in conjunction with the -C option, this will limit the number of files created to the specified number, and begin overwriting files from the beginning, thus creating a &apos;rotating&apos; buffer. In addition, it will name the files with enough leading 0s to support the maximum number of files, allowing them to sort correctly.</span><br><span class="line"></span><br><span class="line">Used in conjunction with the -G option, this will limit the number of rotated dump files that get created, exiting with status 0 when reaching the limit. If used with -C as well, the behavior will result in cyclical files per timeslice.</span><br></pre></td></tr></table></figure></li><li><p>-w file</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-w /var/tmp/trace-%m-%d-%H-%M-%S-%s will give you %m=month, %d=day of month, %H=hour of day, %M=minute of day, %S=second of day, %s=millisecond of day</span><br></pre></td></tr></table></figure></li></ul><p>For Example:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i en0 -w /var/tmp/trace -W 48 -G 1800 -C 100</span><br></pre></td></tr></table></figure></p><p>This will rotate files (of names trace1, trace2, …) cyclically, with period 48, either every 1800 seconds (=30 minutes) or every 100 MB, whichever comes first.</p><hr><p>@ref:</p><ul><li><a href="https://superuser.com/questions/904786/tcpdump-rotate-capture-files-using-g-w-and-c" target="_blank" rel="noopener">https://superuser.com/questions/904786/tcpdump-rotate-capture-files-using-g-w-and-c</a></li><li><a href="https://linux.die.net/man/8/tcpdump" target="_blank" rel="noopener">https://linux.die.net/man/8/tcpdump</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 22.Network-Protocol </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么要内存对齐</title>
      <link href="/21.Operating-System/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/21.Operating-System/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="https://www.zhihu.com/question/27862634/answer/38506197" target="_blank" rel="noopener">如何理解 struct 的内存对齐？ - 張道遠 的回答 - 知乎</a></p><p>为什么 32 位 CPU，Struct 默认是 4 字节对齐的？ </p><ul><li>一般的答案是：CPU 访问内存必须以 4 字节倍数开始，CPU 可以在一个总线周期读取一个‘word’，如果地址是非 4 字节对齐，CPU 可能要花费两个总线周期读取一个 word</li><li>注意这里的字和字长的概念： ‘字’也即 word，一般来说一个 word 占用 4 字节，‘字长’也即 wordSize（4）</li></ul><p>进一步问，为什么 CPU 访问内存必须以 4 字节开头？ …<br>32 位 CPU（字长也即 wordSize = 4 字节），地址总线宽度是 30，这个 30 是怎么定义出来的？</p><hr><p>@ref: <a href="https://blog.51cto.com/u_12945177/1951667" target="_blank" rel="noopener">对内存对齐的深一步理解_12935177的技术博客_51CTO博客</a></p><p>ARM CPU 有以下几条指令：</p><ul><li>LDR/STR： address must be 4-byte aligned </li><li>LDRH/STRH： address must be 2-byte aligned // H=Half </li><li>LDRB/STRB： address must be byte aligned   // B = Byte</li></ul><p><code>reinterpret_cast&lt;int*&gt; ptr</code> 将调用 LDR, 但如果 ptr 不是 4 字节对齐，则会报错。<br>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *buffer[1024]; // 假设buff地址是0x0000,0000</span><br><span class="line">char ch = *buffer;  // 调用LDB</span><br><span class="line">int i = *reinterpret_cast&lt;int*&gt;(buffer+1); //在0x0001地址使用LDR，没有对齐，报错</span><br></pre></td></tr></table></figure><p>从 buff+1 取 4 字节，正确做法是 memcpy： <code>memcpy(&amp;i, buffer+1, 4)</code>，memcpy 是如何实现的？ </p><p>memcpy （ARM 平台的实现）先检测是 dst 地址否 4 字节对齐，如果是，则直接 LDR 逐 4 字节读取，如果没有对齐，则先用 LDRB 逐字节读取，到对齐后再 LDR</p><p>面试题场景的手写 memcpy 实现（通常没有用到逐 word 拷贝，而是用 <code>char*</code> 逐 byte 拷贝）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链接：https://www.nowcoder.com/questionTerminal/9602083ec8d749999d86adf8a725b4f7</span></span><br><span class="line"><span class="comment">// 来源：牛客网</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp, *s;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dest &lt;= src)                     <span class="comment">//没有内存重叠，从低地址开始复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = (<span class="keyword">char</span> *) dest;</span><br><span class="line">        s = (<span class="keyword">char</span> *) src;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            *tmp++ = *s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                 <span class="comment">//有内存重叠，从高地址开始复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = (<span class="keyword">char</span> *) dest + n;</span><br><span class="line">        s = (<span class="keyword">char</span> *) src + n;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            *--tmp = *--s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux.31.Posix接口</title>
      <link href="/21.Operating-System/Linux.31.Posix%E6%8E%A5%E5%8F%A3/"/>
      <url>/21.Operating-System/Linux.31.Posix%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><ul><li>返回0: 子进程</li><li>返回&gt;0: 父进程, 返回值是子进程pid</li><li>子进程会得到父进程的堆(IO缓存, malloc的内存)、栈(局部变量)、数据空间(Data Segment)的拷贝, 在子进程里修改这些变量并不会影响父进程中的值, 注意这种拷贝是“写时复制”（Copy On Write，COW）;</li><li>fork前打开的文件句柄, 其偏移量会在父子进程间共享, 原因是进程内存中仅保存了文件句柄的fd指针, 指针指向的结构体(也就是文件表,保存了文件标准和位移)是共享的. @Uncertain 那么”文件表”是存储在哪里的?</li><li>另外需要注意的是, 因为堆内存也将被拷贝(IO缓存在堆里), 所以如果在创建子进程之前这个IO缓存中就有数据, 那么也会带入子进程, 导致子进程的IO缓存里”多”出一些数据.</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// child process because return value zero</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello from Child!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parent process because return value non-zero.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello from Parent!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><ul><li>返回值同 fork</li><li>不同点1: vfork创建的子进程与父进程共享数据段, 在子进程中修改变量也会影响到父进程中的变量</li><li>不同点2: vfork的子进程优先于父进程执行, 当子进程明确<code>_exit()</code> 或者<code>exit()</code>之后, 父进程才会继续执行.</li></ul><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>clone可以看成是fork的升级版, 不仅可以创建进程或者线程, 还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><ul><li>正常三种: return 语句, exit() 或 _exit(),</li><li>非正常: abort(), 调用该函数之后, 调用者会收到 SIGABRT</li></ul><h2 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait/waitpid"></a>wait/waitpid</h2><ul><li><code>pit_t wait(int *status)</code>: 父进程调用后立刻阻塞, 直到第一个子进程结束, 子进程结束后系统会发送SGICHLD信号, 收到这个信号后, 父进程从wait返回</li><li><code>pid_t waitpid(pid_t pid, siginfo_t *infop, int options)</code>, 等待指定的进程</li></ul><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>fork 或者 vfork之后往往需要再调用 exec启动另一个新程序, 因为 exec不创建新进程, 所以pid不会变, 原程序的 Text Seg, Data Seg, Heap/Stack会被替换</p><h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><ul><li>僵尸进程(zombie process): ps显示stat为”z”的进程<ul><li>产生原因: 子进程退出后(exit, 或发生错误), 子进程仍存在于进程表, 当父进程调用wait之后才会从进程表删除. 如果子进程死掉但是父进程没有调用wait, 子进程就变成了僵尸进程;</li><li>正确做法: 子进程死后, 系统会向父进程发生SIGCHLD信号, 父进程收到此信号后应该用wait处理子进程;</li><li>如果父进程没有处理SIGCHLD信号, 那么只能kill父进程, 让init成为子进程的父进程, init进程会周期性调用wait清理Zombie进程.</li><li>处理SIGCHLD信号示例代码: <a href="https://docs.oracle.com/cd/E19455-01/806-4750/signals-7/index.html" target="_blank" rel="noopener">https://docs.oracle.com/cd/E19455-01/806-4750/signals-7/index.html</a></li></ul></li><li>孤儿进程(orphan process): 父进程死掉, 子进程被init进程接管</li><li>守护(Daemon)进程: 守护进程就是后台服务进程, 因为它会有一个很长的生命周期提供服务, 关闭终端不会影响服务, 也就是说可以忽略某些信号<ul><li>如何实现Deamon进程:<ul><li>父进程exit</li><li>command &amp;</li><li>nohup command</li></ul></li></ul></li></ul><h2 id="守护进程（daemon）"><a href="#守护进程（daemon）" class="headerlink" title="守护进程（daemon）"></a>守护进程（daemon）</h2><p><a href="https://blog.csdn.net/yangbodong22011/article/details/78650896" target="_blank" rel="noopener">Linux 守护进程原理及实例（Redis、Nginx） - CSDN博客</a></p><ul><li>守护进程不属于任何一个控制终端, 不属于任何一个会话(Session)</li><li>守护进程没的父进程是0 @Uncertain</li><li>守护进程会忽略一些signal（包括处理信号SIGHUP（进程和控制终端分离时收到SIGHUP）、 SIGTERM（系统关机之前收到SIGTERM）</li></ul><h1 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><p>@ref</p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/index.html" target="_blank" rel="noopener">深刻理解Linux进程间通信（IPC）</a> </li></ul><p>进程间通信（IPC）= InterProcess Communication,</p><p>Linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力AT&amp;T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux则把两者继承了下来，如图示：</p><p><img src="/images/20220314225200.png" alt=""><br>最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括： Posix消息队列、Posix信号灯、Posix共享内存区。</p><p>这里主要介绍POSIX标准的IPC: </p><ul><li>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li><li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；</li><li>报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li><li>套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><a href="https://www.jianshu.com/p/b3c62923f808" target="_blank" rel="noopener">Linux的进程间通信：管道(转) - 简书</a></p><p>Linux上的管道分两种类型： 匿名管道、命名管道</p><ul><li>匿名管道(PIPE):<ul><li>最常见的形态就是我们在shell操作中最常用的”|”</li><li>只能在父子进程中使用</li><li>系统调用: <code>int pipe(int pipefd[2])</code></li></ul></li><li>命名管道(FIFO):<ul><li>命名管道在底层的实现跟匿名管道完全一致，区别只是命名管道会有一个全局可见的文件名以供别人open打开使用</li><li>系统调用: <code>int mkfifo(const char *pathname, mode_t mode)</code></li></ul></li></ul><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html" target="_blank" rel="noopener">Linux环境进程间通信（五）: 共享内存（上）</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html" target="_blank" rel="noopener">Linux环境进程间通信（五）: 共享内存（下）</a></li></ul><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p><code>kill -l</code> 可以查看所有支持的信号和其对应值, 产生信号有下面几种方式:</p><ul><li>用户按键产生信号<ul><li>Ctrl-C : SIGINT, 中断(Interrupt), 只能向前台进程发送, 可忽略</li><li>Ctrl-\ : SIGQUIT, 退出(Quit), 可忽略</li><li>Ctrl-Z : SIGSTP, 停止(Stop), 挂起的进程可以fg恢复</li></ul></li><li>硬件产生信号<ul><li>除0: SIGFPE, CPU运算单元产生异常并发送给进程,</li><li>内存非法访问: SIGSEGV, 内存控制单元MMU产生</li></ul></li><li><code>kill()</code>函数产生信号<ul><li><code>kill</code> : SIGTERM, 可被忽略</li><li><code>kill -2</code> : SIGINT, 同Ctrl-C</li><li><code>kill -9</code> : SIGKILL, 不可忽略, 但导致进程无法完成清理?</li><li><code>kill -17</code> : SIGCHLD, 子进程死掉, 系统会向父进程发生SIGCHLD信号, 父进程可以选择是否处理</li><li><code>SIGCHLD</code>: 子进程死掉, 系统会向父进程发生SIGCHLD信号, 父进程可以选择是否处理</li><li><code>SIGHUP</code>: 在终端启动一个回话(session), 在这个终端里再启动的命令, 都是这个回话的子进程, 如果回话进程关闭, SIGHUP会被发送到所有子进程</li></ul></li></ul><blockquote><p>进程状态 R S D T X Z:<br>R: Running<br>S: Interruptible Sleep, 可中断的睡眠<br>D: Uninterruptible Sleep. 不可中断的睡眠, 比如等待磁盘IO, 这种进程不接受kill,kill -9的信号<br>T: Stoped, 按下Ctrl+Z的状态</p></blockquote><h2 id="Ctrl-z-和Ctrl-c"><a href="#Ctrl-z-和Ctrl-c" class="headerlink" title="Ctrl+z 和Ctrl+c"></a>Ctrl+z 和Ctrl+c</h2><ul><li>前者是SIGTSTP(挂起进程), 后者是SIGINT(中断进程), 进程接受SIGTSTP后, 用<code>bg 1</code>可以让被挂起的程序在后台继续执行, 命令中的”1”是job(作业号); 命令<code>fg 1</code>重新让进程切换到前台运行. 命令<code>jobs</code>查看在后台运行的任务.</li><li>SIGHUP信号和screen: <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-screen/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-cn-screen/</a></li></ul><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（上）</a> @Archived</li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（下）</a> @Archived</li></ul><h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><p>@ref: </p><ul><li><a href="https://zhuanlan.zhihu.com/p/73248894" target="_blank" rel="noopener">浅谈Linux Namespace机制（一） - 知乎</a></li><li>[<a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">Docker基础技术：Linux Namespace（上） | 酷 壳 - CoolShell</a>]</li></ul><p>对于Namespace的操作有以下方式：</p><ol><li>可以在进程刚创建的时候通过clone系统调用为新进程分配一个或多个新的Namespace。</li><li>通过setns()将进程加入到已有的Namespace中。</li><li>通过unshare()为已存在的进程创建一个或多个新的Namespace。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Posix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.21.网络编程</title>
      <link href="/21.Operating-System/Linux.21.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/21.Operating-System/Linux.21.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O相关概念"><a href="#I-O相关概念" class="headerlink" title="I/O相关概念"></a>I/O相关概念</h2><h3 id="缓存IO-Buffer-IO"><a href="#缓存IO-Buffer-IO" class="headerlink" title="缓存IO(Buffer IO)"></a>缓存IO(Buffer IO)</h3><ul><li><strong>缓存I/O</strong> 又被称作 <strong>标准I/O</strong> ，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。<ul><li>读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</li><li>写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。</li><li>缓存I/O的优点：1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；2）可以减少读盘的次数，从而提高性能。</li><li>缓存I/O的缺点：在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</li></ul></li></ul><h3 id="直接IO-Direct-IO"><a href="#直接IO-Direct-IO" class="headerlink" title="直接IO(Direct IO)"></a>直接IO(Direct IO)</h3><ul><li><strong>直接I/O</strong> 就是应用程序直接访问磁盘数据，而不经过内核缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制。比如说数据库管理系统这类应用，它们更倾向于选择它们自己的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。<ul><li>直接IO的缺点：如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载，这种直接加载会非常缓存。通常直接IO与异步IO结合使用，会得到比较好的性能。（异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待）</li></ul></li></ul><h3 id="缓存IO-vs-直接IO"><a href="#缓存IO-vs-直接IO" class="headerlink" title="缓存IO vs 直接IO"></a>缓存IO vs 直接IO</h3><p>写场景下的DirectIO和BufferIO:<br><img src="/images/operating_system/Linux-DirectIO-vs-BufferIO.png" alt=""></p><h2 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I/O模型"></a>五种I/O模型</h2><ol><li><strong>阻塞IO</strong>: 调用read, 如果内核数据未就绪, 调用read的进程进入阻塞状态。应用程序调用一个IO函数，导致应用程序阻塞并等待数据准备就绪。如果数据没有准备好，一直等待。如果数据准备好了，则从内核拷贝到用户空间拷贝数据，IO函数返回成功指示。<br><img src="/images/operating_system/Linux-IO-Blocked.png" alt=""></li><li><strong>非阻塞IO</strong>: nonblocking IO的特点是用户进程需要不断的主动询问kernel数据是否准备好. 当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试 数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。<br><img src="/images/operating_system/Linux-IO-NonBlocking.png" alt=""></li><li><strong>多路复用IO</strong>: 复用模型会用到select或者poll函数，这两个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。从而使得系统在单线程的情况下可以同时处理多个客户端请求. 与传统的多线程/多进程模型比, I/O多路复用的最大优势是系统开销小。<br>和阻塞IO模型相比，selectI/O复用模型相当于提前阻塞了。等到有数据到来时，再调用recv就不会因为要等数据就绪而发生阻塞。<ul><li>select: 一般采用select + no-block, select返回后要遍历所有阻塞在select上的IO句柄，找到数据就绪的那一个IO句柄后, 应用程序调用recvfrom将数据从内核区拷贝至用户区；</li><li>epoll : 比select更高效，无需轮询全部句柄，epoll只返回数据ready的IO句柄<br><img src="/images/operating_system/Linux-IO-Multiplexing.png" alt=""></li></ul></li><li><strong>信号驱动IO</strong>：让内核在数据就绪时用信号SIGIO通知我们，将此方法称为信号驱动I/O。首先，我们允许套接字进行信号驱动I/O，并通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的。当数据报准备好被读时，就为该进程生成一个SIGIO信号。我们随即可以在信号处理程序中调用 recvfrom 来取读数据报。</li><li><strong>异步IO</strong>: 我们让内核启动操作，并在整个操作完成后（包括将数据从内核拷贝到我们自己的缓冲区）通知我们。<br>调用aio_read函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。<br>上面其它四种模型，至少都会在由kernel copy data to appliction时阻塞。而该模型是当copy完成后才通知application，可见是纯异步的。<br>很少有<code>*nix</code>系统支持，windows的IOCP（完成端口）则是此模型<br><img src="/images/operating_system/Linux-IO-Async.png" alt=""></li></ol><h2 id="高性能I-O设计模式"><a href="#高性能I-O设计模式" class="headerlink" title="高性能I/O设计模式"></a>高性能I/O设计模式</h2><p><strong>I/O多路复用模式：Reactor &amp; Proactor</strong></p><p>  一般地,I/O多路复用机制（I/O multiplexing mechanisms）都依赖于一个事件多路分离器(Event Demultiplexer)。<br>我们常见的事件多路分用器包括：Linux 的 epoll 和 Windows 的 IOCP。</p><p>  <em>事件多路分离器</em>（Event Demultiplexer）可将来自事件源的I/O事件分离出来，并分发到对应的 <em>事件处理器</em> (Event Handler)进行read/write。<br>开发人员预先注册需要处理的事件及其事件处理器（或回调函数），<em>事件多路分离器</em> 负责将请求事件传递给 <em>事件处理器</em> 。<br>两个与事件分离器有关的模式是Reactor和Proactor，Reactor模式采用同步IO，而Proactor采用异步IO。</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>在Reactor中，<em>事件多路分离器</em> 等待文件描述符状态变为 读写操作准备就绪状态，然后将就绪事件传递给对应的 <em>处理器</em>，最后由 <em>处理器</em> 负责完成实际的读写工作。</p><p>Linux epoll使用Reactor模式，Reactor模式使用同步 I/O（一般来说）。Reactor的标准（典型）的工作方式是：</p><ul><li>Reactor线程中, epoll 注册读/写等等事件</li><li>epoll 等待事件到来</li><li>事件到来，Reactor把事件分发给处理器(往往使用线程池跑处理器)</li><li>处理器线程: 读写数据（调用read/write, 从内核buff将数据拷贝到用户态buff)</li><li>处理器线程进行处理(decode数据, 执行业务代码, encode数据)</li></ul><blockquote><p>与 Proactor 模式相比，Reactor 模式下，用户代码的责任是, 在收到可读写事件后进行实际的 I/O 操作。</p></blockquote><p>Reactor模式的线程模型 &amp; Java NIO实现的Reactor线程模型 @ref: [[../12.Java/Java-Tutorials.09.NIO#Reactor三种常见线程模型]]</p><h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>而在Proactor模式中，<em>处理器</em>，只负责发起异步读写操作。 <em>处理器</em> 传递给操作系统的参数需要包括 <em>用户定义的数据缓冲区地址</em> 和 <em>数据大小</em>，IO操作本身由操作系统来完成。<br>当可读写时, 操作系统完成从 <em>内核缓冲区</em> 和 <em>用户定义的数据缓冲区地址</em> 之间的数据拷贝。系统发出IO操作完成事件，由 <em>事件分离器捕获</em>，然后将事件传递给对应 <em>处理器</em>。<br>比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。IOCompletion通知的时候, 数据已经被拷贝到处理器的buff了.<br>典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。</p><p>Windows IOCP使用Proactor模式，Proactor模式使用异步 I/O。Proactor的标准（典型）的工作方式是：</p><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分离器等待操作完成事件</li><li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li><li>事件分离器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li></ul><blockquote><p>Proactor 模式下，用户在调用异步 I/O 时会传递一个 Buffer 给系统，系统进行实际的 I/O 操作并从传递给系统的 Buffer 中获取或者放入数据。</p></blockquote><p>以上参考: <a href="https://blog.csdn.net/robinjwong/article/details/50117091" target="_blank" rel="noopener">Reactor VS Proactor 模式</a> @ref</p><h3 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h3><h4 id="比较实现"><a href="#比较实现" class="headerlink" title="比较实现"></a>比较实现</h4><ul><li>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</li><li>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</li></ul><p>以主动写为例：</p><ul><li>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；</li><li>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</li></ul><h4 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h4><p><strong>√ Reactor优势</strong></p><ul><li>Reactor实现相对简单，对于耗时短的处理场景处理高效；</li><li>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；</li><li>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</li><li>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，</li></ul><p><strong>× Reactor劣势</strong></p><ul><li>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</li></ul><p><strong>√ Proactor优势</strong></p><ul><li>Proactor性能更高，能够处理耗时长的并发场景；</li></ul><p><strong>× Proactor劣势</strong></p><ul><li>Proactor依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，比较优秀的如windows IOCP（完成端口），但由于其windows系统用于服务器的局限性，目前应用范围较小；<br>而Unix/Linux系统对纯异步的支持尚不成熟，应用事件驱动的主流还是通过select/epoll来实现；</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；</li><li>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</li></ul><h4 id="在实际工程中的使用"><a href="#在实际工程中的使用" class="headerlink" title="在实际工程中的使用"></a>在实际工程中的使用</h4><ul><li>Reactor: libevent / libev /libuv / ZeroMQ / Event Library in Redis</li><li>Proactor: Windows IOCP / Boost.Asio</li></ul><h2 id="select-vs-poll-vs-epoll"><a href="#select-vs-poll-vs-epoll" class="headerlink" title="select vs poll vs epoll"></a>select vs poll vs epoll</h2><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>比较 select/poll/epoll</p><ul><li>select/poll/epoll AP</li><li>epoll_event 设置 “水平触发” 和 “边缘触发”</li><li>Java语言, Linux 下的<code>Selector</code>的实现是epoll (代码<code>sun.nio.ch.EPollSelectorProvider</code>)</li></ul><p>@ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/27441342" target="_blank" rel="noopener">Java NIO(7): Epoll版的Selector - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/149721215" target="_blank" rel="noopener">结合代码详细聊聊 Java 网络编程中的 BIO、NIO 和 AIO - 知乎</a></li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。<br>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>int poll (struct pollfd *fds, unsigned int nfds, int timeout);</code></p><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。<br>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><ol><li><p><code>int epoll_create(int size);</code><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p></li><li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</code><br>函数是对指定描述符fd执行op操作。</p></li></ol><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事件</li></ul><ol start="3"><li><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li></ol><h4 id="epoll工作模式"><a href="#epoll工作模式" class="headerlink" title="epoll工作模式"></a>epoll工作模式</h4><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p><ul><li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li><li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li></ul><h3 id="本章参考"><a href="#本章参考" class="headerlink" title="本章参考"></a>本章参考</h3><ul><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a> @ref</li></ul><blockquote><p>所谓同步，数据从存储介质拷贝到内核缓冲区（数据准备的过程）完成之后，需要用户自己将数据拷贝到用户缓冲区。所以，前4种IO模型都是同步的</p></blockquote><p>Linux I/O 模型的发展技术是： select -&gt; poll -&gt; epoll -&gt; aio -&gt; libevent -&gt; libuv。另外还有 Windows的 Completion Port。</p><blockquote><p>提供一致的接口，IO Design Patterns<br>实际上，不管是哪种模型，都可以抽象一层出来，提供一致的接口，广为人知的有ACE,Libevent这些，他们都是跨平台的，而且他们自动选择最优的I/O复用机制，用户只需调用接口即可。说到这里又得说说2个设计模式，Reactor and Proactor。有一篇经典文章<a href="http://www.artima.com/articles/io_design_patterns.html值得阅读，Libevent是Reactor模型，ACE提供Proactor模型。实际都是对各种I/O复用机制的封装。" target="_blank" rel="noopener">http://www.artima.com/articles/io_design_patterns.html值得阅读，Libevent是Reactor模型，ACE提供Proactor模型。实际都是对各种I/O复用机制的封装。</a></p></blockquote><h2 id="常用软件的并发处理"><a href="#常用软件的并发处理" class="headerlink" title="常用软件的并发处理"></a>常用软件的并发处理</h2><ul><li>Nginx:<ul><li>基于epoll监听多个连接(50000个并发连接数的响应), 当某个连接有数据准备好的时候再通知, 这样一个进程能处理多个连接</li><li>大于5k并发的时候, Nginx才明显比apache有更好的表现</li></ul></li><li>Redis<ul><li>Redis使用单线程的I/O复用模型, 自己封装了一个简单的AeEvent事件处理框架, 主要实现了epoll、kqueue和select.</li><li>优势: 对于单纯只有I/O操作来说, 单线程可以将速度优势发挥到最大.</li><li>缺陷：Redis排序、聚合等, 对于这些操作, 单线程模型实际会严重影响整体吞吐量, CPU计算过程中, 整个I/O调度都是被阻塞住的</li></ul></li><li>Apache: 默认是每个请求启动一个线程处理, 并不适合高并发<ul><li>缺陷:<ul><li>有多少并发就需要多少进程, 最大进程数</li><li>在进程创建很多的情况下, 系统切换进程的代价很高, 进程运行的时间很少</li><li>实际上本机处理数据的时间很短, 大多数时间都是在”等待数据准备好”的阶段, 效率低</li></ul></li><li>新版的Apache的改进, 支持多种MPM(Multi-Processing Model)<ul><li>prefork: 古老</li><li>worker: 多进程(注意并不是每个请求一个线程), 每个进程多个线程</li><li>event: epoll</li></ul></li></ul></li><li>Tomcat: 每个请求启动一个线程处理<ul><li>Tomcat 从 JDK 1.6支持开始支持NIO</li></ul></li></ul><h3 id="多线程-vs-多进程"><a href="#多线程-vs-多进程" class="headerlink" title="多线程 vs 多进程"></a>多线程 vs 多进程</h3><ul><li>多进程方式：为每个请求启动一个进程来处理.<ul><li>优点: 进程之间是独立的, 单个进程问题不会影响其他进程</li><li>缺点: 切换进程代价较大, 而且进程间资源是独立的, 造成内存重复利用</li></ul></li><li>多线程<ul><li>优点: 线程间部分数据是共享的, 线程间的切换所需资源开销比进程间切换小得多</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux.12.CPU</title>
      <link href="/21.Operating-System/Linux.12.CPU/"/>
      <url>/21.Operating-System/Linux.12.CPU/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h1><p>→ <a href="/21.Operating-System/CPU的缓存/" title="CPU的缓存">CPU的缓存</a></p><h1 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h1><ul><li>CPU的指令分为特权级指令和非特权级指令, 特权级指令通常是一些比较危险的指令, Intel X86架构的CPU将特权等级分为4个级别：<code>RING0</code>,<code>RING1</code>,<code>RING2</code>,<code>RING3</code>. 操作系统通过区分用户态和内核态来保证特权级指令不被错误的使用.</li><li>Linux仅仅使用了RING0和RING3来分别运行内核态和用户态.</li></ul><h2 id="用户态到内核态的切换"><a href="#用户态到内核态的切换" class="headerlink" title="用户态到内核态的切换"></a>用户态到内核态的切换</h2><ol><li>普通程序进行系统API调用时主动要求切换到内核态, 此时用户态进程要向内核态传递参数, 同时保存用户进程的寄存器、变量等, 以便切换回来时能正确继续执行, 这个过程就是进程 <strong>上下文切换</strong>, 过程如下:<ul><li>保存 CPU 寄存器里原来用户态的指令位</li><li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置</li><li>跳转到内核态运行内核任务</li><li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</li><li>一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态）</li></ul></li><li>异常事件：当CPU在执行运行在用户态下的程序时, 发生了某些事先不可知的异常, 这时会触发由当前运行进程切换到处理此异常的内核相关程序中, 也就转到了内核态, 比如缺页异常.</li><li>硬件中断:当外围设备完成用户请求的操作后, 会向CPU发出相应的中断信号, 这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序, 如果先前执行的指令是用户态下的程序, 那么这个转换的过程自然也就发生了由用户态到内核态的切换</li></ol><p><img src="/images/operating_system/linux_system_call.png" alt=""></p><p>参考: <a href="https://www.ibm.com/developerworks/cn/linux/l-system-calls/index.html" target="_blank" rel="noopener">使用 Linux 系统调用的内核命令</a> @ref</p>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.11.内存</title>
      <link href="/21.Operating-System/Linux.11.%E5%86%85%E5%AD%98/"/>
      <url>/21.Operating-System/Linux.11.%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内存布局"><a href="#Linux内存布局" class="headerlink" title="Linux内存布局"></a>Linux内存布局</h1><h2 id="32位"><a href="#32位" class="headerlink" title="32位:"></a>32位:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  0xFFFFFFFF 高地址</span><br><span class="line"> +---+--------------------+--------------------</span><br><span class="line">1 GB |   Kernel           |                  内核空间 </span><br><span class="line"> +------------------------+--------------------</span><br><span class="line"> |   | Random stack offset|                  用户空间 ↓</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   |   Stack↓           |  进程中的所有的线程共享相同的地址空间</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   |                    |</span><br><span class="line"> |   |                    |</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Mem Mapping        | 文件映射,so库文件等</span><br><span class="line"> |   |                    | mmap()</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> +   |                    |</span><br><span class="line">3 GB |                    |</span><br><span class="line"> +   +--------------------+</span><br><span class="line"> |   |    Heap↑           | malloc()</span><br><span class="line"> |   |                    | brk()</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Random stack offset|</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | BSS Seg.           |</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Data Seg. (+rodata)|</span><br><span class="line"> |   +--------------------+</span><br><span class="line"> |   | Text Seg.          |                  用户空间 ↑</span><br><span class="line"> +---+--------------------+--------------------</span><br><span class="line">  0x00000000 低地址</span><br></pre></td></tr></table></figure><p>内存布局从高地址到低地址:</p><ul><li><code>Kernel</code>: 内核空间在页表中拥有较高的特权级（ring 2或以下）, 因此只要用户态的程序试图访问这些页, 就会导致一个页错误（page fault）, 用户程序不可访问内核页</li><li><code>Stack</code>: 自高地址向低地址增长, 每个进程都有一个自己的栈, 当不断压栈直到超过了最大的栈空间, 将会引起Stack Overflow, 进程中的每一个线程都有属于自己的栈</li><li><code>Memory Mapping Segment</code>: mmap()实现”文件-内存映射”, 它被用于加载动态库, 大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域, 这个区域自高地址向低地址增长</li><li><code>Heap</code>: malloc()分配的内存空间, 如果堆中有足够的空间来满足内存请求, 它就可以被语言运行时库处理而不需要内核参与. 否则堆会被扩大, 通过<code>brk()</code>系统调用来分配请求所需的内存块, 堆自低地址向高地址增长</li><li><code>BSS Segment</code>: 未赋初始值的static变量, 包括全局的static变量和函数内定义的static变量(全局变量默认就是static)</li><li><code>Data Segment</code>: 有初始值的static变量, 程序bin映像的一部分<ul><li>还包括一个叫<code>rodata</code>的区域, 存储”字面量字符串”(包括全局/局部定义的字面量字符串), 以及”const常量”</li></ul></li><li><code>Text Segment</code>: 这里存放的是二进制代码</li></ul><p>更详细的解释参考@ref: <a href="https://whatsdjgpp.github.io/%E6%97%A7%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/blog_archive/Coding/[C]%20GNU%E7%9A%84obj%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8(nm,%20objdump" target="_blank" rel="noopener">GNU的obj分析工具的使用(nm, objdump) | 扔掉笔记</a>/)</p><h2 id="64位"><a href="#64位" class="headerlink" title="64位:"></a>64位:</h2><blockquote><p>64位架构下内存布局与32位类似, 可寻址64TB(Intel架构下是46个地址线, 2^46)</p></blockquote><p><img src="/images/operating_system/64bit_linux_memory.png" alt="64bit_linux_memory"></p><h3 id="How-to-查看某个进程的内存分布"><a href="#How-to-查看某个进程的内存分布" class="headerlink" title="How to 查看某个进程的内存分布"></a>How to 查看某个进程的内存分布</h3><ul><li><code>cat /proc/xxx/maps</code></li></ul><h1 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h1><p>内存寻址(Memory Addressing):<br>分段机制把<code>逻辑地址</code>转换为<code>线性地址</code>, 分页机制进一步把该<code>线性地址</code>再转换为<code>物理地址</code>.</p><h2 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h2><blockquote><p>内存可寻址范围总是跟”地址总线宽度”和”寄存器宽度”相关</p></blockquote><h3 id="实模式的诞生（16位处理器及寻址）"><a href="#实模式的诞生（16位处理器及寻址）" class="headerlink" title="实模式的诞生（16位处理器及寻址）"></a>实模式的诞生（16位处理器及寻址）</h3><ul><li>在8086处理器诞生之前, 内存寻址方式就是直接访问物理地址. 8086处理器为了寻址1M的内存空间, 把地址总线扩展到了20位. 但是, 一个尴尬的问题出现了, ALU的宽度只有16位, 也就是说, ALU不能计算20位的地址. 为了解决这个问题, 分段机制被引入</li><li>为了支持分段, 8086处理器设置了四个段寄存器：CS, DS, SS, ES每个段寄存器都是16位的, 同时访问内存的指令中的地址也是16位的.<ul><li>在送入地址总线之前(20位), 要将端寄存器(16位)的值与内存地址(16位, 即段内偏移值)相加</li><li>端寄存器的值左移4位, 低位补0, 然后加上内存地址</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">|       20        |  20位地址总线</span><br><span class="line">+-----------------+</span><br><span class="line">+------------+</span><br><span class="line">|      16    |       16位段地址</span><br><span class="line">+------------+</span><br><span class="line">    +-------------+</span><br><span class="line">    |    12  | 4  |  16位内存地址（段内偏移量）</span><br><span class="line">    +--------+----+</span><br><span class="line"></span><br><span class="line">实际物理地址 = （段寄存器地址 &lt;&lt; 4） + （CPU 提交的访存地址）</span><br></pre></td></tr></table></figure><h3 id="保护模式的诞生（32位处理器及寻址）"><a href="#保护模式的诞生（32位处理器及寻址）" class="headerlink" title="保护模式的诞生（32位处理器及寻址）"></a>保护模式的诞生（32位处理器及寻址）</h3><ul><li>80286处理器的地址总线为24位, 寻址空间达16M, 同时引入了保护模式（内存段的访问受到限制）</li><li>80386处理器是一个32位处理器, ALU和地址总线都是32位的, 寻址空间达 4G. 也就是说它可以不通过分段机制, 直接访问4G的内存空间. 但它必须支持实模式和保护模式. 所以, 80386在段寄存器的基础上构筑保护模式, 并且保留16位的段寄存器.</li><li>从80386之后的处理器, 架构基本相似, 统称为IA32（32 Bit Intel Architecture）.</li></ul><h3 id="IA32的内存寻址机制"><a href="#IA32的内存寻址机制" class="headerlink" title="IA32的内存寻址机制"></a>IA32的内存寻址机制</h3><h4 id="IA32的三种地址"><a href="#IA32的三种地址" class="headerlink" title="IA32的三种地址"></a>IA32的三种地址</h4><ul><li>逻辑地址: 每个逻辑地址都由一个”段的选择符”和”偏移量组成”. IA32中有六个16位段寄存器</li><li>线性地址：线性地址是一个32位的无符号整数, 可以表达高达2^32（4GB）的地址. 通常用16进制表示线性地址, 其取值范围为0x00000000～0xffffffff.</li><li>物理地址：也就是内存单元的实际地址, 用于芯片级内存单元寻址.  物理地址也由32位无符号整数表示.</li></ul><h4 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h4><p>MMU是一种硬件电路, 它包含两个部件, 一个是分段部件, 一个是分页部件, 在此, 我们把它们分别叫做分段机制和分页机制, 内存寻址分两个步骤:<br>分段机制把一个逻辑地址转换为线性地, 接着, 分页机制把一个线性地址转换为物理地址.</p><h4 id="IA32的段寄存器"><a href="#IA32的段寄存器" class="headerlink" title="IA32的段寄存器"></a>IA32的段寄存器</h4><p>IA32中有六个段寄存器(16 bit)：CS, DS, SS, ES, FS, GS.<br>跟8086的段寄存器不同的是, 这些寄存器存放的不再是某个段的基地址, 而是某个段的选择符（Selector）.</p><h3 id="IA32-硬件-分段机制的实现"><a href="#IA32-硬件-分段机制的实现" class="headerlink" title="IA32(硬件)分段机制的实现"></a>IA32(硬件)分段机制的实现</h3><h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><p>段是虚拟地址空间的基本单位, <strong>段描述符</strong> 是一个8字节的数据结构, 包括以下几个属性:</p><ul><li>段的界限(Limit)：在虚拟地址空间中, 段内可以使用的最大偏移量.</li><li>段的基地址(Base Address)：在线性地址空间中段的起始地址.</li><li>段的保护属性(Attribute)：表示段的特性. 例如, 该段是否可被读出或写入, 或者该段是否作为一个程序来执行, 以及段的特权级等等.</li></ul><p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/segment_descriptor.png" alt="IA32的一个通用的段描述符的结构"></p><h4 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h4><p>描述符表(即段表)定义了IA32系统的所有段的情况. 所有的描述符表本身都占据一个字节为8的倍数的存储器空间, 空间大小在8个字节(至少含一个描述符)到64K字节(至多含8K)个描述符之间.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>IA32的内存寻址机制完成从逻辑地址–线性地址–物理地址的转换. 其中, 逻辑地址的段寄存器中的值提供段描述符, 然后从段描述符中得到段基址和段界限, 然后加上逻辑地址的偏移量, 就得到了线性地址, 线性地址通过分页机制得到物理地址.<br>首先, 我们要明确, 分段机制是IA32提供的寻址方式, 这是硬件层面的. 就是说, 不管你是windows还是linux, 只要使用IA32的CPU访问内存, 都要经过MMU的转换流程才能得到物理地址, 也就是说必须经过逻辑地址–线性地址–物理地址的转换.</p><h3 id="Linux系统-软件-分段机制的实现"><a href="#Linux系统-软件-分段机制的实现" class="headerlink" title="Linux系统(软件)分段机制的实现"></a>Linux系统(软件)分段机制的实现</h3><p>Linux基本不使用分段的机制, 或者说, Linux中的分段机制只是为了兼容IA32的硬件而设计的.</p><p>在 IA32 上任意给出的地址都是一个虚拟地址, 即任意一个地址都是通过<code>选择符:偏移量</code>的方式给出的, 这是段机制存访问模式的基本特点.<br>所以在IA32上设计操作系统时无法回避使用段机制. 一个虚拟地址最终会通过<code>段基地址＋偏移量</code>的方式转化为一个线性地址.<br>但是, 由于绝大多数硬件平台都不支持段机制, 只支持分页机制, 所以为了让 Linux 具有更好的可移植性, 我们需要去掉段机制而只使用分页机制. 但不幸的是, IA32规定段机制是不可禁止的, 因此不可能绕过它直接给出线性地址空间的地址.<br>万般无奈之下, Linux的设计人员干脆让段的基地址为0, 而段的界限为4GB, 这时任意给出一个偏移量, 则等式为<code>0+偏移量=线性地址</code>, 也就是说“偏移量＝线性地址”. 另外由于段机制规定“偏移量&lt;4GB”, 所以偏移量的范围为0H～FFFFFFFFH, 这恰好是线性地址空间范围, 也就是说虚拟地址直接映射到了线性地址, 我们以后所提到的虚拟地址和线性地址指的也就是同一地址. 看来, Linux在没有回避段机制的情况下巧妙地把段机制给绕过去了.</p><h4 id="特权等级-CPU-Rings-和分段机制"><a href="#特权等级-CPU-Rings-和分段机制" class="headerlink" title="特权等级(CPU Rings)和分段机制"></a>特权等级(CPU Rings)和分段机制</h4><p>由于IA32段机制还规定, 必须为代码段和数据段创建不同的段, 所以Linux必须为代码段和数据段分别创建一个基地址为0, 段界限为4GB的段描述符.<br>不仅如此, 由于Linux内核运行在特权级0, 而用户程序运行在特权级别3, 根据IA32段保护机制规定, 特权级3的程序是无法访问特权级为0的段的,<br>所以Linux必须为内核用户程序分别创建其代码段和数据段. 这就意味着Linux <strong>必须创建4个段描述符: 特权级0的代码段和数据段, 特权级3的代码段和数据段</strong></p><blockquote><p>存疑: 在Ring0和Ring3的, 相同的的逻辑地址, 是对应不同的线性地址 [?]</p></blockquote><p>@ref 参考: <a href="http://blog.xiaohansong.com/2015/10/03/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Linux内存寻址之分段机制 | ShareHub</a></p><h2 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h2><h3 id="硬件分页"><a href="#硬件分页" class="headerlink" title="硬件分页"></a>硬件分页</h3><ul><li>分页机制在段机制之后进行, 以完成线性—物理地址的转换过程. 段机制把逻辑地址转换为线性地址, 分页机制进一步把该线性地址再转换为物理地址.</li><li>分页机制管理的对象是固定大小的存储块, 称之为页(page). 分页机制把整个线性地址空间及整个物理地址空间都看成由页组成, 在线性地址空间中的任何一页, 可以映射为物理地址空间中的任何一页, 我们把物理空间中的一页叫做页框(page frame)</li><li>80386使用4K(0xFFF)字节大小的页. 每一页都有4K字节长, 并在4K字节的边界上对齐(即每一页的起始地址都能被4K整除). 因此, 80386把最大可寻址4G字节的线性地址空间划分为1M个Page</li></ul><blockquote><p>线性地址的page, 与物理地址的page是多对一的关系, 也就是两个不同线性地址页, 可能指向同一个物理地址页</p></blockquote><h3 id="两级分页"><a href="#两级分页" class="headerlink" title="两级分页"></a>两级分页</h3><ul><li>页目录(Page Directory): 两级表结构的第一级称为<code>页目录</code>, 页目录占用4K字节, 正好一个页面. 页目录表共有1K个表项, 每个表项为4个字节, 这4字节是指向二级页表的地址.<ul><li>线性地址的最高10位用来作为第一级的索引(所以共2^10=1K个索引)</li></ul></li><li>页表(Page Table): 两级表结构的第二级称为<code>页表</code>, 也刚好存储在一个4K字节的页面中, 包含1K个字节的表项, 每个表项包含一个页的物理基地址.<ul><li>线性地址的中间10位用来作为第二级的索引进行索引,</li><li>以获得包含页的物理地址的页表项, 这个物理地址的高20位与线性地址的低12位形成了最后的物理地址, 也就是页转化过程输出的物理地址.</li></ul></li></ul><p>[未整理完]</p><p>@ref 参考: <a href="http://blog.xiaohansong.com/2015/10/05/Linux%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/index.html" target="_blank" rel="noopener">Linux内存寻址之分页机制 | ShareHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.06.Sed-Awk-Grep</title>
      <link href="/21.Operating-System/Linux.06.Sed-Awk-Grep/"/>
      <url>/21.Operating-System/Linux.06.Sed-Awk-Grep/</url>
      
        <content type="html"><![CDATA[<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><ul><li>-i : 表示将改变直接写入原文件, sed默认只修改输出到终端上的内容</li><li>-f : -f file1 表示将sed 的操作都输出到file1</li><li>-n : slient模式, 默认情况下sed所有来自STDIN的数据都会输出到终端,-n只会将”来自sed的操作”输出到终端, 一般和p一起用;</li><li>-e : 表示使用正则匹配</li></ul><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><ul><li>替换全部: <code>sed &quot;s/aaa/bbb/g&quot; -i file</code></li><li>每行开头插入#号: <code>sed &quot;s/^/#/g&quot; -i file</code></li><li>只在3-6行替换: <code>sed &quot;3,6s/aaa/bbb/g&quot; -i file</code></li><li>只替换每行的第1处aaa: <code>sed &quot;s/aaa/bbb/1&quot; -i file</code></li><li>只替换每行的第2处aaa: <code>sed &quot;s/aaa/bbb/2&quot; -i file</code></li><li>替换每行第3-最后一处aaa: <code>sed &quot;s/aaa/bbb/3,g&quot; -i file</code></li><li>正则替换: <code>sed -e &#39;s/^#\s*\(.*[0-9].*\)$/\1/g&#39; filename</code></li><li>与find联用: <code>find ./ -type f -exec sed -i -e &#39;s/aaa/bbb/g&#39; {} \;</code></li></ul><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><h2 id="参数解析-1"><a href="#参数解析-1" class="headerlink" title="参数解析"></a>参数解析</h2><ul><li>命令格式:<ul><li><code>awk [options] &#39;script&#39; file_name</code> :</li><li><code>awk [options] -f scriptfile file_name</code></li><li><code>cat file_name | awk [options] script</code></li></ul></li><li><p>[options]选项有:</p><ul><li><p><code>-F</code> : 指定分隔符. 分隔符默认是空格</p><ul><li><code>awk -F:</code> 表示冒号作为分隔;</li><li><code>awk -F&quot;[@ /t]&quot;</code> 告诉awk “@符号, 空格和Tab” 都是字段分隔符.</li></ul></li><li><p><code>-v</code> : 赋值一个用户定义变量, 传递给scripts, 例 <code>-v var=value</code></p></li><li><code>-f</code> : 从指定文件中读取 awk scripts, 例 <code>-f scripfile</code></li></ul></li></ul><h2 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>基本用法： <code>awk &#39;script&#39; filename</code>，该脚本 ‘script’ 中内容的格式是 <code>/pattern/ action</code>，其中 pattern 是一个正则表达式，而 action 是当 awk 在该行中找到此模式时应当执行的动作。<ul><li>例1： <code>awk &#39;/local*/{print $0}&#39; /etc/hosts</code></li><li>例2：</li></ul></li></ul><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><ul><li><code>NF</code>:  表示目前的记录被分割的字段的数目，NF可以理解为 Number of Field。<code>awk &#39;{print FNR}&#39; data.txt</code> 会打印出字段个数 (默认是任何数量的空格);</li><li><code>$NF</code>: 表示的最后一个Field（列）即输出最后一个字段的内容;</li><li><code>NR</code> : 已经读出的记录数，即行号，从1开始;</li><li><code>$n</code> : 表示目前的记录被分割后, 第n个字段的内容;</li></ul><h3 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h3><ul><li><p>提取每行符合正则的字符串<code>awk &#39;match($0, /meeting_code[0-9]+/,a){print a[0]}&#39; test.log</code> // 提取格式如 ‘meeting_code0000’ 的字符串，如果在mac上报错，试试gawk</p><blockquote><p>注: match函数原型 <code>match(string,regexp,array)</code></p></blockquote></li><li><p>每个进程打开的文件数: <code>lsof | awk &#39;{process[$1]++;} END{for(key in process) printf(&quot;%s:%d\n&quot;, key, process[key])}&#39;</code></p></li><li>打开TCP连接数量: <code>lsof | awk &#39;{if($8 == &quot;TCP&quot;) opened_tcp++} END{print opened_tcp }&#39;</code></li><li>打开文件按TYPE统计: <code>lsof | awk &#39;{opened_type[$5]++} END{ for(key in opened_type) printf(&quot;%s : %d\n&quot;, key, opened_type[key])}&#39;</code></li></ul><h3 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h3><ul><li>awk多维数组在本质上是一维数组, 因awk在存储上并不支持多维数组, awk提供了逻辑上模拟二维数组的访问方式. 例如, array[2,3] = 1这样的访问是允许的.<br>awk使用一个特殊的字符串SUBSEP (\034)作为分割字段, 在上面的例子 array[2,3] = 1 中, 关联数组array存储的键值实际上是2\0343, 2和3分别为下标（2, 3）, \034为SUBSEP分隔符</li><li>类似一维数组的循环访问, 多维数组使用 <code>for ( item in array )</code> 语法遍历数组. 与一维数组不同的是, 多维数组必须使用<code>split()</code>函数来访问单独的下标分量, 格式： <code>split ( item, subscr, SUBSEP)</code>.<br>例如： <code>split (item, array2, SUBSEP);</code> 后, array2[1]为下标“2”,  array2[2]为下标“3”</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -Fb表示分隔符</span></span><br><span class="line">awk -F <span class="string">'&amp;'</span> <span class="string">'BEGIN&#123;</span></span><br><span class="line"><span class="string">        # 初始化代码块</span></span><br><span class="line"><span class="string">    &#125;&#123;</span></span><br><span class="line"><span class="string">        # awk二维数组, 和awk外的数组变量不是一个</span></span><br><span class="line"><span class="string">        # 数组直接使用, 不需初始化</span></span><br><span class="line"><span class="string">         comment[$5, $3]++</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    END&#123;</span></span><br><span class="line"><span class="string">       printf("%d", length(comment)) # awk内置数组长度</span></span><br><span class="line"><span class="string">       # 循环awk数组</span></span><br><span class="line"><span class="string">       for(ii in comment)&#123;</span></span><br><span class="line"><span class="string">          # 这里的ii是key, value是comment[ii]</span></span><br><span class="line"><span class="string">           split(ii, strs, SUBSEP) # 对多维数组的key做split操作, 得到的数组strs[1]~strs[n]是数组下标</span></span><br><span class="line"><span class="string">           appid = strs[1] # strs从下标1开始</span></span><br><span class="line"><span class="string">           user =  strs[2]</span></span><br><span class="line"><span class="string">           printf("%d,%d\n", strs[1], strs[2], comment[ii]) &gt;&gt; "'</span><span class="variable">$sqlLoadFile</span><span class="string">'" # 类似C的printf</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;'</span> <span class="variable">$tmpDir</span>/<span class="built_in">stat</span>-log*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><h2 id="参数解析-2"><a href="#参数解析-2" class="headerlink" title="参数解析"></a>参数解析</h2><ul><li>用法: grep [参数] [查找字符串] [文件名]</li><li>常用参数:<ul><li>-n：显示匹配行及行号.</li><li>-c：只输出匹配行的计数.</li><li>-I：不区分大小写(只适用于单字符).</li><li>-i：不区分大小写.</li><li>-r：子目录递归查找.</li><li>-A n：a指after匹配指定行的后n行数据.</li><li>-B n：b 指before 匹配指定行的前N行数据.</li><li>-C n：显示匹配行的前后N行, 助记”center”.</li><li>-w xxx: 全词匹配, 比如 grep -w RUNNING, 参数w保证”RUN”不会被搜出来.</li></ul></li></ul><h2 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h2><ul><li>在指定文件查找字符串: <code>grep &quot;XYZ&quot; /etc/passwd</code></li><li>在指定文件查找多个:  <code>grep -e &quot;XYZ&quot; -e &quot;root&quot; /etc/passwd</code></li><li>在指定目录递归查找: <code>grep -r XYZ /etc/</code></li><li>在指定类型的文件查找字符串:<ul><li><code>find . -name &#39;*.c&#39; -exec grep -irn &quot;keyword&quot; {} \;</code></li><li><code>find -name *.c | xargs grep -irwn &quot;keyword&quot;</code></li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.evernote.com/shard/s120/sh/352388f6-979b-4bfb-902e-e9b02759fe6a/c5fc9c39e0fc308439d8145dbe3b9c39" target="_blank" rel="noopener">Sed简明教程</a></li><li><a href="https://www.evernote.com/shard/s120/sh/28f2e3ea-b7e1-43f0-ab34-a61c55298bfe/b3230c8d52a002f70dca475a8c94f375" target="_blank" rel="noopener">Awk简明教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令行 </tag>
            
            <tag> sed </tag>
            
            <tag> awk </tag>
            
            <tag> grep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.05.系统配置</title>
      <link href="/21.Operating-System/Linux.05.%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/21.Operating-System/Linux.05.%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="profile相关"><a href="#profile相关" class="headerlink" title="profile相关"></a>profile相关</h2><blockquote><ol><li>bashrc是在系统启动后就会自动运行。</li><li>profile是在用户登录后才会运行。</li><li>进行设置后，可运用source bashrc命令更新bashrc，也可运用source profile命令更新profile。</li></ol></blockquote><ul><li>/etc/profile: 中设定的变量(全局)的可以作用于任何用户</li><li>~/.bashrc: 等中设定的变量(局部)只能继承/etc/profile中的变量</li><li>~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</li></ul><h2 id="init系统"><a href="#init系统" class="headerlink" title="init系统"></a>init系统</h2><p>init进程是 Linux系统内核初始化最后一步启动的进程，也是系统的第一个进程，pid=1。</p><p>运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统下不同的运行模式。运行级别通常分为7等，分别是从0到6，但如果必要的话也可以更多。<br>例如在大多数Linux操作系统下一共有如下7个典型的运行级别：</p><blockquote></blockquote><p>0 停机，关机<br>1 单用户，无网络连接，不运行守护进程，不允许非超级用户登录<br>2 多用户，无网络连接，不运行守护进程<br>3 多用户，正常启动系统<br>4 用户自定义<br>5 多用户，带图形界面<br>6 重启</p><p>除了模式 0,1,6外, 每种 Unix 和 Unix-like 系统对运行模式的定义不太一样。通常在 /etc/inittab 文件中定义了各种运行模式的工作范围。<br>当前绝大多数Linux发行版已经基于新的systemd，systemd一般不再使用/etc/inittab文件。</p><h3 id="init-sysvinit-和-systemd"><a href="#init-sysvinit-和-systemd" class="headerlink" title="init,sysvinit 和 systemd"></a>init,sysvinit 和 systemd</h3><p>大多数 Linux 发行版的 init 系统是和 System V 相兼容的，被称为 sysvinit。这是人们最熟悉的 init 系统。<br>Ubuntu 采用 upstart 替代了传统的 sysvinit，<br>RHEL 采用 systemd替代 sysvinit。</p><h3 id="sysvinit"><a href="#sysvinit" class="headerlink" title="sysvinit"></a>sysvinit</h3><blockquote><p>本节参考:</p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/" target="_blank" rel="noopener">浅析Linux初始化init系统, 第1部分: sysvinit</a> @ref</li></ul></blockquote><h4 id="sysvinit-运行顺序"><a href="#sysvinit-运行顺序" class="headerlink" title="sysvinit 运行顺序"></a>sysvinit 运行顺序</h4><ol><li>读取 /etc/inittab, 获取配置(系统的 runlevel 等)</li><li>/etc/rc.d/rc.sysinit</li><li>/etc/rc.d/rc 和 /etc/rc.d/rcX.d/ (X 代表运行级别 0-6)</li><li>/etc/rc.d/rc.local</li></ol><h4 id="sysvinit-管理功能"><a href="#sysvinit-管理功能" class="headerlink" title="sysvinit 管理功能"></a>sysvinit 管理功能</h4><p>sysvinit 软件包包含了一系列的控制启动、运行和关闭所有其他程序的工具：</p><ul><li>init: 这个就是 sysvinit 本身的 init 进程实体，以 pid1 身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用/etc/inittab 文件创建进程。</li><li>halt: 停止系统</li><li>poweroff: 等于 shutdown -h –p</li><li>reboot: 等于 shutdown –r</li><li>killall: 向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的 shell。</li><li>last: 回溯/var/log/wtmp 文件(或者-f 选项指定的文件)，显示自从这个文件建立以来，所有用户的登录情况。</li><li>chkconfig:  RHEL 在 sysvinit 的基础上开发的命令行工具</li><li>service: 同上</li></ul><p>使用 sysvinit 启动一个服务:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/apache2 start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service apache2 start</span></span><br></pre></td></tr></table></figure><p>这种方法有两个缺点。</p><ul><li>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ul><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是为系统的启动和管理提供一套完整的解决方案。</p><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><ul><li>systemctl是 Systemd 的主命令，用于管理系统。</li><li>systemd-analyze命令用于查看启动耗时。</li><li>…</li></ul><p>@ref:</p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程：命令篇 - 阮一峰的网络日志</a> </li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/" target="_blank" rel="noopener">浅析Linux初始化init系统, 第3部分: Systemd</a> </li></ul><h4 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a>systemctl 命令</h4><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。//区别 <code>sysctl</code> 命令，用于修改 Kernel参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl reboot</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭系统，切断电源</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl poweroff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CPU停止工作</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl halt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂停系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">suspend</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 让系统进入冬眠状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl hibernate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 让系统进入交互式休眠状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl hybrid-sleep</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动进入救援状态（单用户状态）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl rescue</span></span><br></pre></td></tr></table></figure><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。相关命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出正在运行的 Unit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-units</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl list-units --all</span></span><br></pre></td></tr></table></figure><p>启动、重启、停止Unit：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 立即启动一个服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start example.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 立即停止一个服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop example.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启一个服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart example.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死一个服务的所有子进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">kill</span> example.service</span></span><br></pre></td></tr></table></figure><p>Example: How to 新加一个 Service（Systemd Unit）:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/ngx-example.service</span><br></pre></td></tr></table></figure><blockquote><p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。<br><code>systemctl enable</code> 命令用于在上面两个目录之间，建立符号链接关系。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description=proxy-nginx</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/data0/www/logs/nginx.pid</span><br><span class="line"></span><br><span class="line"># 启动进程时执行的命令</span><br><span class="line">ExecStart=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf</span><br><span class="line"></span><br><span class="line"># 重启服务时执行的命令</span><br><span class="line">ExecReload=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf -s reload</span><br><span class="line"></span><br><span class="line"># 停止服务时执行的命令</span><br><span class="line">ExecStop=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf -s stop</span><br><span class="line">PrivateTmp=True</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="journald-日志系统"><a href="#journald-日志系统" class="headerlink" title="journald 日志系统"></a>journald 日志系统</h3><blockquote><p>本节参考:</p><ul><li><a href="https://ieevee.com/tech/2017/08/24/journald.html" target="_blank" rel="noopener">centos7的日志系统：journald, rsyslog, logrotate</a></li><li><a href="https://www.cnblogs.com/itxdm/p/Systemd_log_system_journalctl.html" target="_blank" rel="noopener">systemd 之 journalctl</a></li></ul></blockquote><p>Systemd 使用 journald 做日志服务，使用 rsyslog 来持久化日志，使用 logrotate 来轮转日志文件。<br>Systemd日志收集流程: <code>systemd --&gt; systemd-journald --&gt; ram DB(/run/log/journal) --&gt; rsyslog -&gt; /var/log/messages</code>;<br>对比 init日志收集: <code>service daemon ---&gt; rsyslog ---&gt; /var/log</code></p><h4 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h4><p>journald用二进制格式保存所有日志信息，用户使用 <code>journalctl</code> 命令来查看日志信息。<br>配置文件位置: <code>cat /etc/systemd/journald.conf</code></p><p>使用<code>journalctl</code>命令查看日志:</p><ul><li>journalctl: 显示所有的日志信息，notice或warning以粗体显示，红色显示error级别以上的信息</li><li>journalctl –dmesg: 查看 dmesg 信息。</li><li>journalctl -k: 查看 kernel 日志。</li><li>journalctl -f: 很像tailf命令</li><li>journalctl –since=yesterday: 指定时间段</li><li>journalctl -u docker.service:  指定服务，查看docker服务的 journal 日志。查看所有service列表使用命令 <code>systemctl list-units</code></li><li>journalctl _PID=8088: 查看指定pid的</li><li>journalctl _UID=33: 查看指定用户的</li><li>journalctl /usr/bin/bash: 查看某个路径的脚本的日志</li><li>journalctl –verify: 检查日志文件的一致性</li></ul><p>例如，docker daemon会配置为将所有容器的日志为存储到 journald。<br><code>/usr/bin/docker-current daemon --exec-opt native.cgroupdriver=systemd --selinux-enabled --log-driver=journald</code><br>所以，运行中 docker的日志，例如 k8s的 apiserver都会打到 journald日志里去（最终输出到 /var/log/messages）</p><h4 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h4><p>rsyslog用来固化journald日志。rsyslog读取 ram DB(/run/log/journal)的数据，并根据优先级排列日志信息，将它们写入到 /var/log目录中永久保存。</p><blockquote><p>默认 journald配置<code>#ForwardToSyslog=no</code>，所以并未将日志转发给syslog。syslog自己去读取的 journald的日志文件(类似journalctl)。</p></blockquote><h4 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h4><p>rsyslog的日志存储于/var/log下，显然日志文件不能无限变大，否则磁盘空间会被耗尽。RHEL7使用logrotate来做日志文件轮转。<br>配置文件位置: <code>cat /etc/cron.daily/logrotate</code></p><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>几个常见的用户组: <a href="https://www.debian.org/doc/manuals/securing-debian-howto/ch12.en.html" target="_blank" rel="noopener">adm/daemon/bin</a> :</p><ul><li>root:超级用户, 就是管理员, 拥有所有权限</li><li>bin:历史遗留用户</li><li>daemon:守护进程, 非特权的, 需要对一些以磁盘文件有写权限的daemon以daemon.daemon(portmap,atd,etc)运行；不需要占有任何文件的daemon 以nobody.nogroup运行；比较复杂的, 涉及安全问题的daemon以特定的用户运行. daemon用户也方便本地安装的daemon运行.</li><li>adm:adm组执行系统监控任务, 组成员可以读取/var/log下的多数文件, 可以使用xconsole. 历史上/var/log来自于/usr/adm, 后来叫/var/adm, 这也是组名称的由来.</li><li>apache/_www: 用root启动httpd服务, apache的子进程还是用apache(或者_www用户)运行的, 可以通过修改<code>/etc/httpd/conf/httpd.conf</code>指定apache运行的用户组.</li></ul><h3 id="更改用户-amp-用户组常用命令"><a href="#更改用户-amp-用户组常用命令" class="headerlink" title="更改用户&amp;用户组常用命令:"></a>更改用户&amp;用户组常用命令:</h3><ul><li><code>usermod -a -G daemon XYZ</code> 将用户XYZ加入一个组</li><li><code>id</code> , <code>whoami</code> :</li><li><code>who</code> :</li><li><code>useradd</code>, <code>userdel</code></li></ul><h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><ul><li>/etc/sudoers</li><li>/etc/hosts.allow: 限制SSH的客户端IP, /etc/hosts.allow 的设定优先于 /etc/hosts.deny</li><li>/etc/hosts.deny: 限制SSH的客户端IP</li></ul><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><ul><li><code>chmod 400 ~/.ssh/authorized_keys</code></li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul><li><p>/etc/resolv.conf: 这个文件是用于配置DNS服务器的, 扩展阅读: <a href="http://mydf.github.io/blog/ubuntu-dnsmasq/" target="_blank" rel="noopener">Ubuntu使用dnsmasq作本地DNS缓存</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure></li><li><p>/etc/hosts: 设置主机名和IP地址绑定</p></li><li>/etc/hostname: 主机名配置</li><li>/etc/sysconfig/network: 主机名和网关<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NETWORK=yes    #网络是否被配置</span><br><span class="line">RORWARD_IPV4=yes    #是否开启IP转发功能</span><br><span class="line">HOSTNAME= localhost.localdomain   #表示服务器的主机名</span><br><span class="line">GAREWAY=192.168.0.1    #表示网络网关的IP地址</span><br><span class="line">GATEWAYDEV=eth0    #网关的设备名，即选择使用哪个网卡</span><br></pre></td></tr></table></figure></li></ul><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p><code>* * * * * * cmd</code>, 分别表示每<code>分/时/每月第几日/月/周几(0~6)</code></p><ul><li>每5分钟: <code>*/5 * * * *</code></li><li>每小时: <code>0 * * * *</code></li><li>每天早上6点10分 <code>10 6 * * *</code></li><li>晚上11点到早上8点之间每两个小时, 和早上8点: <code>0 23-7/2, 8 * * *</code></li></ul><blockquote><p>每个用户的crontab文件在 /var/spool/cron/</p></blockquote><h1 id="终端Terminal"><a href="#终端Terminal" class="headerlink" title="终端Terminal"></a>终端Terminal</h1><ul><li>Ctrl+r搜索, 输入, 按Ctrl+r继续搜索</li><li>Ctrl+a / Ctrl+e : 移动光标开头/末尾m</li></ul><h2 id="tty-pst-pty"><a href="#tty-pst-pty" class="headerlink" title="tty/pst/pty"></a>tty/pst/pty</h2><ul><li>参考 <a href="https://unix.stackexchange.com/questions/21280/difference-between-pts-and-tty" target="_blank" rel="noopener">linux - Difference between pts and tty - Unix &amp; Linux Stack Exchange</a></li></ul><h1 id="性能-amp-并发相关"><a href="#性能-amp-并发相关" class="headerlink" title="性能 &amp; 并发相关"></a>性能 &amp; 并发相关</h1><p>@ref: [[../31.Backend/SystemDesign-C100K]]</p>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux.04.Sysctl</title>
      <link href="/21.Operating-System/Linux.04.Sysctl/"/>
      <url>/21.Operating-System/Linux.04.Sysctl/</url>
      
        <content type="html"><![CDATA[<p>使用Sysctl命令调整内核参数</p><h2 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h2><ul><li><p>列出所有的参数并查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -a | less</span><br></pre></td></tr></table></figure></li><li><p>获取某个参数值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl kernel.msgmnb</span><br></pre></td></tr></table></figure></li><li><p>修改参数值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w 变量名=变量值</span><br></pre></td></tr></table></figure></li><li><p>sysctl 变量的设置通常是字符串、数字或者布尔型。 (布尔型用 1 来表示’yes’，用 0 来表示’no’)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -w kernel.sysrq=0</span><br><span class="line">sysctl -w kernel.core_uses_pid=1</span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=1</span><br></pre></td></tr></table></figure></li><li><p><code>sysctl -w</code>设置的参数会在重启后丢失, 永久生效方法：在/etc/sysctl.conf中添加 然后 <code>sysctl -p</code>立刻生效:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.icmp_echo_ignore_all=1</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul><li>net.ipv4.ip_local_port_range = 1024 65000 //允许系统打开的端口范围, 操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的</li><li>net.core.netdev_max_backlog = 262144 // 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</li><li>net.ipv4.tcp_max_tw_buckets = 6000 //timewait 的数量，默认是180000。</li><li>net.ipv4.tcp_tw_recycle = 1 // 启用timewait 快速回收</li><li>net.ipv4.tcp_tw_reuse = 1   // 开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接。</li><li>net.ipv4.tcp_syncookies = 1 // 开启SYN Cookies，当出现SYN 等待队列溢出时，启用cookies 来处理。</li><li>net.ipv4.tcp_max_orphans = 262144 //系统所能处理不属于任何进程的 socket数量，当我们需要快速建立大量连接时，就需要关注下这个值了. 这个限制仅仅是为了防止简单的DoS 攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。</li><li>net.ipv4.tcp_max_syn_backlog = 262144 // 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M 内存的系统而言，缺省值是1024，小内存的系统则是128。</li><li>net.ipv4.tcp_timestamps = 0     //时间戳可以避免序列号的卷绕。一个1Gbps 的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。</li><li>net.ipv4.tcp_synack_retries = 1 //为了打开对端的连接，内核需要发送一个SYN 并附带一个回应前面一个SYN 的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK 包的数量。</li><li>net.ipv4.tcp_syn_retries = 1 // 在内核放弃建立连接之前发送SYN 包的数量。</li><li>net.ipv4.tcp_fin_timeout = 1 //如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2 状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60 秒。2.2 内核的通常值是180 秒，3你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB 服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2 的危险性比FIN-WAIT-1 要小，因为它最多只能吃掉1.5K 内存，但是它们的生存期长些。</li><li>net.ipv4.tcp_keepalive_time = 30 //当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2 小时。</li><li>net.ipv4.tcp_mem = 786432 2097152 3145728 // tcp的内存大小，其单位是页, 当超过第二个值时，TCP进入 pressure模式，此时TCP尝试稳定其内存的使用，当小于第一个值时，就退出pressure模式。当内存占用超过第三个值时，TCP就拒绝分配 socket了</li><li>net.ipv4.tcp_rmem = 4096 4096 16777216 # 读缓冲的大小, 三个分别是最小/默认/最大值</li><li>net.ipv4.tcp_wmem = 4096 4096 16777216</li></ul>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.03.命令行-Performance</title>
      <link href="/21.Operating-System/Linux.03.%E5%91%BD%E4%BB%A4%E8%A1%8C-Performance/"/>
      <url>/21.Operating-System/Linux.03.%E5%91%BD%E4%BB%A4%E8%A1%8C-Performance/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/operating_system/Linux-Series-Title.png" alt=""></p><h1 id="tldr"><a href="#tldr" class="headerlink" title="@tldr"></a>@tldr</h1><ul><li><strong>cpu</strong>:<ul><li>uptime 查看load值, 不高于core数, <code>sar -q</code>也可以查看load值</li><li>vmstat: 关注r(同load), 和b(等待资源的进程数), 以及cpu占用(用户进程和内核进程)时间百分比: us%不超过50%, us% + sy%不超过80%</li><li>sar也可以查看us% sy%占用CPU时间百分比</li></ul></li><li><strong>内存</strong>:<ul><li>free: 可用内存小于20%需要关注, <code>sar -r</code>类似</li><li>vmstat的si和so: 一般不应该大于0, <code>sar -W</code>也可以查看交换区</li></ul></li><li><strong>I/O</strong>:<ul><li>vmstat: 需关注wa(IO等待占用CPU百分比): 大于30%时需关注, bi/bo也需要关注(阈值?)</li><li>iowait: sar也可以查看iowait%</li></ul></li><li><strong>网络</strong>:<ul><li>netstat -antp : 查看所有tcp连接</li><li>iperf: 吞吐量(Throughput) , 大约为网卡最大速率的一半</li></ul></li></ul><h1 id="基础性能参数"><a href="#基础性能参数" class="headerlink" title="基础性能参数"></a>基础性能参数</h1><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p>一个类比说明load值: 如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程</p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><ul><li>uptime返回1/5/15分钟内的load值(进程队列的长度), 对于单核cpu, load值在1.0以下可以接受, 对于多核CPU, load值要除以”核心数”</li><li>多核CPU的话, 满负荷状态的数字为 “1.00 * CPU核数”, 这里的CPU核数是<code>processor</code>的数量,</li><li>某台服务器举例: 2个物理CPU, 每个物理CPU包括8个Core, 每个Core包括4个Processor(HT超线程),</li><li>以上参考<a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages" target="_blank" rel="noopener">Understanding Linux CPU Load - when should you be worried?</a> @ref</li><li>1/5/15分钟的load值, 应该参考哪一个? 如下:</li></ul><p><img src="/images/operating_system/linux-load-uptime.png" alt="Linux_Load_Uptime"></p><blockquote><p>load值走高也不一定就是cpu资源紧张导致的, 还需要结合<code>vmstat</code>, <code>iostat</code>工具进行确认和判断是cpu不足还是磁盘IO问题又或者是内存不足导致.</p></blockquote><h3 id="cat-proc-cpuinfo"><a href="#cat-proc-cpuinfo" class="headerlink" title="cat /proc/cpuinfo"></a>cat /proc/cpuinfo</h3><p>一个物理封装的CPU（通过<code>physical id</code>区分判断）, 可以有多个”核心”（通过<code>core id</code>区分判断）, 每个核可以有多个”逻辑cpu”（通过<code>processor</code>区分判断）</p><ul><li>物理Cpu数: <code>cat /proc/cpuinfo | grep &quot;physical id&quot; | sort -u |wc -l</code> 输出2</li><li>核心数: <code>cat /proc/cpuinfo | grep &quot;core id&quot; | sort -u |wc -l</code> 输出8</li><li>逻辑Cpu数: <code>cat /proc/cpuinfo | grep &quot;processor&quot; | sort -u | wc -l</code>  输出32</li></ul><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><ul><li><code>ps -ef</code> : e参数列出所有(用户)的进程, f列出PPID;</li><li><code>ps aux</code> : 能显示出更多的线程信息, 比如”VSZ”,”RSS”,”TTY”,”STAT”.</li><li><code>ps -l</code> : 列出进程优先级(PRI), Nice值(NI),内存占用(SZ)</li><li><code>ps -T -p &lt;pid&gt;</code> : 查看进程的所有线程</li></ul><h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND</span><br><span class="line">root                47   0.0  0.0  2502056   1700   ??  Ss   一09上午   0:11.65 /usr/libexec/kextd</span><br><span class="line">root                45   0.0  0.2  2503976   6576   ??  Ss   一09上午   0:29.45 /usr/libexec/UserEventAgent (System)</span><br><span class="line">root                44   0.0  0.0  2472460   1204   ??  Ss   一09上午   0:32.91 /usr/sbin/syslogd</span><br><span class="line">beefymiracle       424  98.7  0.1  2507128   4764   ??  R    一09上午 1762:56.80 /System/Library/PrivateFrameworks/ParsecUI.framework/Versions/A/Support/SpotlightNetHelper.app/Contents/MacOS/SpotlightNetHelper</span><br></pre></td></tr></table></figure><h4 id="VSZ"><a href="#VSZ" class="headerlink" title="VSZ"></a>VSZ</h4><p>KB, virtual memory size, Device mappings are currently excluded;</p><h4 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h4><p>KB, resident set size, 一般作为实际占用内存大小,<br>包括程序二进制映像(binary image), Heap/Stack实际使用(系统为进程分配的堆和栈, 不一定完全用掉), 共享区(shared Library, 也即Memory Mapping)实际使用的空间;</p><h4 id="区分VSZ-RSS-SZ"><a href="#区分VSZ-RSS-SZ" class="headerlink" title="区分VSZ,RSS,SZ"></a>区分VSZ,RSS,SZ</h4><p><a href="http://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management" target="_blank" rel="noopener">http://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management</a></p><h4 id="STAT"><a href="#STAT" class="headerlink" title="STAT"></a>STAT</h4><p>R/S/D/T/Z/X : <a href="http://askubuntu.com/questions/360252/what-do-the-stat-column-values-in-ps-mean" target="_blank" rel="noopener">http://askubuntu.com/questions/360252/what-do-the-stat-column-values-in-ps-mean</a></p><h3 id="ps-el"><a href="#ps-el" class="headerlink" title="ps -el"></a>ps -el</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD</span><br><span class="line">  0     1     0     4004   0  37  0  2478772   7372 -      Ss                  0 ??         3:01.68 /sbin/launchd</span><br><span class="line">  0    44     1     4004   0   4  0  2474032   1228 -      Ss                  0 ??         0:32.87 /usr/sbin/syslogd</span><br><span class="line">501   424     1     4004   0   4  0  2506604   4952 -      R                   0 ??       1757:31.24 /System/Library/PrivateFrameworks/ParsecUI.framework/Versions/A/Support/SpotlightNetHelper.app/Contents/MacOS/SpotlightNetHelper</span><br></pre></td></tr></table></figure><h4 id="SZ"><a href="#SZ" class="headerlink" title="SZ"></a>SZ</h4><p>size in physical pages of the core image of the process. This includes text, data, and stack space. Device mappings are currently excluded</p><h4 id="PRI-优先级"><a href="#PRI-优先级" class="headerlink" title="PRI 优先级"></a>PRI 优先级</h4><p>PRI表示线程优先级(数值越小越先执行), 优先级的范围是[0, MAX_PRIO-1], <code>MAX_PRIO</code> 的值一般为140.</p><h4 id="NI-修正优先级"><a href="#NI-修正优先级" class="headerlink" title="NI 修正优先级"></a>NI 修正优先级</h4><ul><li>NI=Nice, 值表示对优先级PRI的修正, 范围从-20~19, Nice越小表示优先级越高.</li><li>以指定Nice启动任务: <code>nice -n -5 /usr/bin/mysqld &amp;</code>, 注意这里<code>-5</code>并不是表示负数, 而是正数5, 如果要以高优先级启动某进程(负的Nice值), 则应该为<code>nice -n --5 top</code>.</li><li>使用nohup: <code>nohup -n 10 COMMANDS</code></li><li>改变已存在进程的优先级: <code>renice -5 -p 1203</code>注意这里的”-5”表示负数.</li></ul><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><ul><li>pstree -apu 显示进程树</li><li>-a 显示进程的命令行</li><li>-p 显示PID</li><li>-u 显示UID, 如果子进程和父进程的UID不同, 比如Nginx启动worker线程用nobody</li></ul><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><ul><li>查看指定进程: <code>top -d 1 -p 1021</code>, 解释: -d 刷新间隔, -p 进程号, <a href="http://javawind.net/p131" target="_blank" rel="noopener">每列”VIRT”, “RES”, “SHR”的表示含义</a><ul><li>VIRT: 进程“需要的”虚拟内存大小, 包括库/代码/数据, <code>VIRT = SWP + RES</code></li><li>RES:  常驻内存(Resident memory), 包括共享内存, <code>进程实际占用内存 = RES - SHR</code></li><li>SHR:  共享内存(Shared memory), 比如动态库</li></ul></li><li>某个进程占用的CPU和内存也可以用<code>ps -aux</code>查看, 其中<code>RSS</code>(Resident Set Size)表示实际RAM使用, <code>VSZ</code>(Virtual Memory Size)包括程序占用的SWAP空间, 和使用的shared libraries所占用的空间.</li><li>或者, 直接查看<code>/proc/PID/status</code>文件也可以得知进程占用RAM的情况.</li><li>查看线程: <code>top -H</code>, 查看指定进程的线程: <code>top -H -p &lt;pid&gt;</code></li></ul><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><ul><li><a href="https://www.quora.com/What-is-the-difference-between-Buffers-and-Cached-columns-in-proc-meminfo-output" target="_blank" rel="noopener">What is the difference between Buffers and Cached columns in /proc/meminfo output?</a><ul><li>Buffer 是准备写入块设备的数据, 存储了文件的目录/权限等metadata;</li><li>Cache 频繁访问的文件都会被cache, 里面只有文件内容数据;</li></ul></li></ul><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@tc_157_46 ~]# vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 3 23   2840 3118492 110100 21213972    0    0    19   201    0    0  1  1 97  1  0</span><br></pre></td></tr></table></figure><p>vmstat每列解释:</p><ul><li>procs列<ul><li>r 等待cpu时间片的进程数, 如果长期大于1, 说明cpu不足, 需要增加cpu.</li><li>b (在等待资源的进程数, 比如正在等待I/O, 或者内存交换等).</li></ul></li><li>memory列<ul><li>swpd 虚拟内存大小(交换区). 如果swpd的值不为0, 比如超过了100m, 只要si, so的值长期为0, 系统性能还是正常</li><li>free 空闲内存大小</li><li>buff 做为buffer的内存大小, 一般对块设备的读写才需要缓冲.</li><li>cache: 做为page cache的内存大小, 一般做为文件系统的cache, 如果cache较大, 说明用到cache的文件较多, 如果此时IO中bi比较小, 说明文件系统效率比较好.</li></ul></li><li>swap列<ul><li>si 每秒由内存进入内存交换区数量.</li><li>so 每秒由内存交换区进入内存数量.</li></ul></li><li>io列<ul><li>bi 每秒从块设备读取数据的Blocks, 一个Block =1024byte</li><li>bo 每秒块设备写入数据的总量 // 这里我们设置的bi+bo参考值为1000, 如果超过1000(1MB), 而且wa值较大应该考虑均衡磁盘负载, 可以结合<code>iostat</code>输出来分析.</li></ul></li><li>system列<ul><li>in 每秒设备中断数.</li><li>cs 每秒产生的上下文切换次数, 如当cs比磁盘I/O和网络信息包速率高得多, 都应进行进一步调查.</li></ul></li><li>cpu列<ul><li>us 用户进程所占时间的百分比. 如果长期大于50%, 需要考虑优化用户的程序, 比如加密解密等运算.</li><li>sy 系统进程所占时间的百分比. 这里<code>us+sy</code>的参考值为80%, 如果<code>us+sy</code>大于80%说明可能存在CPU不足.</li><li>wa IO等待所占用的CPU时间百分比. 这里wa的参考值为30%, 如果wa超过30%, 说明IO等待严重, 这可能是磁盘大量随机访问造成的, 也可能磁盘或者磁盘访问控制器的带宽瓶颈造成的(主要是块操作).</li><li>id 空闲状态的CPU时间百分比</li></ul></li></ul><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>命令格式: <code>iostat [option] [间隔秒数] [统计次数]</code> , 比如<code>iostat -x 1 10</code>表示1秒打印一次, 共10次</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@tc_157_46 ~]# iostat -x 1 1</span><br><span class="line">Linux 2.6.18-274.el5 (tc_157_46)        07/26/2016</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.18    0.00    1.01    1.06    0.00   96.75</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class="line">sda               1.34   747.37  4.12 55.96   600.54  6426.98   116.95     0.03    0.49   0.38   2.25</span><br><span class="line">sda1              0.00     1.56  0.01  0.66     0.25    17.76    26.94     0.03   38.49  11.73   0.78</span><br><span class="line">sda2              0.00     0.01  0.00  0.00     0.02     0.04   106.87     0.00   88.03   7.93   0.00</span><br><span class="line">sda3              0.01     1.31  0.04  1.94     1.34    26.02    13.83     0.02   11.81   8.91   1.76</span><br><span class="line">sda4              0.00     0.00  0.00  0.00     0.00     0.00     7.40     0.00  110.47 110.47   0.00</span><br><span class="line">sda5              0.01     0.36  0.02  0.25     0.59     4.84    20.14     0.01   41.69  17.49   0.47</span><br><span class="line">sda6              1.32   744.13  4.05 53.12   598.33  6378.33   122.03     0.03    0.52   0.18   1.00</span><br></pre></td></tr></table></figure><ul><li>%util: IO操作占用CPU时间的百分比: 如果%util长期接近100%, 说明产生的I/O请求太多, I/O系统已经满负荷, 该磁盘可能存在瓶颈.</li><li>Idle如果长期大于70% IO压力就比较大了,这时一般读取速度有较多的wait.</li></ul><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>查看系统的不同时间段的状况, CPU, load, 页面交换</p><ul><li>CPU<ul><li>sar 或sar -u:  查看CPU占用状况</li><li>sar -q 查看任务队列, 同load</li></ul></li><li>内存<ul><li>sar -r 查看内存使用, 同free</li><li>sar -W 查看Swap区的数据交换状况, 怀疑Swap频繁导致系统变慢可以使用</li></ul></li><li>IO<ul><li>sar -b</li><li>sar -d 1 5: 一秒每次, 共5次, 显示实时的信息</li></ul></li><li>网卡<ul><li>sar -n DEV 1 5:  一秒每次, 共5次, 显示实时的信息</li></ul></li></ul><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>查看TCP的并发数/TCP连接的状态, 以一个Nginx服务器为例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@zw_85_63 ~]# netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br><span class="line">TIME_WAIT 37968</span><br><span class="line">SYN_SENT 1</span><br><span class="line">FIN_WAIT1 5</span><br><span class="line">FIN_WAIT2 4</span><br><span class="line">ESTABLISHED 2725</span><br><span class="line">SYN_RECV 18</span><br><span class="line">LAST_ACK 4</span><br></pre></td></tr></table></figure><p>→ <a href="/21.Operating-System/Linux.02.网络命令/" title="Linux.02.网络命令">Linux.02.网络命令</a></p><h1 id="sysctl优化内核参数"><a href="#sysctl优化内核参数" class="headerlink" title="sysctl优化内核参数"></a>sysctl优化内核参数</h1><p>获取当前内核参数的设定值:</p><ul><li>sysctl -a | grep vm</li><li>sysctl -a | grep net.ipv4</li></ul><p>使用sysctl调整内核参数, 例:  <code>sysctl -w net.ipv4.tcp_syncookies=0</code>,<br>更多参考→ <a href="/21.Operating-System/Linux.04.Sysctl/" title="Linux.04.Sysctl">Linux.04.Sysctl</a></p><p>@ref</p><ul><li>并发相关的内核参数调整参考 : <a href="https://whatsdjgpp.github.io/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Arch-%E6%9E%B6%E6%9E%84-%E5%B9%B6%E5%8F%91/" target="_blank" rel="noopener">后端架构-并发(C10K/C100K) | 扔掉笔记</a></li></ul><hr><h1 id="附：Linux-Performance-Tools（图）"><a href="#附：Linux-Performance-Tools（图）" class="headerlink" title="附：Linux Performance Tools（图）"></a>附：Linux Performance Tools（图）</h1><p><img src="/images/operating_system/linux-performance-benchmark-tools.png" alt="Linux-Performance-Benchmark-Tools"></p><p><img src="/images/operating_system/linux-performance-tuning-tools.png" alt="Linux-Performance-Tuning-Tools"></p><p><img src="/images/operating_system/linux-performance-observability-sar.png" alt="Linux-Performance-Observability-Sar"></p><blockquote><p>来源: <a href="https://colobu.com/2014/09/18/Linux-Performance-Analysis-and-Tools/" target="_blank" rel="noopener">https://colobu.com/2014/09/18/Linux-Performance-Analysis-and-Tools/</a></p></blockquote><h1 id="附：线上服务器的数据"><a href="#附：线上服务器的数据" class="headerlink" title="附：线上服务器的数据"></a>附：线上服务器的数据</h1><p>平均值~峰值:</p><ul><li><strong>Nginx &amp; Memcache</strong>:<ul><li>load少于0.1, iowait少于0.1%,</li><li>User:System时间大约10%:5%(峰值), 每秒上下文切换(用vmstat查看cs)20-50K,</li><li>打开TCP连接4000, 带宽200Mbps （千兆网卡）</li></ul></li><li><strong>Redis</strong>:<ul><li>load少于0.1, iowait少于0.1%,</li><li>User:System时间不到0.1%(峰值), 每秒上下文切换2-4K+,</li><li>打开TCP连接数600, 带宽2.0Mbps</li></ul></li><li><strong>Resin</strong>:<ul><li>load少于0.2, iowait少于0.2%,</li><li>User:System时间大约15%:2%(峰值), 每秒上下文切换30~60K,</li><li>打开TCP连接数1500, 带宽40~80Mbps,</li></ul></li><li><strong>Hadoop</strong>:<ul><li>load大约0.5~1.5, iowait时间2%-20%, 峰值iowait能到35% ( 一般大于30%需要排查 )</li><li>User:System时间大约15%:1%, 每秒上下文切换2-7K,</li><li>打开TCP连接数, 带宽20-70Mbps</li></ul></li><li><strong>Flume</strong>:<ul><li>load少于0.1, iowait少于0.1%,</li><li>User:System时间大约5%:1%, 每秒上下文切换30-60K,</li><li>打开TCP连接数, 带宽5-25Mbps</li></ul></li></ul><blockquote><p>注: 上面Hadoop机器的iowait有问题, 数据选自一台硬盘有问题的机器</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令行 </tag>
            
            <tag> 后端技术 </tag>
            
            <tag> 系统性能分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.02.网络命令</title>
      <link href="/21.Operating-System/Linux.02.%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/21.Operating-System/Linux.02.%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>ping是通过发送ICMP报文(回显请求), 并等待回显请求的应答, 目标主机的防火墙可能对ICMP报文做了限制, 所以ping不通不代表无法ssh.</p><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><ul><li><p>启动关闭指定网卡</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure></li><li><p>配置IP地址 <code>ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</code></p></li></ul><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>显示建立的网络连接, 分为三种: tcp/udp/unix(进程通讯)</p><ul><li><code>netstat -au</code> : 显示所有udp连接</li><li><code>netstat -at</code> : 显示所有tcp连接</li><li><code>netstat -nlt</code> :<ul><li>-n 显示ip而非域名</li><li>-l 显示所有listen状态的连接</li><li>-p 显示出连接对应的进程, 需要root权限才能看到</li></ul></li><li><code>netstat -r</code> : 显示路由表/网关, 同 route返回的</li></ul><h2 id="nslookup-dig"><a href="#nslookup-dig" class="headerlink" title="nslookup, dig"></a>nslookup, dig</h2><p>nslookup, dig 都是DNS查询命令:</p><ul><li><strong>nslookup</strong>: 用于对DNS正向解析 &amp; 返向解析;<ul><li><code>nslookup a.xxx.com</code> 使用默认dns查询网址的dns记录</li><li><code>nslookup a.xxx.com 8.8.8.8</code> 使用指定dns服务器查询dns记录</li></ul></li><li><strong>dig</strong>: 是一个用于询问DNS 域名服务器的灵活的工具。它执行DNS 查询，显示从已查询名称服务器返回的应答。<ul><li><code>dig</code>: 显示13个根域服务器</li><li><code>dig www.baidu.com</code>: 使用默认dns查询网址的dns记录</li><li><code>dig @8.8.8.8 www.yahoo.com</code>: 使用指定dns服务器查询dns记录</li></ul></li></ul><h2 id="route"><a href="#route" class="headerlink" title="route"></a>route</h2><ul><li>命令格式 <code>route add 目标网段 gw 网关地址 dev 设备</code></li><li>增加默认网关 <code>route add default gw 192.168.0.254</code></li><li>增加网关: <code>route add -net 192.168.1.0 netmask 255.255.255.128 gw 192.168.1.129 dev eth0</code></li><li>删除网关: <code>route del -net 192.168.1.0 netmask 255.255.255.128 dev eth0</code></li><li><p>查看内核路由表: <code>route</code>, 返回如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.6.0     *               255.255.255.0   U     0      0        0 eth0</span><br><span class="line">link-local      *               255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">default         192.168.6.253   0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><ul><li>Destination : 目标网段或者主机</li><li>Gateway : 网关地址。如果是<code>*</code>表示目标是本主机所属的网络不需要路由</li><li>Genmask : 网络掩码</li><li>Flags : 标记。一些可能的标记如下：<ul><li>U — 路由是活动的</li><li>H — 目标是一个主机</li><li>G — 路由指向网关</li></ul></li></ul></li></ul><pre><code>例如，在下面的示例中，本地主机将发送到网络192.19.12的数据包转发到IP地址为192.168.1.1的路由器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Destination    Gateway       Genmask Flags    Metric    Ref     Use    Iface</span><br><span class="line">-----------    -------     -------         -----    -----   ---    ---    -----</span><br><span class="line">192.19.12     192.168.1.1    255.255.255.0      UN      0       0     0    eth0</span><br></pre></td></tr></table></figure>例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Destination    Gateway       Genmask Flags     Metric    Ref    Use    Iface</span><br><span class="line">-----------    -------     ------- -----      ------    ---    ---    -----</span><br><span class="line">default       192.168.1.1     0.0.0.0    UG       0        0     0    eth0</span><br></pre></td></tr></table></figure></code></pre><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><blockquote><p>当ping不到或者丢包严重时, 使用traceroute可以看到从当前计算机到目标主机每一跳的耗时情况, 在哪一个节点丢包等细节</p></blockquote><p>例子:</p><ul><li><code>traceroute -I a.com</code> : 使用ICMP ECHO</li><li><code>traceroute -T a.com</code> : 使用TCP SYN</li><li><code>traceroute -p 8080 a.com</code> : 查询到主机指定端口的路由</li></ul><p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。</p><p>linux系统中，我们称之为 <code>traceroute</code>,在MS Windows中为 <code>tracert</code>。</p><p>traceroute的工作机制主要是利用使用ICMP报文和和IP首部中的TTL（Time to Live?）字段来实现的。在网络数据包的传输过程中，每个处理处理数据包的路由器都要讲数据包的TTL值减1或者减去数据报在路由器中停留的秒数，由于大多数的路由器转发数据报的延时都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1。TTL字段的目的是防止数据报在网络中无休止的流动。当路由器收到一份IP数据报，如果TTL字段是0或者1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是，在通常情况下系统不应该接收TTL字段为0的数据报）。通常情况下是，路由器将该数据报丢弃，并给信源主机发送一份ICMP超时信息。tracerouter程序的关键在于，这份ICMP超时信息包含了该路由器的地址。<br>tracerouter利用网络协议的这种机制，TTL值从1开始每次发送一个TTL等于上次值加一的数据包，直到收到目的主机的响应才停止。这样就能拿到数据包经过路径上的每个路由器的地址信息，从而打印路由信息。<br>有些情况下traceroute无法到达最终节点(traceroute一台主机时，会看到有一些行是以星号表示的) 有可能因为主机屏蔽了ICMP回显, 对于有HTTP服务的服务器, 可以使用-p 指定端口使用TCP协议进行探测<code>traceroute -T -p 80 a.xxx.com</code> (在 macOS上好像不支持-T)</p><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>探测远端机器端口 <code>nmap 192.168.1.1 -p 80</code></p><h2 id="nc-netcat"><a href="#nc-netcat" class="headerlink" title="nc(netcat)"></a>nc(netcat)</h2><ul><li>接受文件: <code>nc -4 -l -p local_port &gt; file</code> 说明:  <code>-4</code>是指IPv4, 如果默认<code>-6</code>有问题就试试这个, <code>-l</code>=listen, <code>-p</code>=port</li><li>发送文件: <code>nc dest_ip dest_port &lt; file</code></li></ul><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>=&gt; [[../22.Network-Protocol/Tcpdump]]</p><h2 id="网卡吞吐量-Throughput"><a href="#网卡吞吐量-Throughput" class="headerlink" title="网卡吞吐量(Throughput)"></a>网卡吞吐量(Throughput)</h2><p><img src="/images/operating_system/Linux-Net-Throughput-A-Day.png" alt=""></p><h3 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h3><p><img src="/images/operating_system/Linux-Net-Throughput-Iftop.png" alt=""></p><p>iftop底部会显示一些全局的统计数据，peek 是指峰值情况，cumm 是从运行至今的累计情况，而 rates 表示最近 2 秒、10 秒、40 秒内总共接收或者发送的平均网络流量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TX:  cumm:   143MB   peak:   10.5Mb    rates:   1.03Mb  1.54Mb  2.10Mb</span><br><span class="line">RX:          12.7GB          228Mb              189Mb   191Mb   183Mb</span><br><span class="line">TOTAL:       12.9GB          229Mb              190Mb   193Mb   185MbW</span><br></pre></td></tr></table></figure><h3 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h3><ul><li>server: <code>iperf -s</code></li><li>client: <code>iperf -c 192.168.0.138 -t 60 -l 8k -i 10</code> // 进行60秒测试, 缓冲区大小8k, 每10秒打印一次结果</li></ul><blockquote><p>测试阿里云服务器大约67.5 Mbits/sec, 似乎是Mac无线网卡的限制…内网的两台服务器测试(非同一机房) 450 Mbits/sec</p></blockquote><h3 id="netperf"><a href="#netperf" class="headerlink" title="netperf"></a>netperf</h3><ul><li>server端: <code>netserver</code></li><li>client端测试tcp: <code>./netperf -t TCP_STREAM -H 192.168.0.138 -l 60 -- -m 2048</code> # 测试时长60秒, 发送分组大小2048 Bytes</li><li>client端测试udp: <code>./netperf -t UDP_STREAM -H 192.168.0.138 -l 60 -- -m 2048</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.01a.常用命令行全称速记</title>
      <link href="/21.Operating-System/Linux.01a.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A8%E7%A7%B0%E9%80%9F%E8%AE%B0/"/>
      <url>/21.Operating-System/Linux.01a.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A8%E7%A7%B0%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>@ref <a href="https://zhuanlan.zhihu.com/p/405637789" target="_blank" rel="noopener">linux命令英文全称 - 知乎</a></p><hr><ul><li><p>su：Swith user 切换用户，切换到root用户</p></li><li><p>cat: Concatenate 串联</p></li><li><p>uname: Unix name 系统名称</p></li><li><p>df: Disk free 空余硬盘</p></li><li><p>du: Disk usage 硬盘使用率</p></li><li><p>chown: Change owner 改变所有者</p></li><li><p>chgrp: Change group 改变用户组</p></li><li><p>ps：Process Status 进程状态</p></li><li><p>tar：Tape archive 解压文件</p></li><li><p>chmod: Change mode 改变模式</p></li><li><p>umount: Unmount 卸载</p></li><li><p>ldd：List dynamic dependencies 列出动态相依</p></li><li><p>insmod：Install module 安装模块</p></li><li><p>rmmod：Remove module 删除模块</p></li><li><p>lsmod：List module 列表模块</p></li><li><p>alias :Create your own name for a command</p></li><li><p>bash :GNU Bourne-Again Shell linux内核</p></li><li><p>grep:global regular expression print</p></li><li><p>httpd :Start Apache</p></li><li><p>ipcalc :Calculate IP information for a host</p></li><li><p>ping :Send ICMP ECHO_Request to network hosts</p></li><li><p>reboot: Restart your computer</p></li><li><p>sudo:Superuser do</p></li><li><p>/bin = BINaries</p></li><li><p>/dev = DEVices</p></li><li><p>/etc = ETCetera</p></li><li><p>/lib = LIBrary</p></li><li><p>/proc = PROCesses</p></li><li><p>/sbin = Superuser BINaries</p></li><li><p>/tmp = TeMPorary</p></li><li><p>/usr = Unix Shared Resources</p></li><li><p>/var = VARiable ?</p></li><li><p>FIFO = First In, First Out</p></li><li><p>GRUB = GRand Unified Bootloader</p></li><li><p>IFS = Internal Field Seperators</p></li><li><p>LILO = LInux LOader</p></li><li><p>MySQL = My最初作者的名字SQL = Structured Query Language</p></li><li><p>PHP = Personal Home Page Tools = PHP Hypertext Preprocessor</p></li><li><p>PS = Prompt String</p></li><li><p>Perl = “Pratical Extraction and Report Language” = “Pathologically Eclectic Rubbish Lister”</p></li><li><p>Python Monty Python’s Flying Circus</p></li><li><p>Tcl = Tool Command Language</p></li><li><p>Tk = ToolKit</p></li><li><p>VT = Video Terminal</p></li><li><p>YaST = Yet Another Setup Tool</p></li><li><p>apache = “a patchy” server</p></li><li><p>apt = Advanced Packaging Tool</p></li><li><p>ar = archiver</p></li><li><p>as = assembler</p></li><li><p>bash = Bourne Again SHell</p></li><li><p>bc = Basic (Better) Calculator</p></li><li><p>bg = BackGround</p></li><li><p>cal = CALendar</p></li><li><p>cat = CATenate</p></li><li><p>cd = Change Directory</p></li><li><p>chgrp = CHange GRouP</p></li><li><p>chmod = CHange MODe</p></li><li><p>chown = CHange OWNer</p></li><li><p>chsh = CHange SHell</p></li><li><p>cmp = compare</p></li><li><p>cobra = Common Object Request Broker Architecture</p></li><li><p>comm = common</p></li><li><p>cp = CoPy</p></li><li><p>cpio = CoPy In and Out</p></li><li><p>cpp = C Pre Processor</p></li><li><p>cups = Common Unix Printing System</p></li><li><p>cvs = Current Version System</p></li><li><p>daemon = Disk And Execution MONitor</p></li><li><p>dc = Desk Calculator</p></li><li><p>dd = Disk Dump</p></li><li><p>df = Disk Free</p></li><li><p>diff = DIFFerence</p></li><li><p>dmesg = diagnostic message</p></li><li><p>du = Disk Usage</p></li><li><p>ed = editor</p></li><li><p>egrep = Extended GREP</p></li><li><p>elf = Extensible Linking Format</p></li><li><p>elm = ELectronic Mail</p></li><li><p>emacs = Editor MACroS</p></li><li><p>eval = EVALuate</p></li><li><p>ex = EXtended</p></li><li><p>exec = EXECute</p></li><li><p>fd = file descriptors</p></li><li><p>fg = ForeGround</p></li><li><p>fgrep = Fixed GREP</p></li><li><p>fmt = format</p></li><li><p>fsck = File System ChecK</p></li><li><p>fstab = FileSystem TABle</p></li><li><p>fvwm = F*** Virtual Window Manager</p></li><li><p>gawk = GNU AWK</p></li><li><p>gpg = GNU Privacy Guard</p></li><li><p>groff = GNU troff</p></li><li><p>hal = Hardware Abstraction Layer</p></li><li><p>joe = Joe’s Own Editor</p></li><li><p>ksh = Korn SHell</p></li><li><p>lame = Lame Ain’t an MP3 Encoder</p></li><li><p>lex = LEXical analyser</p></li><li><p>lisp = LISt Processing = Lots of Irritating Superfluous Parentheses</p></li><li><p>ln = LiNk</p></li><li><p>lpr = Line PRint</p></li><li><p>ls = list</p></li><li><p>lsof = LiSt Open Files</p></li><li><p>m4 = Macro processor Version 4</p></li><li><p>man = MANual pages</p></li><li><p>mawk = Mike Brennan’s AWK</p></li><li><p>mc = Midnight Commander</p></li><li><p>mkfs = MaKe FileSystem</p></li><li><p>mknod = MaKe NODe</p></li><li><p>motd = Message of The Day</p></li><li><p>mozilla = MOsaic GodZILLa</p></li><li><p>mtab = Mount TABle</p></li><li><p>mv = MoVe</p></li><li><p>nano = Nano’s ANOther editor</p></li><li><p>nawk = New AWK</p></li><li><p>nl = Number of Lines</p></li><li><p>nm = names</p></li><li><p>nohup = No HangUP</p></li><li><p>nroff = New ROFF</p></li><li><p>od = Octal Dump</p></li><li><p>passwd = PASSWorD</p></li><li><p>pg = pager</p></li><li><p>pico = PIne’s message COmposition editor</p></li><li><p>pine = “Program for Internet News &amp; Email” = “Pine is not Elm”</p></li><li><p>ping = Packet InterNet Grouper</p></li><li><p>pirntcap = PRINTer CAPability</p></li><li><p>popd = POP Directory</p></li><li><p>pr = pre</p></li><li><p>printf = PRINT Formatted</p></li><li><p>ps = Processes Status</p></li><li><p>pty = pseudo tty</p></li><li><p>pushd = PUSH Directory</p></li><li><p>pwd = Print Working Directory</p></li><li><p>rc = runcom = run command, shell</p></li><li><p>rev = REVerse</p></li><li><p>rm = ReMove</p></li><li><p>rn = Read News</p></li><li><p>roff = RunOFF</p></li><li><p>rpm = RPM Package Manager = RedHat Package Manager</p></li><li><p>rsh, rlogin, = Remote</p></li><li><p>rxvt = ouR XVT</p></li><li><p>sed = Stream EDitor</p></li><li><p>seq = SEQuence</p></li><li><p>shar = SHell ARchive</p></li><li><p>slrn = S-Lang rn</p></li><li><p>ssh = Secure SHell</p></li><li><p>ssl = Secure Sockets Layer</p></li><li><p>stty = Set TTY</p></li><li><p>su = Substitute User</p></li><li><p>svn = SubVersioN</p></li><li><p>tar = Tape ARchive</p></li><li><p>tcsh = TENEX C shell</p></li><li><p>telnet = TEminaL over Network</p></li><li><p>termcap = terminal capability</p></li><li><p>terminfo = terminal information</p></li><li><p>tr = traslate</p></li><li><p>troff = Typesetter new ROFF</p></li><li><p>tsort = Topological SORT</p></li><li><p>tty = TeleTypewriter</p></li><li><p>twm = Tom’s Window Manager</p></li><li><p>tz = TimeZone</p></li><li><p>udev = Userspace DEV</p></li><li><p>ulimit = User’s LIMIT</p></li><li><p>umask = User’s MASK</p></li><li><p>uniq = UNIQue</p></li><li><p>vi = VIsual = Very Inconvenient</p></li><li><p>vim = Vi IMproved</p></li><li><p>wall = write all</p></li><li><p>wc = Word Count</p></li><li><p>wine = WINE Is Not an Emulator</p></li><li><p>xargs = eXtended ARGuments</p></li><li><p>xdm = X Display Manager</p></li><li><p>xlfd = X Logical Font Description</p></li><li><p>xmms = X Multimedia System</p></li><li><p>xrdb = X Resources DataBase</p></li><li><p>xwd = X Window Dump</p></li><li><p>yacc = yet another compiler compiler</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux.01.常用命令行</title>
      <link href="/21.Operating-System/Linux.01.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/21.Operating-System/Linux.01.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="命令全称"><a href="#命令全称" class="headerlink" title="命令全称"></a>命令全称</h2><p>=&gt; <a href="/21.Operating-System/Linux.01a.常用命令行全称速记/" title="Linux.01a.常用命令行全称速记">Linux.01a.常用命令行全称速记</a></p><h2 id="使用-man"><a href="#使用-man" class="headerlink" title="使用 man"></a>使用 man</h2><p>man 可以查看”系统命令/系统调用函数/glibc库函数” 等等共9类内容, 例如 <code>man lsof</code> 第一行是 “LSOF(8)”, 表示是第8类, <code>man man</code> 第一行是”man(8)” 表示man 是第8类, 也可以看到所有9类 “manual”, 如下:</p><blockquote><ol><li>系统命令</li><li>系统调用，一般是对应的C封装函数；所有系统调用的函数在调用发生时都会进入内核空间执行</li><li>各种库函数手册，例如glibc，pthread库API等，如果是非C库，则会标注出对于的链接选项</li><li>特殊设备文件，例如zero, mem等</li><li>文件格式手册，描述Linux支持的各种文件系统以及对于的C接口结构，如vfat/iso</li><li>游戏程序文档</li><li>其它的各种各样不在前边分类的文档（8/9除外）</li><li>系统管理员命令，一般仅供root用户使用，如cron/useradd等</li><li>Linux内核相关部分的手册，一般情况很少用到，这一节就没有intro介绍页</li></ol></blockquote><ul><li><code>man ascii</code>: 该命令用来查看 ASC II表</li><li><code>man malloc</code>: 查看malloc用法, 如果显示 “No manual entry for malloc”, 则需要安装 “man-pages”: <code>yum -y install man-pages</code></li></ul><h2 id="ps-top-free-vmstat"><a href="#ps-top-free-vmstat" class="headerlink" title="ps, top, free, vmstat"></a>ps, top, free, vmstat</h2><p><code>vmstat</code>, <code>sar</code>, <code>iostat</code>, <code>iotop</code> @ref: <a href="/21.Operating-System/Linux.03.命令行-Performance/" title="Linux.03.命令行-Performance">Linux.03.命令行-Performance</a></p><h2 id="sort-uniq-wc-cut"><a href="#sort-uniq-wc-cut" class="headerlink" title="sort, uniq, wc, cut"></a>sort, uniq, wc, cut</h2><ul><li><p><code>sort</code>参数:</p><ul><li>-t 指定分隔符</li><li>-n 按数字大小排序, 如果不加-n默认是ASCII码排序</li><li>-r 倒序</li><li>-k 1,5 指定按哪一列排序, 默认是从第N列到行尾, <code>-k4</code>指定按第四列排序</li></ul><blockquote><p>例:<br>按进程VSS内存排序: <code>ps aux | tr -s &quot; &quot; | sort -nrk 5 | cut -d &quot; &quot; -f 1,2,5,6,11- | more</code><br>分隔符为”:”的文件按照第5列数值排序: <code>cat file | sort -t : -nrk 1,5</code></p></blockquote></li><li><p><code>uniq</code>只能去除相邻行的重复, 所以一般跟<code>sort</code>联用.</p><ul><li>-c: 去重+统计次数</li><li>sort联用: <code>cat /proc/cpuinfo | grep &#39;physical id&#39; | sort | uniq | wc -l</code></li></ul></li><li><code>wc</code>: <ul><li>-l: 统计行数</li><li>-w: 统计单词数</li></ul></li><li><p><code>cut</code>用来显示行中的指定部分, 分隔符用-d 参数(如果不加-d参数则分隔符是制表符), 取出第几列用-f 参数(从1开始),<br>例: <code>who | cut -d &#39; &#39; -f 2</code></p><blockquote><p>注: cut通常和其他命令一起使用, 用来处理其他命令的输出, 但实际情况下很多命令的分隔符并不统一, 所以用 awk比 cut更方便: <code>ls -l | awk &#39;{print $9}&#39;</code></p></blockquote></li></ul><h2 id="chmod-chown-chgrp"><a href="#chmod-chown-chgrp" class="headerlink" title="chmod, chown, chgrp"></a>chmod, chown, chgrp</h2><p>通过<code>ls -l</code>查看文件属性:<br><img src="/images/linux-file-rwx.png" alt="linux-file-rwx"></p><ul><li><code>chmod [-R] xyz 文件或目录名</code>: xyz三个数字即 owner/group/other的 rwx属性之和 (r=4, w=2, x=1)<ul><li><code>chmod 640 file1</code>         // 给user读写权限, group读权限, other无权限</li><li><code>chmod u=rw,g=r,o= file1</code> // 同<code>chmod 640</code></li><li><code>chmod -R o-r /home/*</code>    // 把other的读权限都去掉. chmod支持<code>+</code>,<code>-</code>,<code>=</code>符号.</li></ul></li><li><code>chown [–R] 属主名 文件名</code> or <code>chown [-R] 属主名：属组名 文件名</code></li><li><code>chgrp [-R] 属组名 文件名</code></li></ul><blockquote><p>注: 目录的x权限指可以cd到这个目录, 目录的r权限指可以遍历目录下的文件,<br>父级目录和子文件的权限互不影响, 例如用户有父级目录的x权限, 但目录下的文件不会继承x权限, 但是如果要执行目录下文件, 前提是能切到父级目录, 意味着父级目录要有x权限</p></blockquote><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><ul><li>创建软链接: <code>ln -s src target</code>  // 记住 <code>ln ... as ...</code></li><li>创建硬链接: <code>ln src target</code></li><li>软链接vs硬链接:<ul><li>允许对目录创建软链接,硬链接不可以</li><li>可以跨文件系统创建软链接, 硬链接不可以</li><li>删除源文件, 软链接将失效, 硬链接仍保留删除前源文件内容</li></ul></li></ul><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">理解 Linux 的硬链接与软链接</a></p></blockquote><h2 id="gzip-bzip2-tar"><a href="#gzip-bzip2-tar" class="headerlink" title="gzip, bzip2, tar"></a>gzip, bzip2, tar</h2><p><img src="/images/operating_system/linux-compress-cmd.png" alt="linux_compress_cmd"></p><p>压缩与读压缩命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -v file1    # 压缩为gz格式</span><br><span class="line">bzip2 -z file1   # 压缩为bz2格式</span><br><span class="line"></span><br><span class="line">zcat file1.gz    # 不解压读取gz</span><br><span class="line">bzcat file1.bz2  # 不解压读取bz2</span><br><span class="line"></span><br><span class="line">gzip -d file1.gz   # 解压gz</span><br><span class="line">bzip2 -d file1.bz2 # 解压bz2</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: gzip压缩后不保留源文件, bzip2必须加<code>-k</code>参数才保留源文件</p></blockquote><p>打包与解包:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar cvzf file1 file1.tar.gz   # 打包为 tar.gz</span><br><span class="line">tar cvjf file1 file1.tar.bz2  # 打包为 tar.bz2</span><br><span class="line"></span><br><span class="line">tar xvzf file1.tar.gz</span><br><span class="line">tar xvjf file1.tar.bz2</span><br></pre></td></tr></table></figure></p><h2 id="where-which-locate"><a href="#where-which-locate" class="headerlink" title="where, which, locate"></a>where, which, locate</h2><p>功能和which类似, 也是一种查找, 区别在于locate搜索的是数据库/var/lib/locatedb所以速度更快, 例如<code>locate _vimrc</code></p><h2 id="sed-awk"><a href="#sed-awk" class="headerlink" title="sed, awk"></a>sed, awk</h2><p>@ref: <a href="https://whatsrtos.github.io/Linux/Linux-Sed_Awk_Grep/" target="_blank" rel="noopener">sed &amp; awk &amp; grep</a></p><h2 id="find-grep-ack"><a href="#find-grep-ack" class="headerlink" title="find, grep, ack"></a>find, grep, ack</h2><ul><li><strong>find</strong>:<ul><li>按时间查找, 可用参数有: <code>-mmin</code> 以分钟为单位, <code>-mtime</code> 以天为单位, 后面的数字<code>+</code>表示比该时间更早, <code>-</code>表示该时间之后-当前,<ul><li>查找N天之前更早的: <code>find . -mtime +3 -name &#39;*.log&#39;</code></li><li>查找N天前~当前时刻的: <code>find . -mtime -3 -name &#39;*.log&#39;</code></li></ul></li><li>在当前目录及其子目录下查找符号链接文件: <code>find -type l</code></li><li>在当前目录及其子目录下查文件夹: <code>find -type d</code></li><li>在当前目录查找普通文件: <code>find -type f</code></li><li>在root目录下及其最大3层深度的子目录中查找: <code>find / -max-depth 3 -name log</code></li><li>查找特定文件并ls列出: <code>find -name *.java -exec ls -l {} \;</code> 注意exec的参数必须以”分号”结束,分号还要加转义符.解释:<ul><li><code>{}</code>是前面find找到的文件,</li><li><code>-exec</code>后面的参数后面跟的是command命令, 它的终止是以<code>;</code>为结束标志的, 所以这句命令后面的”分号”是不可缺少的, 考虑到各个系统中分号会有不同的意义, 所以前面加反斜杠.  参考 <a href="https://stackoverflow.com/questions/6085156/using-semicolon-vs-plus-with-exec-in-find" target="_blank" rel="noopener">Using semicolon (;) vs plus (+) with exec in find - Stack Overflow</a></li><li>shell的内建命令<code>-exec</code>将并不启动新的shell, 而是用要被执行命令替换当前的shell进程, 并且将老进程的环境清理掉, 而且exec命令后的其它命令将不再执行. 以新的进程去代替原来的进程, 但进程的PID保持不变.</li></ul></li><li>与xargs配合使用: <code>find find -name *.java | xargs rm -f</code></li></ul></li></ul><blockquote><p>文件的 atime, mtime,ctime<br>atime: 文件访问时间, 用<code>touch</code>,<code>vi</code>等命令都会修改这个时间<br>ctime: 文件元数据(所属人,读写权限..) <code>chown</code>,<code>chmod</code>都会…<br>mtime: 文件内容修改时间, ps修改了文件内容, 文件元数据也会变化<br><code>ls -l</code> 列出来的是ctime<br>命令<code>stat fileName</code>返回如下</p></blockquote><p><img src="/images/20211227145907.png" alt=""></p><ul><li><p><strong>grep</strong>:</p><ul><li>查找某个文件: <code>grep &quot;Invalid user&quot; /var/log/auth.log</code></li><li>查找多个Word: <code>grep -E &quot;word1|word2&quot;</code></li><li>在某个目录下递归查找: <code>grep -irn &quot;xxx&quot; /dir</code></li><li>与<code>find</code>一起使用: <code>find . -name &quot;*.css&quot; | xargs grep &quot;monospac&quot;</code></li></ul><blockquote><p>grep = globally search for regular expression and print out // @ref: <a href="https://www.geeksforgeeks.org/grep-command-in-unixlinux/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/grep-command-in-unixlinux/</a></p></blockquote></li><li><p><strong>ack</strong>:</p><ul><li><code>ack xxxx dir/log1</code>: 在指定文件里搜索xxx</li><li><code>ack --java xxxx</code>: 在java文件里搜索xxx</li><li><code>ack -i xxx</code>: 不区分大小写</li><li><code>ack -w xxx</code>: 全词匹配</li></ul></li></ul><h2 id="who-w-whoami-last"><a href="#who-w-whoami-last" class="headerlink" title="who, w, whoami, last"></a>who, w, whoami, last</h2><ul><li><code>w</code> - Show who is logged on and what they are doing.</li><li><code>who</code> - show who is logged on</li><li><code>whoami</code> - print effective userid</li><li><code>who am i</code> - When a user logs in as a root across the network, both the command</li><li><code>whoami</code> and <code>who am i</code> will show you root. However, when a user abc logs in remotely<br>and runs <code>su – root</code>, <code>whoami</code> will show root whereas <code>who am i</code> will show abc</li><li><code>last</code>: 获取每个用户登录的持续时间. 该记录保存在: <code>/var/log/wtmp</code></li></ul><h2 id="lsof-fuser"><a href="#lsof-fuser" class="headerlink" title="lsof, fuser"></a>lsof, fuser</h2><p><strong>fuser:</strong><br>列出哪个进程在使用文件: <code>fuser /etc/filenames</code></p><p><strong>lsof:</strong></p><ul><li>常用参数:<ul><li><code>-p 进程id</code></li><li><code>-i :端口号</code></li><li><code>-P</code> :  默认情况lsof会显示 “端口名字” 而不是 “数字类型的端口号” （如果此端口号有名字的话）, <code>-P</code>可以指定显示数字端口号, 而不是名字</li></ul></li><li>用法示例:<ul><li>查找已被删除但硬盘空间不释放的文件: <code>lsof |grep delete</code>, 这个文件的innode链接被移除了, 但还没有被删掉</li><li>某个端口: <code>lsof -i TCP:8080</code> or <code>lsof -i :80</code></li><li>某个进程: <code>lsof -p PID</code></li><li>查看所有活动状态的网络服务: lsof -i</li><li>查看某个用户打开的文件: <code>lsof -u ^root</code>, 或者<code>lsof | grep ^root</code></li></ul></li></ul><p>Example: lsof返回数据如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND     PID    USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class="line">init          1    root  cwd       DIR                8,1        4096          2 /</span><br><span class="line">crond      4621    root  txt       REG                8,5       64096     151941 /usr/sbin/crond</span><br><span class="line">crond      4621    root  DEL       REG                8,1                    115 /lib64/libnss_files-2.12.so</span><br><span class="line">nginx     42544    root  194u     unix 0xffff880012b9a080         0t0  510761950 socket</span><br><span class="line">nginx     42544    root  195u     unix 0xffff8800cbb99cc0         0t0  510761952 socket</span><br><span class="line">java      27672    root   66u     IPv4           41351930         0t0        TCP *:56494 (LISTEN)</span><br></pre></td></tr></table></figure><ul><li><code>lsof | awk &#39;{process[$1]++;} END{for(key in process) printf(&quot;%s:%d\n&quot;, key, process[key])}&#39;</code>  // 每个进程打开的文件数</li><li><code>lsof | awk &#39;{if($8 == &quot;TCP&quot;) opened_tcp++} END{print opened_tcp }&#39;</code> //打开TCP连接数量</li><li><code>lsof | awk &#39;{opened_type[$5]++} END{ for(key in opened_type) printf(&quot;%s : %d\n&quot;, key, opened_type[key])}&#39;</code> // 打开文件按TYPE统计</li></ul><h2 id="du-df-fdisk"><a href="#du-df-fdisk" class="headerlink" title="du, df, fdisk"></a>du, df, fdisk</h2><ul><li>du:<ul><li>查看当前子目录大小: <code>du -h --max-depth=1</code></li><li>当前目录文件按大小排序: <code>du -s * | sort -n | tail</code></li></ul></li></ul><h2 id="exec-xargs"><a href="#exec-xargs" class="headerlink" title="-exec, xargs"></a>-exec, xargs</h2><p>xargs的作用一般等同于大多数Unix shell中的反引号, 但更加灵活易用, 并可以正确处理输入中有空格等特殊字符的情况. 对于经常产生大量输出的命令如find、locate和grep来说非常有用: <code>file * |grep ASCII | cut -d&quot;:&quot; -f1 |xargs ls -l</code></p><ul><li>-exec查找并grep: <code>find . -name &quot;*.php&quot; -exec grep -in &quot;string&quot; {} \;</code> 最后的<code>\;</code>是-exec的结束标识</li><li>xargs: <code>find . -name &quot;*.php&quot; | xargs grep -in &quot;string&quot;</code></li></ul><h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h2><ul><li>查看所有的限制: <code>ulimit -a</code><ul><li>set 最大打开文件句柄数: <code>ulimit -n 65535</code>, 查看当前值<code>ulimit -n</code></li><li>set 最大进程数: <code>ulimit -u 32768</code>, 查看当前值<code>ulimit -u</code></li><li>set 线程栈的大小: <code>ulimit -s 10240</code></li><li>set core文件大小: <code>ulimit -c xxx</code>, 不限制core的大小: <code>ulimit -c unlimited</code></li></ul></li></ul><blockquote><p>ulimit起作用的范围是当前Shell, 并不是作用于”当前用户”, 如要对”用户”做限制, 则需要修改系统文件<code>/etc/security/limits.conf</code></p></blockquote><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>umask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。</p><ul><li><code>umask 022</code>: 用户权限为755</li><li><code>umask 077</code>: 用户权限为700</li></ul><h2 id="su-sudo"><a href="#su-sudo" class="headerlink" title="su, sudo"></a>su, sudo</h2><p>su:</p><ul><li><code>su</code>: 切换到root用户, 切换之前的环境变量一并被带到了新shell里;</li><li><code>su - user_name</code>:  切换用户, 切换之后的环境变量会改变为新用户的,  <code>su -</code> 同<code>su - root</code><ul><li>例: <code>su - root -c commands</code>, 执行完commands之后自动切换会原来的用户.</li></ul></li></ul><p>sudo:</p><ul><li><code>sudo</code>是受限制的su, 两个命令的最大区别是：<code>sudo</code> 命令需要输入当前用户的密码，<code>su</code> 命令需要输入 root 用户的密码。</li><li><code>sudo -s cmd</code>: 执行cmd命令, 如果是<code>sudo -s</code>则会启动一个可交互shell, 有点类似<code>su</code>,</li><li>通过修改<code>/etc/sudoer</code>配置哪些用户具有执行sudo的权限, sudo命令能继承哪些环境变量也是在<code>/etc/sudoer</code>中配置的.</li></ul><h2 id="export-amp-环境变量"><a href="#export-amp-环境变量" class="headerlink" title="export &amp; 环境变量"></a>export &amp; 环境变量</h2><ul><li><code>VAR=hello</code> $VAR scope is restricted to the shell;</li><li><code>export VAR=hello</code> makes the $VAR available to child processes;</li></ul><p>每个进程的环境变量可以在<code>/proc/$PID/evnrion</code>查看.</p><h2 id="sh-exec-source的区别"><a href="#sh-exec-source的区别" class="headerlink" title="sh, exec, source的区别"></a>sh, exec, source的区别</h2><ul><li><code>source</code> 和 点命令<code>.</code>是一样的, 不会启动子shell, 不需要script有可执行权限, script里定义的变量也会被导入当前的shell环境.</li><li><code>./script</code> 启动子shell, script里的变量不会被带进当前环境, 相当于<code>fork</code>, 需要脚本有x权限</li><li><code>sh ./script</code> 先启动了一个子shell, 子shell继承父shell的环境变量, 但子shell里新建变量、改变变量 不会被带回父shell, 除非用<code>export VAR=&quot;xxx&quot;</code></li><li><code>exec cmd</code> 产生了新的进程, 新进程会关闭当前shell的进程, 新的进程继承了原shell的PID号, 原shell剩下的内容不会执行,</li></ul><h2 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h2><p>多命令顺序执行:</p><ul><li>分号（<code>;</code>）： 顺序执行，命令之间不存在关系，互不影响<ul><li>例 <code>ls; date; cd /user; pwd</code></li></ul></li><li>逻辑与（<code>&amp;&amp;</code>）： 只有第一条命令成功执行，才会执行第二条命令<ul><li>例 <code>cd ~/dir &amp;&amp; git commit -am &quot;u&quot; &amp;&amp; git pull &amp;&amp; git push</code></li></ul></li><li>逻辑或（<code>||</code>）： 第一条成功执行，第二条不执行; 第一条非正确执行，第二条才会执行</li></ul><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><a href="/21.Operating-System/Linux.31.Posix接口/" title="Linux.31.Posix接口">Linux.31.Posix接口</a><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>并不是所有的程序都像 Nginx, Redis, httpd一样提供守护进程, 保证在关闭终端会话后正常运行.<br>如果终端会话关闭，那么程序也会被关闭。为了能够后台运行，那么我们就可以使用nohup:</p><ul><li><code>nohup cmd &amp;</code> : 后台运行cmd, 程序运行的输出信息放到当前目录的 nohup.out 文件中去</li><li><code>nohup command &gt; myout.log 2&gt;&amp;1 &amp;</code> : 后台运行cmd, 并指定输出的文件</li></ul><blockquote><p>nohup的原理也很简单，终端关闭后会给此终端下的每一个进程发送<code>SIGHUP</code>信号，而使用nohup运行的进程则会忽略这个信号，因此终端关闭后进程也不会退出。</p></blockquote><h2 id="命令重定向"><a href="#命令重定向" class="headerlink" title="命令重定向"></a>命令重定向</h2><blockquote><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件: 文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p></blockquote><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将输出重定向到 file</span></span><br><span class="line">command &gt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将输出追加重定向到 file</span></span><br><span class="line">command &gt;&gt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为n的文件重定向到 file</span></span><br><span class="line"><span class="meta">n&gt;</span><span class="bash">file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为 n 的文件以追加的方式重定向到 file</span></span><br><span class="line"><span class="meta">n&gt;</span><span class="bash">&gt;file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为 m 和 n 的内容合并,注意</span></span><br><span class="line"><span class="meta">n&gt;</span><span class="bash">&amp;m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件描述符为 m 和 n 的内容合并, 一并输出到 file</span></span><br><span class="line">command &gt; file m&gt;&amp;n</span><br></pre></td></tr></table></figure><blockquote><p>有关 <code>command &gt;out.file  2&gt;&amp;1 &amp;</code> 的解释(注意文件描述符和重定向符号之间不能有空格):<br>最后的<code>&amp;</code> 表示后台运行;<br>为什么是 <code>2&gt;&amp;1</code> 而不是 <code>2&gt;1</code> ? 这样做会直接输出文件名为1的文件;<br><code>&gt;outfile</code> 和 <code>2&gt;&amp;1</code> 的顺序可以交换吗? 不可以, <code>command 2&gt;&amp;1 &gt;out.file</code> ,  先<code>2&gt;&amp;1</code> 的意思是 stderr输出到 stdout, 此时的 stdout是输出到终端的, stderr也就被输出到终端, 然后 <code>&gt;out.file</code>是把 stdout输出到文件, 但是此时 stderr还是输出到终端的;</p></blockquote><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 file的内容作为标准输入</span></span><br><span class="line">command &lt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 infile的内容作为标准输入, 标准输出写入 outfile</span></span><br><span class="line">command &lt; infile &gt; outfile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Here Document 式重定向输入, 将定界符（下面例子中的EOF没有特殊含义, 可以自定义界定符）之间的作为stdin</span></span><br><span class="line">command &lt;&lt; EOF</span><br><span class="line">    hello</span><br><span class="line">    world</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p></blockquote><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><ul><li>创建一个空文件, 除了touch还可 : <code>&gt; file</code></li><li>用ssh远程执行本地脚本, 不用scp拷贝 : <code>ssh root@host bash &lt; /local/xxx.sh</code></li><li><code>&lt;(COMMAND)</code> 可以作为一个文件 : <code>diff /etc/host &lt;(ssh remote cat /etc/hosts)</code></li></ul><h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><ul><li>脚本内执行<code>java -jar ...</code>命令, 通过<code>$!</code>获得子进程ID</li><li>脚本执行<code>wait 子进程ID</code></li><li>如下</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_term() &#123;</span><br><span class="line">    kill -TERM "$child_pid"</span><br><span class="line">    wait "$child_pid"</span><br><span class="line">&#125;</span><br><span class="line">trap _term SIGTERM</span><br><span class="line"></span><br><span class="line">java -Dspring.profiles.active=test \</span><br><span class="line">     -Dserver.port=9013 \</span><br><span class="line">     -jar wallet-console-2.0.0.jar &amp;</span><br><span class="line"></span><br><span class="line">child_pid=$!</span><br><span class="line">wait "$child_pid"</span><br></pre></td></tr></table></figure><h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><a href="/21.Operating-System/Linux.02.网络命令/" title="Linux.02.网络命令">Linux.02.网络命令</a><h2 id="常用配置文件"><a href="#常用配置文件" class="headerlink" title="常用配置文件"></a>常用配置文件</h2><a href="/21.Operating-System/Linux.05.系统配置/" title="Linux.05.系统配置">Linux.05.系统配置</a>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU是怎么制造出来的</title>
      <link href="/21.Operating-System/CPU%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%B6%E9%80%A0%E5%87%BA%E6%9D%A5%E7%9A%84/"/>
      <url>/21.Operating-System/CPU%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%B6%E9%80%A0%E5%87%BA%E6%9D%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="https://www.youtube.com/watch?v=7MFly82e46Q" target="_blank" rel="noopener">中兴禁令之芯片为什么这么难做？芯片的基本原理是什么？</a></p><p><img src="/images/20220423225853.png" alt=""></p><p>PN结：p型和n型半导体之间的接触面即称为PN结<br>    • N型：掺入磷元素(5电子)<br>    • P型：掺入硼元素(3电子)</p><p>PN结特点：只有P加正极，N加负极，电流才能通过</p><p>二极管：二极管就是由一个PN结加上相应的电极引线及管壳封装而成的。</p><p>逻辑与门：输入A、B，输出Y;</p><p>两个二极管组成最简单的与门：<br>    • 5v供电<br>    • A=5v，B=5v时：输出Y=5v<br>    • A=0v，B=5v时，输出Y=0v</p>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU的缓存</title>
      <link href="/21.Operating-System/CPU%E7%9A%84%E7%BC%93%E5%AD%98/"/>
      <url>/21.Operating-System/CPU%E7%9A%84%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-Cache基础"><a href="#CPU-Cache基础" class="headerlink" title="CPU Cache基础"></a>CPU Cache基础</h1><ul><li>一般来说, CPU Cache分三级: L1/L2/L3</li><li>CPU Cache大小: L1 &lt; L2 &lt; L3<ul><li>例如：Intel Core i7-8700K ，是一个6核的CPU，每核上的L1是64KB（数据和指令各32KB），L2 是 256K，L3有2MB</li></ul></li><li>读取速度: L1&gt; L2&gt; L3<ul><li>L1 = 4个时钟</li><li>L2 = 11个时钟</li><li>L3 = 39个时钟</li><li>内存= 107个时钟</li></ul></li><li>L1 分指令和数据Cache, 每个Core各一个指令和数据Cache, 每个Core一个L2, 所有Core 共享L3(见下图)</li></ul><p><img src="/images/CPU_CACHE.png" alt="../_images/CPU_CACHE.png"></p><h1 id="CPU-Cache命中"><a href="#CPU-Cache命中" class="headerlink" title="CPU Cache命中"></a>CPU Cache命中</h1><p>➤ Cache Line 和N-Way查找策略</p><ul><li>当要读取某个变量的值, 首先从CPU的L1 Cache里读, 读不到则取L2 Cache读…这样需要把内存地址映射到CPU Cache的某个地址, 但L1 Cache仅有32KB, 需要有一种算法, 能够让内存地址映射到CPU Cache</li><li>Cache Line: CPU把数据从内存加载到CPU Cache 并不是逐个字节加载的, Cache Line 是一次加载的最小单位, 一个主流的CPU的Cache Line 是 64 Bytes（也有的CPU用32Bytes和128Bytes）</li><li>CPU一般使用”N-Way 关联” (N-Way Associative)方式, 比如8-Way: <ul><li>如果某CPU的L1 Cache有32KB, 则共有32KB/64 Bytes = 512个Line</li><li>每一Way的Line数: 512/8= 64个</li><li>此外,每个Cache Line前都有独立的24bit 来存”tag”, 也即内存地址的前24bit</li></ul></li></ul><p>➤ 8-Way Associative 如何对Cache进行查找 // 从内存地址到L1 Cache地址的映射规则, 如下:<br><img src="/images/CPU-Cache-8-Way.png" alt="../_images/CPU-Cache-8-Way.png"></p><ul><li>内存地址(36bit)分三部分:  24bit,  6bit, 6bit</li><li>Index: 中间6bit 可以索引 <code>2^6 = 64</code>行 (下图每行是一组, Set),  中间6位也叫做”Set Index”, 该Set有8个Line</li><li>Tag: 然后对这8个Line(所以叫8Way) 进行<code>O(n)</code> /  n=8的遍历, 如果内存地址前24bit, 等于Line的tag,  则找到了Cache Line</li><li>Offset: 内存地址后6位, 是在该Line内的偏移</li><li>综上, L1 Cache可以对<code>2^36 = 64GB</code>的内存做缓存, Set Index是O(1)的, 放在同一个Set(下图中的一行)的8 Way Line, 相当于HashMap的Hash碰撞… 发生碰撞再通过O(n) 的查找…. </li><li>因为是通过中间6bit进行Set Index的, 所以当内存地址a, 会和a+4096的地址发生Set Index 冲突 , <code>2^(6+6) = 4096</code>, 发生冲突的概率还是很大的</li><li>当CPU Cache未命中时, 会从内存(以Cache Line为最小单位)加载到 Cache, 但每次并不仅仅加载一个Cache Line的数据, 因为访问内存太慢了, CPU会通过”预加载” (Prefetching)技术预先加载更多的内存到CPU Cache. 例如通过for-loop访问一个数组</li></ul><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p>@todo 未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 21.Operating-System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构模式</title>
      <link href="/14.Coding-Pattern/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <url>/14.Coding-Pattern/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>➤ 软件设计的”方法论”</p><ul><li>design patterns: 代码层面</li><li>architecture patterns: 架构层面</li></ul><p>architecture patterns:</p><ul><li>分层架构</li><li>管道..</li><li>CS..</li><li>MVC..</li><li>事件驱动..</li><li>微服务..</li></ul><p>➤ 分层架构: 表现层→业务层→数据层</p><ul><li>特性: 用户请求不能跨层, 层和层之间暴露接口</li><li>优缺点:<br><img src="/images/20220216173947.png" alt=""></li></ul><p>➤ 管道-过滤器架构: source → filter1 → filterN → sink</p><ul><li>例子: shell的<code>|</code></li></ul><p><img src="/images/20220216174005.png" alt=""></p><p>➤ CS架构: Client → Server</p><ul><li>特性: Server端有可共享的/丰富的资源</li></ul><p><img src="/images/20220216174029.png" alt=""></p><p>➤ MVC架构: view → controller → model</p><ul><li>特性:<ul><li>m的变化由controller通知view变更</li><li>view的操作由controller通知model</li><li>适用于用户界面的开发<br><img src="/images/20220216174116.png" alt=""></li></ul></li></ul><p>➤ 事件驱动架构: 事件产生 → 事件队列 → dispatch → handler<br><img src="/images/20220216174129.png" alt=""></p><p>➤ 微服务架构:<br><img src="/images/20220216174408.png" alt=""></p><p>@ref:</p><ul><li><a href="https://learning.oreilly.com/library/view/fundamentals-of-software/9781492043447/" target="_blank" rel="noopener">Fundamentals of Software Architecture</a></li><li><a href="https://zhuanlan.zhihu.com/p/346424474" target="_blank" rel="noopener">从分层架构到微服务架构（一） - 知乎</a></li><li><a href="https://www.infoq.cn/article/6rx047oohjlrdipd1bc2" target="_blank" rel="noopener">程序员必知的几种软件架构模式-InfoQ</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 14.Coding-Pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/14.Coding-Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/14.Coding-Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>索引: <a href="https://zh.wikipedia.org/wiki/设计模式：可复用面向对象软件的基础" target="_blank" rel="noopener">设计模式：可复用面向对象软件的基础</a></p><blockquote><p>《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）是软件工程领域有关设计模式的一本书，提出和总结了对于一些常见软件设计问题的标准解决方案，称为软件设计模式。该书作者是埃里希·伽玛（Erich Gamma）、Richard Helm、Ralph Johnson和John Vlissides，后以“四人帮”（Gang of Four，GoF）[1]著称，书中的设计模式也被成为“四人帮设计模式”（Gang of Four design patterns）</p></blockquote><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul><li><a href="https://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="noopener">命令模式</a></li><li><a href="https://www.runoob.com/design-pattern/intercepting-filter-pattern.html" target="_blank" rel="noopener">拦截过滤器模式</a></li><li><a href="https://www.runoob.com/design-pattern/null-object-pattern.html" target="_blank" rel="noopener">空对象模式</a></li><li><a href="https://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">原型模式</a></li></ul><p><img src="/images/wikipedia-design-patterns.png" alt="wikipedia-design-patterns"></p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><ul><li>工厂类实现工厂方法, 根据传入参数的不同, 返回不同的产品实例(可以返回产品的抽象类)</li><li>简单工厂类的工厂方法是静态方法, 又称为静态工厂模式</li><li>问题:<ul><li>增加一种产品需要修改工厂方法, 增加工厂方法的复杂性</li><li>由于使用了静态方法, 简单工厂无法形成基于继承的层级结构</li></ul></li></ul><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><ul><li>抽象工厂类提供抽象工厂方法(可以有多种方法), 此类方法返回产品的抽象类</li><li>实现抽象工厂类, 实现类需要实现不同的工厂方法, 此外还需要实现 FactoryProducer 来获取不同的工厂实例</li><li>对于调用者而言, 调用这些工厂方法的方式都是一样的</li><li>相比简单工厂:<ul><li>简单工厂在一个工厂方法里生产所有产品, 如果需要新增产品…需要更改具体的工厂方法</li><li>抽象工厂包含多个工厂实现, 每个工厂实现类只生产一类产品, 如果需要新增产品, 只需要增加新工厂类和方法</li><li>问题是, 用户代码又引入了”FactoryProducer”, 以及, 如果要新增产品和工厂, 需要修改抽象工厂类</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br></pre></td></tr></table></figure><p>AbstractFactory factory1 = FactoryProducer.getFactory(type1)<br>AbstractFactory factory2 = FactoryProducer.getFactory(type2)</p><p>AbstractProduct product1 = factory1.get()<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 建造模式</span><br><span class="line">* 抽象Builder, 提供为产品设定各个属性的的抽象方法, 以及创建产品的抽象方法</span><br><span class="line">* 具体Builder, 实现...</span><br><span class="line">* 调用者创建具体的Builder实例, 调用抽象Builder类的设定属性的方法, 最后创建产品..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 单例模式</span><br><span class="line">* 单例模式的类, 会保证该类仅有一个实例, 并提供一个创建&amp;获取唯一实例的方法</span><br><span class="line">* 为了保证只有一个实例, 单例类的构造函数是私有的, 不允许其他类调用其构造函数</span><br><span class="line">* 基本样式:</span><br></pre></td></tr></table></figure></p><p>   class Singleton {<br>     private static Singleton INSTANCE;<br>     private Singleton();<br>     public Singleton getInstance(); // 获取单例的具体实现<br>   }<br>  <code>`</code></p><ul><li>实现singleton的几种方式:<ol><li>Lazy式, <code>getInstance()</code>使用synchronized 加锁</li><li>Lazy式, <code>getInstance()</code>使用DLC(double lock check)</li><li>非Lazy式, 在static区进行实例化 // 不需要lazy loading时的首选</li><li>Lazy式, 嵌套类(Singleton类里加一个static类) // 需要lazy loading时的首选</li><li>枚举 // </li></ol></li></ul><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>adaptor or wrapper</li><li>用户代码里调用 methodA(), 但是实现类()没有提供 methodA()却提供了 methodB(), 这时候需要 adaptor类对实现类进行包装, 并提供 methodA()</li><li>实现: adaptor类中, 持有一个实现类的引用 // 注意adaptor和实现类非继承, 而是关联关系</li></ul><p><img src="/images/design-patterns-adapter.png" alt="design-patterns-adapter"></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul><li>桥接模式把抽象事物/抽象行为分离开, 抽象事物 调用 抽象行为(的方法)</li><li>抽象事物(Abstraction)的继承类仍是抽象类(RedefinedAbstraction)</li><li>抽象行为(Implementor)</li><li>抽象事物(Abstraction)像桥一样把 RedefinedAbstraction类和 Implementor类连接在一起</li><li>实现:<ul><li>抽象事物(Abstraction) 持有抽象行为(Implementor)的引用</li><li>RedefinedAbstraction extends Abstraction //实现具体事物</li><li>ConcreteImplementor extends Implementor  //实现具体行为</li></ul></li></ul><p><img src="/images/design-patterns-bridge.png" alt="design-patterns-bridge"></p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ul><li>增加一个修饰类, 包裹原来的类, 包裹的方式一般是通过修饰类的构造函数传入, 修饰类实现新的功能</li><li>装饰模式可以避免向一个实现类添加新方法导致代码膨胀</li><li>下图中的 Decorator类即装饰类, 装饰类可以改写operation()方法也可以增加自己的方法</li><li>实现:<ul><li>需要被装饰的类(ConcreteComponent), 和它的基类(Component)</li><li>装饰类(Decorator) 持有基类的一个引用. 事实上装饰类也继承上面的基类</li></ul></li></ul><p><img src="/images/design-patterns-decorator.png" alt="design-patterns-decorator"></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul><li>用户代码不调用具体的功能类, 而是通过调用代理类间接调用这些功能类 (用户代码往往调用的是代理类的抽象接口, 代理也不直接调用功能类, 而是调用功能类的接口)</li><li>代理类可以调用多种功能类, 并且可以在代理类中, 增加一些功能</li><li>实现:<ul><li>被代理的类(RealSubject), 需要有一个接口(Subject)</li><li>创建Proxy类, Proxy类也实现该接口(Subject)</li><li>用户(client) 不直接调用 <code>realSubject.DoAction()</code>, 而是调用 Proxy的<code>DoAction()</code>, 间接调用 <code>realSubject.DoAction()</code></li><li>可以在代理类 <code>Proxy::DoAction()</code>中做一些额外的操作: e.g.<ul><li>实现引用计数</li><li>Java的AOP(面向切面编程)</li></ul></li></ul></li></ul><p><img src="/images/design-patterns-proxy.png" alt="design-patterns-proxy"></p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ul><li>创建大量对象时, 把这些对象共有的部分抽象出来单独存储, 这些对象共享共有部分, 而不是重复创建</li><li>享元模式通过共享数据减少内存使用量</li><li>例子: Java String Pool</li></ul><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ul><li>实现责任链模式的抽象类, 通常具有一个next属性</li><li>实现类判断是否在自己这一层进行处理, 然后传递给next指向的对象</li><li>例如一条日志具有 debug/info/warning/error几个级别, 每个实现类判断自己是否需要处理(自己的优先级同这条日志的优先级比较), 然后传给下一个实现类</li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul><li>观察者 attach到被观察者, 被观察者发生改变时, 通知观察者</li><li>下图中, Observer是观察者, Subject作为被观察者的抽象类, 提供了attach和detach观察者的方法(add和delete)</li><li>实现:<ul><li>被观察者( Subject) 持有观察者(Observer)的对象</li><li>注意二者关系是聚合关系(一种松散的关联关系, 二者不必有共同生命周期, Observer可以随时attach/detach到Subject)</li></ul></li></ul><p><img src="/images/design-patterns-observer.png" alt="../_images/design-patterns-observer.png"></p><h1 id="JDK里的设计模式-zz"><a href="#JDK里的设计模式-zz" class="headerlink" title="JDK里的设计模式(zz)"></a>JDK里的设计模式(zz)</h1><ul><li>创建模式:<ul><li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 <code>java.util.Calendar#getInstance()</code>。</li><li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：<code>java.lang.StringBuilder#append()</code>。</li><li>工厂方法：一个返回具体对象的方法，而不是多个，如 <code>java.lang.Object#toString()</code>、<code>java.lang.Class#newInstance()</code>。</li><li>原型模式：使得类的实例能够生成自身的拷贝、如：<code>java.lang.Object#clone()</code>。</li><li>单例模式：全局只有一个实例，如 <code>java.lang.Runtime#getRuntime()</code>。</li></ul></li><li>结构型模式：<ul><li>适配器：用来把一个接口转化成另一个接口，如 <code>java.util.Arrays#asList()</code>。</li><li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 <code>Map.putAll</code>，<code>List.addAll</code>、<code>Set.addAll</code>。</li><li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 <code>java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap</code>。</li><li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 <code>java.lang.reflect.Proxy</code></li></ul></li><li>行为模式：<ul><li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：<code>java.lang.Runnable</code>。</li><li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，<code>java.text.Format</code>，<code>java.text.Normalizer</code>。</li><li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 <code>java.util.Iterator</code>。</li><li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，<code>java.lang.reflect.Method#invoke()</code>。</li><li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 <code>java.util.EventListener</code>。</li><li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 <code>javax.servlet.Filter#doFilter()</code>。</li><li>空对象模式：如 <code>java.util.Collections#emptyList()</code>。</li><li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 <code>java.util.Collections#sort()</code>。</li></ul></li></ul><p>@ref: <a href="https://www.javacodegeeks.com/2011/03/design-patterns-in-jdk.html" target="_blank" rel="noopener">Design Patterns in the JDK | Java Code Geeks - 2021</a></p><h1 id="关于UML"><a href="#关于UML" class="headerlink" title="关于UML"></a>关于UML</h1><p>UML参考: <a href="/14.Coding-Pattern/设计模式-UML类图/" title="设计模式-UML类图">设计模式-UML类图</a></p>]]></content>
      
      
      <categories>
          
          <category> 14.Coding-Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-UML类图</title>
      <link href="/14.Coding-Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML%E7%B1%BB%E5%9B%BE/"/>
      <url>/14.Coding-Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><p>➤ 具体类:</p><ul><li>第一层类名, 第二层成员变量, 第三层方法</li><li>访问控制: <code>+</code>表示public, <code>-</code>表示private …</li></ul><p><img src="/images/uml-class.png" alt="../_images/uml-class.png"></p><p>➤ 抽象类:  </p><ul><li>类名用斜体</li></ul><p><img src="/images/uml-abstract.png" alt="../_images/uml-abstract.png"></p><p>➤ 接口:  </p><ul><li>类名有<code>Interface</code>标识</li></ul><p><img src="/images/uml-interface.png" alt="../_images/uml-interface.png"></p><p>➤ 包:</p><p><img src="/images/uml-package.png" alt="../_images/uml-package.png"></p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p><img src="/images/uml-relation.png" alt="../_images/uml-relation.png"></p><p>➤ TOC</p><ul><li>类-接口关系: 实现关系, implements, 实现类–▷接口 //虚线</li><li>类-类关系:<ul><li>泛化关系: is-a, extends, 派生类——▷基类 //实线</li><li>关联关系: A持有B的引用, A——&gt;B<ul><li>依赖关系: usa-a, A–&gt;B</li><li>聚合关系: has-a, A◇–&gt;B</li><li>组合关系: contains-a, A◆–&gt;B</li></ul></li></ul></li></ul><hr><p>➤ 实现关系:</p><ul><li>例如java中的<code>implements Interface</code></li></ul><p><img src="/images/uml-implements.png" alt="../_images/uml-implements.png"></p><p>➤ 泛化关系:  </p><ul><li>例如java中的<code>extends BaseClass</code></li></ul><p><img src="/images/uml-extends.png" alt="../_images/uml-extends.png"></p><p>➤ 关联关系:  </p><ul><li>A有B类型的成员变量</li></ul><p><img src="/images/uml-association.png" alt="../_images/uml-association.png"></p><p>➤ 依赖关系:  </p><ul><li>use-a</li><li>可以看作是一种弱关联关系, 比上面的关联关系弱, 包括几种情况:<ul><li>A中定义了(B类型的)局部变量</li><li>A调用了B的静态方法</li><li>A的方法形参是B类型</li><li>A的方法返回B类型</li></ul></li></ul><p><img src="/images/uml-use.png" alt="../_images/uml-use.png"></p><p>➤ 聚合关系:  </p><ul><li>has-a, 特殊的关联关系</li><li>A关联B对象, 但A和B关系不紧密, 例如B可以属于多个A1,A2…类型</li><li>例如员工和部门, 员工可以属于多个部门, 部门裁撤, 员工可以转移到其他部门</li></ul><p><img src="/images/uml-has.png" alt="../_images/uml-has.png"></p><p>➤ 组合关系:  </p><ul><li>contain-a, 特殊的关联关系</li><li>A关联对象B, A和B关系紧密, A和B同一个生命周期(一般由A管理B的生成和释放)</li><li>相比依赖/聚合关系, 组合关系表示更强的紧密程度</li></ul><p><img src="/images/uml-contain.png" alt="../_images/uml-contain.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/109655171" target="_blank" rel="noopener">30分钟学会UML类图 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 14.Coding-Pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java代码规范</title>
      <link href="/14.Coding-Pattern/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/14.Coding-Pattern/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>@ref 《Java开发手册（嵩山版）.pdf》</p></blockquote><h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><ul><li>【强制】POJO类中的任何布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列 化错误。</li><li>BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。 说明:equals()方法会比较值和精度(1.0 与 1.00 返回结果为 false)，而 compareTo()则会忽略精度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 14.Coding-Pattern </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 项目结构</title>
      <link href="/14.Coding-Pattern/Golang%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
      <url>/14.Coding-Pattern/Golang%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>@ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/346573562" target="_blank" rel="noopener">该如何组织 Go 项目结构？ - 知乎</a></li><li>[[Go工程化.pdf]]</li></ul><hr><p>一个常见的 Go 应用项目布局，通常有如下结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- my-go-project</span><br><span class="line">  |- cmd/</span><br><span class="line">  |- pkg/</span><br><span class="line">  |- internal/</span><br><span class="line">    |-biz/</span><br><span class="line">    |-data/</span><br><span class="line">    |-service</span><br><span class="line">  |- go.mod</span><br><span class="line">  |- go.sum</span><br><span class="line">  |- Makefile</span><br></pre></td></tr></table></figure><h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h2><p>cmd 包是项目的主干，是编译构建的入口，main 文件通常放置在此处。需要注意的是，cmd 中的代码应该尽量「保持简洁」，main 函数中可能仅仅是参数初始化、配置加载、服务启动、关闭操作。<br>一个典型的 cmd 包的目录结构如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- cmd</span><br><span class="line">   - demo1</span><br><span class="line">     - main.go</span><br><span class="line">   - demo2</span><br><span class="line">     - main.go</span><br></pre></td></tr></table></figure><h2 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a>pkg</h2><p>pkg 中存放的是可供项目内部/外部所使用的公共性代码，例如：用来连接第三方服务的 client 代码等。也有部分项目将该包命名为 lib</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- pkg</span><br><span class="line">   - cache</span><br><span class="line">     - redis</span><br><span class="line">     - memcache</span><br><span class="line">   - conf</span><br><span class="line">     - dsn</span><br><span class="line">     - paladin</span><br></pre></td></tr></table></figure><h2 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h2><p>internal 包主要用处在于提供一个项目级别的代码保护方式，存放在其中的代码仅供项目内部使用。具体使用的规则是：…/a/b/c/internal/d/e/f 仅仅可以被…/a/b/c下的目录导入，…/a/b/g则不允许。internal 是 Go 1.4 版本中引入的特性，更多信息可以参考<a href="https://go.dev/doc/go1.4#internalpackages" target="_blank" rel="noopener">https://go.dev/doc/go1.4#internalpackages</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- internal</span><br><span class="line">   - demo1</span><br><span class="line">      - biz</span><br><span class="line">      - data</span><br><span class="line">      - service</span><br></pre></td></tr></table></figure><blockquote><p>internal: 是为了避免有同业务下有人跨目录引用了内部的 biz、 data、service 等内部 struct。<br>• biz:业务逻辑的组装层，类似DDD的domain层，data类似DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。<br>• data:业务数据访问，包含cache、db等封装，实现了biz的repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义， 它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra 层。<br>• service:实现了api定义的服务层，类似DDD的application层，处理 DTO 到 biz 领域实体的转换(DTO -&gt; DO)，同时协同各类 biz 交互， 但是不应处理复杂逻辑。</p></blockquote><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h2><p>go.mod 与 go.sum 是采用 go modules 进行依赖管理所生成的配置文件。go modules 是 Go 1.11 版本中引入的版本管理功能，目前已经是 go 依赖管理的主流方式，所以此处不再讨论 vendor，dep 等依赖管理方式所生成的目录。</p><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>Makefile 文件通常存放项目的编译部署脚本。Go 的编译命令虽然简单，但总是手写命令还是效率低下，因此使用 Makefile 写编译部署脚本是工程实践中常见的方式。</p><h2 id="kit"><a href="#kit" class="headerlink" title="kit"></a>kit</h2><p>工具包项目通常也叫 kit 项目，包含公司的公共依赖库，在 <a href="https://github.com/ardanlabs/kit" target="_blank" rel="noopener">https://github.com/ardanlabs/kit</a> 中给出了一个 kit 项目布局示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.com/ardanlabs/kit</span><br><span class="line">├── CONTRIBUTORS</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── cfg/  </span><br><span class="line">├── examples/  </span><br><span class="line">├── log/</span><br><span class="line">├── pool/</span><br><span class="line">├── tcp/</span><br><span class="line">├── timezone/</span><br><span class="line">├── udp/</span><br><span class="line">└── web/</span><br></pre></td></tr></table></figure><p>kit 项目有以下几个特点：</p><ul><li>（1）建议公司只有「一个」 kit 项目，kit 包含的是供公司多个项目使用的基础库，提供非常具体但是基本的功能。</li><li>（2）建议 kit 项目不要依赖第三方库版本，即 kit 中不要包含 vendor, go modules 等版本管理信息。kit 本质是基础工具包，如果内部含有 vendor 等版本管理，那么就要随着第三方库的更新而不断更新，导致上层依赖 kit 的应用也得随之更新，变更代价很大。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 14.Coding-Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java测试框架 - JUnit</title>
      <link href="/13.JavaEE-Framework/Tools-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
      <url>/13.JavaEE-Framework/Tools-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h1><h2 id="How-to"><a href="#How-to" class="headerlink" title="How to"></a>How to</h2><ul><li><p>maven 顶层POM文件增加JUnit依赖,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">         &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"> &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>IDEA, 右键项目, maven -&gt; reimport</p></li><li>在src下, 创建一个test目录, 与main同级</li><li>右键这个test目录, “Mark Directory as”  -&gt; “Test Resources Root”</li><li>选中要测试的类, cmd+shift+T, 创建Test类 （Junit3是继承TestCase, Junit4是基于<code>@Test</code>注解）</li><li>Junit提供的断言:<ul><li>assertEquals</li><li>assertNull</li></ul></li></ul><h2 id="用Junit4测试Spring项目"><a href="#用Junit4测试Spring项目" class="headerlink" title="用Junit4测试Spring项目"></a>用Junit4测试Spring项目</h2><p>同样创建测试类, 测试类要加上如下注解:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations=<span class="string">"/META-INF/applicationContext.xml"</span>)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ref: <a href="http://linbinghe.com/2017/3698e116.html" target="_blank" rel="noopener">关于Java单元测试，你需要知道的一切 | Lam’s Blog</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUnit </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java构建工具 - Maven and Gradle</title>
      <link href="/13.JavaEE-Framework/Tools-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
      <url>/13.JavaEE-Framework/Tools-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="setting-xml"><a href="#setting-xml" class="headerlink" title="setting.xml"></a>setting.xml</h2><p>@ref <a href="https://maven.apache.org/settings.html" target="_blank" rel="noopener">https://maven.apache.org/settings.html</a><br>默认配置文件在<code>~/.m2/settings.xml</code>, <code>命令mvn -X</code>可以查看正在使用哪个Setting.xml, 以及xml文件中的配置参数.<br>国内的mirrors和repositories基本都不可用, 所以直接使用central repositories(<a href="http://repo1.maven.org/maven2)并且设置proxy" target="_blank" rel="noopener">http://repo1.maven.org/maven2)并且设置proxy</a>.</p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>@ref <a href="https://maven.apache.org/pom.html" target="_blank" rel="noopener">https://maven.apache.org/pom.html</a></p><h3 id="profiles"><a href="#profiles" class="headerlink" title="profiles"></a>profiles</h3><h2 id="Create-ypur-maven-projects"><a href="#Create-ypur-maven-projects" class="headerlink" title="Create ypur maven projects"></a>Create ypur maven projects</h2><ul><li>命令: <code>mvn archetype:generate -DgroupId=org.kshan.toolbox -DartifactId=XXX -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</code>,</li><li>如果创建web项目, 将最后一项参数修改为: <code>-DarchetypeArtifactId=maven-archetype-webapp</code></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li><code>mvn lifecycle</code>, 比如<code>mvn compile</code>, <code>mvn package</code>, <code>mvn install</code>, 如果插件的目标绑定到该生命周期, 则会执行这个插件的目标(goal).</li><li><code>mvn goal</code>, 目标一般是由插件定义的, 例如<code>mvn archetype:generate</code> 就表示调用maven-archetype-plugin插件的generate目标，这种带冒号的调用方式与生命周期无关<ul><li>运行maven工程里的某个main方法: <code>mvn exec:java -Dexec.mainClass=&quot;org.xx.className</code>, 这里的goal是 maven-exec-plugin插件定义的.</li></ul></li></ol><h3 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h3><ul><li><code>mvn compile</code> : compile the source code of the project</li><li><code>mvn test</code> : test the compiled source code using a suitable unit testing framework</li><li><code>mvn package</code> : take the compiled code and package it in its distributable format, such as a JAR.<ul><li><code>-Dmaven.test.skip=ture</code> :</li><li><code>-Dmaven.compile.fork=true</code> : Runs the compiler in a separate process</li><li><code>-o</code> : Work offline</li></ul></li><li><code>mvn install</code> : install the package into the local repository, for use as a dependency in other projects locally</li><li><code>mvn deploy</code>: copies the final package to the remote repository</li><li><code>mvn clean</code> : cleans up artifacts created by prior builds</li></ul><h4 id="snapshot快照库和release发布库的区别"><a href="#snapshot快照库和release发布库的区别" class="headerlink" title="snapshot快照库和release发布库的区别"></a>snapshot快照库和release发布库的区别</h4><p>maven中的仓库分为两种，snapshot快照仓库和release发布仓库。<br>snapshot快照仓库用于保存开发过程中的不稳定版本，release正式仓库则是用来保存稳定的发行版本。<br>定义一个组件/模块为快照版本，只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可(注意这里必须是大写)，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.abc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myLib1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插件的Goal"><a href="#插件的Goal" class="headerlink" title="插件的Goal"></a>插件的Goal</h3><ul><li><code>mvn eclipse:eclipse</code> : 生成eclipse项目文件, 用于导入eclipse</li><li><code>mvn idea:idea</code> : 同上</li><li>将没有在maven官方repository中的jar包加入到本地的maven repository中: <code>mvn install:install-file  -Dfile=path-to-your-artifact-jar -DgroupId=your.groupId -DartifactId=your-artifactId  -Dversion=your-version -Dpackaging=jar</code></li><li>仅下载依赖: <code>mvn dependency:resolve</code></li><li>下载source和doc : <code>mvn dependency:sources -DdownloadSources=true -DdownloadJavadocs=true</code></li><li>运行指定Jar: <code>mvn exec:java -Dexec.mainClass=&quot;com.vineetmanohar.module.Main&quot; -Dexec.args=&quot;arg0 arg1 arg2&quot;</code></li></ul><h3 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="maven-release-plugin"><a href="#maven-release-plugin" class="headerlink" title="maven-release-plugin"></a>maven-release-plugin</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn release:prepare -Darguments=&quot;-DskipTests&quot;</span><br><span class="line">mvn release:perform</span><br></pre></td></tr></table></figure><h4 id="maven-resources-plugin"><a href="#maven-resources-plugin" class="headerlink" title="maven-resources-plugin"></a>maven-resources-plugin</h4><p>为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。此外，资源文件过滤也是Maven的一大特性，你可以在资源文件中使用${propertyName}形式的Maven属性，然后配置maven-resources-plugin开启对资源文件的过滤，之后就可以针对不同环境通过命令行或者Profile传入属性的值，以实现更为灵活的构建。</p><h4 id="Jetty-Plugin"><a href="#Jetty-Plugin" class="headerlink" title="Jetty Plugin"></a>Jetty Plugin</h4><ul><li>mvn jetty:run</li><li>mvn -Djetty.port=8888 jetty:run</li></ul><h4 id="Help-Plugin"><a href="#Help-Plugin" class="headerlink" title="Help Plugin"></a>Help Plugin</h4><ul><li>获取插件帮助: <code>mvn help:describe -Dplugin=eclipse</code></li><li>获取goal帮助: <code>mvn help:describe -Dplugin=archetype</code></li><li>mvn help:active-profiles</li><li>mvn help:effective-settings</li><li>mvn help:system</li></ul><h2 id="依赖-dependencies"><a href="#依赖-dependencies" class="headerlink" title="依赖(dependencies)"></a>依赖(dependencies)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.apache.thrift.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="查看依赖"><a href="#查看依赖" class="headerlink" title="查看依赖"></a>查看依赖</h3><p>查看各个子module和引入Jar的依赖关系:</p><ul><li>mvn dependency:list   可以看到当前项目已解析的依赖</li><li>mvn dependency:tree  看到依赖树</li><li>mvn dependency:analyse 查看依赖的工具</li></ul><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>scope有5个缺省值:</p><ul><li>compile: 缺省值, 表示该maven项目在 <em>编译</em> / <em>测试</em> / <em>运行</em> 阶段都需要依赖这个jar包,<ul><li>compile方式依赖的库具有传递性: 如果项目依赖了A库, 同时A依赖B(scope=compile) , 那么该项目也会依赖B;</li><li>compile方式依赖的库会被打包进项目Jar包的lib目录下;</li></ul></li><li>provided: 表示该maven项目在 <em>编译</em> / <em>测试</em> 阶段都需要依赖这个jar包, 但在运行阶段是可以由容器(Container)来提供的, 而不必由该项目提供此Jar包;<br>provided相当于compile, 是在打包阶段做了exclude的动作;<ul><li>例如一个Web应用, 在编译时可能需要 Servlet API来编译一个Servlet, 但是你不会想要在打包好的WAR中包含这个Servlet API, 这个Servlet API JAR 应该由应用服务器或者Servlet容器提供;</li><li>provided方式依赖的库并不是传递性的;</li><li>provided方式依赖的库也不会被打包进项目Jar包的lib目录下;</li></ul></li><li>runtime: 在编译时不需要依赖此Jar包, 但在 <em>运行</em> / <em>测试</em> 的时候需要.<br>例如JDBC驱动可以使用runtime, 因为只有在真正运行的时候才会调用到JDBC驱动的代码;</li><li>test: 表示该dependency的Jar包只在单元测试时会依赖到, 不会打包进项目, 不会在运行期被依赖到, 典型的比如junit;</li><li>system: 类似provided, 不会被打包进项目, 在编译时maven不会从默认的repository寻找Jar包, 而是从本地目录加载依赖的Jar包.<br>使用system需要通过<code>&lt;systemPath&gt;</code>指定该依赖包在本地的路径;</li><li>import: Maven 2.0.9 之后新增;</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li><a href="http://stackoverflow.com/questions/16421454/why-maven-is-downloading-metadata-every-time" target="_blank" rel="noopener">Why maven is downloading metadata every time?</a></li><li><a href="http://stackoverflow.com/questions/5780758/maven-always-download-sources-and-javadocs" target="_blank" rel="noopener">Maven – Always download sources and javadocs</a></li><li><a href="http://stackoverflow.com/questions/25639336/whats-the-difference-between-dskiptests-and-dmaven-test-skip-true" target="_blank" rel="noopener">what’s the difference between -DskipTests and -Dmaven.test.skip=true</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
            <tag> Gradle </tag>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/13.JavaEE-Framework/JavaEE.Tomcat/"/>
      <url>/13.JavaEE-Framework/JavaEE.Tomcat/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png" alt="Tomcat"></p><h1 id="配置文件-server-xml"><a href="#配置文件-server-xml" class="headerlink" title="配置文件 server.xml"></a>配置文件 server.xml</h1><p>一个配置文件实例:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JasperListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="server-xml配置元素分类"><a href="#server-xml配置元素分类" class="headerlink" title="server.xml配置元素分类"></a>server.xml配置元素分类</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>server.xml的整体结构如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 现在常常使用自动部署，不推荐配Context --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Context表示一个War应用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>该结构中只给出了Tomcat的核心组件，除了核心组件外，Tomcat还有一些其他组件，下面介绍一下组件的分类。</p><h3 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h3><p>server.xml文件中的元素可以分为以下4类：</p><ul><li>（1）顶层元素：<code>&lt;Server&gt;</code>和<code>&lt;Service&gt;</code></li></ul><p><code>&lt;Server&gt;</code>元素是整个配置文件的根元素，<code>&lt;Service&gt;</code>元素则代表一个Engine元素以及一组与之相连的Connector元素。</p><ul><li>（2）连接器：<code>&lt;Connector&gt;</code></li></ul><p><code>&lt;Connector&gt;</code>代表了外部客户端发送请求到特定Service的接口；同时也是外部客户端从特定Service接收响应的接口。</p><ul><li>（3）容器：<code>&lt;Engine&gt;</code> <code>&lt;Host&gt;</code> <code>&lt;Context&gt;</code></li></ul><p>容器的功能是处理Connector接收进来的请求，并产生相应的响应。Engine、Host和Context都是容器，都实现了Container接口，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。</p><ul><li>Engine 表示一个Servlet引擎，它可以包含一个或多个子容器，比如Host或者Context容器；</li><li>Host 表示一台虚拟的主机，它可以包含一系列Context容器；</li><li>Context 表示一个唯一的ServletContext，一个 Context 对应一个 Web 工程，它可以包含一个 或多个Wrapper容器；</li><li>Wrapper 表示一个独立的Servlet定义，即Wrapper本质就是对Servlet进行了一层包装。</li></ul><p>一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。</p><ul><li>（4）内嵌组件：</li></ul><p>可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host和Context是最重要的最核心的Tomcat组件，其他组件都可以归为内嵌组件。</p><p>下面将详细介绍Tomcat中各个核心组件的作用，以及相互之间的关系。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>本部分将分别介绍各个核心组件的作用、特点以及配置方式等。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server元素在最顶层，代表整个Tomcat容器，因此它必须是server.xml中唯一一个最外层的元素。一个Server元素中可以有一个或多个Service元素。</p><p>在第一部分的例子中，在最外层有一个<code>&lt;Server&gt;</code>元素，shutdown属性表示关闭Server的指令；port属性表示Server接收shutdown指令的端口号，设为-1可以禁掉该端口。</p><p>Server的主要任务，就是提供一个接口让客户端能够访问到这个Service集合，同时维护它所包含的所有的Service的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的Service。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service的作用，是在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；其中Connector的作用是从客户端接收请求，Engine的作用是处理接收进来的请求。</p><p>在第一部分的例子中，Server中包含一个名称为“Catalina”的Service。实际上，Tomcat可以提供多个Service，不同的Service监听不同的端口，后文会有介绍。</p><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector的主要功能，是接收连接请求，创建Request和Response对象用于和请求端交换数据；然后分配线程让Engine来处理这个请求，并把产生的Request和Response对象传给Engine。</p><p>通过配置Connector，可以控制请求Service的协议及端口号。在第一部分的例子中，Service包含两个Connector：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>（1）通过配置第1个Connector，客户端可以通过8080端口号使用http协议访问Tomcat。其中，protocol属性规定了请求的协议，port规定了请求的端口号，redirectPort表示当强制要求https而请求是http时，重定向至端口号为8443的Connector，connectionTimeout表示连接的超时时间。</li><li>（2）通过配置第2个Connector，客户端可以通过8009端口号使用AJP协议访问Tomcat。AJP协议负责和其他的HTTP服务器(如Apache)建立连接；在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。之所以使用Tomcat和其他服务器集成，是因为Tomcat可以用作Servlet/JSP容器，但是对静态资源的处理速度较慢，不如Apache和IIS等HTTP服务器；因此常常将Tomcat与Apache等集成，前者作Servlet容器，后者处理静态资源，而AJP协议便负责Tomcat和Apache的连接。Tomcat与Apache等集成的原理如下图(图片来源)：</li></ul><p><img src="/images/javaee/tomcat_ajp_apache.png" alt="tomcat_ajp_apache"></p><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine组件在Service组件中有且只有一个；Engine是Service组件中的请求处理组件。Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。</p><p>在第一部分的例子中，Engine的配置语句如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，name属性用于日志和错误信息，在整个Server中应该唯一。defaultHost属性指定了默认的host名称，当发往本机的请求指定的host名称不存在时，一律使用defaultHost指定的host进行处理；因此，defaultHost的值，必须与Engine中的一个Host组件的name属性值匹配。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><h4 id="Engine与Host"><a href="#Engine与Host" class="headerlink" title="Engine与Host"></a>Engine与Host</h4><p>Host是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。Host组件至少有一个，且其中一个的name必须与Engine组件的defaultHost属性相匹配。</p><h4 id="Host的作用"><a href="#Host的作用" class="headerlink" title="Host的作用"></a>Host的作用</h4><p>Host虚拟主机的作用，是运行多个Web应用（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。</p><p>Host组件代表的虚拟主机，对应了服务器中一个网络名实体(如”<a href="http://www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。" target="_blank" rel="noopener">www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。</a></p><h4 id="Host的配置"><a href="#Host的配置" class="headerlink" title="Host的配置"></a>Host的配置</h4><p>在第一部分的例子中，Host的配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面对其中配置的属性进行说明：</p><p>name属性指定虚拟主机的主机名，一个Engine中有且仅有一个Host组件的name属性与Engine组件的defaultHost属性相匹配；一般情况下，主机名需要是在DNS服务器中注册的网络名，但是Engine指定的defaultHost不需要，原因在前面已经说明。</p><p>unpackWARs指定了是否将代表Web应用的WAR文件解压；如果为true，通过解压后的文件结构运行该Web应用，如果为false，直接使用WAR文件运行Web应用。</p><p>Host的autoDeploy和appBase属性，与Host内Web应用的自动部署有关；此外，本例中没有出现的xmlBase和deployOnStartup属性，也与Web应用的自动部署有关；将在下一节(Context)中介绍。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="Context的作用"><a href="#Context的作用" class="headerlink" title="Context的作用"></a>Context的作用</h4><p>Context元素代表在特定虚拟主机上运行的一个Web应用。每个Web应用基于WAR文件，或WAR文件解压后对应的目录（这里称为应用目录）。</p><p>Context是Host的子容器，每个Host中可以定义任意多的Context元素。</p><p>在第一部分的例子中，可以看到server.xml配置文件中并没有出现Context元素的配置。这是因为，Tomcat开启了自动部署，Web应用没有在server.xml中配置静态部署，而是由Tomcat通过特定的规则自动部署。下面介绍一下Tomcat自动部署Web应用的机制。</p><h4 id="Web应用自动部署"><a href="#Web应用自动部署" class="headerlink" title="Web应用自动部署"></a>Web应用自动部署</h4><p>如何开启自动部署War:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外Context组件还有一个reloadable属性, <code>&lt;Context docBase=&quot;xxx&quot; path=&quot;/xxx&quot; reloadable=&quot;true&quot;/&gt;</code><br>替换WEB-INF/lib目录中的jar文件或WEB-INF/classes目录中的class文件时，reloadable=”true”会让修改生效（但代价不小），该选项适合调试。</p><p>autoDeploy和reloadable的区别是, 前者是Host的属性后者是Context的属性,<br>前者监控的是webapps目录下War包的改动, 后者监控的是webapps下面文件夹内jar或者class文件的变化;</p><p>一般线上环境会关闭这两个参数, 开发阶段可以通过这两个参数无需重启tomcat预览改变;</p><h5 id="自动部署的实现"><a href="#自动部署的实现" class="headerlink" title="自动部署的实现"></a>自动部署的实现</h5><blockquote><p>Tomcat的Engine会启动一个线程，该线程每10s会发送一个发送一个事件，监听到该事件的部署配置类, 会自动去扫描webapp文件夹下的war包，将其加载成一个Context，即启动一个web服务。</p></blockquote><p>Tomcat的<code>StandardEngine</code>会在<code>starInternal()</code>启动一个线程，该线程运行的是<code>ContainerBackgroundProcessor.run()</code>方法,<br>这个run每隔10s唤醒调用一次<code>processChildren()</code>, 继续跟踪该方法，会看到调用其子容器Engine、Host、Context、Wrapper各容器组件及与它们相关的其它组件的backgroundProcess方法。<br><code>backgroundProcess()</code>发送一个事件<code>Lifecycle.PERIODIC_EVENT</code>,<br>StandardHost通server.xml配置了HostConfig监听器，对该事件的响应方法是<code>HostConfig.lifecycleEvent()</code>,<br><code>lifecycleEvent()</code>会检查<code>autoDeploy=&quot;true&quot;</code>的配置, 如果开启了, 则调用<code>deployApps()</code>扫描webapp文件夹下的war包，将其加载成一个Context，即启动一个web服务。</p><h2 id="核心组件的关联"><a href="#核心组件的关联" class="headerlink" title="核心组件的关联"></a>核心组件的关联</h2><h3 id="整体关系"><a href="#整体关系" class="headerlink" title="整体关系"></a>整体关系</h3><p>核心组件之间的整体关系，在上一部分有所介绍，这里总结一下：</p><p>Server元素在最顶层，代表整个Tomcat容器；一个Server元素中可以有一个或多个Service元素。<br>Service在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。<strong>一个Service可以包含多个Connector，但是只能包含一个Engine；</strong>  Connector接收请求，Engine处理请求。<br>Engine、Host和Context都是容器，且 Engine包含Host，Host包含Context。每个Host组件代表Engine中的一个虚拟主机；每个Context组件代表在特定Host上运行的一个Web应用。</p><p><img src="/images/javaee/tomcat_architecture.png" alt=""></p><h3 id="如何确定请求由谁处理？"><a href="#如何确定请求由谁处理？" class="headerlink" title="如何确定请求由谁处理？"></a>如何确定请求由谁处理？</h3><p>当请求被发送到Tomcat所在的主机时，如何确定最终哪个Web应用来处理该请求呢？</p><ul><li>（1）根据协议和端口号选定Service和Engine</li></ul><p>Service中的Connector组件可以接收特定端口的请求，当请求进来时，Tomcat便可以根据协议和端口号选定处理请求的Service；Service一旦选定，Engine也就确定。</p><ul><li>（2）根据域名或IP地址选定Host</li></ul><p>Service确定后，Tomcat在Service中寻找名称与域名/IP地址匹配的Host处理该请求。如果没有找到，则使用Engine中指定的defaultHost来处理该请求。</p><ul><li>（3）根据URI选定Context/Web应用</li></ul><p>这一点在Context一节有详细的说明：Tomcat根据应用的 path属性与URI的匹配程度来选择Web应用处理相应请求，这里不再赘述。</p><ul><li>（4）举例</li></ul><p>以请求<a href="http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。" target="_blank" rel="noopener">http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。</a></p><h3 id="如何部署多个war包项目"><a href="#如何部署多个war包项目" class="headerlink" title="如何部署多个war包项目"></a>如何部署多个war包项目</h3><p>@todo</p><h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。<br>监听器可以在Server、Engine、Host或Context中，本例中的监听器都是在Server中。实际上，本例中定义的6个监听器，都只能存在于Server组件中。监听器不允许内嵌其他组件。<br>监听器需要配置的最重要的属性是className，该属性规定了监听器的具体实现类，该类必须实现了<code>org.apache.catalina.LifecycleListener</code>接口。</p><h3 id="GlobalNamingResources与Realm"><a href="#GlobalNamingResources与Realm" class="headerlink" title="GlobalNamingResources与Realm"></a>GlobalNamingResources与Realm</h3><p>@todo</p><h3 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h3><p>在第一部分的例子中，Host元素内定义了Valve组件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>单词Valve的意思是“阀门”，在Tomcat中代表了请求处理流水线上的一个组件；Valve可以与Tomcat的容器(Engine、Host或Context)关联。<br>不同的Valve有不同的特性，下面介绍一下本例中出现的AccessLogValve。<br>AccessLogValve的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve放在Host下，便可以记录该Host处理的所有请求。AccessLogValve记录的日志就是访问日志，每天的请求会写到一个日志文件里。AccessLogValve可以与Engine、Host或Context关联；在本例中，只有一个Engine，Engine下只有一个Host，Host下只有一个Context，因此AccessLogValve放在三个容器下的作用其实是类似的。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="bin-catalina-sh"><a href="#bin-catalina-sh" class="headerlink" title="bin/catalina.sh"></a>bin/catalina.sh</h2><p>修改Xms, Xmx, PermSize</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS="-Xms8g -Xmx8g -Xmn2g -server -DServer=mblog -XX:PermSize=128m -XX:MaxPermSize=128m -XX:MaxTenuringThreshold=4 -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=8 -XX:CMSInitiatingOccupancyFraction=70 -XX:+ExplicitGCInvokesConcurrent -XX:+PrintFlagsFinal -XX:+PrintCommandLineFlags -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -Xloggc:../gclogs/gc.log.$nowday"</span><br></pre></td></tr></table></figure><h2 id="conf-server-xml"><a href="#conf-server-xml" class="headerlink" title="conf/server.xml"></a>conf/server.xml</h2><p>Tomcat 采用 Request Per Thread 策略, 每个用户请求由一个线程处理, <code>&lt;Executor&gt;</code> 部分定义了该线程池, 该线程池被 多个<code>&lt;Connector&gt;</code> 共享, server.xml里的优化主要在<code>&lt;Connector&gt;</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.StandardThreadExecutor"</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxThreads</span>=<span class="string">"300"</span> <span class="attr">minSpareThreads</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定使用上面的线程池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">"8080"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"8000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptCount</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxThreads</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptorThreadCount</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">"utf-8"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"443"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">"on"</span> <span class="attr">compressionMinSize</span>=<span class="string">"1024"</span> <span class="attr">compressableMimeType</span>=<span class="string">"text/html,text/xml,text/javascript,text/css,text/plain,application/json,application/xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Executor参数<ul><li><strong>maxThreads</strong>:  线程池最大线程数</li><li><strong>minSpareThreads</strong>: 线程池最小线程数(线程池初始化时), 默认25</li></ul></li><li><p>Connector 参数:</p><ul><li><strong>executor</strong>: 指明使用哪一个 Executor, 如果指定了,那么 Connector中所有关于线程的设定会被忽略, 如果没有指定 一个线程池, Connector将会创建一个私有的线程池.</li><li><strong>maxThreads</strong>: 用于处理客户端请求的最大线程数, 设置为多少视CPU处理能力而定, 一般单个应用不应该超过300, 如果超过300应考虑多个Tomcat组成集群方式</li><li>enableLookups: 是否开启域名反查，一般设置为false来提高处理能力，它的取值还有true，一般很少使用。若设为true, 则支持域名解析，可把 ip 地址解析为主机名</li><li>connectionTimeout: 网络连接超时，单位：毫秒。设置为 0 表示永不超时</li><li><strong>acceptorThreadCount</strong>: 默认为1，表示用于accept新socket连接的线程个数。建议设置为 cpu核数</li><li><strong>acceptCount</strong>: 当全部线程都在忙(意味着客户端并发数超过 maxThreads个线程), 新的请求会放入accept队列, 该值是队列的size, 默认100 (如果要增加Tomcat并发处理能力, 需要同时增加 acceptCount 和 maxThreads)</li><li><strong>maxConnections</strong>: Tomcat能 accept并 process的最大连接数, 超过这个数 tomcat仍然 能accept新的连接, 但不会process</li><li>compressionMinSize: 大于这个数值讲开启压缩, 默认为2K</li><li>compressableMimeType: 压缩哪些类型</li><li><p><strong>protocol</strong>：协议类型，可选类型有四种，分别为 BIO（阻塞型IO），NIO，NIO2和APR。</p><ul><li>BIO：BIO(Blocking I/O)，顾名思义，即阻塞式I/O操作，表示Tomcat使用的是传统的Java I/O操作(即java.io包及其子包)。Tomcat在默认情况下，是以bio模式运行的。遗憾的是，就一般而言，bio模式是三种运行模式中性能最低的一种。BIO配置采用默认即可。</li><li>NIO：NIO(New I/O)，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，因此nio也被看成是non-blocking I/O的缩写。它拥有比传统I/O操作(bio)更好的并发运行性能。要让Tomcat以nio模式来运行也比较简单，我们只需要protocol类型修改为：<code>protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</code><br>对于互联网应用，我们应该在NIO、NIO2之间做选择，因为它能够有效的提升性能（主要是并发能力），其中NIO2即为AIO，需要JDK 1.7+、Linux 2.6+才能支持。<ul><li>NIO：JDK 1.6+，tomcat 6.x+</li><li>NIO2：JDK 1.7+，tomcat 7.x+</li></ul></li><li><p>APR: 通过Native实现的I/O库, Tomcat通过JNI调用;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Tomcat 支持的几种protocol:</span><br><span class="line">//NIO</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">//NIO2</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;</span><br><span class="line">//ARP</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>总结:<br>增加 acceptCount, maxConnections, maxThreads,<br>Tomcat 能 accept 的连接数量 = maxConnections + acceptCount;<br>Tomcat 能 accept 并process的连接数量 = maxConnections;</p><p>@ref: <a href="https://www.zhihu.com/question/53498767" target="_blank" rel="noopener">tomcat 源码为啥不采用netty 处理并发？ - 知乎</a></p><h3 id="NIO线程模型"><a href="#NIO线程模型" class="headerlink" title="NIO线程模型"></a>NIO线程模型</h3><p>Tomcat使用 Connector 完成整个 HTTP Request的处理流程, 包括 accept socket → NIO Selector处理 socket读事件 → 把可读Socket分发给 Work线程 → 从socket读取数据并解析为Http请求 → Http请求交给CoyoteAdaper处理, CoyoteAdaper 通过Mapper找到对应的Servlet.</p><p><img src="/images/javaee/tomcat-nio-connector-process.png" alt="Tomcat-NIO-Connector-Process"></p><p>在NIO实现的Connector中，处理请求的主要实体是NIoEndpoint对象。NIoEndpoint中除了包含Acceptor和Worker外，还是用了Poller，处理流程如下图所示:</p><p><img src="/images/javaee/tomcat-nioendpoint-poler-worker.png" alt="Tomcat-NioEndpoint-Poler-Worker"></p><ul><li>Acceptor accept 客户端请求, 这里虽然是基于NIO的connector，但是在接收socket方面还是传统的<code>serverSocket.accept()</code>方式, Acceptor 获取到 客户端请求的socket, 封装进 tomcat的实现类org.apache.tomcat.util.net.NioChannel对象中, 然后将NioChannel对象封装在一个PollerEvent对象中，并将 PollerEvent对象压入events queue</li><li>Poller 读取 events queue 取出PollerEvent,  Poller线程中维护了一个Selector对象, Poller 从Event中取出 客户端请求的socketChannel, 把这个channel的READ事件注册到 Selector上.</li><li>Poller 通过 <code>Selector.select()</code> 遍历可读的 socketChannel, 从Worker线程池中拿到可用的Worker线程,将socket传递给Worker处理</li><li>Worker 线程将socket封装在SocketProcessor对象中。然后从Http11ConnectionHandler中取出Http11NioProcessor对象，从Http11NioProcessor中调用CoyoteAdapter的逻辑</li></ul><p>本节参考:<br><a href="https://my.oschina.net/weiweiblog/blog/1830173" target="_blank" rel="noopener">https://my.oschina.net/weiweiblog/blog/1830173</a><br><a href="https://www.jianshu.com/p/f91f99610b9e" target="_blank" rel="noopener">https://www.jianshu.com/p/f91f99610b9e</a></p><h3 id="附-Connector和线程池参数解析"><a href="#附-Connector和线程池参数解析" class="headerlink" title="附: Connector和线程池参数解析"></a>附: Connector和线程池参数解析</h3><ol><li><code>&lt;Executor&gt;</code> 部分, 参数说明: <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html</a><ul><li><strong>namePrefix</strong>: The name prefix for each thread created by the executor</li><li><strong>maxThreads</strong>: The max number of active threads in this pool, default is 200</li><li><strong>minSpareThreads</strong>: The minimum number of threads (idle and active) always kept alive, default is 25</li><li><strong>maxIdleTime</strong>: The number of milliseconds before an idle thread shutsdown, unless the number of active threads are less or equal to minSpareThreads. Default value is 60000(1 minute)</li><li><strong>maxQueueSize</strong>: The maximum number of runnable tasks that can queue up awaiting execution before we reject them. Default value is Integer.MAX_VALUE</li></ul></li><li><code>&lt;Connector&gt;</code> 部分, <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</a><ul><li><strong>executor</strong>: A reference to the name in an Executor element. If this attribute is set, and the named executor exists, the connector will use the executor, and all the other thread attributes will be ignored. Note that if a shared executor is not specified for a connector then the connector will use a private, internal executor to provide the thread pool.</li><li><strong>acceptCount</strong>: The maximum queue length for incoming connection requests when all possible request processing threads are in use. Any requests received when the queue is full will be refused. The default value is 100.</li><li><strong>connectionTimeout</strong>: The number of milliseconds this Connector will wait, after accepting a connection, for the request URI line to be presented. Use a value of -1 to indicate no (i.e. infinite) timeout. The default value is 60000 (i.e. 60 seconds) but note that the standard server.xml that ships with Tomcat sets this to 20000 (i.e. 20 seconds). Unless disableUploadTimeout is set to false, this timeout will also be used when reading the request body (if any).</li><li><strong>maxThreads</strong>: The maximum number of request processing threads to be created by this Connector, which therefore determines the maximum number of simultaneous requests that can be handled. If not specified, this attribute is set to 200. If an executor is associated with this connector, this attribute is ignored as the connector will execute tasks using the executor rather than an internal thread pool. Note that if an executor is configured any value set for this attribute will be recorded correctly but it will be reported (e.g. via JMX) as -1 to make clear that it is not used.</li><li><strong>acceptorThreadCount</strong>: The number of threads to be used to accept connections. Increase this value on a multi CPU machine, although you would never really need more than 2. Also, with a lot of non keep alive connections, you might want to increase this value as well. Default value is 1.</li><li><strong>maxConnections</strong>: The maximum number of connections that the server will accept and process at any given time. When this number has been reached, the server will accept, but not process, one further connection. This additional connection be blocked until the number of connections being processed falls below maxConnections at which point the server will start accepting and processing new connections again. Note that once the limit has been reached, the operating system may still accept connections based on the acceptCount setting. The default value varies by connector type. For NIO and NIO2 the default is 10000. For APR/native, the default is 8192.<br>Note that for APR/native on Windows, the configured value will be reduced to the highest multiple of 1024 that is less than or equal to maxConnections. This is done for performance reasons.</li></ul></li></ol><h2 id="APR支持"><a href="#APR支持" class="headerlink" title="APR支持"></a>APR支持</h2><p>APR(Apache Portable Runtime)可移植运行库，它是Apache HTTP Server 2.x的核心。APR有很多用途，包括访问高级IO功能(例如sendfile,<br>epoll和OpenSSL)，OS级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT管道和UNIX sockets)。<br>这些功能可以使Tomcat作为一个通常的前台WEB服务器，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器。</p><p>可以简单地理解为: Tomcat将以JNI的形式调用 APR库中的Native Method处理文件读取或网络传输操作，提升Tomcat对静态文件的处理性能</p><p>安装步骤:</p><ul><li>下载APR, 编译<code>make &amp;&amp; make install</code></li><li>安装Tomcat Native到Tomcat的安装目录下</li><li>修改conf/server.xml, 修改<code>&lt;Connector&gt;</code>的protocol</li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>参考: <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html" target="_blank" rel="noopener">日志机制 - Tomcat 8 权威指南 - 极客学院Wiki</a></p><p>在 Apache Tomcat 上运行的 Web 应用可以使用以下日志：</p><ul><li>任何自选的日志框架，如<code>log4j</code>；</li><li>使用JDK提供的日志<code>java.util.logging</code>；</li><li>Java Servlets 规范所提供的日志 API，如<code>javax.servlet.ServletContext.log(...)</code>；</li></ul><blockquote><p>当tomcat启动时会为每个app分配了一个WebappClassLoader ，这样来避免多个app会加载相同jar包的问题，<br>不同Web应用程序下使用的Servlet日志（或者日志框架提供的日志，如log4j等）是相互独立的（这与Tomcat的class loader有关，参考<a href="http://tomcat.apache.org/tomcat-6.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Class Loader HOW-TO</a> ）。<br>如果Web应用程序使用的是java.util.logging日志，那么它们并不相互独立，这是因为java.util.logging是由JAVA系统中的Bootstrap ClassLoader来加载的，因此它在各Web应用程序之间是共享的。</p></blockquote><h2 id="JULI-vs-JUL"><a href="#JULI-vs-JUL" class="headerlink" title="JULI vs JUL"></a>JULI vs JUL</h2><p>JUL API（<code>java.util.logging</code>）的默认实现功能有限，因此tomcat的默认配置中，新增了另一种日志实现 JULI API（<code>org.apache.juli</code>），</p><blockquote><p>可以在Tomcat的 logging.properties 里看到定义了两种日志:<br>java.util.logging 的 <code>java.util.logging.ConsoleHandler</code> ;<br>JULI的 <code>org.apache.juli.FileHandler</code> ;</p></blockquote><p><strong>JULI</strong> 同样支持标准JDK java.util.logging的配置机制（都默认使用logging.properties作为配置文件），不同的是JULI的每一个类加载属性文件都可以被设置，并可以在其中定义处理器，这样就给了开发者更大的自由度。<br>JULI 的日志配置分为 全局配置 和 WebApp项目配置。<br>全局配置位于tomcat的配置目录<code>${catalina.base}/conf/logging.properties</code>文件,<br>如果该文件未配置或不可读，那么tomcat将会使用JRE中的默认日志配置，可以在<code>${java.home}/lib/logging.properties</code>查看配置文件的内容；<br>项目配置则是针对不同的项目，配置文件位于<code>WEB-INFO/classes/logging.properties</code>.</p><p>JUL 和 JULI使用相同的日志级别：SEVERE (最高级别) &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST (所有内容,最低级别)</p><p>JULI 所使用的配置与 java.util.logging 所支持的配置基本相同，只不过使用了一些扩展，以便更灵活地配置 logger 和 handler。主要的差别在于：</p><ul><li>JULI 的 handler 名称前可以加上前缀，所以同一类可以实例化出多个 handler。前缀是一个以数字开头的字符串，并以 . 结尾。比如 22foobar. 就是个有效的前缀。</li><li>JULI 的 handler 支持额外的属性, 比如<code>bufferSize</code></li></ul><h2 id="Tomcat日志配置解析"><a href="#Tomcat日志配置解析" class="headerlink" title="Tomcat日志配置解析"></a>Tomcat日志配置解析</h2><p>以下是一个 <code>$CATALINA_BASE/conf</code> 中的默认 logging.properties 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 声明所有的handlers</span></span></span><br><span class="line">handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># RootLogger使用的handlers</span></span></span><br><span class="line">.handlers = 1catalina.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 定义了4个 org.apache.juli.FileHandler : 1catalina, 2localhost, 3manager, 4host-manager</span></span></span><br><span class="line">1catalina.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">1catalina.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">1catalina.org.apache.juli.FileHandler.prefix = catalina.</span><br><span class="line">1catalina.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">2localhost.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">2localhost.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">2localhost.org.apache.juli.FileHandler.prefix = localhost.</span><br><span class="line">2localhost.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">3manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">3manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">3manager.org.apache.juli.FileHandler.prefix = manager.</span><br><span class="line">3manager.org.apache.juli.FileHandler.bufferSize = 16384</span><br><span class="line">3manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">4host-manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.prefix = host-manager.</span><br><span class="line">4host-manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 定义 ava.util.logging.ConsoleHandler :</span></span></span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br><span class="line">java.util.logging.ConsoleHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 定义handlers, 使用上面定义的 FileHandler</span></span></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers = 2localhost.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers = 3manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers = 4host-manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> For example, <span class="built_in">set</span> the org.apache.catalina.util.LifecycleBase logger to <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> each component that extends LifecycleBase changing state:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">org.apache.catalina.util.LifecycleBase.level = FINE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To see debug messages <span class="keyword">in</span> TldLocationsCache, uncomment the following line:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">org.apache.jasper.compiler.TldLocationsCache.level = FINE</span></span><br></pre></td></tr></table></figure><ul><li><code>java.util.logging.ConsoleHandler</code>:<br>When running Tomcat on unixes, the console output is usually redirected to the file named catalina.out.<br>The name is configurable using an environment variable. (See the startup scripts).<br>Whatever is written to System.err/out will be caught into that file. That may include:<ul><li>Uncaught exceptions printed by java.lang.ThreadGroup.uncaughtException(..)</li><li>Thread dumps, if you requested them via a system signal</li></ul></li></ul><blockquote><p>java.util.logging.ConsoleHandler 是java自带的日志处理系统（JUL）的控制台日志Handler,<br>Tomcat通过<code>System.err.println()</code>/<code>System.out.println()</code>打出的日志会通过 java.util.logging.ConsoleHandler 写入Tomcat进程的stdout/stderr,<br>并最终输出到文件”catalina.out”中, 这个文件名是在Tomcat启动脚本里定义的:</p></blockquote><ul><li><code>org.apache.juli.FileHandler</code>:<br>org.apache.juli.FileHandler supports buffering of the logs.<br>The buffering is not enabled by default. To configure it, use the bufferSize property of a handler.<br>The value of 0 uses system default buffering (typically an 8K buffer will be used).<br>A value of &lt; 0 forces a writer flush upon each log write.<br>A value &gt; 0 uses a BufferedOutputStream with the defined value but note that the system default buffering will also be applied.</li></ul><blockquote><p>org.apache.支持日志缓存。日志缓存默认是没有启用的。使用 handler 的 bufferSize 属性可以配置它：<br>属性值为 0 时，代表使用系统默认的缓存（通常使用 8k 缓存）；<br>属性值小于 0 时，将在每个日志写入上强制使用 writer flush（将缓存区中的数据强制写出到系统输出）功能；<br>属性值大于 0 时，则使用带有定义值的 BufferedOutputStream 类——但要注意的是，这也将应用于系统默认的缓存。</p></blockquote><h2 id="WebApp的日志配置解析"><a href="#WebApp的日志配置解析" class="headerlink" title="WebApp的日志配置解析"></a>WebApp的日志配置解析</h2><p>下例是一个用于 servlet-examples 应用的 WEB-INF/classes 中的 logging.properties 文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Handler specific properties.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describes specific configuration info <span class="keyword">for</span> Handlers.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###########################################################</span></span></span><br><span class="line"></span><br><span class="line">org.apache.juli.FileHandler.level = FINE</span><br><span class="line">org.apache.juli.FileHandler.directory =  $&#123;catalina.base&#125;/logs</span><br><span class="line">org.apache.juli.FileHandler.prefix = $&#123;classloader.webappName&#125;.</span><br></pre></td></tr></table></figure><blockquote><p>Tomcat启动时报错 “SEVERE: Error listenerStart” 或者 “SEVERE: Error filterStart” 等, 但没有具体的错误日志:<br>这种一般是因为 Tomcat WebAppClassLoader 加载的<code>org.springframework</code>类的日志没有关联一个Handler,<br>可以修改 webapps/xxx/WEB-INF/classes/logging.properties, Tomcat就会在打印 org.springframework 类的详细的报错信息了.<br>注意, 老的应用可能还在使用 System.out 或 System.err，这种情况下还需要在web应用的classes/logging.properties 里增加 java.util.logging.ConsoleHandler:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line">## JULI.FileHandler 的设置</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">## JUL.ConsoleHandler 的设置</span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br></pre></td></tr></table></figure><blockquote><p>对于还在使用 System.out 或 System.err的应用:<br>可以通过在 Context 元素上设置 swallowOutput 属性来调整。如该属性设为 true，那么在请求阶段对 System.out/err 的调用就会被拦截，它们的输出也会通过 <code>javax.servlet.ServletContext.log(...)</code> 调用反馈给日志系统。</p></blockquote><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><ul><li>catalina.2017-08-29.log         //Cataline引擎的日志文件</li><li>localhost.2017-08-29.log        //Tomcat下内部代码抛出的日志jsp页面内部错误的异常</li><li>manager.2017-08-29.log          //Tomcat下默认 manager应用日志</li><li>host-manager.2017-08-29.log     //Tomcat下默认 manager应用日志</li><li>localhost_access_log.2017-08-29.txt  //访问日志记录</li><li>catalina.out                         //控制台输出的日志,Linux下默认重定向到catalina.out</li></ul><p>查看catalina.sh, 最终启动tomcat执行的命令行是 <code>java ${JAVA_OPTS} org.apache.catalina.startup.Bootstrap start</code></p><h2 id="生产环境中的日志"><a href="#生产环境中的日志" class="headerlink" title="生产环境中的日志"></a>生产环境中的日志</h2><p>可能需要注意以下方面：</p><ul><li>将 ConsoleHandler 从配置中移除。默认（ .handlers 设置）日志会使用 FileHandler 和 ConsoleHandler。<br>后者的输出经常会被捕获到一个文件中，比如 catalina.out。从而导致同一消息可能生成了两个副本。</li><li>对于不使用的应用(比如 host-manager)，可以考虑将 FileHandlers 移除。</li><li>handler 默认使用系统缺省编码来写入日志文件，通过 encoding 属性可以修改设置，详情查看相关的 javadoc 文档。</li><li>增加Access访问日志。</li></ul><h2 id="使用log4j"><a href="#使用log4j" class="headerlink" title="使用log4j"></a>使用log4j</h2><p>参考 <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html#usingLog4j" target="_blank" rel="noopener">使用 Log4j</a> @ref</p><ul><li>如果只是想在自己的 Web 应用上使用 log4j 时<ul><li>只需将 log4j.jar 和 log4j.properties 放到 Web 应用的 WEB-INF/lib 和 WEB-INF/classes 中即可</li></ul></li><li>如果想配置 Tomcat 以便利用 log4j 来进行自身日志记录时，下面的步骤都是必需的:<ul><li>创建一个包含下列配置的 log4j.properties 文件，将其保存到 $CATALINA_BASE/lib。<strong>Important!</strong></li><li>下载 log4j</li><li>下载或构建 tomcat-juli.jar 和 tomcat-juli-adapters.jar，以便作为 Tomcat 的额外组件使用。</li><li>将 log4j.jar 和 tomcat-juli-adapters.jar 从 extras 中放入 $CATALINA_HOME/lib 中。</li><li>用 extras 中的 tomcat-juli.jar 替换 $CATALINA_HOME/bin/tomcat-juli.jar。</li><li>删除 $CATALINA_BASE/conf/logging.properties，以防止 java.util.logging 生成零长度的日志文件。</li></ul></li></ul><h1 id="高级IO"><a href="#高级IO" class="headerlink" title="高级IO"></a>高级IO</h1><h2 id="推送-Comet-支持"><a href="#推送-Comet-支持" class="headerlink" title="推送: Comet 支持"></a>推送: Comet 支持</h2><p>施工中</p><h2 id="发送大型静态文件-sendfile"><a href="#发送大型静态文件-sendfile" class="headerlink" title="发送大型静态文件: sendfile"></a>发送大型静态文件: sendfile</h2><p>施工中</p><h1 id="How-to-deploy-war"><a href="#How-to-deploy-war" class="headerlink" title="How to deploy war"></a>How to deploy war</h1><p>有3中方式部署war包:</p><ol><li>在server.xml的<code>&lt;Host&gt;</code>标签中声明<code>&lt;Context&gt;</code>标签</li><li>在server.xml的<code>&lt;Host&gt;</code>标签中开启autoDeploy, 将war包放入webapps中会自动部署</li><li>context.xml配置方式</li></ol><h2 id="Using-the-UI-manager"><a href="#Using-the-UI-manager" class="headerlink" title="Using the UI manager"></a>Using the UI manager</h2><p>Tomcat提供了一个网页版的Manager App, 默认位置在webapps/manager, 也是一个web项目, 使用方式参考: <a href="http://tomcat.apache.org/tomcat-6.0-doc/manager-howto.html#Configuring_Manager_Application_Access" target="_blank" rel="noopener">Apache Tomcat 6.0 (6.0.53) - Manager App HOW-TO</a> @ref</p><p>Go to <code>[&lt;protocol&gt;://]localhost:&lt;port&gt;/manager/html/</code> (usually <code>localhost:8080/manager/html/</code>),<br>If you get:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">403 Access Denied</span><br></pre></td></tr></table></figure></p><p>go to <code>%CATALINA_HOME%\conf\tomcat-users.xml</code> and check that you have enabled a line like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;tomcat,role1,manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Using-maven"><a href="#Using-maven" class="headerlink" title="Using maven"></a>Using maven</h2><p>待补充…</p><h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><blockquote><p>@ref 参考: <a href="https://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Apache Tomcat 7 (7.0.93) - Class Loader HOW-TO</a></p></blockquote><p>与很多服务器应用一样，Tomcat 也安装了各种类加载器。借助类加载器，容器的不同部分以及运行在容器里的 Web Apps 就可以访问不同的仓库（保存着可使用的类和资源）。<br>// 这里英文原文是”different repositories of available classes and resources.” 不知道该怎么翻译这里的”repositories” ?</p><blockquote><p>在 Java 环境中，类加载器的布局结构是一种父子树的形式。通常，类加载器被请求加载一个特定的类或资源时，它会先把这一请求委托给它的父类加载器，只有（一个或多个）父类加载器无法找到请求的类或资源时，它才开始查看自身的仓库。</p></blockquote><p>注意，Web 应用的类加载器模式跟这个稍有不同，下文将详细介绍，但基本原理是一样。<br>当 Tomcat 启动后，它就会创建一组类加载器，这些类加载器被布局成如下图所示这种父子关系，父类加载器在子类加载器之上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Bootstrap</span><br><span class="line">        |</span><br><span class="line">     System</span><br><span class="line">        |</span><br><span class="line">     Common</span><br><span class="line">     /     \</span><br><span class="line">Webapp1   Webapp2 ..</span><br></pre></td></tr></table></figure><p>如上图所示，Tomcat 在初始化时会创建如下这些类加载器：</p><ul><li><strong>Bootstrap</strong> 这种类加载器包含 JVM 所提供的基本的运行时类，以及来自系统扩展目录（<code>$JAVA_HOME/jre/lib/ext</code>）里 JAR 文件中的类。<br>注意：在有些 JVM 的实现中，它的作用不仅仅是类加载器，或者它可能根本不可见（作为类加载器）。</li><li><strong>System</strong> 这种类加载器通常是根据 CLASSPATH 环境变量内容进行初始化的。所有的这些类对于 Tomcat 内部类以及 Web 应用来说都是可见的。<br>不过，标准的 Tomcat 启动脚本（<code>$CATALINA_HOME/bin/catalina.sh</code> 或 <code>%CATALINA_HOME%\bin\catalina.bat</code>）完全忽略了 CLASSPATH 环境变量自身的内容，相反从下列仓库来构建系统类加载器：<ul><li><code>$CATALINA_HOME/bin/bootstrap.jar</code> 包含用来初始化 Tomcat 服务器的 <code>main()</code> 方法，以及它所依赖的类加载器实现类。</li><li><code>$CATALINA_BASE/bin/tomcat-juli.jar</code> 或 <code>$CATALINA_HOME/bin/tomcat-juli.jar</code> 日志实现类。其中包括了对 <code>java.util.logging</code> API 的功能增强类（Tomcat JULI），以及对 Tomcat 内部使用的 Apache Commons 日志库的包重命名副本。详情参看 Tomcat 日志文档。<blockquote><p>如果 <code>*$CATALINA_BASE/bin*</code> 中存在 <code>tomcat-juli.jar</code>，就不会使用 <em>$CATALINA_HOME/bin</em> 中的那一个。它有助于日志的特定配置。</p></blockquote></li><li><code>$CATALINA_HOME/bin/commons-daemon.jar</code> Apache Commons Daemon 项目的类。该 JAR 文件并不存在于由 catalina.bat 或 catalina.sh 脚本所创建的 CLASSPATH 中，而是引用自 bootstrap.jar 的清单文件。</li></ul></li><li><strong>Common</strong> 这种类加载器包含更多的额外类，它们对于Tomcat 内部类以及所有 Web 应用都是可见的。<br>通常，应用类不会放在这里。该类加载器所搜索的位置定义在 <code>$CATALINA_BASE/conf/catalina.properties</code> 的 common.loader 属性中。默认的设置会搜索下列位置（按照列表中的上下顺序）。<ul><li><code>$CATALINA_BASE/lib</code> 中的解包的类和资源。</li><li><code>$CATALINA_BASE/lib</code> 中的 JAR 文件。</li><li><code>$CATALINA_HOME/lib</code> 中的解包类和资源。</li><li><code>$CATALINA_HOME/lib</code> 中的 JAR 文件。<br>默认，它包含以下这些内容：</li><li><em>annotations-api.jar</em> JavaEE 注释类。</li><li><em>catalina.jar</em> Tomcat 的 Catalina servlet 容器部分的实现。</li><li><em>jsp-api.jar</em> JSP 2.3 API</li><li><em>servlet-api.jar</em> Servlet 3.1 API</li><li><em>tomcat-api.jar</em> Tomcat 定义的一些接口</li><li><em>tomcat-dbcp.jar</em> 数据库连接池实现，基于 Apache Commons Pool 的包重命名副本和 Apache Commons DBCP。</li><li><em>tomcat-jdbc.jar</em> 一个数据库连接池替代实现，又被称作 Tomcat JDBC 池。详情参看 JDBC 连接池文档。</li><li>…</li></ul></li><li><strong>WebappX</strong> 为每个部署在单个 Tomcat 实例中的 Web 应用创建的类加载器。你的 Web 应用的 /WEB-INF/classes 目录中所有的解包类及资源，以及 /WEB-INF/lib 目录下 JAR 文件中的所有类及资源，对于该应用而言都是可见的，但对于其他应用来说则不可见。<br>如上所述，Web 应用类加载器背离了默认的 Java 委托模式（根据 Servlet 规范 2.4 版的 9.7.2 Web Application Classloader一节中提供的建议）。<br>当某个请求想从 Web 应用的 WebappX 类加载器中加载类时，该类加载器会先查看自己的仓库，而不是预先进行委托处理。<br>JRE 基类的部分类不能被重写。对于一些类（比如 J2SE 1.4+ 的 XML 解析器组件），可以使用 J2SE 1.4 支持的特性。<br>最后，类加载器会显式地忽略所有包含 Servlet API 类的 JAR 文件，所以不要在 Web 应用包含任何这样的 JAR 文件。Tomcat 其他的类加载器则遵循常用的委托模式。</li></ul><p>因此，从 Web 应用的角度来看，加载类或资源时，要查看的仓库及其顺序如下：</p><ol><li>JVM 的 Bootstrap 类</li><li>Web 应用的 /WEB-INF/classes 类</li><li>Web 应用的 /WEB-INF/lib/*.jar 类</li><li>System 类加载器的类（如上所述）</li><li>Common 类加载器的类（如上所述）</li></ol><p>如果 Web 应用类加载器配置有 <code>&lt;Loader delegate=&quot;true&quot;/&gt;</code> ，则顺序变为：</p><ol><li>JVM 的 Bootstrap 类</li><li>System 类加载器的类（如上所述）</li><li>Common 类加载器的类（如上所述）</li><li>Web 应用的 /WEB-INF/classes 类</li><li>Web 应用的 /WEB-INF/lib/*.jar 类</li></ol><h1 id="源码导读-Tomcat-8-5"><a href="#源码导读-Tomcat-8-5" class="headerlink" title="源码导读 (Tomcat 8.5)"></a>源码导读 (Tomcat 8.5)</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ant clean</span><br><span class="line">ant</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp ./output/classes -Dcatalina.home=./output/build org.apache.catalina.startup.Bootstrap</span><br></pre></td></tr></table></figure><h2 id="启动过程源码调用时序"><a href="#启动过程源码调用时序" class="headerlink" title="启动过程源码调用时序"></a>启动过程源码调用时序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Bootstrap.main // 入口方法</span><br><span class="line">  Bootstrap.init()</span><br><span class="line">    initClassLoaders()  // 初始化commonLoader, catalinaLoader, sharedLoader</span><br><span class="line">      commonLoader = createClassLoader(<span class="string">"common"</span>, null);</span><br><span class="line">        ClassLoaderFactory.createClassLoader(repositories, parent); // 该方法通过AccessController.doPrivileged创建了URLClassLoader, 并返回</span><br><span class="line">    catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>)` // 创建Catalina对象</span><br><span class="line">  Bootstrap.load(args)</span><br><span class="line">    Catalina.load()</span><br><span class="line">      Digester digester = createStartDigester() // 为digester 添加 Rule</span><br><span class="line">      Digester.parse(inputSource) // 解析 server.xml !!</span><br><span class="line">        Digester.startElement()</span><br><span class="line">          Rule.begin()</span><br><span class="line">            ObjectCreateRule.begin() // 这里通过反射调用了 Server &amp; Connector &amp; Context等类的构造方法</span><br><span class="line">              org.apache.catalina.core.StandardServer.StandardServer() // Server构造</span><br><span class="line">              org.apache.catalina.core.StandardService.StandardService() // Service构造</span><br><span class="line">            ConnectorCreateRule.begin</span><br><span class="line">              org.apache.catalina.connector.Connector.Connector()</span><br><span class="line">                // Connector构造, 根据配置中的 <span class="string">"protocol"</span> 设置创建不同的创建 ProtocolHandler:</span><br><span class="line">                Http11NioProtocol() // 默认的 ProtocolHandler</span><br><span class="line">                  AbstractHttp11Protocol(new NioEndpoint())</span><br><span class="line">                    NioEndpoint()</span><br><span class="line">                        AbstractEndpoint()  // 创建 worker 线程池</span><br><span class="line">  Bootstrap.start()</span><br><span class="line">    Catalina.start()</span><br><span class="line">      StandardServer.start() =&gt; LifecycleBase.start()</span><br><span class="line">        StandardServer.startInternal()</span><br><span class="line">          StandardService.start() =&gt; LifecycleBase.start()</span><br><span class="line">            StandardService.startInternal()</span><br><span class="line">              Engine.start() =&gt; LifecycleBase.start()   // 启动 Engine</span><br><span class="line">                StandardEngine.startInternal()</span><br><span class="line">                  ContainerBase.startInternal()</span><br><span class="line">                    StartChild.call()  // 多线程启动, 线程数=Host数量</span><br><span class="line">                      StandardHost.start() =&gt; LifecycleBase.start()</span><br><span class="line">                        StandardHost.startInternal()</span><br><span class="line">                          ContainerBase.startInternal() =&gt; LifecycleBase.setStateInternal()</span><br><span class="line">                            ContainerBase.setState(LifecycleState.STARTING)</span><br><span class="line">                              LifecycleBase.fireLifecycleEvent(lifecycleEvent, data)</span><br><span class="line">                                  HostConfig.start()</span><br><span class="line">                                    HostConfig.deployApps()</span><br><span class="line">                                      HostConfig.deployWARs() // 解析 web.xml !!</span><br><span class="line">              MapperListener.start() =&gt; LifecycleBase.start()  // 启动 MapperListener</span><br><span class="line">                MapperListener.startInternal()</span><br><span class="line">              Connector.start() =&gt; LifecycleBase.start()     // 启动(多个) Connector</span><br><span class="line">                Connector.startInternal()</span><br><span class="line">                  Http11NioProtocol.start() =&gt; AbstractProtocol.start()</span><br><span class="line">                    AbstractEndpoint.start() =&gt; NioEndpoint.startInternal()</span><br><span class="line">                      // 创建三个cache: processorCache, eventCache, nioChannels</span><br><span class="line">                      startAcceptorThreads()</span><br><span class="line">                    new AsyncTimeout(); // Start <span class="keyword">async</span> timeout thread</span><br><span class="line">      StandardServer.<span class="keyword">await</span>() // 创建一个在<span class="number">8005</span>监听的ServerSocket, 用于监听关闭</span><br><span class="line">        ServerSocket.accept // 阻塞在这里</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote><p>参考 <a href="https://blog.csdn.net/tjiyu/article/details/54590259" target="_blank" rel="noopener">Tomcat实现：源码分析Tomcat实现细节 </a> @Archived</p><pre><code>* Connect.start()—创建并发线程模型: Work线程, Poller线程, Acceptor线程, AsyncTimeout线程* 请求处理: Acceptor线程, Poller线程, Selector</code></pre></blockquote><h3 id="如何解析server-xml"><a href="#如何解析server-xml" class="headerlink" title="如何解析server.xml"></a>如何解析server.xml</h3><ul><li>在Catalina.load() 创建digester: <code>Digester digester = createStartDigester()</code></li><li><code>createStartDigester</code>方法创建了digester对象, 并给digester对象添加多种Rule, 每种Rule都对应server.xml里的一个节点类型, 比如<code>&lt;Server&gt;</code>, <code>&lt;Connector&gt;</code>;</li><li>digester对server.xml设置的标签动作有5种调用：<ul><li>addObjectCreate：遇到起始标签的元素，初始化一个实例对象入栈</li><li>addSetProperties：遇到某个属性名，使用setter来赋值</li><li>addSetNext：遇到结束标签的元素，调用相应的方法</li><li>addRule：调用rule的begin 、body、end、finish方法来解析xml，入栈和出栈给对象赋值</li><li>addRuleSet：调用addRuleInstances来解析xml标签</li></ul></li><li>从这些规则和xml中可以看到，Calatina的Server对象是StandardServer。 StandardService包含了多个Connector（xml中有2个connector）和一个StandardEngine Container。 StandardEngine包含了一个Host Container</li></ul><h3 id="初始化Connector"><a href="#初始化Connector" class="headerlink" title="初始化Connector"></a>初始化Connector</h3><p>根据配置文件 protocol = “HTTP/1.1”,”AJP/1.3” 创建对应 protocol, 默认是 Http11NioProtocol,<br>再由Http11NioProtocol 创建 NioEndpoint:</p><p>代码流程</p><ul><li>调用<code>Connector(String protocol)</code>, 构造函数<code>Connector</code>中默认创建<code>org.apache.coyote.http11.Http11NioProtocol</code></li><li>以<code>Http11NioProtocol</code>为例, <code>Http11NioProtocol.init()</code>最终调用到<code>NioEndpoint.bind()</code> =&gt; <code>NioEndpoint.initServerSocket()</code>  =&gt; <code>serverSock.socket().bind(addr,getAcceptCount())</code> 完成了对端口的绑定</li><li>bind()的最后调用了<code>NioSelectorPool.open()</code>, 这是一个存放Selector的池子,</li></ul><h3 id="启动Connector"><a href="#启动Connector" class="headerlink" title="启动Connector"></a>启动Connector</h3><p>Connector 主要功能实现都是在 <strong>NioEndpoint</strong>, NioEndpoint 包括x个Acceptor线程, x个 Poller线程;<br>Acceptor线程(默认一个)用于 accept 客户端请求, 并把 客户端请求socket 封装进event, 放入 events queue;<br>Poller线程池用于消费 events queue, 每个Poller 都有自己的 Selector对象, 不断取出event, 并从中解析出sockt, 并把socket 的 READ事件注册到自己的 Selector.</p><p>代码调用流程:</p><ul><li>Connector的启动会调用<code>start</code>方法, =&gt; <code>Connector.startInternal</code>方法 =&gt; <code>Http11NioProtocol.start()</code> =&gt; <code>AbstractProtocol.start()</code> =&gt; <code>NioEndpoint.start()</code> =&gt; <code>NioEndpoint.startInternal()</code></li><li>在<code>NioEndpoint.startInternal()</code>中,<ul><li>如果Worker线程池是空, 则自己创建: 调用了父类<code>AbstractEndpoint#createExecutor()</code>, 创建work线程池, 名称前缀 “-exec-“;</li><li>创建<code>NioEndpoint$Poller[]</code>数组, Poller是Runnable的实现, 然后所有的Poller线程都start起来, 线程名前缀是 “-ClientPoller-“, 数组的大小也就是Poller的数量是<code>Math.min(2,Runtime.getRuntime().availableProcessors())</code>, 可见 Poller数量 是 min(2, cpu的process数量)</li><li>调用<code>startAcceptorThreads()</code>,  创建 <code>Acceptor</code>线程, 默认一个(线程数是server.xml里的<code>acceptCount</code>), , 线程名前缀是”-Acceptor-“</li></ul></li></ul><h3 id="accept请求"><a href="#accept请求" class="headerlink" title="accept请求"></a>accept请求</h3><p>Acceptor 线程 accept , 并把 客户端请求socket 封装进event, 放入 events queue, 调用流程:</p><ul><li><p><code>Acceptor.run()</code>:</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (endpoint.isRunning()) &#123;</span><br><span class="line">    socket = endpoint.serverSocketAccept();</span><br><span class="line">    endpoint.setSocketOptions(socket) // 调用了 NioEndpoint.setSocketOptions()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再看 <code>NioEndpoint.setSocketOptions()</code>里做了什么:  把客户端请求的socket 封装进 NioChannel,<br>调用 Poller.register(NioChannel): 把 NioChannel 封装进PollerEvent,  每个 Poller都有一个 PollerEvent队列(events queue), 把PollerEvent放入这个队列 // Poller 有多个, 这里会轮询的方式选择出其中一个, <code>AtomicInteger.incrementAndGet()) % pollers.length</code></p></li></ul><h3 id="处理一次Req请求"><a href="#处理一次Req请求" class="headerlink" title="处理一次Req请求"></a>处理一次Req请求</h3><p>Poller线程用于消费 events queue, 代码调用流程:</p><ul><li><code>Poller.run()</code> while循环从 event queue取出 PollerEvent, 然后调用 <code>PollerEvent.run()</code><ul><li><code>PollerEvent.run()</code> // 主要是 在 Poller自己的Selector上注册 READ事件</li><li><code>Poller.processKey(SelectionKey , NioSocketWrapper)</code> 调用-&gt; <code>Poller.processSocket</code> // 处理 OPEN_READ/OPEN_WRITE等事件<ul><li>创建一个 SocketProcessorBase的实例, 把 socket 和 Event 封装进去, SocketProcessorBase 继承自Runnable</li><li>executor.execute(SocketProcessorBase) // 用Worker线程池运行这个 SocketProcessorBase<ul><li><code>SocketProcessorBase.run()</code> -&gt; <code>SocketProcessor.doRun()</code></li></ul></li></ul></li></ul></li></ul><p>再看SocketProcessor 调用流程:</p><ul><li><code>SocketProcessor.doRun()</code> :  // 调用SocketChannel.keyFor()<ul><li><code>AbstractProtocol$ConnectionHandler.process()</code><ul><li><code>NioEndpoint$SocketProcessor.doRun()</code><ul><li><code>Http11Processor.service()</code> : 处理Socket IO流, 解析为Http Request<ul><li><code>ApplicationFilterChain.internalDoFilter()</code>: 调用<code>Filter.doFilter()</code> ,以及<code>Servlet.service()</code>;</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="如何SHUTDOWN"><a href="#如何SHUTDOWN" class="headerlink" title="如何SHUTDOWN"></a>如何SHUTDOWN</h3><ul><li>StandardServer.await() 创建一个在8005监听的ServerSocket, 是用来监听关闭Tomcat命令的, 当执行shutdown.sh关闭tomcat时就是连接8005端口执行“SHUTDOWN”命令;</li><li>关闭请求发给Tomcat, 由StandardServer.await处理, await方法验证关闭请求是否有效, 如果有效则退出await方法, 进入Catalina.stop(), 调用<br>StandardServer.stop, StandardServer.destroy,  然后关闭Connector, Service</li></ul><p>从日志可以看到:</p><ul><li>WebappLoader.stopInternal -&gt; WebappClassLoaderBase.stop -&gt; WebappClassLoaderBase.clearReferences<ul><li>WebappClassLoaderBase.clearReferencesJdbc</li><li>WebappClassLoaderBase.clearReferencesThreads</li></ul></li><li>AbstractProtocol.pause Pausing ProtocolHandler [“http-nio-8080”]</li><li>AbstractProtocol.pause Pausing ProtocolHandler [“ajp-nio-8009”]</li><li>StandardService.stopInternal</li></ul><h2 id="Useful-Java-API-usage"><a href="#Useful-Java-API-usage" class="headerlink" title="Useful Java API usage"></a>Useful Java API usage</h2><ul><li>AsyncChannelWrapperSecure:<ul><li>Executors.newFixedThreadPool , shutdownNow</li><li>AsynchronousSocketChannel</li><li>ByteBuffer, flip, hasRemaining,</li><li>AtomicBoolean</li></ul></li><li>WsWebSocketContainer<ul><li>AsynchronousSocketChannel</li></ul></li></ul><h3 id="并发的处理代码"><a href="#并发的处理代码" class="headerlink" title="并发的处理代码"></a>并发的处理代码</h3><ul><li><p>用线程池启动容器内组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // Start our child containers, if any</span><br><span class="line">Container children[] = findChildren();</span><br><span class="line">List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">    results.add(startStopExecutor.submit(new StartChild(children[i])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean fail = false;</span><br><span class="line">for (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        result.get();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过Callable封装带返回值的任务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private static class StartChild implements Callable&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Container child;</span><br><span class="line"></span><br><span class="line">    public StartChild(Container child) &#123;</span><br><span class="line"></span><br><span class="line">        this.child = child;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void call() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">        child.start();</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://toutiao.io/u/176492?page=4" target="_blank" rel="noopener">Tomcat那些事儿的热门分享 - 开发者头条</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 13.J2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC</title>
      <link href="/13.JavaEE-Framework/JavaEE.SpringMVC/"/>
      <url>/13.JavaEE-Framework/JavaEE.SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Spring-Context"><a href="#使用Spring-Context" class="headerlink" title="使用Spring Context"></a>使用Spring Context</h1><p>使用ClassPathXmlApplicationContext:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"META-INF/spring/spring-main.xml"</span>);</span><br><span class="line">A a = context.getBean(A.class);</span><br></pre></td></tr></table></figure><p>直接使用 DefaultListableBeanFactory:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"spring-core.xml"</span>);</span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br><span class="line">MyBean myBean = (MyBean) beanFactory.getBean(<span class="string">"myBean"</span>);</span><br><span class="line">myBean.sayHello();</span><br></pre></td></tr></table></figure><h1 id="使用Bean"><a href="#使用Bean" class="headerlink" title="使用Bean"></a>使用Bean</h1><p>Spring 基于 Ioc 和 DI 的方式 创建 &amp; 装配 Bean :</p><ul><li>控制反转(Inversion of Control): 使用者不自己创建依赖的对象, 而交由第三方(IoC容器)创建. 从IOC容器中获取（和自动注入）.<br>而不必由用户调用<code>new</code>来创建Bean对象, 通过IoC则可以减少它们之间的耦合度.</li><li>依赖注入(Dependency Injection): 将依赖对象传递给使用者. 在Spring中, bean的装配是依赖注入的具体行为，依赖注入的时候需要根据bean的名称或类型等进行装配。</li></ul><h2 id="创建Bean的几种方式"><a href="#创建Bean的几种方式" class="headerlink" title="创建Bean的几种方式"></a>创建Bean的几种方式</h2><p>基于注解 &amp; XML:</p><h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><h4 id="①-基于-Component"><a href="#①-基于-Component" class="headerlink" title="① 基于 @Component"></a>① 基于 @Component</h4><ol><li><p>通过注解方式创建容器:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public interface ThisIsConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Configuration 来标注该接口是用于定义配置的, Spring 会视为该java文件为一个xml配置</li><li>@ComponentScan Spring 将会扫描该类所在的包下的所有 bean注解(@Component, @Service等等), 等同于在 Spring的xml里写:<br>  <code>&lt;context:component-scan base-package=&quot;com.bigdata&quot;&gt;&lt;/context:component-scan&gt;</code><br>  如果要指定要扫描的包的路径(而不是 这个类所在的包) 可以用 <code>@ComponentScan(value=&quot;包路径&quot;)</code> 指定;</li></ul></li><li>带有 <code>@Component</code>注解的类被Ioc方式创建:</li><li>通过 <code>@Autowired</code> 用 DI 方式进行装配:</li></ol><blockquote><p>关于@Component,@Service,@Controler,@Repository注解<br>这几个注解都是同样的功能，被注解的类将会被Spring 容器创建单例对象。<br>@Component : 侧重于通用的Bean类<br>@Service：标识该类用于业务逻辑<br>@Controler：标识该类为Spring MVC的控制器类<br>@Repository: 标识该类是一个实体类，只有属性和Setter,Getter</p></blockquote><h4 id="②-基于-Bean"><a href="#②-基于-Bean" class="headerlink" title="② 基于 @Bean"></a>② 基于 @Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SwaggerSpringMvcPlugin <span class="title">customImplementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Bean</code> 注解在这里的意思是 : 该方法会返回一个 SwaggerSpringMvcPlugin 类型的 bean</p><h3 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h3><p>① 基于构造器: 下面的类JedisPortsFactory 具有一个构造器(该构造器 有两个参数: config 和 autoFlush)<br>config 引用到了另一个bean, autoFlush 是个boolean型</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"jedisPortsFactory"</span> <span class="attr">class</span>=<span class="string">"com.bigdata.console.tools.online.JedisPortsFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"config"</span> <span class="attr">ref</span>=<span class="string">"jedisEvictionPoolConfig"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"autoFlush"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>② 基于 setter: // CommonsMultipartResolver 要有<code>property</code>对应的 Setter方法</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"-1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>③ 基于静态工厂: 指定 工厂类的class, 适用于 静态工厂方法:</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jp_featurePv"</span> <span class="attr">class</span>=<span class="string">"com.bigdata.consoleJedisPortsFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getJedisMSServers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>④ 基于动态工厂: 指定 动态工厂的bean 和方法, 下面的例子中工厂方法 getJedisMSServers 有一个字符串型的参数, 适用于动态工厂方法:</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jp_featurePv"</span> <span class="attr">factory-bean</span>=<span class="string">"jedisPortsFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getJedisMSServers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h4 id="bean的属性"><a href="#bean的属性" class="headerlink" title="bean的属性"></a>bean的属性</h4><h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h5><ul><li>scope=”singleton”: 单例,  Spring 在每次需要时都返回同一个bean实例</li><li>scope=”prototype”: Spring 在每次需要时都产生一个新的 bean 实例</li><li>scope=”request”</li><li>scope=”session”</li></ul><p>singleton的实现: Spring 维护一个Map, key是 bean的变量名, 用单例方式创建 Bean, 会先放入这个map中, 这个map可以看成是一个缓存;<br>如果是 prototype , 则没有这个map,<br>下面是Spring源码中的 singleton实现方法。以下的源码在 Spring的Bean包中的 DefaultSingletonBeanRegistry.java类中</p><p><img src="/images/javaee/spring-singleton-init-register.png" alt="Spring-Singleton-Init-Register"></p><h5 id="autowire"><a href="#autowire" class="headerlink" title="autowire"></a>autowire</h5><ul><li>autowire=”byName”: 只能用于setter注入。比如我们有方法“setHelloApi”，则“byName”方式Spring容器将查找名字为helloApi的Bean并注入</li><li>autowire=”no”: 意思是不支持自动装配，必须明确指定依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"bean.HelloApiDecorator"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h5><p>Spring保证该Bean所依赖的其他bean已经初始化, 用<code>&lt;ref&gt;</code>元素建立对其他bean的依赖关系, Sprign 会确保创建 bean的顺序:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span> <span class="attr">class</span>=<span class="string">"helloworld.HelloImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"decorator"</span>  <span class="attr">class</span>=<span class="string">"helloworld.HelloApiDecorator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">depends-on</span>=<span class="string">"helloApi"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helloApi"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"helloApi"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h5><p>单例模式的beanA需要引用另外一个非单例模式的beanB，为了在我们每次引用的时候都能拿到最新的beanB</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"prototypeBean"</span> <span class="attr">class</span>=<span class="string">"bean.PrototypeBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span> <span class="attr">class</span>=<span class="string">"bean.SingletonBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SingletonBean.getBean()方法被代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getBean"</span> <span class="attr">bean</span>=<span class="string">"prototypeBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBean</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法, 每次获取一个新的PrototypeBean实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PrototypeBean <span class="title">getBean</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:resource/applicationContext.xml"</span>);</span><br><span class="line">SingletonBean b= (SingletonBean)app.getBean(<span class="string">"singletonBean"</span>);</span><br><span class="line">b.getBean();  <span class="comment">// 每次返回一个新的PrototypeBean</span></span><br></pre></td></tr></table></figure><h2 id="Bean的初始化-销毁回调"><a href="#Bean的初始化-销毁回调" class="headerlink" title="Bean的初始化/销毁回调"></a>Bean的初始化/销毁回调</h2><p><img src="/images/javaee/spring-bean-lifecycle.png" alt="Spring-Bean-Lifecycle"></p><h3 id="基于代码"><a href="#基于代码" class="headerlink" title="基于代码"></a>基于代码</h3><p>InitializingBean接口为bean提供了属性初始化后的处理方法，它只包括afterPropertiesSet方法，凡是继承该接口的类，在bean的属性初始化后都会执行该方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisposableBean接口为bean提供销毁方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="基于XML配置"><a href="#基于XML配置" class="headerlink" title="基于XML配置"></a>基于XML配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.dropNotes.HelloWorld"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的init-method属性和 destroy-method属性, 指定了HelloWorld类的初始化/销毁回调方法名字, 接下来在HelloWorld类中定义无参的方法即可.</p><h3 id="何时调用"><a href="#何时调用" class="headerlink" title="何时调用"></a>何时调用</h3><p>当<code>ApplicationContext.registerShutdownHook()</code>被调用时</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>Spring 通过反射实现IOC</p><h1 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h1><p>AOP(Aspect Oriented Program) : 面相切面编程: 主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。<br>Spring 通过jdk动态代理和cglib动态代理实现AOP</p><blockquote><p>Spring 的AOP是通过Java语言提供的代理(Proxy)实现的, Java语言的代理包括如下几种方式: JDK动态代理, Cglib动态代理.</p></blockquote><h2 id="AOP的一些概念"><a href="#AOP的一些概念" class="headerlink" title="AOP的一些概念"></a>AOP的一些概念</h2><p><img src="/images/javaee/javaee_spring_mvc_aop.png" alt=""></p><ul><li>连接点（Jointpoint）连接点是能够插入切面的一个点，连接点可能是类初始化，可以是调某方法时，抛出异常时，修改某字段时</li><li>切入点（Pointcut）：一组连接点集合</li><li>通知（Advice）：定义在连接点上“要做什么”，以及“何时去做”<ul><li>包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice）</li></ul></li><li>切面（Aspect）：可以认为是”通知”和”切入点”的集合</li><li>引入（inter-type declaration）：为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在AOP中表示为“做什么”；</li><li>目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁做”；</li><li>AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</li><li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</li></ul><h2 id="基于XML配置aspect"><a href="#基于XML配置aspect" class="headerlink" title="基于XML配置aspect"></a>基于XML配置aspect</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义了一个id="pointcut"的切点, 范围是com.javass包下的所有类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义切面的集合, ref="aspect"表示要引入"aspect"这个bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个切点, 包括用哪些切点, 以及在切点处要插入aspect.beforeAdvice()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"beforeAdvice"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义另一个切点, 在切点处要插入aspect.afterFinallyAdvice()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span> <span class="attr">method</span>=<span class="string">"afterFinallyAdvice"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于注解配置aspect"><a href="#基于注解配置aspect" class="headerlink" title="基于注解配置aspect"></a>基于注解配置aspect</h2><p>下面的代码定义一个切面(@Aspect): 哪里切入(@Pointcut), 切入的行为(@Advice)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerLogAspect</span> </span>&#123; <span class="comment">//定义了一个切面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点"logPointCut", 在哪些类里切入</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.xxx.*.controller..*.*(..)) &amp;&amp; "</span> +</span><br><span class="line">            <span class="string">"!execution(public * com.xxx.*.controller..CheckController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advice</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知, 在切点"logPointCut"之前</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"ret"</span>, pointcut = <span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何解决循环依赖"><a href="#如何解决循环依赖" class="headerlink" title="如何解决循环依赖"></a>如何解决循环依赖</h1><p>@toc:</p><ul><li>循环依赖如何产生;</li><li>Spring如何解决循环依赖</li></ul><p>➤ 循环依赖: 创建A的实例依赖B, 创建B的实例依赖A … Spring Bean对另一个Bean的依赖分为两种: 构造器注入依赖, setter属性注入依赖</p><p>➤ Spring如何解决循环依赖:</p><ul><li>Spring单例模式创建Bean步骤:<ul><li>createBeanInstance: 构造方法</li><li>populateBean: 填充属性</li><li>initializeBean: 执行自定义初始化</li></ul></li><li>Spring的Bean三层缓存: singletonFactories, earlySingletonObjects(已经初始化但未setter注入的bean), singletonObject,</li><li>Spring可以解决单例模式下以setter方式的循环依赖, 但无法解决 “A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”</li><li>Spring无法解决 prototype bean的循环依赖, 因为..</li><li>Spring创建Bean的步骤(伪码)  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 从单例缓存取</span><br><span class="line">Object singleton = singletonObjects.get(beanName);</span><br><span class="line">if( singleton == null) &#123;</span><br><span class="line">    //2 取不到, 尝试从 提前曝光缓存取</span><br><span class="line">    singleton = earlySingletonObjects.get(beanName);</span><br><span class="line"></span><br><span class="line">    if(singleton == null) &#123;</span><br><span class="line">        // 3 取不到, 从工厂缓存取, 并创建bean</span><br><span class="line">        ObjectFactory factory = singletonFactories.get(beanName);</span><br><span class="line">        singleton = factory.getObject();</span><br><span class="line"></span><br><span class="line">        // 4 创建好的bean从 放入提前曝光缓存, 并从工厂缓存移除</span><br><span class="line">        earlySingletonObjects.put(beanName, singleton);</span><br><span class="line">        singletonFactories.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return singleton;</span><br></pre></td></tr></table></figure></li></ul><p>@ref:</p><ul><li><a href="https://blog.csdn.net/u010853261/article/details/77940767" target="_blank" rel="noopener">Spring-bean的循环依赖以及解决方式<em>Java</em>惜暮-CSDN博客</a></li><li><a href="https://segmentfault.com/a/1190000012887776#item-4-3" target="_blank" rel="noopener">Spring解密 - Bean的加载流程</a></li></ul><h1 id="一次请求的处理流程"><a href="#一次请求的处理流程" class="headerlink" title="一次请求的处理流程"></a>一次请求的处理流程</h1><ul><li>Request → DispatchServlet</li><li>DispatchServlet:  从 HandleMapping[] 查找匹配, 返回 HandlerExecutionChain { HandlerInterceptor1,HandleInterceptor2..}</li><li>HandleInterceptor → HandleAdaptor → Controller</li><li>Controller 返回 ModelAndView → ViewResolver</li><li>View</li></ul><blockquote><p>@ref <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484846&amp;idx=1&amp;sn=490014ea65669c1a1e73e25d7b9fa569" target="_blank" rel="noopener">SpringMVC 工作原理详解</a></p></blockquote><h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><p>要使用Spring MVC只需要在web.xml(Java Servlet 规范里Java Web项目的部署描述符文件)里增加一个Servlet:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:appcontext-core-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet-工作流程"><a href="#DispatcherServlet-工作流程" class="headerlink" title="DispatcherServlet 工作流程"></a>DispatcherServlet 工作流程</h2><p>对于Spring MVC程序来说, 首先调用的是<code>DispatcherServlet.service(ServletRequest, ServletResponse)</code>, 实现是在<br><code>HttpServlet.service(ServletRequest req, ServletResponse resp)</code>, 这个方法里把ServletRequest对象转换为HttpServletRequest, 在这个方法里又调用进了<br><code>FrameworkServlet.service(HttpServletRequest req, HttpServletResponse resp)</code>, 在这个方法里如果<code>method!=PATCH</code>则调用进<code>super.service(HttpServletRequest, HttpServletResponse)</code>, 也就是<br><code>HttpServletservice(HttpServletRequest, HttpServletResponse)</code>, 这里根据不同的method调用不同的<code>doX()</code>方法,<br>调用了<code>this.doGet()</code>（以GET方法为例）, 因为在<code>FrameworkServlet</code> 重写了<code>doGet()</code>, 所以这里调用的代码是<code>FrameworkServlet.doGet()</code>,  在这个方法里<br>调用了<code>FrameworkServlet.processRequest()</code>, 然后又调用了<code>this.doService()</code>,<br><code>DispatcherServlet</code>重写了<code>doService()</code>, 所以最终调用到<code>DispatcherServlet.doService()</code>, 该方法逻辑大致如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void doDispatch(HttpServletRequest request, HttpServletResponse response)  &#123;</span><br><span class="line">    HandlerExecutionChain mappedHandler = getHandler(processedRequest);</span><br><span class="line">    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>getHandler()</code>主要就是通过<code>this.handlerMappings</code>中的HandlerMapping实例来对具体request映射一个handler（Spring MVC中的Controller类） ;</li><li>如果看过中对于<code>this.handlerMappings</code>初始化的解读，便知道HandlerMapping的具体实现有3个：<ul><li>RequestMappingHandlerMapping : 用来映射Controller和URL</li><li>BeanNameUrlHandlerMapping</li><li>SimpleUrlHandlerMapping</li></ul></li></ol><p><img src="/images/javaee/javaee_spring_mvc_dispacher.png" alt="DispatcherServlet 工作流程"><br>上图中组件处理顺序分别是:</p><ul><li>Dispatcher Servlet分发器</li><li>Handler Mapping 处理器映射</li><li>Controller 控制器</li><li>ModelAndView 模型和视图对象</li><li>ViewResolver 视图解析器</li></ul><h1 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器(Interceptor)"></a>拦截器(Interceptor)</h1><p>处理器映射处理过程配置的拦截器，必须实现 org.springframework.web.servlet包下的 <code>HandlerInterceptor</code>接口。<br>这个接口定义了三个方法：<br><code>preHandle(..)</code>，它在处理器实际执行 之前 会被执行；<br><code>postHandle(..)</code>，它在处理器执行 完毕 以后被执行；<br><code>afterCompletion(..)</code>，它在 整个请求处理完成 之后被执行。</p><h2 id="通过xml定义拦截器"><a href="#通过xml定义拦截器" class="headerlink" title="通过xml定义拦截器"></a>通过xml定义拦截器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"officeHoursInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"officeHoursInterceptor"</span> <span class="attr">class</span>=<span class="string">"samples.TimeBasedAccessInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"openingTime"</span> <span class="attr">value</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"closingTime"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过注解定义拦截器"><a href="#通过注解定义拦截器" class="headerlink" title="通过注解定义拦截器"></a>通过注解定义拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LocaleInterceptor());</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> ThemeInterceptor()).addPathPatterns(<span class="string">"/**"</span>).excludePathPatterns(<span class="string">"/admin/**"</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SecurityInterceptor()).addPathPatterns(<span class="string">"/secure/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器(Controller)"></a>控制器(Controller)</h1><h2 id="传入类型"><a href="#传入类型" class="headerlink" title="传入类型"></a>传入类型</h2><ul><li>@RequestParam注解: <code>@RequestParam(value = &quot;client_id&quot;) String appId</code></li><li>Model类型: 这种通常返回String类型的view路径</li><li>HttpServletResponse:</li><li>HttpServletRequest:</li></ul><h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><ul><li>返回ModelAndView: 返回视图<code>return new ModelView(&quot;/view/111&quot;, map)</code><ul><li>通过ModelAndView也可以重定向: <code>return new ModelAndView(&quot;redirect:/controller2&quot;);</code></li><li>如果modelView是以参数传入的: <code>model.setViewName(&quot;forward:index.jsp&quot;); return model;</code></li></ul></li><li>返回RedirectView: 专门用来处理转发的视图, 见后面的代码.</li><li>返回String: 返回字符串可以指定逻辑视图名, 通过视图解析器解析为物理视图地址<ul><li>通过String也可以重定向: <code>return &quot;redirect:/resource/page2.jsp&quot;;</code></li><li>如果Controller带有<code>@ResponseBody</code>注解, 可以直接返回String字面值;</li></ul></li><li>以json返回对象: 借助<code>@ResponseBody</code>注解, 项目导入Jackson.jar, 并且在Spring配置文件启用了<code>&lt;mvc:annotation-driven /&gt;</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li><li>返回Map:<ul><li>借助<code>@ResponseBody</code>注解, <code>return new HashMap&lt;&gt;();</code>会返回一个json</li><li>没有<code>@ResponseBody</code>注解, <code>map.put(&quot;key1&quot;, &quot;value-1&quot;); return map;</code>, 在jsp页面中可直通过<code>${key1}</code>获得到值</li></ul></li><li>返回void: 需要通过形参传入request和response<ul><li>使用request转向页面: <code>request.getRequestDispatcher(&quot;index.html&quot;).forward(request, response);</code></li><li>通过response页面重定向: <code>response.sendRedirect(&quot;http://www.xxx.com&quot;);</code></li><li>forward和Redirect的区别: forward是由Servlet直接转给另一个Controller处理, Redirect相当于302, 返回给浏览器, 然后浏览器再发一次新的请求到Controller2</li><li>通过response指定响应结果:<ul><li>返回json: <code>response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;this_is_json&quot;);</code></li><li>返回Html: <code>response.getWriter().println(&quot;&lt;title&gt;HelloWorld&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</code></li></ul></li></ul></li></ul><h3 id="用RedirectAttributes带参跳转"><a href="#用RedirectAttributes带参跳转" class="headerlink" title="用RedirectAttributes带参跳转:"></a>用RedirectAttributes带参跳转:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">hello</span><span class="params">(RedirectAttributes attrs)</span> </span>&#123;</span><br><span class="line">    attrs.addAttribute(<span class="string">"message"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    attrs.addFlashAttribute(<span class="string">"username"</span>, <span class="string">"sudoz"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">hello</span><span class="params">(@ModelAttribute(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">                              @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">    map.put(<span class="string">"username"</span>, username);</span><br><span class="line">    map.put(<span class="string">"message"</span>, message);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> mvc:annotation-driven是一种简写形式，完全可以手动配置替代这种简写形式，<code>&lt;mvc:annotation-driven /&gt;</code>会自动注册<code>DefaultAnnotationHandlerMapping</code>与<code>AnnotationMethodHandlerAdapter</code> 两个bean,是Spring MVC为<code>@Controllers</code>分发请求所必须的。<br>并提供了：数据绑定支持，<code>@NumberFormatannotation</code>支持，<code>@DateTimeFormat</code>支持，<code>@Valid支持</code>，读写XML的支持（JAXB），读写JSON的支持（Jackson）。</p><h3 id="Spring是如何处理返回类型的"><a href="#Spring是如何处理返回类型的" class="headerlink" title="Spring是如何处理返回类型的?"></a>Spring是如何处理返回类型的?</h3><p>DispatchServlet.viewResolvers的类型是<code>List&lt;ViewResolver&gt;</code>, Controller返回的类型转给DispatchServlet, 最终交给不同的ViewResolver处理的</p><h1 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h1><p>所有web应用的MVC框架都提供了视图相关的支持。Spring提供了一些视图解析器，它们让你能够在浏览器中渲染模型，并支持你自由选用适合的视图技术而不必与框架绑定到一起。<br>Spring原生支持JSP视图技术、Velocity模板技术和XSLT视图等。</p><p>有两个接口在Spring处理视图相关事宜时至关重要，分别是视图解析器接口ViewResolver和视图接口本身View。<br>视图解析器ViewResolver负责处理视图名与实际视图之间的映射关系。<br>视图接口View负责准备请求，并将请求的渲染交给某种具体的视图技术实现。</p><h2 id="使用ViewResolver接口解析视图"><a href="#使用ViewResolver接口解析视图" class="headerlink" title="使用ViewResolver接口解析视图"></a>使用ViewResolver接口解析视图</h2><p>Spring MVC中所有控制器的处理器方法都必须返回一个逻辑视图的名字，无论是显式返回（比如返回一个String、View或者ModelAndView）还是隐式返回（比如基于约定的返回）。<br>Spring中的视图由一个视图名标识，并由视图解析器来渲染。Spring有非常多内置的视图解析器。</p><h1 id="资源-Resource"><a href="#资源-Resource" class="headerlink" title="资源(Resource)"></a>资源(Resource)</h1><h2 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h2><p>Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。</p><p>路径通配符</p><ul><li><code>?</code>匹配一个字符，如<code>config?.xml</code>将匹配<code>config1.xml</code></li><li><code>*</code>匹配零个或多个字符串，如<code>cn/*/config.xml</code>将匹配<code>cn/javass/config.xml</code>，但不匹配匹配<code>cn/config.xml</code></li><li><code>**</code>匹配路径中的零个或多个目录，如<code>cn/**/config.xml</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Resource例子1:</span></span><br><span class="line">ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//只加载一个绝对匹配Resource，且通过ResourceLoader.getResource进行加载</span></span><br><span class="line">Resource[] resources=resolver.getResources(<span class="string">"classpath:META-INF/INDEX.LIST"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Resource例子2:</span></span><br><span class="line">ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//将加载多个绝对匹配的所有Resource</span></span><br><span class="line"><span class="comment">//将首先通过ClassLoader.getResources("META-INF")加载非模式路径部分</span></span><br><span class="line"><span class="comment">//然后进行遍历模式匹配</span></span><br><span class="line"><span class="comment">// classpath*： 用于加载类路径（包括jar包）中的所有匹配的资源</span></span><br><span class="line">Resource[] resources=resolver.getResources(<span class="string">"classpath*:META-INF/INDEX.LIST"</span>);</span><br></pre></td></tr></table></figure><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>静态资源包括：HTML、CSS、JS、图像、视频、PDF/Office等不需要服务器端处理的文件。</p><p>静态资源文件的位置:</p><ul><li>Java Web默认的静态资源文件夹是 src/main/webapp/</li><li>Spring Boot自动将src/main/resource/下的「/static」「/public」「/resources」「/META-INF/resources」识别为资源文件夹。 下面的css可以通过访问<code>http://localhost:8080/css/a.css</code>获取<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project Root</span><br><span class="line">└─src</span><br><span class="line">    └─ main</span><br><span class="line">        └─ resources</span><br><span class="line">            ├─ static</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ a.css</span><br><span class="line">            ├─ public</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ b.css</span><br><span class="line">            ├─ resources</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ b.css</span><br><span class="line">            └─ META-INF</span><br><span class="line">                └─ resources</span><br><span class="line">                    └─ css</span><br><span class="line">                        └─ d.css</span><br></pre></td></tr></table></figure></li></ul><h1 id="异常处理-Exception"><a href="#异常处理-Exception" class="headerlink" title="异常处理(Exception)"></a>异常处理(Exception)</h1><ol><li>Controller的匹配. 除了<code>value</code>指定url, 还可以通过<code>product</code>指定MIME-TYPE(参考网络协议HTTP)</li><li>调试的时候需要注意, <code>cURL</code>实际是使用了<code>Accept: */*</code>, 浏览器发出的请求是<code>Accept:text/html</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/return-text-plain"</span>, produces = MimeTypeUtils.TEXT_PLAIN_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">returnPlainText</span><span class="params">()</span> <span class="keyword">throws</span> SomeException </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> SomeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How to自定义Error页面:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDefaultErrorViewConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ThymeleafViewResolver thymeleafViewResolver;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> View <span class="title">error</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thymeleafViewResolver.resolveViewName(<span class="string">"custom-error-page/error"</span>, Locale.CHINA);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h1><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="Bean-Configuration-ContextConfiguration"><a href="#Bean-Configuration-ContextConfiguration" class="headerlink" title="@Bean, @Configuration, @ContextConfiguration"></a>@Bean, @Configuration, @ContextConfiguration</h3><ul><li>@Autowired: 可以写在属性上, 和setter方法上, 或者构造函数上, 默认按照类型进行装配</li><li>@Bean: 用于方法上, 该方法必须返回一个类型对象, 该对象被注册为Spring上下文中的bean, 注意方法名字将会作为bean的ID, 相当于在xml中定义<code>&lt;bean&gt;</code><ul><li>@Bean(initMethod=”aa”,destroyMethod=”bb”): 指定aa和bb方法分别在在构造之后/销毁之前执行</li></ul></li><li>@Configuration: 用于类上, 说明这个类可以使用Spring IoC容器作为bean定义的来源, 相当于在xml中定义<code>&lt;beans&gt;</code></li><li>@ContextConfiguration(classes=KnightConfig.class) 使用在类上, 表示使用<code>@Configuration</code>标注的类当作bean的定义来源</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义要注入的bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditorConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TextEditor <span class="title">textEditor</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TextEditor( spellChecker() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">spellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SpellChecker( );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的等同于在xml里定义了两个&lt;bean&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用从@Configuration标注类里注入的bean</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=KnightConfig.class,loader=AnnotationConfigContextLoader.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  TextEditor textEditor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpellChecker spellChecker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Component-ComponentScan"><a href="#Component-ComponentScan" class="headerlink" title="@Component, @ComponentScan"></a>@Component, @ComponentScan</h3><ul><li>@ComponentScan: 使用在类上, 可以扫描到<code>@Component</code>注解的类</li><li>@Component: 使用在类上, 表示可以被<code>@ComponentScan</code>标注的类扫描到</li></ul><blockquote><p>比较: <code>@Configuration</code> + <code>@Bean</code> 的方式需要在@Configuration的类里定义”返回每种Bean类型的方法”, <code>@ComponentScan</code> + <code>@Component</code>的方式省去了定义方法返回Bean的类型<br><code>@Configuration</code>, <code>@ComponentScan</code>, <code>@Component</code>注解通常联合起来使用, 免去了在xml里定义bean, 也不必写<code>@Bean</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123; <span class="keyword">this</span>.cd = cd; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扫描到的Bean:</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件注解-Service-Controller-Repository-Component"><a href="#组件注解-Service-Controller-Repository-Component" class="headerlink" title="组件注解: @Service, @Controller, @Repository, @Component"></a>组件注解: @Service, @Controller, @Repository, @Component</h3><ul><li>@Service: 用于注解Service层, 默认是单例的</li><li>@Controller: 定义控制器类一般这个注解在类中，通常方法需要配合注解 @RequestMapping</li><li>@RestController相当于<code>@ResponseBody</code>和<code>@Controller</code>的合集, 默认是单例的</li><li>@Repository用于注解DAO，这个注解修饰的DAO类会被ComponetScan发现并配置，同时也不需要为它们提供xml配置项</li><li>如果一个类不好归类, 则使用<code>@Component</code>注解</li><li>@PostConstruct/@PreDestroy 用在方法上</li></ul><p>Spring会自动扫描<code>base-package</code>指定的包下面用<code>@Service</code>注解的所有类, 并注册到beans容器里.<br>需要在Spring配置文件里增加: <code>&lt;context:component-scan base-package=&quot;com.xxx.product.core.service&quot;/&gt;</code> 来说明启用自动扫描</p><h3 id="装配注解-Autowired-Resource-Inject-Primary"><a href="#装配注解-Autowired-Resource-Inject-Primary" class="headerlink" title="装配注解: @Autowired, @Resource, @Inject, @Primary"></a>装配注解: @Autowired, @Resource, @Inject, @Primary</h3><ul><li>@Autowired和@Inject: 通过<code>AutowiredAnnotationBeanPostProcessor</code>来实现依赖注入, 顺序:<ol><li>按照类型匹配</li><li>使用限定符进行类型限定</li><li>按照名称匹配</li></ol></li><li>@Resource: 使用<code>CommonAnnotationBeanPostProcessor</code>来实现注入, 顺序:<ol><li>按照名称匹配</li><li>按照类型匹配</li><li>使用限定符进行类型限定</li></ol></li></ul><h3 id="数据库注解-Transcational-Cacheable"><a href="#数据库注解-Transcational-Cacheable" class="headerlink" title="数据库注解: @Transcational, @Cacheable"></a>数据库注解: @Transcational, @Cacheable</h3><ul><li>@Transcational : 事务处理</li><li>@Cacheable : 数据缓存</li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>默认是<code>@Scope(&quot;singleton&quot;)</code>单例的, 此外还有:</p><ul><li><code>singleton</code> 单例的</li><li><code>prototype</code> 表示每次获得bean都会生成一个新的对象</li><li><code>request</code> 表示在一次http请求内有效</li><li><code>session</code> 表示在一个用户会话内有效</li></ul><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"ImplementedClass"</span>)</span><br><span class="line">    <span class="keyword">private</span> AbstractClass a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当抽象类AbstractClass的实现类有多个时, 如果没有<code>Qualifier</code>注解则会报错, 因为Spring不知道应该注入哪个类型, 注意<code>@Qualifier()</code>括号里是类的名字</p><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h3><ul><li>@After @Before. @Around 定义切面,可以直接将拦截规则(切入点 PointCut)作为参数</li><li>@PointCut : 专门定义拦截规则 然后在 @After @Before. @Around 中调用</li><li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li></ul><h2 id="JDK注解"><a href="#JDK注解" class="headerlink" title="JDK注解"></a>JDK注解</h2><ul><li>@Resource: 可以写在属性上, 和setter方法上, 默认按照名称进行装配</li></ul><h1 id="Spring中的线程安全性"><a href="#Spring中的线程安全性" class="headerlink" title="Spring中的线程安全性"></a>Spring中的线程安全性</h1><p>参考自: <a href="https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/" target="_blank" rel="noopener">聊一聊Spring中的线程安全性 | SylvanasSun’s Blog</a> @ref</p><p>Spring作为一个IOC/DI容器，帮助我们管理了许许多多的“bean”。但其实，Spring并没有保证这些对象的线程安全，需要由开发者自己编写解决线程安全问题的代码。</p><p>Spring对每个bean提供了一个<code>scope</code>属性来表示该bean的作用域。它是bean的生命周期。例如，一个<code>scope</code>为<code>singleton</code>的bean，在第一次被注入时，会创建为一个单例对象，该对象会一直被复用到应用结束。</p><blockquote><p>singleton：默认的scope，每个scope为singleton的bean都会被定义为一个单例对象，该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。<br>prototype：bean被定义为在每次注入时都会创建一个新的对象。<br>request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。<br>session：bean被定义为在一个session的生命周期内创建一个单例对象。<br>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。<br>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。</p></blockquote><p>我们交由Spring管理的大多数对象其实都是一些无状态的对象，这种不会因为多线程而导致状态被破坏的对象很适合Spring的默认scope，每个单例的无状态对象都是线程安全的（也可以说只要是无状态的对象，不管单例多例都是线程安全的，不过单例毕竟节省了不断创建对象与GC的开销）。</p><p>无状态的对象即是自身没有状态的对象，自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题。无状态对象包括我们经常使用的DO、DTO、VO这些只作为数据的实体模型的贫血对象，还有Service、DAO和Controller，这些对象并没有自己的状态，它们只是用来执行某些操作的。例如，每个DAO提供的函数都只是对数据库的CRUD，而且每个数据库Connection都作为函数的局部变量（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题），用完即关（或交还给连接池）。</p><p>有人可能会认为，我使用request作用域不就可以避免每个请求之间的安全问题了吗？这是完全错误的，因为Controller默认是单例的，一个HTTP请求是会被多个线程执行的，这就又回到了线程的安全问题。当然，你也可以把Controller的scope改成prototype，实际上Struts2就是这么做的，但有一点要注意，Spring MVC对请求的拦截粒度是基于每个方法的，而Struts2是基于每个类的，所以把Controller设为多例将会频繁的创建与回收对象，严重影响到了性能。</p><p>通过阅读上文其实已经说的很清楚了，Spring根本就没有对bean的多线程安全问题做出任何保证与措施。对于每个bean的线程安全问题，根本原因是每个bean自身的设计。不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用<code>ThreadLocal</code>把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用<code>synchronized</code>、<code>lock</code>、<code>CAS</code>等这些实现线程同步的方法了。</p><h1 id="对”约定优于配置”的支持"><a href="#对”约定优于配置”的支持" class="headerlink" title="对”约定优于配置”的支持"></a>对”约定优于配置”的支持</h1><blockquote><p>约定优于配置（convention over configuration)，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。<br>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。<br>许多新的框架使用了约定优于配置的方法，包括：Spring，Ruby on Rails，Kohana PHP，Grails，Grok，Zend Framework，CakePHP，symfony，Maven，ASP.NET MVC，Web2py（MVC），Apache Wicket。<br>比如Maven对目录做了”约定优于配置”的设定:</p><blockquote><p>   src/main/resources: 资源文件目录;<br>   src/main/java: Java源码目录;<br>   src/main/webapp: web应用文件目录（当打包为war时），如WEB-INF/web.xml</p></blockquote></blockquote><h1 id="对JDBC的支持"><a href="#对JDBC的支持" class="headerlink" title="对JDBC的支持"></a>对JDBC的支持</h1><p>Spring主要提供JDBC模板方式、关系数据库对象化方式和SimpleJdbc方式三种方式来简化JDBC编程，这三种方式就是Spring JDBC的工作模式：</p><ul><li>JDBC模板方式：Spring JDBC框架提供以下几种模板类来简化JDBC编程，实现GoF模板设计模式，将可变部分和非可变部分分离，可变部分采用回调接口方式由用户来实现：如JdbcTemplate、NamedParameterJdbcTemplate、SimpleJdbcTemplate。</li><li>关系数据库操作对象化方式：Spring JDBC框架提供了将关系数据库操作对象化的表示形式，从而使用户可以采用面向对象编程来完成对数据库的访问；如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类。这些类的实现一旦建立即可重用并且是线程安全的。</li></ul><h2 id="JDBC模板"><a href="#JDBC模板" class="headerlink" title="JDBC模板"></a>JDBC模板</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;</span><br><span class="line">        jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                String value = rs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Column TABLENAME:"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert into test(name) values('name1')"</span>);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"delete from test where name=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">"name2"</span>&#125;);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update test set name='name3' where name=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">"name1"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关系数据库对象化"><a href="#关系数据库对象化" class="headerlink" title="关系数据库对象化"></a>关系数据库对象化</h2><h1 id="对MyBatis的支持"><a href="#对MyBatis的支持" class="headerlink" title="对MyBatis的支持"></a>对MyBatis的支持</h1><p>参考<a href="http://www.mybatis.org/spring/zh/getting-started.html" target="_blank" rel="noopener">mybatis-spring – MyBatis-Spring | 第二章 入门</a> @ref</p><h2 id="1-引入mybatis-spring依赖"><a href="#1-引入mybatis-spring依赖" class="headerlink" title="1. 引入mybatis-spring依赖"></a>1. 引入mybatis-spring依赖</h2><h2 id="2-SqlSessionFactoryBean"><a href="#2-SqlSessionFactoryBean" class="headerlink" title="2. SqlSessionFactoryBean"></a>2. SqlSessionFactoryBean</h2><ul><li>增加<code>dataSource</code>的定义, dataSource可以使用DruidDataSource或者自己实现的类</li><li>增加sqlSessionFactory的bean, mapperLocations指定mapper.xml的位置</li><li>增加<code>transactionManager</code>的bean, 开启Spring事务</li><li>增加<code>MapperScannerConfigurer</code>, 它将会查找类路径下的映射器并自动将它们创建成MapperFactoryBean, 而不是注册xml配置文件中注册所有的Mapper</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 要注意 SqlSessionFactory 需要一个 dataSource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/**/*.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义注解驱动事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置扫描包，加载mapper代理对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.kuaizhan.kzweixin.dao.mapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="对Transaction的支持"><a href="#对Transaction的支持" class="headerlink" title="对Transaction的支持"></a>对Transaction的支持</h1><ul><li><code>@Transactional(value=&quot;transactionManagerPrimary&quot;, isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED)</code><ul><li>value: 事务管理器</li><li>隔离级别（isolation）:<ul><li>DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。</li><li>READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li><li>READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的<strong>推荐值</strong>。</li><li>REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li><li>SERIALIZABLE：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul></li><li>传播行为（Propagation）:所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。<ul><li>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>这是最常见的选择。</strong></li><li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。</li></ul></li></ul></li></ul><h1 id="Spring-MVC-Step-by-Step-Deprecated"><a href="#Spring-MVC-Step-by-Step-Deprecated" class="headerlink" title="Spring MVC Step by Step @Deprecated"></a>Spring MVC Step by Step @Deprecated</h1><ol><li>Pom.xml<ul><li>build - resources # 定义资源文件?</li></ul></li><li>webapp/WEB-INF/web.xml<ul><li>context-param: contextConfigLocation=classpath<em>:spring/appcontext-</em>.xml # 指定<code>Spring配置</code>路径</li><li>listener:  # listen优先级&gt;Servlet<ul><li>ContextLoaderListener=org.springframework.web.context.ContextLoaderListener</li><li>RequestContextListener=org.springframework.web.context.request.RequestContextListener</li></ul></li><li>servlet: org.springframework.web.servlet.DispatcherServlet<ul><li>init-param: contextConfigLocation=classpath:appcontext-core-web.xml # 指定<code>Servlet配置</code>路径</li></ul></li></ul></li><li>Spring配置xml: 默认去找classpath下的application-Context.xml,这是一种约定优于配置的概念<ul><li>context:property-placeholder: 指定<code>*.properties</code>位置</li><li>mvc:interceptors // 定义拦截器</li><li>mvc:annotation-driven // 注册DefaultAnnotationHandlerMapping/AnnotationMethodHandlerAdapter, 用于支持@Controller等注解风格</li><li>mvc:resources # css/js/htm等静态资源映射</li><li>增加View解析器:<ul><li>bean id=”velocityConfigurer” class=”org.springframework.web.servlet.view.velocity.VelocityConfigurer”</li><li>bean id=”viewResolver” class=”org.springframework.web.servlet.view.velocity.VelocityViewResolver”</li></ul></li><li>增加多数据源<ul><li>bean id=”parentDataSource” class=”org.springframework.jdbc.datasource.DriverManagerDataSource”</li><li>bean id=”adminDataSource” parent=”parentDataSource” # 数据源1</li><li>bean id=”userDataSource”  parent=”parentDataSource” # 数据源2</li><li>bean id=”dataSource” class=”com.frogking.datasource.DynamicDataSource” # 多数源映射关系, property增加上面两个bean</li><li>bean id=”sessionFactory” class=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</li></ul></li></ul></li></ol><h1 id="附-Configuration-XML说明"><a href="#附-Configuration-XML说明" class="headerlink" title="附: Configuration XML说明"></a>附: Configuration XML说明</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring/appcontext-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span> <span class="attr">id</span>=<span class="string">"ContextLoaderListener"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span> <span class="attr">id</span>=<span class="string">"RequestContextListener"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/2/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:appcontext-core-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>400<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 13.J2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot</title>
      <link href="/13.JavaEE-Framework/JavaEE.SpringBoot/"/>
      <url>/13.JavaEE-Framework/JavaEE.SpringBoot/</url>
      
        <content type="html"><![CDATA[<p><img src="https://sdtimes.com/wp-content/uploads/2018/03/spring-boot-490x257.png" alt="Spring Boot"></p><h1 id="Spring-Boot-vs-Spring"><a href="#Spring-Boot-vs-Spring" class="headerlink" title="Spring Boot vs Spring"></a>Spring Boot vs Spring</h1><ul><li>内置了嵌入式的Tomcat、Jetty等Servlet容器，应用可以不用打包成War格式，而是可以直接以Jar格式运行</li><li>Spring Boot提倡无XML配置文件的理念，使用Spring Boot生成的应用完全不会生成任何配置代码与XML配置文件。</li><li>提供了多个可选择的「starter」:<ul><li>spring-boot-starter-data-redis:</li><li>spring-boot-starter-activemq:</li><li>spring-boot-starter-jdbc:</li><li>spring-boot-starter-web:</li><li>spring-boot-starter-actuator:</li></ul></li></ul><h1 id="Spring-Boot-全家桶-简介"><a href="#Spring-Boot-全家桶-简介" class="headerlink" title="Spring Boot 全家桶(简介)"></a>Spring Boot 全家桶(简介)</h1><p>@todo</p><h1 id="Spring-Boot-的新注解"><a href="#Spring-Boot-的新注解" class="headerlink" title="Spring Boot 的新注解"></a>Spring Boot 的新注解</h1><ul><li><code>@SpringBootApplication</code>: 相当于 <code>@Configuration + @EnableAutoConfiguration + @ComponentScan</code><ul><li><code>@Configuration</code> : 指明是IOC容器的配置类, 被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。</li><li><code>@EnableAutoConfiguration</code>  : SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。</li><li><code>@ComponentScan</code> : 组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。</li></ul></li><li><code>@RestController</code>: 作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON或者是XML。使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，效果等同于通过向<code>response.getOutputStream()</code>写入数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:spring/spring-main.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApiApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApiApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Cloud-amp-微服务"><a href="#Spring-Cloud-amp-微服务" class="headerlink" title="Spring Cloud &amp; 微服务"></a>Spring Cloud &amp; 微服务</h1><p>@todo</p>]]></content>
      
      
      <categories>
          
          <category> 13.J2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servelt and JSP</title>
      <link href="/13.JavaEE-Framework/JavaEE.Servlet/"/>
      <url>/13.JavaEE-Framework/JavaEE.Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Web应用"><a href="#Java-Web应用" class="headerlink" title="Java Web应用"></a>Java Web应用</h1><p>Java Web 应用是一个 servlets, HTML 页面,类,和其他资源的集合，用于一个在 Web 服务器的完成的应用。Web 应用可以捆绑和运行来自多个供应商的在多个容器。<br>servlet 容器必须强制 Web 应用程序和 ServletContext 之间一对一对应的关系。ServletContext 对象提供了一个 servlet 和它的应用程序视图。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>可以使用标准的 Java 归档工具把 Web 应用程序打包并签名到一个 Web 存档格式（WAR）文件中。例如，一个关于“issue tracking”的应用程序可以分布在一个称为 issuetrack.war 的归档文件中。</p><p>当打包成这种形式时，将生成一个 META-INF 目录，其中包含了对 java归档工具有用的信息。尽管这个目录的内容可以通过 servlet 代码调用ServletContext 的 getResource 和 getResourceAsStream 方法来访问，容器也不能把这个目录当作内容来响应客户端请求。此外，任何请求访问 META-INF 目录中的资源必须返回一个 SC_NOT_FOUND（404）的响应。常见的归档格式war 和 ear格式对比：</p><ul><li><p>war: Web Archive file, 结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webapp.war</span><br><span class="line">  |-index.jsp</span><br><span class="line">  |— META-INF</span><br><span class="line">    |-Manifest.mf</span><br><span class="line">  |— WEB-INF</span><br><span class="line">       |- web.xml</span><br><span class="line">       |— classes</span><br><span class="line">       |— lib  // 依赖的jar包</span><br></pre></td></tr></table></figure></li><li><p>ear: Enterprise ARchieve, 用于在Java EE中将一个或者多个模块封装到一个文件中, 这样, 多个不同模块在应用服务器上的部署就可以同时并持续的进行. 结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.ear</span><br><span class="line">   |- ejb.jar    // ejb-jar包</span><br><span class="line">   |- other.jar  // 普通jar包</span><br><span class="line">   |- webapp.war  // war包</span><br><span class="line">   |—META-INF</span><br><span class="line">        application.xml  // EAR描述文件</span><br></pre></td></tr></table></figure></li></ul><h2 id="Web-xml"><a href="#Web-xml" class="headerlink" title="Web.xml"></a>Web.xml</h2><blockquote><p>servlet3.*的规范已经支持不使用 web.xml了</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>HelloWorld Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">        This is a simple web application with a source code organization</span><br><span class="line">        based on the recommendations of the Application Developer's Guide.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.web.listener.MyServletRequestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.web.listener.MyServletContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ResponseFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.web.filter.ResponseFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ResponseFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.web.Servlet.Hello<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Servlet（Server-Applet）"><a href="#Servlet（Server-Applet）" class="headerlink" title="Servlet（Server Applet）"></a>Servlet（Server Applet）</h1><p>本节参考自: <a href="https://www.gitbook.com/book/waylau/servlet-3-1-specification/details" target="_blank" rel="noopener">Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a> @ref</p><h2 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h2><p>servlet 是基于 Java 的 Web 组件，由容器进行管理，来生成动态内容。像其他基于 Java 的组件技术一样，servlet 也是基于平台无关的 Java 类格式，被编译为平台无关的字节码，可以被基于 Java 技术的 Web 服务器动态加载并运行。容器（Container），有时候也叫做 servlet 引擎，是 Web 服务器为支持 servlet 功能扩展的部分。客户端通过 servlet 容器实现的 request/response paradigm（请求/应答模式） 与 Servlet 进行交互。</p><h2 id="什么是-Servlet-容器"><a href="#什么是-Servlet-容器" class="headerlink" title="什么是 Servlet 容器"></a>什么是 Servlet 容器</h2><p>Servlet Container（Servlet 容器） 是 Web 服务器或者应用服务器的一部分，用于提供基于请求/响应发送模式的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器同时也包含和管理他们的生命周期里 Servlet。<br>Servlet 容器可以嵌入到宿主的 Web 服务器中，或者通过 Web 服务器的本地扩展 API 单独作为附加组件安装。Servelt 容器也可能内嵌或安装到启用 Web 功能的应用服务器中。<br>所有的 Servlet 容器必须支持 HTTP 协议用于请求和响应，但额外的基于 请求/响应 的协议，如 HTTPS (HTTP over SSL)的支持是可选的。对于 HTTP 规范需要版本，容器必须支持 HTTP/1.0 和 HTTP/1.1。因为容器或许支持 RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给 Servlet 处理之前修改它们，也可能在将 Servlet 生成的响应发送给客户端之前修改它们，或者可能根据 RFC2616 规范直接对请求作出响应而不交给 Servlet 进行处理。<br>Servlet 容器应该使 Servlet 执行在一个安全限制的环境中。在 Java 平台标准版（J2SE, v.1.3 或更高） 或者 Java平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在 Java 平台定义的安全许可架构中。比如，高端的应用服务器为了保证容器的其他组件不受到负面影响可能会限制 Thread 对象的创建。</p><h2 id="Servlet-与其他技术的对比"><a href="#Servlet-与其他技术的对比" class="headerlink" title="Servlet 与其他技术的对比"></a>Servlet 与其他技术的对比</h2><p>从功能上看，servlet 位于 Common Gateway Interface（公共网关接口，简称 CGI）程序和私有的服务器扩展如 Netscape Server API（NSAPI）或 Apache Modules 这两者之间。<br>相对于其他服务器扩展机制 Servlet 有如下优势：</p><ul><li>它们通常比 CGI 脚本更快，因为采用不同的处理模型。</li><li>它们采用标准的 API 从而支持更多的Web 服务器。</li><li>它们拥有 Java 编程语言的所有优势，包括容易开发和平台无关。</li><li>它们可以访问 Java 平台提供的大量的 API。</li></ul><h2 id="与-Java-EE-的关系"><a href="#与-Java-EE-的关系" class="headerlink" title="与 Java EE 的关系"></a>与 Java EE 的关系</h2><p>Java Servlet API 3.1 版本是 Java 平台企业版 7 版本必须的 API。Servlet 容器和 servlet 被部署到平台中时，为了能在 Java EE 环境中执行，必须满足 JavaEE 规范中描述的额外的一些要求。</p><h2 id="与-Servlet-2-5-规范的兼容性"><a href="#与-Servlet-2-5-规范的兼容性" class="headerlink" title="与 Servlet 2.5 规范的兼容性"></a>与 Servlet 2.5 规范的兼容性</h2><p>在 Servlet 2.5 中, metadata-complete 只影响在部署时的注释扫描。 web-fragments 的概念在 servlet 2.5 并不存在。然而在 servlet 3.0 和之后,metadata-complete 影响扫描所有的在部署时指定部署信息和 web-fragments 注释。注释的版本的描述符必须不影响你扫描在一个web应用程序。除非 metadata-complete 指定，规范的一个特定版本的实现必须扫描所有配置的支持的注解。</p><h2 id="HttpServletRequest-–-请求"><a href="#HttpServletRequest-–-请求" class="headerlink" title="HttpServletRequest – 请求"></a>HttpServletRequest – 请求</h2><p>本节参考 <a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Request/3.%20The%20Request.html" target="_blank" rel="noopener">请求 · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a> @ref</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个请求对象只在一个 servlet 的 service 方法的作用域内，或过滤器的 doFilter 方法的作用域内有效，除非该组件启用了异步处理并且调用了请求对象的 startAsync 方法。<br>在发生异步处理的情况下，请求对象一直有效，直到调用 AsyncContext 的 complete 方法。容器通常会重复利用请求对象，以避免创建请求对象而产生的性能开销。<br>开发人员必须注意的是，不建议在上述范围之外保持 startAsync 方法还没有被调用的请求对象的引用，因为这样可能产生不确定的结果。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>ServletRequest 接口提供方法:</p><ul><li>getParameter</li><li>getParameterNames</li><li>getParameterValues</li><li>getParts</li><li>getPart</li><li>getAttribute</li><li>getHeader/getHeaders</li><li>getContextPath</li><li>…</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>当数据以multipart/form-data的格式发送时，servlet 容器支持文件上传。</p><h3 id="头"><a href="#头" class="headerlink" title="头"></a>头</h3><ul><li>getAttribute</li><li>getAttributeNames</li><li>setAttribute</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>getAttribute</li><li>getAttributeNames</li><li>setAttribute</li></ul><h3 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h3><ul><li>getContextPath</li><li>getServletPath</li><li>getPathInfo</li></ul><p>requestURI = contextPath + servletPath + pathInfo</p><h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><p><a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Request/3.7%20Non%20Blocking%20IO.html" target="_blank" rel="noopener">非阻塞 IO · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a></p><h2 id="ServletResponse-–-响应"><a href="#ServletResponse-–-响应" class="headerlink" title="ServletResponse – 响应"></a>ServletResponse – 响应</h2><p><a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Response/5%20The%20Response.html" target="_blank" rel="noopener">响应 · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a></p><h2 id="ServletContext-–-上下文"><a href="#ServletContext-–-上下文" class="headerlink" title="ServletContext – 上下文"></a>ServletContext – 上下文</h2><p>ServletContext 接口定义了 servlet 运行在的 Web 应用的视图。容器供应商负责提供 servlet 容器的 ServletContext 接口的实现。servlet 可以使用 ServletContext 对象记录事件，获取 URL 引用的资源，存取当前上下文的其他 servlet 可以访问的属性。<br>ServletContext 是 Web 服务器中已知路径的根。例如，servlet 上下文可以从 <a href="http://www.mycorp.com/catalog" target="_blank" rel="noopener">http://www.mycorp.com/catalog</a> 找出，/catalog 请求路径称为上下文路径，所有以它开头的请求都会被路由到与 ServletContext 相关联的 Web 应用。</p><h2 id="Filter-–-过滤器"><a href="#Filter-–-过滤器" class="headerlink" title="Filter – 过滤器"></a>Filter – 过滤器</h2><p>过滤器是一种代码重用的技术，它可以转换 HTTP 请求的内容，响应，及头信息。过滤器通常不产生响应或像 servlet 那样对请求作出响应，而是修改或调整到资源的请求，修改或调整来自资源的响应。</p><p>在web.xml中声明的每个<code>&lt;filter&gt;</code>在每个 JVM 的容器中仅实例化一个实例。容器提供了声明在过滤器的部署描述符的过滤器config（译者注：FilterConfig），对 Web 应用的 ServletContext 的引用，和一组初始化参数。<br>当容器接收到传入的请求时，它将获取列表中的第一个过滤器并调用<code>doFilter</code> 方法，传入 ServletRequest 和 ServletResponse，和一个它将使用的 FilterChain 对象的引用。</p><h3 id="过滤器组件示例"><a href="#过滤器组件示例" class="headerlink" title="过滤器组件示例"></a>过滤器组件示例</h3><ul><li>Authentication filters //用户身份验证过滤器</li><li>Logging and auditing filters //日志记录与审计过滤器</li><li>Image conversion filters //图片转换过滤器</li><li>Data compression filters //数据压缩过滤器</li><li>Encryption filters //加密过滤器</li><li>Tokenizing filters //分词过滤</li><li>Filters that trigger resource access events //触发资源访问事件过滤</li><li>XSL/T filters that transform XML content</li><li>MIME-type chain filters //MIME-TYPE 链过滤器</li><li>Caching filters //缓存过滤器</li></ul><h2 id="Listener-–-监听器"><a href="#Listener-–-监听器" class="headerlink" title="Listener – 监听器"></a>Listener – 监听器</h2><p>Listener 用于监听 java web程序中的事件，例如创建、修改、删除Session、request、context等，并触发响应的事件。<br>Listener 对应观察者模式，事件发生的时候会自动触发该事件对应的Listeer。 Listener 主要用于对 Session、Request、Context 进行监控。servlet2.5 规范中共有 8 种Listener 。</p><p>不同功能的Listener 需要实现不同的 Listener  接口，一个Listener也可以实现多个接口，这样就可以多种功能的监听器一起工作。监听器接口可以分为三类：</p><ul><li>1）监听 Session、Request、Context 的创建于销毁，分别为  <code>HttpSessionLister</code>、<code>ServletContextListener</code>、<code>ServletRequestListener</code></li><li>2）监听对象属性变化，分别为：<code>HttpSessionAttributeLister</code>、<code>ServletContextAttributeListener</code>、<code>ServletRequestAttributeListener</code></li><li>3）监听Session 内的对象，分别为<code>HttpSessionBindingListener</code> 和 <code>HttpSessionActivationListener</code>。与上面六类不同，这两类 Listener 监听的是Session 内的对象，而非 Session 本身，不需要在 <code>web.xml</code>中配置。</li></ul><h3 id="实现一个Listener"><a href="#实现一个Listener" class="headerlink" title="实现一个Listener"></a>实现一个Listener</h3><p>web.xml的Listener配置： <code>&lt;listener&gt;</code>标签与 <code>&lt;listener-class&gt;</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>servlet.listener.MyListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建 MyListener, 实现监听对Session, Context, Request对象的创建与销毁:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span>, <span class="title">ServletContextListener</span>, <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 session</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">log.info(<span class="string">"新创建一个session, ID为: "</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁 session</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">log.info(<span class="string">"销毁一个session, ID为: "</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 context</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">ServletContext servletContext = sce.getServletContext();</span><br><span class="line">log.info(<span class="string">"即将启动"</span> + servletContext.getContextPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载 context</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">ServletContext servletContext = sce.getServletContext();</span><br><span class="line">log.info(<span class="string">"即将关闭"</span> + servletContext.getContextPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpSession-–-会话"><a href="#HttpSession-–-会话" class="headerlink" title="HttpSession – 会话"></a>HttpSession – 会话</h2><p>会话跟踪机制:</p><ul><li>Cookie: 通过 HTTP cookie 的会话跟踪是最常用的会话跟踪机制，且所有 servlet 容器都应该支持。所有 servlet 容器必须提供能够配置容器是否标记会话跟踪 cookie 为HttpOnly的能力。</li><li>SSL会话: 安全套接字层(Secure Sockets Layer)，在 HTTPS 使用的加密技术，有一种内置机制允许多个来自客户端的请求被明确识别为同一会话。Servlet容器可以很容易地使用该数据来定义会话。</li><li>URL 重写: URL 重写是会话跟踪的最低标准。当客户端不接受 cookie 时，服务器可使用 URL 重写作为会话跟踪的基础。URL 重写涉及添加数据、会话 ID、容器解析 URL 路径从而请求与会话相关联。</li></ul><h2 id="Dispatcher-–-分发器"><a href="#Dispatcher-–-分发器" class="headerlink" title="Dispatcher – 分发器"></a>Dispatcher – 分发器</h2><p>RequestDispatcher 接口负责把请求转发给一个 servlet 处理；<br>当请求启用异步处理时，AsyncContext 允许用户将这个请求转发到servlet 容器。</p><p>可以通过<code>ServletContext.getRequestDispatcher()</code>获取 RequestDispatcher.</p><p>使用请求调度器:</p><ul><li><code>include</code> 方法: include 方法的目标 servlet 能够访问请求对象的各个方法（all aspects），但是使用响应对象的方法会受到更多限制。</li><li><code>forward</code> 方法: RequestDispatcher 接口的 <code>forward()</code> 方法，只有在没有输出提交到向客户端时，通过正在被调用的 servlet 调用。如果响应缓冲区中存在尚未提交的输出数据，这些数据内容必须在目标 servlet 的 <code>service()</code> 方法调用前清除。如果响应已经提交，必须抛出一个 <code>IllegalStateException</code> 异常。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String path = “/raisins.jsp”;</span><br><span class="line">RequestDispatcher rd = context.getRequestDispatcher(path);</span><br><span class="line">rd.include(request, response);</span><br></pre></td></tr></table></figure><h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><p>当容器启动后, 容器会判断内存中是否存在指定的 Servlet对象, 如果没有则创建它, 当容器停止或者重新启动, Servlet容器调用 Servlet对象的 destroy方法来释放资源;<br>Servlet生命周期分几个步骤: Servlet类加载 -&gt; 实例化 -&gt; 服务 -&gt; 销毁:</p><ul><li>Servlet容器 负责加载 Servlet类</li><li>Servlet容器 使用开始实例化 Servlet, 创建对象并调用 init()方法</li><li>响应客户请求阶段调用 service()方法</li><li>销毁阶段调用 destroy()方法</li></ul><h3 id="Request-生命周期"><a href="#Request-生命周期" class="headerlink" title="Request 生命周期"></a>Request 生命周期</h3><p>接收到HTTP请求后, 容器会创建 HttpServletRequest对象, 并传递给 Servlet, 在这次请求结束后, Request对象也被销毁;<br>每个请求对象只在一个 servlet 的 <code>service()</code> 方法的作用域内, 或过滤器的 <code>doFilter()</code> 方法的作用域内有效,<br>除非该组件启用了异步处理并且调用了请求对象的 <code>startAsync()</code> 方法. 在发生异步处理的情况下, 请求对象一直有效, 直到调用 AsyncContext 的 <code>complete()</code> 方法.</p><h2 id="并发-amp-多线程问题"><a href="#并发-amp-多线程问题" class="headerlink" title="并发 &amp; 多线程问题"></a>并发 &amp; 多线程问题</h2><p>Servlet采用多线程来处理多个请求同时访问，Servlet容器维护了一个线程池来服务请求。<br>线程池实际上是等待执行代码的一组线程叫做工作者线程(WorkerThread)，Servlet容器使用一个调度线程来管理工作者线程(DispatcherThread)。<br>当容器收到一个访问Servlet的请求，调度者线程从线程池中选出一个工作者线程，将请求传递给该线程，然后由该线程来执行Servlet的<code>service()</code>方法。<br>当这个线程正在执行的时候，容器收到另外一个请求，调度者线程将从池中选出另外一个工作者线程来服务新的请求，容器并不关心这个请求是否访问的是同一个Servlet还是另外一个Servlet。当容器同时收到对同一Servlet的多个请求，那这个Servlet的<code>service()</code>方法将在多线程中并发的执行。</p><p>同步<code>service()</code>的两种方式:</p><ul><li>Servlet实现<code>SingleThreadModel</code>接口: 开发人员实现 SingleThreadModel 接口，由容器保证一个 <code>service()</code> 方法在同一个时间点仅被一个请求线程调用，但是此方案是不推荐的。servlet 容器可以通过串行化访问 servlet的请求，或者维护一个 servlet 实例池完成该需求。如果 Web 应用中的 servlet 被标注为分布式的，容器应该为每一个分布式应用程序的 JVM 维护一个 servlet 实例池。</li><li>synchronized同步<code>service()</code>方法, 不建议使用: 对于那些没有实现 <code>SingleThreadModel</code> 接口的 servlet，但是它的<code>service()</code> 方法（或者是那些 HttpServlet 中通过 service 方法分派的doGet、doPost 等分派方法）是通过 synchronized 关键词定义的，servlet 容器不能使用实例池方案，并且只能使用序列化请求进行处理。强烈推荐开发人员不要去同步 <code>service()</code> 方法（或者那些由 <code>service()</code> 分派的方法），因为这将严重影响性能。</li></ul><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>这就导致了Servlet里的实例变量是线程不安全的,多个线程（多个客户端的请求）共享这些实例变量，一个线程对这些实例变量的改变会影响其它线程的取值，Servlet规范已经声明Servlet不是线程安全的,包括jsp,Servlet,javabean等。</p><blockquote><p>ServletContext：（线程不安全）</p></blockquote><p>ServletContext是可以多线程同时读/写属性的，线程是不安全的。要对属性的读写进行同步处理或者进行深度Clon。所以在Servlet上下文中尽可能少量保存会被修改（写）的数据，可以采取其他方式在多个Servlet中共享，比方我们可以使用单例模式来处理共享数据。</p><blockquote><p>HttpSession：（线程不安全）</p></blockquote><p>HttpSession对象在用户会话期间存在，只能在处理属于同一个Session的请求的线程中被访问，因此Session对象的属性访问理论上是线程安全的。当用户打开多个同属于一个进程的浏览器窗口，在这些窗口的访问属于同一个Session，会出现多次请求，需要多个工作线程来处理请求，可能造成同时多线程读写属性。这时我们需要对属性的读写进行同步处理：使用同步块Synchronized和使用读/写器来解决。</p><blockquote><p>ServletRequest：（线程安全）</p></blockquote><p>对于每一个请求，由一个工作线程来执行，都会创建有一个新的ServletRequest对象，所以ServletRequest对象只能在一个线程中被访问。ServletRequest是线程安全的。ServletRequest对 象在service方法的范围内是有效的，不要试图在service方法结束后仍然保存请求对象的引用。</p><p><a href="http://wenboo.site/2016/11/14/Servlet-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">http://wenboo.site/2016/11/14/Servlet-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/</a></p><h2 id="异步-amp-AsyncContext"><a href="#异步-amp-AsyncContext" class="headerlink" title="异步 &amp; AsyncContext"></a>异步 &amp; AsyncContext</h2><p>@ref <a href="https://www.cnblogs.com/davenkin/p/async-servlet.html" target="_blank" rel="noopener">Servlet 3.0/3.1 中的异步处理</a></p><blockquote><p>在Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求，即每一次Http请求都由某一个线程从头到尾负责处理。如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待IO操作完成， 而IO操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。<br>为了解决这样的问题，Servlet 3.0引入了异步处理，然后在Servlet 3.1中又引入了非阻塞IO来进一步增强异步处理的性能。</p></blockquote><p>在Servlet 3.0中，<code>@WebServlet</code> 和 <code>@WebFilter</code> 注解有一个属性——<code>asyncSupported</code>，boolean 类型默认值为 false。<br>当 <code>asyncSupported</code> 设置为 true，我们可以从HttpServletRequest对象中通过<code>startAsync()</code>获得一个AsyncContext对象，AsyncContext对象构成了异步处理的上下文，Request和Response对象都可从中获取。<br>AsyncContext 可以从当前线程传给另外的线程，并在新的线程中完成对请求的处理并返回结果给客户端，当前请求的线程便可以还回给容器线程池以处理更多的请求。</p><p>一个有较长耗时操作的Servlet可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/simpleAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        asyncContext.start(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过<code>request.startAsync()</code>获取到该请求对应的<code>AsyncContext</code>，然后调用<code>AsyncContext</code>的<code>start()</code>方法进行异步处理，处理完毕后需要调用<code>AsyncContext.complete()</code>方法告知Servlet容器。<br><code>AsyncContext.start()</code>方法会向Servlet容器另外申请一个新的线程（可以是从Servlet容器中已有的主线程池获取，也可以另外维护一个线程池，不同容器实现可能不一样），然后在这个新的线程中继续处理请求，而原先的线程将被回收到主线程池中。<br>事实上，这种方式对性能的改进不大，因为如果新的线程和初始线程共享同一个线程池的话，相当于闲置下了一个线程，但同时又占用了另一个线程。</p><p>这里有一篇文章<a href="https://dzone.com/articles/limited-usefulness" target="_blank" rel="noopener">The Limited Usefulness of AsyncContext.start() - DZone Java</a>,<br>对该方法做了性能测试, 结论如下 :</p><ul><li>Tomcat的 <code>AsyncContext.start</code>实现是, 把处理Request的线程返回线程池, 再从 Http work threadpool里取出线程</li><li>相比不使用异步的情况, 在 Tomcat中使用 Servlet3.0 的 <code>AsyncContext.start</code> 不会带来任何 Tomcat并发性能改进</li><li>正确的办法是另外维护一个线程池，这个线程池不同于Servlet容器的主线程池（请求线程池），如下图：</li></ul><p><img src="/images/javaee/javaee_servlet_async.png" alt=""></p><p>在上图中，用户发起的请求首先交由Servlet容器主线程池（请求线程池）中的线程处理，在该线程中，我们获取到AsyncContext，然后将其交给异步处理线程池。<br>请求线程可以被归还回主线程池，这样主线程池用来处理 Http请求的线程没有被长时间占用。<br>但是需要注意的是，这种做法可以及时归还主线程池，但在仍旧占用另一个线程，所以 JVM的线程总数没有减少，系统瓶颈仍旧在 JVM进程的最大线程数上（单个线程的栈大小默认是<code>-Xss1M</code>）</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/threadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Requet-和-Response的非阻塞IO"><a href="#Requet-和-Response的非阻塞IO" class="headerlink" title="Requet 和 Response的非阻塞IO"></a>Requet 和 Response的非阻塞IO</h3><p>Servlet 3.0对请求的处理虽然是异步的，但是对<code>InputStream</code>和<code>OutputStream</code>的IO操作却依然是阻塞的，对于数据量大的请求体或者返回体，阻塞IO也将导致不必要的等待。因此在Servlet 3.1中引入了非阻塞IO（参考下图红框内容），通过在<code>HttpServletRequest</code>和<code>HttpServletResponse</code>中分别添加<code>ReadListener</code>和<code>WriterListener</code>方式，只有在IO数据满足一定条件时（比如数据准备好时），才进行后续的操作。</p><p><img src="/images/javaee/javaee_servlet_non_block_io.png" alt=""></p><p>对应的代码示例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/nonBlockingThreadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockingAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        ServletInputStream inputStream = request.getInputStream();</span><br><span class="line">        inputStream.setReadListener(<span class="keyword">new</span> ReadListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataAvailable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAllDataRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    asyncContext.complete();</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，我们为<code>ServletInputStream</code>添加了一个<code>ReadListener</code>，并在<code>ReadListener</code>的<code>onAllDataRead()</code>方法中完成了长时处理过程。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>servlet 在处理一个请求时可能抛出 <code>ServletException</code> 或<code>UnavailableException</code> 异常。</p><ul><li><code>ServletException</code> 表示在处理请求时出现了一些错误，容器应该采取适当的措施清理掉这个请求。</li><li><code>UnavailableException</code> 表示 servlet 目前无法处理请求，或者临时性的或者永久性的：<ul><li>如果 <code>UnavailableException</code> 表示的是一个永久性的不可用，servlet 容器必须从服务中移除这个 servlet，调用它的 destroy 方法，并释放servlet 实例。所有被容器拒绝的请求，都会返回一个 <code>SC_NOT_FOUND</code> (404) 响应。</li><li>如果 <code>UnavailableException</code> 表示的是一个临时性的不可用，容器可以选择在临时不可用的这段时间内路由任何请求到 Servlet。所以在这段时间内被容器拒绝的请求，都会返回一个 <code>SC_SERVICE_UNAVAILABLE</code> (503) 响应状态码，且同时会返回一个 Retry-After 头指示此 servlet 什么时候可用。容器可以选择忽略永久性和临时性不可用的区别，并把<code>UnavailableException</code> 视为永久性的，从而 servlet 抛出<code>UnavailableException</code> 后需要把它从服务中移除。</li></ul></li></ul><h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><p>@ref:</p><ul><li><a href="http://docs.oracle.com/javaee/6/api" target="_blank" rel="noopener">JavaTM Platform, Enterprise Edition 6 API Specificatio</a></li><li><a href="https://waylau.gitbooks.io/servlet-3-1-specification" target="_blank" rel="noopener">https://waylau.gitbooks.io/servlet-3-1-specification</a></li></ul><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ol><li>Servlet[I]: 属于<code>javax.servlet</code>包<ul><li><code>init()</code></li><li><code>destroy()</code></li><li><code>service(ServletRequest, ServletResponse)</code></li></ul></li><li>HttpServlet: 属于<code>javax.servlet.http</code>包<ul><li><code>service()</code>: 根据method调用: <code>doHead()</code>, <code>doGet()</code>, <code>doPost()</code> …</li></ul></li><li>DispatcherServlet : 属于<code>org.springframework.web.servlet</code>包<ul><li><code>doService()</code> : 调用了<code>doDispatch()</code></li><li><code>doDispatch()</code> : 从这里调用进<code>@Controller</code>中相关的方法</li></ul></li></ol><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>对应web.xml的<code>&lt;servlet&gt;</code>, ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过<code>ServletConfig.getServletContext</code>方法获得<code>ServletContext</code>对象<br>常用方法:</p><ul><li><code>getServletName</code>：</li><li><code>getServletContext</code>：</li></ul><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>对应web.xml的<code>&lt;context-param&gt;</code>, 容器中部署的每一个web应用都有一个ServletContext接口的实例对象与之关联<br>常用方法:</p><ul><li><code>getInitParameter</code> / <code>getInitParameterNames</code></li><li><code>addFilter</code></li><li><code>addListener</code></li><li><code>addServlet</code></li></ul><p>在任何Servlet实现类中可以使用<code>this.getServletContext</code>获取Context</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ul><li><code>init</code> / <code>destroy</code></li><li><code>doFilter</code></li><li><code>FilterChain</code></li></ul><h3 id="Response"><a href="#Response" class="headerlink" title="Response:"></a>Response:</h3><ol><li>ServletResponse[I]<ul><li><code>getOutputStream()</code> / <code>getWriter()</code></li><li><code>flushBuffer()</code></li></ul></li><li>HttpServletResponse[I]<ul><li><code>addCookie</code></li><li><code>setHeader</code></li></ul></li><li>HttpServletResponseWrapper</li></ol><h3 id="Request"><a href="#Request" class="headerlink" title="Request:"></a>Request:</h3><ol><li>ServletRequest[I]<ul><li><code>getInputStream()</code> / <code>getReader()</code></li><li><code>getParameter</code> / <code>getAttribute</code></li><li><code>startAsync()</code></li></ul></li><li>HttpServletRequest[I]<ul><li><code>getContextPath()</code>, <code>getServletPath()</code>, <code>getPathInfo()</code></li><li><code>getRequestURI()</code> / <code>getRequestURL()</code></li></ul></li><li>HttpServletRequestWrapper</li></ol><h3 id="IO-Stream"><a href="#IO-Stream" class="headerlink" title="IO Stream"></a>IO Stream</h3><ol><li>ServletInputStream:<ul><li><code>readLine</code></li></ul></li><li>ServletOutputStream:<ul><li><code>print</code> / <code>println</code></li></ul></li></ol><h3 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h3><p>RequestDispatcher对象由Servlet容器来创建, 封装一个由路径所标识的服务器资源.<br>在Servlet实现类中获取dispatcher对象: <code>this.getServletContext().getRequestDispatcher(&quot;/api/v2/topic/load&quot;)</code></p><ol><li>获取RequestDispatcher对象<ol><li>ServletRequest的<code>getRequestDispatcher(String  path)</code>方法</li><li>ServletContext的<code>getNamedDispatcher(String  path)</code>和<code>getRequestDispatcher(String  path)</code>方法</li></ol></li><li>RequestDispatcher.forward(ServletRequest, ServletResponse) : 类似php里的inclde, 在返回页面中包括其他资源</li><li>RequestDispatcher.include(ServletRequest, ServletResponse) : 转发</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;/2.html&quot;).include(request, response); // 在当前页面包含2.html</span><br><span class="line">requset.getRequestDisPatcher(&quot;/servlet2&quot;).dispatcher.forward(request, response);  // 转发到servlet2</span><br></pre></td></tr></table></figure><h1 id="JSP（JavaServer-Pages）"><a href="#JSP（JavaServer-Pages）" class="headerlink" title="JSP（JavaServer Pages）"></a>JSP（JavaServer Pages）</h1><h2 id="Servlet-amp-JSP-区别与联系"><a href="#Servlet-amp-JSP-区别与联系" class="headerlink" title="Servlet &amp; JSP 区别与联系"></a>Servlet &amp; JSP 区别与联系</h2><ul><li>Servlet在Java代码中通过HttpServletResponse对象动态输出HTML内容</li><li>JSP在静态HTML内容中嵌入Java代码, Java代码被动态执行后生成HTML内容,</li><li>JSP的本质仍是Servlet, JSP编译之后生成的<code>*.java</code>文件和<code>*.class</code>里有什么?</li><li>Servlet是被Context的类加载器加载的, 所以重写Servlet需要重新部署Context, JSP有自己的加载器, JSP文件在修改之后不需要”重新加载”</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>代码段 <code>&lt;% ... %&gt;</code></li><li><p>声明: <code>&lt;%! ... &gt;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%! int i = 0; %&gt;</span><br><span class="line">&lt;%! int a, b, c; %&gt;</span><br></pre></td></tr></table></figure></li><li><p>表达式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">   今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动作元素"><a href="#动作元素" class="headerlink" title="动作元素"></a>动作元素</h2><ul><li><code>jsp:include</code> :     在页面被请求的时候引入一个文件。</li><li><code>jsp:useBean</code> : 寻找或者实例化一个JavaBean。<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"myName"</span> ... &gt;</span><br><span class="line">   &lt;jsp:setProperty name=<span class="string">"myName"</span> property=<span class="string">"someProperty"</span> .../&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 13.J2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> Servlet </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ORM框架</title>
      <link href="/13.JavaEE-Framework/JavaEE.ORM/"/>
      <url>/13.JavaEE-Framework/JavaEE.ORM/</url>
      
        <content type="html"><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p><strong>ORM</strong> :对象关系映射（Object Relational Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将java程序中的对象自动持久化到关系数据库中。</p><p><strong>JDBC</strong> (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。<br>常见的JDBC代码，简单的select语句也需要冗长的出错处理，并且每个函数都不断地重复同样的代码。<br>Spring Framework的<code>JdbcTemplate</code>正是为了减少上述繁琐的代码而设计出来的。它是对JDBC的一种封装，抽象我们常用的一些方法。</p><p><strong>JPA</strong> 全称为Java Persistence API ，Java持久化API是Sun公司在Java EE 5规范中提出的Java持久化接口。JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。使用JPA持久化对象，并不是依赖于某一个ORM框架。<br>JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现，JBoss应用服务器底层就以Hibernate作为JPA的实现。<br>虽然ORM框架都实现了JPA规范，但是在不同ORM框架之间切换是需要编写的代码有一些差异，而通过使用Spring Data Jpa能够方便大家在不同的ORM框架中间进行切换而不要更改代码。并且Spring Data Jpa对Repository层封装的很好，可以省去不少的麻烦。</p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><ul><li><a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">MyBatis 3 | 入门</a></li><li><a href="https://gitbook.cn/books/5a37b6b66eec7c4f044a75d0/index.html" target="_blank" rel="noopener">通过源码深入理解 SQL 的执行过程</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">MyBatis的架构设计以及实例分析</a></li></ul><h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><ul><li><a href="https://www.w3cschool.cn/hibernate/" target="_blank" rel="noopener">Hibernate 教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 13.J2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> ORM </tag>
            
            <tag> MyBatis </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java日志框架（JCL,SLF4J,Log4J,Logback）</title>
      <link href="/13.JavaEE-Framework/JavaEE.Log/"/>
      <url>/13.JavaEE-Framework/JavaEE.Log/</url>
      
        <content type="html"><![CDATA[<h1 id="日志框架简介"><a href="#日志框架简介" class="headerlink" title="日志框架简介"></a>日志框架简介</h1><ul><li><code>Commons Logging</code>和<code>SLF4J</code>是java中的 <em>日志门面</em>，即它们提供了一套通用的接口，具体的实现可以由开发者自由选择。</li><li><code>Log4j</code>（以及最新的log4j 2）和<code>Logback</code>则是具体的 <em>日志实现</em> 方案。它们可以理解为接口与实现类的关系</li><li>四个框架都可以在程序中使用，但是为了考虑扩展性，一般我们在程序开发的时候，会选择使用Commons Logging或者SLF4J这些日志门面，而不是直接使用log4j或者Logback这些实现。即我们写代码的时候导入的类一般都是来自门面框架中的类，然后将某个日志的实现框架加入到项目中，提供真正的日志输出功能。<br>如果项目依赖多个库，这些库又使用了不同的日志门面，这种情况可以方便的通过 Adapter 转接到同一个日志实现上；</li><li>比较常用的搭配是:<ol><li>commons-logging + log4j，这是一种比较老但稳妥的组合, 缺点是commons-logging不支持占位符;</li><li>slf4j + logback，slf4j支持占位符, logback性能优于log4j;</li></ol></li></ul><h1 id="日志门面（SLF4J，Commons-Loggings）"><a href="#日志门面（SLF4J，Commons-Loggings）" class="headerlink" title="日志门面（SLF4J，Commons-Loggings）"></a>日志门面（SLF4J，Commons-Loggings）</h1><h2 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h2><p>SLF4J全称为<code>Simple Logging Facade for JAVA</code>，Java简单日志门面。<br>类似于Commons Logging，是对不同日志框架提供的一个门面封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。</p><h3 id="Adapter-amp-Bridge"><a href="#Adapter-amp-Bridge" class="headerlink" title="Adapter &amp; Bridge"></a>Adapter &amp; Bridge</h3><p>SLF4J在编译时静态绑定真正的Log库。下图介绍了SLF4J如何绑定具体的日志实现的:</p><p><img src="/images/javaee/javaee_log_slf4j.png" alt=""></p><p>对于application层，具体的日志框架对我们都是透明的，我们只针对slf4j-api编程。应用程序调用slf4j-api，而日志的输出最终是由底层的日志实现（Log4j、Logback）来负责的。<br>上图也说明了具体日志实现（Log4j、Logback）的不同：</p><ul><li>Logback是基于slf4j接口编写的，所以中间不需要适配：<code>SLF4J</code> -&gt; <code>Logback</code></li><li>SLF4J+Log4j的方式就需要适配层：<code>SLF4J</code> -&gt; <code>slf4j-log4j12</code> -&gt; <code>Log4j</code></li></ul><p>SLF4J是如何绑定具体日志实现，参考：<br><a href="http://skyao.github.io/2014/07/21/slfj4-binding/" target="_blank" rel="noopener">slf4j初始化绑定源码分析 | Sky’s Blog</a> @ref</p><p><strong>混乱的开始</strong>：</p><p>SLF4J的开发者提供了各种 Adapter 和 Bridge 来适配各种 Log Implementation 和 Log Facade，使用JCL作为日志门面的旧项目也可以接入SLF4J。<br>甚至可以有:  Facade1 -&gt; Implementation1 -&gt; Bridge -&gt; Facade2 -&gt; Implementation2这种复杂的桥接方式.<br>比如程序中以前使用的日志门面是commong-logging，那么你可以通过引入jcl-over-slf4j包来讲日志重定向到slf4j。<br><img src="/images/javaee/J2EE-Log-SLF4J-Adapter.png" alt=""></p><p>上图中红色的是 Log Facade， 蓝色的是 Log Implementation ，所以有了以下几种可能的复杂桥接方案:</p><ul><li><code>JCL</code>(Commons Logging) -&gt; <code>jcl-over-slf4j</code> -&gt; <code>SLF4J</code> -&gt; <code>Logback</code></li><li><code>Log4j</code> -&gt; <code>log4j-over-slf4j</code> -&gt; <code>SLF4J</code> -&gt; <code>Logback</code></li></ul><blockquote><p>从上面可以看出, <code>SLF4J</code> -&gt; <code>Logback</code>是最简单的方案,  <code>SLF4J</code>想使用 <code>Log4j</code>就需要桥接包</p></blockquote><h3 id="日志占位符"><a href="#日志占位符" class="headerlink" title="日志占位符"></a>日志占位符</h3><p>SLF4J提供了更好的日志记录方式，支持占位符的方式打印日志。比如：<br><code>logger.debug(&quot;Processing trade with id: {} and symbol : {} &quot;, id, symbol);</code></p><p>而不是使用JCL的<code>+</code>的方式：<br><code>logger.debug(&quot;start process request, url:&quot; + url);</code><br>直接使用 <code>+</code> 拼接字符串有什么问题呢？一般生产环境 log 级别都会设到 info 或者以上，那这条 log 是不会被输出的。<br>然而不管是否输出，上面的代码都会做一个字符串连接操作，然后生产一个新的字符串。<br>如果这条语句在循环或者被调用很多次的函数中，就会多做很多无用的字符串连接，影响性能。</p><p>所以 JCL 的最佳实践推荐这么写：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(&quot;start process request, url:&quot; + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而开发者常常忽略这个问题或是觉得麻烦而不愿意这么写。所以SLF4J提供的占位符<code>{}</code>方式更加方便。</p><h3 id="SLF4J-Logback（推荐）"><a href="#SLF4J-Logback（推荐）" class="headerlink" title="SLF4J + Logback（推荐）"></a>SLF4J + Logback（推荐）</h3><p>SLF4J是编译时绑定到具体的日志框架，性能优于采用运行时搜寻的方式的commons-logging<br>SLF4J提供了更好的日志记录方式，带来下这几方面的好处：</p><p>更好的可读性；</p><p>不需要使用<code>logger.isDebugEnabled()</code>来解决日志因为字符拼接产生的性能问题。比如：<br><code>logger.debug(“Processing trade with id: {} and symbol : {} “, id, symbol);</code><br>logback支持了更方便的自定义日志，便于后期的日志分析，可以将日志格式化保存到各种存储引擎中，请点击这里 可以将日志写入到HBase等。但是SLF4J不支持FATAL级别</p><p>使用slf4j + logback步骤:</p><ul><li>添加slf4j + logback的Jar包依赖;<ul><li>去掉commons-loggings和log4j的依赖, 用<code>mvn dependency:tree</code>查看依赖, 并用<code>&lt;exclusions&gt;</code>去掉Jar依赖;</li><li>去掉重复引入的logback相关Jar, 比如我们使用slf4j + logback的方案，只需要引入<code>logback-classic</code>即可，不必再显示添加<code>slf4j-api</code>和<code>logback-core</code>，因为logback-classic本身依赖它们。</li></ul></li><li>slf4j 配置文件: 无</li><li>logback 配置文件: logback.xml</li><li>Java代码:  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(A.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">            logger.debug(<span class="string">"slf4j-logback debug message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(logger.isInfoEnabled())&#123;</span><br><span class="line">            logger.info(<span class="string">"slf4j-logback info message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(logger.isTraceEnabled())&#123;</span><br><span class="line">            logger.trace(<span class="string">"slf4j-logback trace message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>@ref: <a href="https://www.jianshu.com/p/696444e1a352" target="_blank" rel="noopener">slf4j+logback的配置及使用 - 简书</a></p></blockquote><h2 id="Commons-Logging（JCL）"><a href="#Commons-Logging（JCL）" class="headerlink" title="Commons Logging（JCL）"></a>Commons Logging（JCL）</h2><p>Commons Logging是一个通用的日志接口。在有些地方会看到简写为JCL（Jakarta Commons Logging）。</p><blockquote><p>commons-logging是Apache commons类库中的一员。Apache commons类库是一个通用的类库，提供了基础的功能，比如说commons-fileupload，commons-httpclient，commons-io，commons-codes等。</p></blockquote><p>common-logging通过动态查找的机制，在程序运行时自动找出真正使用的日志库。<br>用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的logging， Commons Logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。<br>所以使用Commons Logging，通常都是配合着log4j来使用。使用它的好处就是，代码依赖是Commons Logging而非log4j， 避免了和具体的日志方案直接耦合，在有必要时，可以更改日志实现的第三方库。</p><p>工作原理：</p><ol><li>查找名为org.apache.commons.logging.Log的factory属性配置（可以是java代码配置，也可以是commons-logging.properties配置）；</li><li>查找名为org.apache.commons.logging.Log的系统属性；</li><li>上述配置不存在则classpath下是否有Log4j日志系统，如有则使用相应的包装类；</li><li>如果系统运行在JDK 1.4系统上，则使用Jdk14Logger；</li><li>上述都没有则使用SimpleLog。</li></ol><p>所以如果使用commons-logging＋log4j的组合只需要在classpath中加入log4j.xml配置即可。commons-logging的动态查找过程是在程序运行时自动完成的。他使用ClassLoader来寻找和载入底层日志库，所以像OSGI这样的框架无法正常工作，因为OSGI的不同插件使用自己的ClassLoader。</p><h3 id="Commons-Logging-Log4j"><a href="#Commons-Logging-Log4j" class="headerlink" title="Commons-Logging + Log4j"></a>Commons-Logging + Log4j</h3><blockquote><p>日志门面为Commons-Logging（JCL），实现类为log4j。Commons-Logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。只要应用系统引入了log4j.jar包 并在classpath 配置了log4j.xml ，则Commons-Logging 就会使log4j 使用正常，而代码里不需要依赖任何log4j 的代码。</p></blockquote><p>使用commons-logging + log4j的步骤:</p><ul><li>添加Jar包依赖;</li><li><p>commons-logging 配置文件: 默认的，common-logging会自动检查是否使用log4j，也可以使用配置文件显示的启用log4j。配置文件为<code>commons-logging.properties</code>,放在classpath下;</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4J-Logger</span><br><span class="line">org.apache.commons.logging.LogFactory=org.apache.commons.logging.impl.LogFactoryImpl</span><br></pre></td></tr></table></figure></li><li><p>log4j 配置文件: <code>log4j.properties</code>:</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG,console</span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%-d&#123;yyyy-MM-dd HH:mm:ss&#125;]-[%t-%5p]-[%C-%M(%L)]： %m%n</span><br></pre></td></tr></table></figure></li><li><p>Java代码:</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"Debug info: "</span> + args.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考: <a href="https://svn.apache.org/repos/asf/commons/proper/logging/tags/STRUTS_1_1_B3/usersguide.html" target="_blank" rel="noopener">Jakarta Commons Logging Users Guide</a> @ref</p><h1 id="日志实现（Log4J，LogBack，JUL）"><a href="#日志实现（Log4J，LogBack，JUL）" class="headerlink" title="日志实现（Log4J，LogBack，JUL）"></a>日志实现（Log4J，LogBack，JUL）</h1><p>主流的日志实现有 log4j（还有升级版log4j2）和logback, 实现了将日志输出到具体的介质, 比如文件/Tcp/Scribe等.<br>此外还有<code>java.util.logging</code>（JUL）</p><ul><li>log4j的默认配置文件是 log4j.properties;</li><li>logback的默认配置文件是 logback.xml;</li></ul><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><p>Log4j是Apache的一个开放源代码项目，经典的一种日志解决方案。内部把日志系统抽象封装成Logger 、appender 、pattern等实现。<br>我们可以通过配置文件轻松的实现日志系统的管理和多样化配置。<br>通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；用户也可以控制每一条日志的输出格式；<br>通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。这些可以通过一个 配置文件来灵活地进行配置，而不需要修改程序代码。</p><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><p>配置文件加载顺序:</p><ul><li>log4j.xml</li><li>log4j.properites</li></ul><p>所以把log4j.xml或log4j.properties放在这些目录下，那么log4j会“自动去加载”到，不用程序里手工写加载代码了。这也就“约定大于配置的好处”。</p><h3 id="配置文件-log4j-properties"><a href="#配置文件-log4j-properties" class="headerlink" title="配置文件 log4j.properties"></a>配置文件 log4j.properties</h3><p>配置文件log4j.properties 结构&amp;层级如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger</span><br><span class="line">    appender</span><br><span class="line">        layout</span><br></pre></td></tr></table></figure><ul><li>Loggers(记录器)：记录日志的工具，程序中就是用它来记录我们想要的日志信息。</li><li>Appenders (输出源)：日志输出到什么地方，可以是控制台、文件、流位置、数据库，等等。</li><li>Layouts(布局模式)：日志需要记录哪些基本信息，用什么样的格式去记录展示这些信息。</li><li>一个 Logger 最少要有一个 Appender，一个 Appender 有一个 Layout。</li></ul><p>log4j.properties 示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO,A1               // 定义logger方式1: 定义根logger名=rootLogger, level=INFO, 使用名为A1的appender</span><br><span class="line">log4j.logger.loggerName1=DEBUG,A2      // 定义logger方式2: logger名=loggerName1, 使用名为A2的appender</span><br><span class="line">log4j.logger.org.apache = DEBUG, A3   // 定义logger方式3: 对org.apache下的类有效, 使用名为A3的appender</span><br><span class="line"></span><br><span class="line">// 定义A1 appender的属性</span><br><span class="line">log4j.appender.A1=org.apache.log4j.DailyRollingFileAppender // 可选ConsoleAppender, RollingFileAppender ..</span><br><span class="line">log4j.appender.A1.BufferedIO=false</span><br><span class="line">log4j.appender.A1.BufferSize=1024</span><br><span class="line">log4j.appender.A1.file=../logs/api.log // 日志文件位置</span><br><span class="line">log4j.appender.A1.DatePattern=&apos;.&apos;yyyyMMddHH</span><br><span class="line">log4j.appender.A1.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH\:mm\:ss SSS&#125; [%p] %m%n // 日志格式</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rootLogger方法:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger rootLogger = Logger.getRootLogger();</span><br><span class="line">    <span class="comment">// 从logger名字获取:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = Logger.getLogger(<span class="string">"loggerName1"</span>);</span><br><span class="line">    <span class="comment">// 从class获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log2 = Logger.getLogger(Test.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><ul><li><p>设置日志缓存，以及缓存大小</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.appender.A3.BufferedIO=true</span><br><span class="line">#Buffer单位为字节，默认是8K，IO BLOCK大小默认也是8K</span><br><span class="line">log4j.appender.A3.BufferSize=8192</span><br></pre></td></tr></table></figure></li><li><p>设置日志输出为异步方式 (异步输出必须使用xml方式配置才能支持)</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;appender name=&quot;DAILY_FILE&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">    &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c %x - %m%n&quot;/&gt;</span><br><span class="line">    &lt;/layout&gt;</span><br><span class="line">    &lt;param name=&quot;File&quot; value=&quot;log/log4j.log&quot;/&gt;</span><br><span class="line">    &lt;param name=&quot;DatePattern&quot; value=&quot;&apos;.&apos;yyyy-MM-dd&quot;/&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">&lt;appender name=&quot;ASYNC_FILE&quot; class=&quot;org.apache.log4j.AsyncAppender&quot;&gt;</span><br><span class="line">    &lt;param name=&quot;BufferSize&quot; value=&quot;10000&quot;/&gt;</span><br><span class="line">    &lt;param name=&quot;Blocking&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;DAILY_FILE&quot;/&gt;</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure></li></ul><p>Log4j的AsyncAppender存在的问题:</p><blockquote><p>Log4j的异步appender也就是AsyncAppender存在性能问题（现在Log4j 2.0 RC提供了一种新的异步写log的机制(基于disruptor)来试图解决问题），<br>异步写log有一个buffer的设置，也就是当队列中多少个日志的时候就flush到文件或数据库，<br>当配置为blocking=true的时候，如果应用写日志很快，log4j的缓冲队列将很快被占满，写日志会被阻塞</p></blockquote><h2 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h2><p>Logback也是一种日志实现。Logback是由log4j创始人设计的又一个开源日记组件。<br>Logback当前分成三个模块：Logback-core,Logback- classic和Logback-access。Logback-core是其它两个模块的基础模块。Logback-classic是log4j的一个 改良版本。<br>此外Logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging。<br>Logback-access访问模块与Servlet容器集成提供通过Http来访问日记的功能。</p><p>LogBack 作为一个通用可靠、快速灵活的日志框架，将作为Log4j 的替代和SLF4J 组成新的日志系统的完整实现。官网上称具有极佳的性能，在关键路径上执行速度是log4j 的10 倍，且内存消耗更少。比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在LogBack中需要3纳秒，而在Log4J中则需要30纳秒。 LogBack创建记录器（logger）的速度也更快：13微秒，而在Log4J中需要23微秒。更重要的是，它获取已存在的记录器只需94纳秒，而 Log4J需要2234纳秒，时间减少到了1/23。”。</p><p>官方文档对logback的描述</p><blockquote><p>NATIVE IMPLEMENTATION There are also SLF4J bindings external to the SLF4J project, e.g. logback which implements SLF4J natively. Logback’s ch.qos.logback.classic.Logger class is a direct implementation of SLF4J’s org.slf4j.Logger interface. Thus, using SLF4J in conjunction with logback involves strictly zero memory and computational overhead.</p></blockquote><p>可以看到logback是直接实现了slf4j的接口，是不消耗内存和计算开销的。而log4j不是对slf4j的原生实现，所以slf4j api在调用log4j时需要一个适配层。</p><h3 id="Quick-Start-1"><a href="#Quick-Start-1" class="headerlink" title="Quick Start"></a>Quick Start</h3><p>@todo</p><h3 id="配置文件-logback-xml"><a href="#配置文件-logback-xml" class="headerlink" title="配置文件 logback.xml"></a>配置文件 logback.xml</h3><p>logback在启动时，根据以下步骤寻找配置文件：</p><ul><li>①在classpath中寻找logback-test.xml文件</li><li>②如果找不到logback-test.xml，则在 classpath中寻找logback.groovy文件</li><li>③如果找不到 logback.groovy，则在classpath中寻找logback.xml文件</li></ul><p>如果上述的文件都找不到，则logback会使用JDK的SPI机制查找 <code>META-INF/services/ch.qos.logback.classic.spi.Configurator</code>中的 logback 配置实现类，这个实现类必须实现Configuration接口，使用它的实现来进行配置。<br>如果上述操作都不成功，logback 就会使用它自带的 BasicConfigurator 来配置，并将日志输出到console。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!--scan:</span></span><br><span class="line"><span class="comment">            当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</span></span><br><span class="line"><span class="comment">scanPeriod:</span></span><br><span class="line"><span class="comment">            设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</span></span><br><span class="line"><span class="comment">de<span class="doctag">bug:</span></span></span><br><span class="line"><span class="comment">            当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">configuration 子节点为 appender、logger、root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于区分不同应用程序的记录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>edu-cloud<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件所在目录，如果是tomcat，如下写法日志文件会在则为$&#123;TOMCAT_HOME&#125;/bin/logs/目录下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"logs"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger输出日志的logger名 %msg：日志消息，%n是换行符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--解决乱码问题--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--滚动文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoFile"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ThresholdFilter:临界值过滤器，过滤掉 TRACE 和 DEBUG 级别的日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/log.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span><span class="comment">&lt;!--保存最近30天的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里如果是info，spring、mybatis等框架则不会输出：TRACE &lt; DEBUG &lt; INFO &lt;  WARN &lt; ERROR--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--root是所有logger的祖先，均继承root，如果某一个自定义的logger没有指定level，就会寻找</span></span><br><span class="line"><span class="comment">    父logger看有没有指定级别，直到找到root。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoFile"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorFile"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"logstash"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JUL"><a href="#JUL" class="headerlink" title="JUL"></a>JUL</h2><p>java.util.logging 是 java自带的日志处理系统, 配置文件一般是logging.properties,</p><p><code>java.util.logging.LogManager</code> 负责读取配置, LogManager 还可以根据两个系统属性来允许用户控制日志的配置：</p><ul><li>“-Djava.util.logging.config.class=YourClass”</li><li>“-Djava.util.logging.config.file=logging.properties”</li></ul><h3 id="logging-properties"><a href="#logging-properties" class="headerlink" title="logging.properties"></a>logging.properties</h3><p>和Tomcat的配置格式类似:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlers=java.util.logging.FileHandler,java.util.logging.ConsoleHandler,</span><br><span class="line">java.util.logging.ConsoleHandler.level=WARNING</span><br><span class="line">java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter</span><br><span class="line"></span><br><span class="line">java.util.logging.FileHandler.level=INFO</span><br><span class="line">java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter</span><br><span class="line">java.util.logging.FileHandler.limit=1024000</span><br><span class="line">java.util.logging.FileHandler.count=10</span><br><span class="line">java.util.logging.FileHandler.pattern=/data1/logs/log.%d&#123;yyyyMMddHH&#125;</span><br><span class="line">java.util.logging.FileHandler.append=true</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>如果你的项目是一个库，需要提供给给别的项目使用，那么建议使用Log Facade，而不使用具体的 Log Implementation。<br>如果一定要使用 Log Implementation，<br>那么建议你的项目里对 Log Implementation 的依赖设置为<code>&lt;scope&gt;runtime&lt;/scope&gt;</code> 并且<code>&lt;optional&gt;true&lt;/optional&gt;</code>, 设为optional，依赖不会传递；</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是一个独立的项目(比如Web项目)，<br>那么不要单独使用 Log Impementation，而应该跟 Log Facade一起使用。</p><p><strong>如果有必要, 排除依赖的第三方库中的 Log Impementation依赖</strong></p><p>这是很常见的一个问题，第三方库的开发者未必会把具体的 <em>Log Implementation</em> 或者桥接器的依赖设置为optional，然后你的项目会继承这些 <em>Log Implementation</em> 的库，<br>—— 但这未必是你想使用的，比如第三方库依赖了Log4j，但你自己的项目使用的是Logback。<br>另外，如果不同的第三方依赖使用了不同的桥接器和 <em>Log Implementation</em> ，也极容易形成依赖环。项目里就需要针对每个 <em>Log Implementation</em> 库都都写一个配置文件。<br>这种情况下推荐的处理方法，使用exclude来排除所有的这些 <em>Log Implementation</em> 和桥接器的依赖，只保留第三方库里面对 <em>Log Facade</em> 的依赖。</p><p>@ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/24272450" target="_blank" rel="noopener">Java 日志框架解析(上) - 历史演进 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/24275518" target="_blank" rel="noopener">Java 日志框架解析(下) - 最佳实践 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 13.J2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> JCL </tag>
            
            <tag> SLF4J </tag>
            
            <tag> Log4J </tag>
            
            <tag> Logback </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java EE 技术标准（JTS,JMS,JMX,JTA,JPA,EJB,JNDI,JDBC）</title>
      <link href="/13.JavaEE-Framework/JavaEE.01.%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/"/>
      <url>/13.JavaEE-Framework/JavaEE.01.%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/javaee/JavaEE-Title.png" alt=""></p><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p>Java平台共分为三个主要版本：Java SE、Java EE 和 Java ME。</p><ul><li>Java SE，Java Platform Standard Edition，Java平台标准版, 基本等同于 JDK；</li><li>Java EE，Java Platform Enterprise Edition，也即Java平台企业版，JavaEE实际上是一系列技术标准的集合，并不提供具体实现；</li><li>Java ME，Java Platform Micro Edition，用于嵌入式和移动设备的Java平台，已经式微。</li></ul><p>Java EE相关阅读:</p><ul><li><a href="https://juejin.im/entry/5a9cbe29f265da239f06da2e" target="_blank" rel="noopener">Java EE未来路在何方？ - 掘金</a></li><li><a href="https://www.infoq.cn/article/2015/07/spring-javaee" target="_blank" rel="noopener">开发者眼中的Spring与Java EE - InfoQ</a></li><li><a href="https://www.zhihu.com/question/268742981" target="_blank" rel="noopener">关于J2EE和Spring目前到底是怎样的关系，以及未来这两者的发展是怎样的，是否存在竞争市场的情况？ - 知乎</a></li></ul><p>J2EE里面的2是什么意思？</p><blockquote><p>J2SE，J2SE，J2ME中2的含义要追溯要1998年。<br>1998年Java 1.2版本发布，1999年发布Java 1.2的标准版，企业版，微型版三个版本，为了区分这三个版本，分别叫做Java2SE，Java2EE，Java2ME，简称J2SE，J2EE，J2ME。故，2的含义为1.2版本。但是，这种叫法已经在2005年Java 1.6发布后取消，J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME。<br>所以，现在的J2EE等叫法是05年以前旧的叫法。</p></blockquote><p><strong>Java EE是一系列技术标准所组成的平台，包括：</strong></p><ul><li>Servlet: Java Servlet API</li><li>JNDI(Java Name and Directory Interface): Java命名和目录接口，它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。<br>并提供了一致的模型来存取和操作企业级的资源如DNS和LDAP、本地文件系统、或应用服务器中的对象。</li><li>JTA(Java Transaction API): Java事务API.</li><li>JTS(Java Transaction Service): Java事务服务.</li><li>JPA(Java Persistence API): 通过注解或XML描述对象－关系表的映射关系, 并将对象持久化到数据库中, 实现有Spring-data-jpa, Hibernate。</li><li>JMS(Java Message Service): Java消息服务接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>Java消息服务的规范包括两种消息模式，点对点和发布者／订阅者。</li><li>JMX(Java Management Extensions): Java管理扩展，JMX提供了一套接口，让开发者和管理者可以通过 MBean 获取程序运行的状态以及动态的修改程序的相关配置。<br>JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。<br>Tomcat、Kafka等都通过JMX实现了监控接口，Jconsole和VisualVM可以通过JMX协议获取程序运行状态实现监控。</li><li>Java Bean: 一般情况下指的是实体类, 所有属性为private, 提供默认构造方法和getter, setter, 如果一个JavaBean需要在不同的JVM的进程中进行传递，还需要实现Serializable接口.</li><li>MBean（Managed Bean）: 托管Bean, 是一种通过依赖注入创建的Java Bean。MBean代表了运行在Java虚拟机上的资源，例如应用程序或Java EE服务（事务监控、JDBC驱动程序等）。<br>其可以用于收集如性能、资源使用率、问题信息等关键的统计信息（通过拉取），获取或设置应用程序的配置或属性（通过推送或拉取），以及对故障或状态变化等的通知事件（通过推送）。</li><li>EJB(Enterprise JavaBean): 企业级JavaBean, 与普通Java Bean 的区别: JavaBean的使用可以不需要容器，EJB的运行一般需要EJB容器(即应用服务器，如JBoss/Weblogic/Websphere…</li><li>POJO(Plain Ordinary Java Object): 简单的Java对象, 实际就是普通Java Beans, 是为了避免和EJB混淆所创造的简称</li><li>JDBC(Java Database Connectivity): 是一个标准 SQL(Structured Query Language, 结构化查询语言)数据库访问接口</li></ul><p>附：<a href="https://www.oracle.com/technetwork/java/javaee/tech/index.html" target="_blank" rel="noopener">来自 Oracke的 Java EE 8 技术列表</a></p><h1 id="JavaEE的发展"><a href="#JavaEE的发展" class="headerlink" title="JavaEE的发展"></a>JavaEE的发展</h1><ul><li>2017 年 3 月: <a href="https://www.infoq.cn/article/enterprise-java-opinion" target="_blank" rel="noopener">InfoQ观点：Java EE的未来</a></li><li>2018 年 2 月: <a href="https://www.infoq.cn/article/2018/02/from-javaee-to-jakartaee" target="_blank" rel="noopener">Java EE重命名为Jakarta EE：Java EE Guardians与Oracle的分歧</a></li><li>2019 年 5 月: <a href="https://www.infoq.cn/article/7TvOThYKv-Hbzp4NIsIf" target="_blank" rel="noopener">谈判失败，Oracle亲手把Java EE送上断头台</a></li><li>2021年9月: Spring Boot 3.0 M1发布, 基线从Java8提升至Java17, 所有 Java EE API被迁移到Jakarta EE(用户需要将<code>javax</code>替换为<code>jakarta</code>. 例如，<code>javax.servlet.Filter</code>将替换为<code>jakarta.servlet.Filter</code>)  来源: <a href="https://spring.io/blog/2022/01/20/spring-boot-3-0-0-m1-is-now-available" target="_blank" rel="noopener">Spring Boot 3.0.0-M1 is now available</a></li></ul><h1 id="JTA-Java-Transaction-API"><a href="#JTA-Java-Transaction-API" class="headerlink" title="JTA (Java Transaction API)"></a>JTA (Java Transaction API)</h1><p>@ref:</p><ul><li><a href="https://www.oracle.com/java/technologies/jta.html" target="_blank" rel="noopener">Java Transaction API (JTA)</a></li><li><a href="https://www.baeldung.com/jee-jta" target="_blank" rel="noopener">Guide to Jakarta EE JTA | Baeldung</a></li><li><a href="https://www.progress.com/tutorials/jdbc/understanding-jta" target="_blank" rel="noopener">Understanding JTA - The Java Transaction API</a></li><li><a href="https://spring.io/blog/2011/08/15/configuring-spring-and-jta-without-full-java-ee/" target="_blank" rel="noopener">Configuring Spring and JTA without full Java EE</a></li></ul><h1 id="JTS-Java-Transaction-Service"><a href="#JTS-Java-Transaction-Service" class="headerlink" title="JTS (Java Transaction Service):"></a>JTS (Java Transaction Service):</h1><p>@ref:</p><ul><li><a href="https://docs.oracle.com/cd/E19644-01/817-5449/djjts.html" target="_blank" rel="noopener">Chapter 3 Using the Transaction Service</a></li><li><a href="https://www.ibm.com/support/pages/learning-more-about-java-transaction-service-jts" target="_blank" rel="noopener">Learning more about Java Transaction Service (JTS)</a></li></ul><h1 id="JMS-Java-Message-Service"><a href="#JMS-Java-Message-Service" class="headerlink" title="JMS (Java Message Service)"></a>JMS (Java Message Service)</h1><p>@ref:</p><ul><li><a href="https://www.oracle.com/java/technologies/java-message-service.html" target="_blank" rel="noopener">Java Message Service (JMS)</a></li><li><a href="https://www.javatpoint.com/jms-tutorial" target="_blank" rel="noopener">JMS Tutorial - javatpoint</a></li><li><a href="https://docs.oracle.com/javaee/7/api/javax/jms/package-summary.html" target="_blank" rel="noopener">javax.jms (Java(TM) EE 7 Specification APIs)</a></li></ul><h1 id="JMX-Java-Management-Extensions"><a href="#JMX-Java-Management-Extensions" class="headerlink" title="JMX (Java Management Extensions)"></a>JMX (Java Management Extensions)</h1><p>@ref:</p><ul><li><a href="https://zh.wikipedia.org/wiki/JMX" target="_blank" rel="noopener">JMX - 维基百科，自由的百科全书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 13.J2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaEE </tag>
            
            <tag> JTS </tag>
            
            <tag> JMS </tag>
            
            <tag> JMX </tag>
            
            <tag> JTA </tag>
            
            <tag> JPA </tag>
            
            <tag> JNDI </tag>
            
            <tag> EJB </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-14-代理</title>
      <link href="/12.Java/Java-Tutorials.14.%E4%BB%A3%E7%90%86/"/>
      <url>/12.Java/Java-Tutorials.14.%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>什么是代理模式:<br>用户代码不直接调用某些功能类的方法, 而是通过代调类作为”中间层”去调用”被代理类”. 所有调用都会被代理类拦截, 我们可以利用代理类的这个特性, 在代理类里增加额外的执行代码.<br>使用代理可以给我们带来如下好处: 用户代码(调用者)和功能类(被调用者)解耦, 第二个好处是通过代理层可以加入一些通用的代码.<br>Java代理模式的实现主要有: 静态代理, JDK动态代理, Cglib动态代理.</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>如何使用JDK的动态代理:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">YourInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 实际类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourClass</span> <span class="keyword">implements</span> <span class="title">YourInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 实现InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 被代理的实例</span></span><br><span class="line">  <span class="keyword">private</span> YourInterface target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">YourHandler</span><span class="params">(YourInterface target)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">// 通过Proxy调用方法都会调用到这里,</span></span><br><span class="line">      <span class="comment">// 在这里可以放一些类似AOP @Around的处理..</span></span><br><span class="line">      Object result = method.invoke(target, args);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YourInterface obj = <span class="keyword">new</span> YourClass();</span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> YourHandler(obj);</span><br><span class="line"><span class="comment">// 4 创建代理</span></span><br><span class="line">YourInterface proxy = (YourInterface)Proxy.newProxyInstance(</span><br><span class="line">  obj.getClass().getClassLoader(),</span><br><span class="line">  obj.getClass().getInterfaces(),</span><br><span class="line">  handler);</span><br><span class="line"></span><br><span class="line">proxy.doSomething();</span><br></pre></td></tr></table></figure><p>通过proxy调用<code>YourClass</code>实现自接口<code>YourInterface</code>的所有方法, 都会调用到<code>YourHandler</code>的invoke方法,<br>在invoke方法里可以很方便的做一些前置和后置处理（访问控制、远程通信、日志、缓存等）, 在invoke里再通过反射调用实际类<code>YourClass</code>的方法.</p><p>动态代理的优点是, 当<code>YourInterface</code>的实现类有很多的时候, 比如有YourClassA, YourClassB…<br>通过代理调用这些实现类的方法(必须是实现YourInterface里的方法), 都会由代理调用到<code>InvocationHandler.invoke()</code>,<br>如果用静态代理, 那么代理类(实现了YourInterface接口)必须为YourInterface的每一个方法都增加单独的代码.</p><p>参考: <a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">Java 动态代理作用是什么？ - 知乎</a> @ref</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在调用<code>Proxy.newProxyInstance()</code>之后,<br>又调用了<code>ProxyGenerator.generateProxyClass()</code>方法生成最终代理类的字节码, 并通过ClassLoader把字节码转化成对象.<br>在最终代理类里实现了我们的Interface定义的所有方法, 在这些方法内部, 都通过反射调用了<code>InvocationHandler</code>接口实现类的<code>invoke()</code>方法</p><blockquote><p>包<code>sun.misc.ProxyGenerator</code>提供了一个功能, 可以生成YourInterface的实现类的字节码:<br><code>byte[] data = ProxyGenerator.generateProxyClass(name,new Class[]{YourInterface.class});</code></p></blockquote><h2 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h2><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。<br>与JDK动态代理不同的是, 使用CGLIB即使被代理类没有实现任何接口也可以实现动态代理功能。但是不能对final修饰的类进行代理。<br>JDK动态代理通过反射类Proxy和InvocationHandler回调接口实现，要求委托类必须实现一个接口，只能对该类接口中定义的方法实现代理，这在实际编程中有一定的局限性。</p><p>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。<br>ASM是一个Java字节码操控框架。通过分析被代理类的class文件, 在内存中创建被代理类的增强子类, 它能被用来动态生成类或者增强既有类的功能。<br>ASM可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。<br>脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p><p>下面通过一个例子看看使用CGLib如何实现动态代理:</p><p>定义业务逻辑:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"This is add service"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现MethodInterceptor接口，定义方法的拦截器:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] arg, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Before:"</span> + method);</span><br><span class="line">      Object object = proxy.invokeSuper(obj, arg);</span><br><span class="line">      System.out.println(<span class="string">"After:"</span> + method);</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>Enhancer</code>类生成<code>UserServiceImpl</code>的代理类:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">enhancer.setCallback(new YourMethodInterceptor());</span><br><span class="line">UserServiceImpl userService = (UserServiceImpl)enhancer.create();</span><br></pre></td></tr></table></figure><p><code>Enhancer</code>是CGLib的字节码增强类, 可以生成类的字节码(<code>UserServiceImpl</code>的子类),<br>其作用类似<code>sun.misc.ProxyGenerator</code>, 区别是<code>Enhancer</code>不需要被代理类实现接口, 而<code>ProxyGenerator</code>要求被代理类必须实现接口</p><p>以上参考:<br>@ref <a href="http://blog.jobbole.com/105423/" target="_blank" rel="noopener">说说 cglib 动态代理</a></p><h2 id="Spring-AOP与代理"><a href="#Spring-AOP与代理" class="headerlink" title="Spring AOP与代理"></a>Spring AOP与代理</h2><blockquote><p>Spring AOP中的一些注解 &amp; 概念:</p><blockquote><p>@Aspect: PointCut + Advice<br>@PointCut: 切点, 在哪里切入<br>@Advice: 切入的行为(在切点之前还是之后, 或者环绕切点), 以及做什么</p></blockquote></blockquote><p>Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。<br>Spring AOP中的动态代理主要有两种方式，<strong>JDK动态代理</strong> 和 <strong>CGLIB动态代理</strong>。</p><ul><li>如果目标类(被切的类)有统一的实现接口，Spring AOP使用JDK动态代理，</li><li>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</li></ul><p>因此如果某个类被标记为final，并且没有实现接口，那么它是无法被动态代理的，也就无法当做切点（CutPoint）</p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-13-引用</title>
      <link href="/12.Java/Java-Tutorials.13.%E5%BC%95%E7%94%A8/"/>
      <url>/12.Java/Java-Tutorials.13.%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="4种引用对比"><a href="#4种引用对比" class="headerlink" title="4种引用对比"></a>4种引用对比</h1><ul><li>强引用: 只要强引用还在就不会被 GC，JVM宁愿抛出 OutOfMemoryError错误也不会回收；</li><li>软引用(SoftReference): 用来描述非必需对象, GC时发现内存不够时（Heap内存超阈值）将会被回收。当垃圾回收器决定对其回收时，会先清空它的 SoftReference，也就是说 SoftReference 的 <code>get()</code>方法将会返回 null，然后再调用对象的<code>finalize()</code> 方法，并在下一轮 GC 中对其真正进行回收。</li><li>弱引用(WeakReference): 也是用来描述非需对象的, 无论内存够不够，下次GC时一定都被回收；</li><li>虚引用(PhantomReference): PhantomReference的get方法永远返回null，为一个对象设置虚引用关联的唯一目的是跟踪对象被垃圾回收的状态，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否即将被垃圾回收，当<code>PhantomReference</code>被放入队列时，说明referent的<code>finalize()</code>方法已经调用，并且垃圾收集器准备回收它的内存了。</li><li>FinalReference 以及 Finzlizer：@todo</li></ul><p><strong>How to Use:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;(); <span class="comment">// 对象被回收后, 被放入q里</span></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">WeakReference&lt;String&gt; softRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str, queue); <span class="comment">// 这一步后, 有两个引用指向"Hello"</span></span><br><span class="line">str = <span class="keyword">null</span>; <span class="comment">// 当String对象只有一个软引用指向它时, 才有可能被回收</span></span><br><span class="line">System.out.print(softRef.get()); <span class="comment">// 通过软引用调用对象用get方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这里因内存不足发生了GC，被回收的软引用会被放入队列queue</span></span><br><span class="line"><span class="comment">// 从队列取出第一个:</span></span><br><span class="line">Reference&lt;? extends String&gt; ref = queue.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ref != <span class="keyword">null</span>) &#123;  <span class="comment">// 从队列里取出的ref是个引用地址，非空</span></span><br><span class="line">  <span class="keyword">if</span>(ref.get() != <span class="keyword">null</span>) &#123; <span class="comment">// 对ref再次get，肯定返回null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p><strong>How to Use:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weakHashMapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Key, Project&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Key key1 = <span class="keyword">new</span> Key();</span><br><span class="line">        <span class="keyword">final</span> Key key2 = <span class="keyword">new</span> Key();</span><br><span class="line"></span><br><span class="line">        map.put(k1, <span class="keyword">new</span> Object());</span><br><span class="line">        map.put(k2, <span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;Key, Project&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey().getKey() + <span class="string">"   "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        key1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;Key, Project&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey().getKey() + <span class="string">"   "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakHashMap 自动回收的特性可以作为缓存来用, 例如 tomcat的ConcurrentCache</p><p><strong>源码解析:</strong><br>WeakHashMap 的主要属性:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WeakHashMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">        // 桶数组</span><br><span class="line">        Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        // 回收队列</span><br><span class="line">        private final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同时, <code>WeakHashMap</code> 的内部类<code>Entry</code>（也就是实际存储数据的节点）继承自<code>WeakReference&lt;T&gt;</code>，看一下Entry的构造：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry(Object key, V value,</span><br><span class="line">    ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">    <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">  <span class="keyword">super</span>(key, queue); <span class="comment">// 调用了WeakReference(T, Queue)</span></span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">  <span class="keyword">this</span>.next  = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用WeakHashMap 的 put(k,v), 首先创建Entry对象, Entry构造里首先调用了<code>WeakReference(K, Queue)</code>,<br>用一个WeakReference指向key，key会在下次GC被回收(null)，value被一个强引用指向了，不会被回收，可以通过queue.poll取出所有被释放的Key，</p><p>A: 那么WeakHashMap 是如何回收value的?</p><p>Q: 在<code>get</code>, <code>put</code>, <code>size</code> 方法里都会先调用一个<code>expungeStaleEntries()</code>方法,<br>遍历ReferenceQueue 取出每个Entry(即被回收的Key), 找到Entry 对应的<code>table[i]</code>,<br><code>table[i]</code>是 Entry组成的链表(当hash冲突的时候), 遍历这个链表, 取出每一个Entry, 如果ReferenceQueue 取出的那个Entry,<br>把这个 Entry.value置为null, 帮助回收;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">     for (Object x; (x = queue.poll()) != null; ) &#123;</span><br><span class="line">         synchronized (queue) &#123;</span><br><span class="line">             @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                 Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x; // @Uncertain</span><br><span class="line">             int i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">             Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">             Entry&lt;K,V&gt; p = prev;</span><br><span class="line">             while (p != null) &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                 if (p == e) &#123;</span><br><span class="line">                     if (prev == e)</span><br><span class="line">                         table[i] = next;</span><br><span class="line">                     else</span><br><span class="line">                         prev.next = next;</span><br><span class="line">                     // Must not null out e.next;</span><br><span class="line">                     // stale entries may be in use by a HashIterator</span><br><span class="line">                     e.value = null; // Help GC</span><br><span class="line">                     size--;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 prev = p;</span><br><span class="line">                 p = next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>// 疑问, 只有Key是WeakReference, GC发生时, 应该只有Key 被放入ReferenceQueue, 而不是Entry对象<br>// 解释, queue 里存储的是 <code>Reference&lt;K&gt;</code> 类型, 而Entry 是Reference的子类, 所以可以转换<br>// <a href="https://www.zhihu.com/question/63932795" target="_blank" rel="noopener">WeakHashMap中关于queue的疑惑 ？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-12-新特性</title>
      <link href="/12.Java/Java-Tutorials.12.%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/12.Java/Java-Tutorials.12.%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><blockquote><p>“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。<br>闭包的概念: 可以把闭包简单理解成”定义在一个函数内部的函数体”，并且在内部函数体中能访问在外部函数中定义的变量</p></blockquote><p>lambda的语法为: <code>expression</code> = <code>(variable) -&gt; action</code>, 例如</p><ul><li><code>Runnable r = ()  -&gt; { log.info&quot;HelloWorld&quot;;}</code></li><li><code>int sum = (x,y) -&gt; x+y;</code></li><li>等号的右边即是一个lambda表达式</li></ul><h3 id="Lambda表达式要点总结"><a href="#Lambda表达式要点总结" class="headerlink" title="Lambda表达式要点总结"></a>Lambda表达式要点总结</h3><ul><li>lambda表达式可以用于以下几个情况:<ul><li>有单个抽象方法的类, 比如一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式;</li><li>使用了 @FunctionalInterface 注释的函数式接口，比如<code>java.util.function</code>包下面的Predicate、Function、Consumer 或 Supplier, BinaryOperator<ul><li>例如ArrayList的<code>forEach(Consumer&lt;E&gt; action)</code>方法的形参是Consumer类型, 可以接受一个lambda表达式做实参;</li><li>例如Collection的stream()返回一个Stream, Stream类的<code>filter()</code>, <code>map()</code> 的形参分别是Predicate和Function;</li></ul></li></ul></li><li>lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。例如<code>list.forEach(System.out::println)</code></li><li>Lambda表达式在Java中又称为闭包或匿名函数</li><li>Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样： <code>private static java.lang.Object lambda$0(java.lang.String);</code></li><li>lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</li><li>lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量，读取是可以的但不能修改。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int factor = 2;</span><br><span class="line">primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建匿名类"><a href="#创建匿名类" class="headerlink" title="创建匿名类"></a>创建匿名类</h3><p>例1:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda写法:</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">  () -&gt; System.out.println(<span class="string">"Lambda thread"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p>例2: 你们最讨厌的Comparator接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Score&gt; byName = <span class="keyword">new</span> Comparator&lt;Score&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Score o1, Score o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Collections.sort(list, byName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda写法:</span></span><br><span class="line">Comparator&lt;Score&gt; byName =</span><br><span class="line">  (Score o1, Score o2) -&gt; o1.getName().compareTo(o2.getName());</span><br></pre></td></tr></table></figure><h3 id="表达式迭代-forEach"><a href="#表达式迭代-forEach" class="headerlink" title="表达式迭代 forEach"></a>表达式迭代 forEach</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Default Method"</span>, <span class="string">"Stream API"</span>, <span class="string">"Date and Time API"</span>);</span><br><span class="line"></span><br><span class="line">list.forEach((e) -&gt; System.out.println(e));</span><br><span class="line"><span class="comment">// 或者使用Java 8的方法引用:</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="map-amp-reduce"><a href="#map-amp-reduce" class="headerlink" title="map() &amp; reduce()"></a>map() &amp; reduce()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为每个订单的价格加上12$的税, 并求和</span></span><br><span class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">double</span> bill = costBeforeTax.stream().map((cost) -&gt; cost + <span class="number">0.12</span>*cost).reduce((sum, cost) -&gt; sum + cost).get();</span><br><span class="line">System.out.println(<span class="string">"Total : "</span> + bill);</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>什么是函数式接口？ 简单说就是只拥有一个抽象方法的接口，如Runnable</p><h3 id="Function功能型函数式接口"><a href="#Function功能型函数式接口" class="headerlink" title="Function功能型函数式接口"></a>Function功能型函数式接口</h3><p>类 <code>java.util.function.Function&lt;T,R&gt;</code> 相当于仅含有一个方法的接口类, 这个方法接收一个参数T, 返回类型R.<br>在Java8中, 这种接口类可以用一个lambda表达式来表示.<br>Function只有一个方法apply, 该方法接收一个参数并返回一个值:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; func = x -&gt; x*<span class="number">2</span>;</span><br><span class="line">Integer ii = func.apply(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>除了👆上面这种形式, 在Java8中还增加了<code>::</code>, 称为”方法引用操作符”, <code>对象::方法</code>将返回一个函数接口（function interface），<br>我们可以使用它来引用类的方法. 例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.pow(num , <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyMath myMath = <span class="keyword">new</span> MyMath();</span><br><span class="line">Function&lt;Double, Double&gt; square = myMath::square; <span class="comment">// 声明一个函数式接口实例, 相当于把square方法抽取出来, 增加给这个实例</span></span><br><span class="line"><span class="keyword">double</span> ans = square.apply(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意被<code>::</code>引用的方法需要符合“函数式接口” （一个输入参数一个返回值）</p></blockquote><h3 id="Predicate断言型函数式接口"><a href="#Predicate断言型函数式接口" class="headerlink" title="Predicate断言型函数式接口"></a>Predicate断言型函数式接口</h3><p>类 <code>java.util.function.Predicate&lt;T&gt;</code> 相当于一个”接收一个输入参数T, 返回boolean的lambda表达式”类型 :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; pred = x -&gt; x&gt;<span class="number">5</span>;</span><br><span class="line"><span class="keyword">boolean</span> ret = pred.test();</span><br></pre></td></tr></table></figure><p>使用<code>::</code>方法引用操作符:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.addAll(Arrays.asList(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>));</span><br><span class="line">Predicate&lt;String&gt; pred = set::contains;</span><br><span class="line"><span class="keyword">boolean</span> exists = pred.test(<span class="string">"one"</span>);</span><br></pre></td></tr></table></figure><p>Predicate.test()的更多例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List languages = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">filter(languages, (str)-&gt;str.startsWith(<span class="string">"J"</span>));</span><br><span class="line">filter(languages, (str)-&gt;str.endsWith(<span class="string">"a"</span>));</span><br><span class="line">filter(languages, (str)-&gt;<span class="keyword">true</span>);</span><br><span class="line">filter(languages, (str)-&gt;<span class="keyword">false</span>);</span><br><span class="line">filter(languages, (str)-&gt;str.length() &gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate predicate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String name: names)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(name)) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Predicate.and(), or(), xor()的例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List languages = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(<span class="string">"J"</span>);</span><br><span class="line">Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == <span class="number">4</span>;</span><br><span class="line">languages.stream()</span><br><span class="line">    .filter(startsWithJ.and(fourLetterLong))</span><br><span class="line">    .forEach((n) -&gt; System.out.print(<span class="string">"nName, which starts with 'J' and four letter long is : "</span> + n));</span><br></pre></td></tr></table></figure><h3 id="Consumer消费型函数式接口"><a href="#Consumer消费型函数式接口" class="headerlink" title="Consumer消费型函数式接口"></a>Consumer消费型函数式接口</h3><p>@todo</p><h3 id="Supplier供给型函数式接口"><a href="#Supplier供给型函数式接口" class="headerlink" title="Supplier供给型函数式接口"></a>Supplier供给型函数式接口</h3><p>@todo</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如：</p><ul><li>调用<code>Collection.stream()</code>或者<code>Collection.parallelStream()</code>方法</li><li>调用<code>Arrays.stream(T[] array)</code>方法</li><li>Map类容器无法直接用<code>stream()</code>, 但可以使用<code>map.entrySet().stream()</code>获得流</li></ul><p>常见的stream接口继承关系如图：<br><img src="/images/java/java-stream-hierarchy.png" alt=""></p><h3 id="流-Stream-的特性"><a href="#流-Stream-的特性" class="headerlink" title="流(Stream)的特性"></a>流(Stream)的特性</h3><p>大部分情况下Stream是容器调用<code>Collection.stream()</code>方法得到的，但Stream和Collections有以下不同：</p><ul><li>无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li><li>为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li><li>惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li>可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><h3 id="中间操作-amp-结束操作"><a href="#中间操作-amp-结束操作" class="headerlink" title="中间操作 &amp; 结束操作"></a>中间操作 &amp; 结束操作</h3><p>对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)，二者特点是：</p><ul><li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li><li>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li></ul><p>下表汇总了Stream接口的部分常见方法:</p><table><thead><tr><th>operator</th><th>function</th></tr></thead><tbody><tr><td>中间操作</td><td>concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td></tr><tr><td>结束操作</td><td>allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td></tr></tbody></table><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter(): 函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足predicate条件元素的Stream。</p><blockquote><p>predicate 可以看成是返回boolean的lambda表达式</p></blockquote><p>下面例子中, filter方法接收一个<code>predicate</code>类型的参数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>下面例子中, filter接收的参数是<code>list2::contains</code>， 被引用的方法（这里的contain方法）需符合“predicate”原型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求list1和list2的交集</span></span><br><span class="line">List&lt;T&gt; intersect = list1.stream()</span><br><span class="line">                     .filter(list2::contains)</span><br><span class="line">                     .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><p>distinct(): 函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的Stream。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.distinct()</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h5 id="limit-amp-skip"><a href="#limit-amp-skip" class="headerlink" title="limit &amp; skip"></a>limit &amp; skip</h5><p>limit(n)/skip(n): limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素</p><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p>sorted(): 排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt;　sorted()</code>和<code>Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream().sorted((x, y) -&gt; x-y ).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Map::Entry.comparingByValue和Comparator提供的方法:</span></span><br><span class="line">unsortedMap.entrySet().stream()</span><br><span class="line">.sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))</span><br></pre></td></tr></table></figure><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>map(): 对当前Stream所有元素执行mapper操作, 返回新的Stream</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.map(str -&gt; str.toUpperCase())</span><br><span class="line">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h5><p>flatMap(): “摊平”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把List&lt;Int&gt; 摊平成 Int</span></span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">stream.flatMap(list -&gt; list.stream())</span><br><span class="line">    .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h4 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h4><p>结束操作包括collect, reduce, forEach等, 分别用于聚合和遍历.</p><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>forEach是结束操作, 会立刻执行, 执行结束后Stream失效.<br>方法定义为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历。<br><em>通常我们在使用forEach时, 也会用来做合并操作</em>。</p><ul><li><p>使用Stream.forEach()迭代</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></li><li><p>在forEach中进行合并:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Combine map1 and map2</span></span><br><span class="line"><span class="comment">// Map.merge()用于相同k的合并</span></span><br><span class="line">Map&lt;String,Integer&gt; mergedMap = <span class="keyword">new</span> HashMap(map1);</span><br><span class="line">map2.forEach((k,v) -&gt; mergedMap.merge(k,v, Integer::Sum));</span><br></pre></td></tr></table></figure></li></ul><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><p>规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。<br>Stream类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。<br>其原型为：<br><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></p><p><code>reduce()</code>最常用的场景就是从一组值中生成一个值，<code>reduce()</code>的方法定义有三种重写形式：</p><ol><li><p><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code>: 返回的类型<code>Optional</code>表示（一个）值的容器，使用它可以避免null值的麻烦。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure></li><li><p><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">23</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">97</span>,<span class="number">32</span>&#125;;</span><br><span class="line"><span class="comment">// 求所有元素的和:</span></span><br><span class="line">Integer sum = Arrays.stream(array).reduce(<span class="number">0</span>, (a, b) -&gt; a+b);</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line">Integer sum = Arrays.stream(array).reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code>:<br>它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求单词长度之和</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">Integer lengthSum = stream.reduce(<span class="number">0</span>,　<span class="comment">// 初始值</span></span><br><span class="line">        (sum, str) -&gt; sum+str.length(), <span class="comment">// 累加器</span></span><br><span class="line">        (a, b) -&gt; a+b);　<span class="comment">// 部分和拼接器，并行执行时才会用到</span></span><br></pre></td></tr></table></figure></li><li><p>更多<code>reduce()</code>的例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求最小值， 有起始值</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接，有起始值, concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接，有起始值, 有filter操作, concat = "ace"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>).</span><br><span class="line">filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>).</span><br><span class="line">reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure></li></ol><h5 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h5><p><code>Stream.collect()</code>方法和类<code>Collectors</code>一起使用, 常用于把一个Stream的结果收集进容器里,<br>考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：</p><ol><li>目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。</li><li>新元素如何添加到容器中？是List.add()还是Map.put()。</li><li>如果并行的进行规约，还需要告诉collect() 多个部分结果如何合并成一个。</li></ol><p>结合以上分析，collect()方法定义为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;R, ? super T&gt; accumulator,</span><br><span class="line">                  BiConsumer&lt;R, R&gt; combiner);</span><br></pre></td></tr></table></figure><p>三个参数依次对应上述三条分析。不过每次调用collect()都要传入这三个参数太麻烦，收集器Collectors就是对这三个参数的简单封装,所以collect()的另一定义为<code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</code>。</p><p><strong>一些例子:</strong></p><ul><li><p>将Stream规约成List</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式１</span></span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList());<span class="comment">// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li><li><p>将Stream转换成List 或Set</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure></li><li><p>Stream转换成map &amp; map排序:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream转换成map:</span></span><br><span class="line"><span class="comment">// Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</span></span><br><span class="line">Map&lt;Integer, String&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// map排序 &amp; 取TopN:</span></span><br><span class="line"><span class="comment">// 对Entry的流进行排序, 然后生成有序的LinkedHashMap:</span></span><br><span class="line">Map&lt;String ,Long&gt; sortedMap = unsortedMap.entrySet().stream()</span><br><span class="line">    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))</span><br><span class="line">    .limit(topN)</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,</span><br><span class="line">                        (oldValue, newValue) -&gt; oldValue,</span><br><span class="line">                        LinkedHashMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure></li><li><p>合并Map1, Map2</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; mx = Stream.of(m1, m2)</span><br><span class="line">        .map(Map::entrySet)          <span class="comment">// converts each map into an entry set</span></span><br><span class="line">        .flatMap(Collection::stream) <span class="comment">// converts each set into an entry stream, then</span></span><br><span class="line">                                    <span class="comment">// "concatenates" it in place of the original set</span></span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.toMap(        <span class="comment">// collects into a map</span></span><br><span class="line">                Map.Entry::getKey,   <span class="comment">// where each entry is based</span></span><br><span class="line">                Map.Entry::getValue, <span class="comment">// on the entries in the stream</span></span><br><span class="line">                Integer::max         <span class="comment">// such that if a value already exist for</span></span><br><span class="line">                                    <span class="comment">// a given key, the max of the old</span></span><br><span class="line">                                    <span class="comment">// and new value is taken</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></li><li><p>拼接字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</span><br><span class="line">String mergedString = stream.filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure></li><li><p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toCollection()指定规约容器的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));<span class="comment">// (3)</span></span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));<span class="comment">// (4)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Stream的底层实现"><a href="#Stream的底层实现" class="headerlink" title="Stream的底层实现"></a>Stream的底层实现</h3><ul><li>stream():  Stream只是一个接口，并没有操作的缺省实现。最主要的实现是ReferencePipeline,而它的一些具体实现又是由AbstractPipeline完成的</li><li>parrallelStream(): 底层使用的是ForkJoinPool, 比较适合使用计算密集型并且没有I/O的任务</li></ul><h2 id="新的Data-amp-Time"><a href="#新的Data-amp-Time" class="headerlink" title="新的Data &amp; Time"></a>新的Data &amp; Time</h2><p>@ref: <a href="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html" target="_blank" rel="noopener">Java 8 新特性概述</a></p><h1 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h1><p>@ref: <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html" target="_blank" rel="noopener">Java 9 新特性概述</a></p><h1 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h1><p>@ref: <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener">Java 10 新特性介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-11-安全和加密</title>
      <link href="/12.Java/Java-Tutorials.11.%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/"/>
      <url>/12.Java/Java-Tutorials.11.%E5%AE%89%E5%85%A8%E5%92%8C%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>java.security 包提供了消息摘要/消息签名等算法.</p><p>将长度不固定的消息（message)作为输入参数，运行特定的Hash函数，生成固定长度的输出，这个输出就是Hash，也称为这个消息的消息摘要（Message Digest）<br>消息签名可以看成是在密钥加密的基础上的消息摘要, 消息摘要和消息签名的作用:</p><ol><li>数据完整性检查</li><li>数据校验, 是否在传递过程中被篡改</li></ol><p>施工中…</p><h2 id="消息摘要-Message-Digest"><a href="#消息摘要-Message-Digest" class="headerlink" title="消息摘要(Message Digest)"></a>消息摘要(Message Digest)</h2><p>有如下几种消息摘要:</p><ul><li>MD5, 任何消息都压缩为16字节(128位)的摘要(指纹), 不推荐使用MD5的原因是?</li><li>SHA1(属于SHA一代), 任何消息都压缩为20字节(160位)的摘要, 所以SHA-1共有最多2^120个摘要;</li><li>SHA256(属于SHA二代), 32字节(256位);</li><li>SHA512</li><li>MAC(或者HMAC算法), 在散列基础上增加了密钥;</li><li>BCrypt: 根据Blowfish加密算法所设计的密码散列函数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MD5 &amp; SHA</span></span><br><span class="line">MessageDigest alg = MessageDigest.getInstance(<span class="string">"SHA-1"</span>); <span class="comment">// 也可以是MD5</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>]; <span class="comment">// bytes存入要计算摘要的信息</span></span><br><span class="line"><span class="keyword">byte</span>[] hash = alg.digest(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HMAC</span></span><br><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"HmacMD5"</span>); <span class="comment">//初始化密钥生成器</span></span><br><span class="line">SecretKey secretKey = keyGenerator.generateKey(); <span class="comment">//产生密钥</span></span><br><span class="line"><span class="keyword">byte</span>[] encoded = secretKey.getEncoded(); <span class="comment">//获取密钥</span></span><br><span class="line">SecretKey restoreSecretKey = <span class="keyword">new</span> SecretKeySpec(encoded, <span class="string">"HmacMD5"</span>); <span class="comment">//还原密钥</span></span><br><span class="line">Mac mac = Mac.getInstance(restoreSecretKey.getAlgorithm()); <span class="comment">//实例化MAC</span></span><br><span class="line">mac.init(restoreSecretKey); <span class="comment">//初始化MAC</span></span><br><span class="line"><span class="keyword">byte</span>[] hmacmd5Bytes = mac.doFinal(src.getBytes()); <span class="comment">//执行摘要计算</span></span><br></pre></td></tr></table></figure><h2 id="消息签名-Message-Signature"><a href="#消息签名-Message-Signature" class="headerlink" title="消息签名(Message Signature)"></a>消息签名(Message Signature)</h2><ul><li>DSA(数字签名)/RSA(公钥/私钥), 例如DSA是利用了对数值巨大的数字进行因数分解的困难性.</li></ul><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul><li>DES</li><li>AES取代DES</li><li>Blowfish: 对称密钥区块加密算法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***** DES *****/</span></span><br><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">keyGenerator.init(<span class="number">56</span>);<span class="comment">//设置长度</span></span><br><span class="line">SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = secretKey.getEncoded();</span><br><span class="line"></span><br><span class="line"><span class="comment">//key转换</span></span><br><span class="line">DESKeySpec desKeySpec = <span class="keyword">new</span> DESKeySpec(keyBytes);</span><br><span class="line">SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">SecretKey generateSecret = secretKeyFactory.generateSecret(desKeySpec);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"DES/ECB/PKCS5Padding"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, generateSecret);</span><br><span class="line"><span class="keyword">byte</span>[] result = cipher.doFinal(src.getBytes());</span><br><span class="line">System.out.println(Hex.encodeHexString(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE,generateSecret);<span class="comment">//使用同一个key</span></span><br><span class="line">result = cipher.doFinal(result);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(result));</span><br></pre></td></tr></table></figure><h3 id="blowfish-amp-bcrypt"><a href="#blowfish-amp-bcrypt" class="headerlink" title="blowfish &amp; bcrypt"></a>blowfish &amp; bcrypt</h3><p><a href="https://stackoverflow.com/questions/5244950/encryption-with-blowfish-in-java" target="_blank" rel="noopener">Encryption with BlowFish in Java - Stack Overflow</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blowfish</span></span><br><span class="line">String Key = <span class="string">"Something"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] KeyData = Key.getBytes();</span><br><span class="line">SecretKeySpec KS = <span class="keyword">new</span> SecretKeySpec(KeyData, <span class="string">"Blowfish"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"Blowfish"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, KS);</span><br><span class="line"><span class="keyword">byte</span>[] encryptedData = cipher.doFinal(toEncryptString.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line">Cipher cipher2 = Cipher.getInstance(<span class="string">"Blowfish"</span>);</span><br><span class="line">cipher2.init(Cipher.DECRYPT_MODE, KS);</span><br><span class="line"><span class="keyword">byte</span>[] decryptedData = cipher2.doFinal(encryptedData.getBytes());</span><br></pre></td></tr></table></figure><p>BCrypt是基于Blowfish加密算法所设计的密码散列函数, 代码<a href="http://www.mindrot.org/projects/jBCrypt/" target="_blank" rel="noopener">jBCrypt - strong password hashing for Java</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bcrypt</span></span><br><span class="line">String password = <span class="string">"testpassword"</span>;</span><br><span class="line">String hashed = BCrypt.hashpw(password, BCrypt.gensalt(<span class="number">12</span>)); <span class="comment">// 2的12次方</span></span><br><span class="line"><span class="comment">// 返回的hashed 字符串包括盐</span></span><br><span class="line"><span class="comment">// $2a$10$vI8aWBnW3fID.ZQ4/zo1G.q1lRps.9cGLcZEiGDMVr5yUP1KUOYTa</span></span><br><span class="line"><span class="comment">// 2a identifies the bcrypt algorithm version that was used.</span></span><br><span class="line"><span class="comment">// 10 is the cost factor; 2^10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">if</span> (BCrypt.checkpw(candidate, hashed)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul><li>RSA: @todo</li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-10-注解</title>
      <link href="/12.Java/Java-Tutorials.10.%E6%B3%A8%E8%A7%A3/"/>
      <url>/12.Java/Java-Tutorials.10.%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class annotation</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"topicControllerV2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Medhod annotation:</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/load"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TopicLoadResponse <span class="title">topicLoad</span><span class="params">(@RequestParam(value = <span class="string">"client_id"</span>)</span> String appId,</span></span><br><span class="line"><span class="function">    @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"topic_url"</span>)</span> String topicUrl,</span></span><br><span class="line"><span class="function">    @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"topic_source_id"</span>, required = <span class="keyword">false</span>)</span> String topicSourceId) </span>&#123;</span><br><span class="line">      <span class="comment">// ...method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义一个注解"><a href="#定义一个注解" class="headerlink" title="定义一个注解"></a>定义一个注解</h2><p>所有注解都隐式的继承自java.lang.annotation.Annotation</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Controller:</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 使用元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;  <span class="comment">// 注解的定义: modifier @interface Annotation</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>; <span class="comment">// 注解的方法都是这种格式: Type elementName() default defaultVal;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestMapping</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>; <span class="comment">//</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// RequestMethod是枚举类型GET/POST..</span></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取带有特定注解(这里用@YourAnnotation注解为例)的类, 使用了org.reflections.Reflections工具类:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reflections reflections = <span class="keyword">new</span> Reflections(<span class="string">"org.test"</span>);</span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(YourAnnotation.class);</span><br></pre></td></tr></table></figure></p><h2 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h2><p>JavaSE在java.lang.annotation和javax.annotation包定义了大量注解, 其中4个是元注解, 用于定义一般注解 &amp;描述注解的行为属性.</p><ul><li>@Deprecated: 所有场合,包 &amp; 类 &amp; 方法 &amp; 属性</li><li>@SuppressWarnings: 类 &amp; 方法 &amp; 属性, 阻止某种警告信息, <code>@SuppressWarnings(value={&quot;unchecked&quot;,&quot;deprecation&quot;})</code></li><li>@Override: 只有方法</li><li>@Resources: ?</li><li>@Resource: 可以写在属性上, 和setter方法上, 默认按照名称进行装配</li><li>@PostConstruct 方法, 指明该方法在构造器之后立刻被调用</li><li>@PreDestory 方法, 指明该方法在类被销毁前调用</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><ol><li>@Target:<ul><li><code>@Target(ElementType.TYPE)</code>     // 类, 接口, 枚举, 注解</li><li><code>@Target(ElementType.METHOD)</code>    //方法</li><li><code>@Target(ElementType.PARAMETER)</code> //方法参数</li><li><code>@Target(ElementType.FIELD)</code>     //字段</li></ul></li><li>@Retention:<ul><li><code>@Retention(RetentionPolicy.SOURCE)</code>   //注解仅存在于源码中, 在class字节码文件中不包含</li><li><code>@Retention(RetentionPolicy.CLASS)</code>    // 默认的保留策略, 注解会在class字节码文件中存在, 但运行时无法获得,</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>  // 注解会在class字节码文件中存在, 在运行时可以通过反射获取到</li></ul></li><li>@Document: 说明该注解将被包含在javadoc中</li><li>@Inherited: 一般在定义注解时使用, 说明这个子类可以继承父类中的这个注解</li></ol>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-09-NIO</title>
      <link href="/12.Java/Java-Tutorials.09.NIO/"/>
      <url>/12.Java/Java-Tutorials.09.NIO/</url>
      
        <content type="html"><![CDATA[<p>@toc:</p><ul><li>NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存）</li><li>NIO高性能的实现（异步非阻塞I/O + 堆外内存）</li><li>网络编程中两种高性能I/O设计模式（多路复用）：Reactor 和 Proactor</li></ul><h1 id="从BIO到NIO"><a href="#从BIO到NIO" class="headerlink" title="从BIO到NIO"></a>从BIO到NIO</h1><blockquote><p>BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。<br>Java NIO是java 1.4之后新出的一套IO接口，这里的的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。<br>NIO（Non-blocking I/O）是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p></blockquote><h1 id="NIO包介绍"><a href="#NIO包介绍" class="headerlink" title="NIO包介绍"></a>NIO包介绍</h1><p>Java Non-blocking I/O主要有三大核心部分：<code>Channel</code>(通道)，<code>Buffer</code>(缓冲区), <code>Selector</code>；<br>除此之外，Java NIO还包括了新的文件/目录的操作: <code>Path</code>和<code>Files</code>。</p><ol><li>java.nio.channels 包：<ul><li><code>java.nio.channels.ServerSocketChannel</code></li><li><code>java.nio.channels.SocketChannel</code></li><li><code>java.nio.channels.FileChannel</code></li></ul></li><li><code>java.nio.channels.SocketChannel.Selector</code> 类</li><li>java.nio.Buff 接口：<ul><li><code>java.nio.ByteBuffer</code>: 最基本的字符buff, 从<code>Channel</code>(ServerSocketChannel, FileChannel等)读取出的内容放在<code>ByteBuffer</code>里, 或者通过<code>Channel.write</code>把ByteBuffer内容写入Channel;</li><li><code>java.nio.MappedByteBuffer</code>: FileChannel通道打开的文件映射到内存, 通过<code>MappedByteBuffer</code>来操作;</li></ul></li><li>java.nio.file 包：<ul><li><code>java.nio.file.Path</code>: Path的实例指代一个目录或文件</li><li><code>java.nio.file.Paths</code>: Path的工厂类, 用于获取Path实例</li><li><code>java.nio.file.Files</code>: 提供对<code>Path</code>的操作</li></ul></li></ol><p>▶ BIO和NIO的对比变化如下:</p><ul><li>(1) BIO流 vs NIO管道:<ul><li>Java BIO的各种流的读写都是阻塞操作。这意味着一个线程一旦调用了read(),write()方法但系统缓冲区没数据可读，那么该线程会进入阻塞状态（Blocked）。</li><li>NIO读写都是非阻塞的, NIO基于Channel(管道)和Buffer(缓冲区)进行操作：数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Channel可以是文件也可以是Socket；</li></ul></li><li>(2) NIO里新增了Selector，用于监听多个Channel的事件，当Channel产生可读写事件后, 用ByteBuffer读取数据。<br>Selector允许一个单一线程监听多个Channel输入。我们可以注册多个Channel到Selector上，然后然后用一个线程来挑出一个处于可读或者可写状态的Channel。Selector机制使得单线程管理过个Channel变得容易。</li><li>(3) NIO的提供了<code>Path</code>和<code>Files</code>来取代io包中的<code>File</code>, <code>Path</code>的实例指代一个目录或文件，<code>Files</code>则提供了对目录或文件的基本操作（exists, copy, move, delete）</li></ul><h2 id="NIO-ByteBuffer"><a href="#NIO-ByteBuffer" class="headerlink" title="NIO ByteBuffer"></a>NIO ByteBuffer</h2><p>ByteBuffer的属性、方法:</p><ul><li>属性 capacity &gt;= limit &gt;= position &gt;= mark<ul><li><code>capacity</code>: 指定数组大小, Buffer创建后就不可改变;</li><li><code>limit</code>: 最大可以读的到位置, 初始值等于capacity, 调用flip()方法后limit=position</li><li><code>position</code>: 当前的读写位置, 初始值0, 每次写入一个字节position+1, 每次读都是从position++位置读一个字节</li><li><code>mark</code>: 初始值-1, 备忘位置, 参加mark()/reset()方法</li></ul></li><li><code>ByteBuffer.allocate(int)</code>: 创建buff并初始化大小</li><li><code>put(byte)</code>, <code>put(byte[])</code>: 向buff存储数据</li><li><code>get()</code>, 返回position位置的一个byte</li><li><code>flip()</code>, 向Buffer写完数据开始读数据前要调用一次, 把position的值赋给limit, 然后position=0, 然后可以调用get()从position读出字节;</li><li><code>rewind()</code>, position=0, mark=-1, 不改变limit的值, 可以再读一遍[0~limit]的字节</li><li><code>mark()</code>: mark=position, 调用mark()来记录当前position</li><li><code>reset()</code>: position=mark, 调用reset()让position置为mark的值, 一次reset()对应一次mark()</li><li><code>clear()</code>: limit,position,mark置为初始值;</li><li><code>compact()</code>: 清除未读的数据, 将所有未读的数据拷贝到buffer起始处</li><li><code>equals()</code>: 比较两个buff剩余未读的字节数, 比较剩余的每一个字节</li><li><code>compareTo()</code>: ..</li></ul><blockquote><p>ByteBuffer内部是由一个数组实现的, 所以capacity理论最大值受<code>MAX_Integer</code>和<code>-Xmx</code>限制</p></blockquote><h2 id="NIO-Channel"><a href="#NIO-Channel" class="headerlink" title="NIO Channel"></a>NIO Channel</h2><p>@todo</p><h2 id="NIO-Selector"><a href="#NIO-Selector" class="headerlink" title="NIO Selector"></a>NIO Selector</h2><p>@todo</p><h2 id="Files-amp-Path"><a href="#Files-amp-Path" class="headerlink" title="Files &amp; Path"></a>Files &amp; Path</h2><p>示例代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioPathAndFiles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    Path path = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> pathExists =</span><br><span class="line">        Files.exists(path,</span><br><span class="line">            <span class="keyword">new</span> LinkOption[]&#123; LinkOption.NOFOLLOW_LINKS&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目录</span></span><br><span class="line">    Path path2 = Paths.get(<span class="string">"data/subdir"</span>);</span><br><span class="line">    Files.createDirectory(path2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"~/text.txt"</span>);</span><br><span class="line">    <span class="comment">//通过bufferedReader读取</span></span><br><span class="line">    BufferedReader bufferedReader = Files.newBufferedReader(path, StandardCharsets.UTF_8);<span class="comment">//文件编码</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String tempString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((tempString = bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sb = sb.append(tempString);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    <span class="comment">//通过Files方法readAllLines</span></span><br><span class="line">    List&lt;String&gt; strings = Files.readAllLines(path);</span><br><span class="line">    strings.forEach(s -&gt; System.out.print(s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pulic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"/text"</span>);</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    Files.write(path, <span class="string">"Hello JDK7!"</span>.getBytes(), StandardOpenOption.APPEND);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NIO网络读写"><a href="#NIO网络读写" class="headerlink" title="NIO网络读写"></a>NIO网络读写</h2><p>API说明:</p><ul><li>服务端:<ul><li><code>ServerSocketChannel.open()</code> : 创建一个server socket channel实例, 相当于传统Socket的<code>ServerSocket</code></li><li><code>ServerSocketChannel.socket().bind(SocketAddress local)</code> : 绑定端口</li><li><code>ServerSocketChannel.configureBlocking(false)</code>: 把server socket channel设置为 <strong>非阻塞</strong> 的情况下, <code>accept()/read()/write()</code>会立刻返回;</li><li><code>ServerSocketChannel.accept()</code>: 阻塞, 并在有客户端成功连接时返回一个<code>SocketChannel</code>实例</li><li><code>ServerSocketChannel.register(Selector, EVENT)</code>: 为server channel注册监听的事件</li></ul></li><li>Selector:<ul><li><code>Selector.open()</code>: 创建一个selector实例</li><li><code>Selector.select()</code>: 开始监听并阻塞</li></ul></li><li>客户端:<ul><li><code>SocketChannel.configureBlocking(false)</code>: 把socket channel设置为非阻塞, 读写会立刻返回</li><li><code>SocketChannel.write(ByteBuffer)</code>: 写方法</li><li><code>SocketChannel.read(ByteBuffer)</code>: 读方法, 返回值是读取的字节数</li></ul></li></ul><p>用NIO API实现简单的Socket Server（用<code>Selector</code>实现多路复用, 用<code>Channel.configureBlocking(false)</code>设置为非阻塞I/O）:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer echoBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ServerSocketChannel实例, 并绑定端口</span></span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channel 绑定 Selector, 并注册 Read</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">SelectionKey regKey = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">  <span class="comment">// 在这里阻塞</span></span><br><span class="line">  <span class="keyword">int</span> num = selector.select();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行到这里表示有事件产生</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">      SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">          <span class="comment">// 取出服务端SocketChannel</span></span><br><span class="line">          ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">          <span class="comment">// 接受请求, 返回客户端SocketChannel</span></span><br><span class="line">          SocketChannel sc = serverSocketChannel.accept();</span><br><span class="line">          <span class="comment">// 客户端SocketChannel设置NoneBlock</span></span><br><span class="line">          sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 客户端SocketChannel也添加进</span></span><br><span class="line">          SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          <span class="comment">// 不要忘记删除</span></span><br><span class="line">          it.remove();</span><br><span class="line">          System.out.println(<span class="string">"Got connection from "</span> + sc);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;</span><br><span class="line">          <span class="comment">// 取出可读的channel</span></span><br><span class="line">          SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理数据</span></span><br><span class="line">          <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              echoBuffer.clear();</span><br><span class="line">              <span class="keyword">int</span> r = sc.read(echoBuffer);</span><br><span class="line">              <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">              echoBuffer.flip();</span><br><span class="line">              sc.write(echoBuffer);</span><br><span class="line">              bytesEchoed += r;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">"Echoed "</span> + bytesEchoed + <span class="string">" from "</span> + sc);</span><br><span class="line">          it.remove();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结: NIO 的Socket 多路复用如下:</p><ul><li>创建服务端 socketChannel</li><li>创建 Selector</li><li>服务端 socketChannel 在 Selector上注册 ACCEPT事件</li><li>While循环<ul><li>selector.select() 阻塞, 如果 Selector上有事件发生, 退出阻塞</li><li>selector取出所有事件集合, 并遍历</li><li>如果有 ACCEPT 事件, 服务端 socketChannel去accept这个请求, 创建 客户端 socketChannel, 并在Selector上注册该 channel的 READ事件</li><li>如果有 READ 事件, 读对应的 客户端 socketChannel</li></ul></li></ul><h3 id="与传统Socket比较"><a href="#与传统Socket比较" class="headerlink" title="与传统Socket比较"></a>与传统Socket比较</h3><p>从上面的代码可以看到,</p><ul><li>传统的Java Socket(BIO, 阻塞IO), 等同于<code>java.net + java.io</code>, 使用的”Socket句柄”是<code>java.net.ServerSocket</code>(服务端socket)和<code>java.net.Socket</code>(客户端socket), 通过<code>Socket</code>获取InputStream/OutpubtStream进行读/写.</li><li>NIO Socket使用的”socket句柄”是<code>java.nio.channels</code>包下面的<code>ServerSocketChannel</code>和<code>SocketChannel</code>, SocketChannel的读写是通过<code>java.nio.ByteBuffer</code></li><li>前者IO方法是阻塞的, 后者IO方法是非阻塞 // ?</li></ul><h4 id="多线程-BIO缺陷"><a href="#多线程-BIO缺陷" class="headerlink" title="多线程-BIO缺陷"></a>多线程-BIO缺陷</h4><ul><li>线程的创建和销毁成本很高</li><li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千…</li><li>线程的切换成本是很高</li><li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，高并发下会使系统负载压力过大</li></ul><blockquote><p>BIO(阻塞IO)模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能阻塞等待。<br>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。<br>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。<br>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。</p></blockquote><p>以上参考: <a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a> @ref</p><h2 id="NIO大文件读写"><a href="#NIO大文件读写" class="headerlink" title="NIO大文件读写"></a>NIO大文件读写</h2><p>大文件读写几种方案:</p><ul><li>传统IO读取方式:<ul><li>字节方式读取: FileInputStream VS BufferedInputStream</li><li>字符方式读取: BufferedReader</li></ul></li><li>NIO读取:<ul><li>FileChannel + ByteBuffer</li><li>MappedByteBuffer(内存映射)</li></ul></li></ul><p>测试结论参考:  <a href="https://blog.csdn.net/yiifaa/article/details/78141622" target="_blank" rel="noopener">JAVA NIO(六)：读取10G的文件其实很容易 - CSDN博客</a> @ref</p><h3 id="传统NIO读取"><a href="#传统NIO读取" class="headerlink" title="传统NIO读取:"></a>传统NIO读取:</h3><p><code>java.io.RandomAccessFile</code>提供了文件随机读写,<br>下面的代码是使用nio中的<code>FileChannel</code>和<code>ByteBuffer</code> 从<code>RandomAccessFile</code>中读取:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel(); <span class="comment">// 1 获取channel</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((read = fileChannel.read(buffer)) &gt; <span class="number">0</span>) &#123; <span class="comment">// 2 读channel到ByteBuffer</span></span><br><span class="line">    buffer.flip(); <span class="comment">// 3 开始读之前flip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲器读入数组, 省略处理过程...</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[read];</span><br><span class="line">    buffer.get(bytes); <span class="comment">// 4</span></span><br><span class="line">    buffer.clear();  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">fileChannel.close();</span><br><span class="line">randomAccessFile.close();</span><br></pre></td></tr></table></figure><h3 id="使用内存映射"><a href="#使用内存映射" class="headerlink" title="使用内存映射:"></a>使用内存映射:</h3><p>nio.FileChannel还提供了内存映射的方式读取文件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"><span class="keyword">long</span> length = randomAccessFile.length();</span><br><span class="line"><span class="comment">// 整个文件映射到内存:</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mappedByteBuffer.hasRemaining()) &#123;</span><br><span class="line">    mappedByteBuffer.get(); <span class="comment">//读取1字节</span></span><br><span class="line">    sum ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Close file &amp; channel</span></span><br></pre></td></tr></table></figure><h3 id="内存映射读取的优劣"><a href="#内存映射读取的优劣" class="headerlink" title="内存映射读取的优劣"></a>内存映射读取的优劣</h3><ul><li>内存映射方式的读取速度更快<ul><li>read()是系统调用, 首先将文件从硬盘拷贝到内核空间的一个缓冲区, 再将这些数据拷贝到用户空间, 实际上进行了两次数据拷贝.</li><li>map()也是系统调用, 但没有进行数据拷贝, 当缺页中断发生时, 直接将文件从硬盘拷贝到用户空间, 只进行了一次数据拷贝.</li></ul></li><li>MappedByteBuffer使用虚拟内存, 因此分配(map)的内存大小不受JVM的-Xmx参数限制, 但是也是有大小限制的;</li><li>如果当文件超出1.5G限制时, 可以通过position参数重新<code>map(mode, position, size)</code>文件后面的内容;</li><li>MappedByteBuffer在处理大文件时的确性能很高, 但也存在一些问题, 如内存占用/文件关闭不确定, 被其打开的文件只有在垃圾回收的才会被关闭, 而且这个时间点是不确定的。javadoc中也提到：”A mapped byte buffer and the file mapping that it represents remain* valid until the buffer itself is garbage-collected.”</li></ul><p>参考: <a href="http://blog.jobbole.com/104880/" target="_blank" rel="noopener">深入浅出 MappedByteBuffer</a> v</p><h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。<br>堆外内存默认是和<code>-Xmx</code>默认一样大，也可以使用<code>-XX:MaxDirectMemorySize</code>指定堆外内存大小</p><h3 id="堆内-vs-堆外"><a href="#堆内-vs-堆外" class="headerlink" title="堆内 vs 堆外"></a>堆内 vs 堆外</h3><ul><li><strong>堆外内存</strong>减少了堆内内存的垃圾回收, 减少STW停顿;</li><li>使用Java的 <strong>堆内内存</strong> 进行IO操作, 会比C Native的程序多一次内存拷贝。为什么呢？</li></ul><blockquote><p>Java的IO底层也是调用了C Native的<code>read()/write()</code>函数, 这些函数需要传入<code>void *</code>类型的内存地址, 并且这个内存地址指向的内容不能被改变, 否则<code>read()/write()</code>操作的内存就错了;<br>有些GC回收器会整理内存, Java对象在内存的地址会被改变,<br>所以使用堆内内存进行IO操作, 需要先把堆内内容copy到JVM堆外的连续内存, 然后传递给C的<code>read()/write()</code>, 这就多了一次内存拷贝;<br>JVM规范没有要求<code>byte[]</code>一定是物理连续的, 但是C里用<code>malloc()</code>分配的内存是连续的;</p></blockquote><h3 id="How-to创建堆外内存"><a href="#How-to创建堆外内存" class="headerlink" title="How to创建堆外内存"></a>How to创建堆外内存</h3><p>三种方式创建堆外内存：Auto</p><ol><li><p>使用NIO提供的分配方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(1024); // 返回的是HeapByteBuffer</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocateDirect(1024);  // 返回的是DirectByteBuffer</span><br></pre></td></tr></table></figure></li><li><p>使用NIO提供的堆外内存相关的类：<code>DirectByteBuffer</code>，<code>MappedByteBuffer</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DirectByteBuffer</span><br><span class="line">DirectByteBuffer dbf = new DirectByteBuffer(1024);</span><br><span class="line"></span><br><span class="line">// MappedByteBuffer可以通过FileChannel实例获取, 用于文件内存映射</span><br></pre></td></tr></table></figure></li><li><p>直接使用unsafe:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();</span><br><span class="line">long pointer = unsafe.allocateMemory(1024);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>DirectByteBuffer该类本身还是位于Java内存模型的堆中。<br>而DirectByteBuffer构造器中调用<code>unsafe.allocateMemory(size)</code>是个一个native方法，这个方法分配的是堆外内存，通过C的malloc来进行分配的。并不属于JVM内存。</p></blockquote><h3 id="堆外内存释放"><a href="#堆外内存释放" class="headerlink" title="堆外内存释放"></a>堆外内存释放</h3><ul><li>通过堆内对象触发GC, 堆内对象和指向的堆外内存一并被回收;</li><li>通过Unsafe回收;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeDirectMemoryExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> address = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FreeDirectMemoryExample</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">address = unsafe.allocateMemory(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.finalize();</span><br><span class="line">unsafe.freeMemory(address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆外内存GC"><a href="#堆外内存GC" class="headerlink" title="堆外内存GC"></a>堆外内存GC</h3><p>如果堆外内存容量超过了<code>-XX:MaxDirectMemorySize</code> 会发生<code>OutOfMemoryError: Direct buffer memory</code>，<br>如果GC 回收了 DirectBuffer 对象，那么 DirectBuffer 对象指向的堆外内存，会在GC的后期被回收，<br>如果Java程序使用的堆内内存（Heap）占用率不高但是却大量使用DirectBuffer分配堆外内存，<br>这种情况下不会因为堆内内存触发 Full GC也就无法自动释放堆外内存，<br>所以通常需要调用 <code>System.gc()</code> 来强制回收 堆外内存（但是线上环境不建议这样触发Full GC），这种情况下一定确保不能启用了 <code>-XX:+DisableExplicitGC</code> 导致 <code>System.gc()</code>被禁用。</p><blockquote><p><code>System.gc()</code>会建议JVM进行Full GC, 对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存.<br>DirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象.<br>JVM 发生 YGC（Young gc很频繁, 会STW, 但是Copy GC算法的STW极短）的时候会将新生代里的不可达的 DirectByteBuffer 对象及其堆外内存回收了，但是无法对Old Gen里的 DirectByteBuffer 对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题。( 并且堆外内存多用于生命期中等或较长的对象 )<br>如果有大量的 DirectByteBuffer 对象移到了Old Gen，但是又一直没有做Old Gen 的CMS GC或者Gull GC，那么物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多。</p></blockquote><h2 id="本章参考"><a href="#本章参考" class="headerlink" title="本章参考"></a>本章参考</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门</a></li><li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a></li><li><a href="https://yq.aliyun.com/articles/2371" target="_blank" rel="noopener">理解Java NIO-博客-云栖社区-阿里云</a></li></ul><h1 id="NIO高性能是如何实现的"><a href="#NIO高性能是如何实现的" class="headerlink" title="NIO高性能是如何实现的"></a>NIO高性能是如何实现的</h1><ol><li>使用异步非阻塞实现高效的单线程轮询，避免阻塞式IO开多线程的方式。// NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（Selector），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。<ul><li>NIO的读写函数可以立刻返回（用<code>Channel.configureBlocking(false)</code>设置该通道为非阻塞），如果一个连接不能读写（<code>socket.read()</code>返回0或者<code>socket.write()</code>返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</li><li>Java的<code>Selector</code>对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</li></ul></li><li>使用DirectBuffer减少IO时数据拷贝次数：<ul><li>使用堆内内存的时候，比如我们要完成一个从文件中读数据到堆内内存的操作，调用<code>FileChannelImpl.read(HeapByteBuffer)</code>实际上File IO会将数据读到堆外内存中，然后堆外内存再将这部分堆外数据拷贝到堆内内存。// 为什么Java IO会多一次内存拷贝?</li><li>如果直接使用堆外内存，如<code>DirectByteBuffer</code>，这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，程序通过JNI, 直接将这部分的内存数据通过<code>read()/write()</code>到堆外内存中。</li></ul></li></ol><p>➤ 比较传统IO</p><ul><li>NIO提供了直接内存的 ByteBuffer, 相比堆内内存, 在read/write时使用直接内存可以减少一次内存拷贝 // 但DirectByteBuffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能</li><li>NIO多了非阻塞IO + 多路复用Selector</li><li>非阻塞IO意味着不必再用多线程的方式, 节省了线程调度和切换的开销(以及线程内存的开销)</li><li>Selector可以使用一个线程即可管理大量IO连接的读写事件.</li><li>BIO的”每个连接一个线程”, 比较Netty的多线程, 区别是?</li></ul><h1 id="NIO-amp-Reactor"><a href="#NIO-amp-Reactor" class="headerlink" title="NIO &amp; Reactor"></a>NIO &amp; Reactor</h1><h2 id="Proactor-vs-Proactor"><a href="#Proactor-vs-Proactor" class="headerlink" title="Proactor vs Proactor"></a>Proactor vs Proactor</h2><p>[[../21.Operating-System/Linux.21.网络编程#高性能I/O设计模式]]</p><h2 id="Reactor三种常见线程模型"><a href="#Reactor三种常见线程模型" class="headerlink" title="Reactor三种常见线程模型"></a>Reactor三种常见线程模型</h2><p>➤ 三种Reactor线程模型:</p><ul><li>单线程 Reactor模型</li><li>多线程 Reactor模型</li><li>主从线程 Reactor模型</li></ul><p>➤ Reactor &amp; Proactor IO模型的角色:</p><ul><li>Demultiplexer: 多路复用器, select or epoll 的抽象, 产生IO事件</li><li>Dispatcher: 分发器, 将多路复用器产生的事件进行分发</li><li>Acceptor: accept事件处理器(函数)</li><li>IOHandler: IO事件处理器(函数)</li></ul><blockquote><p>@ref: <a href="https://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reactor_pattern</a></p></blockquote><p>➤ 单线程 Reactor 模型: 一个 Reactor Thread,  负责处理全部 I/O事件(accept, read, send), 以及业务代码(decode, compute, encode)</p><ul><li>在一个 Reactor Thread 里, select 监听 accept/read/write事件, 事件由 Dispatcher 进行分发:<ul><li>有accept事件, Dispatcher 分发给 Acceptor 进行握手/鉴权等处理;</li><li>有read/write事件, Dispatcher 分发给 IOHandler: 进行 read → decode → compute → encode → send ;</li></ul></li><li>缺点: 当某个Handler阻塞时，会导致其他客户端的handler和accpetor都得不到执行，无法做到高性能，只适用于业务处理非常快速的场景<br><img src="/images/java/Reactor-Single-Thread.png" alt=""></li></ul><p>➤ 线程池 Reactor 模型: 一个 Reactor Thread, 负责处理全部 I/O事件(accept, read, send), 但业务代码交给线程池处理..</p><ul><li>Reactor Thread 里, select 监听 accept/read/write事件, 事件由 Dispatcher 进行分发:<ul><li>有accept事件, 处理同单线程模型;</li><li>有read事件, Dispatcher 分发给 IOHandler处理 (函数调用, 仍在 Reactor线程里), 也就是在Reactor线程里进行非阻塞read;</li><li>从Worker Thread Pool 取出一个Worker, 对读到的数据进行 decode → compute → encode 处理流程;</li><li>Worker的结果交还给 Reactor Thread, 由 Reactor Thread 进行send;</li></ul></li><li>比较单线程模型, 多线程Reactor模型仍在主线程里处理读/写操作, 不再处理业务代码, 业务代码交给线程池执行;</li><li>缺点: Reactor Thread 仍然负责全部的accept/read/write的处理, 如果在 Reactor Thread 进行有大量读写事件, 同时大量连接事件(在accept时进行鉴权等), 这时候仍会有单线程的瓶颈</li></ul><p><img src="/images/java/Reactor-Work-Thread-Pool.png" alt=""></p><p>➤ 主从多线程 Reactor 模型: 不再是一个 Reactor Thread, 有 Main Reactor &amp; Sub Reactor 两个线程, 分别处理 accept事件 &amp; IO事件, 业务代码交给线程池处理</p><ul><li>有多个 Reactor Thread (main and sub), 每个 Reactor Thread 有自己的 Selector;</li><li><strong>Main Reactor Thread</strong> 的 Selector负责监听 accept 事件, 交给 Acceptor 处理;</li><li>Acceptor 接受请求之后创建新的 SocketChannel, 并处理鉴权/握手等;</li><li>完成上一步处理的 SocketChannel, 从 Main Reactor Thread 的 Selector移除, 并注册到 Sub Reactor Thread 的 Selector上;</li><li><strong>Sub Reactor Thread</strong> 的 Selector监听 SocketChannel的 read事件, 并调用 IOHandler进行非阻塞 read;</li><li>Worker Thread Pool 处理 decode → compute → encode 流程 …</li></ul><p><img src="/images/java/Reactor-Multiple-Thread.png" alt=""></p><blockquote><p>@ref: Scalable IO in Java - Doug Lea, State University of New York at Oswego [[../_attachments/Scalable IO in Java - Doug Lea.pdf]]</p></blockquote><h2 id="Netty-实现多线程-Reactor"><a href="#Netty-实现多线程-Reactor" class="headerlink" title="Netty 实现多线程 Reactor"></a>Netty 实现多线程 Reactor</h2><p>▶ Netty中重要的 API类:</p><ul><li>NioEventLoop:<ul><li>继承自 SingleThreadEventExecutor, 只有一个线程的线程池</li><li>每个 NioEventLoop 都有一个 Selector, 可以用来监听 accept/r/w事件</li></ul></li><li>NioEventLoopGroup: 一个NioEventLoopGroup 管理多个 NioEventLoop, 构造函数可以指定管理 NioEventLoop的个数, 如果没有设置，默认取 -Dio.netty.eventLoopThreads，如果该系统参数也没有指定，则为可用的 CPU 内核数 × 2。</li></ul><p>▶ 用 Netty 实现多线程 Reactor:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ServerHandlerInitializer());</span><br></pre></td></tr></table></figure><ul><li>Netty Server 创建两个 <code>NioEventLoopGroup</code>: bossGroup 和 workerGroup;</li><li>bossGroup线程组 通常只有一个 <code>EventLoop</code>线程(Boss线程), 这个线程作为 <strong>Main Reactor Thread</strong>, 负责 select监听端口的 accept事件并进行后续处理(创建SocketChannel.. );</li><li>workerGroup线程组, 通常包含 cpu core数量的 1-2倍个<code>EventLoop</code>线程(Worker线程), 这些 Worker线程作为 <strong>Sub Reactor Threads</strong>;</li><li>Boss线程把创建的 SocketChannel, 顺序分发给 workerGroup线程组中的每一个 Worker线程(类似轮询);</li><li>Worker线程的 Selector监听 SocketChannel的 read事件, 如果有 read事件, 交给 Handler链处理(链式顺序执行 ChannelHandler); // 代码中的 <code>socketChannel.pipline().addLast(ChannelHandler)</code></li><li>ChannelHandler建议: 如果业务代码非常简单且耗时可控, 业务代码可以在 ChannelHandler直接执行. 如果否, 则投递到业务线程池中处理. 「不要把 Netty Server 当作业务容器，对于大多数复杂的业务产品，仍然需要集成或者开发自己的业务容器，做好和 Netty 的架构分层」</li></ul><blockquote><p>@ref <a href="https://www.infoq.cn/article/netty-threading-model" target="_blank" rel="noopener">Netty系列之Netty线程模型 - InfoQ</a></p></blockquote><h1 id="Java对AIO的支持"><a href="#Java对AIO的支持" class="headerlink" title="Java对AIO的支持"></a>Java对AIO的支持</h1><p>AIO(asynchronous I/O): 异步IO, <code>java.nio.channels</code>包做了支持, 包括: <code>AsynchronousSocketChannel</code> /  <code>AsynchronousServerSocketChannel</code> / <code>AsynchronousFileChannel</code></p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-08-网络编程</title>
      <link href="/12.Java/Java-Tutorials.08.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/12.Java/Java-Tutorials.08.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Server/Client的Socket API介绍.</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">Socket client = server.accept(); <span class="comment">// 阻塞</span></span><br><span class="line">InputStream  input  = client.getInputStream();</span><br><span class="line">OutputStream output = client.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> value = input.readDouble();</span><br><span class="line">output.writeDouble(value);</span><br><span class="line"></span><br><span class="line">inpput.close();</span><br><span class="line">output.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(host, port); <span class="comment">// 阻塞</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">...</span><br><span class="line">out.close();</span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">socket.connect(<span class="keyword">new</span> InetSocketAddress(host, port), timeout); <span class="comment">// 阻塞</span></span><br></pre></td></tr></table></figure><h2 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h2><ul><li>Socket.shutdownOutput():</li><li>Socket.shutdownInput():</li><li>boolean isOutputShutdown():</li><li>boolean isInputShutdown():</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="comment">// 向out写入一些数据, 写入完毕, 半关闭socket的输出</span></span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"><span class="comment">// 此时socket仍可以从InputStream读取...</span></span><br><span class="line">socket.shutdown();</span><br></pre></td></tr></table></figure><h2 id="可中断套接字"><a href="#可中断套接字" class="headerlink" title="可中断套接字"></a>可中断套接字</h2><p>当连接到一个套接字时，当前线程将会被阻塞直到建立连接或产生超时为止。java.nio包提供的一个特性——SocketChannel类，与上面的Socket不同，SocketChannel是可以中断的<br>如果发生中断, 下面的操作不会阻塞, 而是抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">channel.socket().connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(channel);</span><br><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (in.hasNextLine())</span><br><span class="line">     String line = in.nextLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07z-并发-多线程设计模式</title>
      <link href="/12.Java/Java-Tutorials.07z.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/12.Java/Java-Tutorials.07z.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>➤ Guarded Suspension模式</p><ul><li>Guarded Suspension 模式:  拿到锁后, <code>while(queue.size()&lt;0) wait()</code></li><li>为什么不用if ?  一般来说 <code>wait()</code> 需要使用 while判断, 因为从 wait中醒来时..</li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015558585" target="_blank" rel="noopener">Java多线程基础（五）——Guarded Suspension模式 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote><p>➤ Balking模式</p><ul><li>Balking 模式: 拿到锁后, if(!changed) return // 不符合立刻返回</li><li>Guarded 和 Balking 的区别?  Guarded 是等到条件可用时再去执行, Balking是条件不可用直接返回</li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015558615" target="_blank" rel="noopener">Java多线程基础（六）——Balking模式 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote><p>➤ Two-phase Termination模式</p><ul><li>两段式终止: 当线程被 Interrupt之后, 此时线程还是 Running 状态, 进入终止处理的流程</li><li>一般性做法: 线程的 <code>while(1) work()</code> 抛出异常后, 在 finally里 做资源释放和清理工作</li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015558833" target="_blank" rel="noopener">Java多线程基础（十二）——Two-phase Termination模式 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07d5-JUC-其他工具类</title>
      <link href="/12.Java/Java-Tutorials.07d5.JUC-%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/12.Java/Java-Tutorials.07d5.JUC-%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>Callable</code>接口类似于Runnable，但是Runnable不会返回结果，并且无法抛出返回结果的异常，<code>Callable</code>功能更强大一些，被线程执行后，可以返回值，这个返回值可以被<code>Future</code>拿到。<br>如果主线程发起IO操作并轮询等待返回结果，这种很适合用Callable/Future。</p><ul><li><code>Callable</code>有些类似<code>Runnable</code>, 它们都是接口, 前者需要实现<code>V call()</code>, 后者需要实现<code>void run()</code>;</li><li>需要用<code>FutureTask</code>包装一下<code>Callable</code>, <code>FutureTask</code>提供了<code>get()</code>方法, 可以获取执行结果;</li><li>创建<code>Thread</code>实例, 通过构造器<code>Thread(FutureTask)</code>, 这里实际还是调用的<code>Thread(Runnable)</code>, <code>FutureTask</code>接口继承自<code>Runnable</code>;</li><li>Future是 <code>ExecutorService.submit(Callable)</code>返回的类型;</li><li>实际上<code>FutureTask</code>实现了<code>Future</code>接口, 通过<code>FutureTask</code> 和 <code>Future</code>类型引用都可以调用 <code>get()</code> , <code>cancel()</code> , <code>isDone()</code> , <code>isCancelled()</code>等方法;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAndFutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FutureTask 示例1:</span></span><br><span class="line"><span class="comment">        由FutureTask直接创建线程,并执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureTaskExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Callable实现类</span></span><br><span class="line">        Callable callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建FutureTask</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread 并开始执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞在此, 直到任务完成:</span></span><br><span class="line">        Integer result = futureTask.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Future 示例2:</span></span><br><span class="line"><span class="comment">        Callable 提交到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lambda创建Callable实现类</span></span><br><span class="line">        Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125; ;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(callable);</span><br><span class="line"></span><br><span class="line">        Integer result = future.get();</span><br><span class="line">        <span class="comment">// 或取消线程</span></span><br><span class="line">        future.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题: <code>FutureTask.cancel()</code> 和 <code>Thread.interrupt()</code>有什么区别?<br>通过查看<code>cancel()</code>的源码发现, 实际<code>cancel()</code>最终还是调用了<code>Thread.interrupt()</code>, 所以, <code>FutureTask.cancel()</code>也无法真正停止异步任务,<br>如果真的需要任务可以被终止/取消, 那么就需要在<code>Runnable</code>或<code>Callable</code>的主循环里捕捉InterruptException异常.</p><h2 id="ListenableFuture-Guava"><a href="#ListenableFuture-Guava" class="headerlink" title="ListenableFuture(Guava)"></a>ListenableFuture(Guava)</h2><p>Guava的 Listenable Future对 Future做了改进，支持注册一个任务执行结束后回调函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 ListenableFuture</span></span><br><span class="line">ListenableFuture&lt;String&gt; listenableFuture =</span><br><span class="line">listeningExecutor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过addCallback() 给 ListenableFuture增加回调</span></span><br><span class="line">Futures.addCallback(ListenableFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something on success</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable thrown)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture-Java8"><a href="#CompletableFuture-Java8" class="headerlink" title="CompletableFuture(Java8)"></a>CompletableFuture(Java8)</h2><p>本节参考:</p><blockquote><ul><li><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">Java CompletableFuture 详解 | 鸟窝</a></li><li><a href="https://colobu.com/2018/03/12/20-Examples-of-Using-Java%E2%80%99s-CompletableFuture/" target="_blank" rel="noopener">[译]20个使用 Java CompletableFuture的例子 | 鸟窝</a></li></ul></blockquote><p>Java8的CompletableFuture参考了Guava的ListenableFuture的思路，CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。</p><p>CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p><p>与Guava ListenableFuture相比，CompletableFuture不仅可以在任务完成时注册回调通知，而且可以指定任意线程，实现了真正的异步非阻塞。</p><p><strong>▶ 创建一个CompletableFuture:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</span><br><span class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></pre></td></tr></table></figure></p><blockquote><p>runAsync方法不支持返回值/supplyAsync可以支持返回值<br>没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。</p></blockquote><p><strong>▶ 使用 thenApply 串行任务:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</span><br></pre></td></tr></table></figure></p><blockquote><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。<br>T：上一个任务返回结果的类型<br>U：当前任务的返回值类型</p></blockquote><p><strong>▶使用 thenAccept 消费处理结果:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action);</span><br><span class="line">public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);</span><br><span class="line">public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor);</span><br></pre></td></tr></table></figure></p><p><strong>▶ 使用 thenCombine 合并任务:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn);</span><br><span class="line">public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn);</span><br><span class="line">public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn,Executor executor);</span><br></pre></td></tr></table></figure></p><blockquote><p>thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。</p></blockquote><p><strong>▶ 使用 thenCompose 流水化处理任务:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) ;</span><br><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor) ;</span><br></pre></td></tr></table></figure></p><blockquote><p>thenCompose 方法允许你对两个 CompletionStage 进行流水线操作，第一个操作完成时，将其结果作为参数传递给第二个操作。</p></blockquote><p><strong>▶ 代码示例1: thenApply/whenComplete/exceptionally</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).thenApply(<span class="keyword">new</span> Function&lt;Long, Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Long t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = t*<span class="number">5</span>;</span><br><span class="line">            System.out.println(<span class="string">"result2="</span>+result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    future.whenComplete(<span class="keyword">new</span> BiConsumer&lt;Void, Throwable&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Void t, Throwable action)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行完成！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    future.exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行失败！"</span>+t.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>▶ anyOf / allOf</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs);</span><br><span class="line">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs);</span><br></pre></td></tr></table></figure></p><blockquote><p>anyOf: 当任意一个CompletableFuture完成后， 创建一个完成的CompletableFuture<br>allOf: 当所有的阶段完成后, 创建一个完成的CompletableFuture</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;List&gt; <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; future1 = rpcService1.invoke();</span><br><span class="line">    CompletableFuture&lt;Double&gt; future2 = rpcService2.invoke();</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture</span><br><span class="line">        .allOf(future1, future2)</span><br><span class="line">        .thenApply(v -&gt; &#123;</span><br><span class="line">            Double d1 = future1.get();</span><br><span class="line">            Double d2 = future2.get();</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(d1, d2);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompletableFuture-Timeout"><a href="#CompletableFuture-Timeout" class="headerlink" title="CompletableFuture-Timeout"></a>CompletableFuture-Timeout</h3><ul><li><p>@ref <a href="https://www.thinbug.com/q/23575067" target="_blank" rel="noopener">Java 8 CompletableFuture中的默认值超时 - Thinbug</a><br>似乎是翻译的 Stack Overflow …</p></li><li><p>@ref <a href="http://iteratrlearning.com/java9/2016/09/13/java9-timeouts-completablefutures.html" target="_blank" rel="noopener">Asynchronous timeouts with CompletableFutures in Java 8 and Java 9</a><br>超时 &amp; CompletableFutures<br>如果直接对CompletableFutures 使用 Future.get(1, TimeUnit.SECONDS) 作为超时, 这样做仍旧阻塞main线程;<br>在Java9中的支持: completeOnTimeout 或者 orTimeout</p></li></ul><h3 id="CompletableFuture-vs-ParallelStream"><a href="#CompletableFuture-vs-ParallelStream" class="headerlink" title="CompletableFuture vs ParallelStream"></a>CompletableFuture vs ParallelStream</h3><ul><li>可以测试这里的代码, 使用 ParallelStream 是使用的 forkJoinPool, 处理过程会回到主线程调用 task</li><li>CompletableFuture 默认也是使用 forkJoinPool, 但没有在主线程里调用task(?), 说明没有用到分治(?)</li><li>如果是计算密集型, 使用 parallel stream, 如果是IO密集, 使用 CompletableFuture</li></ul><blockquote><p>@ref <a href="https://www.jdon.com/idea/java/java-8-completablefuture-vs-parallel-stream.html" target="_blank" rel="noopener">Java8的completablefuture和parallel stream比较 -解道Jdon</a></p></blockquote><h2 id="计数器CountDownLatch"><a href="#计数器CountDownLatch" class="headerlink" title="计数器CountDownLatch"></a>计数器CountDownLatch</h2><blockquote><p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。<br>CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p></blockquote><p>CountDownLatch提供了类似计数器的同步手段, 构造器和主要方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;  &#125;;  //参数count为计数值</span><br><span class="line"></span><br><span class="line">//将count值减1</span><br><span class="line">public void countDown() &#123; &#125;;</span><br><span class="line"></span><br><span class="line">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="line">public void await() throws InterruptedException &#123; &#125;;</span><br><span class="line"></span><br><span class="line">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 在这里阻塞直到latch执行过两次countDown()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他参考: <a href="http://www.importnew.com/15731.html" target="_blank" rel="noopener">什么时候使用CountDownLatch - ImportNew</a> @ref</p></blockquote><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>Semaphore翻译成字面意思为 “信号量”，Semaphore可以控同时访问的任务个数，通过 acquire() 获取一个许可，如果没有就等待； release() 释放一个许可。<br>构造器和主要方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了一个fair表示是否是公平的，即等待时间越久的越先获取许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125;     <span class="comment">//获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    <span class="comment">//获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125;          <span class="comment">//释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;    <span class="comment">//释放permits个许可</span></span><br></pre></td></tr></table></figure><h2 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h2><p>@todo</p><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>Java在JDK 7之后加入了并行计算的框架Fork/Join，可以解决我们系统中大数据计算的性能问题。Fork/Join采用的是分治法，Fork是将一个大任务拆分成若干个子任务，子任务分别去计算，而Join是获取到子任务的计算结果，然后合并，这个是递归的过程。子任务被分配到不同的核上执行时，效率最高。</p><p>Fork/Join框架的核心是<code>ForkJoinPool</code>(类似<code>ExecuteService</code>会给线程池中的线程分发任务，不同之处在于它使用了工作窃取算法，所谓工作窃取，是采用分治法的思想，将一个大任务拆分为若干互不依赖的子任务，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务。同时，为了最大限度地提高并行处理能力，采用了工作窃取算法来运行任务，也就是说当某个线程处理完自己工作队列中的任务后，尝试当其他线程的工作队列中窃取一个任务来执行，直到所有任务处理完毕。</p><p><code>ForkJoinTask</code>是一个抽象类，有两个实现子类，<code>RecursiveTask</code>（有返回值）和<code>RecursiveAction</code>（无返回结果），我们自己定义任务时，只需选择这两个类继承即可。<br>继承<code>RecursiveTask</code>和<code>RecursiveAction</code>类必须实现<code>compute()</code>方法，在这个方法里要实现递归控制条件。</p><p><code>compute()</code>的实现通常为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (任务足够小)&#123;</span><br><span class="line">  直接执行该任务;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  将任务一分为二;</span><br><span class="line">  Fork执行这两个任务;</span><br><span class="line">  Join等待结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个计算数组之和的Fork/Join例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CJForkJoinTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 要计算和的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> low;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> high;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (high - low &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 小于阈值则直接计算</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一个大任务分割成两个子任务</span></span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            CJForkJoinTask left = <span class="keyword">new</span> CJForkJoinTask(array, low, mid);</span><br><span class="line">            CJForkJoinTask right = <span class="keyword">new</span> CJForkJoinTask(array, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line"></span><br><span class="line">            sum = left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 生成大数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = genArray(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Fork/Join任务:</span></span><br><span class="line">        CJForkJoinTask CJForkJoinTask = <span class="keyword">new</span> CJForkJoinTask(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建Fork/Join线程池:</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 提交任务到线程池:</span></span><br><span class="line">        forkJoinPool.submit(CJForkJoinTask);</span><br><span class="line">        <span class="comment">// 获取结果:</span></span><br><span class="line">        Integer result = CJForkJoinTask.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07d4-JUC-线程池</title>
      <link href="/12.Java/Java-Tutorials.07d4.JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/12.Java/Java-Tutorials.07d4.JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池相关类和方法"><a href="#线程池相关类和方法" class="headerlink" title="线程池相关类和方法"></a>线程池相关类和方法</h1><ul><li>ExecutorService: Java线程池的接口, 提供了如下方法:<ul><li><code>void execute(Runnable command)</code> 执行Ruannable类型的任务</li><li><code>Future&lt;?&gt; submit(Runnable task)</code> 可用来提交Callable或Runnable任务，并返回代表此任务的Future对象</li><li><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>: 同上</li><li><code>void shutdown()</code> : 关闭线程池，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。最终调用了每个线程的<code>interrupt()</code></li><li><code>void shutdownNow()</code> : 关闭线程池, 中断正在处理任务的线程，也不处理阻塞队列中已保存的任务。最终调用了每个线程的<code>interrupt()</code></li><li><code>boolean isShutdown()</code></li></ul></li><li>ThreadPoolExecutor: 实现了ExecutorService接口, 通用线程池</li><li>ScheduledExecutorService: ExecutorService的实现类, 用执行定时任务<ul><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit)</code>: 执行定时任务</li></ul></li><li>Executors: 线程池的工厂类, 用于创建线程池<ul><li><code>ExecutorService newCachedThreadPool()</code>: 创建一个可缓存线程池，队列容量固定是1（可以认为没有队列），线程数会一直增长（如果没有空闲线程），如果线程空闲超过60s会被回收；</li><li><code>ExecutorService newFixedThreadPool(int nThreads)</code>: 创建一个定长线程池，超出的线程会进入等待队列，队列是无限大的；</li><li><code>ExecutorService newSingleThreadExecutor()</code>: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li><li><code>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code>: 创建一个定长线程池，支持定时及周期性任务执行。</li></ul></li></ul><p>示例代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tpoolTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ExecutorService cachedPool = Executors.newCachedThreadPool();</span><br><span class="line">  ExecutorService fixedPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">  ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// execute()无返回值</span></span><br><span class="line">  cachedPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/*doSomething*/</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  cachedPool.shutdown();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// submit()有返回值</span></span><br><span class="line">  <span class="comment">// labmda写法</span></span><br><span class="line">  Futrue&lt;String&gt; futrue = fixedPool.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  String ret = futrue.get();</span><br><span class="line">  fixedPool.shutdownNow();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// schedule()增加定时任务</span></span><br><span class="line">  schedulePool.schedule(() -&gt; &#123;</span><br><span class="line">System.out.print(<span class="string">"scheduled task"</span>);</span><br><span class="line">&#125;, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">  );</span><br><span class="line">  schedulePool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的<code>shutdown</code>或者<code>shutdownNow</code>方法来关闭线程池。原理是遍历线程池的工作线程，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法停止。<br>两者的区别：<br><code>shutdown</code> 方法将执行平缓的关闭过程：不在接收新的任务，同时等待已提交的任务执行完成，包括哪些还未开始执行的任务。<br><code>shutdownNow</code> 方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p><h1 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>工厂类<code>Executors</code>包装了对<code>ThreadPoolExecutor</code>构造方法的调用, 隐藏了很多创建线程池的细节, 所以在并发严格的情况下, 最好的方式还是直接调用<code>ThreadPoolExecutor</code>构造方法创建线程池.</p><p>ThreadPoolExecutor的构造函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造器中各个参数的含义:</strong></p><ul><li><strong>corePoolSize</strong>: （线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到线程数大于 corePoolSize 时就不再创建。如果调用了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会提前创建并启动所有基本线程。</li><li><strong>workQueue</strong>: 一个阻塞队列，用来存储等待执行的任务。当线程数已经大于corePoolSize时, 再向线程池添加任务，会把任务放入该队列中。阻塞队列有以下几种选择：<ul><li><code>LinkedBlockingQueue</code>：一个基于链表结构的 <em>无界阻塞队列</em>，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 <code>ArrayBlockingQueue</code>。<br>静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</li><li><code>SynchronousQueue</code>：一个不存储元素的 <em>有界阻塞队列</em>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态（可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。），吞吐量通常要高于<code>LinkedBlockingQueue</code>，<br>静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li><li><code>ArrayBlockingQueue</code>：基于数组结构的 <em>有界阻塞队列</em>，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级的 <em>无限阻塞队列</em>。</li></ul></li><li><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数（池+队列里的线程数）。线程池新增任务时判断顺序<code>corePoolSize?</code> -&gt; <code>workQueue?</code> -&gt; <code>maximumPoolSize</code><ul><li>如果是<code>LinkedBlockingQueue</code>这种 <em>近似无界的队列</em>，<code>maximumPoolSize</code>没有效果；</li><li>如果是<code>ArrayBlockingQueue</code>这种 <em>有界阻塞队列</em>，如果队列满了，并且已创建的线程数小于<code>maximumPoolSize</code>，则线程池会再创建新的线程执行任务，直到总线程数超过<code>maximumPoolSize</code>。</li></ul></li><li><strong>keepAliveTime</strong>: 工作线程空闲后，保持存活的时间。线程池会一直终止空闲超过keepAliveTime的线程，直到线程池中的线程数不超过<code>corePoolSize</code>。</li><li><strong>unit</strong>: keepAliveTime的单位</li><li><strong>handler</strong>: 当队列和线程池都满了（<code>maximumPoolSize</code>），说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。<ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ul></li></ul><p>再回过来看Executors提供的几种工厂方法:</p><blockquote><ul><li><code>newCachedThreadPool()</code>: corePoolSize为0, maximumPoolSize为INT.Max, 队列使用SynchronousQueue不存储线程, 所以有新任务提交时, 如果没有空闲的线程, 则继续创建新的线程, 直到线程数达到<code>INT.Max</code>. 空闲时间超过60s的线程会被回收；</li><li><code>newFixedThreadPool(int nThreads)</code>: corePoolSize和maximumPoolSize都是nThreads, 意味着线程池大小从0会增长到coreSize, 队列是近似无界队列LinkedBlockingQueue, 可以一直接收新任务, keepAliveTime=0意味着不会回收空闲线程</li><li><code>newSingleThreadExecutor()</code>: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul></blockquote><p>所以,<br>使用<code>newCachedThreadPool()</code>的问题在于, 如果没有控制好任务大小(所有线程一直在忙) 线程数会一直增长（<code>maxPoolSize</code> 是<code>Integer.MAX_VALUE</code>). 只有线程空闲的时候才有机会减少线程数.<br>使用<code>newFixedThreadPool()</code>的问题在于, 虽然工作线程数是固定的, 但是等待队列大小是<code>Integer.MAX_VALUE</code>,<br>这两种线程池都有可能因为创建大量线程导致OOM.</p><h2 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h2><p>线程池创建线程时，会将工作线程封装成Worker类，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。<br>我们可以从Worker的run方法里看到这点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行当前task或从队列里取出新的task</span></span><br><span class="line">      <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        task.run(); <span class="comment">// 执行Runnable.run()</span></span><br><span class="line">        afterExecute(task, thrown);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化线程池"><a href="#优化线程池" class="headerlink" title="优化线程池"></a>优化线程池</h1><p>线程池参数的解析和使用建议:</p><ul><li>线程池大小:<ul><li>如果是计算密集任务，一般设置为cpu核心数，</li><li>如果是IO密集任务一般设置为核心数2~3倍；// 理论值, 实际工程中远比这个大</li></ul></li><li>默认情况下，核心工作线程值在初始的时候被创建，当新任务来到的时候被启动，但是我们可以通过重写<code>prestartCoreThread</code>或<code>prestartCoreThreads</code>方法来改变这种行为。<br>通常场景我们可以在应用启动的时候来WarmUp核心线程，从而达到任务过来能够立马执行的结果，使得初始任务处理的时间得到一定优化。</li><li>合理的拒绝策略: @todo</li><li>队列的选择：<ul><li>无界队列：<ul><li>使用无界队列如<code>LinkedBlockingQueue</code>没有指定最大容量的时候，将会引起当核心线程都在忙的时候，新的任务被放在队列上。<br>因此，永远不会有大于<code>corePoolSize</code>的线程被创建，因此<code>maximumPoolSize</code>参数将失效。<br>这种策略比较适合所有的任务都不相互依赖，独立执行。如Web服务器中，每个线程独立处理请求。<br>但是当任务处理速度小于任务进入速度的时候会引起队列的无限膨胀。</li><li>先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先得到执行，<br>需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</li></ul></li><li>有界队列：有界队列如<code>ArrayBlockingQueue</code>帮助限制资源的消耗，但是不容易控制。<br>队列长度和<code>maximumPoolSize</code>这两个值会相互影响，<br>使用 <em>大的队列</em> 和 小<code>maximumPoolSize</code>会降低CPU占用、操作系统资源、上下文切换的消耗，但是会降低吞吐量，如果任务被频繁的阻塞如IO线程，系统其实可以调度更多的线程。<br>使用 <em>小的队列</em> 通常需要大<code>maximumPoolSize</code>，从而使得CPU更忙一些，但是又会增加降低吞吐量的线程调度的消耗。<br>总结一下：是IO密集型可以考虑 <em>多些线程+小的队列</em> 来平衡CPU的使用，CPU密集型可以考虑 <em>少些线程+大的队列</em> 减少线程调度的消耗。</li></ul></li></ul><p><strong>线程池的监控:</strong><br>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li><li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+ getActiveCount：获取活动的线程数。<br>通过扩展线程池进行监控。通过继承线程池并重写线程池的b<code>eforeExecute</code>，<code>afterExecute</code>和<code>terminated</code>方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</li></ul><p>@ref:</p><ul><li><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="noopener">聊聊并发（三）——JAVA线程池的分析和使用</a></li><li><a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="noopener">如何合理地估算线程池大小？ | 并发编程网 – ifeve.com</a></li><li><a href="https://www.zhihu.com/question/38128980" target="_blank" rel="noopener">java线程池大小为何会大多被设置成CPU核心数+1？ - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07d3-JUC-线程安全的集合</title>
      <link href="/12.Java/Java-Tutorials.07d3.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88/"/>
      <url>/12.Java/Java-Tutorials.07d3.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>旧的线程安全的集合: 任何集合类都可以通过使用同步包装器变成线程安全的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; synchArrayList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt; synchMap = Collections.synchronizedList(<span class="keyword">new</span> HasMap&lt;K,V&gt;());</span><br></pre></td></tr></table></figure><p><code>java.util.concurrent</code>包提供了线程安全的集合, 继承关系如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阻塞队列</span><br><span class="line">  |- BlockingQueue（单向队列）</span><br><span class="line">       |- ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</span><br><span class="line">       |- LinkedBlockingQueue: 一个由链表结构组成的有界阻塞队列</span><br><span class="line">       |- PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列</span><br><span class="line">       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列</span><br><span class="line">  |- BlockingDeque（双向队列）</span><br><span class="line">       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列</span><br><span class="line"></span><br><span class="line">非阻塞队列</span><br><span class="line">  |- ConcurrentLinkedQueue</span><br><span class="line">  |- ConcurrentLinkedDeque</span><br><span class="line"></span><br><span class="line">Map</span><br><span class="line">  |- ConcurrentHashMap</span><br><span class="line">  |- ConcurrentSkipListMap</span><br><span class="line"></span><br><span class="line">Set</span><br><span class="line">  |- ConcurrentSkipListSet</span><br></pre></td></tr></table></figure><h1 id="Queue-amp-Deque"><a href="#Queue-amp-Deque" class="headerlink" title="Queue &amp; Deque"></a>Queue &amp; Deque</h1><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:center">是否阻塞</th><th style="text-align:center">是否有界</th><th style="text-align:center">队列长度</th><th style="text-align:center">内部实现</th></tr></thead><tbody><tr><td style="text-align:left">ArrayBlockingQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">构造器指定</td><td style="text-align:center">循环数组,FIFO</td></tr><tr><td style="text-align:left">LinkedBlockingQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">构造器指定, 默认Int.Max</td><td style="text-align:center">链表,FIFO</td></tr><tr><td style="text-align:left">LinkedBlockingDeque</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">构造器指定, 默认Int.Max</td><td style="text-align:center">双向链表,FIFO</td></tr><tr><td style="text-align:left">SynchronousQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">PriorityBlockingQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">构造器指定, 默认11, 无限扩容</td><td style="text-align:center">二叉堆</td></tr><tr><td style="text-align:left">DelayQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">初始empty, 无限扩容</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ConcurrentLinkedQueue</td><td style="text-align:center">非阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">初始empty, 无限扩容</td><td style="text-align:center">单向链表</td></tr><tr><td style="text-align:left">ConcurrentLinkedDeque</td><td style="text-align:center">非阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">初始empty, 无限扩容</td><td style="text-align:center">双向链表</td></tr></tbody></table><p>线程安全的队列可以分为 <strong>阻塞队列</strong> , <strong>非阻塞队列</strong>, 按照是否可无限扩容分为 <strong>有界队列</strong> , <strong>无界队列</strong> :</p><ul><li>阻塞队列是指: 当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。<br>阻塞队列一般是用锁(例如<code>BlockingQueue</code>)来实现,<br>阻塞队列继承自接口<code>BlockingQueue</code>, 常用的有: <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>LinkedBlockingDeque</code>;</li><li>非阻塞队列是指:<br>非阻塞队列一般是用<code>CAS</code>实现的”Lock-Free”方法,<br>非阻塞队列主要有: <code>ConcurrentLinkedQueue</code>, <code>ConcurrentLinkedDeque</code>;</li><li>有界/无界: 无界队列可以无限扩容</li></ul><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列一般使用condition实现消费者和生产者的”通讯”。<br>比如当生产者往满的队列里添加元素时会阻塞住，当消费者消费了队列中的元素后，会通过condition通知生产者当前队列可用。</p><p>BlockingQueue接口方法有put/take：</p><p><strong>阻塞方法：</strong></p><ul><li>put(E o)：将元素添加到此队列尾，如果队列满将一直阻塞，可以响应中断。</li><li>take()：检索并移除此队列的头部，如果队列为空则一直阻塞，可以响应中断。</li></ul><p><strong>不阻塞且抛异常的方法：</strong></p><ul><li>add(E o)：将元素添加到此队列中，如果队列已满不会阻塞，直接抛出 IllegalStateException</li><li>remove()： 移除队列头部的元素，如果队列为空不会阻塞，直接抛出 IllegalStateException</li></ul><p><strong>不阻塞且带返回值的方法：</strong></p><ul><li>offer(E o)： 将元素添加到队列，不阻塞，成功返回true，失败返回false；</li><li>offer(E o, long timeout, TimeUnit unit)： 带等待时间的offer方法，如果队列已满，将等待指定的时间；</li><li>poll(long timeout, TimeUnit unit)： 返回队列的头部并移除，如果队列为空，则等待指定等待的时间。如果取不到返回null；</li></ul><p>其他方法：</p><ul><li>drainTo(Collection&lt;? super E&gt; c)： 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</li><li>drainTo(Collection&lt;? super E&gt; c,int maxElements)： 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</li><li>remainingCapacity()： 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的元素数量；如果没有内部限制，则返回 Integer.MAX_VALUE。</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul><li>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序</li><li>ArrayBlockingQueue内部由 一个公共的读写锁，两个Condition(notFull、notEmpty) 管理队列满或空时的阻塞状态。<br>因为在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue。</li><li>构造器<code>ArrayBlockingQueue(int)</code>都要指定数组初始大小，并且大小不再扩展。</li><li>默认情况下ArrayBlockingQueue不保证访问者公平的访问队列，所谓“公平访问队列”是指：当队列可用时，可以按照阻塞的先后顺序访问队列。即：<br>先阻塞的生产者线程，可以先往队列里插入元素；<br>先阻塞的消费者线程，可以先从队列里获取元素。<br>我们可以使用以下代码创建一个“公平的”阻塞队列：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = new  ArrayBlockingQueue(1000,true);</span><br></pre></td></tr></table></figure></li></ul><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul><li>LinkedBlockingQueue是链表实现的“有界”的阻塞队列。构造函数可以指定最大长度，队列的默认和最大长度为<code>Integer.MAX_VALUE</code></li><li>内部基于链表实现，由两个锁（takeLock与putLock），以及 两个Condition(notFull、notEmpty) 管理队列满或空时的阻塞状态。<br>由于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li></ul><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><ul><li>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。构造函数可以指定最大长度，队列的默认和最大长度为<code>Integer.MAX_VALUE</code></li><li>相比其他的阻塞单向队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法</li></ul><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue是无界的，是一种无缓冲的等待队列，<br>但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加，可以认为SynchronousQueue是一个缓存值为1的阻塞队列，<br>但是 isEmpty()方法永远返回是true，remainingCapacity() 方法永远返回是0，remove()和removeAll() 方法永远返回是false，iterator()方法永远返回空，peek()方法永远返回null。</p><p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别：如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><ul><li>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。<br>队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：<ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li><li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。</li></ul></li><li>队列中的Delayed必须实现compareTo来指定元素的顺序。</li></ul><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><ul><li>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。</li><li>内部基于二叉堆。使用一把公共的读写锁。虽然实现了BlockingQueue接口，其实没有任何阻塞队列的特征，空间不够时会自动扩容。</li><li>构造器：<ul><li><code>PriorityBlockingQueue()</code>：默认数组初始大小11，不指定Comparator，存入的对象需要实现<code>Comparable</code>接口；</li><li><code>PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code>；</li></ul></li></ul><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><ul><li>ConcurrentLinkedQueue是一个基于链接节点的无边界的线程安全队列，它采用FIFO原则对元素进行排序。采用“wait-free”算法（即CAS）来实现的。</li><li>ConcurrentLinkedQueue的结构是单向链表和head/tail两个指针，因为入队时需要修改队尾元素的next指针，以及修改tail指向新入队的元素两个CAS动作无法原子，所以需要的特殊的算法，见：<br><a href="https：//www.ibm.com/developerworks/cn/java/j-jtp04186/">Java 理论与实践： 非阻塞算法简介</a></li></ul><h3 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h3><ul><li>ConcurrentLinkedDeque是一种基于双向链表的无界链表。</li><li>与大多数集合类型不同，其size方法不是一个常量操作。因为链表的异步性质，确定当前元素的数量需要遍历所有的元素，所以如果在遍历期间有其他线程修改了这个集合，size方法就可能会报告不准确的结果。</li><li>批量的操作：包括添加、删除或检查多个元素，比如addAll()、removeIf()或者removeIf() 或forEach()方法，这个类型并不保证以原子方式执行。由此可见如果想保证原子访问，不得使用批量操作的方法。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>➤ 特性: 适用于读多写少, 读出来的数据不满足一致性</p><p>➤ 实现:</p><ul><li>get():</li><li>add(): ReentrantLock加锁, copy新数组, 向新数组add值, 新数组替换旧数组 // array 数组设定为 volitile 的, 数组中的元素不是volatile, 数组引用才是</li></ul><p>@ref:</p><ul><li><a href="https://juejin.im/post/5aeeb55f5188256715478c21" target="_blank" rel="noopener">并发容器之CopyOnWriteArrayList - 掘金</a></li><li><a href="https://blog.csdn.net/h525483481/article/details/80347485" target="_blank" rel="noopener">实现一个简单的阻塞队列_Java_h525483481的专栏-CSDN博客</a></li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h2><p>ConcurrentSkipListSet的实现非常简单，其内部引用了一个ConcurrentSkipListMap对象，所有API方法都是调用了ConcurrentSkipListMap。<br>ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集。但是：<br>第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的；<br>第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的；</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>数据分段存储，每个段有一个写锁，当一个线程占用某个段的锁时，其他段也可以正常访问，有效分散了阻塞的概率，而且没有读锁；</li><li>没有读锁是因为put/remove动作是个原子动作(比如put是一个对数组元素/Entry 指针的赋值操作)，读操作不会看到一个更新动作的中间状态；</li><li>每次扩容为原来容量的2倍，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容；</li><li>在获取size操作的时候，不是直接把所有segment的count相加就可以可到整个ConcurrentHashMap大小，也不是在统计size的时候把所有的segment的put、remove、clean方法全部锁住，这种方法太低效。<br>在累加count操作过程中，之前累加过的count发生变化的几率非常小，所有ConcurrentHashMap的做法是先尝试2（RETRIES_BEFORE_LOCK）次通过不锁住Segment的方式统计各个Segment大小，如果统计的过程中，容器的count发生了变化，再采用加锁的方式来统计所有的Segment的大小。</li><li>putIfAbsent(k,v)：当k已经存在时返回已存在的v。</li></ul><p>➤ 内部实现:</p><ul><li>实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方, 为什么?</li><li>put操作:<br>  计算桶位置:  i = (table.size-1) &amp; hash<br>  如果table[i] == null : 用自旋+CAS 改变table[i] 的值<br>  如果 f = table[i] != null : Synchronized(f)锁住f节点</li><li>size的实现: 类似 LongAdder</li></ul><p>➤ 1.7和1.8中的实现有何不同?</p><ul><li>1.7 : Segment[], 每个Segment继承自ReentrantLock, 每个Segment对象持有<code>HashEntry&lt;K,V&gt;[] table</code></li><li>1.8 : 放弃分段锁, 对每个table[]桶进行加锁</li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000016096542" target="_blank" rel="noopener">Java多线程进阶（二三）—— J.U.C之collections框架：ConcurrentHashMap(1) 原理 - 透彻理解Java并发编程 - SegmentFault 思否</a><br>@ref <a href="https://segmentfault.com/a/1190000016124883" target="_blank" rel="noopener">Java多线程进阶（二四）—— J.U.C之collections框架：ConcurrentHashMap(2) 扩容 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><ul><li>JDK6新增的并发优化的SortedMap，以SkipList实现。SkipList是红黑树的一种简化替代方案，是个流行的有序集合算法。Concurrent包选用它是因为它支持基于CAS的无锁算法，而红黑树则没有好的无锁算法。</li><li>ConcurrentSkipListMap 的key是有序的；</li><li>与ConcurrentHashMap相比，ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log(n)，和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出优势。</li><li>它的size()比较特殊，需要遍历所有元素；</li></ul><h1 id="Deprecated-Vector-amp-HashTable"><a href="#Deprecated-Vector-amp-HashTable" class="headerlink" title="Deprecated: Vector &amp; HashTable"></a>Deprecated: Vector &amp; HashTable</h1><p>Vector和HashTable已经被弃用，取而代之的是ArrayList和HashMap，如果要使用线程安全的容器，可以用Collections转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; syncList = Collections.synchronzedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt; syncMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K,V&gt;());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07d2-JUC-ReentrantLock</title>
      <link href="/12.Java/Java-Tutorials.07d2.JUC-ReentrantLock/"/>
      <url>/12.Java/Java-Tutorials.07d2.JUC-ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h1 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁: ReentrantLock"></a>可重入锁: ReentrantLock</h1><p>ReentrantLock是”可重入锁”: 一个线程已经持有锁的情况下, 重复对该锁进行<code>lock()</code>操作,  能立刻获得锁且不会被阻塞.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123; ... &#125; <span class="keyword">catch</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">  reentrantLock.unlock(); <span class="comment">// 在finally里释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock的构造函数<code>ReentrantLock(boolean fair)</code>可以返回公平锁(true)和非公平锁(false).</p><ul><li>公平锁（Fair）：加锁前检查是否有排队等待的线程，如果队列非空先进入队列，获取锁的顺序同调用lock的顺序一致;</li><li>非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待;</li></ul><p>因为队列的存在和线程调度的机制, 公平锁的吞吐量更低, 所以 ReentrantLock()默认构造是 <strong>非公平锁</strong></p><h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><code>ReentrantLock</code>中有一个 Sync 类型的成员, 根据调用不同的构造方法, sync 被初始化为<code>NonFairSync</code>(非公平锁, 默认) 或者<code>FairSync</code>(公平锁), 这两种Sync都继承自<code>AbstractQueuedSynchronizer</code>, 简称 <strong>AQS</strong>.<br>AQS是java.util.concurrent的核心, <code>CountDownLatch</code>, <code>FutureTask</code>, <code>Semaphore</code>, <code>ReentrantLock</code>等都有一个内部类是这个抽象类的子类. <code>ReentrantLock中</code>所有涉及对AQS的访问都要经过Sync类</p><p>图-ReentrantLock-AQS UML:<br><img src="/images/java/java_reentrantLock_uml.png" alt="ReentrantLock AQS"></p><p>@todo:</p><ul><li>AQS提供的功能, 对外暴露的public方法;</li><li>AQS同步计数 和 队列的实现</li><li>队列节点Node几种状态: CANCELLED, SIGNAL, CONDITION, INITIAL</li></ul><p><code>AbstractQueuedSynchronizer</code>有几个重要的成员变量:<br>  1 int类型的计数器<code>state</code> ;<br>  2 等待线程的队列(由head和tail指针表示的双向队列);<br>  3 从<code>AbstractOwnableSynchronizer</code>继承来的<code>exclusiveOwnerThread</code> (Thread类型);</p><p>计数器是volatile修饰的, 作用是记录锁被重入的次数, 初值是0, 重入一次+1, 释放一次-1, 计数器为0表示没有线程持有该锁, 是free的;<br>尝试CAS修改计数器失败的线程, 会被放入队列尾部;<br><code>exclusiveOwnerThread</code>用来记录当前该锁被哪个线程占用(但不是volatile的, 此处有疑问)</p><p>AbstractQueuedSynchronizer抽象类提供的主要的属性和方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">// 双向队列头</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 双向队列尾</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  <span class="comment">// 重入计数器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock.lock() 调用了 sync.acquire(1) 方法,</span></span><br><span class="line">  <span class="comment">// 最终调用到 AQS.acquire(1):</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 由NonfairSync 和 FairSync分别实现</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 队列操作</span></span><br><span class="line">            selfInterrupt(); <span class="comment">// interrupt当前线程</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock.unlock() 调用了 sync.release(1) 方法,</span></span><br><span class="line">  <span class="comment">// 最终调用到 AQS.acquire(1):</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 由Sync实现</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ref: <a href="https://segmentfault.com/a/1190000015562787#item-3-9" target="_blank" rel="noopener">Java多线程进阶（六）—— J.U.C之locks框架：AQS综述(1) - 透彻理解Java并发编程 - SegmentFault 思否</a></p><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>ReentrantLock.lock()调用栈如下(以 NonFairSync为例):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReentrantLock.lock()</span><br><span class="line">    NonFairSync.acquire(1)</span><br><span class="line">        AbstractQueuedSynchronizer.acquire(1)</span><br><span class="line">            NonFairSync.tryAcquire(1)</span><br></pre></td></tr></table></figure><p>过程大致如下:</p><ul><li>对计数器<code>CAS(0,1)</code>操作, （<code>CAS(0,1)</code>意即为如果计数器等于期望值0则设置为1）</li><li>CAS成功, 成功获取到该锁, 并把exclusiveOwnerThread置为当前线程引用地址, <code>lock()</code>成功返回;</li><li>CAS不成功, 表明已经有线程持有该锁, 且exclusiveOwnerThread不等于当前线程, 创建当前线程的<code>AQS.Node</code>对象, 并插入AQS的队尾, 并调用<code>LockSupport.park()</code>使当前Thread进入Blocked</li></ul><blockquote><p>state表示重入成功获取到锁的计数, 每次成功重入+1,<br>如果尝试获取锁的线程不等于已持有锁的线程, 计数不用+1, 把这个线程加入AQS队列, 并且使这个线程进入Blocked状态<br><code>lock()</code>放入队列调用的是 <code>AQS.addWaiter(Node)</code><br><code>LockSupport.park()</code> 是Native方法, 作用是block 当前线程, 同 wait方法类似, 也需要使用 Guarded 模式 <a href="/12.Java/Java-Tutorials.07z.多线程设计模式/" title="Java-Tutorials.07z.多线程设计模式">Java-Tutorials.07z.多线程设计模式</a></p></blockquote><p>线程A/B抢锁的场景:</p><ul><li>线程A获取到锁: A是首个获取锁的线程, 获取到锁后, 【等待队列】还是空(AQS.head值还是null)</li><li>线程B获取锁(失败): 如果CAS失败, 表示线程B获取锁失败, 把线程B的Node放入【等待队列】队尾 (该队列的头指针是AQS.head存储, head指向的是一个空Node,插入的B节点在其之后), 然后执行 <code>acquireQueued()</code>, 线程park;</li><li>线程A释放锁: CAS状态值-1, 然后取【等待队列】的首节点B(不是head的空节点), 然后 <code>LockSupport.unpark(B)</code>唤醒 // 此时B仍在队列</li><li>线程B唤醒执行: B唤醒后自旋调用 <code>tryAcquire()</code>再次尝试获取锁, 成功后把AQS.head设置为B节点, 并清除B节点信息(B变成了空节点)</li><li>线程B释放锁</li></ul><p>@ref: <a href="https://segmentfault.com/a/1190000015562456" target="_blank" rel="noopener">Java多线程进阶（五）—— J.U.C之locks框架：LockSupport - 透彻理解Java并发编程 - SegmentFault 思否</a></p><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h3><p>ReentrantLock.unlock()调用栈如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReentrantLock.unlock()</span><br><span class="line">    NonFairSync.release(1)</span><br><span class="line">        AbstractQueuedSynchronizer.release(1)</span><br><span class="line">            Sync.tryRelease(1)</span><br></pre></td></tr></table></figure><ul><li>只允许已经持有锁的线程调用<code>unlock()</code>, 否则<code>unlock()</code>会抛出 IllegalMonitorStateException异常</li><li>已经持有锁的线程, 每次调用<code>unlock()</code>计数器都会-1, 直到计数器等于0, 这时候表示锁全部被解开了, 再从AQS的队列取出第一个节点, 把这个节点对应的线程设置为Runnable</li></ul><h2 id="测锁与超时"><a href="#测锁与超时" class="headerlink" title="测锁与超时"></a>测锁与超时</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECOND)) &#123; <span class="comment">// 超时时间内尝试获取锁失败立刻返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123; <span class="comment">// 尝试获取锁失败立刻返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul><li>如果一个数据结构只有很少线程修改其值, 但是有很多线程读取, 这种数据结构非常适合用读写锁<code>ReentrantReadWriteLock</code></li><li>writeLock一旦被持有, 排除其他的写锁和读锁;</li><li>readLock一旦被持有, 排斥写锁, 但不排斥其他的读锁;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">Lock wl = rwl.writeLock(); <span class="comment">// 抽取写锁</span></span><br><span class="line">Lock rl = rwl.readLock(); <span class="comment">// 抽取读锁</span></span><br><span class="line"></span><br><span class="line">wl.lock();</span><br><span class="line"><span class="comment">// 写操作, 这里排斥其他的读写锁</span></span><br><span class="line">wl.unlock();</span><br><span class="line"></span><br><span class="line">rl.lock();</span><br><span class="line"><span class="comment">// 读操作, 其他读锁仍可以进入, 写锁则不能</span></span><br><span class="line">rl.unlock();</span><br></pre></td></tr></table></figure><p>其他特点:</p><ul><li>支持 Fair 和 NoFair两种模式</li><li>支持 Condition: 只有写锁支持 newCondition(), 读锁不支持这个方法, 为什么这样设计? // 当持有写锁时, 读锁是可以任意访问的, 即使拿到了读锁的 Condition也没有意义, 因为读线程之前不需要协调</li><li>可以降级: 写锁可以降级为读锁, 当线程先拿到读锁,接着拿到写锁, 此时写锁是被降级为读锁的</li></ul><p>@ref: <a href="https://segmentfault.com/a/1190000015562389" target="_blank" rel="noopener">Java多线程进阶（四）—— J.U.C之locks框架：ReentrantReadWriteLock - 透彻理解Java并发编程 - SegmentFault 思否</a></p><h1 id="比较ReentrantLock和synchronized"><a href="#比较ReentrantLock和synchronized" class="headerlink" title="比较ReentrantLock和synchronized"></a>比较ReentrantLock和synchronized</h1><ol><li>ReentrantLock可以”可中断的”获取锁 <code>void lockInterruptibly() throws InterruptedException</code></li><li>ReentrantLock可以尝试非阻塞地获取锁 <code>boolean tryLock()</code></li><li>ReentrantLock可以超时获取锁，通过<code>tryLock(timeout, unit)</code></li><li>ReentrantLock可以实现公平锁，通过<code>new ReentrantLock(true)</code>实现</li><li>ReentrantLock对象可以同时绑定多个Condition对象，只需要多次调用<code>newCondition()</code>方法即可。而在synchronized中只能使用一个对象的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></li><li>Condition对应的方法是<code>await()</code>, <code>signal()</code>, <code>signalAll()</code>, Object对应的方法<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></li><li>ReentrantLock的实现是 AQS, synchronized实现模型是 Monitor</li></ol><blockquote><p>注: ReentrantLock.lockInterruptibly() : 当调用lockInterruptibly时如果线程有中断标志, 则抛出 InterruptedException, 如果调用InterruptedException没有拿到锁, 线程进入Blocked状态, 是可以被 Interrupt的<br>@ref <a href="https://segmentfault.com/a/1190000015562196#item-1-2" target="_blank" rel="noopener">Java多线程进阶（二）—— J.U.C之locks框架：接口 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote><h1 id="条件对象-Condition"><a href="#条件对象-Condition" class="headerlink" title="条件对象: Condition"></a>条件对象: Condition</h1><p>实例代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(!resource_is_available) &#123;</span><br><span class="line">    condition.await(); <span class="comment">//1 失去锁 &amp; waiting状态 &amp; 进入condition的等待集</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// here acquired lock, doSomething...</span></span><br><span class="line">  condition.signalAll(); <span class="comment">//2 把condition等待集里的所有线程移除</span></span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;...&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  reentrantLock.unlock(); <span class="comment">//3 永远在finally里释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件对象的实现"><a href="#条件对象的实现" class="headerlink" title="条件对象的实现"></a>条件对象的实现</h2><p><code>ReentrantLock.newCondition()</code>返回一个<code>ConditionObject</code>对象, 是AbstractQueuedSynchronizer的一个内部类;<br>一个锁可以创建多个<code>ConditionObject</code>对象;<br><code>ConditionObject</code>的实现也是一个队列, firstWaiter和lastWaiter记录了队列的头和尾</p><ol><li>一个线程调用<code>condition.await()</code>之后进入waiting状态并进入该condition的队列中, 处于waiting的线程无法改变自身状态, 只能等待其他线程调用<code>condition.signalAll()</code>;</li><li>一个线程调用<code>condition.signalAll()</code>之后, 所有在此condition等待队列中的其他线程被移出, 这些线程重新设置runnable状态, 这些线程从<code>await()</code>阻塞调用里返回;</li></ol><p>补充: <code>wait()</code>放入队列调用的是 <code>AQS.ConditionObject.addConditionWaiter(Node)</code></p><ul><li>线程A拿到锁, 然后调用 condition.wait():A进入condition的 【条件队列】,然后调用 LockSupport.park;</li><li>线程B拿到锁, 然后调用 condition.signal(): 删除【条件队列】的首节点A, 转换节点类型(?), 将A节点插入【等待队列】,然后把A节点状态设置值为Node.SIGNAL, 并调用 LockSupport.unpark唤醒A;</li><li>线程B释放锁: CAS状态值-1, 然后取出【等待队列】首节点A, 并唤醒首节点</li><li>线程A唤醒: 唤醒后再次调用<code>tryAcquire()</code>, 成功的话就从【等待队列】删除A</li></ul><p>@ref: <a href="https://segmentfault.com/a/1190000015807209" target="_blank" rel="noopener">Java多线程进阶（八）—— J.U.C之locks框架：AQS的Conditon等待(3) - 透彻理解Java并发编程 - SegmentFault 思否</a></p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07d1-JUC-Atomic</title>
      <link href="/12.Java/Java-Tutorials.07d1.JUC-Atomic/"/>
      <url>/12.Java/Java-Tutorials.07d1.JUC-Atomic/</url>
      
        <content type="html"><![CDATA[<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><blockquote><p>原子变量是一种更好的”Volatile”. – 《Java并发编程实战》</p></blockquote><p>java提供了几个类用于原子操作:</p><ol><li>原子更新基本类型：AtomicBoolean，AtomicInteger, AtomicLong.</li><li>原子更新数组：AtomicIntegerArray，AtomicLongArray, AtomicReferenceArray.</li><li>原子更新引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference.</li><li>原子更新字段类型：AtomicReferenceFieldUpdater, AtomicIntegerFieldUpdater, AtomicLongFieldUpdater.</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// incrementAndGet提供了几个方法实现原子操作:</span></span><br><span class="line"><span class="keyword">int</span> i = atomicInteger.get();</span><br><span class="line">atomicInteger.getAndSet(<span class="number">0</span>); <span class="comment">// 当前值设置为0, 并返回之前的值</span></span><br><span class="line">atomicInteger.compareAndSet(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// 如果当前值等于1, 则更新为3</span></span><br><span class="line">atomicInteger.decrementAndGet(<span class="number">1</span>); <span class="comment">// 自减</span></span><br><span class="line">atomicInteger.incrementAndGet(<span class="number">1</span>); <span class="comment">// 自增</span></span><br></pre></td></tr></table></figure><p>大多数方法都是调用<code>sun.misc.Unsafe</code>里的方法实现的, <code>sun.misc.Unsafe</code>只提供三种CAS方法： <code>compareAndSwapObject</code>, <code>compareAndSwapInt</code>和<code>compareAndSwapLong</code></p><h3 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h3><p>Java中的 AtomicStampedReference<e>也实现了ABA，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题</e></p><blockquote><p>参考 <a href="http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html" target="_blank" rel="noopener">用AtomicStampedReference解决ABA问题</a> @ref</p></blockquote><h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><ul><li>思考: 已经有<code>AtomicLong.addAndGet(l)</code>的情况下, 为什么还要设计<code>LongAdder</code>?  <ul><li>AtomicLong是使用 “自旋+CAS”实现, 面对写多的情况下有性能瓶颈</li></ul></li><li>读操作: <code>value = base + cell[]</code>, 但并没有对这个过程加锁, 在存在竞争的情况下, 可能..</li><li>写操作: 直接尝试<code>cas(base)</code>, 失败的话检查<code>cell[]</code>是否初始化,<ul><li>如果没有则开始初始化, 对<code>cell[]</code>进行初始化 size=2,</li><li>如果<code>cell[]</code>已经初始化, 选出属于当前线程的<code>cell[]</code>槽位 // 槽位id = <code>hash(当前线程id) &amp; m</code>, m = <code>cell.size-1</code></li><li>对<code>cell[i]</code>自旋CAS</li></ul></li><li>reset操作: <code>base</code> 和 <code>cell[]</code> 依次置0</li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015865714" target="_blank" rel="noopener">Java多线程进阶（十七）—— J.U.C之atomic框架：LongAdder - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07d0-JUC-Index</title>
      <link href="/12.Java/Java-Tutorials.07d0.JUC-Index/"/>
      <url>/12.Java/Java-Tutorials.07d0.JUC-Index/</url>
      
        <content type="html"><![CDATA[<h2 id="What’s-J-U-C"><a href="#What’s-J-U-C" class="headerlink" title="What’s J.U.C ?"></a>What’s J.U.C ?</h2><p>Java 1.5. 提供了<code>java.util.concurrent</code>包, 该包参考自EDU.oswego.cs.dl.util.concurrent, 是JSR 166标准规范的一个实现.<br>J.U.C提供了</p><h2 id="Java-07d-JUC-Index"><a href="#Java-07d-JUC-Index" class="headerlink" title="Java-07d-JUC Index"></a>Java-07d-JUC Index</h2><ol><li>Atomic: 基于CAS的无锁原子操作, 包括基本类型/数组/引用/对象field 四类原子操作 <a href="/12.Java/Java-Tutorials.07d1.JUC-Atomic/" title="Java-Tutorials.07d1.JUC-Atomic">Java-Tutorials.07d1.JUC-Atomic</a></li><li>Locks: 可重入锁 ReentrantLock, 读写锁 ReadWriteLock, 条件对象 Condition 等 <a href="/12.Java/Java-Tutorials.07d2.JUC-ReentrantLock/" title="Java-Tutorials.07d2.JUC-ReentrantLock">Java-Tutorials.07d2.JUC-ReentrantLock</a></li><li>并发容器: ArrayBlockingQueue, ConcurrentHashMap 等 <a href="/12.Java/Java-Tutorials.07d3.线程安全的集合/" title="Java-Tutorials.07d3.线程安全的集合">Java-Tutorials.07d3.线程安全的集合</a></li><li>线程池: ExecutorService的实现类 <a href="/12.Java/Java-Tutorials.07d4.JUC-线程池/" title="Java-Tutorials.07d4.JUC-线程池">Java-Tutorials.07d4.JUC-线程池</a></li><li>其他Sync: CountDownLatch, FutureTask 等 <a href="/12.Java/Java-Tutorials.07d5.JUC-其他工具类/" title="Java-Tutorials.07d5.JUC-其他工具类">Java-Tutorials.07d5.JUC-其他工具类</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07c-Volatile</title>
      <link href="/12.Java/Java-Tutorials.07c.Volatile/"/>
      <url>/12.Java/Java-Tutorials.07c.Volatile/</url>
      
        <content type="html"><![CDATA[<h3 id="volatile关键字特性"><a href="#volatile关键字特性" class="headerlink" title="volatile关键字特性"></a>volatile关键字特性</h3><ul><li>多CPU环境的可见性: 多CPU的环境下, CPU有可能从寄存器或Cache里直接取值, 这种情况下运行在不同CPU上的线程获取的值可能不同, volitile变量可以保证每次更新都改变到主存, 每次读取都从主存中读取.</li><li>volatile可以作为一种开销较低的免锁机制(某些情况下).</li><li>volatile变量的”复合操作”(对变量的写操作依赖当前值)不具备原子性.</li><li>volatile 的<code>long</code>, <code>double</code>的读写不保证有原子性.</li></ul><h2 id="volatile不适用的情况"><a href="#volatile不适用的情况" class="headerlink" title="volatile不适用的情况"></a>volatile不适用的情况</h2><ol><li>用于计数器(请使用<code>AomicInteger</code>)， 虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。</li><li>“依赖当前值”的写操作, 比如<code>i=i+1</code></li><li>非原子操作, <code>i++</code>, <code>i=!i</code>都不是原子操作</li></ol><p>比如以下代码是有问题的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function">protect <span class="keyword">void</span> <span class="title">filp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  i = !i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile适用的情况"><a href="#volatile适用的情况" class="headerlink" title="volatile适用的情况"></a>volatile适用的情况</h2><ol><li>作为简单的状态标志, <code>vol_variable = 1</code> 和<code>vol_variable = 0</code> 这种操作是原子的, 对volatile变量的赋值也对其他线程立刻可见;</li><li>保证只有一个线程写, 其他线程只能读;</li></ol>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07c-CAS</title>
      <link href="/12.Java/Java-Tutorials.07c.CAS/"/>
      <url>/12.Java/Java-Tutorials.07c.CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>▷ 原子操作:</p><blockquote><p><a href="https://www.zhihu.com/question/27026846" target="_blank" rel="noopener">对int变量赋值的操作是原子的吗？ - 知乎</a></p></blockquote><p>▷ 乐观锁 &amp; 悲观锁:</p><ul><li>悲观锁: 假定会出现冲突, 加锁前检查所有冲突的可能性，每次在拿数据的时候都会上锁，拿到锁之后才可以修改临界区数据；</li><li>乐观锁(Optimistic Locking): 假定不会出现冲突, 先尝试去修改数据的操作, 根据操作的返回值确定是否抢锁成功;</li><li>Java中乐观锁 &amp; 悲观锁的实现: CAS &amp; ReentrantLock</li></ul><p>▷ CAS:</p><ul><li>CAS(Compare And Swap)：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</li><li>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B并返回True，否则就什么都不做并返回False。比较+替换是一个原子操作。</li></ul><h2 id="Unsafe提供的CAS"><a href="#Unsafe提供的CAS" class="headerlink" title="Unsafe提供的CAS"></a>Unsafe提供的CAS</h2><p>上面提到<code>ReentrantLock.lock()</code>的实现是通过AQS, AQS的 CAS方法实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                        (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">            <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS 使用 unsafe包提供的CAS (Native方法), 然后通过JNI 调用到了Hotspot的 Unsafe.cpp中,<br>C++代码最终调用的是<code>Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value)</code>,<br>cmpxchg()调用了汇编 <code>CMPXCHG</code>指令，具体汇编指令可以查看Intel手册 <a href="http://faydoc.tripod.com/cpu/cmpxchg.htm" target="_blank" rel="noopener">CMPXCHG</a></p><h2 id="CAS的ABA问题"><a href="#CAS的ABA问题" class="headerlink" title="CAS的ABA问题"></a>CAS的ABA问题</h2><p>ABA问题: 线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。以上就是由于ABA问题带来的隐患，各种乐观锁的实现中通常都会用版本戳version来避免，详见 [AtomicStampedReference]</p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07b-Synchronized</title>
      <link href="/12.Java/Java-Tutorials.07b.Synchronized/"/>
      <url>/12.Java/Java-Tutorials.07b.Synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><p>(1) synchronized方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!resource_is_available) <span class="comment">// 持有对象锁</span></span><br><span class="line">      wait(); <span class="comment">// Object.wait(),</span></span><br><span class="line">      <span class="comment">// 重新获得锁, doSomething...</span></span><br><span class="line">      notifyAll(); <span class="comment">// 通知其他等待该对象锁的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) synchronized块:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">long</span> userID, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">      <span class="comment">// doSomething ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个类对象都有从Object继承的”对象锁”, synchronized方法利用这个对象锁保护方法内的代码片段.</li><li>对于同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前对象的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><blockquote><p><strong>同步方法</strong> 和 <strong>同步代码块</strong> 都是用了进入/退出Monitor对象来实现的, 但两者的实现细节不一样</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>在synchronized代码块前后增加的<code>monitorenter</code>和<code>monitorexist</code>两个JVM字节码指令,指令的参数是this引用。</li><li>synchronized关键字起到的作用是设置一个独占访问临界区，在进入这个临界区前要先获取对应的监视器锁，任何Java对象都可以成为监视器锁，声明在静态方法上时监视器锁是当前类的Class对象，实例方法上是当前实例。</li><li>synchronized提供了原子性、可见性和防止重排序的保证。</li><li>JMM中定义监视器锁的释放操作happen-before与后续的同一个监视器锁获取操作。再结合程序顺序规则就可以形成内存传递可见性保证。</li></ul><p>下面以一段Java代码为例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronize</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestSynchronize().inc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap查看<code>inc()</code>方法的实现:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void inc();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PRIVATE</span><br><span class="line">   Code:</span><br><span class="line">     stack=3, locals=3, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: dup</span><br><span class="line">        2: astore_1</span><br><span class="line">        3: monitorenter                     // monitor 1</span><br><span class="line">        4: aload_0</span><br><span class="line">        5: dup</span><br><span class="line">        6: getfield      #2                  // Field count:I</span><br><span class="line">        9: iconst_1</span><br><span class="line">       10: iadd</span><br><span class="line">       11: putfield      #2                  // Field count:I</span><br><span class="line">       14: aload_1</span><br><span class="line">       15: monitorexit                      // monitor 2</span><br><span class="line">       16: goto          24</span><br><span class="line">       19: astore_2</span><br><span class="line">       20: aload_1</span><br><span class="line">       21: monitorexit                     // monitor 3</span><br><span class="line">       22: aload_2</span><br><span class="line">       23: athrow</span><br><span class="line">       24: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            4    16    19   any</span><br><span class="line">           19    22    19   any</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 14: 0</span><br><span class="line">       line 15: 4</span><br></pre></td></tr></table></figure><p>在synchronized代码块前后增加的<code>monitorenter</code>和<code>monitorexist</code>两个JVM字节码指令,指令的参数是this引用。</p><p>hotspot中对于 <code>monitor_enter</code>和 <code>monitor_exit</code>的C++代码是:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LIRGenerator::monitor_enter(LIR_Opr object, LIR_Opr lock, LIR_Opr hdr, LIR_Opr scratch, int monitor_no, CodeEmitInfo* info_for_exception, CodeEmitInfo* info) &#123;</span><br><span class="line">  if (!GenerateSynchronizationCode) return;</span><br><span class="line">  // for slow path, use debug info for state after successful locking</span><br><span class="line">  CodeStub* slow_path = new MonitorEnterStub(object, lock, info);</span><br><span class="line">  __ load_stack_address_monitor(monitor_no, lock);</span><br><span class="line">  // for handling NullPointerException, use debug info representing just the lock stack before this monitorenter</span><br><span class="line">  __ lock_object(hdr, object, lock, scratch, slow_path, info_for_exception);</span><br><span class="line">&#125;</span><br><span class="line">void LIRGenerator::monitor_exit(LIR_Opr object, LIR_Opr lock, LIR_Opr new_hdr, LIR_Opr scratch, int monitor_no) &#123;</span><br><span class="line">  if (!GenerateSynchronizationCode) return;</span><br><span class="line">  // setup registers</span><br><span class="line">  LIR_Opr hdr = lock;</span><br><span class="line">  lock = new_hdr;</span><br><span class="line">  CodeStub* slow_path = new MonitorExitStub(lock, UseFastLocking, monitor_no);</span><br><span class="line">  __ load_stack_address_monitor(monitor_no, lock);</span><br><span class="line">  __ unlock_object(hdr, object, lock, scratch, slow_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，<br>所以在Java SE1.6里<code>对象锁</code>一共有四种状态，<strong>无锁状态</strong>，<strong>偏向锁状态</strong>，<strong>轻量级锁状态</strong> 和 <strong>重量级锁状态</strong>，<br>它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p><blockquote><p>轻量级锁适合追求响应时间，同步块执行速度非常快的情况<br>重量级锁追求吞吐量，适合同步块执行速度较长的代码。</p></blockquote><p>随着锁的升级， Java对象头里的<code>Mark Word</code>存储的内容也会变化。</p><blockquote><p>回顾 Java对象的内存结构: 对象有32+32个字节的”对象头”, 其中第一个32字节是”Mark Word”, 存储了hashCode, 锁信息, 以及分代信息等, 结构如下:</p></blockquote><p><img src="/images/java/jmm-object-mark-word.png" alt=""></p><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁状态下, 对象Mark Word 锁标志也是01(同偏向锁一样)</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁。<br>偏向锁只是比较，没有使用CAS操作，也没有自旋，所以在没有多线程竞争的情况下，加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。<br>偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><h2 id="轻量级锁-自旋"><a href="#轻量级锁-自旋" class="headerlink" title="轻量级锁(自旋)"></a>轻量级锁(自旋)</h2><p>轻量级锁是指 当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），<br>JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。<br>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。<br>  如果成功，当前线程获得锁，<br>  如果失败，表示其他线程竞争锁，当前线程便尝试使用 <strong>自旋</strong>来获取锁。<br>因为轻量锁用到了CAS，第一次CAS失败会进入自旋，自旋虽然会消耗CPU，但不会切换线程状态，自旋较适用于锁使用者保持锁时间比较短的情况</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁通过对象内部的监视器(<strong>monitor对象</strong>)实现的，其中monitor对象的本质是依赖于底层操作系统的<code>Mutex Lock</code>实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。<br>重量级锁不使用自旋，不会消耗CPU。但会让线程进入阻塞状态让出CPU，增加了线程切换的代价。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考自 https://blog.csdn.net/javazejian/article/details/72828483</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferRemoveSync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用</span></span><br><span class="line">        <span class="comment">//因此sb属于不可能共享的资源,JVM会自动消除内部的锁</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBufferRemoveSync rmsync = <span class="keyword">new</span> StringBufferRemoveSync();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            rmsync.add(<span class="string">"abc"</span>, <span class="string">"123"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h2><p>上面提到重量锁的实现是利用了Monitor对象,<br>编译器在把java文件编译为字节码的后, 会在<code>synchronized</code>代码块前后插入<code>monitorenter</code>和<code>monitorexit</code>指令,<br><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，而<code>monitorexit</code>是插入到方法结束处和异常处， JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。<br>“任何Java对象都有一个 monitor对象 与之关联，当且一个 monitor对象 被持有后，它将处于锁定状态。”<br>这两个指令是通过monitor对象实现的（有关<code>monitorenter</code>和<code>monitorexit</code>指令的实现在JVM的InterpreterRuntime.cpp文件），<br>monitor对象可以看成是JVM进程里的C++对象。每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>Monitor模型中, 有三个重要的属性, 可以想象成三个不同的房间：Special Room, Entry Set, Wait Set</p><p>如果一个顾客想要进入这个特殊的房间（Special Room），他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。<br>如果，因为某些原因，该客户客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间的可以可以在稍后再次进入那件特殊的房间。</p><p>图-Monitor模型:<br><img src="/images/java/java_monitor.gif" alt="Monitor模型"></p><h1 id="Object-wait-和notify"><a href="#Object-wait-和notify" class="headerlink" title="Object.wait()和notify()"></a>Object.wait()和notify()</h1><ul><li>The Owner: 指向持有Monitor对象的线程, 同一时刻只允许一个线程持有;</li><li>Entry Set: 尝试持有Monitor的线程都会先进入这个队列, 如果线程获取到了Monitor对象, 线程会从Entry Set队列删除, Owner同时会指向这个线程, 这个对列里的线程再次获取锁从而进入The Owner区;</li><li>Wait Set: 调用了<code>object.wait()</code>的线程从Owner区进入Wait Set, 等待被唤醒,  如上图中的③,  注意必须拥有锁的线程才能调<code>object.wait()</code>;<ul><li>如果调用<code>object.notify()</code>和<code>object.notifyAll()</code>, 线程会进入Entry Set队列或者自旋获取Owner ?</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07a2-ThreadLocal</title>
      <link href="/12.Java/Java-Tutorials.07a2.ThreadLocal/"/>
      <url>/12.Java/Java-Tutorials.07a2.ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">java.lang.ThreadLocal&lt;T&gt;</span><br></pre></td></tr></table></figure><p>ThreadLocal是一个为线程提供线程局部变量的工具类。为线程提供一个线程私有的变量副本，这样多个线程都可以随意更改自己线程局部的变量，不会影响到其他线程。<br><del>不过需要注意的是，ThreadLocal提供的只是一个浅拷贝，如果变量是一个引用类型，那么就要考虑它内部的状态是否会被改变，想要解决这个问题可以通过重写ThreadLocal的<code>initialValue()</code>函数来自己实现深拷贝，建议在使用ThreadLocal时一开始就重写该函数。</del><br>首次调用<code>threadLocal.get()</code>方法时会调用<code>initialValue()</code>赋一个初始值。</p><p>例子: 1.8之前提供的<code>SimpleDateFormat</code>不是线程安全的, 下面的代码用ThreadLocal 解决这个问题:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Session <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前线程的ThreadLocal 为新的对象</span></span><br><span class="line">threadLocal.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yy-MM-dd"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取当前线程的ThreadLocal 内保存的对象</span></span><br><span class="line">DateFormat localFormatter = (DateFormat)threadLocal.get();</span><br></pre></td></tr></table></figure><p>注： JDK1.8的 DateTimeFormatter是线程安全的.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们需要知道Thread类中有一个threadLocals变量:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>中含有一个叫做<code>ThreadLocalMap</code>的内部类，该类为一个采用线性探测法实现的<code>HashMap</code>。<br>这个 HashMap 的 Entry继承了WeakReference:  <code>Entry(ThreadLocal,Object)</code>,它的 key为<code>ThreadLocal</code>对象, value是缓存的本地对象,<br>从 ThreadLocal中 get值的时候，首先通过 <code>Thread.currentThread</code>得到当前线程，然后拿到这个线程的 ThreadLocalMap，取得Entry中的value值。</p><p>下面是<code>ThreadLocalMap</code>代码片段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">    * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">    * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">    * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">    * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">    * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">       Object value;</span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="keyword">super</span>(k);</span><br><span class="line">           value = v;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>中只有三个成员变量，这三个变量都是与<code>ThreadLocalMap</code>的hash策略相关的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment">* to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment">* inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment">* searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment">* (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment">* in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment">* are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment">* less common cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment">* zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">* implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">* multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the next hash code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的实例变量<code>threadLocalHashCode</code>是用来进行寻址的hashcode，它由函数 <code>nextHashCode()</code>生成，该函数简单地通过一个增量HASH_INCREMENT来生成hashcode。至于为什么这个增量为0x61c88647，主要是因为ThreadLocalMap的初始大小为16，每次扩容都会为原来的2倍，这样它的容量永远为2的n次方，该增量选为0x61c88647也是为了尽可能均匀地分布，减少碰撞冲突。</p><p><code>ThreadLocal</code>部分参考自: <a href="https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/" target="_blank" rel="noopener">聊一聊Spring中的线程安全性 | SylvanasSun’s Blog</a> </p><h1 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h1><p>如果在父线程中创建 ThreadLocal，会发现父线程设置的值在子线程中无法获取，JDK中有InheritableThreadLocal解决此问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThreadUsage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新启一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threadLocal.get() -&gt; "</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>InheritableThreadLocal 继承了 ThreadLocal<t>，并且数据存放在Thread的 类变量的 inheritableThreadLocals中，变量类型是 ThreadLocal.ThreadLocalMap;<br>在 Thread 构造方法调用的 init() 中，可看见如果 parent.inheritableThreadLocals不为空，则 ThreadLocal.createInheritedMap()拷贝 ThreadLocalMap，注意这里的拷贝是浅拷贝。子线程如果修改了继承自父线程的ThreadLocal，其他的子线程也可能会看到这个改变。</t></p><blockquote><p>@ref: <a href="https://cloud.tencent.com/developer/article/1162226" target="_blank" rel="noopener">alibaba/TransmittableThreadLocal</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-07a1-线程API</title>
      <link href="/12.Java/Java-Tutorials.07a1.%E7%BA%BF%E7%A8%8BAPI/"/>
      <url>/12.Java/Java-Tutorials.07a1.%E7%BA%BF%E7%A8%8BAPI/</url>
      
        <content type="html"><![CDATA[<h1 id="线程6种状态"><a href="#线程6种状态" class="headerlink" title="线程6种状态"></a>线程6种状态</h1><ol><li>New, 创建Thread实例之后;</li><li>Runnable, 执行<code>thread.start()</code>之后;</li><li>Blocked, 线程试图获取ReentrantLock失败, 或进入synchronize代码块, 或调用Block IO;</li><li>Waiting, 调用<code>object.wait()</code>或<code>thread.join()</code>之后;<ul><li>调用<code>object.wait()</code>, <code>condition.await()</code>方法都会产生WAITING状态;</li><li>调用<code>thread.join()</code>后, 调用者会Waiting一直到thread线程退出;</li></ul></li><li>Time-Waitting, 调用<code>Object.wait(long)</code>或<code>thread.join(long)</code>, <code>lock.tryLock(long)</code>时;</li><li>Terminated: 线程的<code>run()</code>方法正常退出或者<code>run()</code>方法抛出未捕获异常时;</li></ol><blockquote><p>上面的状态来自Oracle JDK 8 <code>java.lang.Thread.State</code>, 并不等同于unix下的原生线程状态,<br><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Thread.State.html" target="_blank" rel="noopener">Thread.State (Java Platform SE 8 )</a></p></blockquote><p>图-线程6种状态的转换:<br><img src="/images/java/java_thread_states_all.png" alt="Thread States"></p><h1 id="线程控制API"><a href="#线程控制API" class="headerlink" title="线程控制API"></a>线程控制API</h1><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种Runnable接口</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> runnable() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// new之后线程处于"New"状态</span></span><br><span class="line">t.start(); <span class="comment">// start之后线程处于"Runnable"状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">Class MyThread extends Thread &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Mythread().start();</span><br></pre></td></tr></table></figure><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><ul><li>调用<code>t.interrupt()</code>方法时, 线程<code>t</code>会收到中断信号, Java并没有要求线程一定响应中断. 线程应该根据情况决定是否响应中断, 循环调用<code>t.isInterrupted()</code>可以检测线程的中断标志位.</li><li>如果线程内调用了<code>sleep()</code>或者<code>wait()</code>方法让线程进入等待状态, 当调用<code>t.interrupt()</code>, 线程会抛出<code>InterruptException</code>, 如果你的线程里调用了可能抛出该异常的阻塞方法, 那么就不必每次调用<code>isInterrupt()</code>检测中断状态了, 在catch里捕获该异常即可.</li><li>如果线程已经被中断的情况下再调用<code>sleep()</code>, <code>sleep()</code>方法会清除中断状态并且抛出上述异常, 并不会进入sleep状态, 所以线程循环中有<code>sleep()</code> 的也不必用<code>isInterrupt</code>检查中断状态</li><li>可抛出中断异常的: 线程内调用<code>wait()</code>, 或者调用<code>thread.join()</code>和<code>thread.sleep()</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted() <span class="comment">/* &amp;&amp; */</span>) &#123;</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>); <span class="comment">// 如果有sleep, 上面的isInterrupted不必要</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t.start(); <span class="comment">// sub-thread now is "runnnable"</span></span><br><span class="line"></span><br><span class="line">t.interrupt(); <span class="comment">// main thread interrupt sub-thread</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>执行<code>thread.join()</code>的线程会进入waiting状态, 直到<code>thread</code>线程终止或自然退出, 继续执行后面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">thread.start();</span><br><span class="line">thread.join(); <span class="comment">// 在这里waiting</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的thread退出后, 才会进行到这里</span></span><br></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>执行<code>thread.sleep(m)</code>的线程会进入timed_waitting状态m毫秒(注意, 并没有sleep这种状态),<br><code>Thread.sleep()</code>与线程调度器交互，它将当前线程设置为等待一段时间的状态。一旦等待时间结束，线程状态就会被改为可运行（runnable），并开始等待CPU来执行后续的任务。因此，当前线程的实际休眠时间取决于线程调度器，而线程调度器则是由操作系统来进行管理的。</p><p>比较<code>thread.sleep(long millis)</code>和<code>object.wait()</code>:</p><ul><li>对于<code>sleep()</code>方法，我们首先要知道该方法是属于Thread类中的。而<code>wait()</code>方法，则是属于Object类中的。</li><li><code>sleep()</code>方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是cpu对线程的监控状态依然保持者，当指定的时间到了又会自动恢复runnable。</li><li>在调用<code>sleep()</code>方法后, 线程进入timed_waiting状态, 并且线程不会释放对象锁。</li><li>当调用线程里调用<code>obj.wait()</code>方法的时候，线程进入等待此对象的等待队列，放弃对象锁并进入waiting状态，只有针对此对象调用<code>notify()</code>方法后, 线程才会从对象锁的等待队列中被取出。</li></ul><h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别?"></a>sleep和wait的区别?</h2><ul><li><code>Thread.sleep()</code>方法是一个静态方法，作用在当前线程上；</li><li><code>obj.wait()</code>方法是一个实例方法，并且只能在其他线程调用本实例的<code>obj.notify()</code>方法时被唤醒。</li><li>调用<code>wait()</code>方法时，线程在等待的时候会释放掉它所获得的monitor，但是调用<code>Thread.sleep()</code>方法时，线程在等待的时候仍然会持有monitor或者锁。</li><li>Java中的<code>wait()</code>方法应在同步代码块中调用(已经获得了对象锁的情况下, 调用对象.wait()会放弃锁)</li><li>使用<code>sleep()</code>方法时，被暂停的线程(是处于timed_wait状态?) 在被唤醒之后会立即进入就绪态（Runnable state)</li><li>从<code>wait()</code>方法被唤醒的时候(通常是其他线程调用了<code>obj.notify()</code>)，被暂停的线程要首先获得锁，然后再进入Runnable。</li><li>如果你需要暂定线程一段特定的时间就使用<code>sleep()</code>方法，如果你想要实现线程间通信就使用<code>wait()</code>方法。</li></ul><h2 id="如何终止线程"><a href="#如何终止线程" class="headerlink" title="如何终止线程?"></a>如何终止线程?</h2><p>几个问题:</p><ol><li>被调用了<code>sleep()</code>的线程(timed_waiting状态)可以被<code>interrupt()</code>抛出异常吗?</li><li>调用了<code>thread.join()</code>的线程(waiting状态)可以被<code>interrupt()</code>抛出异常吗?</li><li>调用了<code>object.wait()</code>的线程(waiting状态)可以被<code>interrupt()</code>抛出异常吗?</li><li>调用阻塞IO方法被阻塞住的线程可以被<code>interrupt()</code>抛出异常吗?</li><li>试图抢占锁(synchronized或ReentrantLock)但失败的线程(blocked状态)可以被<code>interrupt()</code>抛出异常吗?</li></ol><p>答案: 可以, 可以, 可以, 否, 否</p><p><strong>所以</strong> 只有处于waiting或timed_waiting状态的线程才可以抛出<code>InterruptException</code>异常被中断, block状态的线程不可以;</p><p>如何终止waiting或timed_waiting状态的线程呢? 有两种方式:</p><ul><li>用Volatile的标志位控制线程的循环逻辑;</li><li>使用interrupt()方法中断当前线程, 线程的循环里应该try-catch <code>InterruptException</code></li></ul><p>但是对于进入blocked状态的线程, 是无法被<code>interrupt()</code>中断的, 所以可能的做法是: 关闭阻塞的资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOBlocked</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">        in = is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptException e1) &#123;</span><br><span class="line">            <span class="comment">// 事实永远无法到达这, 因为read不抛InterruptException</span></span><br><span class="line">            <span class="comment">// InterruptException是受检异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HowToInterruptIOBlockedThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开网络流</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InputStream stream = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8080</span>).getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行会导致IO Blocked的线程</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> IOBlocked(stream));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程sleep</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试停止所有正在执行的任务, shutdownNow会尝试调用所有线程的interrupt</span></span><br><span class="line">        service.shutdownNow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过关闭线程操作的资源来释放阻塞的线程</span></span><br><span class="line">        stream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="唤醒线程"><a href="#唤醒线程" class="headerlink" title="唤醒线程"></a>唤醒线程</h2><p>如何唤醒sleep或者wait的线程?</p><ul><li>对于因为IO阻塞而进入的blocked状态的线程, 没有办法唤醒;</li><li>对于因为调用<code>waiting()</code>, <code>t.sleep()</code>, <code>t.join()</code>而进入waiting或timed_waiting状态的线程, 调用<code>t.interrupt()</code>可以让上面的”阻塞操作”抛出<code>InterruptedException</code>来打到”唤醒”的效果;</li></ul><h2 id="被弃用的方法"><a href="#被弃用的方法" class="headerlink" title="被弃用的方法"></a>被弃用的方法</h2><p>Thread类不再推荐被使用的方法: <del>~yield,stop,suspend,resume</del>~</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield方法会临时暂停当前正在执行的线程，来让有同样优先级的正在等待的线程有机会执行。<br>如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。<br>执行了yield方法的线程什么时候会继续运行由线程调度器来决定。<br>yield方法不保证当前的线程会暂停或者停止，但是可以保证当前线程在调用yield方法时会放弃CPU。</p><p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。<br>因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。<br>但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><blockquote><p>该方法天生是不安全的。使用thread.stop()停止一个线程，导致释放（解锁）所有该线程已经锁定的监视器（因沿堆栈向上传播的未检查ERROR <code>ThreadDeath</code>而解锁）。 // → 非受检异常<br>如果之前受这些监视器保护的任何对象处于不一致状态，则不一致状态的对象（受损对象）将对其他线程可见，这可能导致任意的行为。<br>ThreadDeath是java.lang.Error，不是java.lang.Exception。不受检异常意味着我们不会有意识在代码里写Try-Catch去处理异常, 比如在finally里释放锁</p></blockquote><p>上面的意思是:<br>线程当前可能持有一个监视器(或锁)，执行 <code>thread.stop()</code> 将会产生一个 ThreadDeath 错误(不受检ERROR)，线程向上抛出错误，导致监视器被解锁。<br>可能导致的问题: 以银行转账的例子,如果在”减扣A余额, 增加B余额”的过程中, 线程被stop, 将产生业务数据的不一致.</p><p><strong>建议</strong> 用interrupt替代stop, 在线程中循环检测<code>thread.isInterrupted()</code> 或者 捕获<code>InterruptException</code> 然后由业务代码进行收尾处理.</p><p>ThreadDeath 和 InterruptException 的区别是:<br>  前者不受检, 意味着业务代码没有机会捕获并处理, 会向上层堆栈抛出错误, 线程状态变为 “Terminated”;<br>  后者是受检异常, 可以被捕获并由业务代码处理;</p><h3 id="suspend-amp-resume"><a href="#suspend-amp-resume" class="headerlink" title="suspend &amp; resume"></a>suspend &amp; resume</h3><ul><li>当某个线程的suspend()方法被调用时，该线程会被挂起。如果该线程占有了锁，则它不会释放锁。线程在挂起的状态下还持有锁，这导致其他线程将不能访问该资源直到目标线程恢复工作。</li><li>线程的<code>resume()方法</code>会恢复 因<code>suspend()</code>方法挂起的线程，使之重新能够获得CPU执行。</li></ul><p>建议使用 <code>object.wait</code> 和 <code>object.notify</code>方法代替 <code>suspend</code> &amp; <code>resume</code></p><h1 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h1><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ul><li>java中线程优先级范围 <code>MIN_PRIORITY</code>~<code>MAX_PRIORITY</code> (其值1~10), <code>NORMAL_PRIORITY</code>(其值=5);</li><li>线程默认情况下继承父线程的优先级;</li></ul><h2 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>当JVM还存在一个非守护线程, JVM就不会退出, 当存活的线程仅剩下守护线程时, JVM才会退出.<br>守护线程最典型的应用就是GC</p><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-06-序列化</title>
      <link href="/12.Java/Java-Tutorials.06.%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/12.Java/Java-Tutorials.06.%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>@Question:</p><ul><li>如何定义一个可序列化的类?</li><li>serialVersionUID属性的作用和生成方式?</li><li>哪些字段不会被序列化?</li><li>ArrayList类的序列化是如何实现的?</li><li>如何自定义序列化?</li><li>反序列化的调用过程?</li></ul><ol><li>实现 <code>Serializable</code>接口的类可以被序列化, 通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>对象进行序列化及反序列化</li><li>通过<code>ObjectOutputStream</code>反序列化的时候, 会比较 serialVersionUID是否相同, 如果不同会抛异常<code>InvalidClassException</code>, 建议: 在创建可序列化的类的时候指定一个serialVersionUID, 并且在可兼容升级的时候不要修改serialVersionUID, 除非是不兼容的版本. 如果没有定义serialVersionUID, 在反序列化的时候, ObjectOutputStream会自动生成一个(根据类名,接口名,属性名, 以及描述符等生成一个64位的哈希数字)</li><li>static 和 transient关键字修饰的属性不会被序列化</li><li>ArrayList的实现里, 把<code>elementData[]</code>声明为 transient, 同时也实现了<code>writeObject(ObjectOutputStream)</code>和<code>readObject(ObjectInputStream)</code>, 在这两个方法里实现自定义序列化, 目的是为了避免<code>elementData[]</code>中大量空元素被序列化, 减少序列化字节占用.</li><li>如何自定义序列化实现: 类实现自己的<code>writeObject(ObjectOutputStream)</code>和<code>readObject(ObjectInputStream)</code></li><li>反序列化调用过程(伪码): <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject(Object)</span><br><span class="line">    ObjectStreamClass.initNonProxy // 检查是否实现 Serializable接口, serialVersionUID是相等</span><br><span class="line">        调用类的readObject()</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>@ref <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120882&amp;idx=1&amp;sn=8e355b5ee3cce0a2d0108edbdf88e606" target="_blank" rel="noopener">你真的以为你了解Java的序列化了吗？</a><br>@ref <a href="https://juejin.im/entry/5c2192de6fb9a049e2320859" target="_blank" rel="noopener">为什么阿里巴巴要求程序员谨慎修改serialVersionUID 字段的值 - 后端 - 掘金</a></p></blockquote><p>序列化/反序列化API示例代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4964541705925508858L</span>;</span><br><span class="line"><span class="keyword">transient</span> Logger logger = LoggerFactory.getLogger(Config.class);</span><br><span class="line"><span class="keyword">long</span> uid;</span><br><span class="line">String nick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(filePath));</span><br><span class="line">os.writeObject(user);</span><br><span class="line">os.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(filePath));</span><br><span class="line">User newUser = (User)is.readObject();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-05-IO</title>
      <link href="/12.Java/Java-Tutorials.05.IO/"/>
      <url>/12.Java/Java-Tutorials.05.IO/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 的 I/O 操作类在包 java.io 下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：</p><ul><li>基于字节操作的 I/O 流接口：<code>InputStream</code> 和 <code>OutputStream</code></li><li>基于字符操作的 I/O 流接口： <code>Writer</code> 和 <code>Reader</code></li><li>基于磁盘操作的 I/O 文件接口： <code>File</code></li></ul><p>参考: <a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">深入分析 Java I/O 的工作机制</a> @ref</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>按照流操作对象的类型是字节还是字符, 分为字节流和字符流</p><ol><li>字节流的父类是 <code>InputStream</code>/<code>OutputStream</code>, 读写单个字节/字节数组,</li><li>字符流的父类是 <code>Reader</code>/<code>Writer</code> 用于读写被编码(GBK/UTF8)的字符串, 读写Char/Char数组;</li></ol><p>按照功能分为节点流(node stream)和过滤流(filter stream, 或者叫装饰流)</p><ol><li>节点流用来处理从基本位置获取字节(文件, 内存, 管道), <code>FileInputStream</code>, <code>ByteArrayInputStream</code>, <code>PipedInputStream</code>, 这些类提供基本的读写方法;</li><li>过滤流用于包装节点流, 提供了新的方法, 可以更方便的读写高级类型的数据(类序列化, 压缩文件, Java基本类型) <code>ObjectInputStream</code>, <code>ZipInputStream</code>,  <code>DataInputStream</code>.</li></ol><h3 id="节点流-amp-过滤流"><a href="#节点流-amp-过滤流" class="headerlink" title="节点流 &amp; 过滤流"></a>节点流 &amp; 过滤流</h3><p>图-外层的DataInputStream（过滤流）提供了额外的方法：<br><img src="/images/java/Node_Stream_Filter_Stream.gif" alt="Node Stream &amp; Filter Stream"></p><h3 id="字节流-amp-字符流"><a href="#字节流-amp-字符流" class="headerlink" title="字节流 &amp; 字符流"></a>字节流 &amp; 字符流</h3><p><strong>字符流</strong>相关类以及继承关系:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符流</span><br><span class="line">  |-InputStream</span><br><span class="line">  |   |-FileInputStream [node流] 文件流</span><br><span class="line">  |   |-ByteArrayInputStream [node流] 内存字符流</span><br><span class="line">  |   |-PipedInputStream [node流] 管道流</span><br><span class="line">  |   |-ObjectInputStream</span><br><span class="line">  |   |-SequenceInputStream</span><br><span class="line">  |   |-FilterInputStream</span><br><span class="line">  |       |-DataInputStream</span><br><span class="line">  |       |-BufferedInputStream</span><br><span class="line">  |</span><br><span class="line">  |-OutputStream</span><br></pre></td></tr></table></figure><p><strong>字节流</strong>相关类以及继承关系:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字节流</span><br><span class="line">  |-Reader</span><br><span class="line">  |   |-InputStreamReader</span><br><span class="line">  |       |-FileReader</span><br><span class="line">  |   |-PipedReader</span><br><span class="line">  |   |-BufferedReader</span><br><span class="line">  |   |-CharArrayReader</span><br><span class="line">  |   |-StringReader</span><br><span class="line">  |</span><br><span class="line">  |-Writer</span><br><span class="line">      |-PrintWriter 没有对应的Reader, 可以使用java.io.Scaner</span><br></pre></td></tr></table></figure><h4 id="字节流-常用类和方法"><a href="#字节流-常用类和方法" class="headerlink" title="字节流 常用类和方法"></a>字节流 常用类和方法</h4><ul><li><code>InputStream</code>/<code>OutputStream</code> 提供基本的字符/字符数组读写<ul><li><code>InputStream.available()</code> : 返回可读的字节数</li><li><code>read()</code>, <code>read(byte[])</code>: 阻塞的, read返回读取的一个字节(int)</li><li><code>write(int b)</code>, <code>write(byte[])</code>: 阻塞的</li><li><code>close()</code></li></ul></li><li><code>FileInputStream</code>/<code>FileOutputStream</code></li><li><code>ByteArrayInputStream</code>/<code>ByteArrayOutputStream</code>: 包含一个内部缓冲区(字节数组), 该缓冲区包含从流中读取的字节</li><li><code>PipedInputStream</code>/<code>PipedOutputStream</code> 同上</li><li><code>BufferedInputStream</code>/<code>BufferedOutputStream</code>: 为另一个流提供缓冲</li><li><code>ObjectInputStream</code>/<code>ObjectOutputStream</code><ul><li><code>Object readObject()</code></li><li><code>void writeObject(Object)</code></li></ul></li></ul><h4 id="字符流-常用类和方法"><a href="#字符流-常用类和方法" class="headerlink" title="字符流 常用类和方法"></a>字符流 常用类和方法</h4><ul><li><strong>Reader</strong>: 提供对char,char[],String类型数据的基本操作<ul><li><code>read()</code>: 返回字符的Unicode编码(0-65535,双字节范围), 到达流末尾返回-1;</li><li><code>read(char[])</code>: 读取字符到数组并返回已读取的字符个数;</li><li><code>skip(long n)</code>: 跳过n个char</li><li><code>mark(int limit)</code>: 为流的当前位置增加标记, 下次调用reset可以返回这个标记, 如果调用mark()后读取字符数超过limit, 下次调用reset会失败.</li><li><code>reset()</code>:</li><li><code>close()</code>:</li></ul></li><li><strong>InputStreamReader</strong><ul><li><code>getEncoding()</code>: 获取输入流的编码</li><li><code>ready()</code>: 如果有数据可读, 返回true</li></ul></li><li><strong>FileReader</strong>: 继承自 InputStreamReader<ul><li>构造器: <code>FileReader(String)</code>, <code>FileReader(java.io.File)</code></li></ul></li><li><strong>BufferedReader</strong>:<ul><li><code>readLine()</code> : 读取一行并返回字符串(不包括换行符), 如果流已经读尽则返回null</li></ul></li><li><strong>Scanner</strong>: 不是继承自Reader</li><li><strong>Writer</strong> : 提供对char,char[],String类型数据的基本操作<ul><li><code>write(char c)</code>, <code>write(char[])</code>, <code>write(String)</code></li><li><code>append(char)</code>, <code>append(CharSequence)</code></li><li><code>flush()</code>: 让缓冲区的内容立刻写入</li><li><code>close()</code> :</li></ul></li><li><strong>PrintWriter</strong>:</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>本章主要介绍文件操作类: <code>java.io.File</code> 和 <code>java.io.RandomAccessFile</code></p><h3 id="java-io-File"><a href="#java-io-File" class="headerlink" title="java.io.File"></a>java.io.File</h3><p>File 是“文件”和“目录路径名”的抽象表示形式。File 直接继承于Object，实现了Serializable接口和Comparable接口。<br>实现Serializable接口，意味着File对象支持序列化操作。<br>实现Comparable接口，意味着File对象之间可以比较大小；File能直接被存储在有序集合(如TreeSet、TreeMap中)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFileDirAPIS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建目录</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">"dir"</span>);</span><br><span class="line">    dir.mkdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建文件</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(dir, <span class="string">"file1.txt"</span>);</span><br><span class="line">    file1.createNewFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列出目录下的文件</span></span><br><span class="line">    File[] fs = dir.listFiles();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-io-RandomAccessFile"><a href="#java-io-RandomAccessFile" class="headerlink" title="java.io.RandomAccessFile"></a>java.io.RandomAccessFile</h3><p><code>java.io.RandomAccessFile</code>是随机访问文件(包括读/写)的类。它支持对文件随机访问的读取和写入，即我们可以从指定的位置读取/写入文件数据。<br>需要注意的是，RandomAccessFile 虽然属于java.io包，但它不是InputStream或者OutputStream的子类；<br>它也不同于FileInputStream和FileOutputStream。 FileInputStream 只能对文件进行读操作，而FileOutputStream 只能对文件进行写操作；<br>RandomAccessFile 同时支持文件的读和写，并且它支持随机访问。</p><blockquote><p><code>RandomAccessFile</code> 大部分功能被JDK1.4中NIO的内存映射文件替代了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(args[<span class="number">0</span>], <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">long</span> position = raf.length();</span><br><span class="line"><span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  position -= <span class="number">1</span>;</span><br><span class="line">  raf.seek(position);</span><br><span class="line">  <span class="keyword">byte</span> b = raf.readByte();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p>旧风格的I/O操作的异常捕获:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read(); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read(); <span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            input.close(); <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中可能会抛出异常. try语句块中有3个地方能抛出异常, finally语句块中有一个地方会能出异常.<br>不论try语句块中是否有异常抛出, finally语句块始终会被执行.这意味着, 不论try语句块中发生什么, InputStream 都会被关闭, 或者说都会试图被关闭.如果关闭失败, InputStream’s close()方法也可能会抛出异常.<br>Q: 假设try语句块抛出一个异常, 然后finally语句块被执行.同样假设finally语句块也抛出了一个异常.那么哪个异常会根据调用栈往外传播？<br>A: 即使try语句块中抛出的异常与异常传播更相关, 最终还是finally语句块中抛出的异常会根据调用栈向外传播.</p></blockquote><p>在JDK7中, <strong>try-with-resources</strong> 风格的IO异常捕获:<br>try-with-resources语句会确保在try语句结束时关闭所有资源. 实现了<code>java.lang.AutoCloseable</code>或<code>java.io.Closeable</code>的对象都可以做为在<code>try()</code>代码块内打开的资源, 并且可以在退出<code>try()</code>语句块时被自动关闭.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try()代码块内打开多个资源:</span></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">  java.util.zip.ZipFile zf = <span class="keyword">new</span> java.util.zip.ZipFile(zipFileName);</span><br><span class="line">  InputStream ins = <span class="keyword">new</span> FileInputStream(<span class="string">"/a.txt"</span>);</span><br><span class="line">  java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)</span><br><span class="line">  <span class="comment">// 这里没有分号</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Enumerate each entry</span></span><br><span class="line">  <span class="keyword">for</span> (java.util.Enumeration entries = zf.entries(); entries.hasMoreElements();) &#123;</span><br><span class="line">      <span class="comment">// Get the entry name and write it to the output file</span></span><br><span class="line">      String newLine = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">      String zipEntryName =</span><br><span class="line">           ((java.util.zip.ZipEntry) entries.nextElement()).getName() + newLine;</span><br><span class="line">      writer.write(zipEntryName, <span class="number">0</span>, zipEntryName.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception1 | Exception2 e) &#123; <span class="comment">// 新风格的catch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当try-with-resources结构中抛出一个异常, 同时资源调用close方法时也抛出一个异常, try-with-resources结构中抛出的异常会向外传播, 而资源被关闭时抛出的异常被抑制了. 这与旧风格代码的例子相反.</p></blockquote><h2 id="API-Example"><a href="#API-Example" class="headerlink" title="API Example"></a>API Example</h2><h3 id="字节流-API-Example"><a href="#字节流-API-Example" class="headerlink" title="字节流 API Example"></a>字节流 API Example</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基本字节流 InputStream/OutputStream 接口测试: */</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>&#125;;</span><br><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"~/testFile"</span>);</span><br><span class="line">os.write(bytes); <span class="comment">// 1</span></span><br><span class="line">os.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size; <span class="keyword">byte</span>[] readbuf;</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"~/testFile"</span>);</span><br><span class="line"><span class="keyword">if</span>((size= is.available()) &gt; <span class="number">0</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">  is.read(readbuf= <span class="keyword">new</span> <span class="keyword">byte</span>[size]); <span class="comment">// 3</span></span><br><span class="line">  System.out.println(<span class="keyword">new</span> String(readbuf));</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Filter Streams Layered onto Node Stream */</span></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"A.txt"</span>); <span class="comment">// Node Stream</span></span><br><span class="line">BufferedOutputStream bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream); <span class="comment">// Filter Stream</span></span><br><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(bufferedOutputStream);</span><br><span class="line">out.writeInt(<span class="number">3</span>);</span><br><span class="line">out.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">  <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(<span class="string">"A.txt"</span>)));</span><br><span class="line"><span class="comment">// DataInputStream Methods:</span></span><br><span class="line">in.readInt();</span><br><span class="line">in.readBoolean();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h3 id="字符流-API-Example"><a href="#字符流-API-Example" class="headerlink" title="字符流 API Example"></a>字符流 API Example</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* PrintWriter and Scanner */</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"A.txt"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">out.println(<span class="string">"Hello"</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"A.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">  String line = scanner.nextLine();</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FileReader -&gt; BufferedReader */</span></span><br><span class="line">FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">"~/testout.txt"</span>);</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>((i=br.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">  System.out.print((<span class="keyword">char</span>)i);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">fr.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BufferedReader 逐行读取 */</span></span><br><span class="line">String line;</span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(ReadFile);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件字节流 -&gt; 文件字符流 */</span></span><br><span class="line">FileOutputStream os = <span class="keyword">new</span> FileOutputStream(WriteFile);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(os,<span class="string">"UTF-8"</span>);</span><br><span class="line">writer.append(<span class="string">"Hello\r\n"</span>);</span><br><span class="line">writer.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符流处理Socket */</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">Writer writer = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">write.write(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// close writer and socket</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-04-泛型</title>
      <link href="/12.Java/Java-Tutorials.04.%E6%B3%9B%E5%9E%8B/"/>
      <url>/12.Java/Java-Tutorials.04.%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型类和泛型方法"><a href="#泛型类和泛型方法" class="headerlink" title="泛型类和泛型方法"></a>泛型类和泛型方法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T first;</span><br><span class="line">  <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setFirst</span><span class="params">(T)</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setSecond</span><span class="params">(T)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class ArrayAlg &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span> <span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t[t.length / <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用泛型方法</span></span><br><span class="line">ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 或者不用指定泛型方法的T, 编译期自行推断也是可以的:</span></span><br><span class="line">ArrayAlg.getMiddle(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型的类型限定"><a href="#泛型的类型限定" class="headerlink" title="泛型的类型限定"></a>泛型的类型限定</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">  T min = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &lt; min) min = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果T需要多个类型限定: <code>&lt;T extends Comparable &amp; Serializable&gt;</code></p><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><ul><li>JVM没有”泛型类”这种类型, java代码被编译后生成的字节代码, 这个过程中所有的泛型类型要被替换, 原则:<ul><li>有类型限定的, 替换为第一个限定类型, <code>T extends Comparable &amp; Serializable</code>被替换为<code>Comparable</code></li><li>无类型限定, 替换为Object, <code>T</code>被替换为<code>Object</code></li></ul></li></ul><h3 id="对类型查询的影响"><a href="#对类型查询的影响" class="headerlink" title="对类型查询的影响"></a>对类型查询的影响</h3><h4 id="1-instanceof"><a href="#1-instanceof" class="headerlink" title="1. instanceof"></a>1. instanceof</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; s = <span class="keyword">new</span> Pair&lt;String&gt;(); <span class="comment">// 擦除后为 Pair&lt;Object&gt; s</span></span><br><span class="line"><span class="keyword">if</span>(s <span class="keyword">instanceof</span> Pair&lt;T&gt;) &#123; <span class="comment">// Pair&lt;T&gt;擦除后为Pair&lt;Object&gt;</span></span><br><span class="line"> <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s <span class="keyword">instanceof</span> Pair&lt;Double&gt;) &#123;</span><br><span class="line"> <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-getClass"><a href="#2-getClass" class="headerlink" title="2. getClass()"></a>2. getClass()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; s = <span class="keyword">new</span> Pair&lt;String&gt;();</span><br><span class="line">Pair&lt;Double&gt; d = <span class="keyword">new</span> Pair&lt;Double&gt;();</span><br><span class="line"><span class="keyword">if</span>(s.getClass() == d.getCLass()) &#123; <span class="comment">// getClass()总是返回Pair&lt;Object&gt;</span></span><br><span class="line">  <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不能创建泛型类数组"><a href="#不能创建泛型类数组" class="headerlink" title="不能创建泛型类数组"></a>不能创建泛型类数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 试图创建泛型类型的数组会在编译期报错:</span></span><br><span class="line">Pair&lt;String&gt;[] arr = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">1</span>]; <span class="comment">// error !</span></span><br><span class="line">Pair&lt;String&gt;[] arr = Array.newInstance(Pair&lt;String&gt;.getClass(),<span class="number">1</span>); <span class="comment">// error !</span></span><br></pre></td></tr></table></figure><p>原因是数组一旦创建会记住元素的类型, 当试图向数组中存储不同的类型时会报错, <code>Pair&lt;String&gt;[]</code>这样声明的泛型数组, 擦除后变为<code>Pair&lt;Object&gt;[]</code>.</p><h3 id="不能实例化泛型"><a href="#不能实例化泛型" class="headerlink" title="不能实例化泛型"></a>不能实例化泛型</h3><p>不能使用像<code>new T()</code>, <code>new T[N]</code>, <code>T.class</code>这样的表达式.</p><h2 id="通配符-lt-gt"><a href="#通配符-lt-gt" class="headerlink" title="通配符&lt;?&gt;"></a>通配符&lt;?&gt;</h2><h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Foo</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.get(<span class="number">0</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List&lt;?&gt;</code>表示持有某种特定类型的List，但是不知道具体是哪种类型。那么我们可以向其中添加对象吗？当然不可以，因为并不知道实际是哪种类型，所以不能添加任何类型，这是不安全的。</p><h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p><code>? extends ClassType</code>表示ClassType的任何子类</p><p>先看一段代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Fruit&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile Error: can’t add any type of object:</span></span><br><span class="line"><span class="comment">// flist.add(new Apple());</span></span><br><span class="line"><span class="comment">// flist.add(new Fruit());</span></span><br><span class="line"><span class="comment">// flist.add(new Object());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能向list里添加null</span></span><br><span class="line">list.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get是可以编译通过的</span></span><br><span class="line">list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>做了泛型的向上转型 (<code>List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;()</code>)，那么我们也就失去了向这个<code>List</code>添加任何对象的能力，即使是<code>Object</code>也不行。<br>那么上界通配符有什么用呢?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(List&lt;? extends Fruit&gt; list)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">        Fruit fruit = list.get(i);</span><br><span class="line">        System.out.println(fruit.getName());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      list.add(<span class="keyword">new</span> Apple()); <span class="comment">// Compile Error!</span></span><br><span class="line">      list.add(<span class="keyword">new</span> Object()); <span class="comment">// Compile Error!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List&lt;? extends Fruit&gt; list</code> 表示一个List, 里面存储的类型是<code>Fruit</code>的派生类, 从list里get出来的类型至少是<code>Fruit</code>, 或者<code>Fruit</code>的派生类, 可以调用<code>Fruit</code>类的方法.<br>传递给<code>GenericTest.func()</code>的参数可以是<code>List&lt;Apple&gt;</code>, 也可以是<code>List&lt;Lemon&gt;</code>,<br>上界通配符<code>&lt;? extends Base&gt;</code>, 可以调用基类<code>Base</code>里定义的方法, 也可以get, 但是不可以set</p><h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p><code>? super Integer</code>表示Integer的超类, 只能用于<code>setter</code>.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Pair&lt;? <span class="keyword">super</span> Integer&gt;)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="限定符和泛型的一些问题…"><a href="#限定符和泛型的一些问题…" class="headerlink" title="限定符和泛型的一些问题…"></a>限定符和泛型的一些问题…</h3><p><strong>泛型中无界通配符<code>&lt;?&gt;</code> 和<code>&lt;T&gt;</code>的区别?</strong></p><ul><li><code>&lt;T&gt;</code>用在类或方法的定义里: <code>public class ArrayList&lt;T&gt;</code></li><li><code>&lt;?&gt;</code>通配符用在”调用”的地方, 通配符是拿来使用定义好的泛型的, 可以使用<code>?</code>的一般满足:<ol><li>方法定义里只使用Object的方法，跟<code>?</code>类型无关;</li><li>使用中不依赖于泛型, 最典型的是<code>Class&lt;?&gt; ...</code></li></ol></li><li>无限定通配符表示匹配任意类。<code>ArrayList&lt;?&gt;</code> 和<code>ArrayList&lt;Object&gt;</code> 看上去有点类似，但实际却不一样。<ol><li><code>ArrayList&lt;?&gt;</code>是任意 <code>ArrayList&lt;T&gt;</code> 的超类;</li><li><code>List&lt;Apple&gt;</code>是<code>List&lt;? extends Fruit&gt;</code>的子类(假设Apple继承自Fruit)</li><li><code>ArrayList&lt;Object&gt;</code> 并不是<code>ArrayList&lt;T&gt;</code> 的超类;</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-03-反射</title>
      <link href="/12.Java/Java-Tutorials.03.%E5%8F%8D%E5%B0%84/"/>
      <url>/12.Java/Java-Tutorials.03.%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="反射和RTTI"><a href="#反射和RTTI" class="headerlink" title="反射和RTTI"></a>反射和RTTI</h2><ul><li>RTTI: Run-Time Type Indentification, 运行时类型识别. 并非Java体系中的概念, 来自Thinking in C++</li><li>Reflection(反射): 允许在程序运行期间探知并分析类对象的结构.</li></ul><h2 id="Class类和Class对象"><a href="#Class类和Class对象" class="headerlink" title="Class类和Class对象"></a>Class类和Class对象</h2><ul><li>每个类实例都有一个相对应的”Class对象”, 所以类实例在进行向上转型时不会丢失原有的类型信息, 这个Class对象的类型就是”Class类”, 位于<code>java.lang.Class</code>;<ul><li><code>T.class</code>: 获取类型T的Class对象, 基本类型<code>int</code>也可以通过<code>int.class</code>获取, 虽然int等基本类型不是类, 但是也可以<code>Class cl = int.class;</code></li><li><code>t.getClass()</code>: 返回的也是Class对象, <code>getClass()</code>是Object类的方法;</li><li>可以用<code>==</code>判断class对象是否相等: <code>if(a.getClass() == A.class)</code>;</li></ul></li><li>JVM通过”Class对象”创建”类对象”, 然后通过”类对象”创建类实例:<ol><li>加载, 加载器(Class Loader)从磁盘上找到并加载.class文件, 加载.class文件可以看成是加载字节码, 并创建Class对象;</li><li>链接, 分为三个步骤: 验证字节码(语法层面), 为static分配空间但不初始化(基本类型置为0,引用置为null), 解析这个类对其他类的引用;</li><li>初始化, 首先初始化该类的超类, 然后是static成员和static块, 最后才是构造器执行(构造器也可以看成是static方法).</li></ol></li></ul><h3 id="用反射创建类"><a href="#用反射创建类" class="headerlink" title="用反射创建类"></a>用反射创建类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1:</span></span><br><span class="line">Human human = <span class="keyword">new</span> Human();</span><br><span class="line">Class c1 = human.class;</span><br><span class="line">Human human = (Human)c1.newInstance(); <span class="comment">// Class.newInstance()返回的是Object类型</span></span><br><span class="line"><span class="comment">// 方式2:</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"org.xxx.Human"</span>);</span><br><span class="line">Human human = (Human)c1.newInstance();</span><br></pre></td></tr></table></figure><h3 id="使用反射API分析类"><a href="#使用反射API分析类" class="headerlink" title="使用反射API分析类"></a>使用反射API分析类</h3><p>Class, Constructor(构造方法), Field(属性), Method(方法), Modifier(作用域)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cl = Class.forName(<span class="string">"orj.xxx.ClassName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.newINstance创建类对象, 这调用类的默认构造器</span></span><br><span class="line">ClassName obj = cl.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的public static</span></span><br><span class="line">String modify = Modifier.toString(cl.getModifiers());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造器</span></span><br><span class="line">Constructor[] contructors = cl.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method[] methods = cl.getDeclaredMethods();</span><br><span class="line"><span class="comment">// Class Method.getReturnType(); // 获得方法返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的限定</span></span><br><span class="line">String methodModiifier = Modifier.toString(method.getModifiers());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用任意方法</span></span><br><span class="line">Class clazz = ConcurrentHashMap.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取concurrentHashMap.containsKey()方法</span></span><br><span class="line"><span class="comment">// 第二个参数是可变参数Class&lt;?&gt;... parameterTypes</span></span><br><span class="line">Method method = clazz.getMethod(<span class="string">"containsKey"</span>, Object.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一参数是类实例, 如果调用static方法, 第一个参数穿null</span></span><br><span class="line"><span class="comment">// 第二个参数是可变参数Object... args</span></span><br><span class="line">method.invoke(<span class="keyword">new</span> ConcurrentHashMap&lt;String,String&gt;(), <span class="string">"ThisIsKey"</span>);</span><br></pre></td></tr></table></figure><h3 id="Class类的方法列表"><a href="#Class类的方法列表" class="headerlink" title="Class类的方法列表"></a>Class类的方法列表</h3><ul><li><code>Class&lt;?&gt; forName(String className)</code></li><li><code>Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code></li><li><code>T newInstance()</code>:</li><li><code>boolean isInstance(Object)</code> : Native方法, 注意区别<code>instanceof</code>二元操作符</li><li><code>boolean isArray()</code>: 是否是数组, Native方法</li><li><code>Class&lt;?&gt; getComponentType()</code>: 返回Class类型, 返回的Class是数组元素的类型, 示例代码: <code>String[].class.getComponentType()</code></li><li><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>: 返回指定方法名和形参的方法</li><li>以下用来获取构造器/方法/属性的列表:<ul><li><code>Constructor[] getDeclaredConstructors()</code></li><li><code>Method[] getDeclaredMethods()</code></li><li><code>Field[] getDeclaredFields()</code></li></ul></li></ul><h2 id="数组和反射"><a href="#数组和反射" class="headerlink" title="数组和反射"></a>数组和反射</h2><p><code>java.lang.reflect.Array</code>类提供了数组的反射方法, 注意区分<code>java.util.Arrays</code></p><h3 id="用反射创建数组"><a href="#用反射创建数组" class="headerlink" title="用反射创建数组"></a>用反射创建数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array.newInstance 创建数组</span></span><br><span class="line"><span class="keyword">int</span>[] array1 = (<span class="keyword">int</span>[])Array.newInstance(<span class="keyword">int</span>.class, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class.newInstance 创建数组, 这里会抛异常, 因为数组类型T[]没有默认构造函数</span></span><br><span class="line"><span class="comment"> * 这也是Array.newInstence和Class.newInstance的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class intArrClass = array1.getClass();</span><br><span class="line"><span class="keyword">int</span>[] array2 = (<span class="keyword">int</span>[])intArrClass.newInstance(); <span class="comment">// 异常 !!</span></span><br></pre></td></tr></table></figure><h3 id="用反射分析数组"><a href="#用反射分析数组" class="headerlink" title="用反射分析数组"></a>用反射分析数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class.getComponentType 获取数组元素类型</span></span><br><span class="line">Class c = array.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.getLength获取长度</span></span><br><span class="line"><span class="keyword">int</span> l = Array.getLength(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非数组的类型调用getComponentType会发生什么? 返回Null</span></span><br><span class="line">Class c2 = Object.class.getComponentType();</span><br></pre></td></tr></table></figure><h3 id="reflect-Array类的方法列表"><a href="#reflect-Array类的方法列表" class="headerlink" title="reflect.Array类的方法列表"></a>reflect.Array类的方法列表</h3><ul><li><code>Object newInstance(Class&lt;?&gt; componentType, int length)</code></li><li>reflect.Array并没有探测数组元素类型, 和数组长度的方法:(<code>Class</code>类提供了一个: <code>array.getClass().getComponentType().toString());</code></li><li><code>int Array.getLength(Object arr)</code> : 返回值是int, 数组大小最大只能是int ?</li><li>…</li></ul><h2 id="安全的类型转换"><a href="#安全的类型转换" class="headerlink" title="安全的类型转换"></a>安全的类型转换</h2><ul><li>向上转型:  <code>List&lt;Object&gt; list = new ArrayList&lt;Object&gt;()</code>;</li><li>向下转型: <code>ChildA child = (obj instanceof ChildA ? (ChildA)obj : null);</code></li></ul><blockquote><p>instanceof关键字用于判断一个引用类型变量所指向的对象是否是一个类（或接口、抽象类、父类）的实例。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-02-集合</title>
      <link href="/12.Java/Java-Tutorials.02.%E9%9B%86%E5%90%88/"/>
      <url>/12.Java/Java-Tutorials.02.%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合类继承关系"><a href="#集合类继承关系" class="headerlink" title="集合类继承关系"></a>集合类继承关系</h1><p>Java核心类库提供了两大类容器, Collection(集合)和Map, 其中Collection接口又派生出List, Queue, Set三种接口:</p><p><img src="/images/java/java-collection-hierarchy.gif" alt="Hierarchy of Collection"></p><p>容器顶层接口Collection/Map以及主要实现类 &amp; 继承关系:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.Collection [I]</span><br><span class="line">    java.util.List [I]</span><br><span class="line">        ArrayList</span><br><span class="line">        LinkedList*</span><br><span class="line">        Vector</span><br><span class="line">            Stack</span><br><span class="line">    java.util.Queue [I]</span><br><span class="line">        LinkedList*</span><br><span class="line">        PriorityQueue</span><br><span class="line">    java.util.Deque [I]</span><br><span class="line">        LinkedList</span><br><span class="line">    java.util.Set [I]</span><br><span class="line">        TreeSet*</span><br><span class="line">        HashSet*</span><br><span class="line">            LinkedHashSet</span><br><span class="line">java.util.Map [I]</span><br><span class="line">        TreeMap*</span><br><span class="line">        HashMap*</span><br><span class="line">            LinkedHashMap</span><br></pre></td></tr></table></figure><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>Collection接口方法:</p><ul><li><code>add()</code>: ArrayList和LinkedList都是append to end</li><li><code>remove(Object)</code>:  遍历整个并equals判断是否相等, 然后删除</li><li><code>contains(Object)</code>: 都是O(N)遍历</li><li><code>containsAll(Collection&lt;?&gt; c):</code> 不是测试是否包含连续的集合, 比如String.indexOf那样</li><li><code>size()</code>:</li><li><code>toArray()</code>: 生成数组</li><li><code>iterator()</code>: 返回迭代器Iterator<e>, 它具有next()方法, 用于每次返回一个元素, 直到循环器中元素穷尽:</e></li><li>从Object继承的<code>equals()</code>, <code>hashCode()</code>等…</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List接口常用方法:</p><ul><li><code>add(int index, E element)</code>:<br>Inserts the specified element at the specified position in this list (optional operation).</li><li><code>addAll(Collection&lt;? extends E&gt; c)</code>:<br>Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection’s iterator (optional operation).</li><li><code>contains(Object o)</code>:<br>Returns true if this list contains the specified element.</li><li><code>containsAll(Collection&lt;?&gt; c)</code>:<br>Returns true if this list contains all of the elements of the specified collection.</li><li><code>retainAll(Collection&lt;?&gt; c)</code>:<br>Retains only the elements in this list that are contained in the specified collection (optional operation).</li><li><code>sort(Comparator&lt;? super E&gt; c)</code>:<br>Sorts this list according to the order induced by the specified Comparator.</li><li><code>subList(int fromIndex, int toIndex)</code>:<br>Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive.</li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList内部是<code>Object[]</code>数组实现, 数组初始大小10, 每次扩展为原大小的 1.5倍, 随机访问性能好, 插入/删除代价较大, iterator是整数封装.<br>ArrayList实现了List接口:</p><ul><li><code>iterator()</code>, <code>listIterator()</code>, <code>listIterator(index)</code></li><li><code>add(E)</code>, <code>add(index,E)</code>, <code>addAll(Collection)</code></li><li><code>remove(E)</code>, <code>remove(index)</code>, <code>removeAll(Collection)</code></li><li><code>set(index,E)</code></li><li><code>sort(Comparator&lt;? super E&gt; c)</code>: 实际调用了<code>Arrays.sort()</code></li><li><code>subList(start,end)</code>: 返回的并不是ArrayList ,而是ArrayList的一个视图, 对于SubList的所有操作最终会反映到原列表上。</li><li><code>retainAll(Collection)</code> 保留ArrayList中和Collection中共有的元素(但会改变ArrayList, 没有在Collection中的元素会从ArrayList里删除)</li><li><code>Object[] toArray()</code>: 对该方法返回的数组, 进行操作（增删改查）都不会影响原集合的数据（ArrayList中elementData）</li><li>使用工具类<code>Arrays</code>的 <code>asList()</code>方法把数组转换成集合后, 不能使用该集合的<code>add</code>/<code>remove</code>/<code>clear</code>方法, 否则抛出 <code>UnsupportedOperationException</code> 异常。<blockquote><p>说明: <code>asList()</code> 的返回对象是一个 Arrays 内部类,并没有实现集合的修改方法。<code>Arrays.asList()</code> 体现的是适配器模式,只是转换接口,后台的数据仍是数组。</p></blockquote></li></ul><p>➤ 扩容:</p><ul><li><code>ArrayList()</code> 创建的数组大小是0, 第一次add()的时候会把数组扩容到<code>DEFAULT_CAPACITY</code>, 也就是10,</li><li>每次调用<code>add()</code>的时候都会检查一下添加后的数组大小是否比当前的数组大, 如果是则扩大到 1.5倍原数组的大小. <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> // 为什么是x1.5倍?<ul><li>所以ArrayList(默认构造函数)每次扩容的大小是: 0, 10, 15, 22, 33, 49 …</li><li>如果在构造ArrayList时就指定了初始大小为N, 则扩容大小是, N, 1.5N …</li></ul></li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>链表实现, 随机访问性能差, 插入/删除较快, iterator是引用封装.<br>LinkedList同时实现了List, Queue, Deque接口:</p><ul><li><code>add(E)</code>, <code>add(index,E)</code>, <code>addAll(Collection)</code></li><li><code>poll()</code>, <code>offer(E)</code> … 所有Queue接口的方法</li><li><code>addFirst(E)</code>, <code>addLast(E)</code>, <code>offerFirst(E)</code>, <code>offerLast(E)</code> … 所有Deque接口的方法</li></ul><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>类似ArrayList, Object[]数组实现, 包括的方法参考ArrayList, synchronized同步 @弃用</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><code>push()</code>入栈, <code>pop()</code>弹出栈顶部元素, <code>peek()</code>获取栈顶但不弹出顶部元素,<br>Stack实际就是对Vector包装了一层, 所以也是synchronized同步</p><h2 id="Queue-amp-Deque"><a href="#Queue-amp-Deque" class="headerlink" title="Queue &amp; Deque"></a>Queue &amp; Deque</h2><h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h3><ul><li><code>offer</code> , <code>add</code>: 添加元素到队列尾部.<br>当队列满时, offer返回false, add抛出异常.</li><li><code>poll</code> , <code>remove</code>: 返回队列头部的元素, 并移除出这个元素.<br>当队列为空时, poll返回false, remove抛出异常.</li><li><code>peek</code> , <code>element</code>: 返回队列头部的元素但不移除它.<br>当队列空时, peek返回false, element抛出异常.</li></ul><h3 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h3><ul><li><code>offerFirst</code>, <code>offerLast</code> : 添加元素到队列, 失败返false</li><li><code>addFirst</code>, <code>addLast</code> :    添加元素到队列, 失败抛异常</li><li><code>pollFirst</code>, <code>poolLast</code> :  返回并移出元素, 失败返false</li><li><code>removeFirst</code>, <code>removeLast</code> : 返回并移出元素, 失败抛异常</li><li><code>peekFirst</code>, <code>peekLast</code> :     返回但不移出, 失败返false</li><li><code>elementFirst</code>, <code>elementLast</code> : 返回但不移出, 失败抛异常</li></ul><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><ul><li><code>LinkedList</code>: 双向链表, 同时实现了Deque和Queue接口, 它是唯一一个允许放入null的Queue；</li><li><code>ArrayDeque</code>: 以循环数组实现的双向Queue，默认初始大小是16，每次扩容double。<br>普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有指向队头/队尾两个下标值.<br>从队列取出元素时，表示队头下标值++；<br>向队列插入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组0位置。<br>如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</li></ul><p><strong>带优先级的队列</strong> :</p><ul><li><p><code>PriorityQueue</code>: 用二叉堆实现的优先级队列。出队列的顺序不是按照FIFO的顺序, 而是按照插入元素来排序。插入的元素必须实现Comparable, 或者在PriorityQueue构造器传入Comparator,<br>优先级队列是无界的，但是有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。<br>优先级队列不允许 null 元素。</p><blockquote><p>二叉堆 @ref: <a href="https://blog.csdn.net/lcore/article/details/9100073" target="_blank" rel="noopener">数据结构之优先队列–二叉堆(Java实现) - LCore的专栏 - CSDN博客</a></p></blockquote></li></ul><p><strong>线程安全的阻塞/非阻塞队列</strong>, 详见<a href="#线程安全的队列">线程安全的队列</a> :</p><ul><li>阻塞：<code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>LinkedBlockingDeque</code>；</li><li>非阻塞： <code>ConcurrentLinkedQueue</code> / <code>ConcurrentLinkedDeque</code>；</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是不能包含重复的元素的集合, Set接口常用方法:</p><ul><li><code>add(E e)</code></li><li><code>addAll(Collection&lt;? extends E&gt; c)</code></li><li><code>contains(Object o)</code></li><li><code>containsAll(Collection&lt;?&gt; c)</code></li><li><code>retainAll(Collection&lt;?&gt; c)</code></li><li><code>toArray()</code></li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 是一个没有重复元素的集合. 元素并没有以某种特定顺序来存放,<br>HashSet内部实现是使用了HashMap的<code>transient HashMap&lt;E,Object&gt; map</code>, <code>add(E)</code>方法实际调用的是<code>hashMap.put(e,PRESENT)</code></p><blockquote><p>@ref: <a href="http://wangkuiwu.github.io/2012/02/16/collection-16-hashset/" target="_blank" rel="noopener">Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a></p></blockquote><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet 可以按照插入顺序对元素进行遍历.<br>LinkedHashSet 继承了 HashSet, 内部是基于 LinkedHashMap 来实现的. 可以在LinkedHashSet构造器看出来：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet是基于TreeMap实现的.<br>TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序. 这取决于使用的构造方法.<br>TreeSet的add、remove 和 contains方法的时间复杂度是O(logn).</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Item t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        return 0; 相等</span></span><br><span class="line"><span class="comment">        return 1; this大</span></span><br><span class="line"><span class="comment">        return -1; 比较的更大</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.val &gt; t.val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.val &lt; t.val) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Teacher&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;Item&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">3</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">1</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//遍历输出:</span></span><br><span class="line">        Iterator itTSet = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(itTSet.hasNext())</span><br><span class="line">            System.out.print(itTSet.next() + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ref: <a href="http://wangkuiwu.github.io/2012/02/17/collection-17-treeset/" target="_blank" rel="noopener">Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a></p></blockquote><h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator: 迭代器"></a>Iterator: 迭代器</h1><ul><li>Iterator接口的方法<ul><li><code>hasNext</code>: 返回true或false</li><li><code>next</code>: 迭代器后移一次之后, 回迭代器前面的元素</li><li><code>remove</code>: 删除上次next()返回的, 所以新创建迭代器之后, 必须先next一次才能remove. 一次remove之前必须有一次next, 不能连续调用remove;</li><li><code>add</code>: Iterator接口没有add, 但ArrayList和LinkedList的内部Itr都实现了add. 在当前迭代器之前插入. 如果创建了迭代器后立刻add, 则是插入到首位.</li></ul></li><li>ArrayList的Iterator:<ul><li>属性<code>int cursor</code>和<code>int lastRet</code>分别用来记录”下次next方法要返回的元素位置” 和”上次next方法返回的”, 初始值分别是0和-1;</li><li>创建迭代器:<ul><li>方法1: ArrayList.iterator()</li><li>方法2: ArrayList.listIterator(), 返回的迭代器有<code>add(Ele)</code>方法用于插入新元素;</li></ul></li></ul></li></ul><h2 id="How-to-iterate-collection"><a href="#How-to-iterate-collection" class="headerlink" title="How to iterate collection"></a>How to iterate collection</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; itr = collection.iterator(); i.hasNext();) &#123;</span><br><span class="line">    System.out.print(itr.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合泛型算法"><a href="#集合泛型算法" class="headerlink" title="集合泛型算法"></a>集合泛型算法</h1><p><strong>Collection &amp; Collections &amp; Arrays:</strong></p><ul><li><code>java.util.Collection&lt;E&gt;</code> 是一个泛型接口;</li><li><code>java.util.Collections</code> 是一个集合工具类, 提供一些操作集合的通用方法;</li><li><code>java.utils.Arrays</code> 是一个集合工具类, 提供操作数组的通用方法, 例如merge, sort等;</li><li><code>java.lang.reflect.Array</code> 类提供了数组的反射方法;</li></ul><p>图-Collection类 vs Collections类:<br><img src="/images/java/java_collection_vs_collections.jpeg" alt="Collection vs Collections"></p><h2 id="排序操作（主要针对List接口相关）"><a href="#排序操作（主要针对List接口相关）" class="headerlink" title="排序操作（主要针对List接口相关）"></a>排序操作（主要针对List接口相关）</h2><ul><li><code>reverse(List list)</code>：反转指定List集合中元素的顺序</li><li><code>rotate(List list, int distance)</code>：将所有元素向右移位指定长度, 如果distance等于size那么结果不变</li><li><code>shuffle(List list)</code>：对List中的元素进行随机排序（洗牌）</li><li><code>sort(List list)</code>：对List里的元素根据自然升序排序</li><li><code>sort(List list, Comparator c)</code>：自定义比较器进行排序</li><li><code>swap(List list, int i, int j)</code>：将指定List集合中i处元素和j出元素进行交换</li></ul><blockquote><p>如果要使用Collections.sort, 则要求集合内存放的类型必须实现Comparable接口</p></blockquote><h2 id="查找和替换（主要针对Collection接口相关）"><a href="#查找和替换（主要针对Collection接口相关）" class="headerlink" title="查找和替换（主要针对Collection接口相关）"></a>查找和替换（主要针对Collection接口相关）</h2><ul><li><code>binarySearch(List list, Object key)</code>：使用二分搜索法, 以获得指定对象在List中的索引, 前提是集合已经排序</li><li><code>fill(List list, Object obj)</code>：使用指定对象填充</li><li><code>frequency(Collection Object o)</code>：返回指定集合中指定对象出现的次数</li><li><code>max(Collection coll)</code>：返回最大元素</li><li><code>max(Collection coll, Comparator comp)</code>：根据自定义比较器, 返回最大元素</li><li><code>min(Collection coll)</code>：返回最小元素</li><li><code>min(Collection coll, Comparator comp)</code>：根据自定义比较器, 返回最小元素</li><li><code>replaceAll(List list, Object old, Object new)</code>：替换</li></ul><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map不是继承Collection接口, 也没有继承Iterable接口, Map接口提供的方法:</p><ul><li><code>put(k,v)</code>, <code>get(k)</code>, <code>containsKey(k)</code>, <code>containsValue(v)</code></li><li><code>remove(k)</code>, <code>replace(k,v1,v2)</code></li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>HashMap 是一个散列表, 它存储的内容是键值对(key-value)映射.</li><li>HashMap 继承于AbstractMap, 实现了 Map、Cloneable、java.io.Serializable接口.</li><li>HashMap 的实现不是同步的, 这意味着它不是线程安全的. 它的 key、value都可以为null. 此外, HashMap中的映射不是有序的.</li></ul><p>HashMap 的实例有两个参数影响其性能: “初始容量” 和 “加载因子”. 容量 是哈希表中桶的数量, 初始容量 只是哈希表在创建时的容量.<br>加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度.<br>当哈希表中的条目数超出了加载因子与当前容量的乘积时, 则要对该哈希表进行 rehash 操作（即重建内部数据结构）, 从而哈希表将具有大约两倍的桶数.</p><p>通常, 默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷.<br>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子, 以便最大限度地减少 rehash 操作次数. 如果一个Map的初始容量大于”最大条目数”乘以加载因子, 则不会发生 rehash 操作.</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>HashMap几个重要成员:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node[] table;     // 桶</span><br><span class="line">float loadFactor; // 负载因子</span><br><span class="line">int threshold;    // 等于table.length x loadFactor,  所能容纳的key-value对极限</span><br><span class="line">int modCount;     // 记录HashMap内部结构发生变化的次数</span><br><span class="line">int size;         // HashMap当前容纳键值对的数量</span><br></pre></td></tr></table></figure><p><code>put(Key, Val)</code>函数大致的实现为:</p><ul><li>计算<code>Key</code>的hashCode, 创建新的Node对象 <code>new Node(hash, key, value, null)</code> // node存储了hashCode, Key, Val</li><li>然后再计算<code>Key</code>在桶里的index （index等于<code>table.length-1 &amp; hash</code>）;</li><li>如果没碰撞(table[index] == null), 把node直接放到table数组里: <code>table[index]=node</code>；</li><li>如果碰撞了(table[index] != null), 则判断<code>table[i]</code>的首个元素的key是否hashCode相同 &amp;&amp; key equals 为真;<ul><li>是, 是则覆盖掉旧的value;</li><li>否, 插入到<code>table[i]</code>的链表里, 所以链表里保存是”Key的hashCode相同, 但Key不equal的元素”;</li></ul></li><li>如果碰撞导致链表过长(大于等于<code>TREEIFY_THRESHOLD</code>, 8), 就把这条链表转换成红黑树；</li><li><p>如果map内的元素总数超过<code>table.length x loadFactor</code>, 就要resize（扩容）</p><blockquote><p>上面提到了 <code>table[index]</code>在哈希冲突时候, 会把 table[index] 处理成链表, 当链表过长的时候, 链表的遍历性能是O(n), 很差, 所以<br>当链表长度&gt;=8时, 转成查找效率更高的红黑树;</p></blockquote></li></ul><p><code>get(k)</code>函数的实现: 这里省略了部分步骤, 只看当 <code>table[i]</code> 是链表 or 红黑树的情况:<br>遍历链表or树, 判断Key是否equal, 如果是, 返回该节点;</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>table[]数组double, 把所有元素re-hash放到扩容后的table[]中.</p><blockquote><p>在HashMap中, 哈希桶数组table的长度length大小必须为2的n次方(一定是合数), 这是一种非常规的设计, 常规的设计是把桶的大小设计为素数. 相对来说素数导致冲突的概率要小于合数,<br>HashMap采用这种非常规设计, 主要是为了在取模和扩容时做优化, 同时为了减少冲突, HashMap定位哈希桶索引位置时, 也加入了高位参与运算的过程.</p></blockquote><p>@ref: <a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap -</a></p><h3 id="解决哈希表冲突"><a href="#解决哈希表冲突" class="headerlink" title="解决哈希表冲突"></a>解决哈希表冲突</h3><ul><li>开放定址法: $ Hi = (Hash(Key) + di) % N $ 其中 i = 1,2,3…N-1(k&lt;=N-1), 根据di的取值, 开放定址法分为<ul><li>线性探测法: $ di = 1,2,3… $</li><li>平方探测法: $ di = i^2  $  @Uncertain</li><li>随机探测法: di随机数</li><li>开放定址法的优劣: 节省空间, 删除麻烦</li></ul></li><li>再哈希法:</li><li>链地址法: (HashMap使用此方法), 需要额外存储空间</li></ul><h3 id="为什么是0-75"><a href="#为什么是0-75" class="headerlink" title="为什么是0.75?"></a>为什么是0.75?</h3><p>从前面可知, 新添加进来的 Key-Value, 通过<code>key.hashCode</code>计算地址存放, 发现当前位置已经有元素, 则称为元素的碰撞, 需要重新计算或者其他方式放置该元素.<br>HashMap为了避免碰撞采取的优化策略, 简单的说, 原本可以放100个数据的空间, 当放到80个的时候, 根据经验, 接下去冲突的可能性会更加高. 因此就自动增加空间来减小冲突可能性.<br>数组大小与碰撞几率服从泊松分布, 根据经验在0.75处几率最小.</p><p><img src="/images/java/hashmap-load-factor-poisson-distribution.png" alt="HashMap_Load_Factor_Poisson_Distribution"></p><ul><li>@ref <a href="https://zhuanlan.zhihu.com/p/149687607" target="_blank" rel="noopener">面试官：为什么 HashMap 的加载因子是0.75？ - 知乎</a></li><li>@ref <a href="https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noopener">泊松分布和指数分布：10分钟教程 - 阮一峰的网络日志</a></li></ul><h3 id="Set视图"><a href="#Set视图" class="headerlink" title="Set视图"></a>Set视图</h3><p>获取HashMap的Set视图: <code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>, 返回类型是<code>EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</code>, EntrySet的方法:</p><ul><li>size(), 直接返回HashMap的size</li><li>forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action)</li></ul><blockquote><p><a href="http://wangkuiwu.github.io/2012/02/10/collection-10-hashmap/" target="_blank" rel="noopener">Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a></p></blockquote><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul><li>LinkedHashMap 继承自 HashMap, 它能保证遍历元素时, 输出的顺序和输入时的顺序相同.</li><li>LinkedHashMap 不仅实现HashMap的开散列哈希表（数组+链表）, 还维护着一个运行于所有键值对的双向链接列表. 此列表定义了迭代的顺序, 该迭代顺序包括插入顺序和访问顺序两种, 默认是插入顺序；可以通过设置 accessOrder为 true, 把迭代顺序设置为访问顺序.</li><li>LinkedHashMap 重写了父类的 HashMap 的get方法: 在调用父类的 getEntry() 方法取得查找的元素之后, 再判断排序模式 accessOrder是否为true, 如果是, 那么就把最新访问的元素添加到双向链表的表头, 并从原来的位置删除（可以用来实现LRU）. 因为链表的插入和删除操作都是常量级的时间复杂度, 所以不会带来性能损失.</li><li>LinkedHashMap 在保留 HashMap 的查找效率的同时, 保持元素输出的顺序和输入时的顺序相同, 并提供了元素的LRU访问.</li></ul><blockquote><p>参考: <a href="https://blog.csdn.net/u014313009/article/details/24520851" target="_blank" rel="noopener">LinkedHashMap内部实现</a> @ref</p></blockquote><h3 id="LinkedHashMap-amp-HashMap代码比较"><a href="#LinkedHashMap-amp-HashMap代码比较" class="headerlink" title="LinkedHashMap &amp; HashMap代码比较"></a>LinkedHashMap &amp; HashMap代码比较</h3><ul><li>LinkedHashMap 继承自 HashMap;</li><li>HashMap的桶数组 <code>HashMap.Node&lt;K,V&gt; table[]</code>, HashMap.Node&lt;K,V&gt;继承自Map.Entry&lt;K,V&gt;;</li><li>LinkedHashMap的<code>Entry</code>继承自<code>HashMap.Node&lt;K,V&gt;</code>, （与<code>HashMap.Node</code>相比）增加了before/after两个引用做双向链表</li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap 是一个有序的key-value集合, TreeMap 根据Key的自然顺序进行排序, 或者根据TreeMap构造器提供的 Comparator进行排序.<br>内部是基于红黑树（Red-Black tree）的 NavigableMap实现.<br>TreeMap的基本操作 <code>containsKey</code>、<code>get</code>、<code>put</code> 和 <code>remove</code> 的时间复杂度是 <strong>log(n)</strong>.</p><ul><li>TreeMap 是一个有序的key-value集合, 它是通过红黑树实现的.</li><li>TreeMap 继承于AbstractMap, 所以它是一个Map, 即一个key-value集合.</li><li>TreeMap 实现了NavigableMap接口, <code>descendingKeySet()</code>方法返回一个与原顺序相反的值的一个Set集合, 其实是指向同一块内存区域, 在该视图上的任何修改都会影响到原始的数据.</li><li>TreeMap 实现了Cloneable接口, 意味着它能被克隆.</li><li>TreeMap 实现了java.io.Serializable接口, 意味着它支持序列化.</li></ul><blockquote><p><a href="http://wangkuiwu.github.io/2012/02/12/collection-12-treemap/" target="_blank" rel="noopener">Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a></p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>TreeMap的特点: 1 插入的元素可以按Key的自然顺序遍历, 2 像HashMap一样近似O(1)的查找复杂度;<br>二叉堆满足1, 但是不满足2,<br>红黑树的中序遍历可以满足1, 同时红黑树的查找复杂度(参考BST)是<code>O(logN)</code></p><ul><li><code>put</code>: 如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。</li><li><code>get</code>: log(n)</li><li>顺序遍历: 中序遍历</li></ul><h3 id="为什么采用红黑树"><a href="#为什么采用红黑树" class="headerlink" title="为什么采用红黑树"></a>为什么采用红黑树</h3><p>排序二叉树虽然可以快速检索, 但在最坏的情况下: 如果插入的节点集本身就是有序的（比如由小到大排列, 或是由大到小排列）,<br>那么最后得到的排序二叉树将变成链表: 所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）.<br>在这种情况下, 排序二叉树就变成了普通链表, 其检索效率就会很差.<br>为了改变排序二叉树存在的不足, Rudolf Bayer 与 1972 年发明了另一种改进后的排序二叉树: 红黑树, 他将这种排序二叉树称为”对称二叉 B 树”, 而红黑树这个名字则由 Leo J. Guibas 和 Robert Sedgewick 于 1978 年首次提出.</p><blockquote><p>参考: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">教你透彻了解红黑树</a> @ref</p></blockquote><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul><li>HashTable的方法都是采用了<code>synchronized</code>同步.</li><li>高并发场景下不推荐使用HashTable, 应该使用<code>java.util.concurrent.ConcurrentHashMap</code>替代.</li></ul><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>这种Map通常用在数据缓存中.它将键存储在WeakReference中, 就是说, 如果没有强引用指向键对象的话, 这些键就可以被垃圾回收线程回收</p><h2 id="关于Map-Entry"><a href="#关于Map-Entry" class="headerlink" title="关于Map.Entry"></a>关于Map.Entry</h2><p>HashMap有一个该类型的属性: <code>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</code>,<br>该属性在调用<code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>方法内被初始化:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EntrySet</code>类是HashMap的一个static内部类, 定义了<code>forEach</code>方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="How-to-iterate-map"><a href="#How-to-iterate-map" class="headerlink" title="How to iterate map"></a>How to iterate map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// entry.getKey()</span></span><br><span class="line">    <span class="comment">// entry.getValue()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">//map.get(key);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">Iterator it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)it.next();</span><br><span class="line">    <span class="comment">// entry.getKey(), entry.getValue()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Tutorials-01-基础</title>
      <link href="/12.Java/Java-Tutorials.01.%E5%9F%BA%E7%A1%80/"/>
      <url>/12.Java/Java-Tutorials.01.%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),<br>Java没有bit类型, 但可以使用<code>BitSet</code>类代替.</p><ul><li>byte: 1字节, 范围-128~127</li><li>short: 2字节, 范围-32768~32767, 为什么最小是-32768 ?</li><li>int/long: <code>100L</code>表示long类型, 0x/0/0b前缀分别表示16/8/2进制<ul><li>如果<code>long l = 3600 * 24 * 30 * 1000</code>，1000后面不加L，右边会按int计算并产生溢出</li></ul></li><li>float/double: 3.14F表示float类型, 3.14和3.14D都表示double</li><li>char: 单引号, ‘\u2122’或’A’</li></ul><h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><p>浮点数(基本类型)之间是否相等不能用==来比较，浮点数(包装数据类型)不能用 equals 来判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例1:</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.0F</span> - <span class="number">0.9F</span>; <span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">  <span class="comment">// 预期进入此代码块，执行其它业务逻辑 // 但事实上 a==b 的结果为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例2:</span></span><br><span class="line">Float x = Float.valueOf(a);</span><br><span class="line">Float y = Float.valueOf(b);</span><br><span class="line"><span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line">  <span class="comment">// 预期进入此代码块，执行其它业务逻辑</span></span><br><span class="line">  <span class="comment">// 但事实上 equals 的结果为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例:</span></span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>; <span class="keyword">float</span> diff = <span class="number">1e-6F</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line">  System.out.println(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitSet bits = <span class="keyword">new</span> BitSet(<span class="number">16</span>); <span class="comment">// 初始大小对性能的影响</span></span><br><span class="line">bits.set(index, <span class="keyword">true</span>);</span><br><span class="line">bits.get(index)</span><br></pre></td></tr></table></figure><h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><h3 id="包装器API"><a href="#包装器API" class="headerlink" title="包装器API"></a>包装器API</h3><p>基本类型对应包装器为 Character, Byte, Short, Integer, Long, Float, Double, 包装器与基本类型互转:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer ii = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i = ii.intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Integer 可以直接与int比较 */</span></span><br><span class="line"><span class="keyword">if</span>(ii == i) &#123;</span><br><span class="line">  <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String &lt;-&gt; int</span></span><br><span class="line">String s = String.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i2 = Integer.parseInt(<span class="string">"1011"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坑</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> Long(<span class="number">1</span>).equals(<span class="number">1</span>)) &#123;</span><br><span class="line">  printf(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面并没有打印出True, 因为`equals(obj)`方法自动把int的1装箱为"Integer"类型,</span></span><br><span class="line"><span class="comment">在equals里第一步check类型就返回false了:(</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Double类的一些方法:</p><ul><li><code>Double.compareTo(Double)</code> : 大于小于直接比较, =的判断是把double转成一个LongBit? Native方法, 需要看一下浮点数的内存</li><li><code>isNaN()</code> 返回true表示不是正常数字, 比如除以0, 负数的平方根. 代码里如何得到一个NaN?</li></ul><h3 id="装箱拆箱的实现"><a href="#装箱拆箱的实现" class="headerlink" title="装箱拆箱的实现"></a>装箱拆箱的实现</h3><p>▶ 何时发生装箱/拆箱:</p><ul><li>什么是自动装箱: int → Integer, 实际调用 <code>Integer.valueOf(int)</code></li><li>什么时候发生自动装箱:<ul><li>创建对象: <code>Integer i = 3</code></li><li>方法参数传递: <code>void method(Integer i)</code></li></ul></li><li>什么是自动拆箱: Integer → int, 实际调用 <code>integer.intValue()</code></li><li>什么时候发生自动拆箱:<ul><li>加法: <code>integer1 + integer2</code>, 先拆箱转换为int …</li><li>需要注意的是<code>if (integer3 == integer1 + integer2)</code>, 首先右边1和2拆箱为int, 变成<code>if (integer3 == int)</code>, 这时不是发生(int→integer)装箱, 而是继续拆箱, 最终比较的是<code>if (int == int)</code></li></ul></li></ul><p>▶ Integer/Long自动装箱 <code>valueOf(x)</code>的实现</p><ul><li>Integer/Long的<code>valueOf(i)</code>使用了享元模式, 在<code>static</code>代码块中预先创建了范围<code>-128~127</code>的对象, 缓存在Cache里;</li><li>当调用<code>valueOf(i)</code>的时候，先判断i的范围是否是-128~127，如果是则直接从cache里返回对象，减少类的创建;</li><li>下面创建Integer的效率, 前者可能更高: <code>Integer i = 3</code> , <code>Integer i = new Integer(3)</code>; 为什么?</li><li>Float/Double的<code>valueOf(f)</code>没有使用享元模式;</li></ul><p>▶ 代码example</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long l1 = Long.valueOf(<span class="number">128</span>);</span><br><span class="line">Long l2 = Long.valueOf(<span class="number">128</span>);</span><br><span class="line">System.out.println(<span class="string">"l1==l2 "</span> + (l1==l2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Long l3 = Long.valueOf(<span class="number">127</span>);</span><br><span class="line">Long l4 = Long.valueOf(<span class="number">127</span>);</span><br><span class="line">System.out.println(<span class="string">"l3==l4 "</span> + (l3==l4));</span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1==i2 "</span> + (i1==i2));</span><br><span class="line">System.out.println(<span class="string">"i1==i2+i3 "</span> + (i1==i2+i3));</span><br></pre></td></tr></table></figure><p>输出: false, true, false, true</p><blockquote><p>@ref <a href="https://www.jianshu.com/p/0ce2279c5691" target="_blank" rel="noopener">Java 自动装箱与拆箱的实现原理 - 简书</a></p></blockquote><h3 id="慎用-Long-equals"><a href="#慎用-Long-equals" class="headerlink" title="慎用 Long.equals()"></a>慎用 Long.equals()</h3><p>以下代码会输出false:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Long(<span class="number">1</span>).equals(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>原因是，<code>Long.equals(Object)</code>，进入equals是会对整形参数1进行一次装箱，i被包装成<code>Integer(1)</code>，<br>和其他类的equals行为一样，<code>Long.equals(Integer(1))</code>会先判断输入参数的类型<code>if (obj instanceof Long)</code>，这里就返回false了。</p><p>所以用Long的正确条例是，<code>Long</code>的方法传参数都用明确的long型：<code>new Long(1L)</code>, <code>longObj.equals(1L)</code>。</p><h3 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger, BigDecimal"></a>BigInteger, BigDecimal</h3><p>Java还提供了两个用于大数运算的类: <code>BigInteger</code>(任意大整数)和<code>BigDecimal</code>(任意大小的带小数点的数字). 常用方法: <code>add()</code>, <code>subtract()</code>, <code>multiply()</code>, <code>divide()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger big1 = <span class="keyword">new</span> BigInteger(<span class="string">"99"</span>);</span><br><span class="line">BigInteger big2 = BigInteger.valueOf(<span class="number">99</span>);</span><br><span class="line">BigInteger big3 = big1.add(big2).multiply(big2);</span><br></pre></td></tr></table></figure><blockquote><p>BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。 说明:equals()方法会比较值和精度(1.0 与 1.00 返回结果为 false)，而 compareTo()则会忽略精度。</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>Java中数组本质上也是对象, 拥有所有Object的方法, 不同于int/double等基本类型.<ul><li>Java对象在内存里前几个字节是”对象头”, 非数组对象的的对象头占用2字节, 数组对象的对象头占用3字节, 多的1字节用来存储对象长度</li><li>数组可以通过属性<code>length</code>获取长度, 遍历数组: <code>for(int i = 0; i &lt; array.length; i++)</code></li></ul></li><li>数组创建后会记住元素类型和大小, 所以:<ul><li><code>A[]</code>类型的数组可以强转换为<code>Object[]</code>, 但不能反过来执行;</li><li>用<code>new A[1]</code>方式创建的数组, 只能向内存储<code>A</code>类型或者<code>A的派生类</code>的对象, 试图存入其他类型对象会抛ArrayStoreException;</li><li>数组创建后不再能改变长度;</li></ul></li></ul><p>▶ 数组如果作为形参 or 返回值, 可以使用<code>Object</code>, 而不是用<code>Object[]</code> :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射方式创建新数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">copyOfGenericArray</span><span class="params">(Object src, <span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> newLength&gt;<span class="number">0</span> : <span class="string">"assert length failed"</span>;</span><br><span class="line">  <span class="keyword">if</span>(!src.getClass().isArray()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Class cl = src.getClass().getComponentType();</span><br><span class="line">  Object newArray = Array.newInstance(cl, newLength);</span><br><span class="line">  <span class="keyword">int</span> length = Array.getLength(src);</span><br><span class="line">  System.arraycopy(src, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>▶ 数组与list互转:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list -&gt; array</span></span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">Object[] objArray = list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array -&gt; list</span></span><br><span class="line">List&lt;Object&gt; newList = Arrays.asList(objArray);</span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Java核心类库有两个Arrays类:</p><ul><li><code>java.lang.reflect.Array</code>: 提供了数组的反射相关方法;</li><li><code>java.utils.Arrays</code>: 类似Collections类, 提供了merge/sort等方法</li></ul><p>示例代码: 用反射创建数组, 拷贝数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.reflect.Array创建数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = (<span class="keyword">int</span>[])Array.newInstance(<span class="keyword">int</span>.class,length)  <span class="comment">// &lt;Core Java&gt; P207</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝数组</span></span><br><span class="line">System.arraycopy(src[], srcPos, dest[], destPos, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用java.utils.Arrays拷贝:</span></span><br><span class="line">Object[] newArr = Arrays.copyOf(Obj[], length)</span><br><span class="line"><span class="comment">// Arrays工具类还提供了sort, binarySearch, asList()</span></span><br><span class="line"></span><br><span class="line">Entry[] entries = <span class="keyword">new</span> Entry[<span class="number">1</span>];</span><br><span class="line">Object[] objs = (Object[])entries; <span class="comment">// 向上转型数组ok</span></span><br></pre></td></tr></table></figure><h4 id="java-util-Arrays"><a href="#java-util-Arrays" class="headerlink" title="java.util.Arrays"></a>java.util.Arrays</h4><p><code>java.util.Arrays</code> 包含了许多处理数组的实用方法：</p><ul><li><p><code>asList</code>: 将一个数组(变长参数的语法糖实现就是数组)转变成一个List（确切的来说是 <code>ArrayList</code>），注意这个List是定长的，企图添加或者删除数据都会报错（<code>java.lang.UnsupportedOperationException</code>）.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 下面这种用法是错误的:</span></span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br></pre></td></tr></table></figure></li><li><p><code>sort</code>: 对数组进行排序。适合byte,char,double,float,int,long,short等基本类型，还有Object类型（实现了Comparable接口），如果提供了比较器Comparator也可以适用于泛型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span>; <span class="comment">// 需要类实现Comparable接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>; <span class="comment">// 带比较器</span></span><br></pre></td></tr></table></figure></li><li><p><code>binarySearch</code>: 通过二分查找法对已排序（譬如经过Arrays.sort排序，且按照升序进行排序。如果数组没有经过排序，那么检索结果未知）的数组进行查找。适合byte,char,double,float,int,long,short等基本类型，还有Object类型和泛型</p></li><li><code>copyOf</code>: 数组拷贝，并返回新数组，底层采用System.arrayCopy（native方法）实现。</li><li><code>copyOfRange</code>: 数组拷贝，指定一定的范围，<code>String str2[] = Arrays.copyOfRange(arr,1,3)</code>;</li><li><code>equals</code>和<code>deepEquals</code>:<ul><li>equals：判断两个数组的每一个对应的元素是否equals</li><li>deepEquals：主要针对一个数组中的元素还是数组的情况</li></ul></li><li><code>toString</code>和<code>deepToString</code> : 参考<code>equals</code>和<code>deepEquals</code></li><li><code>hashCode</code>和<code>deepHashCode</code> :<ul><li>hashCode：计算一个数组的hashCode. 每个元素的<code>element.hashCode()</code>都要参与计算</li></ul></li><li><code>fill</code>: 给数组赋值。填充数组。<code>Arrays.fill(intArr, 1);</code></li></ul><h4 id="Java-lang-reflect-Array"><a href="#Java-lang-reflect-Array" class="headerlink" title="Java.lang.reflect.Array"></a>Java.lang.reflect.Array</h4><p>施工中</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>Java在SE5中才添加了emum特性, 在定义一个enum时会自动创建<code>toString()</code>和<code>value()</code>方法(均是static方法), enum还支持类似Objec的私有属性,和构造;<ul><li>enum 类型不支持<code>public</code>和<code>protected</code>修饰符的构造方法, 因此构造函数一定要是<code>private</code>或 <code>friendly</code>的. 也正因为如此, 所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的.</li><li>枚举可以出现在switch语句中, 若要判断两个枚举类型常量的值是否相等, 使用<code>==</code>, 或<code>equals()</code>都可以. 前者更好因为可以可以判断null的情况</li><li>比较两个枚举类型常量的值的大小要使用<code>compareTo()</code>方法.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个基本的枚举:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> COLOR &#123;</span><br><span class="line">  RED(<span class="number">1</span>),</span><br><span class="line">  GREEN(<span class="number">2</span>) <span class="comment">// GREEN后面没有分号哟...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个带属性和构造器的枚举:</span></span><br><span class="line"><span class="keyword">public</span> emum ApiUrl &#123;</span><br><span class="line">    REGIST(<span class="string">"http://changyan.com/api/open/reg"</span>,<span class="number">1</span>),</span><br><span class="line">    LOGIN(<span class="string">"http://changyan.com/api/open/validate"</span>,<span class="number">2</span>),</span><br><span class="line">    SSO(<span class="string">"http://changyan.com/api/open/set-cookie"</span>,<span class="number">3</span>); <span class="comment">// 分号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 私有的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ApiUrl</span><span class="params">(String url, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">// 私有的构造器!!!</span></span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getUrl</span><span class="params">()</span> </span>&#123; ...&#125; <span class="comment">// Getter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index + <span class="string">"_"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ApiUrl apiUrl = ApiUrl.REGIST; <span class="comment">// 初始化枚举变量</span></span><br><span class="line">System.out.print(ApiUrl.REGIST.toString());</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul><li>赋值: 类实例的赋值操作<code>a=b</code>实际是把b这个”对象引用”指向了a的指向的对象, 如果b原来的对象的引用数为0, 在一定条件下会被JVM销毁.</li><li>对于基本数据类型, <code>==</code>判断的是值, 而不是”是否指向同一个引用”;</li><li>用<code>==</code>比较Object, 如果a和b是否指向的是同一块内存则为true</li><li>判断两个字符串的内容是否相同不能用<code>if(str1==str2)</code>, 要用<code>str1.equals(str2)</code>方法.</li><li>大部分jdk中的类实现了<code>Object.equals(Object)</code>这个方法(判断两值是否相等), 但是对于某些自定义的类要留意其<code>equals</code>方法, 因为<code>Object.equals</code>默认行为是比较引用的<code>this==obj</code>;</li></ul><blockquote><p>hashCode和equals更多参考: (五)面向对象</p></blockquote><h2 id="左右结合"><a href="#左右结合" class="headerlink" title="左右结合"></a>左右结合</h2><p>Java中赋值<code>=</code>, 单目运算<code>++</code>等, 条件运算符<code>?:</code>是右结合, 其他都是左结合,<br>比如<code>x=y=z</code>, 相当于<code>x=(y=z)</code></p><h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><ul><li>左移&lt;&lt; : 丢弃最高位(符号位同样丢弃), 0补最低位. 当byte和short左移时, 自动升级为int型.<ul><li>数学意义: 左移n位相等于乘以2^n</li></ul></li><li>右移&gt;&gt; : 高位补充符号位, 正数右移补充0, 负数右移补充1, 当byte和short右移时, 自动升级为int型.<ul><li>数学意义:  右移n位相当于除以2^n</li></ul></li><li>无符号右移&gt;&gt;&gt; : 无论正负, 高位补充0<ul><li>无符号右移只是对32位和64位的值有意义</li></ul></li></ul><p>关于补码/反码参考脚注<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><h2 id="java-lang-Math"><a href="#java-lang-Math" class="headerlink" title="java.lang.Math"></a>java.lang.Math</h2><ul><li>abs: <code>return v&gt;0?v:-v;</code></li><li>sqrt: native</li><li>pow: native</li></ul><h1 id="控制流程和语句"><a href="#控制流程和语句" class="headerlink" title="控制流程和语句"></a>控制流程和语句</h1><ul><li>Java的<code>if</code>, <code>for</code>, <code>while</code>, <code>do-while</code>, <code>if...else if</code>和C++完全一样, 此外Java还多了foreach:  <code>for(int i : integerArray) {...}</code></li><li><code>switch</code>语句支持String类型和<code>enum</code>类型</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li>Java的参数传递为<code>值传递</code>. 也就是说, 当我们传递一个参数时, 方法内将获得该参数的一个拷贝.</li><li>基本类型(int/char等)的参数传递, 方法内获得是一个拷贝. Java方法对变量的修改不会影响到原变量.</li><li>对象类型作为形参传递, 函数内获得一个引用的拷贝.</li><li><a href="http://segmentfault.com/q/1010000000332606" target="_blank" rel="noopener">Java不能实现C/C++中的swap功能</a></li></ul><blockquote><p>对象类型都是通过引用拷贝(跟C++中引用不同)传参, 通过该引用能够更改其指向的对象内部值, 如果只是更改该引用值, 仅对函数内部可见, 函数外部的实参依然没有改变;</p></blockquote><h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><p>Java对普通类型的变量 or 引用类型的变量, 都无法简单通过<code>=</code>赋值实现 Swap,</p><p>折中的做法有: 1)使用数组, 2)作为成员变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void swap1(int[] data, int a, int b) &#123;</span><br><span class="line">      int t = data[a];</span><br><span class="line">      data[a] = data[b];</span><br><span class="line">      data[b] = t;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void swap2(int a, int b) &#123;</span><br><span class="line">       this.a = b;</span><br><span class="line">       this.b = a;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h2><p>Java也支持变参函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//第一种形式</span></span><br><span class="line">    foreach(String arg : args) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para, String... args)</span> </span>&#123; <span class="comment">//第二种形式</span></span><br><span class="line">    <span class="comment">// 遍历方法同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="Object的一些默认方法"><a href="#Object的一些默认方法" class="headerlink" title="Object的一些默认方法"></a>Object的一些默认方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">int</span> hash = obj.hashCode(); <span class="comment">// navive方法, 返回内存地址, 但String.hashCode不是这样</span></span><br><span class="line"><span class="keyword">boolean</span> b = obj.equals(obj); <span class="comment">// return obj==this;</span></span><br><span class="line">Class cl = obj.getClass(); <span class="comment">// navive方法</span></span><br><span class="line">Class cl2 = Object.class; <span class="comment">// 通过 类名.class获取class实例</span></span><br><span class="line">Object newObject = obj.clone(); <span class="comment">// error ! clone是protected native方法</span></span><br></pre></td></tr></table></figure><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>Object的equals方法默认是比较引用地址. equals方法的特点:</p><ul><li>自反性: a.eq(a)==true</li><li>对称性: if a.eq(b)==true, then b.eq(a)==true</li><li>传递性: a-&gt;b, b-&gt;c, a-&gt;c</li></ul><p>所以伪码如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if super.equals==false false</span><br><span class="line">if this==obj true</span><br><span class="line">if obj==null false</span><br><span class="line">if class!=obj.class false</span><br><span class="line">if [!obj instanceof this] false</span><br><span class="line">其他的属性比较...</span><br></pre></td></tr></table></figure><h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p><code>hashCode()</code>返回int类型, 返回值可以看成是对象的”消息摘要”</p><p>默认的hasCode()返回的并不是内存地址, hasCode()内部调用了native方法, 不同的JVM实现可能不一样, OpenJDK的实现如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mark = monitor-&gt;header();</span><br><span class="line"></span><br><span class="line">hash = mark-&gt;hash();</span><br><span class="line">if (hash == 0) &#123;</span><br><span class="line">  hash = get_next_hash(Self, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第一次hashCode, 则通过get_next_hash 重新获取一个随机值, 并保存在对象头</p><p>@ref: <a href="https://cloud.tencent.com/developer/article/1622192" target="_blank" rel="noopener">java默认的hashcode方法到底得到的是什么？ - 云+社区 - 腾讯云</a></p><h3 id="equals-vs-hashCode"><a href="#equals-vs-hashCode" class="headerlink" title="equals vs hashCode"></a>equals vs hashCode</h3><ul><li>如果重新了equals方法, 就必须重写hashCode方法, 以便可以将对象插入到HashMap中(摘自Java核心技术卷1, 为什么?)</li><li>如果两个对象equals, 那么hashCode一定相同, 如果两个对象hashCode相同, 但不一定equals, 为什么?</li><li>equals要依次比较每个属性的值, hashCode是对”需要比较的属性”求散列, 所以如果哈希方法不够好出现碰撞, hashCode相同但是每个属性不equals</li><li>因为HashMap插入时用Key的hashCode作为数组的下标, 所以hashCode返回必须是正int</li><li>好的hashCode方法应该对”需要比较的每个属性”充分散列</li></ul><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>Object.clone默认是浅拷贝;</p><h4 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h4><p><code>Cloneable</code>和<code>Serializable</code> 一样都是标记型接口，它们内部都没有方法和属性，<code>implements Cloneable</code>表示该对象能被克隆，能使用<code>Object.clone()</code>方法。<br>如果没有<code>implements Cloneable</code>的类调用<code>Object.clone()</code>方法就会抛出 <strong>CloneNotSupportedException</strong></p><p>Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example类的 <code>clone()</code>默认调用了 <code>Object.clone()</code>, 这是一个Native方法, 默认是 <strong>浅克隆（shallow clone）</strong></p><blockquote><p>浅拷贝（浅克隆）复制出来的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。<br>深拷贝（深克隆）复制出来的所有变量都含有与原来的对象相同的值，那些引用其他对象的变量将指向复制出来的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p></blockquote><p>如何实现 deep clone:<br>clone方法里要对每个引用类型的成员都调用一次 <code>clone()</code>, 例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Wheel wheel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Car car = (Car)<span class="keyword">super</span>.clone();</span><br><span class="line">        car.wheel = (Wheel)<span class="keyword">this</span>.wheel.clone();</span><br><span class="line">        <span class="keyword">return</span> car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Serializable实现深克隆（deep clone）:</strong></p><p>略</p><h2 id="构造和销毁"><a href="#构造和销毁" class="headerlink" title="构造和销毁"></a>构造和销毁</h2><p>构造器(constructor):<br>Java的构造器实际上是一个static函数, 因为在没有实例化之前就可以调用构造, 但是一般来说, static方法里不能使用<code>this</code>关键字, 因为<code>this</code>的含义是指向类实例本身的一个引用(C++的this是指向类实例自身的指针), 但是构造器这个特殊的static方法里却可以使用<code>this</code>关键字.</p><h3 id="继承和构造顺序"><a href="#继承和构造顺序" class="headerlink" title="继承和构造顺序"></a>继承和构造顺序</h3><p>派生类被实例化时, 总是先调用<code>super()</code>, 即基类的默认构造方法. 在派生类的构造函数中, 也可以使用<code>super(args...)</code>调用指定的基类构造方法.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"parent"</span>); <span class="comment">// 通过super调用基类的"非默认构造器"</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"child"</span>); <span class="comment">// 通过this调用Override的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>如果一个类没有定义<em>任何</em>构造方法, 那么编译器会为这个类自动生成一个不带参数的<code>默认构造方法</code>,</p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ul><li>Java允许在类中定义一个<code>finalize()</code>方法, 这个方法里可以做什么? JVM何时调用这个方法?</li><li>Efftive Java中提到<code>finalize()</code>方法可用作”守卫方法”, 比如socket在这里做最后的关闭检查:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">protect <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  close();</span><br><span class="line">  <span class="keyword">super</span>.finalize(); <span class="comment">// 不要忘记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ul><li>在调用Java的方法时, 会隐式的将”指向自身的引用”作为方法的第一个参数<code>function(this, param)</code>, C++的this是”指向类实例自身”的指针;</li><li>static方法的第一个参数则是null.</li></ul><h2 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h2><ul><li>没有任何权限修饰, 默认是包内可见, friendly的;</li><li>访问权限 public &gt; protected &gt; friendly &gt; private<ul><li>protected: 包可见, 子类可见;</li><li>friendly: 包可见, 子类不可见 (没有这个关键字, 什么都不加默认是friendly);</li><li>private: 只对该类型可见;</li></ul></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul><li>Java不支持多重继承class, 但支持多重继承interface. 思考一个问题:</li></ul><blockquote><p>“有两个类B1和B2继承自A. 假设B1和B2都继承了A的方法并各自进行了覆盖, 编写了自己的实现. 假设C通过多重继承继承了B1和B2, 那么C应该同时继承B1和B2的重载方法, 那么它应该继承哪个的呢？是B1的还是B2的呢？”</p></blockquote><p>C++中经常会掉入这个陷阱, 虽然它也提出了替代的方法来解决这个问题. 我们在Java中就不会出现这个问题. 就算两个接口拥有同样的方法, 实现的类只会有一个方法, 这个方法由实现的类编写. 动态的加载类会让多重继承的实现变得困难.</p><blockquote><p>因为在C++没有Interface, 在C++中使用”虚拟继承”解决上面的问题:</p><ol><li>B1和B2去虚拟继承A: <code>class B1 : public virtual A</code> ,<code>class B2 : public virtual A</code></li><li>C多重继承B1和B2: <code>class C : public B1, public B2</code> ;</li></ol></blockquote><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ul><li>含有抽象方法(abstract function)的类是抽象类(abstract class).</li><li>任何子类都必须实现抽象类的抽象方法, 或者自身也声明为抽象类;</li></ul><p>抽象类<code>public abstract class A</code>, 和接口的异同:</p><ul><li>抽象类和接口都能有自己的属性成员, 不同的是接口中的成员属性都是static和final的, 因此比较合适的做法是在interface里放置一些常量.</li><li>抽象类里还可以定义自己的方法实现, 并能被派生类继承, 但接口不能含有任何方法实现.</li></ul><h3 id="Java和C-实现多态的对比"><a href="#Java和C-实现多态的对比" class="headerlink" title="Java和C++实现多态的对比"></a>Java和C++实现多态的对比</h3><table><thead><tr><th>C++</th><th>Java</th></tr></thead><tbody><tr><td>virtual func</td><td>普通方法</td></tr><tr><td>virtual f()=0</td><td>abstract func()</td></tr><tr><td>abstract class</td><td>interface</td></tr></tbody></table><h2 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态(polymorphism)"></a>多态(polymorphism)</h2><p>多态的含义就是一个方法多种实现, 分静态和动态, 在同一个类中实现多态是通过<code>函数重载</code> -Overload, 在继承中实现多态是通过<code>运行时绑定</code>.</p><ul><li>在Java的继承中, 除了static和final方法(private也是final的)之外, 其他的方法都是<code>运行时绑定</code>的,</li><li>类的属性成员并不在多态的讨论范围内, “多态”仅仅指方法的多态. 比如基类和派生类都有field属性, 那么在派生类实例中, 将包含两个field, 通过<code>基类.field</code>也只能访问基类的field, 因为 <strong>属性没有多态</strong>.</li><li>类的构造方法不具备多态性, 因为类的构造器默认是static属性的, 对比C++的构造也不具备多态性(C++通过虚函数实现), 原因是构造期间尚未生成虚函数表.</li><li>在派生类中, 覆写(Override)基类的私有方法不会编译报错, 但不会照期望的执行, 结论就是: 只有非private方法才可以被派生类覆写(Override).</li><li>Override和Overload都可以看成是多态性的表现, 前者是基类和派生类之间的多态, 后者是一个类内部的多态表现. // 疑似C++理论</li></ul><h2 id="final-static-关键字"><a href="#final-static-关键字" class="headerlink" title="final, static 关键字"></a>final, static 关键字</h2><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>Java中的<code>final</code>关键字和C++中的<code>const</code>关键字一样, 都表示不可改变.</p><p>final关键字可以修饰:</p><ul><li>成员: 表示常量, 也可以在final成员定义时不给初值, 在构造方法里赋初值;</li><li>形参: 表示这个参数引用指向的内容不能被改变.</li><li>方法: 表示这个方法不能在派生类中被”覆写”(Override), 但可以被继承使用. 类中所有private方法都被隐式的声明为final的.</li><li>类: 表示这个类不能被继承, final类中所有的方法也被隐式声明为final的, 设计类时候, 如果这个类不需要有子类, 类的实现细节不允许改变, 并且确信这个类不会载被扩展, 那么就设计为final类. final和abstract这两个关键字是反相关的, final类就不可能是abstract的</li><li>C++的const类成员和Java的final类属性: 在C/Java的类中, 都支持<code>public final int ee = 1</code> 这样的声明+赋初值的方式, 也支持先声明再初值的方式(这种情况下, 都需要在构造函数里初值). 这样的设计的好处是可以做到一个类中final域在不同的对象有不同的值.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List Loans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"home loan"</span>);  <span class="comment">//valid</span></span><br><span class="line">list.add(<span class="string">"personal loan"</span>); <span class="comment">//valid</span></span><br><span class="line">loans = <span class="keyword">new</span> Vector();  <span class="comment">//not valid</span></span><br></pre></td></tr></table></figure><p>下面总结了一些使用final关键字的好处:</p><ul><li>final关键字提高了性能, JVM和Java应用都会缓存final变量.</li><li>final变量可以安全的在多线程环境下进行共享, 而不需要额外的同步开销.</li><li>使用final关键字, JVM会对方法/变量及类进行优化.</li></ul><blockquote><p>摘自《Java编程思想》第四版第143页：<br>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“</p></blockquote><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>使用static块初始化final的Map:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; myMap;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; aMap = ....;</span><br><span class="line">        aMap.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">        aMap.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        myMap = Collections.unmodifiableMap(aMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回顾C-的const"><a href="#回顾C-的const" class="headerlink" title="回顾C++的const"></a>回顾C++的const</h3><p>可以修饰函数(修饰返回值or修饰形参or修饰类的函数成员),</p><blockquote><p>const int<em> ptr; // ptr指向的内容无法修改<br>int</em> const ptr; // 指针ptr本身的值无法被修改<br>修饰形参: void func(const int *ptr);<br>修饰返回值: const &amp;aaa func(void); //<br>修饰类的函数成员: void func(int, int) const; // 函数内不能修改类成员的值</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>@todo</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="一般内部类"><a href="#一般内部类" class="headerlink" title="一般内部类"></a>一般内部类</h3><ul><li>外部类不一定有内部类实例, 但内部类一定有对应的外部类,</li><li>内部类的成员不能是static, 也不能有static代码块(但内部类可以是static的, 嵌套类)</li><li>外部类和内部类可以 <strong>互相访问</strong> 所有成员(包括private);<ul><li>外部类可以访问内部类的一切成员, 无论这个内部类是public还是private的, 无论内部类的成员是public还是private的, 外部类通过<code>内部类实例.成员名</code>访问内部类的成员;</li><li>内部类可以访问外部类的一切成员, 包括外部类的private成员, 访问方式是<code>外部类类名.this.func()</code>, 或者也可以”直接调用”外部类的成员.</li></ul></li><li>在编译成功后, 会出现这样两个class文件: <code>Outer.class</code>和<code>Outer$Inner.class</code>;</li></ul><p>定义一个内部类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * public可有可无, 默认public的内部类是包内可见, friendly</span></span><br><span class="line"><span class="comment">   * 内部类可以单独继承一个抽象类或实现一个接口 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      show(); <span class="comment">// 可以这样调用外部类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部类如何访问内部类"><a href="#外部类如何访问内部类" class="headerlink" title="外部类如何访问内部类"></a>外部类如何访问内部类</h4><ul><li>内部类访问外部类属性: <code>println(OutterClass.this.propertyName);</code></li><li>外部类访问内部类属性: <code>println(inner.propertyName)</code> // 必须先创建内部类实例inner</li><li>在拥有外部类对象之前, 是不可能创建内部类对象的, 换句话说, 其他人只能通过外部类对象才能访问内部类:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outter.Inner in = <span class="keyword">new</span> Outter.Inner(); <span class="comment">// ERROR! 要先创建外部类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的创建内部类对象:</span></span><br><span class="line">Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner in = out.getInner(); <span class="comment">// 在getter里返回Inner对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种创建方式:</span></span><br><span class="line">Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner in = out.new Inner(); <span class="comment">// obj.new语法</span></span><br></pre></td></tr></table></figure><h4 id="其他类如何访问内部类"><a href="#其他类如何访问内部类" class="headerlink" title="其他类如何访问内部类"></a>其他类如何访问内部类</h4><ul><li>public的内部类 的public成员是包可见;</li><li>public的内部类 的private成员包不可见, 仅对外部类可见;</li><li>当Inner是private时, 其他类不能通过<code>Outter.Inner in = out.getInner()</code>或者<code>Outter.Inner in = out.new Inner</code>的方式创建Inner对象, 因为Inner类就是private的;<br>但是, 如果private的Inner继承自一个Base类, 这个Base类又是包可见（Public）的, 那么可以通过<code>Base base = out.getInner()</code>的方式创建内部类对象, 换句话说, 这个Base是内部类的一个对外接口, 只能通过这个对外接口访问private的内部类;</li></ul><p>以上参考: <a href="http://zhangjunhd.blog.51cto.com/113473/65624/" target="_blank" rel="noopener">探讨Java内部类的可见性;</a> @ref</p><h3 id="内部类的必要性"><a href="#内部类的必要性" class="headerlink" title="内部类的必要性?"></a>内部类的必要性?</h3><ol><li>Java不允许多重继承, 使用内部类可以”继承”外部类的方法, 并且内部类可以独立的继承自另一个抽象类或者接口.</li><li>把实现细节放在内部类, 相当于是对外隐藏细节, 封装.</li><li>事件监听大量用到匿名内部类.</li><li>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现, 所以无论外围类是否已经继承了某个（接口的）实现, 对于内部类都没有影响[Think in Java]</li></ol><h3 id="局部内部类-amp-匿名类"><a href="#局部内部类-amp-匿名类" class="headerlink" title="局部内部类 &amp; 匿名类"></a>局部内部类 &amp; 匿名类</h3><ul><li>匿名类首先要有一个Interface or 基类;</li><li>匿名类没有名字, 也<strong>没有构造方法</strong>, 没有访问修饰符;</li><li>匿名类可以访问外部的变量, 但是<strong>创建匿名类的方法参数是final的</strong>;</li></ul><p>定义一个匿名类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匿名类要有一个接口或基类 */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pool <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 传入匿名类的参数要声明为final的 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pool() &#123;</span><br><span class="line">        <span class="keyword">int</span> number = num++;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;    <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI中大量使用的事件callback:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="嵌套内部类"><a href="#嵌套内部类" class="headerlink" title="嵌套内部类"></a>嵌套内部类</h3><ul><li>static的内部类被称为嵌套类, 嵌套内部类不需要由外部类创建, 也就没有隐藏的外部类引用</li><li>不能调用非static的外部类成员, 也不能访问<code>Outter.this.property</code>;</li><li>外部类初始化的时候, 不会触发嵌套内部类的初始化.</li></ul><blockquote><p>静态内部类的初始化的时机( 初始化时会执行static代码块, 初始化static成员变量, JVM会把这些操作放在一个叫 <code>clint</code>的方法中执行 ):</p></blockquote><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li>String是一个特殊的类, 不需要构造函数就可以创建实例<code>String s = &quot;hello world&quot;</code>;</li><li>String的<code>char[]</code>是final static的, 只有一份拷贝.一旦String被创建, 字符串的内容就不可改变了 // Question: 当new一个String时, 是如何判断字符串池里是否已经有相同字符串的?</li><li>字符串的比较不能使用<code>==</code>: <code>==</code>仍然比较的是引用, 而应该使用<code>String.equals()</code></li></ul><h2 id="String一些方法和实现"><a href="#String一些方法和实现" class="headerlink" title="String一些方法和实现"></a>String一些方法和实现</h2><ul><li><code>bool contains(String str)</code> : 判断参数s是否被包含在字符串中，并返回一个布尔类型的值</li><li><code>int indexOf(String str, int fromIndex)</code> :</li><li><code>String substring(int beginIndex, int endIndex)</code> : 该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。</li><li><code>int compareTo(String anotherString)</code> : 该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。</li><li><code>boolean equals(Object anotherObject)</code> : 比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<ul><li>比较引用是否相等</li><li>要比较的对象是否 <code>instanceof String</code></li><li>比较数组的长度 &amp; 依次比较每个char</li></ul></li><li><code>String concat(String str)</code> : 将参数中的字符串str连接到当前字符串的后面, 生成一个新字符串返回</li><li><code>String replace(char oldChar, char newChar)</code> : 用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。</li><li><code>String replaceAll(String regex, String replacement)</code> : 该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。</li></ul><h2 id="String-不可被继承"><a href="#String-不可被继承" class="headerlink" title="String 不可被继承"></a>String 不可被继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure><h2 id="比较StringBuffer"><a href="#比较StringBuffer" class="headerlink" title="比较StringBuffer"></a>比较StringBuffer</h2><ul><li>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。两者的<code>char []</code> 不是final的, 可以修改;</li><li>StringBuffer线程安全, 所有方法都是synchronized的;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 比较 `String concat(String)`, `+`, 以及 StringBuffer 效率*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认StringBuilder的char[]初始长度是16</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  <span class="number">1000</span>; i++)  &#123;</span><br><span class="line">  sb.append(<span class="string">" "</span>);</span><br><span class="line">  <span class="comment">// 可以看到sb.append的实现, 每次拷贝要扩容char[], 所以StringBuilder(len)设置好初始值</span></span><br><span class="line">  <span class="comment">// 拼接字符串使用sb.append()的代价最小, 因为不用频繁创建Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">// concat的实现&gt;</span></span><br><span class="line"><span class="comment">/* 计算拼接后的长度len, 创建一个char[len]</span></span><br><span class="line"><span class="comment"> * 拷贝str2的cha[] 到上面创建的数组</span></span><br><span class="line"><span class="comment"> * 调用String(char[]) 生成了新的String对象</span></span><br><span class="line"><span class="comment"> * 所以, 每次对String改变都会导致创建新的对象, 性能差异在这里</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">str.concat(<span class="string">" "</span>).concat(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会把下面的string + 的操作转为StringBuild, 但生成1000次StringBuilder实例, 操作符+效率差在这里</span></span><br><span class="line">String str2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  <span class="number">1000</span>; i++)  &#123;</span><br><span class="line">  str2 = str2 + <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-char-byte的互转"><a href="#String-char-byte的互转" class="headerlink" title="String,char,byte的互转"></a>String,char,byte的互转</h2><ul><li>String是由<code>char[]</code>存储数据, char是unicode, 用16bit(2字节)的数值表示一个char: <code>char c = &#39;\u554a&#39;;</code></li><li>String和char都可以用<code>\u0000</code>这种方式初始化.</li><li>byte是字节, String/char转为byte[]时, 不能确定byte[]的长度, 视转换用哪种编码(GBK/UTF-8)而定.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String string = <span class="string">"\u0048\u0069"</span>; <span class="comment">// Unicode对应的字符串是"Hi"</span></span><br><span class="line"><span class="keyword">char</span>[] chars = string.toCharArray();</span><br><span class="line">System.out.printf(<span class="string">"str_len= %d, arr_len= %d"</span>, string.length(), chars.length); <span class="comment">// 输出2 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串指定位置的Unicode值:</span></span><br><span class="line"><span class="keyword">int</span> index = s.offsetByCodePoints(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(index + <span class="string">":"</span> + s.codePointAt(index)); <span class="comment">// 输出72</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"嘿H1"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b1 = str.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] b2 = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="comment">// str, b1, b2, c的length分别是?</span></span><br></pre></td></tr></table></figure><p>unicode编码只指定了编码值, gbk和utf8定义了如何存储编码值.</p><ul><li>一个char存储的是16位的unicode, 范围0~0xFFFF(65535), 超过这个范围的汉字, 比如”𩄀”, 要用两个char也就是4字节表示.</li><li>如果unicode用gbk编码, 一个中文3字节, 一个英文1字节;</li><li>如果unicode用utf-8编码, 中文2字节, 英文一字节;</li><li>所以上面的输出分别是3, 5, 6, 3;</li></ul><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="String-amp-StringBuffer"><a href="#String-amp-StringBuffer" class="headerlink" title="String &amp; StringBuffer"></a>String &amp; StringBuffer</h2><p>见 <a href="#字符串">字符串</a></p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>见 <a href="#数据类型">数据类型</a></p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>@todo</p><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><blockquote><p>使用 DateTimeFormatter 替换 SimpleDateFormat: <a href="https://zhuanlan.zhihu.com/p/51695220" target="_blank" rel="noopener">你真的会使用SimpleDateFormat吗？ - 知乎</a></p></blockquote><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>图-Java异常类的层次结构:<br><img src="/images/java/java_exception.png" alt="Java Exception"></p><h2 id="Error-amp-Exception"><a href="#Error-amp-Exception" class="headerlink" title="Error &amp; Exception"></a>Error &amp; Exception</h2><p>在 Java 语言规范中，所有异常都是 Throwable 类或者其子类的实例。Throwable 有两大直接子类。第一个是 Error，涵盖程序不应捕获的异常。当程序触发 Error 时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。第二子类则是 Exception，涵盖程序可能需要捕获并且处理的异常。</p><ul><li><strong>Error</strong> 是程序无法处理的, 内存不足或JVM的错误, 比如 <code>OutOfMemoryError</code>, <code>ThreadDeath</code></li><li><strong>Exception</strong> 可由程序处理, 又分为”CheckedException”(受捡异常, 上图粉红色), 和”UncheckedException”(不受检异常, 上图蓝色)<ul><li>前者是程序需要捕获并处理的异常(比如打开文件错误, 网络超时等待), 需要throws-try-catch语句显式的捕获;</li><li>后者是代码错误, 比如数组越界, 这种不需要明确throws, 如果throws了也不强制代码必须catch, 其实Error也能算是不受检异常;</li></ul></li></ul><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Throwable</span><br><span class="line">    Error: 也算是&quot;不受检&quot;</span><br><span class="line">      OutOfMemoryError</span><br><span class="line">      ThreadDeath</span><br><span class="line">    Exception:</span><br><span class="line">      UserDefinedException: 用户自定义异常继承者Exception</span><br><span class="line">      ClassNotFoundException: 调用Class.forName时</span><br><span class="line">      InstantiationException: 调用Class.NewInstance时</span><br><span class="line">      IOException: 有一大堆派生自IOException的异常...</span><br><span class="line">      EOFException: 抛出此类异常，表示连接丢失，也就是说网络连接的另一端非正常关闭连接（可能是主机断电、网线出现故障等导致）</span><br><span class="line">      ConnectException：connection refused connect.</span><br><span class="line">      BindException：address already in use</span><br><span class="line">      RuntimeException (不受检异常):</span><br><span class="line">        NullPointerException: 最著名的不受检异常</span><br><span class="line">        IndexOutOfBoundsException: 数组越界</span><br><span class="line">        IllegalArgumentException: 调用方法时参数异常</span><br><span class="line">        IllegalAccessException: 方法对类没有访问权限</span><br><span class="line">        ArithmeticException: 数学算数异常</span><br><span class="line">        ArrayStoreException: 试图向数组存入不支持的类型</span><br><span class="line">        ClassCastException: 调用Class.cast(Object)时</span><br><span class="line">        NotSerializableException: 尝试对没有声明 Serializable接口的类进行序列化</span><br></pre></td></tr></table></figure><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>如果该异常被 catch 代码块捕获，finally 代码块则在 catch 代码块之后运行。<br>在某些不幸的情况下，catch 代码块也触发了异常，那么 finally 代码块同样会运行，并会抛出 catch 代码块触发的异常。<br>在某些极端不幸的情况下，finally 代码块也触发了异常，那么只好中断当前 finally 代码块的执行，并往外抛异常。</p><h2 id="try语句中的return"><a href="#try语句中的return" class="headerlink" title="try语句中的return"></a>try语句中的return</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x返回多少? 会打印出什么?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testTryCatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out.println(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        out.println(<span class="string">"finally"</span>);</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="comment">// return ++x; // 如果finally里也有return?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>try{return}</code>, 但finally没有return语句(比如上面的代码), 仍旧会执行<code>finally</code>块, try中的”返回值”被保存在局部变量中, jsr指令跳到finally块执行, 然后返回之前保存在局部变量的返回值.</li><li>如果上面代码finally也有return, 执行顺序是: try里的++x, finally里的++x, finally里的return</li><li>如果try和Catch都有return, 返回catch块的return</li><li>如果try和finally块都有return, try中<code>return表达式</code>仍会执行, 但不会返回try块的返回值, 而是执行finally块的return.</li></ul><blockquote><p>转自: <a href="http://blogread.cn/it/article/7423" target="_blank" rel="noopener">“你真的了解try{ return }finally{}中的return？</a></p></blockquote><h2 id="getMessage-vs-toString"><a href="#getMessage-vs-toString" class="headerlink" title="getMessage vs toString"></a>getMessage vs toString</h2><p><img src="/images/java/exception-tostring.png" alt="Exception_toString"></p><p>如代码所示,<br><code>e.toString()</code>获取的信息包括异常类型和异常详细消息，而<code>e.getMessage()</code>只是获取了异常的详细消息字符串,<br>所以推荐在Catch中使用<code>e.toString()</code></p><h2 id="常见异常及解释"><a href="#常见异常及解释" class="headerlink" title="常见异常及解释"></a>常见异常及解释</h2><blockquote><p><a href="http://www.importnew.com/16725.html" target="_blank" rel="noopener">Java常见异常及解释 - ImportNew</a></p></blockquote><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><ul><li>表达式<code>assert 表达式:错误消息</code> 比如<code>assert x&gt;y : &quot;断言失败!&quot;</code></li><li>如何开启关闭断言? 单点为某个类开启断言? <code>java -ea Xxx</code> , <code>java -ea:MyClass Xxx</code></li></ul><h1 id="Native-Method"><a href="#Native-Method" class="headerlink" title="Native Method"></a>Native Method</h1><h2 id="实现一个Native方法"><a href="#实现一个Native方法" class="headerlink" title="实现一个Native方法:"></a>实现一个Native方法:</h2><ol><li><p>声明java native method:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CJNativeInterfaceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">input</span><span class="params">(String prompt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"./libJniTest.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CJNativeInterfaceDemo jniDemo = <span class="keyword">new</span> CJNativeInterfaceDemo();</span><br><span class="line">        jniDemo.input(<span class="string">"JNI Test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成c++头文件</p><ul><li><code>javac CJNativeInterfaceDemo.java</code> 生成.class文件</li><li><code>javah -jni CJNativeInterfaceDemo</code> 生成.h文件</li></ul></li><li><p>实现C++函数并编译成动态库<code>gcc  -I/usr/lib/jvm/java-7-openjdk-i386/include/ CJNativeInterfaceDemo.c -shared -o libJniTest.so</code></p></li></ol><hr><h1 id="附录-JDK常用类"><a href="#附录-JDK常用类" class="headerlink" title="附录:JDK常用类"></a>附录:JDK常用类</h1><h2 id="java-lang📦继承关系图"><a href="#java-lang📦继承关系图" class="headerlink" title="java.lang📦继承关系图"></a>java.lang📦继承关系图</h2><p><img src="/images/java/java_lang_package.gif" alt="java.lang"></p><h2 id="java-util📦继承关系图"><a href="#java-util📦继承关系图" class="headerlink" title="java.util📦继承关系图"></a>java.util📦继承关系图</h2><p><img src="/images/java/java_util_package.gif" alt="java.util"></p><h1 id="附录-补码-反码"><a href="#附录-补码-反码" class="headerlink" title="附录:补码,反码"></a>附录:补码,反码</h1><blockquote><p>反码: 正数的反码是本身, 负数的反码=符号位不变, 其他位取反<br>补码: 正数的补码是本身, 负数的补码=符号位不变, 其他位取反, 再加1<br>看几组补码-真值: “1111 1111”=-1,  “1000 0010”=-126,  “1000 001”=-127, “1000 0000”=-128<br>不要用计算补码的方式去”算”-128的补码, 1000 0000 是定义的.</p></blockquote><p>参考:</p><ul><li>@ref <a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></li><li>@ref <a href="https://www.douban.com/note/223507364/" target="_blank" rel="noopener">原码、反码和补码</a></li></ul><h1 id="附录-运算符"><a href="#附录-运算符" class="headerlink" title="附录:运算符"></a>附录:运算符</h1><ul><li><code>/</code> 整数除法 15/2 = 7</li><li><code>%</code> 取余, 或者叫取模</li></ul><h2 id="C-里的函数"><a href="#C-里的函数" class="headerlink" title="C++里的函数"></a>C++里的函数</h2><ul><li><code>mod(a, b)</code>: 等同于<code>a%b</code>, 取余</li><li><code>floor(a)</code>: 返回小于等于a的整数, <code>floor(2.5)=2</code>, <code>floor(-3.5)=-3</code></li><li><code>ceil(a)</code>: 返回大于等于a的整数, <code>ceil(2.5)=3</code></li></ul><h2 id="位运算符-java"><a href="#位运算符-java" class="headerlink" title="位运算符(java)"></a>位运算符(java)</h2><ul><li><code>&amp;</code> 符号位</li><li><code>|</code> 符号位</li><li><code>~</code> 符号位</li><li><code>^</code> 符号位</li><li><code>&lt;&lt;</code> 左移: 丢弃最高位(符号位同样丢弃), 0补最低位. 当byte和short左移时, 自动升级为int型.<ul><li>数学意义: 左移n位相等于乘以2^n</li></ul></li><li><code>&gt;&gt;</code> 右移: 高位补充符号位, 正数右移补充0, 负数右移补充1, 当byte和short右移时, 自动升级为int型.<ul><li>数学意义:  右移n位相当于除以2^n</li></ul></li><li><code>&gt;&gt;&gt;</code> 无符号右移: 无论正负, 高位补充0<ul><li>无符号右移运算符&gt;&gt;&gt; 只是对32位和64位的值有意义</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-08-编译</title>
      <link href="/12.Java/Advanced-Java.08.%E7%BC%96%E8%AF%91/"/>
      <url>/12.Java/Advanced-Java.08.%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。</p><h2 id="编译器介绍"><a href="#编译器介绍" class="headerlink" title="编译器介绍"></a>编译器介绍</h2><h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p>源码-&gt;字节码, javac</p><ol><li>语法分析, 代码-&gt;Token, Token-&gt;语法树</li><li>填充符号表</li><li>语义分析, 保证逻辑性</li><li>字节码生成</li></ol><h3 id="后端编译器"><a href="#后端编译器" class="headerlink" title="后端编译器"></a>后端编译器</h3><p>字节码-&gt;机器码, 比如HotSpot自带的JIT, 当虚拟机发现某个方法或代码块运行特别频繁时, 就会把这些代码认定为<code>Hot Spot Code</code>, 虚拟机将会把这些代码编译成与本地平台相关的机器码</p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-07-字节码</title>
      <link href="/12.Java/Advanced-Java.07.%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/12.Java/Advanced-Java.07.%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>一些有关Java字节码的文章:</p><ul><li><a href="https://dzone.com/articles/introduction-to-java-bytecode" target="_blank" rel="noopener">Java Zone: Introduction to Java Bytecode </a> 这篇文章图文并茂地向你讲述了 Java 字节码的一些细节，是一篇很不错的入门文章。</li><li><a href="https://www.ibm.com/developerworks/library/it-haggar_bytecode/index.html" target="_blank" rel="noopener">IBM DeveloperWorks: Java bytecode</a> 讲 Java 字节码。</li></ul><h2 id="字节码相关库"><a href="#字节码相关库" class="headerlink" title="字节码相关库"></a>字节码相关库</h2><p>可以操作字节码的库:</p><ul><li>JVM Tool Interface (JVMTI): <a href="https://github.com/jon-bell/bytecode-examples" target="_blank" rel="noopener">Java Bytecode and JVMTI Example</a>，这是一些使用 JVM Tool Interface 操作字节码的比较实用的例子。包括方法调用统计、静态字节码修改、Heap Taggin 和 Heap Walking。计、静态字节码修改、Heap Taggin 和 Heap Walking</li><li>asm tools - 用于生产环境的 Java .class 文件开发工具。</li><li>Byte Buddy - 代码生成库：运行时创建 Class 文件而不需要编译器帮助。</li></ul><h2 id="多态性实现机制"><a href="#多态性实现机制" class="headerlink" title="多态性实现机制"></a>多态性实现机制</h2><h3 id="方法绑定"><a href="#方法绑定" class="headerlink" title="方法绑定"></a>方法绑定</h3><p>Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。<br>一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种称为 <strong>静态绑定</strong>；<br>另一部分方法在类运行期间才能确定某些目标方法的直接引用，称为 <strong>动态绑定</strong>；</p><p>Java 字节码中与调用相关的指令共有五种（还有一种invokedynamic，比较复杂）：</p><ul><li><strong>静态绑定</strong>: 调用哪个方法在编译期就确定了, 在类的加载阶段, static/final/private方法的符号引用被替换为直接引用, 用<code>invokestatic</code>,<code>invokespecial</code>指令调用的方法都是在加载阶段被替换为直接引用:<ul><li>invokestatic指令: 用来调用static方法;</li><li>invokespecial指令: 用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li></ul></li><li><strong>动态绑定</strong>: 在运行阶段(每次类被初始化的时候?)才能确定直接引用的方法.<ul><li>invokevirtual指令: 调用所有的虚方法（即非私有实例方法, 除了static/private/Constructor方法之外的都算作虚方法, 虽然final方法也是由invokevirtual调用但是final方法不属于虚方法）</li><li>invokeinterface指令: 调用接口方法</li></ul></li></ul><h3 id="单分派-amp-多分派"><a href="#单分派-amp-多分派" class="headerlink" title="单分派 &amp; 多分派"></a>单分派 &amp; 多分派</h3><blockquote><p>方法的调用者与方法的参数统称为方法的”宗量”, 单分派是根据一个宗量对目标方法进行选择, 多分派是根据多个宗量对目标方法进行选择</p></blockquote><p>单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。此外分派还可以根据”动态/静态解析”分为动态分派(运行期)和静态分派(编译期间).<br>两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。</p><ul><li>在编译阶段编译器的选择过程，即静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型(基类类型)，二是方法参数类型。因为是根据两个宗量进行选择，所以 Java 语言的静态分派属于多分派类型。</li><li>运行阶段虚拟机的选择过程，即动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的参数类型。因为只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派类型。</li></ul><p><img src="/images/java/java_dispatcher.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java内存模型》笔记</title>
      <link href="/12.Java/Advanced-Java.06.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/12.Java/Advanced-Java.06.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>@ref: <a href="http://www.infoq.com/cn/minibooks/java_memory_model" target="_blank" rel="noopener">《深入理解Java内存模型》</a></p><p>@tldr:</p><ul><li><a href="#并发编程模型">并发编程模型</a><ul><li>并发编程模型要解决的两个问题: 通信和同步</li><li>两种并发编程模型的: 基于共享内存, 基于消息</li></ul></li><li><a href="#Java内存模型的抽象">Java内存模型的抽象</a><ul><li>Java内存模型（JMM）的抽象: 主内存和线程的”本地内存”</li><li><a href="#JMM的happens-before规则">happens-before规则</a><ul><li>该规则是JSR-133内存模型(JDK层面定义的)中提出的概念, happens-before并不是指两个指令执行的先后顺序, 而是两个指令的 <strong>内存可见性</strong>. 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</li><li>该规则还保证了, 哪些java代码能达到happens-before的效果:<ul><li>单线程下顺序执行;</li><li>正确使用volatile, Synchronize 的情况下, 多线程也能提供happens-before效果;</li></ul></li></ul></li></ul></li><li><a href="#重排序">重排序</a><ul><li>为什么会产生重排序，有哪几种重排序?</li><li>在JMM上, 重排序必须遵守as-if-serial语义: as if serial, 「就像是顺序执行」<ul><li>在单线程环境下, 保证a-i-s, 处理器和编译器的重排序优化,不能改变存在数据依赖关系的两个操作的执行顺序</li><li>在存在竞争的多线程下, 处理器和编译器不保证a-i-s, 必须正确使用lock，volatile和final 才可以.</li></ul></li></ul></li><li><a href="#内存屏障">内存屏障</a><ul><li>内存屏障指令是cpu架构层面定义的, Java编译器会在生成字节码中插入内存屏障指令来禁止某些重排序, 保证多核环境下代码执行的”一致性”</li><li>JMM提供了四种内存屏障, 其中最重要的是<code>StoreLoad</code>屏障指令, 它能保证…</li></ul></li><li>Java如何实现多线程环境下的正确同步:<ul><li>Volatile实现了怎样的内存语义, 是如何实现的?</li><li>Synchronize实现了怎样的内存语义, 是如何实现的?</li><li>ReentrantLock是如何实现的? CAS具有跟Volatile读写一样的内存语义, 是如何实现的?</li><li><a href="concurrent包的实现">concurrent包的实现</a> : 四种方式(CAS和volatile)</li></ul></li></ul><h2 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h2><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。</p><p><strong>通信</strong> 是指: 通信是指线程之间以何种机制来交换信息。在共享内存的并发模型里，对于线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p><strong>同步</strong> 是指: 程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><blockquote><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p></blockquote><p>Java并发模型中, 线程的同步采用的是 <strong>共享内存</strong> 的方式，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h2 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h2><p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的 <strong>本地内存</strong>（local memory），本地内存中存储了该线程以读/写共享变量的副本。<br><strong>本地内存</strong> 是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p><p><img src="/images/java/JMM.png" alt="JMM"></p><blockquote><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p></blockquote><h3 id="JMM的happens-before规则"><a href="#JMM的happens-before规则" class="headerlink" title="JMM的happens-before规则"></a>JMM的happens-before规则</h3><p>从JDK5开始，java使用新的JSR-133内存模型，JSR-133提出了happens-before的概念，<strong>通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</strong><br>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的happens-before规则如下：</p><ol><li>顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>监视器锁（Monitor）规则：对一个监视器锁的解锁，happens-before于随后对这个监视器锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li></ol><blockquote><p>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。<br>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</p></blockquote><h3 id="JMM顺序一致性"><a href="#JMM顺序一致性" class="headerlink" title="JMM顺序一致性"></a>JMM顺序一致性</h3><p><strong>什么是“顺序一致性”内存模型：</strong></p><p>顺序一致性模型(sequential consistency)是一个被计算机科学家理想化了的理论参考模型，顺序一致性内存模型有两大特性：</p><ol><li>在单线程环境下，所有操作必须按照代码的顺序来执行。</li><li>多线程环境下，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ol><p>然而，即使是顺序一致性在实际系统中也是很少使用的，主要是它严格限制了程序的优化执行，强行的使程序在本地处理器上按程序序（program order）执行在大多数情况下是没有必要的。</p><p><strong>JMM的顺序一致性保证：</strong></p><p>JMM提供的顺序一致性内存模型是一种”面向程序员的内存模型”（Programmer-centric model），JMM对正确同步的多线程程序的内存一致性做了如下保证：<br>如果程序是正确同步的（正确使用了lock，volatile和final），程序的执行将具有顺序一致性（sequentially consistent）– 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。<br>重排序分三种类型：</p><ol><li><strong>编译器优化</strong> 的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行</strong> 的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><strong>内存系统</strong> 的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p><img src="/images/java/jmm-re-order.png" alt=""></p><blockquote><ol><li>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。</li><li>写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</li></ol></blockquote><h3 id="遵守as-if-serial语义"><a href="#遵守as-if-serial语义" class="headerlink" title="遵守as-if-serial语义"></a>遵守as-if-serial语义</h3><p>as-if-serial: 翻译就是「就像是顺序执行」.</p><p>编译器和处理器对重排序准守<code>as-if-serial</code>语义，<code>as-if-serial</code>的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器/runtime/处理器都必须遵守as-if-serial语义。</p><p>为了遵守<code>as-if-serial</code>语义，编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不能改变存在数据依赖关系的两个操作的执行顺序。比如<code>a=b; b=1;</code> 以及<code>a=1; b=a;</code>，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><p><strong>编译器和处理器仅指在单线程环境下遵守as-if-serial</strong>，在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。必须通过正确的同步实现.</p><p>注意：if等控制语句没有 <strong>数据依赖性</strong>，比如代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(flag)</span><br><span class="line">  int i = r * r;</span><br></pre></td></tr></table></figure></p><p>其中<code>if</code>和<code>int i= r * r</code>是控制依赖关系，但没有数据依赖性。<br>当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响，提高执行效率。<br>下面的情形是有可能发生的：处理器可以提前读取并计算<code>r * r</code>，然后把计算结果临时保存到一个名为 <strong>重排序缓冲（reorder buffer ROB）</strong> 的硬件缓存中。当接下来<code>if(flag)</code>的条件判断为真时，就把该计算结果写入变量i中。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>编译器和处理器必须同时遵守重排规则。由于单核处理器能确保与“顺序执行”相同的一致性，所以在单核处理器上并不需要专门做什么处理，就可以保证正确的执行顺序。但在多核处理器上通常需要使用内存屏障指令来确保这种一致性。在不同的CPU架构上内存屏障的实现非常不一样。相对来说Intel CPU的强内存模型比DEC Alpha的弱复杂内存模型（缓存不仅分层了，还分区了）更简单。</p><blockquote><p>内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。</p></blockquote><p>Java编译器在生成指令序列的适当位置会插入 <strong>内存屏障（Barriers）</strong> 指令来禁止特定类型的处理器重排序。以实现屏障前后指令的可见性。</p><p>JMM把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th>example</th><th>实现效果</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1; LoadLoad; Load2;</td><td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。(禁止Load1,Load2重排序)</td></tr><tr><td>StoreStore</td><td>Store1; StoreStore; Store2;</td><td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。(禁止Store1,Store2重排序)</td></tr><tr><td>LoadStore</td><td>Load1; LoadStore; Store2;</td><td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。(禁止Load1,Store2重排序)</td></tr><tr><td>StoreLoad</td><td>Store1; StoreLoad; Load2;</td><td>确保Store1数据对其他处理器变得可见（刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。(禁止Store1,Load2重排序)</td></tr></tbody></table><p><strong>StoreLoad</strong> 是一个“全能型”的屏障，它可以保证“先刷新到主内存再访问”。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="volatile变量的特性"><a href="#volatile变量的特性" class="headerlink" title="volatile变量的特性"></a>volatile变量的特性</h3><ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。可以认为对volatile的写是原子的；</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于<code>volatile++</code>这种”依赖当前值”的复合操作不具有原子性，所以仅仅使用volatile变量当做同步手段(比如当做锁的计数器) 是不可以的。 线程安全的计数器请使用<code>AtomicInteger</code></li></ul><blockquote><p>扩展阅读: long和double读写的原子性:<br>JMM不保证对64位的long型和double型变量的读/写操作具有原子性,<br>在一些32位的处理器上，如果要求对64位数据的读/写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的读/写具有原子性。<br>当JVM在这种处理器上运行时，会把一个64位long/ double型变量的读/写操作拆分为两个32位的读/写操作来执行。<strong>这两个32位的读/写操作可能会被分配到不同的总线事务中执行</strong>，此时对这个64位变量的读/写将不具有原子性。</p></blockquote><h3 id="volatile读写建立的happens-before关系"><a href="#volatile读写建立的happens-before关系" class="headerlink" title="volatile读写建立的happens before关系"></a>volatile读写建立的happens before关系</h3><p><strong>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信</strong>。看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A执行writer():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;               <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;         <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程B执行read():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;          <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;      <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据happens-before①，1 happens-before 2，3 happens-before 4；</li><li>根据volatile语义，2 happens-before 3；</li><li>根据happens-before④，1 happens-before 4；</li></ul><blockquote><p>上面写1 happens-before 2，指的是1对于2可见，但不一定是执行顺序；</p></blockquote><h3 id="volatile读写的内存语义"><a href="#volatile读写的内存语义" class="headerlink" title="volatile读写的内存语义"></a>volatile读写的内存语义</h3><p>volatile读写的内存语义如下：</p><ul><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</li></ul><blockquote><p>“内存语义”的概念:</p><blockquote><p>内存语义（没找到对应的英文原语）： 可以理解为 多核环境下, “同步”(在Java里指Volatile，Synchronize等)实现的原则, 或者是”能达到的效果”.</p></blockquote></blockquote><h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><p>下面是 JMM 针对编译器制定的 volatile 重排序规则表：<br><img src="/images/java/JMM-Volatile-Re-Order.png" alt=""></p><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个 <strong>volatile写</strong> 操作的 <strong>前面</strong> 插入一个<code>StoreStore</code>屏障。</li><li>在每个 <strong>volatile写</strong> 操作的 <strong>后面</strong> 插入一个<code>StoreLoad</code>屏障。</li><li>在每个 <strong>volatile读</strong> 操作的 <strong>后面</strong> 插入一个<code>LoadLoad</code>屏障。</li><li>在每个 <strong>volatile读</strong> 操作的 <strong>后面</strong> 插入一个<code>LoadStore</code>屏障。</li></ul><p><strong>① volatile写 插入的内存屏障：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通读/写操作</span><br><span class="line">StoreStore屏障 //禁止上面的普通写和下面的 Volatile写 重排序</span><br><span class="line">volatile写</span><br><span class="line">StoreLoad屏障  //禁止上面的Volatile写和下面有可能的 Volatile读写 重排序</span><br></pre></td></tr></table></figure></p><p><img src="/images/java/jmm-volatile-barriers_store.png" alt="jmm-volatile-read-barriers"></p><p><strong>② volatile读 插入的内存屏障：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile读</span><br><span class="line">LoadLoad屏障  // 禁止下面的普通读和上面的 Volatile读 重排序</span><br><span class="line">LoadStore屏障 // 禁止下面的普通写和上面的 Volatile读 重排序</span><br><span class="line">普通读/写</span><br></pre></td></tr></table></figure></p><p><img src="/images/java/jmm-volatile-barriers_load.png" alt="jmm-volatile-write-barriers"></p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>有关Synchronized的实现, 请参考👉<a href="https://whatsrtos.github.io/30MinsTutorial/Java%20Tutorials/#Synchronized" target="_blank" rel="noopener">《Java Tutorials》</a></p><h3 id="Synchronized的释放-获取建立的happens-before关系"><a href="#Synchronized的释放-获取建立的happens-before关系" class="headerlink" title="Synchronized的释放-获取建立的happens before关系"></a>Synchronized的释放-获取建立的happens before关系</h3><p>线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。</p><h3 id="Synchronized释放-获取的内存语义"><a href="#Synchronized释放-获取的内存语义" class="headerlink" title="Synchronized释放-获取的内存语义"></a>Synchronized释放-获取的内存语义</h3><ul><li>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</li><li>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被monitor保护的临界区代码必须要从主内存中去读取共享变量。</li><li>对比锁释放-获取的内存语义与volatile写-读的内存语义，可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</li></ul><h3 id="Synchronized内存语义的实现"><a href="#Synchronized内存语义的实现" class="headerlink" title="Synchronized内存语义的实现"></a>Synchronized内存语义的实现</h3><p>Synchronized提供的Monitor机制可以保证：临界区内的代码可以重排序，但不允许临界区内的代码“逸出”到临界区之外。<br>JMM会在退出Monitor和进入Monitor这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程在临界区内可以做重排序，但其他线程根本无法“观察”到该线程在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock实现的happens-before关系和内存语义与Synchronized的一样。<br>ReentrantLock实现的基础是Volatile变量和CAS, 上面提到了Volatile变量的读/写可以实现”禁止重排序”的效果, CAS操作同时具有Volatile读和写的禁止重排序效果.<br>(#CAS的原理和实现的内存语义)一节介绍了CAS是如何同时具有Volatile变量的读和写的内存语义的.</p><h3 id="ReentrantLock内存语义的实现解析"><a href="#ReentrantLock内存语义的实现解析" class="headerlink" title="ReentrantLock内存语义的实现解析"></a>ReentrantLock内存语义的实现解析</h3><p>回顾ReentrantLock的实现，<code>lock()</code>调用栈如下：</p><ol><li>ReentrantLock : lock()</li><li>FairSync : lock()</li><li>AbstractQueuedSynchronizer : acquire(int arg)</li><li>ReentrantLock : tryAcquire(int acquires)</li></ol><p>在第4步真正开始加锁，<code>tryAcquire</code>方法首先读volatile变量state，<br>  如果<code>state==0</code>, 说明还未加锁, 再尝试<code>CAS(state, 0, 1)</code>, 如果CAS成功则成功获取到锁;<br>  如果<code>state!=0</code>, 说明已经加锁, 再判断ExclusiveOwnerThread是否等于当前线程, 如果等于, 重入该锁(立刻获取到锁)</p><p>解锁方法<code>unlock()</code>的方法调用栈如下(公平锁为例)：</p><ol><li>ReentrantLock : unlock()</li><li>AbstractQueuedSynchronizer : release(int arg)</li><li>Sync : tryRelease(int releases)</li></ol><p>在第3步真正开始释放锁，<code>tryRelease</code>方法首先读volatile变量state，<br>  读取到的值-1, 然后把这个减1后的值写入state(这里并没用CAS更新), 如果这个减1后的值==0, 则把锁状态置为free</p><p>由上可知, 公平锁在释放锁的时候写Volatile变量, 在获取锁的时候读取Volatile变量, 根据volatile的happens-before规则：<br><strong>释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。</strong></p><h4 id="CAS的原理和实现的内存语义"><a href="#CAS的原理和实现的内存语义" class="headerlink" title="CAS的原理和实现的内存语义"></a>CAS的原理和实现的内存语义</h4><p>CAS同时具有volatile读和volatile写的内存语义。下面我们来分析在常见的 intel x86 处理器中，CAS 是如何同时具有 volatile 读和 volatile 写的内存语义的。</p><p>sun.misc.Unsafe类的<code>compareAndSwapInt()</code>方法是个Native方法, 最终调用到了JVM的C++代码<code>Atomic::cmpxchg()</code>（compare and change）,</p><p>C++的<code>Atomic::cmpxchg()</code>最终调用的是”compare and change”的汇编代码<code>cmpxchg</code> ,</p><p><code>Atomic::cmpxchg()</code>函数会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。<br>如果程序是在多处理器上运行，就为cmpxchg指令加上<code>lock</code>前缀（汇编代码是这个样子<code>lock cmpxchg dword ptr[edx], ecx</code>）。<br>intel的手册对<code>lock</code>前缀的说明如下：</p><ol><li>确保对内存的读-改-写操作原子执行。</li><li>禁止该指令与之前和之后的读和写指令重排序。</li><li>把写缓冲区中的所有数据刷新到内存中。</li></ol><p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。所以，现在我们终于能明白为什么JDK文档说 <strong>CAS同时具有volatile读和volatile写的内存语义</strong> 了。</p><h3 id="Concurrent包的实现总结-Volatile-和-CAS"><a href="#Concurrent包的实现总结-Volatile-和-CAS" class="headerlink" title="Concurrent包的实现总结: Volatile 和 CAS"></a>Concurrent包的实现总结: Volatile 和 CAS</h3><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p><ol><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ol><p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。<br>同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。<br>如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为volatile；</li><li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li><li>同时，配合以<code>volatile读/写的内存语义</code> 和 <code>CAS的内存语义</code>，来实现线程之间的通信。</li></ol><p>下图是Java concurrent包的实现层次结构, 以Volatile和CAS为基础, JDK实现了AQS / Atomic类 / 非阻塞队列等等基本类, 然后<br>通过这些基本类实现了重入锁, 阻塞队列, 线程池等..</p><p><img src="/images/java/jmm-cas-and-volatile.png" alt=""></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p><ul><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ul><h3 id="读写-FINAL-域的重排序规则"><a href="#读写-FINAL-域的重排序规则" class="headerlink" title="读写 FINAL 域的重排序规则"></a>读写 FINAL 域的重排序规则</h3><p>① 写: 写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><p>② 读: 在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</p><h3 id="FINAL-域是引用类型"><a href="#FINAL-域是引用类型" class="headerlink" title="FINAL 域是引用类型"></a>FINAL 域是引用类型</h3><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：<br>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><h2 id="回到错误的DLC单例代码"><a href="#回到错误的DLC单例代码" class="headerlink" title="回到错误的DLC单例代码"></a>回到错误的DLC单例代码</h2><p>常见的双重锁检查（Double Checked Locking）的单例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> </span>&#123;                 <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                    <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;               <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                          <span class="comment">//4:第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123;  <span class="comment">//5:加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)                    <span class="comment">//6:第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();           <span class="comment">//7:问题的根源出在这里</span></span><br><span class="line">            &#125;                                            <span class="comment">//8</span></span><br><span class="line">        &#125;                                                <span class="comment">//9</span></span><br><span class="line">        <span class="keyword">return</span> instance;                                 <span class="comment">//10</span></span><br><span class="line">    &#125;                                                    <span class="comment">//11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写是有问题的，在多线程并发的情况下，当有某个线程在步骤4进行检查的时候发现instance非null，但instance却指向一块已经分配但是未初始化的内存。<br>示例代码的第7行<code>instance = new Instance()</code>创建一个对象。这一行代码可以分解为如下的三行伪代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized (DoubleCheckedLocking.class) &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        memory = allocate();   //1：分配对象的内存空间</span><br><span class="line">        ctorInstance(memory);  //2：初始化对象</span><br><span class="line">        instance = memory;     //3：设置instance指向刚分配的内存地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由JSR-133的happens-before和<code>as-if-serial</code>语义，在单线程里1 happens-before 3，但2不能保证happens-before 3，<br>2和3有可能发生重排序，执行顺序变为 1-3-2，调用构造方法初始化对象被重排序到了最后一步，</p><p>如果发生了1-3-2的重排序，<br>当线程A执行完3，但还没执行2的时候(instance指向分配好的内存, 但这块内存还未由构造函数初始化)，A线程却被CPU让出了,<br>线程B开始运行, 到第一次判断<code>instance==null</code>，线程B判断instance是非null，不用走下面的sync, 直接返回了这个instance, 线程B获取到了(还未初始化的)instance引用。然后就出问题了</p><p><strong>所以, 解决方法有两种思路:</strong></p><ol><li>不允许 2 和 3 重排序；</li><li>允许 2 和 3 重排序，但不允许其他线程“看到”这个重排序，也即1-3-2都执行完之后其他线程才可以”看到”改变（可见性）。</li></ol><p>第一种解决方案是, 将 <code>instance</code> 变量声明成 volatile。<br>当声明对象的引用为 volatile 后，“问题的根源”的三行伪代码中的 2 和 3 之间的重排序，在多线程环境中将会被禁止。</p><p>第二种方案, 基于类初始化锁, 代码示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance ;  <span class="comment">// 这里将导致 InstanceHolder 类被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下Java对初始化的规范:</p><pre><code>T 是一个类, 首次对 T 的 static成员属性 进行读写的时候, 会触发 T的初始化T 是一个外部类, T被初始化的时候, 其静态内部类Inner不会被初始化,</code></pre><p>作为内部类, InstanceHolder 不会在 外部类初始化时被初始化(可以实现延后初始化),<br>首次调用 <code>InstanceFactory.getInstance()</code>的时候, 相当于调用了 <code>getstatic</code>指令读取 InstanceHolder的静态属性, 会导致 InstanceHolder 被初始化,<br>初始化包括 执行static代码块, 初始化static成员属性, 这些操作代码都被放在一个叫 <code>&lt; clinit &gt;</code>的方法中, 被JVM加锁执行.<br>这个方案的实质是：允许“问题的根源”的三行伪代码中的 2 和 3 重排序，但不允许其他线程（这里指线程 B）“看到”这个重排序。</p><blockquote><p>Java 语言规范规定，对于每一个类或接口 C，都有一个唯一的初始化锁 LC 与之对应。从 C 到 LC 的映射，由 JVM 的具体实现去自由实现。JVM 在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="noopener">深入理解Java内存模型（一）——基础</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-2" target="_blank" rel="noopener">深入理解Java内存模型（二）——重排序</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-3" target="_blank" rel="noopener">深入理解Java内存模型（三）——顺序一致性</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-4" target="_blank" rel="noopener">深入理解Java内存模型（四）——volatile</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-5" target="_blank" rel="noopener">深入理解Java内存模型（五）——锁</a></li><li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-05-对象内存模型</title>
      <link href="/12.Java/Advanced-Java.05.%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/12.Java/Advanced-Java.05.%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p><img src="/images/java/JVM-Object-Memory.png" alt=""></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机的对象头包括两部分信息对象头分三部分内容(如果不是数组则是两部分):</p><ol><li><strong>Mark Word</strong>: 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位VM中分别为32bit和64bit;</li><li><strong>Class Metadata Address</strong>: klass类型指针, 用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。这部分数据的长度在32位和64位VM中分别为32bit和64bit。64位开启指针压缩的情况下, 这部分占32bit;</li><li><strong>Array Length</strong>: 如果是数组对象，还需要有一个<code>Array Length</code>保存数组长度的空间，32bit</li></ol><p><img src="/images/java/jmm-object-memory-head.png" alt="对象头"></p><h3 id="Mark-Word结构"><a href="#Mark-Word结构" class="headerlink" title="Mark Word结构"></a>Mark Word结构</h3><p>Mark Word每个区域表示的内容, 不同对象锁状态下的含义也不同:</p><p><img src="/images/java/jmm-object-mark-word.png" alt=""></p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>去掉对象头, 剩下的是实例数据（Instance Data）和对齐填充（Padding）:<br>实例数据部分包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节（64位系统中是8个字节）。<br>非final非static成员属性才在这里, final的常量属性在方法区; static的属性在class对象里, class对象也在堆区.</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>填充字节, 使得对象的大小是8的倍数</p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-05-class文件结构</title>
      <link href="/12.Java/Advanced-Java.05.class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/12.Java/Advanced-Java.05.class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>class文件是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述。<br>class文件中的每个数据项都有它的固定长度， 数据项的不同长度分别用u1，u2，u4，u8表示，长度分别是byte、short、int、long。<br>class文件中存在以下数据项(该图表参考自《深入Java虚拟机》)：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:left">u4</td><td style="text-align:center">magic</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">minor_version</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">major_version</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">constant_pool_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">cp_info</td><td style="text-align:center">constant_pool</td><td style="text-align:center">constant_pool_count - 1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">access_flags</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">this_class</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">super_class</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">interfaces_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">interfaces</td><td style="text-align:center">interfaces_count</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">fields_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">field_info</td><td style="text-align:center">fields</td><td style="text-align:center">fields_count</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">methods_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">method_info</td><td style="text-align:center">methods</td><td style="text-align:center">methods_count</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:center">attribute_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:center">attributes</td><td style="text-align:center">attributes_count</td></tr></tbody></table><p>下图参考自: <a href="https://blog.csdn.net/luanlouis/article/details/39960815" target="_blank" rel="noopener">《Java虚拟机原理图解》 Class文件中的常量池详解</a> @ref<br><img src="/images/java/JVM-Class-Struct.png" alt=""></p><p><strong>class文件每个区域的说明：</strong></p><ul><li><code>magic</code>和<code>version</code>: magic也即魔数(固定值0xCAFEBABE)占用4字节, class文件版本号占用4字节, 不同版本的javac编译器编译的class文件, 版本号可能不同;</li><li>常量池数量<code>constant_pool_count</code>, class文件中的项constant_pool_count的值为1, 说明每个类都只有一个常量池。 常量池中的数据也是一项一项的， 没有间隙的依次排放。常量池中各个数据项通过索引来访问， 有点类似与数组， 只不过常量池中的第一项的索引为1, 而不为0, 如果class文件中的其他地方引用了索引为0的常量池项， 就说明它不引用任何常量池项。</li><li>常量池(<code>constant_pool</code>)存储的内容主要包括<code>符号引用</code>和<code>字面量</code>, 常量池中除了存放了常量字符串，final常量值，还包括 <strong>符号引用</strong>（包括当前类的类名， 字段名， 方法名， 各个字段和方法的描述符， 对当前类的字段和方法的引用信息， 当前类中对其他类的引用信息等等）。<br>class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的<code>this_class</code>, <code>super_class</code>, <code>field_info</code>, <code>attribute_info</code>等，<br>另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。此外， 常量池中各个项也会相互引用。<ul><li><strong>a. 字面量</strong>: 主要包括字符串常量和final常量值;</li><li><strong>b. 符号引用</strong>: 包括 类继承的超类, 接口的全限定名, 及描述符（包括fields的名称和描述符, methods的名称及描述符）<ol><li>类和接口的全限定名: 例如一个类的权限定名是<code>org/kshan/corej/TestClass</code>;</li><li>字段的名称和描述符:<ul><li>字段名称: 当类被加载后的链接阶段, 这些符号引用被替换为直接引用;</li><li>字段描述符: 用来描述字段的类型比如二维数组<code>int [][]</code>被记录为<code>[[I</code>, <code>String[]</code>被记录为<code>[Ljava/lang/String</code>;</li></ul></li><li>方法的名称和描述符:<ul><li>方法名称: 当类被加载后的链接阶段, 这些符号引用被替换为直接引用;</li><li>方法描述符: 用来描述方法的形参/返回值, 例如方法<code>int getIndex(String name,char[] tgc,int start,int end,char target)</code>的描述符为<code>(Ljava/lang/String[CIIC) I</code>;</li></ul></li></ol></li></ul></li><li><code>access_flag</code>, 在常量池之后的两个字节, 这个标志用于识别一些类或接口层次的访问信息</li><li><code>this_class</code>/<code>super_class</code>/<code>interfaces</code>: 类索引（<code>this_class</code>）和父类索引（<code>super_class</code>）都是一个 u2 类型的数据,而接口索引集合（<code>interfaces</code>）则是一组 u2 类型的数据集合, Class 文件中由这三项数据来确定这个类的继承关系;</li><li><code>field_info</code>字段表</li><li><code>method_info</code>方法表</li><li><code>attribute_info</code>属性表</li><li>方法字节码</li></ul><h2 id="class文件常量池"><a href="#class文件常量池" class="headerlink" title="class文件常量池"></a>class文件常量池</h2><p>注意不要与JVM内存模型中的”运行时常量池”混淆, Class文件中常量池主要存储了字面量以及符号引用，其中<br>字面量主要包括字符串，final常量的值或者某个属性的初始值等等，<br>符号引用主要存储类和接口的全限定名称，字段的名称以及描述符，方法的名称以及描述符，<br>JVM内存模型中有堆，方法区，栈，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存放的其实也是各种字面量以及符号引用， 只不过运行时常量池具有动态性，它可以在运行的时候向其中增加其它的常量进去，最具代表性的就是<code>String.intern</code>方法。</p><h2 id="实例分析class文件常量池"><a href="#实例分析class文件常量池" class="headerlink" title="实例分析class文件常量池"></a>实例分析class文件常量池</h2><p>Java测试类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CJEntry</span> <span class="keyword">extends</span> <span class="title">CJBaseClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> thatIsConstVar = <span class="number">5</span>; <span class="comment">// 整形常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> thatIsStaticVar = <span class="keyword">true</span>; <span class="comment">// 静态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> thatIsInstanceVar;  <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thatIsInstanceMethod</span><span class="params">(String input)</span> </span>&#123; <span class="comment">// 实例方法</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(input); <span class="comment">// 调用静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后使用javap分析class文件: <code>javac org/kshan/corej/CJEntry.java &amp;&amp; javap -v org.kshan.corej.CJEntry</code>, 只截取输出的”Constant pool” :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #1 = Methodref          #5.#23         // org/kshan/corej/CJBaseClass.&quot;&lt;init&gt;&quot;:()V  ## 构造方法的符号引用</span><br><span class="line"> #2 = Methodref          #24.#25        // java/lang/Integer.parseInt:(Ljava/lang/String;)I  ## Integer.parseInt()的符号引用</span><br><span class="line"> #3 = Fieldref           #4.#26         // org/kshan/corej/CJEntry.thatIsStaticVar:Z  ## 静态field的符号引用</span><br><span class="line"> #4 = Class              #27            // org/kshan/corej/CJEntry  ## 父类符号引用</span><br><span class="line"> #5 = Class              #28            // org/kshan/corej/CJBaseClass ## 接口符号引用</span><br><span class="line"> #7 = Utf8               thatIsConstVar  ##static final常量名字</span><br><span class="line">#10 = Integer            5  ## static final常量值</span><br><span class="line">#11 = Utf8               thatIsStaticVar  ## 变量名字</span><br><span class="line">#13 = Utf8               thatIsInstanceVar ## 变量名字</span><br><span class="line">#14 = Utf8               &lt;init&gt; ##</span><br><span class="line">#15 = Utf8               ()V  ##</span><br><span class="line">#18 = Utf8               thatIsInstanceMethod</span><br><span class="line">#19 = Utf8               (Ljava/lang/String;)I</span><br><span class="line">#23 = NameAndType        #14:#15  // &quot;&lt;init&gt;&quot;:()V  ## 构造方法的NameAndType, &lt;init&gt;是构造方法的名字, ()V表示无参返回Void</span><br><span class="line">#24 = Class              #30      // java/lang/Integer</span><br><span class="line">#25 = NameAndType        #31:#19        // parseInt:(Ljava/lang/String;)I  ## 静态方法名字:描述符`(形参列表)返回值`的格式</span><br><span class="line">#26 = NameAndType        #11:#12        // thatIsStaticVar:Z</span><br><span class="line">#27 = Utf8               org/kshan/corej/CJEntry</span><br><span class="line">#28 = Utf8               org/kshan/corej/CJBaseClass</span><br><span class="line">#29 = Utf8               java/io/Serializable</span><br><span class="line">#30 = Utf8               java/lang/Integer</span><br><span class="line">#31 = Utf8               parseInt</span><br></pre></td></tr></table></figure><blockquote><p>@ref: <a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">实例分析Java Class的文件结构 | | 酷 壳 - CoolShell</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-04-ClassLoader</title>
      <link href="/12.Java/Advanced-Java.04.ClassLoader/"/>
      <url>/12.Java/Advanced-Java.04.ClassLoader/</url>
      
        <content type="html"><![CDATA[<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>加载 – 链接 – 初始化, 以上三个阶段涉及到的JVM内存区域:</p><blockquote><ol><li>在加载阶段, 创建的class对象存储在堆(Heap);</li><li>在链接阶段, final常量和字符串在方法区分配空间(jdk8变成了元空间);</li><li>在初始化阶段, 初始化static成员, 也在堆;</li></ol></blockquote><p><img src="/images/java/JVM-Load-Class.png" alt=""></p><h3 id="①加载-Loading"><a href="#①加载-Loading" class="headerlink" title="①加载(Loading)"></a>①加载(Loading)</h3><ul><li>由对应的ClassLoader从磁盘读取.class文件字节 // 这里的类加载器可以自定义</li><li>由 <code>ClassLoader.defineClass()</code>方法创建一个java.lang.Class的对象, 对象存储在堆(Heap),</li></ul><h3 id="②链接"><a href="#②链接" class="headerlink" title="②链接"></a>②链接</h3><ol><li>验证(Verification): 验证加载类的字节码, 验证成功则载入到方法区(Method Area), 验证项包括如下:<ul><li>变量使用前要初始化</li><li>方法调用与对象引用之间类型要匹配</li><li>访问私有数据和方法的规则没有违反</li><li>运行时堆栈没有溢出</li></ul></li><li>准备(Preparation): 这一阶段在方法区(Method Area)分配<ul><li>为类的static变量分配空间, 并赋 <strong>默认值</strong>, 比如<code>public static int value = 3</code>, 这一阶段value被赋值为0, static字段的初始化要到下个”初始化”阶段才开始执行;</li><li>为类的final常量分配空间, 赋 <strong>指定的值</strong>, 比如<code>public static final int value = 3</code>, 在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3;</li><li>除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的 <strong>方法表</strong>。</li></ul></li><li>解析(Resolution): 把类中的符号引用转换为直接引用, 对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。<br>解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）</li></ol><h3 id="③初始化-Initialization"><a href="#③初始化-Initialization" class="headerlink" title="③初始化(Initialization)"></a>③初始化(Initialization)</h3><p>主要对类变量(非final非static)进行初始化, 对于static的 Object类型(非基本类型)的成员也是在这个时候进行初始化,</p><p>这一阶段会执行<code>&lt; clinit &gt;</code> 方法,<br><code>&lt; clinit &gt;</code> 是编译期生成的, <strong>static代码块</strong> ,类变量直接赋值的代码 都会被放入<code>&lt; clinit &gt;</code>, 顺序与在java代码里出现顺序一致.<br>Java 虚拟机会通过加锁来确保类的 <code>&lt; clinit &gt;</code> 方法仅被执行一次。</p><p>JVM 规范枚举了下述多种触发初始化的情况(但不限于这几种):</p><ol><li>Java虚拟机启动时, 被标明为启动类(有main方法)会被初始化</li><li>初始化一个类的时候如果发现其父类还没用初始化, 则先初始化其父类, 这种属于 <strong>被动初始化</strong>;</li><li>用 new 明确创建一个类实例, 这里用的是 <code>new</code>字节码指令, 当且类还没有完成初始化;</li><li>首次对类的 static (同时必须满足非final)的成员属性进行读写, 一般是调getter/setter方法的时候, 对应字节码指令: <code>getstatic</code>, <code>putstatic</code></li><li>首次调用类的 static 方法, 对应字节码指令: <code>invokestatic</code></li><li>调用<code>Class.forName(&quot;xxx&quot;)</code>;</li></ol><p>比较四种指令<code>new</code>, <code>getstatic</code>, <code>putstatic</code>, <code>invokestatic</code>:</p><blockquote><p>除了<code>new</code>是主动初始化, 后面三种都是被动初始化.</p></blockquote><p>比较<code>Class.forName(&quot;xxx&quot;)</code> 和<code>ClassLoader.loadClass()</code>:</p><blockquote><p>作用都是返回Class对象;<br>Class.forName()只能通过应用加载器(AppClassLoader)创建Class对象, 还会调用类的static代码块;<br>ClassLoader.loadClass()可以通过自定义ClassLoader创建Class对象,</p></blockquote><h2 id="内部类的初始化"><a href="#内部类的初始化" class="headerlink" title="内部类的初始化"></a>内部类的初始化</h2><ul><li>对于非静态内部类, 不允许有static成员, 也不允许有static代码块;</li><li>静态内部类是可以有<code>static{}</code>代码块的, 我们在<code>new Outter()</code>的时候, 其内部类的static代码块并没有被调用到, 直到对内部类进行<code>getstatic</code>, <code>invokestatic</code>等操作的时候, 内部类的static代码块才会被调用, 才会初始化. 单例模式就用到了这个”延迟初始化”的特性.</li></ul><p>通过内部类实现单例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClassLoader-editing"><a href="#ClassLoader-editing" class="headerlink" title="ClassLoader @editing"></a>ClassLoader @editing</h2><p>JVM在加载(Loading)阶段依靠ClassLoader完成, ClassLoader的加载类过程主要使用<code>ClassLoader.loadClass(String name)</code>方法，<br>该方法中封装了中加载机制 <strong>双亲委派模式</strong> ：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。<br>加载完成后, 虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中, 在JVM堆中也创建一个 java.lang.Class 类的对象.</p><h3 id="ClassLoader分类"><a href="#ClassLoader分类" class="headerlink" title="ClassLoader分类"></a>ClassLoader分类</h3><p>Java 中的类加载器大致可以分成两类，一类是系统提供的”系统提供的ClassLoader”，另外一类则是由应用开发者编写的”应用程序类ClassLoader”。</p><ul><li>系统类类加载器（System ClassLoader）: 系统提供的类加载器主要有下面三个：<ul><li>启动类加载器(Bootstrap ClassLoader): 它负责加载存放在JDK\jre\lib\rt.jar里<code>java.*</code>开头的类;</li><li>扩展类加载器(Extension ClassLoader): 该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现,它负责加载JDK\jre\lib\ext目录中所有类库(如<code>javax.*</code>开头的类),开发者可以直接使用扩展类加载器</li><li>系统类加载器(System ClassLoader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，它加载classpath路径下的jar包和class文件。可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它。</li></ul></li><li>应用程序类加载器（Application ClassLoader): 该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现,它负责加载用户类路径CLASSPATH所指定的类,开发者可以直接使用该类加载器,如果应用程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器。<br>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 <code>object.getClass().getClassLoader()</code>方法就可以获取到此引用。</li></ul><blockquote><p>Class.forName() 默认了应用程序加载器(Laucher$AppClassLoader);<br>除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类;</p></blockquote><h3 id="ClassLoader树状组织结构"><a href="#ClassLoader树状组织结构" class="headerlink" title="ClassLoader树状组织结构"></a>ClassLoader树状组织结构</h3><p>除了 Bootstrap ClassLoader, 所有的类加载器都有一个父加载器(注意这里的”父子”关系并不是指继承关系)。通过 <code>classLoader.getParent()</code>方法可以得到。</p><ul><li>System ClassLoader的父加载器是 Extension ClassLoader，而 Extension ClassLoader的父加载器是 Bootstrap ClassLoader</li><li>开发者编写的 Application ClassLoader和普通Java类一样, 也需要另一个ClassLoader加载, 这个ClassLoader就是其父加载器, 一般来说，开发人员编写的类加载器的父类加载器是 System ClassLoader。</li></ul><p>类加载器通过这种方式组织起来，形成树状结构。树的根节点就是 Bootstrap ClassLoader。</p><p>看下图, 虚线上方的三种 ClassLoader都是JDK核心类库提供的, 虚线下方是 Application ClassLoader 和 用户自定义ClassLoader;</p><p><img src="/images/java/JVM-ClassLoader-Tree.png" alt=""></p><h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><blockquote><p>在介绍代理模式之前，首先需要说明一下 Java 虚拟机是如何判定两个 Java 类是相同的。<br>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p></blockquote><p>ClassLoader的加载类过程主要使用<code>loadClass(String, boolean)</code>方法，该方法中使用了了 <strong>双亲委派模式</strong>:<br>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先委托父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。<br>所以一个类加载的顺序是: Bootstrap, Extendsions, System, 自定义ClassLoader。<br>以<code>java.lang.Object</code>类的加载为例, 如果这个加载过程由Java应用自己的类加载器来完成的话, 很可能就存在多个版本的java.lang.Object类, 通过代理模式, 对于Java核心库的类的加载工作由引导类加载器来统一完成, 保证了 Java应用所使用的都是同一个版本的Java核心库的类</p><p><code>loadClass(String, boolean)</code>方法的双亲委派模式实现如下:</p><ol><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用<code>parent.loadClass(name, false);</code>）.或者是调用bootstrap类加载器来加载。</li><li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 <code>findClass()</code>方法来完成类加载</li></ol><h3 id="ClassLoader-API介绍"><a href="#ClassLoader-API介绍" class="headerlink" title="ClassLoader API介绍"></a>ClassLoader API介绍</h3><table><thead><tr><th style="text-align:left">method</th><th style="text-align:left">desc</th></tr></thead><tbody><tr><td style="text-align:left"><code>getParent()</code></td><td style="text-align:left">返回该类加载器的父类加载器。</td></tr><tr><td style="text-align:left"><code>loadClass(String name)</code></td><td style="text-align:left">加载名称为 name的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr><td style="text-align:left"><code>findClass(String name)</code></td><td style="text-align:left">查找名称为 name的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr><td style="text-align:left"><code>findLoadedClass(String name)</code></td><td style="text-align:left">查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。</td></tr><tr><td style="text-align:left"><code>resolveClass(Class&lt;？&gt; c)</code></td><td style="text-align:left">链接指定的 Java 类。</td></tr><tr><td style="text-align:left"><code>defineClass(String name, byte[] b, int off, int len)</code></td><td style="text-align:left">把字节数组 b中的内容转换成 Java 类，返回的结果是 java.lang.Class类的实例。这个方法被声明为 final的。</td></tr><tr><td style="text-align:left"><code>getResources(String path)</code></td><td style="text-align:left">获取classpath下面的文件, path是包名路径（例如<code>com/sina/ml</code>）, 返回的是classpath绝对路径的URL封装</td></tr></tbody></table><p>比较loadClass 和 defineClass方法:</p><ul><li>启动类的加载过程是通过调用 <code>loadClass()</code>来实现的, <code>loadClass()</code>被称为类的“初始加载器”(initiating loader), <code>loadClass()</code>里封装了前面提到的代理模式的实现;</li><li>真正完成类的加载工作是通过调用 <code>defineClass()</code>来实现的, <code>defineClass()</code>被称为类的“定义加载器”(defining loader), 如果要自定义一个ClassLoader, 需要重写findClass, 最后调用defineClass;</li><li>loadClass抛出ClassNotFoundException异常;</li><li>defineClass抛出NoClassDefFoundError异常;</li></ul><h3 id="实现一个ClassLoader"><a href="#实现一个ClassLoader" class="headerlink" title="实现一个ClassLoader"></a>实现一个ClassLoader</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1继承CLassLoader</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2重写findClass</span></span><br><span class="line">   <span class="keyword">protected</span> Class&lt;?&gt; findClass(String classFullName) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      String path = classFullName.repace(<span class="string">"."</span>, File.separatorChar) + <span class="string">".class"</span>; <span class="comment">// 装换为路径.class</span></span><br><span class="line">      InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">      ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">          baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">byte</span>[] bytes =  classBytes baos.toByteArray();</span><br><span class="line">      <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length); <span class="comment">// 3 defineClass抛出NoClassDefFoundError异常</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 测试classLoader</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader();  <span class="comment">// 自定义的加载器</span></span><br><span class="line">      MyClassLoader loader2 = Thread.currentThread().getContextClassLoader(); <span class="comment">// `Launcher$AppClassLoader`</span></span><br><span class="line"></span><br><span class="line">      Class&lt;?&gt; class1 = loader1.loadClass(<span class="string">"com.example.Sample"</span>); <span class="comment">// 4 loadClass抛出ClassNotFoundException异常</span></span><br><span class="line">      Class&lt;?&gt; class2 = loader2.loadClass(<span class="string">"com.example.Sample"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(class1 == class2) &#123; <span class="comment">// true, class1, class2指向同一个引用</span></span><br><span class="line">        System.out.println(<span class="string">"class1 == class2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示加载和隐式加载"><a href="#显示加载和隐式加载" class="headerlink" title="显示加载和隐式加载"></a>显示加载和隐式加载</h3><ul><li>显式加载：调用 <code>ClassLoader.loadClass(className)</code>与 <code>Class.forName(className)</code></li><li>隐式加载：<ul><li>创建类对象</li><li>使用类的静态域</li><li>创建子类对象</li><li>使用子类的静态域</li></ul></li></ul><p>注意还有其他特殊的隐式加载：</p><ul><li>在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class</li><li>在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class</li><li>在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件。</li></ul><p>参考原文：<a href="https://blog.csdn.net/jiyiqinlovexx/article/details/51090751" target="_blank" rel="noopener">https://blog.csdn.net/jiyiqinlovexx/article/details/51090751</a></p><h3 id="类加载器与-Web-容器"><a href="#类加载器与-Web-容器" class="headerlink" title="类加载器与 Web 容器"></a>类加载器与 Web 容器</h3><p>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。<br>以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。<br>这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。<br>这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p><p><img src="/images/java/JVM-JavaWeb-ClassLoader.png" alt=""></p><h3 id="JVM如何判断两个类是否相同"><a href="#JVM如何判断两个类是否相同" class="headerlink" title="JVM如何判断两个类是否相同"></a>JVM如何判断两个类是否相同</h3><p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。<br>只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。<br>比如网络上的一个Java类<code>org.classloader.simple.NetClassLoaderSimple</code>，javac编译之后生成字节码文件 NetClassLoaderSimple.class，<br>ClassLoaderA 和 ClassLoaderB 这两个类加载器并读取了 NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类，对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewworkClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//测试加载网络中的class文件</span></span><br><span class="line">            String rootUrl = <span class="string">"http://localhost:8080/httpweb/classes"</span>;</span><br><span class="line">            String className = <span class="string">"org.classloader.simple.NetClassLoaderSimple"</span>;</span><br><span class="line">            NetworkClassLoader ncl1 = <span class="keyword">new</span> NetworkClassLoader(rootUrl);</span><br><span class="line">            NetworkClassLoader ncl2 = <span class="keyword">new</span> NetworkClassLoader(rootUrl);</span><br><span class="line">            Class&lt;?&gt; clazz1 = ncl1.loadClass(className);</span><br><span class="line">            Class&lt;?&gt; clazz2 = ncl2.loadClass(className);</span><br><span class="line">            Object obj1 = clazz1.newInstance();</span><br><span class="line">            Object obj2 = clazz2.newInstance();</span><br><span class="line">            clazz1.getMethod(<span class="string">"setNetClassLoaderSimple"</span>, Object.class).invoke(obj1, obj2);  <span class="comment">// 抛出 ClassCaseException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Uncertain 实际代码测试结果:<br>相同的CL类, 不同的CL实例, 创建的class实例是==的</p>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-03b-GC案例分析</title>
      <link href="/12.Java/Advanced-Java.03b.GC%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/12.Java/Advanced-Java.03b.GC%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>➤ GC问题排查总结:</p><ul><li>GC常见问题: GC发生频繁, GC某个阶段耗时长</li><li>要定位问题, 首先看GC Log 和监控图, 确定如下:<ul><li>现在用的是哪种GC收集器? ( 该收集器的GC的触发条件? 每个阶段做了什么? 哪个阶段有STW?)</li><li>如果是GC频繁, 是哪个分代的GC频繁?<ul><li>如果是新生代GC: 新生对象太多, 新生代空间太小</li><li>如果是FGC: 有些FGC是因为新生代GC引起的</li></ul></li><li>如果是GC某个阶段耗时过长, 需要确认: 这个阶段主要做了什么? 导致耗时变长的原因之一是扫描对象过多</li></ul></li></ul><p>➤ 案例1: Minor 和Major GC 频繁, Major耗时较长, 且出现晋升的动态年龄阈值被降低的情况</p><ul><li>观察: 新生代和老年代使用率, 确定是因为大量新生对象(导致新生代GC频繁), JVM动态调整了晋升年龄, 导致大量低龄对象进入老年代.</li><li>分析: 如果新生代容量扩容1倍, 可以推算, MinorGC发生频率降低1倍, Minor GC的”扫描阶段”耗时增加1倍, 但”拷贝阶段”的耗时不会显著增加, 虽然Minor GC间隔增加, 但…</li><li>解决: 增大新生代容量</li></ul><p>➤ 案例2: 使用CMS, remark阶段STW超过1000ms</p><ul><li>分析: remark是CMS进行老年代回收的第3个步骤, remark阶段需要以新生代对象为根进行扫描(防止跨代引用), 所以新生代对象数量直接影响remark阶段的扫描耗时</li><li>CMS为了解决这个问题, 在remark阶段加入了一个”可中断的并发预清理阶段”(CMS-concurrent-abortable-preclean), 在”并发标记”阶段结束后, 如果Eden大小超过2M, 将会进入此阶段. 如果此阶段能等到一次Minor GC, 那么remark阶段需要扫描的对象数量将大大减少.</li><li><p>concurrent-abortable-preclean阶段是可中断的: 如果此阶段在超过<code>CMSMaxAbortablePrecleanTime</code> 秒后都没有等到一次Minor, 仍旧会进入remark;</p></li><li><p>案例中, 发现remark耗时过长的时候, 新生代使用率都很高, 所以可以判定remark耗时过长是因为新生代对象数量过多;</p></li><li>解决: CMS提供了<code>CMSScavengeBeforeRemark</code>参数, 强制在remark之前进行一次Minor GC;</li></ul><p>➤ 案例3: 日志里Full GC耗时过长</p><ul><li><p>分析:  GC日志里的Full GC不代表全堆GC, 而是指有”STW的GC”类型,</p></li><li><p>引起STW 的GC可能原因: 1)新生代晋升时,发现老年代剩余空间不够; 2)老年代空间大于%; 3)Perm代发生GC;</p></li><li>案例: 排除1, 因为没有 promotion failed; 排除2, 因为发生Full GC时老年代使用率不高; 并且Full GC之后 Perm代变大, 确定是第3种情况, perm不够用;</li><li>解决: 增加 permSize</li></ul><blockquote><p><strong>动态年龄计算</strong>：Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 = 64M，desired survivor = 32M，此时Survivor区中age&lt;=2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。</p><p>JVM引入动态年龄计算，主要基于如下两点考虑：</p><ol><li>如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件： a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。 b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</li><li>相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。</li></ol></blockquote><blockquote><p>@ref <a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化 - 美团技术团队</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-03a-GC</title>
      <link href="/12.Java/Advanced-Java.03a.GC/"/>
      <url>/12.Java/Advanced-Java.03a.GC/</url>
      
        <content type="html"><![CDATA[<h1 id="Minor-Major-Full-GC"><a href="#Minor-Major-Full-GC" class="headerlink" title="Minor/Major/Full GC"></a>Minor/Major/Full GC</h1><p>我们把新生代 / 老年代 / 全部堆空间(包括新生代,老年代)对应的GC, 分别称为 Minor GC / Major GC / Full GC,<br>三个不同内存区域的GC细节如下:</p><p><strong>① Minor GC</strong>: 在年轻代Young space(包括Eden区和Survivor区)中的垃圾回收称之为 <strong>Minor GC</strong>，或 <strong>Young GC</strong></p><ul><li>触发条件: 无法为一个新的对象分配空间时，比如 <em>Eden区满了</em> 。所以分配率越高，越频繁执行Minor GC。</li><li>STW: Minor GC会Stop the World，如果Eden区大部分对象都要被GC（这也是正常情形）Minor GC耗时可以基本不记，但是如果Eden区大部分对象都不符合GC条件，暂停时间将会长很多。</li><li>GC过程: 一般使用Copy GC, 具体步骤如下<ul><li>用new或者newInstance等方式创建的对象默认都是存放在Eden区，Eden满了触发Minor GC，把存活的对象放入S0，并清空Eden；</li><li>第二次Eden满了，会把Eden和S0的存活对象放入S1，并清空Eden和S0区；</li><li>在几次Minor GC后, 有些对象在S0/S1之间来回拷贝几次, 将会进入老年代(Tenured), 所以young GC后OldGen的占用量通常会有所升高；</li></ul></li></ul><p><img src="/images/java/jvm-gc-minor-gc.png" alt=""></p><blockquote><p>↑ Minor GC 图例: 左边是 Minor GC 前(黄色是垃圾对象, 红色是存活对象), 右边是 Minor GC 后</p></blockquote><p><strong>② Major GC</strong>: 清理老年代（Tenured space）</p><ul><li>触发条件: <em>老年代使用率超过某个阈值,默认大约90%</em>，许多Major GC是由Minor GC触发的。</li><li>STW: 一般Tracing GC在标记和清理阶段都会有STW, 具体STW耗时根据使用哪种GC收集器而定；</li><li>GC过程: 使用Mark-Sweep 或Mark-Compact算法；</li></ul><p><strong>③ Full GC</strong>: 清理整个堆，包括YoungGen / OldGen / PermGen（1.8之前） / Matespace(1.8+)等所有部分的全局范围的GC。</p><ul><li>触发条件：<ul><li>在将要进行(Young GC)时, 如果发现要晋升至OldGen的对象大小比OldGen剩余大小更大, 则不会触发young GC而是转为触发full GC; // 如果是用的CMS收集器可以在日志中看到 “promotion failed” 和 “concurrent mode failure”</li><li>当OldGen使用率大过某个比例; // ?</li><li>方法区满了触发(在Java8之前);</li><li>Metaspace Space使用达到MaxMetaspace阈值(Java8+)；</li><li>调用<code>System.gc()</code>: 此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数</li><li>当执行<code>jmap -histo:live</code>或者<code>jmap -dump:live</code></li></ul></li><li>STW: 视不同的GC收集器而定</li><li>GC过程: 同上</li></ul><blockquote><p>需要明白的一点， 我们在jstat或GC日志中看不到Minor GC/ Major GC / Full GC这些名词, 这些术语无论是在 JVM 规范还是在垃圾收集研究论文中都没有正式的定义.</p><ul><li>在jstat中, GC事件只分为两种: Young GC和 Full GC,  这里把Major GC和Full GC都算作了Ful GC。实际上<br>需要注意的是jstat返回的FGC并不是真正的Full GC发生次数, CMS的老年代GC分两个阶段(初始标记和Remark)都会Stop the World, 这两次STW在jstat里被视作了两次Full GC，所以jstat的FGC更接近于统计“Stop the World”的次数；</li><li>在GC日志中, GC事件是由GC回收器命名的, 比如ParNew是清理年轻代(等同于Young GC),  日志里出现”CMS”等字样的都是指老年代的清理事件。</li></ul></blockquote><h1 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h1><p>主要GC算法有Copy GC 和Tracing GC, 后者又根据是否压缩内存分为Mark-Sweep 和 Mark-Compact GC算法.</p><h2 id="Copy-GC-算法"><a href="#Copy-GC-算法" class="headerlink" title="Copy GC 算法"></a>Copy GC 算法</h2><p>Copy GC算法(用于新生代的Minor GC): 把空间分成两部分，一个叫分配空间(Allocation Space)，一个是幸存者空间(Survivor Space)。创建新的对象的时候都是在分配空间里创建。在GC的时候，把分配空间里的活动对象复制到Survivor Space，把原来的Allocation Space全部清空。然后把这两个空间交换角色。</p><ul><li>Copy GC是从GC roots对象开始对象图的深度优先遍历，访问到一个对象则在Survivor Space分配一个与该对象大小相同的一块内存，然后把这个对象的所有数据都拷贝过去（copy data），然后把它的visited标记为true，它的forwarding记为新的地址。</li><li>当存活对象少的时候，Copying GC算法的效率就有很高的吞吐量。Copying GC 是典型的采用空间换时间的方式来提升性能。</li><li>Copying GC可以避免内存碎片。</li></ul><h2 id="Tracing-GC-算法"><a href="#Tracing-GC-算法" class="headerlink" title="Tracing GC 算法"></a>Tracing GC 算法</h2><p>Tracing GC算法(用于老年代的Major GC), 根据是否压缩内存又分两种 <strong>Mark-Sweep</strong>和 <strong>Mark-Compact</strong><br>在介绍Tracing GC之前, 需要先熟悉几个名词, 可达性分析和GC Roots：</p><p>判断对象存活的两种方法:</p><ul><li>① <strong>引用计数法</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题：比如对象a和b互相有一个对方的引用，虽然两个对象都没用了但是计数却不为0。<br>现在主流的JVM无一使用引用计数方式来实现Java对象的自动内存管理，但Py和PHP似乎是用的这种方法；</li><li>② <strong>可达性分析法</strong>（Reachability Analysis）：它的处理方式就是，设立若干种roots对象，roots对象作为起点在图中进行深度优先遍历，每访问到一个对象，则该对象称为“可达对象”，也就是还活着的对象。否则就是不可达对象，可以被回收。<br>JVM里适用于老年代的GC收集器都使用了”可达性分析”来判断对象是否存活,是否可以回收</li></ul><blockquote><p>什么是 <strong>GC Roots</strong>：对于一个正在回收的空间，所有不在这个空间里又指向本空间中的对象的引用的集合就是“GC roots”。<br>一般而言，GC Roots 包括（但不限于）如下几种：</p><blockquote><ol><li>Java 方法栈桢中的局部变量</li><li>已启动且未停止的Java线程以及线程栈帧内引用的对象</li><li>方法区中类静态属性实体引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li><li>由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的</li></ol></blockquote></blockquote><h3 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h3><p><strong>标记-清除算法</strong> (Mark-Sweep)如同它的名字一样，算法分为“标记”和“清除”两个阶段：</p><ul><li>mark，从 root 开始进行树遍历，每个访问的对象标注为「使用中」</li><li>sweep，扫描整个内存区域，对于标注为「使用中」的对象去掉该标志，对于没有该标注的对象直接回收掉</li></ul><p><img src="/images/java/jvm-gc-mark-sweep.png" alt="标记-清除算法示意图"></p><p>标记-清除算法最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：</p><ul><li>效率问题，标记和清除两个过程的效率都不高, 回收时间与 heap 大小成正比；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h3 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h3><p><strong>标记-整理算法</strong> (Mark-Compact):</p><ul><li>mark: 从 root 开始进行树遍历，每个访问的对象标注为「使用中」</li><li>compact: 扫描整个内存区域，把标注为「使用中」的对象移动到内存另一端，没有标注的对象回收掉。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</li></ul><p><img src="/images/java/jvm-gc-mark-sweep-vs-mark-compact.png" alt="mark-sweep vs mark-compact"></p><h1 id="GC收集器"><a href="#GC收集器" class="headerlink" title="GC收集器"></a>GC收集器</h1><p>GC收集器是上面提到的几种GC算法的具体实现,  有些GC收集器只能用于新生代(比如ParNew), 有些只用于老年代(比如CMS), 有些可以同时用于两个代(Serial);<br>对于每种GC收集器, 都要注意以下几个问题:</p><p>a. 这种GC收集器可以用于哪个区, 如何启用;<br>b. 实现是什么样的, 分几个阶段, 哪些阶段有STW;<br>c. 并行(Parallel)还是并发(Concurrent)的, 注意“并发”和“并行”的不同：</p><ol><li><p><strong>并行</strong>（Parallel）：使用多个线程同时执行GC任务，但此时用户线程仍然处于等待状态。并行GC的两个例子，一个是ParNew，一个是parallel scavenge。这两种GC的特点都是启动了多个GC线程来做垃圾回收。</p><blockquote><p>名字Par(allel)开头的一般都是并行GC, 多个线程同时进行GC, 但仍会停顿;</p></blockquote></li><li><p><strong>并发</strong>（Concurrent）：指用户任务与GC任务同时执行（但不一定是并行的，可能会交替执行），用户任务不会停顿。并发GC的一个典型例子，是CMS，看它的名字就知道了Concurrent Mark Sweep。</p><blockquote><p>名字C(oncurrent)开头的是并发GC, GC线程和工作线程并发的执行;</p></blockquote></li></ol><p>下图是说明了不同分代可以使用的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用:<br><img src="/images/java/JVM-GC-Generation.png" alt=""></p><p><strong>几种常见的GC收集器组合</strong>：</p><blockquote><p>新生代Parallel + 老年代Parallel Old<br>新生代ParNew + 老年代CMS<br>新生代, 老年代都使用G1</p></blockquote><p><strong>下面介绍7种GC收集器</strong> :</p><p>① <strong>串行回收器</strong>（Serial Garbage Collector）, 可以用于新生代和老年代, 下面都使用Serial New和Serial Old表示两代的GC回收器</p><ul><li>通过JVM参数<code>-XX:+UseSerialGC</code>可以使用串行垃圾回收器。</li><li>特性：<ul><li>新生代、老年代都可以使用串行回收器, 新生代复制算法, 老年代标记-压缩算法.</li><li>串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，可能会产生较长的停顿，所以可能不适合服务器环境。它依然是HotSpot虚拟机运行在Client模式下的默认的新生代收集器。</li></ul></li></ul><p>② <strong>ParNew回收器</strong>：Serial收集器新生代的多线程版本, 只适用于新生代.</p><ul><li>-XX:+UseParNewGC（new代表新生代，所以适用于新生代），-XX:ParallelGCThreads 线程数量</li><li>特性:<ul><li>ParNew收集器就是Serial收集器的多线程版本，它也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码</li><li>ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，原因是: 除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作</li></ul></li></ul><p>③ <strong>并行回收器</strong>（Parallel Garbage Collector）: 可以用于新生代和老年代, 新生代是Parallel Scavenge 收集器( 复制算法), 老年代是Parallel Old( 标记整理算法).</p><ul><li>JVM参数:<ul><li><code>-XX:+UseParallelGC</code>：新生代使用Parallel收集器 + 老年代使用串行收集器</li><li><code>-XX:+UseParallelOldGC</code>：新生代+老年都使用Parallel</li></ul></li><li>特性:<ul><li>使用多线程进行扫描堆并标记对象, 缺点是在minor和full GC的时候都会Stop the world</li><li>CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。</li></ul></li></ul><p>④ <strong>CMS</strong>(Concurrent Mark Sweep), 仅适用于老年代的回收器, 是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于“标记-清除”算法实现的。</p><ul><li>JVM参数:<ul><li>通过JVM参数<code>-XX:+UseConcMarkSweepGC</code> 打开</li><li><code>-XX:+ExplicitGCInvokesConcurrent</code> : 使<code>System.gc()</code>触发的Full GC改为CMS，防止过长的STW时间</li></ul></li><li>特性:<ul><li>只适用于老年代GC, 新生代可以搭配ParNew收集器;</li><li>特点是尽可能降低STW停顿，但是因为与用户任务一起并发进行GC，所以吞吐量下降;</li><li>“初始标记”和”重新标记”阶段仍然Stop the World, 但耗时最长的”并发标记”和”并发清除”过程收集器线程都可以与用户线程一起”并发的”工作;</li><li>因为是Mark-Sweep的, GC后有内存碎片, 所以很多情况下Old Gen有足够空间但是仍会由Minor GC触发Major GC;</li><li>当CMS失败出现Concurrent Mode Failure会转换到Serial Old, 将导致非常长时间的Stop The World</li></ul></li><li>实现步骤:<ol><li>初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象（标记直接被GC root引用 或者 被年轻代存活对象所引用的所有对象），速度很快，<strong>需要“Stop The World”</strong>。</li><li>并发标记（CMS concurrent mark）: 由上一阶段标记过的”可达对象”出发进行标记（遍历老年代），用户任务不停顿</li><li>预清理(CMS preclean): 仍旧与用户任务并行, 主要是标记由新生代晋升的对象, 预清理阶段还可能包括一个”可中断预清理”等待一次 Minor GC, 详见 [GC日志实例分析];</li><li>重新标记（CMS remark）: 这一阶段会暂停所有用户线程，因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象（变为可达），这个阶段需要重新标记出此类对象，防止在下一阶段被清理掉。特别需要注意一点，这个阶段是 <strong>以新生代中对象为根</strong> 来判断对象是否存活的（CMS只做老年代的Major GC，但判断老年代对象是否被引用到需要扫描新生代对象）详见[GC日志实例分析]部分的解释。<strong>该阶段会“Stop The World”</strong>；</li><li>并发清除（CMS concurrent sweep）：用户任务不停顿</li></ol></li></ul><blockquote><p>@ref <a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p></blockquote><p>⑤ <strong>G1回收器</strong> : 在JDK 7u4版本被正式推出，用于逐步替换掉CMS收集器, G1适用于新生代和老年代:</p><ul><li>通过参数<code>-XX:+UseG1GC</code>来启用</li><li>特性:<ul><li>采用标记整理（Mark-Compact）算法，不会产生内存空间碎片。</li><li>可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li></ul></li><li>实现步骤:<ul><li>G1将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，每个区域都可以充当 Eden 区、Survivor 区或者老年代的一部分。</li><li>建立可预测的停顿时间模型，G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大（死亡对象最多）的Region（这也就是Garbage-First名称的来由）。</li><li>GC步骤: @todo 重新整理<ul><li>初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，<strong>此阶段需要STW</strong>，但耗时很短。</li><li>并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li><li>最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs里面，最终标记阶段需要把 Remembered Set Logs的数据合并到 Remembered Set中，<strong>这阶段需要STW</strong>。</li><li>筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul></li></ul></li></ul><p>⑥ <strong>ZCG</strong>: ZGC是JDK11引入的, 特点是极短的STW时间, 无论堆的大小(上T级的情况)能保证10ms以下的JVM停顿。</p><ul><li>特性:<ul><li>采用标记整理（Mark-Compact）算法</li></ul></li><li>实现细节:<ul><li>ZGC将堆划分为Region作为清理，移动，以及并行GC线程工作分配的单位。不过G1一开始就把堆划分成固定大小的Region，而ZGC 可以有2MB，32MB，N× 2MB 三种Size Groups，动态地创建和销毁Region，动态地决定Region的大小。所以ZGC能更好的处理大对象的分配。</li><li>ZGC的堆没有分代</li><li>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</li><li>GC步骤:<ol><li>Pause Mark Start －初始停顿标记</li><li>Concurrent Mark －并发标记</li><li>Relocate － 移动对象: 将被标记的对象（仍在使用的）移动到新的Region</li><li>Remap － 修正指针</li></ol></li></ul></li></ul><p>下图是SPECjbb 2015基准测试，在128G的大堆下，最大停顿时间只有 1.68ms, 相比之下Parallel和G1都超过了200ms, 最坏高达800ms<br><img src="/images/java/JVM-ZGC-Pause-Time-Test.png" alt=""></p><p>参考: <a href="https://blog.csdn.net/gupao123456/article/details/82355512" target="_blank" rel="noopener">一文读懂Java 11的ZGC为何如此高效 - CSDN博客</a> @ref</p><h1 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h1><p>GC策略的评价指标</p><ol><li>吞吐量: 系统的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间 = 应用程序耗时 + 总GC耗时。<br>如果系统运行了100分钟，全部GC耗时1分钟，则系统吞吐量=99%</li><li>停顿时间： 是否需要STW，以及STW耗时多少</li><li>垃圾回收频率: 一般而言，频率越低越好，通常增大堆空间可以有效降低垃圾回收发生的频率，但是会增加回收时产生的停顿时间。</li><li>反应时间: 当一个对象成为垃圾后，多长时间内，它所占用的内存空间会被释放掉。</li></ol><p>给出一些经验性的参考值:</p><ul><li>Young CG发生频率很高, 可能几秒一次, 每次YGC的STW耗时很短, 可能不超过10ms;</li><li>Major GC 正常情况大约1-2次/天, 如果几小时就出现一次 Major GC属于不正常,</li><li>Full GC尽量杜绝</li></ul><p><strong>一些参考案例:</strong></p><ul><li><a href="https://www.jianshu.com/p/5524fce8b08f" target="_blank" rel="noopener">探索StringTable提升YGC性能 - 简书</a><ul><li>StringTable 过大导致的YGC时间过长 // String Table在Young Gen ?</li></ul></li><li><a href="https://tech.meituan.com/jvm_optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化</a><ul><li>案例1: 优化TP99、TP90时间</li><li>案例2: 优化耗时波动</li><li>案例3: 避免Full GC</li><li>25ms GC的影响有多大</li></ul></li><li><a href="https://mp.weixin.qq.com/s/FeHquGVIRiF6oC9BEVOWCg" target="_blank" rel="noopener">如何降低young gc时间</a><ul><li>Hystrix信号量+RPC异步化, 减少线程池数目, 降低YGC</li></ul></li><li><a href="https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications" target="_blank" rel="noopener">Garbage Collection Optimization for High-Throughput and Low-Latency Java Applications</a></li></ul><h1 id="GC日志解读"><a href="#GC日志解读" class="headerlink" title="GC日志解读"></a>GC日志解读</h1><p>GC日志相关参数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br></pre></td></tr></table></figure></p><h2 id="一般GC日志格式"><a href="#一般GC日志格式" class="headerlink" title="一般GC日志格式"></a>一般GC日志格式</h2><p>图1: Young GC日志格式解释如下(ParallelGC):</p><p><img src="/images/java/JVM-GC-Minor-Parallel.png" alt=""></p><p>图2: Full GC日志格式解释如下(ParallelGC):</p><p><img src="/images/java/JVM-GC-Full-Parallel.png" alt=""></p><h2 id="GC日志实例分析"><a href="#GC日志实例分析" class="headerlink" title="GC日志实例分析"></a>GC日志实例分析</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><strong>一次YGC和Full GC:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]</span><br><span class="line"># 33.125 表示从Java虚拟机启动以来经过的秒数</span><br><span class="line"># DefNew 表示新生代用了Serial收集器, ParNew表示ParNew收集器, PSYoungGen表示Parallel Scavenge收集器</span><br><span class="line"># 3324K-&gt;152K(3712K) 表示 GC前新生代大小-&gt;GC后新生代大小(新生代总大小)</span><br><span class="line"># 3324K-&gt;152K(11904K) 表示 GC前堆大小-&gt;GC后堆大小(堆总大小)</span><br><span class="line"># 0.0025925 secs 表示此次新生代GC耗时2ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</span><br><span class="line"># 100.667 表示从Java虚拟机启动以来经过的秒数</span><br><span class="line"># Full GC 表示这是一次Full GC</span><br><span class="line"># [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 老年代GC前-&gt;后大小</span><br><span class="line"># 4603K-&gt;210K(19456K) 表示堆GC前-&gt;后</span><br><span class="line"># [Times: user=0.01 sys=0.00, real=0.02 secs] 表示耗时20ms</span><br></pre></td></tr></table></figure><h3 id="ParNew-CMS收集器"><a href="#ParNew-CMS收集器" class="headerlink" title="ParNew + CMS收集器"></a>ParNew + CMS收集器</h3><p><strong>正常的CMS GC日志, 可以看到CMS标记的三个阶段:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始标记, STW</span><br><span class="line">15578.148: [GC [1 CMS-initial-mark: 6294851K(20971520K)] 6354687K(24746432K), 0.0466580 secs] [Times: user=0.04 sys=0.00, real=0.04 secs]</span><br><span class="line"></span><br><span class="line"># 并发标记, 从CG Root出发开始标记</span><br><span class="line">15578.195: [CMS-concurrent-mark-start]</span><br><span class="line">15578.333: [CMS-concurrent-mark: 0.138/0.138 secs] [Times: user=1.01 sys=0.21, real=0.14 secs]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 预清理</span><br><span class="line">15578.334: [CMS-concurrent-preclean-start]</span><br><span class="line">15578.391: [CMS-concurrent-preclean: 0.056/0.057 secs] [Times: user=0.20 sys=0.12, real=0.06 secs]</span><br><span class="line"></span><br><span class="line"># 可中断预清理</span><br><span class="line">15578.391: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line">15581.905: [CMS-concurrent-abortable-preclean: 3.506/3.514 secs] [Times: user=11.93 sys=6.77, real=3.51 secs]</span><br><span class="line"></span><br><span class="line"># 重新标记, STW</span><br><span class="line">15582.032: [weak refs processing, 0.0027800 secs]15582.035: [class unloading, 0.0033120 secs]15582.038: [scrub symbol table, 0.0016780 secs]15582.040: [scrub string table, 0.0004780 secs] [1 CMS-remark: 6299829K(20971520K)] 6348225K(24746432K), 0.1365130 secs] [Times: user=1.24 sys=0.00, real=0.14 secs]</span><br><span class="line"></span><br><span class="line"># 并发清理</span><br><span class="line">15582.043: [CMS-concurrent-sweep-start]</span><br><span class="line">15590.327: [CMS-concurrent-sweep: 8.193/8.284 secs] [Times: user=30.34 sys=16.44, real=8.28 secs]</span><br></pre></td></tr></table></figure><ul><li><p>阶段1：Initial Mark, 这个是 CMS 两次 stop-the-wolrd 事件的其中一次，这个阶段的目标是：标记那些直接被 GC root 引用或者被年轻代存活对象所引用的所有对象，</p><blockquote><p>40.146: [GC [1 CMS-initial-mark: 26386K(786432K)] 26404K(1048384K), 0.0074495 secs]</p></blockquote></li><li><p>阶段2：并发标记, 在这个阶段 Garbage Collector 会根据上个阶段找到的 GC Roots 遍历查找，标记所有存活的对象。这一阶段，Garbage Collector 与用户的应用程序并发运行。</p><blockquote><p>40.683: [CMS-concurrent-mark: 0.521/0.529 secs]</p></blockquote></li><li><p>阶段3：Concurrent Preclean, 这也是一个并发阶段，与应用的线程并发运行，不会 stop-the-wolrd 。这一阶段会查找前一阶段中从新生代晋升或者有更新的对象。这一阶段可以减少 stop-the-world 的remark阶段的工作量</p><blockquote><p>40.701: [CMS-concurrent-preclean: 0.017/0.018 secs]</p></blockquote></li><li><p>阶段4：Concurrent Abortable Preclean (可中断的预清理) 这也是一个并发阶段，同样不会不会 stop-the-wolrd 。该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。此阶段在 Eden区使用超过2M时启动，当然 2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了 Minor GC，或者等了超过<code>CMSMaxAbortablePrecleanTime</code>的时间(默认5s)都没有发生 Minor GC，则会进入下一阶段 – Remark。// 该阶段尽量等一次Minor GC来减少新生代对象数量，减少remark阶段需要扫描新生代对象的数量，减少remark阶段 STW耗时。 通过<code>CMSScavengeBeforeRemark</code>参数，可以在这一阶段强制进行一次Minor GC。</p><blockquote><p>15581.905: [CMS-concurrent-abortable-preclean: 3.506/3.514 secs] [Times: user=11.93 sys=6.77, real=3.51 secs]</p></blockquote></li><li><p>阶段5：Remark, 这是第二个 STW 阶段，暂停所有用户线程，从GC Root开始重新扫描整堆，标记存活的对象。需要注意的是，虽然CMS只回收老年代的垃圾对象，但是这个阶段依然需要扫描新生代，因为很多GC Root都在新生代，而这些GC Root指向的对象又在老年代，这称为“跨代引用”。</p><blockquote><p>15582.032: [weak refs processing, 0.0027800 secs]15582.035: [class unloading, 0.0033120 secs]15582.038: [scrub symbol table, 0.0016780 secs]15582.040: [scrub string table, 0.0004780 secs] [1 CMS-remark: 6299829K(20971520K)] 6348225K(24746432K), 0.1365130 secs] [Times: user=1.24 sys=0.00, real=0.14 secs]</p></blockquote></li><li><p>阶段6：Concurrent Sweep，并发清理，不需要 STW，需要注意的： 因为CMS是 Mark-Sweep算法, 仍会存在内存碎片。</p><blockquote><p>15590.327: [CMS-concurrent-sweep: 8.193/8.284 secs] [Times: user=30.34 sys=16.44, real=8.28 secs]</p></blockquote></li></ul><blockquote><p>@ref 参考: <a href="https://mp.weixin.qq.com/s/Ukm3xcp4YLHDMJF-hVTczw" target="_blank" rel="noopener">JVM 之 ParNew 和 CMS 日志分析</a></p></blockquote><p><strong>有GC问题的日志例子:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">106.641: [GC 106.641: [ParNew (promotion failed): 14784K-&gt;14784K(14784K), 0.0370328 secs]106.678: [CMS106.715: [CMS-concurrent-mark: 0.065/0.103 secs] [Times: user=0.17 sys=0.00, real=0.11 secs]</span><br><span class="line"># ParNew (promotion failed) 表示新生代GC过程中, 对象晋升到老年代失败, 因为需要晋升至老年代的对象超过了老年代的可用大小</span><br><span class="line"># 这种情况下会触发Full GC, 见下</span><br><span class="line"></span><br><span class="line">0.195: [GC 0.195: [ParNew: 2986K-&gt;2986K(8128K), 0.0000083 secs]0.195: [CMS0.212: [CMS-concurrent-preclean: 0.011/0.031 secs] [Times: user=0.03 sys=0.02, real=0.03 secs]</span><br><span class="line">(concurrent mode failure): 56046K-&gt;138K(57344K), 0.0271519 secs] 59032K-&gt;138K(65472K), [CMS Perm : 2079K-&gt;2078K(12288K)], 0.0273119 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]</span><br><span class="line"># 第二行表示在cms-preclean阶段发生了 concurrent mode failure,</span><br><span class="line"># CMS失败往往意味着JVM会退回到 Serial Old 收集器进行回收, 造成较长的STW</span><br></pre></td></tr></table></figure><p>上面是因为执行 ParNew GC的时候, 因为需要晋升至老年代的对象超过了老年代的可用大小, 所以 promotion failed, 而触发了 Full GC,<br>还存在一种情况, 老年代大小足够的情况下仍然会触发 promotion failed, 可以通过 <code>-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5</code> 参数, 在5次 Full GC后进行一次 Compaction操作避免内存碎片.</p><p><strong>总结 CMS GC常见的两种错误解决方案:</strong></p><ol><li>promotion failed<br>解决办法：<code>-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5</code> 或者 调大新生代或S0/S1空间;</li><li>concurrent mode failure<br>解决办法： 或增加老年带的空间, 或者调节<code>+XX:CMSInitiatingOccupancyFraction=70</code>使老年代使用更高比例（这里是70%）后才开始CMS GC;</li></ol><h1 id="GC引起的Error"><a href="#GC引起的Error" class="headerlink" title="GC引起的Error"></a>GC引起的Error</h1><p>什么代码会导致GC引起的内存错误： <code>OutOfMemoryError:Java Heap</code>, <code>OutOfMemoryError:PermGen</code>, <code>OutOfMemoryError:Matespace</code>, <code>OutOfMemoryError: Direct buffer memory</code> ? (以及堆栈错误<code>StackOverflowError</code>)</p><ul><li>Java虚拟机栈和本地方法栈: 在JVM规范中，对Java虚拟机栈规定了两种异常：<ol><li>如果线程请求的栈大于所分配的栈大小，则抛出 StackOverFlowError错误，比如进行了一个不会停止的递归调用；</li><li>如果虚拟机栈是可以动态拓展的，拓展时无法申请到足够的内存，则抛出 OutOfMemoryError错误。</li></ol></li><li>堆内存: OutOfMemoryError</li><li>直接内存: 在JDK1.4中引入的NIO使用Native函数库在堆外内存上直接分配内存，但直接内存不足时，也会导致OOM。</li><li>方法区: 随着Metaspace元数据区的引入，方法区的OOM错误信息也变成了 “java.lang.OutOfMemoryError:Metaspace”。<br>对于旧版本的Oracle JDK，由于永久代的大小有限，而JVM对永久代的垃圾回收并不积极，如果往永久代不断写入数据，例如String.Intern()的调用，在永久代占用太多空间导致内存不足，也会出现OOM的问题，对应的错误信为 “java.lang.OutOfMemoryError:PermGen space”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-02d-JVM分析工具</title>
      <link href="/12.Java/Advanced-Java.02d.JVM%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/12.Java/Advanced-Java.02d.JVM%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK提供的命令行"><a href="#JDK提供的命令行" class="headerlink" title="JDK提供的命令行"></a>JDK提供的命令行</h2><blockquote><p>以下每个工具都可以 <code>cmd --help</code>的方式查看说明</p></blockquote><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>查看当前用户启动jvm进程</p><ul><li><code>jps -m</code>: 显示传递给Main方法的参数</li><li><code>jps -l</code>: 显示Java进程的完整包名</li><li><code>jps -v</code>: 显示JVM的参数</li><li><code>jps -lvm</code></li></ul><blockquote><p>jvm启动后会在<code>/tmp/hsperfdata_&lt;username&gt;/</code>目录下生成一个pid为名的文件, 这个目录由<code>-Djava.io.tmpdir</code>参数指定, 如果因为某些原因这个文件没有生成, jps也就不起作用<br>文件内容:?</p></blockquote><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>查看每个分代的使用率和GC次数，在没有GUI图形的服务器上是运行期定位虚拟机性能问题的首选。</p><p>注意jstat返回只有 YGC和 FGC，并不区分 Major GC和 Full GC；<br>jstat和<code>-XX:+PrintGCDetails</code>提供的结果有不同，在于：<br>jstat无法统计并行的任务，比如<code>UseConcMarkSweepGC</code>情况下，初始mark和remark阶段都会有 Stop the World的耗时，jstat的输出会把两个STW阶段视作两次 Full GC；<br>而在GC日志里可以清楚的看到 UseConcMarkSweepGC情况下，每个阶段的耗时。</p><p>例如, 如果配置了CMS垃圾回收器，那么 jstat中的 FGC增加1并不表示就一定发生了 Full GC，很有可能是发生了老年代的 CMS GC，而且每发生一次老年代的 CMS GC，jstat中的 FGC就会+2</p><p>常用jstat命令：</p><ul><li><code>jstat -gc pid</code>: 统计JVM内存（Young/Old/Method）的已使用/总空间大小，以及Young GC和Full GC发生次数和耗时；</li><li><code>jstat -gcutil pid</code> : 统计JVM内存（Young/Old/Method）的占用百分比，以及Young GC和Full GC发生次数和耗时；</li><li><code>jstat -class pid</code> : 类装载、卸载数量、总空间, 及类装载所耗费的时间</li><li><code>jstat -gccapacity pid</code> : 查看三代（young,old,perm）对象的使用量大小(字节)</li><li><code>jstat -gcnew pid</code>:  年轻代的容量和GC情况</li><li><code>jstat -gcnewcapacity pid</code>:</li><li><code>jstat -gcold pid</code>:  老年代的容量和GC情况</li><li><code>jstat -gcoldcapacity pid</code>:</li></ul><blockquote><p>如果用jstat查看远程机器上的jvm, 需要在远程主机启动jstatd(详见 <strong>jstatd</strong>)</p><blockquote><p>jstat -gc pid@remote_IP # 用jstat连接远端的jstatd</p></blockquote></blockquote><h4 id="jstat-gc返回列解析"><a href="#jstat-gc返回列解析" class="headerlink" title="jstat -gc返回列解析"></a>jstat -gc返回列解析</h4><p><strong>示例1</strong>: attaches 到pid=14542的进程上, -h3表示每三行打印一次列名称, 采样间隔5s<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat -gc -h3 14542 5s</span><br><span class="line"></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">10240.0 10752.0  0.0    0.0   133120.0 10215.4   87552.0     9225.3   27904.0 26661.4 3328.0 3007.2     20    0.305  13      1.410    1.715</span><br><span class="line">10240.0 10752.0  0.0    0.0   133120.0 10659.2   87552.0     9225.3   27904.0 26661.4 3328.0 3007.2     20    0.305  13      1.410    1.715</span><br><span class="line">10240.0 10752.0  0.0    0.0   133120.0 10659.2   87552.0     9225.3   27904.0 26661.4 3328.0 3007.2     20    0.305  13      1.410    1.715</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">10240.0 512.0   0.0    0.0   133120.0   79.2    87552.0     9224.0   27904.0 26662.1 3328.0 3007.2     21    0.318  14      1.522    1.840</span><br><span class="line">10240.0 512.0   0.0    0.0   133120.0  523.0    87552.0     9224.0   27904.0 26662.1 3328.0 3007.2     21    0.318  14      1.522    1.840</span><br><span class="line">10240.0 512.0   0.0    0.0   133120.0  523.0    87552.0     9224.0   27904.0 26662.1 3328.0 3007.2     21    0.318  14      1.522    1.840</span><br></pre></td></tr></table></figure></p><p><strong>每列说明如下</strong>:</p><ul><li>S0C: S0 Capacity(KB)</li><li>S0U: S0 Utilization(KB)</li><li>EC: Current eden space capacity (kB).</li><li>EU: Eden space utilization (kB).</li><li>MC: Metaspace capacity (kB).</li><li>MU: Metacspace utilization (kB).</li><li>YGC:  从JVM进程启动到当前采样，发生young gen GC总次数</li><li>YGCT: 从JVM进程启动到当前采样，young gen GC总消耗时间(秒)， 相邻两次相减就是该次耗时</li><li>FGC: 从JVM进程启动到当前采样，发生full GC总次数</li><li>FGCT: 从JVM进程启动到当前采样，full GC总消耗时间(秒)， 相邻两次相减就是该次耗时</li></ul><blockquote><p>注: 上面是java 1.8的jstat的返回值, 可以看到有Metaspace(元空间), 如果是java 1.7或更老版本, 则没有MC/MU, 而是PC/PU:</p><ul><li>PC：Perm Capacity(KB)</li><li>PU: Perm Utilization(KB)</li></ul></blockquote><h4 id="jstat-gcutil返回列解析"><a href="#jstat-gcutil返回列解析" class="headerlink" title="jstat -gcutil返回列解析"></a>jstat -gcutil返回列解析</h4><p><strong>示例2</strong>: attaches 到pid=14542的进程上, -h3表示每三行打印一次列名称, 采样间隔250ms<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat -gcutil -h3 14542 3s</span><br><span class="line"></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 16.35   0.00  94.62  63.31  97.41  94.84   4522   83.661    32    0.931   84.592</span><br><span class="line"> 16.35   0.00  95.52  63.31  97.41  94.84   4522   83.661    32    0.931   84.592</span><br><span class="line"> 16.35   0.00  96.92  63.31  97.41  94.84   4522   83.661    32    0.931   84.592</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  14.90   1.43  63.31  97.41  94.84   4523   83.678    32    0.931   84.609</span><br><span class="line">  0.00  14.90   2.65  63.31  97.41  94.84   4523   83.678    32    0.931   84.609</span><br><span class="line">  0.00  14.90   3.68  63.31  97.41  94.84   4523   83.678    32    0.931   84.609</span><br></pre></td></tr></table></figure></p><p>上面发生了一次Young GC, S0从16.35%降到0%, S1从0%增长到14.90%, Eden从96.92%降到1.43, 耗时0.017s</p><p>以上参考Oracle Java 8 jstat手册：<br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">jstat</a></p><h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>jstatd是一个[[../@project/Java-RMI]]的server，它可以监控Hotspot的JVM的启动和结束，同时提供接口可以让远程机器连接到JVM。 比如 jstat / JVisualVM 都可以通过jstatd来远程观察JVM的运行情况。<br>在远程服务器上启动jstatd: <code>nohup jstatd -J-Djava.security.policy=/home/xxx/jstatd.all.policy -J-Djava.rmi.server.hostname=192.168.0.2 -p 1099 &amp;</code> , 1099是jstatd的默认端口</p><p>jstatd.all.policy内容如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant codebase &quot;file:$&#123;java.home&#125;/../lib/tools.jar&quot; &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>查看jvm进程的线程状态, 也可以做线程的dump,<br><code>jstack pid</code> : 查看当前所有线程的运行栈, 包括线程当前状态(blocked, waitting), 线程占用了哪个对象锁, 线程在等待哪个对象锁;</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>查看堆内存的情况, 也可以生成堆内存的dump信息,<br>jmap dump会触发Full GC, 所以在生产环境要小心使用.</p><ul><li><code>jmap -heap pid</code>: 打印Heap(新生代/老年代/永久代等等..)的size参数和实际占用</li><li><code>jmap -histo pid</code>: 打印出每个类的对象数量, 以及占用内存。如果出现jvm堆占用率过高，可以用<code>histo</code>查看哪个类的对象最多，猜测出哪里的代码有问题</li><li><code>jmap -histo:live pid</code>: 只打印存活的</li><li><code>jmap -dump:format=b,file=FileName 6900</code>: 把内存详细使用情况dump到文件(<strong>小心, 这个命令可能会暂停当前应用</strong>)<ul><li><code>-dump:[live,]format=b,file=FileName</code>: live指只有活动的对象被转储到dump文件</li></ul></li></ul><blockquote><p>如果程序内存不足或者频繁GC，很有可能存在内存泄露情况：</p><blockquote><ol><li>可以先使用<code>jmap -heap</code>命令查看堆的使用情况，看一下各个堆空间的占用情况。</li><li>使用<code>jmap -histo:[live]</code>查看堆内存中的对象的情况。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露，就要结合代码，为什么没有被释放</li><li>也可以使用 <code>jmap -dump:format=b,file=&lt;fileName&gt;</code>命令将堆信息保存到一个文件中，再借助jhat命令查看详细内容</li><li>在内存出现泄露、溢出或者其它前提条件下，建议多dump几次内存，把内存文件进行编号归档，便于后续内存整理分析。</li></ol></blockquote></blockquote><p>图-使用<code>jmap -histo pid</code> 按类型统计存活类的个数:<br><img src="/images/java/jmap-histo-live.png" alt="jmap-histo-live"></p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>查看jmap转储的二进制文件</p><ul><li><code>jhat -port 5000 FileName</code> : 在本地启动http服务显示jmap生成的dump文件信息, 在<a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a> 查看</li></ul><p><strong>总结:对Jvm进程进行堆栈Dump的方法</strong></p><blockquote><p>jstack可以生成Jvm线程的堆栈dump文件, jmap可以生成堆栈的dump文件,<br>让虚拟机在内存不足时自动生成dump文件: <code>-XX:+HeapDumpOnOutOfMemoryError</code><br>图形化的dump生成工具: Java VisualVM</p></blockquote><h3 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h3><p>1.7之后新增, 有多种功能的命令集合, 命令格式: <code>jcmd $PID $Command</code>, 查看可用的Command: <code>jcmd $PID help</code>,  “Oracle官方建议使用jcmd代替jmap”</p><ul><li><code>jcmd -l</code>: 类似<code>jps -m</code></li><li><code>jcmd pid Thread.print</code> : 打印当前堆栈</li><li><code>jcmd pid GC.heap_dump /tmp/dumpFile</code> : 导出dump文件</li><li><code>jcmd pid VM.system_properties</code> : 打印出该进程所有-D参数</li></ul><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><ul><li><code>jinfo pid</code>, 获取jvm进程的所有参数, 后续版本可能会移除这个工具</li></ul><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><ul><li>被调试的java进程启动参数<code>-Xdebug -Xrunjdwp:transport=dt_socket,address=8787</code></li><li>连接到上面的进程进行debug: <code>jdb -attach 192.168.1.79:8787 -sourcepath .</code></li></ul><h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>Java 5提供的JConsole</p><h2 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h2><p>JProfiler是由ej-technologies GmbH开发的商业授权的性能分析工具.</p><p>参考: <a href="https://yq.aliyun.com/articles/276" target="_blank" rel="noopener">深入浅出JProfiler-博客-云栖社区-阿里云</a> @ref</p><h2 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h2><p>VisualVM 是一个性能分析工具，自从 JDK 6 Update 7 以后已经作为 Oracle JDK 的一部分，位于 JDK 根目录的 bin 文件夹下。<br>以下参考自: <a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html" target="_blank" rel="noopener">使用 VisualVM 进行性能分析及调优</a> @ref</p><p>使用VisualVM需要远程服务器上运行一个jstatd守护进程, 或者远程服务器上运行的Java Application启用了JMX, 应用程序添加如下参数来启动JMX:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote=true</span><br><span class="line">-Dcom.sun.management.jmxremote.port=9090</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br></pre></td></tr></table></figure><p><img src="/images/java/JVisualVM.png" alt="JVisualVM UI"></p><p>JVisualVM连接到JVM线程使用了Attach API,  在本文档搜索<code>Attach API</code>.<br>启动命令: <code>jvisualvm</code></p><h2 id="Btrace"><a href="#Btrace" class="headerlink" title="Btrace"></a>Btrace</h2><blockquote><p>BTrace是SUN Kenai云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。</p></blockquote><p>Btrace能用来做什么?<br>举例, 如果要对线上运行的Java程序进行调试, 可以通过在代码里加入debug打印信息来实现, 但缺点也很明显, 需要不断地修改代码，加入<code>System.out.println()</code>, 还需要不断重启应用程序. 对于线上服务这是不可接受的.</p><p>Btrace可以改变上面低效的调试方式, Btrace可以使用类似AOP式的代码植入, 在我们关心的代码位置插入自定义代码, 比如:<br>  在每个方法结束都打印耗时, 统计最耗时的方法;<br>  在<code>ArrayList.add</code>里加入代码, 如果size过大则打印log, 找出超大的ArrayList;<br>  当<code>System.gc()</code>被调用时, 打印出调用堆栈, 找出是哪里在调用gc;</p><p>并且最重要的是, 使用Btrace不需要重新编译项目代码, 也不需要重启进程, 所以Btrace非常适合在线上发生异常的环境上进行调试埋点.</p><h3 id="Btrace的使用"><a href="#Btrace的使用" class="headerlink" title="Btrace的使用"></a>Btrace的使用</h3><p>Btrece的使用:</p><ol><li>启动Java程序</li><li>编写Btrace代码, 用注解指定要切入的类和方法</li><li>用btracec编译上面的代码</li><li>用btrace命令把agent 动态attach到运行中的Java进程, 并由agent修改运行中Java程序的类</li></ol><p>更多BTrace使用例子:</p><ul><li><a href="https://github.com/btraceio/btrace/tree/master/samples" target="_blank" rel="noopener">btrace/samples at master · btraceio/btrace</a></li></ul><h3 id="Btrace用到的技术介绍"><a href="#Btrace用到的技术介绍" class="headerlink" title="Btrace用到的技术介绍"></a>Btrace用到的技术介绍</h3><p>Btrace使用 <strong>Java Complier API</strong> 编译切入代码,<br>再使用 <strong>Attach API</strong> 把agent.jar附加到目标JVM上。<br>并使用asm来重写被切入类的字节码（CGLIB代理也用到了asm）, 再使用 <strong>Instrumentation API</strong> 在不重启程序的情况下实现对原有类的替换。</p><blockquote><p><strong>Attach API</strong> 和 <strong>Instrumentation API</strong> 都是<strong>JVM Tool Interface</strong> (JVMTI)里提供的工具类;<br>有关JVMTI相关的链接:</p><blockquote><p><a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a><br><a href="https://github.com/jon-bell/bytecode-examples" target="_blank" rel="noopener">https://github.com/jon-bell/bytecode-examples</a></p></blockquote></blockquote><p>参考:</p><ul><li><a href="http://www.rowkey.me/blog/2016/09/20/btrace/" target="_blank" rel="noopener">BTrace原理浅析</a></li><li><a href="https://www.ibm.com/developerworks/cn/views/java/libraryview.jsp?search_by=深入%20Java%20调试体系" target="_blank" rel="noopener">深入 Java 调试体系</a><ul><li>第 1 部分，JPDA 体系概览</li><li>第 2 部分: JVMTI 和 Agent 实现</li><li>第 3 部分: JDWP 协议及实现</li><li>第 4 部分: Java 调试接口（JDI）</li></ul></li></ul><h2 id="HouseMD"><a href="#HouseMD" class="headerlink" title="HouseMD"></a>HouseMD</h2><blockquote><p>比BTrace更轻量级的Java进程运行时的诊断调式命令行工具，可以用来跟踪跟踪方法的耗时。</p></blockquote><ul><li><a href="https://github.com/CSUG/HouseMD/wiki/UserGuideCN" target="_blank" rel="noopener">UserGuideCN · CSUG/HouseMD Wiki</a></li></ul><h2 id="Memory-Analyzer-MAT"><a href="#Memory-Analyzer-MAT" class="headerlink" title="Memory Analyzer (MAT)"></a>Memory Analyzer (MAT)</h2><blockquote><p>Java Heap Dump 文件(通过<code>jmap -dump</code>转储的文件)分析工具，可以分析堆内存中每种对象的数量，还可以跟踪对象的引用链，排查内存泄漏问题。</p></blockquote><ul><li><a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html" target="_blank" rel="noopener">使用 Eclipse Memory Analyzer 进行堆转储文件分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-02c-JVM参数和性能</title>
      <link href="/12.Java/Advanced-Java.02c.JVM%E5%8F%82%E6%95%B0%E5%92%8C%E6%80%A7%E8%83%BD/"/>
      <url>/12.Java/Advanced-Java.02c.JVM%E5%8F%82%E6%95%B0%E5%92%8C%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM的模式"><a href="#JVM的模式" class="headerlink" title="JVM的模式"></a>JVM的模式</h2><p><a href="http://www.importnew.com/20715.html" target="_blank" rel="noopener">关于JVM的类型和模式 - ImportNew</a></p><ul><li>使用<code>java -version</code>命令查看出当前虚拟机处于哪种类型模式: <em>Server</em> or <em>Client</em></li><li>JVM启动时采用何种模式是在名为jvm.cfg的配置文件中配置的:<ul><li>在32位JDK中，jvm.cfg位置为：JAVA_HOME/jre/lib/i386/jvm.cfg</li><li>在64位JDK中，jvm.cfg位置为：JAVA_HOME/jre/lib/amd64/jvm.cfg</li></ul></li><li><p>Server 和 Client 的区别:</p><blockquote><p>These two systems are different binaries. They are essentially two different compilers (JITs)interfacing to the same runtime system. The client system is optimal for applications which need fast startup times or small footprints, the server system is optimal for applications where the overall performance is most important. In general the client system is better suited for interactive applications such as GUIs. Some of the other differences include the compilation policy,heap defaults, and inlining policy.<br>Client JVM适合需要快速启动和较小内存空间的应用，它适合交互性的应用，比如GUI；而Server JVM则是看重执行效率的应用的最佳选择。不同之处包括：编译策略、默认堆大小、内嵌策略。</p></blockquote></li><li><p>使用<code>java -X</code> 可以看到Jvm工作模式 // JVM有以下几种模式：-Xint, -Xcomp, 和 -Xmixed</p><ul><li>-Xint代表解释模式(interpreted mode)，-Xint标记会强制JVM以解释方式执行所有的字节码</li><li>-Xcomp代表编译模式(compiled mode)，与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化</li><li>-Xmixed代表混合模式(mixed mode)，前面也提到了，混合模式是JVM的默认工作模式。它会同时使用编译模式和解释模式。对于字节码中多次被调用的部分，JVM会将其编译成本地代码以提高执行效率；而被调用很少（甚至只有一次）的方法在解释模式下会继续执行，从而减少编译和优化成本</li></ul></li></ul><h2 id="JVM相关日志"><a href="#JVM相关日志" class="headerlink" title="JVM相关日志"></a>JVM相关日志</h2><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError XX:HeapDumpPath=../</code> 开启jvm内存不足时生成dump文件, 指定位置</li><li><code>-XX:ErrorFile=/var/log/hs_err_pid.log</code> jvm崩溃日志</li><li><code>-XX:+PrintGC -XX:+PrintGCDateStamps -Xloggc:../logs/gc.log</code> 开启GC日志, 输出时间戳, 指定GC日志位置</li></ul><h2 id="JVM参数-D-X-XX"><a href="#JVM参数-D-X-XX" class="headerlink" title="JVM参数: -D -X -XX"></a>JVM参数: -D -X -XX</h2><p>查看当前JVM默认参数的命令: <code>java -XX:+PrintFlagsFinal -version</code>, 下面是需要注意的参数说明:</p><p><strong>-D参数：</strong></p><ul><li>-D: JVM系统参数, 可以自定义, 在代码里通过<code>System.getProperty(&quot;xxx&quot;)</code>获取到<ul><li><code>-Djava.ext.dirs=/path</code>: <code>-classpath</code>参数只能指定jar包, 如果需要把某个目录的jar都包含进来, 可以使用<code>-Djava.ext.dir=</code></li><li><code>-Dfile.encoding=UTF-8</code>:</li><li><code>-Djava.io.tmpdir=/tmp</code>: 在此路径下生成pid文件, jps命令读取此文件返回结果, 默认是<code>/tmp/hsperfdata_&lt;username&gt;/</code>目录下</li></ul></li></ul><p><strong>-X参数：</strong></p><ul><li>-X: 设置JVM扩展参数, 非标准的, 不保证任何JVM都实现<ul><li><code>-Xms512m</code>: 堆的初始化大小,默认物理内存的1/64(&lt;1GB),</li><li><code>-Xmx512m</code>: 最大堆大小,物理内存的1/4(&lt;1GB)</li><li><code>-Xss1m</code>: 线程栈大小, JDK5.0以后每个线程堆栈大小为1M</li></ul></li></ul><p><strong>-XX参数：</strong></p><ul><li><p>-XX: 不稳定的参数, 不推荐在生产环境中使用:</p><ul><li><code>-XX:AutoBoxCacheMax</code> : JAVA进程启动的时候,会加载rt.jar这个核心包的,rt.jar包里的Integer自然也是被加载到JVM中, VM在加载Integer这个类时,会优先加载静态的代码。当JVM进程启动完毕后, -128 ~ +127 范围的数字会被缓存起来,调用valueOf方法的时候,如果是这个范围内的数字,则直接从缓存取出。<br>因此可以根据实际情况把AutoBoxCacheMax的值设置的更多一些: -XX:AutoBoxCacheMax=2000</li><li><code>-XX:+AlwaysPreTouch</code> : JAVA进程启动的时候,虽然我们可以为JVM指定合适的内存大小,但是这些内存操作系统并没有真正的分配给JVM,而是等JVM访问这些内存的时候,才真正分配.<br>这个参数可以让让操作系统在启动JVM时, 把内存真正的分配给JVM;</li><li><p><code>-XX:CMSInitiatingOccupancyFraction</code> : 当老年代堆空间的使用率达到75%的时候就开始执行垃圾回收, CMSInitiatingOccupancyFraction默认值是92%,这个就太大了<br>如 <code>-XX:CMSInitiatingOccupancyFraction=75</code>, 注意 <code>CMSInitiatingOccupancyFraction</code> 参数必须跟下面两个参数一起使用才能生效:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br></pre></td></tr></table></figure></li><li><p><code>-XX:MaxTenuringThreshold</code> 默认情况下, 这个值是15, 意思是 当新生代执行了15次 young gc后, 如果还有对象存活在Survivor区中,那么就可以直接将这些对象晋升到老年代.<br>但是由于新生代使用copy算法,如果 Survivor区存活的对象太久的话, Survivor区存活的对象就越多, 这个就会影响copy算法的性能,使得 young gc停顿的时间加长,建议设置成6。<br>有个例外的情况, 可能导致GC收集器 不按照<code>MaxTenuringThreshold</code>的值进行晋升,<br>[动态年龄计算] :JVM遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。例如age=2的所有对象占用了超过一半Survivor区大小, 那么晋升至老年代的age阈值会调整为2</p></li><li><code>-XX:ExplicitGCInvokesConcurrent</code> 如果系统使用堆外内存,比如用到了Netty的DirectByteBuffer类,那么当想回收堆外内存的时候,需要调用<code>System.gc()</code>, 而这个方法将进行full gc,整个应用将会停顿,<br>如果是使用CMS垃圾收集器,那么可以设置<code>-XX:+ExplicitGCInvokesConcurrent</code>, 来改变<code>System.gc()</code>的行为,让其从 full gc 变为 CMS GC,<br>CMS GC 是并发收集的,且中间执行的过程中,只有部分阶段需要 STW;</li><li><code>-XX:PermSize</code> : 设置持久代(perm gen)初始值    物理内存的1/64, 例 <code>XX:PermSize=512M</code></li><li><code>-XX:MaxPermSize</code>    设置持久代最大值    物理内存的1/4</li><li><code>-XX:SurvivorRatio</code>: Eden和Survivor的大小比例, <code>-XX:SurvivorRatio=8</code>表示 <code>Eden:Survivor=8:1</code>，这是默认值</li><li><code>-XX:NewRatio</code>:  老年代:年轻代 的比值, The default NewRatio for the Server JVM is 2: the old generation occupies 2/3 of the heap while the new generation occupies 1/3<br>如果Young GC很频繁, 可以降低老年代的比例: <code>-XX:NewRatio=1</code>;</li><li>注意：<code>-Xmn</code>的优先级比<code>-XX:NewRatio</code>高，若<code>-Xmn</code>已指定，则无需再按<code>NewRatio</code>的比例计算。生产环境中一般只需指定<code>-Xmn</code></li><li><code>-XX:MaxTenuringThreshold</code>: 控制进入老年前生存次数等, 如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率, 该参数只有在串行GC时才有效.</li><li><code>-XX:+DisableExplicitGC</code>:    关闭System.gc()         这个参数需要严格的测试</li><li><code>-XX:+UseParallelGC</code>: 选择垃圾收集器为并行收集器.此配置仅对年轻代有效</li><li><code>-XX:+UseParNewGC</code>: 设置年轻代为并行收集</li><li><code>-XX:+UseParallelOldGC</code>: 老年代垃圾收集方式为并行收集(Parallel Compacting)</li><li><code>-XX:+UseConcMarkSweepGC</code>:    使用CMS内存收集</li><li><code>-XX:+PrintGC</code></li><li><code>-XX:+PrintGCDetails</code></li><li><code>-XX:+PrintGC:PrintGCTimeStamps</code></li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>: 当JVM因内存不足崩溃时产生dump文件</li><li><code>-XX:ErrorFile=/var/log/hs_err_pid.log</code>: JVM崩溃, 产生的日志位置</li></ul></li></ul><h2 id="JVM参数最佳实践"><a href="#JVM参数最佳实践" class="headerlink" title="JVM参数最佳实践"></a>JVM参数最佳实践</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx4g -Xms4g -Xmn1G</span><br><span class="line">-XX:+UseParNewGC -XX:UseConcMarkSweepGC</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=70</span><br><span class="line">-verbose:gc -XX:+printGCDetails -XX:+PrintGCTimeStamps -Xloggc:$&#123;HBASE_HOME&#125;/logs/gc-$&#123;hostname&#125;-hbase.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-02b-JVM内存分代</title>
      <link href="/12.Java/Advanced-Java.02b.JVM%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3/"/>
      <url>/12.Java/Advanced-Java.02b.JVM%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK6时期"><a href="#JDK6时期" class="headerlink" title="JDK6时期"></a>JDK6时期</h1><p><img src="/images/java/JVM-Memory-Model-Generation.png" alt="JVM Runtime Memory Area"></p><p>如上图, JDK6时代的JVM内存分为下面几个部分:</p><ul><li>堆区(Heap Space): 这部分被所有线程共享, 包括:<ul><li>年轻代: <code>eden:s0:s1</code> 的默认比例是<code>8:1:1</code>,  可见eden区大部分对象都是要被回收的;</li><li>老年代: <code>老年代:年轻代</code> 的比例默认是<code>2:1</code> , 也就是说默认情况下堆区的2/3都属于老年代,</li></ul></li><li>栈区(Stack Space): 每个线程独有, 包括: PC, Stack, Native Stack</li><li>方法区(Method Area)</li></ul><blockquote><p>JVM标准定义的内存区域为Heap/Stack Space/Medhod Area; 分代的名称（年轻代/老年代/永久代）是HotSpot中定义的, 并不是JVM标准中定义的, 注意区分 @Uncertain</p></blockquote><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><ul><li>这块区域被同一JVM实例的所有线程共享, Java对象全都创建在堆上.</li><li>堆的大小由<code>-Xms</code> ~ <code>-Xmx</code>指定: <code>-Xmx2048m -Xms2048m</code><ul><li><code>-Xmx</code>堆的最大值默认是内存的1/4;</li><li><code>-Xms</code>堆的最小值;</li></ul></li></ul><h3 id="YoungGen-新生代"><a href="#YoungGen-新生代" class="headerlink" title="YoungGen(新生代)"></a>YoungGen(新生代)</h3><p>大小由参数<code>-XX:NewSize</code> ~ <code>-XX:MaxNewSize</code> (jdk 1.3)指定, jdk1.4之后统一成一个参数 <code>-Xmn512m</code></p><p>新生代又被分为三个区域:</p><ul><li>Eden: 新创建的对象被分配在这里;</li><li>To Survivor &amp; From Survivor:  发生Young GC时, 有用的对象从 <code>Eden</code>区域 和 <code>From Survivor</code>区域 移动到 → <code>To Survivor</code> , Eden 和 From被清空, 同时From 和 To 交换角色 ;</li></ul><h4 id="Eden区的TLAB"><a href="#Eden区的TLAB" class="headerlink" title="Eden区的TLAB"></a>Eden区的TLAB</h4><p>在Eden区创建对象时, JVM为了保证Eden区数据的线程安全, 会对分配过程加锁, 对于频繁的对象分配, 加锁会引起额外的性能开销.<br>所以 Hotspot 1.6的实现中引入了TLAB技术, 每个线程在Eden都独占一块缓存区 – TLAB（Thread Local Allocation Buffer）, 每个线程创建的对象会被优先放入TLAB中, 因为在TLAB区域分配内存无需加锁, 可以提升对象创建效率.<br>当线程的”TLAB区”满了时, 会触发 “TLAB refill”: 线程把TLAB的所有权交回给共享的Eden, 然后重新从Eden里分配一块空间作为新的TLAB.</p><p>图-Eden区的结构:<br><img src="/images/java/JVM-HEAP-EDEN-TLAB.png" alt=""></p><p>参考列表:</p><ul><li>@ref <a href="https://www.zhihu.com/question/56538259" target="_blank" rel="noopener">在TLAB中创建的对象，如何被其他线程共享？ - 知乎</a></li><li>@ref <a href="https://www.jianshu.com/p/cd85098cca39" target="_blank" rel="noopener">JVM源码分析之线程局部缓存TLAB - 简书</a></li></ul><h3 id="OldGen-老年代"><a href="#OldGen-老年代" class="headerlink" title="OldGen(老年代)"></a>OldGen(老年代)</h3><ul><li>也叫Tenured(晋升代), 在GC里被称为老年代(Old Generation)</li><li>没有参数可以指定大小, 但可以通过<code>Heap-新生代</code>计算出来</li></ul><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>每个线程都在这里开辟一块内存栈, 每个线程栈的大小可以由<code>-Xss</code>指定, 这块区域是每个线程私有的, 该区域内存包括:</p><ol><li>Program Counter Register: 计数器, 记录当前线程执行Java字节码的行号 // JVM中唯一没有规定任何 OutOfMemoryError 的区域;</li><li>Stack: 即每个线程执行时的 <em>栈帧</em>,  栈帧里存储了当前方法的临时变量/函数的返回地址和参数/函数调用的上下文. 线程中每次有方法调用时，会创建一个 Frame，方法调用结束时 Frame 销毁。; // 该区域会抛出 StackOverflowError 和 OutOfMemoryError</li><li>Native Method Stack: 除了上面的栈, 每个线程都有自己的Native方法执行栈(前者是线程执行字节码的栈, 后者是线程执行Native代码的栈, Java代码可以和Native代码互相调用), // 该区域会抛出 StackOverflowError 和 OutOfMemoryError</li></ol><blockquote><p>线程栈大小由参数<code>-Xss</code>指定, 默认1m, 在tomcat这种多线程web服务器上, 保持1m或者更小可以处理更多的并发请求<br>Stack 和 Native Stack 都会抛出StackOverFlowError 和 OutOfMemoryError两种错误,</p><blockquote><p>StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。<br>OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></blockquote></blockquote><h2 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h2><ul><li>方法区与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</li><li>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他的虚拟机（如Oracle JRockit、IBM J9等）来说是不存在永久代的概念的。</li><li>所以在 HotSpot VM, <strong>永久代也是有GC的, GC时机与老年代相同（再次提醒永久代不属于堆）</strong></li><li>HotSpot VM的永久代大小由<code>-XX:PermSize</code> ~ <code>-XX:MaxPermSize</code>指定, 一般服务器设置为:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MaxPermSize=500m</span><br></pre></td></tr></table></figure></li></ul><p>JDK 1.6的HotSpot 的永久代包括:</p><ol><li>Runtime Constant Pool, 运行时常量池, 详见 [#Java中的常量池]</li><li>String Pool: 字符串常量池, 以”Hello”字面量方式创建的字符串会存储在这里.</li></ol><p>如果运行时有大量的类产生，可能会导致方法区被填满，直至溢出。常见的应用场景如：</p><ul><li>Spring和ORM框架使用CGLib操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</li><li>大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）。</li><li>基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）。<br>这些都会导致方法区溢出，报出java.lang.OutOfMemoryError: PermGen space</li></ul><h1 id="JDK7时期"><a href="#JDK7时期" class="headerlink" title="JDK7时期"></a>JDK7时期</h1><p>String Pool被从 PermGen里移除了, 放在了Heap里, 并且可以通过<code>-XX:StringTableSize</code>指定其大小;<br>Runtime Constant Pool 也在1.7之后放入了Heap里? @Uncertain<br>此外JDK7的内存模型基本和6一样;</p><h1 id="JDK6-7的VM参数总结"><a href="#JDK6-7的VM参数总结" class="headerlink" title="JDK6~7的VM参数总结"></a>JDK6~7的VM参数总结</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             &lt;JVM 6 &amp; 7 Memory options&gt;</span><br><span class="line">+-----------------+-----------------+--------------</span><br><span class="line">|     PC          |                 |</span><br><span class="line">|-----------------|-----------------+-------------</span><br><span class="line">|    Stack &amp;      |                 |</span><br><span class="line">|  Native Stack   |                 |  -Xss</span><br><span class="line">+-----------------+-----------------+---------------</span><br><span class="line">|   Method Area   |  String Pool &amp;  |</span><br><span class="line">|   (PermGen)     |    Runtime-     | -XX:MaxPermSize</span><br><span class="line">|                 |  Constant Pool  | -XX:PermSize</span><br><span class="line">+-----------------+-----------------+-------+-------+---</span><br><span class="line">|    OldGen       |                 |       |       |</span><br><span class="line">|  (TenuredGen)   |                 |       | -Xmx  |</span><br><span class="line">+-----------------+-----------------+-------+       |</span><br><span class="line">|                 |  To Survivor    |       |       | Heap</span><br><span class="line">|    YoungGen     |-----------------| -Xmn  |       |</span><br><span class="line">|                 |  From Survivor  |       | -Xms  |</span><br><span class="line">|                 |-----------------|       |       |</span><br><span class="line">|                 |     Eden        |       |       |</span><br><span class="line">+-----------------+-----------------+-------+-------+---</span><br></pre></td></tr></table></figure><h1 id="JDK8时期"><a href="#JDK8时期" class="headerlink" title="JDK8时期"></a>JDK8时期</h1><p>在HotSpot JDK7以及更早的版本里, 永久代最大大小由<code>-XX:MaxPermSize</code>指定, 一旦超过这个大小就不能再扩展, 假如加载的类过多会导致Medhod Area过大而导致OOM,<br>HotSpot JDK8 <strong>移除</strong> 了JDK7的 PermGen(永久代), 类的元信息被移到了 Meta space(元空间), 这块内存放在 Native memory当中, 不再属于JVM线程内的内存区.</p><blockquote><p>JDK7 移除了PermGen 的 运行时常量池 &amp; 字符串常量池;<br>JDK8 移除了整个PermGen, 类的元信息被放在 MateSpace; // 运行时常量池呢?</p></blockquote><p>JDK8的堆空间变得更加简单:</p><p><img src="/images/java/jvm-memory-heap-jdk8.png" alt="JVM-Memory-Heap-JDK8"></p><p>JDK8 使用 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定 Meta space(元空间)的大小:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m</span><br></pre></td></tr></table></figure><p>以上设置的<code>MetaspaceSize</code> 并不是永久代初始大小, 这个JVM参数是指Metaspace扩容时触发FullGC的初始化阈值，也是最小的阈值。这里有几个要点需要明确：</p><ul><li>如果没有配置 <code>-XX:MetaspaceSize</code>，那么触发FGC的阈值是21807104（约20.8m），可以通过 <code>jinfo -flag MetaspaceSize pid</code> 命令得到这个值；</li><li>如果配置了 <code>-XX:MetaspaceSize</code>，那么触发FGC的阈值就是配置的值；</li><li>Metaspace由于使用不断扩容到 <code>-XX:MetaspaceSize</code>参数指定的量，就会发生FGC；且之后每次 Metaspace扩容都可能会发生FGC（至于什么时候会，比较复杂，跟几个参数有关）；</li><li>如果 Old区配置 CMS垃圾回收，那么扩容引起的 FGC也会使用 CMS算法进行回收；</li></ul><blockquote><p>对于一个64位的服务器端JVM来说,其默认的 –XX:MetaspaceSize值为21MB. 这就是初始的高水位线. 一旦触及到这个水位线, Full GC 将会被触发并卸载没有用的类（即这些类对应的类加载器不再存活）,然后这个高水位线将会重置. 新的高水位线的值取决于GC后释放了多少元空间. 如果释放的空间不足,这个高水位线则上升. 如果释放空间过多,则高水位线下降. 如果初始化的高水位线设置过低,上述高水位线调整情况会发生很多次. 通过垃圾回收器的日志我们可以观察到 Full GC 多次调用. 为了避免频繁的GC,建议将–XX:MetaspaceSize设置为一个相对较高的值.</p></blockquote><p>以上参考:  @ref <a href="http://www.infoq.com/cn/articles/Java-PERMGEN-Removed" target="_blank" rel="noopener">Java永久代去哪儿了</a></p><h1 id="JVM分代设置大小-经验值"><a href="#JVM分代设置大小-经验值" class="headerlink" title="JVM分代设置大小(经验值)"></a>JVM分代设置大小(经验值)</h1><ul><li>堆区的默认值最大size是256MB, 永久代默认最大size是64MB, <code>堆:永久代</code>大约是是<code>4:1</code> （Test @ JDK6 + Windows 32 bit）</li><li>每个分代大小比例(经验值): <code>Eden : Survivor0 : Survivor1 : OldGen : PermGen = 8 : 1 : 1 : 20 : 5</code></li><li>每个分代具体设置多大, 还可以根据 <strong>JVM活跃数据</strong> 的大小进行估算:</li></ul><blockquote><p>活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取GC数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下</p></blockquote><p><img src="/images/java/jvm-gensize-experience-point.png" alt="JVM_GenSize_Experience_Point"></p><p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总堆：1200MB = 300MB × 4</span><br><span class="line">新生代：450MB = 300MB × 1.5</span><br><span class="line">老年代： 750MB = 1200MB - 450MB</span><br></pre></td></tr></table></figure><h1 id="内存分区可能抛出的错误"><a href="#内存分区可能抛出的错误" class="headerlink" title="内存分区可能抛出的错误"></a>内存分区可能抛出的错误</h1><ul><li>Stack : <code>StackOverflowError</code> &amp; <code>OutOfMemoryError</code></li><li>Heap: <code>OutOfMemoryError</code></li><li>Method: <code>OutOfMemoryError: PermGen space</code>(1.8之前)</li><li>MetaSpace(1.8+): @todo</li></ul><h1 id="Java中的常量池"><a href="#Java中的常量池" class="headerlink" title="Java中的常量池"></a>Java中的常量池</h1><ol><li><code>Class Constant Pool</code>, 每个.class文件都包含的一块常量区, 存储了: 1 该类定义字面量(Literal, 字面量的字符串/final字段常量值/基本数据类型), 2 符号引用(Symbolic References, 类的完全限定名/方法名称和描述/字段名称和描述);</li><li><code>Runtime Constant Pool</code>, 位于PermGen的 Method Area里, .class文件常量池在类被加载后存放在此区域. class文件常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用;</li><li><code>String Pool</code>(也叫String Literal Pool, 字符串常量池), 在JDK6~JDK7u40版本是在PermGen里, JDK7u40之后的版本被移到了Heap里;<ul><li>String Pool中存的是字面量的字符串,比如<code>String s = &quot;Hello&quot;</code>之后字面量”Hello”就存储在这里 // pool中是保存的引用还是对象?</li><li>String Pool可以动态增长, 典型的是<code>String.intern</code>方法;</li><li>在HotSpot VM里实现的string pool功能的是一个<code>StringTable</code>类,它是一个哈希表,里面存的是驻留字符串(也就是我们常说的用双引号括起来的);</li></ul></li></ol><h1 id="对象在内存中的存储"><a href="#对象在内存中的存储" class="headerlink" title="对象在内存中的存储"></a>对象在内存中的存储</h1><ul><li><strong>堆区</strong>(年轻代/老年代):<ol><li>每个类在被ClassLoader载入时会创建该类的<code>Class对象</code>, 存放在堆区;</li><li>类的<code>static members</code>:<ul><li>如果是基本类型(int,float等)的static members, 在方法区跟类型信息在一起;</li><li>如果类类型的static members, 被new创建的对象本身在堆区, 引用(内存地址)还是在方法区;</li></ul></li><li>字符串常量(字面量): JDK7之后移到了堆区;</li></ol></li><li><strong>方法区</strong>(永久代): JDK8之后方法区被移动到了Native Memory中的 <strong>Meta space(元空间)</strong><ol><li>类的元信息:<ul><li>类的完整有效名, 类的直接父类的完整有效名, 方法的形参类型以及返回类型,</li><li>类的方法字节码(bytecodes)</li><li>类的加载器的引用(ClassLoader)</li></ul></li><li>运行时常量池 <code>Runtime Constant Pool</code></li></ol></li></ul><blockquote><p>类信息在方法区的内存布局有些类似<code>.class</code>文件结构, 参考后面的 “class文件结构”一节</p></blockquote><h1 id="字符串在内存中的存储"><a href="#字符串在内存中的存储" class="headerlink" title="字符串在内存中的存储"></a>字符串在内存中的存储</h1><blockquote><p>String pool: 全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p></blockquote><h2 id="String-Pool与String-intern"><a href="#String-Pool与String-intern" class="headerlink" title="String Pool与String.intern()"></a>String Pool与String.intern()</h2><p>Java并不要求常量只在编译期产生, 并非只有class文件常量池的内容才能进入方法区的”运行时常量池”,<br>运行期间可以添加常量进入常量池, 比如<code>String.intern()</code>方法;<br>运行<code>str.intern()</code>后, “首先在String Pool里查找是否有equals的字符串, 如果没有则在String Pool创建一个字面量字符串, 并返回其引用”<br>JDK6和JDK7的intern方法实现有差异, 具体看下面.</p><h2 id="JDK6-7-8的String-Pool"><a href="#JDK6-7-8的String-Pool" class="headerlink" title="JDK6,7,8的String Pool"></a>JDK6,7,8的String Pool</h2><ol><li>JDK6: GermGen的大小在64位机器上一般为96MB, 由<code>-XX:MaxPermSize</code>指定, String Pool(主要是个C++描述的StringTable)的大小默认是1009(StringTable “桶”的大小), 且这个大小不能扩展, StringTable的实现原理类似HashMap, hash值相同的会放进同一个桶的链表里. 如果太多调用了<code>String.intern()</code>, 会导致这个StringTable性能下降.</li><li>JDK7: String Pool从PermGen移到Heap, 并且增加了<code>-XX:StringTableSize</code>参数可以配置String Pool的大小, <code>-XX:StringTableSize=1000003</code>.</li><li>JDK8: String Pool与7相比没有太大变化, <code>-XX:StringTableSize</code>默认是60013, 可以用-XX:+PrintFlagsFinal获取当前你使用的值是多少.</li></ol><blockquote><p>以上参考自<a href="http://java-performance.info/string-intern-in-java-6-7-8/" target="_blank" rel="noopener">String.intern in Java 6, 7 and 8 - string pooling  - Java Performance Tuning Guide</a> @ref</p></blockquote><p>下面代码运行结果是 ?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>); <span class="comment">// 两个对象, 一个存储于String Pool, 一个在Heap</span></span><br><span class="line">s.intern();</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>); <span class="comment">// 一个对象, 在Heap</span></span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line"><span class="comment">//s3.intern();</span></span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure><p>先说答案: 在JDK6 下结果是 “false false”, 在JDK8下是 “false, true”.</p><p>没有在JDK8上验证, 但我觉得 7和8在 String Pool 上改动不大, 8仅仅是把 Method Area 移动到了 Native Memory 中 –被叫做 Metespace(元空间)的区域.<br>因为看不到 HotSpot的 native层源码, 所以只能看 OpenJDK的, 但是不保证 OpenJDK 与 HotSpot 实现一样 @todo 有时间一定要看了才能解惑.</p><p>从JDK6 到 JDK7 的 String Pool 和 <code>intern</code>方法的改变都比较大(String Pool从 PermGen移动到了 Heap, <code>String.intern()</code>改变见下面的分析)</p><p><strong>in JDK6:</strong></p><ul><li><code>String s = new String(&quot;Hello&quot;)</code>会创建两个字符串对象, 一个在 String Pool里的字面值, 一个是 Heap里的对象.</li><li><code>intern()</code>方法首先在String Pool里查找是否有 equals的字符串, 如果没有则在 String Pool创建一个字面量字符串, 并返回其引用. 已经存在的话返回在String Pool里的引用.</li></ul><blockquote><p><code>String s = new String(&quot;1&quot;)</code>, s创建后, String Pool 和 Heap各创建一个”1”, s指向的是Heap里的对象;<br><code>String s2 = &quot;1&quot;</code>, s2指向的是 String Pool里的字面值;<br><code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)</code>  这时”11”在内存里只有 Heap里的一个, s3指向这个 Heap里的对象,<br><code>s3.intern</code>之后 String Pool里也创建一个”11”;<br><code>String s4 = &quot;11&quot;</code> s4指向的是 String Pool里的对象</p></blockquote><p><strong>in JDK7:</strong></p><ul><li><code>String s = new String(&quot;Hello&quot;)</code>的行为跟6一样;</li><li><code>str.intern()</code>执行后, 如果再 String Pool里没有到 equals的字符串, 就不再在 String Pool里创建对象了, 而是直接把 Heap里的对象引用放进来. // 这也是6-&gt;7的 String的一个重要改变, 减少重复的字符串创建, 也更节省内存.</li></ul><blockquote><p><code>String s = new String(&quot;1&quot;)</code>, s创建后, String Pool 和 Heap各创建一个”1”, s指向的是Heap里的对象;<br><code>s.intern()</code> 检查 String Pool里已经存在”1”的字面值了, 什么都不做;<br><code>String s2 = &quot;1&quot;</code>, s2指向的是 String Pool里的字面值;<br><code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)</code>  这时”11”在内存里只有 Heap里的一个, s3指向这个 Heap里的对象,<br><code>s3.intern()</code> 在String Pool里找不到”11”, 但是不再创建新的, 而是直接把s3的引用复制进 String Pool,<br><code>String s4 = &quot;11&quot;</code> 这种方式创建是指明在 String Pool里创建, 但是 String Pool里已经存在一个”11”的引用了, 那么s4直接指向这个引用. 所以s3和s4指向的都是 Heap里的”11”;</p></blockquote><blockquote><p>以上参考自<a href="http://www.importnew.com/14142.html" target="_blank" rel="noopener">深入解析String#intern - ImportNew</a> @ref</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-02a-JVM简介</title>
      <link href="/12.Java/Advanced-Java.02a.JVM%E7%AE%80%E4%BB%8B/"/>
      <url>/12.Java/Advanced-Java.02a.JVM%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-Architecture-Explained"><a href="#JVM-Architecture-Explained" class="headerlink" title="JVM Architecture Explained"></a>JVM Architecture Explained</h1><blockquote><p><a href="https://dzone.com/articles/jvm-architecture-explained?oid=18544920" target="_blank" rel="noopener">The JVM Architecture Explained - DZone Java</a></p></blockquote><ul><li>JVM 三个子系统: Class Loader, Runtime Data Area, Execution Engine</li><li>Execution Engine: The bytecode, which is assigned to the Runtime Data Area, will be executed by the Execution Engine. The Execution Engine reads the bytecode and executes it piece by piece (// Execution Engine 又分为三个子系统: 解释器, JIT编译器, 垃圾收集器) :<ol><li>Interpreter: The interpreter interprets the bytecode faster but executes slowly. The disadvantage of the interpreter is that when one method is called multiple times, every time a new interpretation is required. // 解释器,每次执行同一段代码需要创建多个解释器?</li><li>JIT Compiler:  Execution Engine 使用 Interpreter解释代码并执行, 当 Execution Engine 检测到重复执行的代码时, JIT编译器将字节码便以为 native code<ol><li>Intermediate Code Generator: 中间代码生成器–产生中间代码</li><li>Code Optimizer: 代码优化器–负责优化上面生成的中间代码</li><li>Target Code Generator: 目标代码生成器–负责生成机器代码(或 native code)</li><li>Profiler: 负责查找热点，即是否多次调用该方法。</li></ol></li><li>Garbage Collector: 垃圾收集器</li></ol></li></ul><p><img src="/images/java/JVM-Architecture.png" alt="JVM-Architecture"></p><h2 id="HotSpot-vs-OpenJ9"><a href="#HotSpot-vs-OpenJ9" class="headerlink" title="HotSpot vs OpenJ9"></a>HotSpot vs OpenJ9</h2><ul><li>HotSpot VM: Oracle / Sun JDK、OpenJDK的各种变种（例如IcedTea、Zulu），用的都是相同核心的HotSpot VM。</li><li>OpenJ9 VM: <a href="https://www.eclipse.org/openj9/" target="_blank" rel="noopener">OpenJ9</a></li></ul><p>HotSpot VM 对比 Open J9:</p><blockquote><blockquote><ul><li>原文: <a href="https://royvanrijn.com/blog/2018/05/openj9-jvm-shootout/" target="_blank" rel="noopener">Part 1: OpenJ9 versus HotSpot</a></li><li>翻译: <a href="https://www.oschina.net/translate/openj9-jvm-shootout" target="_blank" rel="noopener">OpenJ9 和 HotSpot 的对比 Part 1 - OSCHINA</a></li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Java-01-JDK</title>
      <link href="/12.Java/Advanced-Java.01.JDK/"/>
      <url>/12.Java/Advanced-Java.01.JDK/</url>
      
        <content type="html"><![CDATA[<p>Java Development Kit（JDK），包括一个完整的Java运行环境（Java Runtime Environment，JRE），还包括一系列用于Java开发的组件和工具（javac、jar、javap、javadoc、jdb、jps、jhat、jstack ……）</p><h2 id="JDK-组件"><a href="#JDK-组件" class="headerlink" title="JDK 组件"></a>JDK 组件</h2><h3 id="java-javac-jar"><a href="#java-javac-jar" class="headerlink" title="java, javac, jar"></a>java, javac, jar</h3><ul><li>编译Java源码： <code>javac -classpath PATH;PATH/xx.jar -sourcepath SOURCE_DIR -d OUTPUT_DIR</code></li><li>把.class文件打成Jar包： <code>jar cvf JAR_FILE_NAME CLASS_FILE_NAMES</code></li><li>运行executable的Jar包（Jar包指定了Main-Class）： <code>java -jar JAR_FILE_NAME</code></li><li>执行Jar包里的类（该类有main方法）： <code>java -cp JAR_FILE_NAME CLASS_FULL_NAME</code></li><li>执行Jar包里的类的指定方法： <code>java -cp JAR_FILE_NAME CLASS_FULL_NAME METHOD_NAME</code>, 例如Tomcat 的启动脚本最终是执行了 Bootstrap这个主类中的start方法：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">-Djava.util.logging.config.file=/data0/tomcat/tomcat_8080/conf/logging.properties</span><br><span class="line">-Xms2048m -Xmx2048m -XX:MaxPermSize=256m</span><br><span class="line">-classpath /data0/tomcat/tomcat_8080/bin/bootstrap.jar:/data0/tomcat/tomcat_8080/bin/tomcat-juli.jar -Dcatalina.base=/data0/tomcat/tomcat_8080 -Dcatalina.home=/data0/tomcat/tomcat_8080 -Djava.io.tmpdir=/data0/tomcat/tomcat_8080/temp</span><br><span class="line">org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure><h3 id="javap-javah"><a href="#javap-javah" class="headerlink" title="javap, javah"></a>javap, javah</h3><ul><li>javah：根据class文件生成h头文件<code>javah -jni ClassFileName</code></li><li>javap：反编译class文件成字节码<code>javap -c ClassFileName</code></li></ul><h3 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h3><p>@todo</p><h3 id="javadoc"><a href="#javadoc" class="headerlink" title="javadoc"></a>javadoc</h3><p>@todo</p><h3 id="jps-jstack-jhat-jmap"><a href="#jps-jstack-jhat-jmap" class="headerlink" title="jps, jstack, jhat, jmap"></a>jps, jstack, jhat, jmap</h3><p>@ref: <a href="/12.Java/Advanced-Java.02d.JVM分析工具/" title="Advanced-Java.02d.JVM分析工具">Advanced-Java.02d.JVM分析工具</a></p><h3 id="rt-jar-tools-jar-dt-jar"><a href="#rt-jar-tools-jar-dt-jar" class="headerlink" title="rt.jar, tools.jar, dt.jar"></a>rt.jar, tools.jar, dt.jar</h3><p>rt.jar, tools.jar, dt.jar 都包含于JRE（除此之外还JRE包括Java虚拟机）：</p><ul><li>rt.jar: rt = runtime, 包括了Java核心类库, <code>java.*</code>包下的类；</li><li>tools.jar: Jar包工具类, 我们执行的诸如<code>javac</code>等命令实际上是通过<code>java</code>命令调用了tools.jar, 比如 <code>javac ClassName.java</code> 相当于 <code>java -cp tools.jar xx.Main ClassName.java</code>；</li><li>dt.jar: 主要是Swing类库；</li></ul><h4 id="jar文件结构"><a href="#jar文件结构" class="headerlink" title="jar文件结构"></a>jar文件结构</h4><ul><li>jar包中的 META-INFO/MANIFEST.MF:<ul><li><code>Main-Class: com.xxx.Test</code> // 指定该选项可以更简单执行jar: <code>java -jar JAR_FILE_NAME</code></li><li><code>Class-Path: libXX.jar</code> // libXX.jar在相同目录下?</li></ul></li></ul><h2 id="Oracle-JDK-vs-Open-JDK"><a href="#Oracle-JDK-vs-Open-JDK" class="headerlink" title="Oracle JDK vs Open JDK"></a>Oracle JDK vs Open JDK</h2><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p><a href="https://juejin.im/post/5ca1c747e51d45761c7441fa" target="_blank" rel="noopener">Oracle与OpenJDK之间的区别 - 掘金</a></p><h3 id="免费-vs-付费"><a href="#免费-vs-付费" class="headerlink" title="免费 vs 付费"></a>免费 vs 付费</h3><ul><li>OpenJDK 每6个月发布一个新版本，不过每次新的版本发布后，旧的就不维护了，比如OpenJDK 12发布之后，11版本便停止更新，停留在11.0.2版本，没有LTS版本；</li><li>Oracle JDK同样每6个月发布一个新版本，其中9、10、12是 non-LTS版本，Oracle提供的免费更新只有6个月；</li><li>Oracle JDK 8、11是 LTS版本，提供6个月免费更新，但在这之后的更新不再免费（仅针对商业用户）。</li></ul><table><thead><tr><th>Java 版本</th><th>发布日期</th><th>Oracle 提供的免费更新</th></tr></thead><tbody><tr><td>Java 8(LTS)</td><td>2014.3</td><td>2019.1</td></tr><tr><td>Java 9</td><td>2017.9</td><td>2018.3</td></tr><tr><td>Java 10</td><td>2018.3</td><td>2018.9</td></tr><tr><td>Java 11(LTS)</td><td>2018.9</td><td>2019.3</td></tr><tr><td>Java 12</td><td>2019.3</td><td>2019.9</td></tr></tbody></table><p>使用 Oracle JDK的解决方案：</p><ul><li>Oracle Java 8 （LTS）:<ul><li>免费：用 8u192以及更早版本（有安全隐患）</li><li>交钱使用 Oracle提供的更新（8u211之后的更新）</li></ul></li><li>Oracle Java 11 （LTS）:<ul><li>交钱</li></ul></li><li>Oracle Java 10、12、13 non-LTS<ul><li>每6个月都升级到下一个版本的JDK</li></ul></li></ul><p>使用其他 OpenJDK的方案：</p><ul><li>Alibaba JDK, <a href="https://www.infoq.cn/article/SK7fJE1ZT0ykjc0_gecs" target="_blank" rel="noopener">阿里开源自用OpenJDK版本，Java社区迎来中国力量-InfoQ</a></li><li>Azul Systems发布的Zulu产品线中的Java SE产品, <a href="https://www.zhihu.com/question/53791269/answer/136575323" target="_blank" rel="noopener">链接</a>, 下图是Azul JDK的 LTS维护周期:</li></ul><p><img src="/images/java/Azul_JDK_LTS_Version.png" alt=""></p><p>关于 Oracle的许可协议：</p><ul><li>Oracle JDK 的许可协议有两种:<ul><li>BCL(Oracle Binary Code License Agreement): 个人/开发使用免费，商用免费（但商用免费仅限于”通用计算”设备, 移动设备/嵌入式设备不包括在免费领域）。JDK中的某些商业特性（使用<code>-XX:+UnlockCommercialVMOptions</code>打开的特性）仍是需要付费才可以使用的；</li><li>OTN(Oracle Technology Network License Agreement): 个人/开发使用免费，商用收费；</li></ul></li><li>Oracle 9/10是 BCL, 11/12变成了OTN，Oracle Java SE 11开始，按照OTN（Oracle Technology Network License Agreement）协议规定，只有在开发、测试及原型证明的场景下提供有限的授权。关于授权政策的一些具体问题可以参考下面网页： <a href="https://www.java.com/zh_CN/download/faq/distribution.xml" target="_blank" rel="noopener">https://www.java.com/zh_CN/download/faq/distribution.xml</a> @ref</li><li>Oracle JDK 8 在 8u211 和 8u212之后, 许可协议也变成了 OTN（因为 Oracle JDK 8 u192 是2019年1月前发布的最新版本，所以只要一直使用 JDK 8 u192 以及更早的版本，就不需付费）</li></ul><p>本节参考:</p><ul><li>@ref <a href="https://zhuanlan.zhihu.com/p/64731331" target="_blank" rel="noopener">Oracle如何对JDK收费 - 知乎</a></li><li>@ref <a href="https://www.zhihu.com/question/53791269" target="_blank" rel="noopener">Oracle 终于要向 Java 的非付费用户开枪了-怎么看？ - 知乎</a></li></ul><h3 id="JDK-版本历史"><a href="#JDK-版本历史" class="headerlink" title="JDK 版本历史"></a>JDK 版本历史</h3><p>→ <a href="https://en.wikipedia.org/wiki/Java_version_history" target="_blank" rel="noopener">Java version history - Wikipedia</a></p><p>JDK LTS版本:</p><ul><li>Java SE8: 2014.3~2030.12 (Oracle于2019.1停止商用更新)</li><li>Java SE11: 2018.9~2026.9</li><li>Java SE17: 2021.9~2029.9</li></ul><h3 id="JSR-JCP-…"><a href="#JSR-JCP-…" class="headerlink" title="JSR, JCP …"></a>JSR, JCP …</h3><ul><li><strong>JSR</strong> 是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。</li><li><strong>JCP</strong>, Java Community Process，Java 社区进程，JCP维护的规范包括J2ME、J2SE、J2EE，XML，OSS，JAIN等。组织成员可以提交JCR（Java Specification Requests），通过特定程序以后，进入到下一版本的规范里面。</li></ul><blockquote><p><a href="https://www.infoq.cn/article/2018/01/no-jcp-for-javaee" target="_blank" rel="noopener">Java EE跟JCP说再见-InfoQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 12.Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Tutorials-02并发</title>
      <link href="/11.Programming-Language/Golang-Tutorials.02.%E5%B9%B6%E5%8F%91/"/>
      <url>/11.Programming-Language/Golang-Tutorials.02.%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="chan-amp-select"><a href="#chan-amp-select" class="headerlink" title="chan &amp; select"></a>chan &amp; select</h1><ul><li><p>chan是并发安全的通信对象:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用make 创建一个存储int 类型的chan:</span><br><span class="line">ch1 := make(chan int)</span><br><span class="line"></span><br><span class="line">// 向chan写入:</span><br><span class="line">ch1 &lt;- 1</span><br><span class="line"></span><br><span class="line">// 从chan读出:</span><br><span class="line">i := &lt;-ch1</span><br><span class="line"></span><br><span class="line">// 或者通过ok判断ch里是否有数据</span><br><span class="line">i, ok := &lt;-ch1</span><br><span class="line"></span><br><span class="line">// 不接受返回值的读:</span><br><span class="line">fmt.Println(&lt;-ch)</span><br></pre></td></tr></table></figure></li><li><p>channel的关闭: <code>close(channel)</code>, 问题:</p><ul><li>如果f正在因读ch阻塞, <code>close(ch)</code>后, f会继续阻塞or?</li><li>如果ch还有数据, <code>close(ch)</code>后… 数据被丢弃?</li></ul></li><li><p>select 监视一组chan, 并从已经准备好的chan里随机选出一个, 用法类似switch, 每个case是读取chan:<br>下面的select</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">  case i := &lt;-ch1:</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  case j := &lt;-ch2:</span><br><span class="line">    fmt.Println(j)</span><br><span class="line">  default:</span><br><span class="line">    fmt.Println(&quot;?&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带缓冲区的chan: <code>ch := make(chan int, 100)</code></p><ul><li>不带缓冲区的channel, 如果ch已经有数据, 再向ch写数据会导致写入方阻塞, 如果ch空, 读取方会阻塞</li><li>带缓冲区的channel, 如果ch没满, 写入方不会阻塞</li></ul></li></ul><hr><p>@ref: <a href="https://zhuanlan.zhihu.com/p/36907022" target="_blank" rel="noopener">深入golang之—goroutine并发控制与通信 - 知乎</a></p><p>任何语言的并发都需要解决的问题：</p><ul><li>进程间通讯</li><li>竞争状态</li></ul><p>进程间通讯主要有两种模型：共享数据和消息</p><p>CSP模型：Communicating Sequential Process，Go的Channel 和 Actor都算一种实现，二者的区别..</p><p>代码demo功能：主进程和协程通信，主进程等待协程退出</p><ul><li>共享变量实现：考虑这种做法的缺点是？</li><li>Channel + WaitGroup实现</li><li>Context + WaitGroup实现</li></ul><hr><h1 id="os-exec"><a href="#os-exec" class="headerlink" title="os/exec"></a>os/exec</h1><p>@Ref：<a href="https://colobu.com/2020/12/27/go-with-os-exec/" target="_blank" rel="noopener">go os/exec 简明教程</a></p><p>cmd基本函数：</p><ul><li>cmd.Start() 和 cmd.Wait(), 其他函数的实现可以看做是对Start和Wait的封装</li><li>cmd.Run() = Start() + Wait()</li><li>cmd.CombinedOutput() = cmd. Stdout和cmd.Stderr关联同一个Buffer + Run()<br>cmd属性:<ul><li>标准输出/错误： cmd. Stdout 和 cmd. Stderr属性</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd := exec.Command(&quot;ls&quot;, &quot;-lah&quot;)</span><br><span class="line">var stdout, stderr bytes.Buffer</span><br><span class="line">cmd.Stdout = &amp;stdout // stdout关联Buffer</span><br><span class="line">cmd.Stderr = &amp;stderr</span><br><span class="line"></span><br><span class="line">err := cmd.Start() // 非阻塞</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;failed to call cmd.Start(): %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;pid: %d&quot;, cmd.Process.Pid)</span><br><span class="line">cmd.Process.Wait() // 阻塞直到退出</span><br><span class="line">log.Printf(&quot;exitcode: %d&quot;, cmd.ProcessState.ExitCode())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Tutorials-01基础</title>
      <link href="/11.Programming-Language/Golang-Tutorials.01.%E5%9F%BA%E7%A1%80/"/>
      <url>/11.Programming-Language/Golang-Tutorials.01.%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnxinyminutes.com/docs/zh-cn/go-cn/" target="_blank" rel="noopener">Learn Go in Y Minutes</a></p></blockquote><h1 id="Golang中的约定大于配置"><a href="#Golang中的约定大于配置" class="headerlink" title="Golang中的约定大于配置"></a>Golang中的约定大于配置</h1><p>Golang遵循”约定大于配置”(convention over configuratio)的理念:</p><ul><li>小写开头的标识(变量/函数/结构体类型等等)是package内可见, 大写开头的标识包外可见(类似public)</li><li>import as <code>_</code> 和 <code>.</code> 的包:<ul><li><code>import _ &quot;packageXXX&quot;</code> : 调用包内的<code>init()</code>方法</li><li><code>import . &quot;packageXXX&quot;</code> : 调用包内的函数,不需要再加<code>packageXXX.</code></li></ul></li><li>单元测试:<ul><li>文件名: <code>源文件名_test.go</code></li><li>函数名: <code>func Test源函数名()</code></li></ul></li><li>结构体中的”小写开头的成员”, 在用<code>json.Marshal</code>序列化时会被忽略</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li><p>声明 + 初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i int = 1</span><br><span class="line"></span><br><span class="line">// 更方便的写法</span><br><span class="line">j := 1</span><br></pre></td></tr></table></figure></li></ul><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>@todo</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul><li>uint8/int8: 平台无关, 都是8位</li><li>uint16/int16: ..</li><li>uint32/int32: ..</li><li>uint64/int64: ..</li><li>float32</li><li>float64</li><li>uint/int: 与上面的不同, uint/int可能是32 or 64 bits(视机器平台而定)</li><li>complex64: 复数, 由float32的实部 + float32的虚部构成</li></ul><p>@ref: <a href="https://golang.google.cn/ref/spec#Numeric_types" target="_blank" rel="noopener">The Go Programming Language Specification - The Go Programming Language</a></p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><ul><li>判断字符串empty: <code>len(str) == 0</code></li><li>字符串是”只读的”, 意味着无法直接修改字符串的内存空间</li><li><p>字符串的实现:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type StringHeader struct &#123;</span><br><span class="line">  Data uintptr</span><br><span class="line"> Len  int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li><p>Golang的类型转换: <code>T(var)</code></p></li><li><p>字符串 → any 都可以用<code>strconv</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i, err := strconv.ParseInt(&quot;1287089&quot;,10,32)</span><br><span class="line">result := int(i)</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li><p>多个返回值:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 多个返回</span><br><span class="line">func foo1(x, y int) (sum, prod int) &#123;</span><br><span class="line">  return x+y, x*y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变参数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可变参数</span><br><span class="line">func foo1(params ...type) &#123;</span><br><span class="line">  for _, param := range params &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Golang是值传递还是引用传递?</p><ul><li>Golang 是值传递, 函数内得到一份形参的拷贝</li><li>对于 slice, map, chan,  因为其结构内包含指针, 所以仍可以在函数内改变其存储的值</li><li>数组也是值传递，因为数组的类型是<code>[N]Type</code>，所以数组作为形参是有局限性的，推荐用slice</li></ul></li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包 先看几个例子:</p><p>例子1:<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x := 1</span><br><span class="line">f := func() bool &#123;</span><br><span class="line">  return x &gt; 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p><p>例子2:<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func foo2(x int) func() &#123;</span><br><span class="line">  return func() &#123;</span><br><span class="line">      x = x + 1</span><br><span class="line">      fmt.Printf(&quot;foo1 val = %d\n&quot;, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = foo2(133)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p><ul><li>什么是闭包(closure)? 一个函数, 并且此函数依赖函数外声明的变量, 那么闭包的定义是: 此函数+依赖的外部变量</li><li>实际上, Golang实现闭包, 实际是把 函数和它依赖的外部变量都放在了一个struct里, 用这个struct保存了函数和它依赖的外部变量</li><li>另外, 闭包的实现依赖Golang的逃逸分析, 对于闭包的环境变量, 是在堆上分配的, 这是闭包实现的基础</li><li>闭包另一个特性是延迟绑定, 意思是, 上面的闭包(也即struct)里保存的变量, 不是在编译期确定的, 而是在<strong>闭包的运行时才确定</strong>,  在闭包的外部寻找依赖变量的最新值, 并赋值进去</li></ul><p>下面输出什么?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func foo7(x int) []func() &#123;</span><br><span class="line">    var fs []func()</span><br><span class="line">    values := []int&#123;1, 2, 3, 5&#125;</span><br><span class="line">    for _, val := range values &#123;</span><br><span class="line">        fs = append(fs, func() &#123;</span><br><span class="line">            fmt.Printf(&quot;foo7 val = %d\n&quot;, x+val)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return fs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f7s := foo7(11)</span><br><span class="line">for _, f7 := range f7s &#123;</span><br><span class="line">    f7()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析:</p><ul><li>foo7返回了一个数组, 数组内是x个闭包函数, 闭包函数依赖2个外部变量: x 和 val</li><li>foo7返回 f7s的时候, 仅仅是返回了一个闭包的定义, 闭包内依赖的x 和 val并没有绑定值</li><li>第一次执行<code>f7()</code>, 寻找 x 和 val的最新值并绑定到闭包, 也即11 和 5</li></ul><p>@ref:</p><ul><li>闭包的实现 · 深入解析Go：<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html</a></li><li>Golang：“闭包（closure）”到底包了什么？ - 知乎：<a href="https://zhuanlan.zhihu.com/p/92634505" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92634505</a></li></ul><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><ul><li><p>if可以先赋值再判断</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if x:=computerValue(); x&gt;y &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按次数循环</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 循环1</span><br><span class="line">for x:=0; x&lt;10; x++ &#123;</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一直循环</span><br><span class="line">for &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历map/slice, 使用关键字<code>range</code>:  <code>index, elem : = range slice</code> or <code>k, v := range map</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 循环遍历 map</span><br><span class="line">for k,v := range map[string]int &#123;&quot;one&quot;:1, &quot;two&quot;:2&#125; &#123;</span><br><span class="line">  fmt.Println(&quot;%s %d\n&quot;, k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 循环遍历 slice</span><br><span class="line">for i,s := range []string &#123;&quot;one&quot;,&quot;two&quot;&#125; &#123;</span><br><span class="line">  fmt.Println(&quot;%d %s\n&quot;, i,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch x &#123;</span><br><span class="line">case 1:</span><br><span class="line">  // 隐式break, 匹配到一个即停止</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><blockquote><p>@ref: <a href="https://colobu.com/2017/06/26/learn-go-type-aliases/" target="_blank" rel="noopener">https://colobu.com/2017/06/26/learn-go-type-aliases/</a></p></blockquote><p>golang中type的用法:</p><ul><li>定义新类型: <code>type newType oldType</code> // C++中的typedef用法是<code>typedef oldType newType</code> …</li><li>定义结构体: <code>type STypeName struct{}</code></li><li><p>类型别名:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type rune = int32</span><br><span class="line">type byte = uint8</span><br><span class="line">type FloatType float32</span><br><span class="line"></span><br><span class="line">// 类型别名2:</span><br><span class="line">type S = string</span><br><span class="line">var str S = &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">// 函数别名:</span><br><span class="line">type F = func()</span><br><span class="line">var foo F = func() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><ul><li><p>定义</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourFirstStruct struct &#123;</span><br><span class="line">  member1 string</span><br><span class="line">  member2 string</span><br><span class="line">  // 每个成员没有分号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s := YourFirstStruct &#123;</span><br><span class="line">  member1: &quot;member1&quot;,</span><br><span class="line">  member2: &quot;member2&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>golang只有值传递, struct在函数内/外传递 or 直接<code>=</code>赋值给另一struct变量, 都会有一次拷贝, 与Java中Object是引用操作为主不同:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 := YourFirstStruct &#123;</span><br><span class="line">  member1: &quot;&quot;</span><br><span class="line">  member2: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">s2 := s1 // 赋值导致一次拷贝</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 避免拷贝的做法:</span><br><span class="line">ptr1 := &amp;YourFirstStruct &#123;</span><br><span class="line">&#125;</span><br><span class="line">ptr2 := ptr1 // 指针传递</span><br></pre></td></tr></table></figure></li><li><p>给Struct添加方法, 无需C++那样的头文件声明, 直接定义方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// s被叫做“接收器”</span><br><span class="line">func (s *YourFirstStruct) foo() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ul><li><p>interface是一种类型, 包括0个或多个方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type I interface &#123;</span><br><span class="line">  Get() int</span><br><span class="line">  Set(int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>空interface: <code>interface{}</code> 没有方法的interface, 可以认为任何类型都实现了该interface,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func foo(any interface&#123;&#125;) &#123;</span><br><span class="line">  // foo可以接受任何类型的参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Golang里没有extends这样的关键字来表名 某struct 实现了 某Interface, 只是在 <em>赋值</em>, <em>入参</em>, <em>返回值</em> 时被动检查</p></li></ul><h1 id="array"><a href="#array" class="headerlink" title="array"></a>array</h1><ul><li><p>数组在编译期即指定大小</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数组在用var声明时即分配了空间并给初始值</span><br><span class="line">var arr0 [4]string</span><br><span class="line"></span><br><span class="line">// 声明, 同时赋值</span><br><span class="line">arr1 := [3]string &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">arr2 := [...]string &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>golang在创建<strong>字面量数组</strong>时, 会根据数组长度进行不同的处理</p><ul><li>数组len&lt;=4, 直接在栈上分配数组</li><li>数组len&gt;4, 会在静态区分配数组(编译期), 并在运行时取出来</li><li>上述没有考虑逃逸</li></ul></li><li>数组的类型是: <code>[N]ElemType</code>, 长度也算类型的一部分, 例如 <code>[10]int</code> 和 <code>[3]int</code> 是不同的类型</li><li>在golang中，数组也是值传递</li></ul><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><ul><li>切片: Golang内置类型, 即”动态数组” // 数组的长度不可改变</li><li><p>比较 slice 和 array 的声明方式  // 注意<code>s2 := []int{1,2,3}</code>这种字面量声明方式, 如果用<code>[N]</code> or <code>[...]</code> 创建出来的就不是slice而是array了:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数组: 声明即分配空间</span><br><span class="line">var arr0 [4]string</span><br><span class="line"></span><br><span class="line">// 切片: 声明时没有分配空间</span><br><span class="line">var slice0 []string</span><br><span class="line">slice0[0] = 1 // panic: runtime error: index out of range</span><br><span class="line"></span><br><span class="line">// 创建切片1, 通过数组</span><br><span class="line">s1 := arr0[0:1]</span><br><span class="line"></span><br><span class="line">// 创建切片2, 创建时给初值</span><br><span class="line">s2 := []int&#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">// 创建切片3, len=cap=0</span><br><span class="line">s3 := make([]int, 0)</span><br></pre></td></tr></table></figure></li><li><p>切片作为函数的参数<code>func([]int sli)</code>, 如果在函数内进行append操作…</p></li><li><p>切片的扩容: 向切片add元素, 如果 len 大于 cap, 将创建新数组, 大小为原切面cap的两倍, 然后所有元素复制到新数组中</p></li><li><p>切片由两部分组成: Header + 数组实际存储空间, 其中 Header的结构表述如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">array unsafe.Pointer // 指针, 指向连续的内存</span><br><span class="line">len   int</span><br><span class="line">cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/golang-slice.png" alt="../_images/golang-slice.png"></p></li><li><p>从数组创建切片: <code>slice := array[startIndex:endIndex]</code> , 切片将包含 array[startIndex] …array[endIdex-1], 这种方式创建的新数组, 只是新建了一个slice结构, data指针指向的是同一块内存地址, 故修改新slice的数据也会影响旧slice:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">slice := array3[1:3]  // 此时slice包括 [2,3], len=2, 但slice指向的数组是[2,3,4,5], 故cap=4</span><br><span class="line">slice[0] = 7 // 对切片的修改也会影响数组, 但当切片发生一次扩容之后, 切片会指向一个新申请的数组空间</span><br></pre></td></tr></table></figure></li></ul><p>➤ 比较数组和切片:</p><ul><li>数组声明即分配空间, 且不可改变长度</li><li>切片声明不分配空间, 需要通过<code>make()</code> or <code>arr[start:end]</code></li><li>切片的类型是 <code>[]type</code>, 数组的类型是<code>[N]type</code></li><li>Slice 和 Arr内存存储位置有何不同? stack vs heap ? @todo</li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul><li><p>声明和初始化, 赋值, 访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明</span><br><span class="line">var mmap1 map[string]int</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">mmap1 = make(map[string]int)</span><br><span class="line"></span><br><span class="line">// 赋值</span><br><span class="line">mmap1[&quot;One&quot;] = 1</span><br><span class="line"></span><br><span class="line">// 访问</span><br><span class="line">if v, exist := mmap1[&quot;One&quot;]; exist &#123;</span><br><span class="line">  delete(mmap1, &quot;One&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 声明+定义</span><br><span class="line">mmap2 := map[string]string &#123;&quot;One&quot;:1, &quot;Two&quot;:2&#125;</span><br></pre></td></tr></table></figure></li><li><p>与slice一样, <code>make(map[K]V)</code> 返回的实际是指针类型</p></li><li>How to range map:</li></ul><h1 id="内置函数-len-append-copy-panic"><a href="#内置函数-len-append-copy-panic" class="headerlink" title="内置函数(len/append/copy/panic..)"></a>内置函数(len/append/copy/panic..)</h1><p>@ref: <a href="https://pkg.go.dev/builtin#pkg-functions" target="_blank" rel="noopener">https://pkg.go.dev/builtin#pkg-functions</a></p><ul><li>len/cap: 返回数组, slice, map, string, chan ..的长度&amp;容量</li><li>append/copy: 切片拼接&amp;复制<ul><li>原型: <code>func append(slice []Type, elems ...Type) []Type</code></li><li>原型: <code>func copy(dst, src []Type) int</code></li></ul></li><li>print/println: 输出到std err // 区分<code>fmt.Print()</code><ul><li>原型: <code>func print(args ...Type)</code></li><li>原型: <code>func println(args ...Type)</code></li></ul></li><li>delete: 用于删除map里的key, 原型: <code>func delete(m map[Type]Type1, key Type)</code></li><li>new:  → 本页[[#new]]</li><li>make:  → 本页[[#make]]</li></ul><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></table></figure><ul><li>slice:<ul><li>make([]T)</li><li>make([]T, len)</li><li>make([]T, len, cap)</li></ul></li><li>map:<ul><li>make(map[K]V)</li><li>make(map[K]V, cap)</li></ul></li><li>chan:<ul><li>make(chan int, 5)</li></ul></li></ul><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ul><li>原型: <code>func new(Type) *Type</code></li><li>作用: 返回为指定类型分配的内存地址</li><li><p>example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourStruct struct &#123;</span><br><span class="line">  member1 int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建struct方式1</span><br><span class="line">p1 := new(YourStruct)</span><br><span class="line">p1.member1 = 2</span><br><span class="line"></span><br><span class="line">// 创建struct方式2</span><br><span class="line">p2 := &amp;YourStruct&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>Golang中new 和var ，一个返回指针一个返回变量，二者的实现没有本质区别， 都是要通过逃逸分析判断是在栈上/堆上分配变量，（如果没有逃逸，new创建的变量也可能在栈上创建）// 逃逸分析在编译期？ or 运行期？</p></li></ul><h2 id="make-vs-new"><a href="#make-vs-new" class="headerlink" title="make vs new"></a>make vs new</h2><p>make vs new</p><ul><li>new(T)：<ul><li>分配一块内存，内存置零，返回其指针（并未初始化）</li><li>根据new(T)的T创建内存，返回<code>*T</code>类型，<code>p := new(Type)</code> 等同于<code>p := &amp; Type{}</code></li></ul></li><li>make(T)：<ul><li>分配一块内存，并初始化，返回地址</li><li>make只能用于初始化slice/map/chan</li></ul></li></ul><p><img src="/images/golang-make-vs-new.png" alt="../_images/golang-make-vs-new.png"></p><p>比较： new([]int) 只分配了一片内存（指向[]int类型，也就是slice的头）但是这块内存的ptr并未初始化，make([]int) 为slice的prt做了初始化</p><p>@ref</p><ul><li>Go 语言中的 make 和 new | Go 语言设计与实现：<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/</a></li></ul><h2 id="panic-amp-recovery"><a href="#panic-amp-recovery" class="headerlink" title="panic &amp; recovery"></a>panic &amp; recovery</h2><p>举例:</p><ul><li>G调用了F;</li><li>F调用panic</li></ul><p>行为:</p><ul><li>调用<code>panic</code>的函数 F被立刻停止, 不再向下执行</li><li>调用函数F中的defer, 然后F返回到它的Caller, G</li><li>G后面的代码不再执行, 执行所有的defer</li><li>程序以非0值退出</li><li>以上 @ref: <a href="https://pkg.go.dev/builtin#panic" target="_blank" rel="noopener">https://pkg.go.dev/builtin#panic</a></li></ul><ul><li>defer 可以嵌套： <code>defer func() { defer xxx }</code></li><li>panic 函数调用后，会终止“调用panic”的Goroutine的执行流程：直接去执行该Goroutine的defer链表中所有函数</li><li>panic 可以嵌套： 可以在defer中再调用panic</li><li>recovery 只能在defer 函数中被调用， 用来终止程序的崩溃</li><li>编译器负责对defer关键字进行转换，在调用 defer 的函数末尾调用 runtime.deferreturn 函数 // 函数退出时一定执行defer</li><li>编译器把recovery关键字转换为<code>runtime.gorecover()</code>函数的调用，实现如下，当前Goroutine没有panic的时候，该函数直接返回，当有panic的时候</li></ul><p>@ref：</p><ul><li>Go 语言 panic 和 recover 的原理 | Go 语言设计与实现：<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</a></li></ul><p>问题：下面的输出顺序（嵌套崩溃）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">defer fmt.Println(&quot;in main&quot;)</span><br><span class="line">defer func() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">panic(&quot;panic again and again&quot;)</span><br><span class="line">&#125;()</span><br><span class="line">panic(&quot;panic again&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">panic(&quot;panic once&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="error"><a href="#error" class="headerlink" title="error"></a>error</h1><ul><li><p><code>error</code>是一个Interface:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">  // 接口只有一个函数,返回字符串</span><br><span class="line">  Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>errors</code>创建一个错误: <code>err := errors.New(&quot;Error occured!&quot;)</code>, 返回的是一个<code>type errorString struct</code>类型的错误</p></li><li>定义自己的error类型: 定义自己的错误Struct类型, 然后实现<code>Error() string</code>方法即可</li></ul><h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><ul><li>defer 后面的表达式在函数退出前执行</li><li>一个func可以有多个 defer语句, 函数退出时执行顺序与定义顺序相反</li></ul><ul><li>每个Gorounite 都定义了一个defer struct链表，新增defer结构是在链表头，函数return之前会调用（从链表头到尾）链表里所有的</li><li>在加入链表时，就需要先计算出传入defer 函数的参数，参数也存储在defer struct中（？不确定），所以…</li><li>如果defer 中对（调用defer的函数的）返回值做了修改，也会影响到返回值（因为<code>return ret</code>不是原子操作，是先赋值再return）</li></ul><p>@ref</p><ul><li>理解 Go 语言 defer 关键字的原理 | Go 语言设计与实现：<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/</a></li><li>defer关键字 · 深入解析Go：<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a></li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul><li>小写开头的成员默认不被序列化</li><li>struct tag: <code>json:&quot;var_name&quot;</code> 指定序列化后的变量名</li><li>struct tag: <code>json:&quot;var_name,omitempty&quot;</code> 如果成员值为”zero-value”, 序列化将不包括此字段</li><li><p>struct tag: <code>json:&quot;-&quot;</code> 序列化时跳过此字段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type YourFirstStruct struct &#123;</span><br><span class="line">  Mem1 string  `json:&quot;variable1&quot;`</span><br><span class="line">  Mem2 string  `json:&quot;variable2,omitempty&quot;`</span><br><span class="line">  Mem3 string  `json:&quot;-&quot;`</span><br><span class="line">  // 每个成员没有分号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Type(struct/map等) → byte[]</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slice_of_byte, err := json.Marshal(obj)</span><br></pre></td></tr></table></figure></li><li><p>byte[] → Type</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj := interface&#123;&#125;</span><br><span class="line">json_str := `&#123;&quot;Name&quot;:&quot;X&quot;, &quot;Age&quot;: 101&#125;`</span><br><span class="line">err := json.Unmarshal([]byte(json_str), &amp;obj)</span><br></pre></td></tr></table></figure></li></ul><h1 id="时间-API"><a href="#时间-API" class="headerlink" title="时间 API"></a>时间 API</h1><ul><li>获取int64时间戳: <code>var timestampSec int32 = time.Now().Unix()</code></li></ul><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><a href="https://geektutu.com/post/quick-go-test.html" target="_blank" rel="noopener">https://geektutu.com/post/quick-go-test.html</a></p><h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>init()函数特性:</p><ul><li>在main之前, 由runtime调用</li><li>init的调用顺序同import package的顺序</li><li>同一个go文件下, 可以有多个init, 调用顺序同定义顺序</li><li>同一个package下, 可以有多个init, 调用顺序似乎是go文件字典顺序, 但不要依赖此顺序做初始化</li><li>用户无法自己调用<code>init()</code>, 会报错undefined</li></ul><p>使用场景:</p><ul><li>做初始化</li><li>实现sync.Once功能呢</li><li>无法用初始化表达式初始的变量</li></ul><h1 id="go-命令行"><a href="#go-命令行" class="headerlink" title="go-命令行"></a>go-命令行</h1><ul><li><a href="https://studygolang.com/articles/10912" target="_blank" rel="noopener">Golang 基本命令及使用 - Go语言中文网 - Golang中文社区</a><blockquote><ul><li>go get -v github.com/rogpeppe/godef</li><li>go get -u -v -f all  下载所有</li><li>有错误: go install git.code.xx.com/trpcprotocol/h323ep/agent_h323ep_go_agent //  go install 后面是git地址?</li></ul></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">go &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation for package or symbol</span><br><span class="line">env         print Go environment information</span><br><span class="line">fix         update packages to use new APIs</span><br><span class="line">fmt         gofmt (reformat) package sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         add dependencies to current module and install them</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified go tool</span><br><span class="line">version     print Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp Tutorials-04-Debug and Perf</title>
      <link href="/11.Programming-Language/Cpp-Tutorials.04.Debug-and-Perf/"/>
      <url>/11.Programming-Language/Cpp-Tutorials.04.Debug-and-Perf/</url>
      
        <content type="html"><![CDATA[<h1 id="排查指针-内存问题-amp-解决方案"><a href="#排查指针-内存问题-amp-解决方案" class="headerlink" title="排查指针/内存问题 &amp; 解决方案"></a>排查指针/内存问题 &amp; 解决方案</h1><p>指针引起的内存问题:</p><ul><li>野指针读写: 野指针指的是未经初始化的指针（似乎<code>int *p;</code>定义的指针没有自动置为Null）</li><li>悬垂指针读写: 被free释放但是没有置为Null的指针</li><li>数组等类型读写越界</li><li>内存释放两次（DF，Double Free），第二次释放导致coredump</li><li>内存泄漏, 通常是不匹配地使用 malloc/new/new[] 和 free/delete/delete[]</li></ul><h2 id="Core-Down问题排查"><a href="#Core-Down问题排查" class="headerlink" title="Core Down问题排查"></a>Core Down问题排查</h2><p>引起core down的原因可能有:</p><ul><li>数组访问越界, 读到错误的数据, 这种情况一般直接Core down?</li><li>数组/指针写越界, 破坏了其他的数据, 这种情况可能当时不引起Core down</li><li>Double Free, 第二次<code>free()</code>直接Core down</li></ul><h3 id="不使用第三方工具"><a href="#不使用第三方工具" class="headerlink" title="不使用第三方工具"></a>不使用第三方工具</h3><p>重载new/ malloc, 申请的内存添加头部/尾部特殊字节(线程id), 并用magic number填充, core down时可以分析是被哪个线程写入了</p><h3 id="使用第三方工具-库解决方案"><a href="#使用第三方工具-库解决方案" class="headerlink" title="使用第三方工具/库解决方案:"></a>使用第三方工具/库解决方案:</h3><h4 id="一些满足特殊现象的分析方法"><a href="#一些满足特殊现象的分析方法" class="headerlink" title="一些满足特殊现象的分析方法:"></a>一些满足特殊现象的分析方法:</h4><ul><li>对于固定会越界的代码位置来说，计算好数据位置，使得越界后第一个字节的内存起始的内存页<code>mprotect</code>写保护中就可以了。随后像man文档的例子一样注册SIGSEGV信号的处理函数即可，这里可以用backtrace(3)和backtrace_symbols(3)等函数来打出调用栈，轻松找过越界的罪魁祸首</li><li><code>gdb</code>调试支持对内存位置设置修改断点，而且gdb的内存断点不像直接用<code>mprotect()</code>有那么多限制</li></ul><h4 id="静态分析工具"><a href="#静态分析工具" class="headerlink" title="静态分析工具"></a>静态分析工具</h4><p>代码静态分析工具, google有很多, 可以检查疑似写内存的问题</p><h4 id="分析coredump文件"><a href="#分析coredump文件" class="headerlink" title="分析coredump文件"></a>分析coredump文件</h4><p>一般方法仍然是分析coredump文件, coredump文件里有哪些有用的信息?</p><ul><li><strong>glibc的MALLOC_CHECK环境变量</strong>,  适用于“double free”, “free(invalid )”<ul><li>实现: 实际上malloc()分配的内存会比用户实际申请的长度大一点，在返回给用户代码的指针位置的前面有一个固定大小的结构，放置着该块内存的长度、属性和管理的数据结构。</li><li>每当在程序运行过程free内存给glibc时，glibc会检查其隐藏的元数据的完整性，如果发现错误就会立即abort。</li></ul></li><li><strong>electric-fence内存调试库</strong>: 适用于内存被写坏, 延后引发的core down。<ul><li>原理是采用Linux的虚拟内存机制来保护动态分配的内存，在申请的内存的位置放置只读的哨兵页，在程序越界读写时直接coredump退出。</li><li>因为对内存做保护使用了mprotect(2)等API，这个API对内存设置只读等属性要求内存页必须是4K对齐的（本质上是Intel CPU的页属性设置的要求），所以内存使用率较低的程序可以用该库进行检查，但是内存使用率很高的程序在使用过程中会造成内存暴涨而不可用。</li></ul></li><li><strong>Valgrind仿真工具</strong>(最常用的是Memcheck) 可以检查: 使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>以上两种工具都很明显影响性能, 新版本的gcc（gcc49）提供了很好的内存访问检查机制<code>命令行参数 -fsanitize=address -fno-omit-frame-pointer</code><ul><li>检查内存越界的实现是..?</li></ul></li><li>另外, Google的 <strong>address sanitizer</strong>（简称asan）是一个用来检测c/c++程序的快速内存检测工具。相比valgrind的优点就是速度快，官方文档介绍对程序性能的降低只有2倍。</li></ul><h2 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h2><ul><li>代码静态检查工具</li><li>Valgrind仿真</li><li>重载全局的malloc / free函数，申请和释放内存的时候打印函数和返回地址（用异步日志库）</li></ul><blockquote><p>C++考虑使用shared_ptr, RAII机制来避免内存泄漏</p></blockquote><h2 id="多线程-amp-高并发情况下"><a href="#多线程-amp-高并发情况下" class="headerlink" title="多线程 &amp; 高并发情况下"></a>多线程 &amp; 高并发情况下</h2><p>在增加debug log/ efence动态库 / 都会严重影响qps导致Core down无法重现, 另外特殊网络环境(高延迟, 丢包)下才会重现的问题</p><ul><li>弱网络环境模拟<code>traffic control</code>: 能够控制网络速率、丢包率、延时等网络环境，作为iproute工具集中的一个工具，由linux系统自带</li><li>Http压测工具<code>wrk</code>, 类似ab</li></ul><p>手动异常测试请求:</p><ol><li>异常的tcp连接。即在客户端 tcp connent系统调用时，10%概率直接close这个socket。</li><li>异常的ssl连接。考虑两种情况，full handshake第一阶段时，即发送 client hello时，客户端10%概率直接close连接。full handshake第二阶段时，即发送 clientKeyExchange时，客户端 10%概率直接直接关闭 TCP连接。</li><li>异常的HTTPS请求，客户端10%的请求使用错误的公钥加密数据，这样nginx解密时肯定会失败。</li></ol><p>使用 tcpcopy等工具在线上引流到测试机器进行压测，如果常规流量达不到重现标准，可以对流量进行放大。若线上搭建环境测试有困难，可以对线上流量抓包，然后在线下重放（tcpdump、tcpreplay和tcprewrite等工具）。<br>这一步之后，一般情况下都能增大重现的概率。如果还难以重现，往往都是一些代码本身的竞态条件（Race Condition）造成的，一般需要在引流测试的同时对CPU或者IO加压，以增大资源竞争的概率来增加问题复现的概率。甚至有些问题是出现网络抖动等情况下，需要模拟弱网络的环境（Linux 2.6内核以上有netem模块，可以模拟低带宽、传输延迟、丢包等情况，使用tc这个工具就可以设置netem的工作模式）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://0xffffff.org/2017/01/22/39-multi-thread-memory-bug/" target="_blank" rel="noopener">Linux环境下多线程C/C++程序的内存问题调试 | 浅墨的部落格</a></li><li><a href="http://wetest.qq.com/lab/view/?id=103" target="_blank" rel="noopener">高并发性能调试经验分享 - 腾讯WeTest</a></li><li><a href="http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html" target="_blank" rel="noopener">定位多线程内存越界问题实践总结 - DJ IN MUSIC - 博客园</a></li></ul><h1 id="程序性能分析"><a href="#程序性能分析" class="headerlink" title="程序性能分析"></a>程序性能分析</h1><p>@ref： <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/" target="_blank" rel="noopener">Perf – Linux下的系统性能调优工具，第 1 部分</a></p><h2 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h2><p>perf应该是最全面最方便的一个性能检测工具。由 linux内核携带并且同步更新，基本能满足日常使用。</p><ul><li>使用 perf，您可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；您也可以分析软件事件，比如 Page Fault 和进程切换。</li><li>使用 Perf 可以计算每个时钟周期内的指令数，称为 IPC，IPC 偏低表明代码没有很好地利用 CPU。</li><li>Perf 还可以对程序进行函数级别的采样，从而了解程序的性能瓶颈究竟在哪里等等。</li></ul><p>通过<code>perf top</code>就能列举出当前系统或者进程的热点事件，函数的排序。 perf record能够纪录和保存系统或者进程的性能事件，用于后面的分析，比如火焰图。</p><h2 id="oprofile"><a href="#oprofile" class="headerlink" title="oprofile"></a>oprofile</h2><p>基本被perf取代</p><blockquote><p>@ref: <a href="http://velep.com/archives/1013.html" target="_blank" rel="noopener">linux性能分析工具oprofile的安装与使用 » reille blog</a></p></blockquote><h2 id="gprof"><a href="#gprof" class="headerlink" title="gprof"></a>gprof</h2><p>gprof主要是针对应用层程序的性能分析工具，缺点是需要重新编译程序，而且对程序性能有一些影响。不支持内核层面的一些统计，优点就是应用层的函数性能统计比较精细，接近我们对日常性能的理解，比如各个函数时间的运行时间，，函数的调用次数等，很人性易读。<br>原理是 编译期前在每个函数增加一个mcount函数调用, 用来记录函数耗时和调用次数。</p><h2 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h2><p>systemtap 其实是一个运行时程序或者系统信息采集框架，主要用于动态追踪，当然也能用做性能分析，功能最强大，同时使用也相对复杂。不是一个简单的工具，可以说是一门动态追踪语言。如果程序出现非常麻烦的性能问题时，推荐使用 systemtap。</p>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp Tutorials-01b-内存</title>
      <link href="/11.Programming-Language/Cpp-Tutorials.01b.%E5%86%85%E5%AD%98/"/>
      <url>/11.Programming-Language/Cpp-Tutorials.01b.%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>自然对齐 <code>naturally aligned</code>（我没找到英文定义，不知道源自哪里）</p><p>比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。<br>如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。<br>对于C/C++中的基本数据类型，假设它的长度为n字节，那么该类型的变量会被编译器默认分配到n字节对齐的内存上。<br>例如，char的长度是1字节，char类型变量的地址将是1字节对齐的（任意值均可）；int的长度是4字节，所以int类型变量将被分配到4字节对齐的地址上。这种默认情况下的变量对齐方式又称作自然对齐（naturally aligned）</p><blockquote><p><a href="https://www.quora.com/What-is-natural-alignment-Why-should-a-generic-pointer-be-aligned" target="_blank" rel="noopener">What is natural alignment? Why should a generic pointer be aligned? - Quora</a></p></blockquote><p>struct 以及含位域的结构体对齐 =&gt; <a href="/11.Programming-Language/C-Tutorials.01.基础/" title="C-Tutorials.01.基础">C-Tutorials.01.基础</a></p><p>更多 =&gt; [[../21.Operating-System/为什么要内存对齐]]</p><h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>回顾: 进程的虚拟内存地址布局</p><p><img src="/images/30mins_tutorial/cpp_vm_model.png" alt="进程虚拟内存布局"></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的<code>brk</code>相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与<code>mmap</code>系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><h2 id="深入理解malloc"><a href="#深入理解malloc" class="headerlink" title="深入理解malloc"></a>深入理解malloc</h2><p><code>void *ptr = malloc(N)</code> 之后发生了什么?</p><ul><li>函数<code>malloc()</code>通过<code>brk()</code>给进程分配了N bytes的线性地址区域(VM)  此时系统并没有随即分配页框(RAM), 进程也没有占用N bytes的物理内存. // 这也表明了, 你时常在使用top的时候VIRT值增大, 而RES值却不变的原因.</li><li>当第一次通过指针使用此内存页, 在RAM中找不到与之相对应的页框. 发生缺页异常, 系统灵敏地捕获这一异常, 进入缺页异常处理阶段：接下来, 系统会分配一个页框(RAM)映射给它, 我们把这种情况(被访问的页还没有被放在任何一个页框中, 内核分配一新的页框并适当初始化来满足调用请求)称为Demand Paging.</li><li>过了很长一段时间, 通过<code>*ptr</code>再次引用内存第一页. 若系统在RAM找不到它映射的页框(可能交换至磁盘了). 发生缺页异常, 并被系统捕获进入缺页异常处理. 接下来, 系统则会分配一页页框(RAM), 找到备份在磁盘的那“页”, 并将它换入内存(其实因为换入操作比较昂贵, 所以不总是只换入一页, 而是预换入多页. 这也表明某些文档说：”vmstat某时出现不少si并不能意味着物理内存不足”).<br>凡是类似这种会迫使进程去睡眠(很可能是由于当前磁盘数据填充至页框(RAM)所花的时间), 阻塞当前进程的缺页异常处理称为主缺页(major falut), 也称为<code>大缺页</code>. 相反, 不会阻塞进程的缺页, 称为次缺页(minor fault).</li><li>通过指针使用到了N bytes的第二页. 参见第一次访问N bytes第一页, “Demand Paging”</li><li>通过<code>free()</code>释放了内存, 线性地址区域被删除, 页框也被释放.</li><li>再次通过<code>*ptr</code>引用内存页, 已被<code>free()</code>了(用户进程本身并不知道). 发生缺页异常, 缺面异常处理程序会检查出这个缺页不在进程内存空间之内. 对待这种编程错误引起的缺页异常, 系统会杀掉这个进程, 并且报告著名的段错误(Segmentation fault).</li></ul><blockquote><p>主缺页异常处理过程示意图,参见 <a href="https://www.slideshare.net/guestb7dc8e/handling-page-fault" target="_blank" rel="noopener">Handling Page Fault</a></p></blockquote><h3 id="Mapping-Area和Heap"><a href="#Mapping-Area和Heap" class="headerlink" title="Mapping Area和Heap"></a>Mapping Area和Heap</h3><ul><li>如果malloc申请的字节数N &gt; 128k, 那么malloc会调用<code>mmap</code>在Mapping Area区申请一块内存.</li><li>对于小于128k的内存, malloc会调用<code>brk</code>在Heap区申请内存.</li><li>Mapping Area和Heap的不同在于:<ul><li>malloc在Mapping Area区申请的内存块, 当调用free时, 虚拟内存和物理内存一起被释放了;</li><li>malloc在Heap区申请的内存, 当调用<code>free(p)</code>时, 如果p指向这块内存的更高的地址还有未free的内存块, p的内存块的虚拟内存/物理内存都不会立刻释放, 而是仅仅标示为”可再分配的”,</li><li>实际上Linux维护了一个结构体链来维护已经分配过的Heap区, 每个结构体都对应一块malloc申请的内存块, 当调用malloc申请内存时(如果小于128k), 系统则会在这个链表里寻找一个”已经free且足够大”的块, 如果找不到符合条件的块, 则会在Heap的<code>Mapped Region</code>申请新的;</li><li>寻找”已经free且足够大”的块有first fit和best fit两种, 如果使用first fit不可避免的有空间浪费</li></ul></li><li>因为Heap区都是小于128k的细碎内存块, 上面的链表可以防止反复申请/释放带来的内存碎片, 但mmap对应的区域都是大块(大于128K)的内存, 所以不用采用上面的机制.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         +-----------+</span><br><span class="line">         |  Mapping  |</span><br><span class="line">         |  Area     |</span><br><span class="line">         +------------- - - -+--</span><br><span class="line">         |           |       |</span><br><span class="line">         |  Unmapped |       |</span><br><span class="line">         |   Region  |       |</span><br><span class="line">         |           |     Heap</span><br><span class="line">break -&gt; +-----------+</span><br><span class="line">         |  Mapped   |       |</span><br><span class="line">         |  Region   |       |</span><br><span class="line">         |           |       |</span><br><span class="line">         +------------- - - -+--</span><br><span class="line">         |   BSS     |</span><br><span class="line">         |   DATA    |</span><br><span class="line">         |   TEXT    |</span><br><span class="line">         +-----------+</span><br></pre></td></tr></table></figure><blockquote><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；<br>而从break往高地址，是未映射的地址空间，如果访问这段空间则程序会报错。</p></blockquote><p>@ref:</p><ul><li><a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html" target="_blank" rel="noopener">CodingLabs - 如何实现一个malloc</a></li><li><a href="https://vinoit.me/2016/05/20/linux-memory-alloc/" target="_blank" rel="noopener">Linux内存分配的原理–malloc/brk/mmap | VZ’s Blog</a></li></ul><h2 id="深入理解new"><a href="#深入理解new" class="headerlink" title="深入理解new"></a>深入理解new</h2><p>C++中的<code>new</code>, <code>operator new</code>, <code>placement new</code>:</p><ol><li>operator new: <code>void* buf = operator new(100)</code>;  operator new只负责申请内存, 在程序中遇到<code>char* buf = new char[100]</code>语句时，它将转换为对函数operator new的调用</li><li>new(new operator): <code>A *a = new A();</code> // 申请内存和构造</li><li>placement new expression(定位表达式) : <code>A *p = new(pArea) A();</code> // prt是被分配好内存的指针<ul><li><code>delete *p</code>和<code>delete pArea</code>的区别?</li></ul></li></ol><h3 id="new-new-operator"><a href="#new-new-operator" class="headerlink" title="new(new operator)"></a>new(new operator)</h3><ul><li>new(<code>new operator</code>或者叫<code>new运算符</code>): 负责分配内存并调用构造函数, 有<code>new</code>和<code>::new</code>之分，前者位于std</li><li>对应的删除<code>delete operator</code>, 调用析构函数并释放内存</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A* a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure><p>通过反汇编可以看出<code>A* = new A</code>会被gcc解析成<code>operator new(sizeof(A))</code>和<code>A()</code>两个步骤, <code>delete a</code>被解析为<code>~A()</code>和<code>operator delete(a)</code>两个步骤。</p><p>通过下面的<code>operator new</code>一节可以得知, 如果一个类重载了operator new函数, new运算符会调用该类自己的operator new版本,<br>但是下面的语句可以指定使用全局的operator new:  <code>A *p = ::new A;</code></p><h3 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h3><ul><li><code>operator new</code>指对new的重载形式，它是一个函数，并不是运算符。只负责分配内存而不会调用构造, 对于<code>operator new</code>来说，分为全局重载和类重载<ul><li>全局重载: <code>void* ::operator new(size_t size)</code></li><li>类中重载: <code>void* A::operator new(size_t size)</code>, 注意operator new的参数是<code>size_t</code>, 返回是void指针</li></ul></li><li><code>operator new()</code>完成的操作一般只是分配内存，事实上系统默认的全局<code>::operator new(size_t size)</code>也只是调用malloc分配内存，并且返回一个<code>void*</code>指针。而构造函数的调用(如果需要)是在new(<code>new operator</code>或者叫<code>new运算符</code>)中完成的。</li><li>如果调用<code>operator new</code>分配内存失败, 会尝试调用new_handler, 如果仍然失败, 则抛出std::bad_alloc</li><li>对应的删除operator delete: <code>operator delete(buf)</code>;</li></ul><p>全局operaotr new 源码:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *__<span class="function">CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// try to allocate size bytes</span></span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>) <span class="comment">//申请空间</span></span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>) <span class="comment">//若申请失败则调用处理函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// report no memory</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc nomem;</span><br><span class="line">            _RAISE(nomem); <span class="comment">// #define _RAISE(x) ::std:: _Throw(x) 抛出nomem的异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何调用operator new：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定调用全局的operator new , 而不是类自己重载的版本 // 存疑</span></span><br><span class="line"><span class="keyword">void</span> *p = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">void</span> *p = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><ul><li><p>operator new有三种形式：</p><ul><li>(1)throwing <code>void* operator new (std::size_t size) throw (std::bad_alloc);</code></li><li>(2)nothrow  <code>void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) throw();</code></li><li>(3)placement <code>void* operator new (std::size_t size, void* ptr) throw();</code></li></ul></li><li><p><code>A* a = new A;</code> 这句代码里的new先是调用了throwing版本的operator new分配内存, 然后调用构造;</p></li><li><code>A* a = new(std::nothrow) A;</code> new先调用nothrow版本的operator new, 然后调用构造;</li><li>placement版本的operator new，它也是对operator new的一个重载，定义于<code>&lt;new&gt;</code>中, 它多接收一个ptr参数，但它只是简单地返回ptr, 内部什么都没有做, 当使用 <strong>placement new expression</strong> 的时候会调用这个版本的operator new</li></ul><h4 id="重载-operator-new"><a href="#重载-operator-new" class="headerlink" title="重载::operator new"></a>重载::operator new</h4><p>Effective C++ 第三版第 50 条列举了定制 new/delete 的几点理由</p><ul><li>检测代码中的内存错误</li><li>优化性能</li><li>获得内存使用的统计数据</li></ul><ol><li>不改变operator new的默认参数重载: 用这种方式的重载，使用方不需要包含任何特殊的头文件，也就是说不需要看见这两个函数声明。“性能优化”通常用这种方式。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"global op new called, size = %zu\n"</span>,sz);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">puts</span>(<span class="string">"global op delete called"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以下调用自定义的operator new/delete:</span></span><br><span class="line">     <span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">     <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">     <span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>增加新的参数的operator new, 为了跟踪内存分配的错误</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">int</span> line)</span></span>;  <span class="comment">// 其返回的指针必须能被普通的 ::operator delete(void*) 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">int</span> line)</span></span>;   <span class="comment">// 这个函数只在析构函数抛异常的情况下才会被调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new (__FILE, __LINE__)会调用构造函数吗?</span></span><br><span class="line">Foo* p = <span class="keyword">new</span> (__FILE, __LINE__) Foo;</span><br></pre></td></tr></table></figure><h4 id="重载class-operator-new"><a href="#重载class-operator-new" class="headerlink" title="重载class::operator new"></a>重载class::operator new</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"custom new for size "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"custom new for size "</span> &lt;&lt; sz &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 以下会调用类成员的operator new/delete</span></span><br><span class="line">     X* p1 = <span class="keyword">new</span> X;</span><br><span class="line">     <span class="keyword">delete</span> p1;</span><br><span class="line">     X* p2 = <span class="keyword">new</span> X[<span class="number">10</span>];</span><br><span class="line">     <span class="keyword">delete</span>[] p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重载时的优先顺序"><a href="#重载时的优先顺序" class="headerlink" title="重载时的优先顺序"></a>重载时的优先顺序</h4><p>在使用 new运算符分配类类型的对象时（如果该类重载了operator new），将调用该类的operator new。<br>在使用 new运算符分配内置类型的对象、未重载operator new函数的类类型的对象、任何类型的数组时，将调用全局operator new 函数。</p><h4 id="new-handler"><a href="#new-handler" class="headerlink" title="new_handler"></a>new_handler</h4><p>operator new失败, 会调用<code>new_handler</code>, 如果<code>new_handler</code>不存在则抛出一个<code>std::bad_alloc</code>异常,<br><code>std::set_new_handler</code>可以为当前operator new指定一个new_handler</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*p_new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::set_new_handler(p_new_handler);</span><br><span class="line"><span class="keyword">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000000000L</span>];</span><br></pre></td></tr></table></figure><p>如何设计一个良好的new_handler ? 《Effective C++》建议以下几种做法(选1即可):</p><ol><li>让更多的内存可以被使用（也就是清理内存，让出更多的空间给这里的内存分配操作）</li><li>安装另一个new_handler（当这个new_handler无法处理当前分配失败的情况时，我们可以装在另外一个new_handler试图处理这种情况）</li><li>卸载new_handler（如果当前的new_handler确实无法处理当前错误，那么就将当前的new_handler卸载，例如nullptr，让new抛出bad::alloc的异常）</li><li>直接抛出bad::alloc的异常</li><li>调用abort()或exit()直接终止程序</li></ol><h3 id="placement-new-expression"><a href="#placement-new-expression" class="headerlink" title="placement new expression"></a>placement new expression</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(T)]; <span class="comment">// 分配内存</span></span><br><span class="line">T* tptr = <span class="keyword">new</span>(ptr) T(<span class="string">"hello"</span>);   <span class="comment">// 在已分配内存进行构造</span></span><br><span class="line">tptr-&gt;~T();                      <span class="comment">// 析构</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure><p>第二行的<code>new(ptr) T(&quot;hello&quot;)</code>会调用operator new的placement形式</p><blockquote><p>delete tptr能释放ptr指向的内存吗?</p></blockquote><h3 id="delete和operator-delete"><a href="#delete和operator-delete" class="headerlink" title="delete和operator delete"></a>delete和operator delete</h3><ul><li>delete: 调用析构函数并释放内存</li><li>operator delete: <code>operator delete(buf)</code></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://blog.csdn.net/solstice/article/details/6198937" target="_blank" rel="noopener">C++ 工程实践(2)：不要重载全局 ::operator new() - CSDN博客</a></li><li><a href="http://zh.cppreference.com/w/cpp/language/new" target="_blank" rel="noopener">new 表达式 - cppreference.com</a></li><li><a href="http://zh.cppreference.com/w/cpp/memory/new/operator_new" target="_blank" rel="noopener">operator new, operator new[] - cppreference.com</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cpp Tutorials-01-基础</title>
      <link href="/11.Programming-Language/Cpp-Tutorials.01.%E5%9F%BA%E7%A1%80/"/>
      <url>/11.Programming-Language/Cpp-Tutorials.01.%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul><li>private(默认访问权限)：只能由1.该类中的函数、2.其友元函数访问。不能被任何其他访问</li><li>protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问</li><li>public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问</li></ul><p>注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。</p><h2 id="类实例内存占用"><a href="#类实例内存占用" class="headerlink" title="类实例内存占用"></a>类实例内存占用</h2><p>@todo: 虚函数表</p><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p><h2 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h2><p>在同一个作用域内(namespace or class)内可以声明几个同名的函数, 函数的参数列表(参数个数/类型/顺序)必须不同, 不能近通过返回值区分重载函数;</p><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>头文件:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *str=<span class="literal">NULL</span>);<span class="comment">//构造函数</span></span><br><span class="line">    MyString(<span class="keyword">const</span> Mystring&amp; obj); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring &amp;obj);</span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>+(<span class="keyword">const</span> Mystring &amp;obj);</span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Mystring &amp;obj);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span>  <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> MyString &amp;obj);</span><br><span class="line">    <span class="keyword">friend</span>  <span class="built_in">std</span>::istream &amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp;in, MyString &amp;obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>源文件:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyString.h"</span></span></span><br><span class="line">Mystring Mystring::<span class="keyword">operator</span>=(<span class="keyword">const</span> Mystring &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分配内存空间，记得+1，因为c风格的字符串以'\n'结尾，需要多加一个字符</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;pstr=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(obj.pstr)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pstr,obj.pstr);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul><li>析构函数virtual的必要性? 如果一个类是作为基类的,那么该类的析构应该写为virtual; 这样在 <code>delete 基类指针</code> 时, 会自动选择相应版本的析构函数.</li></ul><h2 id="类的继承后方法属性变化"><a href="#类的继承后方法属性变化" class="headerlink" title="类的继承后方法属性变化"></a>类的继承后方法属性变化</h2><ul><li>private 属性不能够被继承。</li><li>使用private继承，父类的protected和public属性在子类中变为private；</li><li>使用protected继承，父类的protected和public属性在子类中变为protected；</li><li>使用public继承，父类中的protected和public属性不发生改变;</li></ul><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><ul><li><code>class Divide: public Base1, protected Base2 { ... };</code><ul><li>Base的private在Divide中是否占用空间 // yes</li><li>Base类的static成员, static成员是在堆还是全局区 ?</li><li>继承了多个基类的派生类, 有多个虚函数表,</li><li>如果派生类没有重写任何基类的virtual函数, 派生类也有虚函数表(vtable), 里面是指向基类的函数</li><li>如果派生类没有重写任何基类的virtual函数, 且派生类新建了一个virtual函数, 派生类的虚函数表(vtable)里面依次基类虚函数指针, 派生类自己的虚函数指针</li></ul></li></ul><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>@todo</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="充满风险的隐式类型转换"><a href="#充满风险的隐式类型转换" class="headerlink" title="充满风险的隐式类型转换"></a>充满风险的隐式类型转换</h3><p>施工中</p><h3 id="现实类型转换"><a href="#现实类型转换" class="headerlink" title="现实类型转换"></a>现实类型转换</h3><ul><li>旧风格的类型转换:<ul><li>C 风格（C-style）强制转型: <code>(T) exdivssion</code> // cast exdivssion to be of type T</li><li>函数风格（Function-style）强制转型: <code>T(exdivssion)</code> // cast exdivssion to be of type T</li></ul></li><li><p><code>static_cast</code>: 用法<code>static_cast &lt; type-id &gt; ( expression )</code>,</p><ul><li>上行转换（把子类的指针或引用转换成基类表示）是安全的；</li><li>进行下行转换（把基类指针或引用转换成子类指针或引用），由于没有动态类型检查，所以是不安全的</li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证</li><li><code>static_cast</code>不能转换掉expression的const、volitale、或者__unaligned属性</li><li><code>static_cast</code>转换失败会…[?]  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static_cast 示例</span></span><br><span class="line">Base *a   = <span class="keyword">new</span> Base;</span><br><span class="line">Derived *b = <span class="keyword">static_cast</span>&lt;Derived *&gt;(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.14159265</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>dynamic_cast</code>:  主要用来在继承体系中的安全向下转型。它能安全地将指向基类的指针转型为指向子类的指针或引用，</p><ul><li>为什么需要<code>dynamic_cast</code>强制转换? 当无法使用virtual函数的时候</li><li>如果转型失败会返回null（转型对象为指针时）或抛出异常（转型对象为引用时）</li><li><code>dynamic_cast</code> 会动用运行时信息（RTTI）来进行类型安全检查，因此<code>dynamic_cast</code>存在一定的效率损失。</li><li>基类要有虚函数，否则会编译出错；<code>static_cast</code>则没有这个限制。</li></ul></li></ul><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul><li><a href="https://msdn.microsoft.com/zh-cn/library/hh279674.aspx" target="_blank" rel="noopener">智能指针（现代 C++）</a></li></ul><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>@todo</p><h1 id="C-设计技巧"><a href="#C-设计技巧" class="headerlink" title="C++ 设计技巧"></a>C++ 设计技巧</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>资源获取即初始化（ Resource Acquisition Is Initialization ），或称 RAII。<br>它将必须在使用前请求的资源（被分配的堆内存、执行的线程、打开的接头、打开的文件、被锁的互斥、磁盘空间、数据库连接等——任何存在于受限供给中的事物）的生命周期绑定到一个对象的生存期。</p><p>RAII 可总结如下:</p><ul><li>将资源的操作封装入一个RAII类里:<ul><li>构造函数请求资源，并建立所有类不变量或在它无法完成时抛出异常，</li><li>析构函数释放资源并决不抛出异常；</li></ul></li><li>始终经由RAII类的实例使用资源，在栈上创建RAII类型的函数内变量，当函数退出时依靠”Stack winding”来保证一定调用RAII类的析构函数完成资源释放</li></ul><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;TYPENAME T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RAII</span> &#123;</span></span><br><span class="line">  T* p_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  explicit RAII(T* p) : p_(p) &#123;&#125;</span><br><span class="line">  ~RAII() &#123;</span><br><span class="line">    <span class="keyword">delete</span> p_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> *p_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  RAII(<span class="keyword">const</span> RAII&amp; other);</span><br><span class="line">  RAII&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RAII&amp; other);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">  RAII&lt;SOMERESOURCE&gt; p_;</span><br><span class="line">  RAII&lt;SOMERESOURCE&gt; p2_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Example() :</span><br><span class="line">    p_(<span class="keyword">new</span> SomeResource()),</span><br><span class="line">    p2_(<span class="keyword">new</span> SomeResource()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~Example() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleting Example, freeing SomeResource!/n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>问题: <code>new Example()</code>生成的<code>Example</code>实例, 如果没有调用<code>delete()</code>, <code>RAII</code>类的析构函数会被调用到吗?</p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>错误的加锁:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex.lock();    <span class="comment">// 请求互斥</span></span><br><span class="line">    f();             <span class="comment">// 若 f() 抛异常，则互斥不被释放</span></span><br><span class="line">    mutex.unlock();  <span class="comment">// 抵达此语句，互斥才被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方法, 使用<code>std::lock_guard</code>:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mutex; <span class="comment">// 定义全局的mutex</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">    f(); <span class="comment">// f()抛出异常, 仍然会调用到~lock_guard() 释放锁</span></span><br><span class="line">    <span class="comment">// 运行到这里自动执行~lock_guard()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注:lock_guard是互斥封装器, 构造/析构函数定义如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">explicit lock_guard(Mutex&amp; m_):</span><br><span class="line">    m(m_)</span><br><span class="line">&#123;</span><br><span class="line">    m.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~lock_guard()</span><br><span class="line">    &#123;</span><br><span class="line">        m.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@ref:</p><ul><li><a href="http://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">RAII - cppreference.com</a></li><li><a href="http://www.cnblogs.com/gnuhpc/archive/2012/12/04/2802307.html" target="_blank" rel="noopener">【C++设计技巧】C++中的RAII机制</a></li></ul><h2 id="Pimpl"><a href="#Pimpl" class="headerlink" title="Pimpl"></a>Pimpl</h2><p>这个机制是”Private Implementation”的缩写: 也即 <strong>实现私有化</strong>，力图使得头文件对改变不透明。</p><h3 id="“实现私有化”必要性"><a href="#“实现私有化”必要性" class="headerlink" title="“实现私有化”必要性"></a>“实现私有化”必要性</h3><p>在C++中, 头文件(类的声明)和源文件(类的实现)是分开的,<br>举个例子, 头文件<code>base.h</code>里声明了一个基类<code>Base</code>, 如果改动<code>Base</code>的公有接口, 会导致所有包含<code>base.h</code>的类(调用Base类的代码, 以及Base的派生类)都有重新编译, 在一个大工程中，这样的修改可能导致重新编译时间的激增。你可以使用Doxygen或者SciTools看看头文件依赖。<br>改动公有接口导致的编译时间激增是可以理解的, 但是如果我们改动了<code>Base</code>的私有接口或者成员, 也会导致上面编译时间激增的情况, 这就有些不可接受了.</p><h3 id="如何Pimpl"><a href="#如何Pimpl" class="headerlink" title="如何Pimpl"></a>如何Pimpl</h3><p>MyClass.h 文件内容如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassImpl</span>;</span>   <span class="comment">// forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MyClass();</span><br><span class="line">  ~MyClass();</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  MyClassImpl *m_pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MyClass.cpp 文件内容如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义MyClass的函数:</span></span><br><span class="line">MyClass::MyClass() : m_pImpl(<span class="keyword">new</span> MyClassImpl) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~MyClass() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::foo() &#123;</span><br><span class="line">    <span class="keyword">return</span> m_pImpl-&gt;foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并定义MyClassImpl</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> var++; &#125;</span><br><span class="line">        <span class="keyword">int</span> var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Pimpl要实现的是, 在对类的私有函数/成员做改动时, 不希望(所有包含该头文件的)源文件被重新编译.</li><li><strong>如果一个类被设计为基类，应避免在头文件中出现private函数或成员</strong>， 如果该类有private的函数或成员，最好把它们放进“前置声明（forward declaration）”的类里面，以避免private的声明出现在头文件；</li><li>Java需要这种机制吗 ? 不需要, java里有<code>interface</code>, interface里不包含私有数据的, 所以不会有“改动上层类的私有数据导致编译量增加”这种问题.</li></ul><h3 id="前置声明-forward-declaration"><a href="#前置声明-forward-declaration" class="headerlink" title="前置声明(forward declaration)"></a>前置声明(forward declaration)</h3><p>如果类A中, 有C类型的成员, 则可以在A.h中声明该成员之前, 用<code>class C;</code>的方式来前置声明类型C, 而不再需要在A.h中包含C.h文件:</p><p>A.h头文件:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include "C.h"  // 不再需要这一行了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span> <span class="comment">// 前置声明C</span></span><br><span class="line">    C* ptr; <span class="comment">// 成员声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是使用类型的前置声明是有条件的。假设有一个类C，那么如果你的类中如果有定义类型为C的非静态成员，抑或你的类继承了C的话，就不能使用类Test的前置声明，只能用<code>include C.h</code>的方式<br>大概有三种情况可以使用前置声明：</p><ul><li>参数或返回类型为C的函数声明；</li><li>类型为C的类静态成员；</li><li>类成员变量的类型是 C类型的指针或引用: <code>C*</code>或 <code>C&amp;</code>；</li></ul><p>@ref: <a href="http://www.cnblogs.com/gnuhpc/archive/2012/06/30/2570761.html" target="_blank" rel="noopener">【C++程序设计技巧】Pimpl机制</a></p><h2 id="NVI"><a href="#NVI" class="headerlink" title="NVI"></a>NVI</h2><p>NVI（Non-Virtual Interface ）机制：将虚函数声明为非公有，而将公有函数都声明为非虚 —— 虚拟和公有选其一。</p><ul><li>如果在基类中作为”对外接口”(public)的函数, 一定设计成非virtual的</li><li>当且仅当子类需要调用基类的虚函数时才将虚函数设置为protected</li><li>NVI机制不适用于析构函数，对于析构函数，如果是public的也应该是virtual的</li></ul><blockquote><p>如果一个类是作为基类的,那么该类的析构应该写为virtual; 这样在”delete 基类指针” 时, 会自动选择相应版本的析构函数.</p></blockquote><h3 id="为什么需要NVI"><a href="#为什么需要NVI" class="headerlink" title="为什么需要NVI"></a>为什么需要NVI</h3><p>在标准C++库中我们可以看到这样的一个现象：6个公有虚函数，并且都是std::exception::what()和其重载。142个非公有虚函数。<br>这样设计的目的何在呢，为什么“多此一举”的把虚函数设置为非公有呢？</p><p>先看示例代码:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">         DoFoo1();</span><br><span class="line">         DoFoo2();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoFoo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base's DoFoo1"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoFoo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base's DoFoo2"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoFoo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived's DoFoo2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>因为C++没有Interface的概念, 我们把基类里定义的 <strong>public且非虚的函数</strong> 视作”接口”, 与java中的接口不同的是, 基类的”接口”函数有自己的函数体.</p></blockquote><ul><li>一般在基类的”接口”里定义更上层的代码(参件<code>Foo()</code>函数), 而把具体的实现放进private/protected的虚函数, 这样做的好处是实现了接口和实现的分离;</li><li>派生类可以从基类继承的函数声明为<code>protected virtual</code>的;</li><li>需要派生类自己实现的函数声明为<code>private virtual</code>的;</li></ul><p>Pimpl和NVI都实现了：接口和实现的分离，将不经常变动的控制代码放入public非虚函数，经常变更或者需要派生类重写的放进非public的虚函数。<br>从设计模式上来看，Pimpl用的是委托，NVI用的继承.</p><p>@ref: <a href="http://www.cnblogs.com/gnuhpc/archive/2012/01/17/2324836.html" target="_blank" rel="noopener">【C++程序设计技巧】NVI（Non-Virtual Interface ）</a></p>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C Tutorials-04-C语言 and CPP标准</title>
      <link href="/11.Programming-Language/C-Tutorials.04.C%E5%92%8CCPP%E6%A0%87%E5%87%86/"/>
      <url>/11.Programming-Language/C-Tutorials.04.C%E5%92%8CCPP%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言标准"><a href="#C语言标准" class="headerlink" title="C语言标准"></a>C语言标准</h1><ul><li>C89: 1989 年，C语言由美国国家标准协会（ANSI）进行了标准化，这个版本的语言经常被称作”ANSI C”，或有时称为”C89”</li><li>C99: 在2000年三月，ANSI采纳了ISO/IEC 9899:1999标准。这个标准通常指C99。<ul><li>新特性: 包括内联函数（inline functions）、可变长度的数组、灵活的数组成员（用于结构体）、复合字面量、指定成员的初始化器、对IEEE754浮点数的改进、支持不定参数个数的宏定义，在数据类型上还增加了 long long int 以及复数类型。</li></ul></li><li>C11: 在2011年12月，ANSI采纳了ISO/IEC 9899:2011标准。这个标准通常即C11。<ul><li>新特性: 字节对齐说明符、泛型机制（generic selection）、对多线程的支持、静态断言、原子操作以及对 Unicode 的支持</li></ul></li><li>C18: 在2018年6月，ANSI采纳了ISO/IEC 9899:2018标准，这个标准通常即C18(有时被称为C17)，它是C语言的现行标准。</li></ul><h1 id="C-标准"><a href="#C-标准" class="headerlink" title="C++标准"></a>C++标准</h1><ul><li>C++98: C++98是第一个C++标准。它分为两个部分：核心语言和C++标准程序库；后者包含了大部分标准模板库和C标准程序库的稍加修改版本。存在许多不属于标准部分的C++程序库，且使用外部链接，程序库甚至可以用C撰写。</li><li>C++03:</li><li>C++11:</li><li>C++14</li><li>C++17:</li></ul><h1 id="C-和-C-的异同"><a href="#C-和-C-的异同" class="headerlink" title="C 和 C++的异同"></a>C 和 C++的异同</h1><ul><li>宏与模板: C++ 的模板在设计之初的一个用途就是用来替换宏定义。模板特性在 C++11 后支持了可变长度的模板参数表，可以用来替代 C 中的可变长度函数并保证类型安全。</li><li>指针与引用: C++ 中你仍然可以使用 C 风格的指针，但是对于变量传递而言，更推荐使用 C++ 的 引用 特性来实现类似的功能。由于引用指向的对象不能为空，因此可以避免一些空地址访问的问题。</li><li>struct: 在 C 和 C++ 中都有 struct 的概念，C 中的 struct 用来描述一种固定的内存组织结构，而 C++ 中的 struct 就是一种类，它与类唯一的区别就是它的成员和继承行为默认是 public 的，而一般类的默认成员是 private 的。</li><li>const: const 在 C 中只有限定变量不能修改的功能，而在 C++ 中，由于大量新特性的出现，const 也被赋予的更多用法。C 中的 const 在 C++ 中的继任者是 constexpr</li><li>内存分配: C++ 中新增了 new 和 delete 关键字用来在“自由存储区”上分配空间，这个自由存储区可以是堆也可以是静态存储区，他们是为了配合“类”而出现的。其中 delete[] 还能够直接释放动态数组的内存，非常方便。new 和 delete 关键字会调用类型的构造函数和析构函数，相比 C 中的 malloc()、realloc()、free() 函数，他们对类型有更完善的支持，但是效率不如 C 中的这些函数。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>@ref:</p><ul><li><a href="https://zh.wikipedia.org/wiki/C%2B%2B#C++%E6%A0%87%E5%87%86" target="_blank" rel="noopener">C++ - 维基百科，自由的百科全书</a></li><li><a href="https://huangwang.github.io/2019/06/26/CPlusPlus%E6%A0%87%E5%87%86%E6%BC%94%E5%8C%96%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">C++标准演化简介 | Jack Huang’s Blog</a></li><li><a href="https://www.elliot98.top/post/tech/modern_c_standard/" target="_blank" rel="noopener">现代 C99, C11 标准下的 C 语言编程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C Tutorials-03-make and cmake</title>
      <link href="/11.Programming-Language/C-Tutorials.03.make-and-cmake/"/>
      <url>/11.Programming-Language/C-Tutorials.03.make-and-cmake/</url>
      
        <content type="html"><![CDATA[<h1 id="make-cmake-qmake-区别"><a href="#make-cmake-qmake-区别" class="headerlink" title="make/cmake/qmake 区别"></a>make/cmake/qmake 区别</h1><ul><li><a href="https://www.zhihu.com/question/27455963" target="_blank" rel="noopener">make makefile cmake qmake都是什么，有什么区别？ - 知乎</a></li></ul><h1 id="make-→-Makefile"><a href="#make-→-Makefile" class="headerlink" title="make → Makefile"></a>make → Makefile</h1><h2 id="make-命令"><a href="#make-命令" class="headerlink" title="make 命令"></a>make 命令</h2><ul><li><code>-C DIR，--directory=DIR</code>: 在读取 Makefile 之前，进入到目录 DIR，然后执行 make。当存在多个 “-C” 选项的时候，make 的最终工作目录是第一个目录的相对路径</li><li><code>-e，--enveronment-overrides</code>: 使用环境变量定义覆盖 Makefile 中的同名变量定义。</li><li><code>-f=FILE，--file=FILE，-makefile=FILE</code>: 指定文件 “FILE” 为 make 执行的 Makefile 文件</li></ul><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>@todo</p><h1 id="cmake-→-CMakeLists-txt"><a href="#cmake-→-CMakeLists-txt" class="headerlink" title="cmake → CMakeLists.txt"></a>cmake → CMakeLists.txt</h1>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C Tutorials-01-基础</title>
      <link href="/11.Programming-Language/C-Tutorials.01.%E5%9F%BA%E7%A1%80/"/>
      <url>/11.Programming-Language/C-Tutorials.01.%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul><li>C/C++作为一种强类型语言, 一个变量被使用前必须被定义.</li><li>在32位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(4B) long(4B), float(4B), double(8B), long long(8B);</li><li>在64位系统中基本类型的长度(字节): char(1B), short(2B), int(4B), 指针(<strong>8B</strong>) long(<strong>8B</strong>), float(4B), double(8B), long long(8B);</li><li>long 和 int 范围是<code>[-2^31,2^31)</code>, 即-2147483648~2147483647.</li><li>而unsigned范围是<code>[0,2^32)</code>, 即0~4294967295. 也就是说, 常规的32位整数只能够处理40亿以下的数.</li><li>相比于C++98标准, C++11整型的最大改变就是多了long long<ul><li>long long整型有两种：long long和unsigned long long. 在C++11中, 标准要求long long整型可以在不同平台上有不同的长度, 但至少有64位. 我们在写常数字面量时, 可以使用LL后缀（或是ll）标识一个long long类型的字面量, 而ULL（或ull、Ull、uLL）表示一个unsigned long long类型的字面量. 比如：<code>unsigned long long int ulli = -9000000000000000000ULL;</code></li><li>对于有符号的, 下面的类型是等价的：long long、signed long long、long long int、signed long long int; 对于无符号的：unsigned long long和unsigned long long int也是等价的.</li><li>同其他的整型一样, 要了解平台上<code>long long</code>大小的方法就是查看<code>&lt;climits&gt;</code>（或<code>&lt;limits.h&gt;</code>中的宏）. 与long long整型相关的一共有3个：LLONG_MIN、LLONG_MAX和ULLONG_MIN, 它们分别代表了平台上最小的long long值、最大的long long值, 以及最大的unsigned long long值.</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_min = LLONG_MIN;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ll_max = LLONG_MAX;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull_max = ULLONG_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译选项:g++ -std=c++11 2-2-1.cpp</span></span><br><span class="line">    <span class="comment">// 在代码清单中, 将以上3个宏打印了出来, 对于printf函数来说,</span></span><br><span class="line">    <span class="comment">// 输出有符号的long long类型变量可以用符号%lld,</span></span><br><span class="line">    <span class="comment">// 无符号的unsigned long long则可以采用%llu.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min of long long: %lld\n"</span>, ll_min); <span class="comment">// min of long long: -9223372036854775808</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max of long long: %lld\n"</span>, ll_max); <span class="comment">// max of long long: 9223372036854775807</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"max of unsigned long long: %llu\n"</span>, ull_max);   <span class="comment">// max of unsigned long long: 18446744073709551615</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ref: <a href="https://blog.csdn.net/dos5gw/article/details/6448048" target="_blank" rel="noopener">结构体对齐, 位域, 柔性数组 - DOS5GW的专栏 - CSDN博客</a></p><h2 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h2><p>大端/小端存储（big endian/little endian）:</p><ul><li>MSB＝高权位,LSB＝低权位,比如自然数字0x1A39,1A是MSB,39是LSB,判断大小端存储,可根据数据在内存中存储的地址是以MSB/LSB为地址,<ul><li>大端: LSB在高地址,MSB在低地址;</li><li>小端: MSB在高地址,LSB在低地址;</li></ul></li></ul><p>比如一个int,其LSB作为此数据的首地址(内存中的低地址),则为小端存储;</p><p>比如书写顺序0x1122,11是高字节MSB,22是低字节LSB.<br>如果用大端存储:高地址22,低地址11;<br>如果用小端存储:高地址11,低地址22;</p><p>@ref: <a href="https://blog.csdn.net/dos5gw/article/details/6340996" target="_blank" rel="noopener">大端(Big Endian)与小端(Little Endian)详解 - DOS5GW的专栏 - CSDN博客</a></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul><li>位与<code>&amp;</code>, 位或<code>|</code>, 异或<code>^</code>, 取反<code>~</code>, 位左移<code>&lt;&lt;</code> , 位右移<code>&gt;&gt;</code></li><li>sizeof是C语言的一种单目操作符, 如C语言的其他操作符++、–等. 它并不是函数. sizeof操作符以字节形式给出了其操作数的存储大小. 操作数可以是一个表达式或括在括号内的类型名. 操作数的存储大小由操作数的类型决定. 　<ul><li>当操作数具有数组类型时, 其结果是数组的总字节数</li><li>联合类型操作数的sizeof是其最大字节成员的字节数</li><li>sizeof的优先级为2级, 比乘除等3级运算符优先级高</li></ul></li></ul><blockquote><p><a href="https://www.zhihu.com/question/30526656" target="_blank" rel="noopener">编程语言中, 取余和取模的区别到底是什么？ - 知乎</a><br>当除数和被除数不同符号时: 取余向0方向舍弃小数位, 取模向负无穷方向舍弃小数位, 比如4/(-3)约等于-1.3 :<br>取余: 4 rem 3 = -1;<br>取模: 4 mod 3 = -2;</p></blockquote><h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p>格式化输出printf是一个变参函数, 原型为<code>int printf(char *format,...)</code> ,<br>C语言用宏来处理这些可变参数, 根据参数入栈的特点从最靠近第一个可变参数的固定参数开始, 依次获取每个可变参数的地址.  例如<code>printf (&quot;Decimals: %d %ld\n&quot;, 1977, 650000L);</code><br>需要注意的是格式要跟变量的长度对应, 比如long long要使用<code>%ll</code>, int类型不能使用<code>%c</code>格式.</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组-amp-指针的不同"><a href="#数组-amp-指针的不同" class="headerlink" title="数组 &amp; 指针的不同"></a>数组 &amp; 指针的不同</h2><p>比如有:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><ol><li>初始化的不同<ul><li>在第一句中,以<code>&amp;s[0]</code>开始的连续6个字节内存分别被赋值为: ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘/0’</li><li>第二句中,p被初始化为程序data段的某个地址,该地址是字符串”china”的首地址</li></ul></li><li>sizeof的不同: <code>sizeof(s)</code>应为6, 而sizeof(p)应为一个”指针”的大小.</li><li><code>&amp;</code>取地址操作符的不同:<ul><li><code>&amp;s</code>的类型为pointer to array of 6 chars.</li><li><code>&amp;p</code>的类型为pointer to pointer to char.</li></ul></li></ol><h2 id="数组退化"><a href="#数组退化" class="headerlink" title="数组退化"></a>数组退化</h2><p>数组类型也是一种数据类型, 其本质功能和其他类型无异:定义该类型的数据所占内存空间的大小以及可以对该类型数据进行的操作(及如何操作).<br>数组在某些情况下, “数组类型的变量”会退化成指针类型,<br>这时候无法再获取数组长度, 会影响<code>sizeof</code>操作符的结果,</p><h3 id="数组什么时候会”退化”"><a href="#数组什么时候会”退化”" class="headerlink" title="数组什么时候会”退化”"></a>数组什么时候会”退化”</h3><p>数组在除了3种情况外, 其他时候都要”退化”成指向首元素的指针. 这3中例外情况是:<br>比如有数组 <code>char s[10] = &quot;hello&quot;;</code></p><ol><li><code>sizeof(s)</code></li><li><code>&amp;s</code></li><li>用<code>char s[10]</code>作为左值创建”字符串”, <code>s</code>仍然是数组类型</li></ol><h2 id="静态数组索引-C99"><a href="#静态数组索引-C99" class="headerlink" title="静态数组索引(C99)"></a>静态数组索引(C99)</h2><p>下面的代码向编译器保证, 你传递给f 的指针指向一个具有至少10个int 类型元素的数组的首个元素. 我猜这也是为了优化; 例如, 编译器将会假定a 非空. 编译器还会在你尝试要将一个可以被静态确定为null的指针传入或是一个数组太小的时候发出警告.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个不可修改的数组, 这和说明符<code>int * const a</code>.作用是一样的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">const</span>])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柔性数组-flexible-array"><a href="#柔性数组-flexible-array" class="headerlink" title="柔性数组(flexible array)"></a>柔性数组(flexible array)</h2><p>C99中, 结构中的最后一个元素允许是未知大小的数组, 这就叫做柔性数组成员, 但结构中的柔性数组成员前面必须至少一个其他成员.<br>柔性数组成员允许结构中包含一个大小可变的数组. sizeof返回的这种结构大小不包括柔性数组的内存.<br>包含柔性数组成员的结构用malloc函数进行内存的动态分配, 并且分配的内存应该大于结构的大小, 以适应柔性数组的预期大小.<br>柔性数组到底如何使用呢？看下面例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure><p>有些编译器会报错无法编译可以改成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[];</span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure><p>这样我们就可以定义一个可变长的结构体, 用 <code>sizeof(type_a)</code>得到的只有 4, 就是<code>sizeof(i)=sizeof(int)</code>.<br>那个 0 个元素的数组没有占用空间, 而后我们可以进行变长操作了. 通过如下表达式给结构体分配内存：</p><p><code>type_a *p = (type_a*)malloc(sizeof(type_a) + 100*sizeof(int));</code></p><p>这样我们为结构体指针 p 分配了一块内存(该内存块大小远大于结构的大小). 用 <code>p-&gt;item[n]</code>就能简单地访问可变长元素.<br>但是这时候我们再用 <code>sizeof（*p）</code>测试结构体的大小, 发现仍然为 4.<br>已经确定不包含柔性数组的内存大小. 只是说在使用柔性数组时需要把它当作结构体的一个成员, 仅此而已. 再说白点, 柔性数组其实与结构体没什么关系, 算不得结构体的正式成员.</p><p>需要说明的是：C89不支持这种东西, C99把它作为一种特例加入了标准. 但是, C99<br>所支持的是 incomplete type, 而不是 zero array, 形同 <code>int item[0];</code>这种形式是非法的, C99支<br>持的形式是形同 <code>int item[];</code>只不过有些编译器把 <code>int item[0];</code>作为非标准扩展来支持, 而且在<br>C99发布之前已经有了这种非标准扩展了, C99发布之后, 有些编译器把两者合而为一了.<br>当然, 上面既然用 malloc函数分配了内存, 肯定就需要用 free函数来释放内存：<code>free(p);</code></p><p>@ref:</p><ul><li>结构体对齐 <a href="http://blog.csdn.net/yinkaizhong/archive/2009/12/06/4951288.aspx" target="_blank" rel="noopener">http://blog.csdn.net/yinkaizhong/archive/2009/12/06/4951288.aspx</a></li><li>柔性数组 <a href="http://blog.csdn.net/yiruirui0507/archive/2010/07/22/5756328.aspx" target="_blank" rel="noopener">http://blog.csdn.net/yiruirui0507/archive/2010/07/22/5756328.aspx</a></li></ul><h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><p>➤ 用法: <code>typedef oldType newType</code>:</p><ul><li><code>typedef unsigned char BYTE;</code> // 新定义BYTE</li><li><code>typedef struct Language { ... } LANG;</code> // 新定义LANG</li></ul><p>➤ <code>typedef</code> vs <code>#define</code></p><ul><li>typedef仅可用于类型, define宏还可以用于数值, 例如<code>#define 1 ONE</code></li><li>typedef由编译器进行解释, define宏是由预编译期解释的</li></ul><p>@ref <a href="https://www.runoob.com/cprogramming/c-typedef.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-typedef.html</a></p><h1 id="指针-amp-引用"><a href="#指针-amp-引用" class="headerlink" title="指针&amp;引用"></a>指针&amp;引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>函数指针: <code>typedef void (*pf)(int, int);</code></li><li><p><code>restrict</code>关键词是一个限定词, 可以被用在指针上. 它向编译器保证, 在这个指针的生命周期内, 任何通过该指针访问的内存, 都只能被这个指针改变. 比如,</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">restrict</span> x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">  (*y)++;</span><br><span class="line">  <span class="keyword">int</span> z = *x;</span><br><span class="line">  (*y)--;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="引用-C"><a href="#引用-C" class="headerlink" title="引用(C++)"></a>引用(C++)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>!=&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        <span class="keyword">if</span>(!other.m_data) m_data=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other.m_data)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_data,other.m_data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回this的解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>在C99之前, 你只能按顺序初始化一个结构体. 在C99中你可以这样做</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo = &#123;.z = <span class="number">3</span>, .x = <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>这段代码首先初始化了foo.z,然后初始化了foo.x. foo.y 没有被初始化, 所以被置为0.<br>这一语法同样可以被用在数组中. 以下三行代码是等价的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">4</span>] = <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="结构体字节对齐"><a href="#结构体字节对齐" class="headerlink" title="结构体字节对齐"></a>结构体字节对齐</h2><p>➤ 一般结构体的<code>sizeof</code>, gcc和cl编译器有所不同, 以cl为例:</p><ul><li>结构体成员变量的首地址能够被这个成员（该成员可能是个结构体）最宽基本类型成员的大小所整除;</li><li>sizeof(struct)的值等于struct内最大基本元素长度的整数倍, 如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）.</li><li>每个成员相对结构体首地址的偏移量是该成员长度的整数倍,</li><li>gcc以4的整数倍对齐;</li></ul><blockquote><p>写代码时，通常只需要关注：尽量将数据宽度大的字段(也即较长的double/longlong型变量)放到结构体的前面即可，数据宽度较小的字段无需编译器补齐，从而可以节约内存。</p></blockquote><p>➤ 包含结构体成员的结构体,</p><ul><li>在寻找最宽基本类型成员时, 应当包括“子结构体”的成员;</li><li><p>“子结构体变量”的首地址能够被其最宽基本类型成员的大小所整除;</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;; <span class="comment">//sizeof(S1) = 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c1;</span><br><span class="line">  S1 s;  <span class="comment">//8 bytes</span></span><br><span class="line">  <span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>S1或S3的最宽简单成员的类型都为int, 所以S3的最宽简单类型为int;<br>S3::s的类型是struct S1, 其起始地址是sizeof(int)的整数倍（struct S1最宽的成员是int型）;<br>S3占用内存如下：<br>S3:c1占1字, 填充3字, S1:c占一字, 填充3字, S1:i占4字, S3:c2占1字, 填充3字, 故sizeof(struct S3) = 16;</p></blockquote></li></ul><p>➤ 改变缺省的对齐条件, 即“成员相对于结构体首地址的偏移量, 是成员大小的整数倍”, 变成了“成员相对于结构体首地址的偏移量, 是对齐字节的整数倍”. VC6中使用语法如下：<br>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push) <span class="comment">// 将当前pack设置压栈保存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2) <span class="comment">//按照2字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;; <span class="comment">// 6 bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  c1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">sss</span>;</span></span><br><span class="line">    <span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>#pragma pack(n)</code>, 如果n比结构体成员的sizeof值小, 那么该成员的偏移量应该以此值为准, 结构体成员的偏移量应该取二者的最小值.<br>上面对定义中最宽的int, 和#pragma pack(2)比较, 所以对齐条件是2字节;<br>char S1::c占1字, int S1::i宽度是4, 这里不以4而是以2对齐, 所以int S1::i的起始位置是2, sizeof(S1) == 6.<br>注: 没有任何成员的“空结构体”占1byte;</p></blockquote><h2 id="含位域结构体的sizeof"><a href="#含位域结构体的sizeof" class="headerlink" title="含位域结构体的sizeof"></a>含位域结构体的sizeof</h2><p>使用位域的主要目的是压缩存储, 其大致规则为：</p><ul><li>1) 如果相邻位域字段的类型相同, 且其位宽之和小于类型的sizeof大小, 则后面的字段将紧邻前一个字段存储, 直到不能容纳为止;</li><li>2) 如果相邻位域字段的类型相同, 但其位宽之和大于类型的sizeof大小, 则后面的字段将从新的存储单元开始, 其偏移量为其类型大小的整数倍;</li><li>3) 如果相邻的位域字段的类型不同, 则各编译器的具体实现有差异, VC6采取不压缩方式, Dev-C++采取压缩方式;</li><li>4) 如果位域字段之间穿插着非位域字段, 则不进行压缩;</li><li>5) 整个结构体的总大小为最宽基本类型成员大小的整数倍.</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在 C语言中，字符串实际上是使用 null 字符 <code>\0</code> 终止的一维字符数组。</p><p>在 string.h中提供的字符串api:</p><ul><li>strcpy(s1, s2);</li><li>strcat(s1, s2);</li><li>strlen(s1);</li><li>strcmp(s1, s2);</li><li>strchr(s1, ch);</li><li>strstr(s1, s2);</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>@todo 可变参数 <a href="https://www.runoob.com/cprogramming/c-variable-arguments.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-variable-arguments.html</a></p><h1 id="宏-macro"><a href="#宏-macro" class="headerlink" title="宏(macro)"></a>宏(macro)</h1><p>C/C++的宏定义将一个标识符定义为一个字符串, 源程序中的该标识符均以指定的字符串来代替. 宏的替换是在程序源代码被编译之前, 由预处理器（Preprocessor）对程序源代码进行的处理.<br>宏主要用在宏定义和条件编译</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h3><p><code>#define MAX 1000</code>: 在《Effective C++》中, 这种做法却并不提倡, 书中更加推荐以const常量来代替宏常量. 因为在进行词法分析时, 宏的引用已经被其实际内容替换, 因此宏名不会出现在符号表中. 所以一旦出错, 看到的将是一个无意义的数字, 比如上文中的1000, 而不是一个有意义的名称, 如上文中的MAX. 而const在符号表中会有自己的位置, 因此出错时可以看到更加有意义的错误提示.</p><h3 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&lt;(b) ? (b) : (a))</span></span><br></pre></td></tr></table></figure><p>为什么大量的宏定义中用到了<code>do-while</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x) bar(x); baz(x)</span></span><br><span class="line"><span class="comment">// 如果这样使用宏:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    FOO(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 会被替换成:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    bar(x); baz(x); <span class="comment">// 第二句脱离了if控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进一下, 加上大括号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x)  &#123; bar(x); baz(x); &#125;</span></span><br><span class="line"><span class="comment">// 被替换成这样:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    &#123; bar(x); baz(x); &#125;; <span class="comment">// 多了个分号, 编译错误</span></span><br></pre></td></tr></table></figure><p>所以正确的写法:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(x) do &#123; bar(x); baz(x); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样使用宏:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    FOO(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 会被替换成:</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    <span class="keyword">do</span> &#123; bar(x); baz(x); &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>do{...} while(condition)</code>语句最后可以有分号也可以没有, 这两种语法上都正确</p><h3 id="宏定义中的”-”和”-”"><a href="#宏定义中的”-”和”-”" class="headerlink" title="宏定义中的”#”和”##”"></a>宏定义中的”#”和”##”</h3><p><code>#</code>的功能是将其后面的宏参数进行字符串化操作（Stringfication）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_RUN(func)</span></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="built_in">printf</span>(<span class="string">"entry:"</span>#func<span class="string">"\n"</span>); func(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>#func</code>替换后, 作为字符串拼接, 相当于<code>printf(&quot;entry:&quot; + funcName + &quot;\n&quot;)</code></p><p><code>##</code>##被称为连接符（concatenator）, 用来将两个Token连接为一个Token.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> * name;</span><br><span class="line">  <span class="keyword">void</span> (*function) (<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMAND(NAME) &#123; NAME, NAME ## _command &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后你就用一些预先定义好的命令来方便的初始化一个command结构的数组了：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">command</span> <span class="title">cmds</span>[] = &#123;</span></span><br><span class="line">COMMAND(quit),</span><br><span class="line">COMMAND(help),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><code>#define</code>常与<code>#ifdef</code>, <code>#ifndef</code>, <code>defined</code>指令配合使用, 用于条件编译.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADER_INC_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADER_INC_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>用宏控制debug日志:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Debug information\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>通过DEBUG宏, 我们可以在代码调试的过程中输出辅助调试的信息. 当DEBUG宏被删除时, 这些输出的语句就不会被编译. 更重要的是, 这个宏可以通过编译参数来定义. 因此通过改变编译参数, 就可以方便的添加和取消这个宏的定义, 从而改变代码条件编译的结果.</p><h1 id="whatsrtos博客旧文章"><a href="#whatsrtos博客旧文章" class="headerlink" title="whatsrtos博客旧文章"></a>whatsrtos博客旧文章</h1><ul><li><a href="https://whatsrtos.github.io/blog_archive/[C]%20C%E8%AF%AD%E8%A8%80%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%99%B7%E9%98%B1/" target="_blank" rel="noopener">C语言里面的一些陷阱 | 扔掉笔记 ᐛ</a></li><li><a href="https://whatsrtos.github.io/blog_archive/[C]%20C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/" target="_blank" rel="noopener">C语言的编译与链接 - gcc,ld,ar等工具的介绍 | 扔掉笔记 ᐛ</a></li><li><a href="https://whatsrtos.github.io/blog_archive/[C]%20GNU%E7%9A%84obj%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">GNU的obj分析工具的使用 - nm,objdump | 扔掉笔记 ᐛ</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C Tutorials</title>
      <link href="/11.Programming-Language/06.ObjectiveC-Tutorials/"/>
      <url>/11.Programming-Language/06.ObjectiveC-Tutorials/</url>
      
        <content type="html"><![CDATA[<h1 id="h文件"><a href="#h文件" class="headerlink" title="h文件"></a>h文件</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AnyHeaderFile.h"</span></span></span><br><span class="line">@interface ClassName : SuperClass</span><br><span class="line">&#123;</span><br><span class="line">    @property <span class="keyword">int</span> x; <span class="comment">// @property属性成员, m文件不用自己写getter 和 setter</span></span><br><span class="line">    @property (nonatomic, assign) <span class="keyword">int</span> commentTimeFontSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公有方法</span></span><br><span class="line">+ (<span class="keyword">void</span>) getInstance; <span class="comment">// 静态方法</span></span><br><span class="line">- (type)doItWithA:(type)a;</span><br><span class="line">- (type)doItWithA:(type)a</span><br><span class="line">    ParamB:(type)b</span><br><span class="line">    ParamC:(type)c;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="m文件"><a href="#m文件" class="headerlink" title="m文件"></a>m文件</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"YourClassName.h"</span></span></span><br><span class="line">@<span class="function">interface <span class="title">ClassName</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// m文件里也可以定义interface</span></span></span><br><span class="line">@end</span><br><span class="line">@implementation ClassName &#123;</span><br><span class="line">    <span class="comment">// define private instance variables</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// implement methods</span></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">ClassName * myObject =[[ClassName alloc] init]; <span class="comment">// init可以认作是构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">[myObject doIt];</span><br><span class="line">[myObject doItWithA:a];</span><br><span class="line">[myObject doItWithA:a ParamB:b];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性 @property</span></span><br><span class="line">[myObject setPropertyName:a];</span><br><span class="line">myObject.propertyName = a; <span class="comment">// alt</span></span><br><span class="line">a = [myObject propertyName];</span><br><span class="line">a = myObject.propertyName; <span class="comment">// alt</span></span><br></pre></td></tr></table></figure><h1 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NSString *personOne = @<span class="string">"Ray"</span>;</span><br><span class="line">NSString *personTwo = @<span class="string">"Shawn"</span>;</span><br><span class="line">NSString *combinedString = [NSString stringWithFormat:@<span class="string">"%@: Hello, %@!"</span>, personOne, personTwo];</span><br><span class="line">NSLog(@<span class="string">"%@"</span>, combinedString);</span><br><span class="line"></span><br><span class="line">NSString *tipString = @<span class="string">"24.99"</span>;</span><br><span class="line"><span class="keyword">float</span> tipFloat = [tipString floatValue];</span><br></pre></td></tr></table></figure><h1 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NSMutableArray *<span class="built_in">array</span> = [@[person1, person2] mutableCopy];</span><br><span class="line">[<span class="built_in">array</span> addObject:@<span class="string">"Waldo"</span>];</span><br><span class="line">NSLog(@<span class="string">"%d items!"</span>, [<span class="built_in">array</span> count]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (NSString *person in <span class="built_in">array</span>) &#123;</span><br><span class="line"> NSLog(@<span class="string">"Person: %@"</span>, person);</span><br><span class="line">&#125;</span><br><span class="line">NSString *waldo = <span class="built_in">array</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h1 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个代码块</span></span><br><span class="line">^&#123;</span><br><span class="line">    NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (^simpleBlock)(<span class="keyword">void</span>); <span class="comment">// 相当于函数指针</span></span><br><span class="line">simpleBlock = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"This is a block"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.raywenderlich.com/downloads/RW-Objective-C-Cheatsheet-v-1-5.pdf" target="_blank" rel="noopener">Objective-C Cheat Sheet and Quick Reference</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言快速入门 </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程</title>
      <link href="/11.Programming-Language/05.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/11.Programming-Language/05.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是响应式编程"><a href="#什么是响应式编程" class="headerlink" title="什么是响应式编程"></a>什么是响应式编程</h1><p>响应式编程或反应式编程（英语：Reactive programming）是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。<br>例如，在命令式编程环境中， <code>a:=b+c</code>表示将表达式的结果赋给 a，而之后改变 b或 c的值不会影响 a。<br>但在响应式编程中， a的值会随着 b或 c的更新而更新。</p><p>响应式编程最初是为了简化交互式用户界面的创建和实时系统动画的绘制而提出来的一种方法，但它本质上是一种通用的编程范式。例如，在MVC软件架构中，响应式编程允许将相关模型的变化自动反映到视图上，反之亦然。</p><p>响应式编程的三种模型:</p><ol><li>Actor模型, 实现类库:<ul><li>AKKA Actor: Actor模型为编写并发和分布式系统提供了一种更高的抽象级别。它将开发人员从显式地处理锁和线程管理的工作中解脱出来，使编写并发和并行系统更加容易。</li></ul></li><li>响应式扩展(reactive extensions, Rx)模型, 实现类库:<ul><li>RxJava: Reactive Extensions for Java</li><li>Reactor: Reactor是Pivotal发布的第四代响应式框架，跟RxJava 2有些相似。 Spring WebFlux 以Reactor为基础，实现Web领域的反应式编程框架。</li></ul></li><li>函数响应式编程(functional reactive programming, FRP)模型</li></ol><blockquote><p>@ref <a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">响应式编程 - 维基百科</a></p></blockquote><p>附: 常用编程范式</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">声明式</a>:<ul><li><a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">响应式</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">函数式</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">命令式</a>:<ul><li><a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E7%B7%A8%E7%A8%8B" target="_blank" rel="noopener">过程式</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">面向对象</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">元编程</a></li></ul><h1 id="响应式系统模型"><a href="#响应式系统模型" class="headerlink" title="响应式系统模型"></a>响应式系统模型</h1><h2 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h2><p>Actor模型=数据+行为+消息。Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。<br>Actor是一个个独立的实体，他们之间是毫无关联的。但是，他们可以通过消息来通信。一个Actor收到其他Actor的信息后，它可以根据需要作出各种相应。Actor的常见应用模式是处理大规模并发输入流：将具体工作分类给异步的工作节点，之后返回工作节点计算的结果。<br>Actor模型实际上并不是纯正的函数式编程模型。Receive方法返回Unit类型，这意味着在该方法中，所有事情都是通过副作用完成的。再者，只要需要，Actor模型便会允许使用可变状态，但这里要遵守一个规则，将状态封装在某个actor中，并确保所有状态的响应操作是线程安全的。<br>综上，Actor模型是处理大规模、高度可用、事件驱动应用程序的更为通用的方法。</p><h2 id="函数响应式编程（functional-reactive-programming，FRP）"><a href="#函数响应式编程（functional-reactive-programming，FRP）" class="headerlink" title="函数响应式编程（functional reactive programming，FRP）"></a>函数响应式编程（functional reactive programming，FRP）</h2><p>在函数响应式编程模型中，基于时间的状态需要通过某一系统传播到需要使用这些状态的代码中。当FRP模型中的某一状态发生变化时，你并不需要手动地对依赖这些变化的变量进行更新，与之相反，FRP会使用声明的方式描述数据元素之间的依赖关系，而FRP运行时则会负责状态的传播。因此，用户使用函数式声明语句和组合语法编写代码。</p><p>FRP基本上就是面向异步事件流的编程了，这个异步事件流（Stream）是一个按时间排序的事件序列。Stream是不可变的，任何操作都返回新的Stream，且它是一个Monad。</p><h2 id="响应式扩展（reactive-extensions，Rx）"><a href="#响应式扩展（reactive-extensions，Rx）" class="headerlink" title="响应式扩展（reactive extensions，Rx）"></a>响应式扩展（reactive extensions，Rx）</h2><p>Reactive Extension 这个概念最早出现在.net社区的Rx.net，一个提供处理异步事件的程序库，其核心概念是Observable，表示有限或者无限多个现在或者将来到达的事件。Observable提供了onNext，onError，onCompleted供开发者定制新元素到达，出现错误，或者流结束时的程序的行为。并提供了List上类似的操作，如map，filter，reduce，大大降低了异步事件编程的复杂度。<br>因为这些概念是如此的强大，以至于很多编程语言，如java，ruby，javascript很快就有了各自的reactvie extension。</p><p>Rx模型中的可观察序列代表事件流或其他数据源。通过将可观察序列与LINQ（language-integrated query，语言集成查询）库提供的查询操作符（组合器）拼接起来，Rx组成了异步程序。</p><p>RxJava ( Reactive Extension for Java ) ，Reactive可以翻译为响应式、反应式。<br>ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，<br>Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，<br>Rx库支持.NET、JavaScript和C++，现在已经支持几乎全部的流行编程语言，<br>Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是<a href="http://reactivex.io/" target="_blank" rel="noopener">reactivex.io</a>。<br>RxJava是由Netflix主导做出的提供在JVM上实现Reactive Programming 的一种方式。同类的库还有Project Reactor, Akka 和Google 的 Agera等等。</p><h1 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h1><blockquote><p>Java 9 新特性：Reactive Streams（响应式流）是一个使用非阻塞back pressure（背压机制）的异步流处理标准。在<code>java.util.concurrent</code>包中提供</p></blockquote><ul><li><a href="https://www.cnblogs.com/IcanFixIt/p/7245377.html" target="_blank" rel="noopener">Java 9 揭秘（17. Reactive Streams）</a></li></ul><h1 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h1><blockquote><p>Reactor是Pivotal发布的第四代响应式框架，跟RxJava 2有些相似。 Spring WebFlux 以Reactor为基础，实现Web领域的反应式编程框架。</p></blockquote><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html" target="_blank" rel="noopener">使用 Reactor 进行反应式编程</a></li></ul><h1 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h1><blockquote><p>Reactive Extensions for Java</p></blockquote><ul><li><a href="http://www.infoq.com/cn/articles/rxjava-by-example" target="_blank" rel="noopener">RXJava实例解析</a></li><li><a href="http://www.infoq.com/cn/news/2016/12/rxjava-2-with-reactive-streams" target="_blank" rel="noopener">RxJava 2.0发布：支持响应式流规范</a></li></ul><h1 id="Akka"><a href="#Akka" class="headerlink" title="Akka"></a>Akka</h1><blockquote><p>Actor模型为编写并发和分布式系统提供了一种更高的抽象级别。它将开发人员从显式地处理锁和线程管理的工作中解脱出来，使编写并发和并行系统更加容易。</p></blockquote><ul><li><a href="https://www.jianshu.com/p/db04cab86ab9" target="_blank" rel="noopener">漫谈并发编程：Actor模型 - 简书</a></li><li><a href="https://www.cnblogs.com/MOBIN/p/7236893.html" target="_blank" rel="noopener">Actor模型原理 - MOBIN - 博客园</a></li></ul><h1 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h1><blockquote><p>Java 异步非阻塞编程框架，底层基于Netty异步通信。Vert.x本身是事件驱动、非阻塞纯异步IO模型，这意味着可以使用很少的线程处理大量并发请求。</p></blockquote><ul><li><a href="https://colobu.com/2016/03/31/vertx-thread-model/" target="_blank" rel="noopener">Vert.x 线程模型揭秘 | 鸟窝</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言快速入门 </tag>
            
            <tag> 响应式编程 </tag>
            
            <tag> Reactive </tag>
            
            <tag> Actor </tag>
            
            <tag> RxJava </tag>
            
            <tag> Akka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell Script Tutorials</title>
      <link href="/11.Programming-Language/04.Shell-Tutorials/"/>
      <url>/11.Programming-Language/04.Shell-Tutorials/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-简介"><a href="#Shell-简介" class="headerlink" title="Shell 简介"></a>Shell 简介</h1><p>Shell是用户和 Linux操作系统之间的接口, 也可以看作是命令行的解释器.<br>常见的 Shell Script解释器有:</p><ul><li>sh: 即 Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</li><li>bash: Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。</li><li>zsh: zsh是由Paul Falstad于1990年创建的，它是一个Bourne风格的shell，它包含了bash中的功能，甚至更多。 例如，zsh具有拼写检查功能，可以监视登录/注销，某些内置编程功能（如字节码），支持语法中的科学计数，允许浮点运算和更多功能。</li></ul><p>Shell 脚本文件开头一般会声明用哪种脚本解释器:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><h2 id="如何切换Shell"><a href="#如何切换Shell" class="headerlink" title="如何切换Shell"></a>如何切换Shell</h2><p>切换到 zsh:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>切换到 bash:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure><h1 id="变量-数据类型"><a href="#变量-数据类型" class="headerlink" title="变量, 数据类型"></a>变量, 数据类型</h1><ul><li>变量定义: <code>var=value</code>注意等号两边没有空格,推荐用双引号把右值引用起来</li><li>调用已经定义的变量<code>$var</code>或<code>${var}</code>;</li><li>declare的使用<a href="http://blog.csdn.net/flowingflying/article/details/5146160" target="_blank" rel="noopener">点这里</a>.</li><li>Shell提供语法检测变量是否赋值:<ul><li><code>${var:-value}</code> : 如果var存在且非空, 整个表达式的值是var; 如果var为空或者未定义, 表达式的值是value;</li><li><code>${var:=value}</code> : 如果var存在且非空, 整个表达式的值是var; 如果var为空或者未定义, 表达式的值是value, 并且给var赋值;</li><li><code>${var:+mesg}</code> : 测试var, 如果var存在且非空，则${var:+mesg}的返回值为mesg;如果var为空或未定义，则返回null</li></ul></li><li>如果是把一个命令的结果赋值给某变量:  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=`date`</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">var=$(date)</span><br></pre></td></tr></table></figure></li></ul><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><ul><li>HOME, PS1, 等等</li><li><code>$0</code>: 脚本自身的名称</li><li><code>$1</code> ~ <code>$n</code> : 每个参数, 例如<code>$1</code>是第一个参数</li><li><code>$＃</code>: 所有参数的数量</li><li><code>$*</code> : 所有参数的组成的字符串,比如命令<code>test.sh param1 param2</code>, 其<code>$*</code>的值是”param1 param2”;</li><li><code>$@</code>: 所有参数, 和上面不同的是: <code>$@</code>是由多个子字符串组成的, <code>$@</code>的内容是”param1”, “param2” 这两个字符串;</li><li><code>$?</code>: 上个命令退出状态码, 0表示成功</li><li><code>$$</code>: 当前Shell进程的PID</li><li><code>$!</code>: Shell最后运行的后台Process的PID</li></ul><h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var1=$((1 + 3))</span><br><span class="line">var2=$((var1 + 1)) <span class="comment">## 注意var1前没有</span></span><br><span class="line">var3=`expr <span class="variable">$var2</span> + 1`</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><code>@</code>和<code>*</code>可以获取数组所有元素: <code>${my_array[*]}</code> , <code>${my_array[@]}</code></li><li>数组长度: <code>${＃array[*]}</code>, ＃号在shell里表示长度</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arr1[0]=<span class="string">"cy"</span></span><br><span class="line">arr1[1]=<span class="string">"kz"</span></span><br><span class="line">arr1=(java,php,python) <span class="comment"># 此时[0]和[1]都被覆盖了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr1[*]&#125;</span> <span class="comment"># 以一个字符串打印所有元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr1[@]&#125;</span> <span class="comment"># 每个元素作为一个字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;＃arr1[*]&#125;</span> <span class="comment"># 数组元素个数, 卧槽,,, 这语法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空</span></span><br><span class="line"><span class="built_in">unset</span> arr1[0] <span class="comment"># 仅清空一个元素</span></span><br><span class="line"><span class="built_in">unset</span> arr1[*] <span class="comment"># 清空所有</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>定义: <code>str=&quot;hello&quot;</code></li><li>拼接: <code>str=$str&quot;world&quot;</code></li><li>字符串长度: <code>${＃str}</code></li><li>替换: <code>${源字符串/查找字串/替换字串}</code> :  一个’/‘表示替换第一个’//‘表示替换所有，当查找出中出现了：”/“需要转义成”\/“</li></ul><blockquote><p>常用的字符串替换: <code>arr=(${string//,/ })</code> 可以实现把逗号分隔的字符串转成数组</p></blockquote><h3 id="字符串续行"><a href="#字符串续行" class="headerlink" title="字符串续行"></a>字符串续行</h3><p>shell字符串续行符 “\”，来把一行长字符串分解成多行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Example1: <span class="built_in">echo</span>将输出一行 <span class="string">"continuation     lines"</span></span></span><br><span class="line">echo "continuation \</span><br><span class="line">    lines"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example2: 把一条长命令写为多行</span></span><br><span class="line">commannd1 arg1 arg2 \</span><br><span class="line">arg3 arg4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example3: 定义一个字符串, 写为多行, 但字符串里不包括换行符</span></span><br><span class="line">var="this is \</span><br><span class="line">continuation"</span><br></pre></td></tr></table></figure><h2 id="常用类型比较"><a href="#常用类型比较" class="headerlink" title="常用类型比较"></a>常用类型比较</h2><p>包括文件/字符串/数字比较</p><h3 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h3><ul><li><code>-e filename</code> 如果 filename 存在，则为真</li><li><code>-d filename</code>    如果 filename 为目录，则为真</li><li><code>-f filename</code>   如果 filename 为常规文件，则为真</li><li><code>-L filename</code>   如果 filename 为符号链接，则为真</li></ul><p>Example:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ ! -f /tmp/foo.txt ]; then</span><br><span class="line">    echo "File not found!"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><ul><li><code>-z string</code> 如果 string 长度为零，则为真</li><li><code>-n string</code> 如果 string 长度非零，则为真</li><li><code>string1 = string2</code> 如果 string1 与 string2 相同，则为真</li><li><code>string1 != string2</code> 如果 string1 与 string2 不同，则为真</li><li><code>&quot;$str&quot; == &quot;This&#39;s String&quot;</code> 变量比较字符串</li><li><code>&quot;$sub&quot; =~ &quot; $string &quot;</code>  变量$sub是否包含在字符串$string里, 注意两个空格</li></ul><p>判断字符串是空串:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ "$str" == "" ];then</span><br><span class="line">   echo NULL</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h3><ul><li><code>num1 -eq num2</code> 数字比较, 等于则为真</li><li><code>num1 -ne num2</code> 数字比较, 不等于则为真</li><li><code>num1 -lt num2</code> 小于</li><li><code>num1 -gt num2</code> 大于</li><li><code>num1 -ge num2</code> 大于或等于</li></ul><h1 id="Shell-Scripts中的符号总结"><a href="#Shell-Scripts中的符号总结" class="headerlink" title="Shell Scripts中的符号总结"></a>Shell Scripts中的符号总结</h1><h2 id="井号"><a href="#井号" class="headerlink" title="井号"></a>井号</h2><p><code>#</code>井号: 求长度</p><ul><li>字符串的长度: <code>${＃string}</code></li><li>数组的长度: <code>${＃array[*]}</code></li></ul><h2 id="大中小括号"><a href="#大中小括号" class="headerlink" title="大中小括号"></a>大中小括号</h2><ul><li><code>()</code>小括号, 三种用途<ul><li>命令组: <code>(cmd1; cmd2)</code>括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被括号外的命令使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。</li><li>命令替换: <code>$(cmd)</code> 等同于 <code>`cmd`</code>，原理是 shell先扫描一遍命令行，发现了该行里有<code>$(cmd)</code>结构，便将<code>$(cmd)</code>中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。例如 <code>airportd_pid=$(ps -ef | grep airportd | grep -v grep | awk &#39;{print $2}&#39;)</code></li><li>定义数组: <code>array=(a b c d)</code></li></ul></li><li><p><code>$(())</code>双小括号: 数值计算, 不支持浮点型。例如 <code>$((exp))</code>结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1（false），而一个非零值的表达式所返回的退出状态码将为0（true）。若是逻辑判断，表达式exp为真则为1,假则为0。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 例1:</span></span><br><span class="line">echo $(( groupnum*100 ))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例2: 数值与运算符可以没有空格,变量的使用时也可以不使用<span class="variable">$num</span></span></span><br><span class="line">while ((num&lt;100))</span><br><span class="line">do</span><br><span class="line">    echo "$num"</span><br><span class="line">    ((num=num*2))</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p><code>[]</code>中括号: 见”if-then-else”</p></li><li><code>[[ ]]</code>双中括号: 可以视作<code>[]</code>的升级版版, 对字符串提供了高级特性, 比如支持正则: <code>if [[ $var != &quot;x*&quot; ]]</code></li><li><code>{}</code>花括号: 变量替换, 例如 <code>${var}</code></li></ul><h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>反引号用于命令替换, 同上面的<code>$(cmd)</code>, 例如: <code>count=`echo $var | sed &#39;s/^-//&#39;`</code> 这行命令截去var前置的负号</p><h1 id="控制流程和语句"><a href="#控制流程和语句" class="headerlink" title="控制流程和语句"></a>控制流程和语句</h1><h2 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h2><ul><li><code>cmd1 ; cmd2</code> : 命令顺序执行，命令之间不存在关系，互不影响</li><li><code>cmd1 &amp;&amp; cmd2</code> : cmd1返回0(成功)那么才执行cmd2</li><li><code>cmd1 || cmd2</code> : cmd1返回非0(不成功)那么才执行cmd2</li></ul><h2 id="grouping-commands"><a href="#grouping-commands" class="headerlink" title="grouping commands"></a>grouping commands</h2><h3 id="cmd1-cmd2"><a href="#cmd1-cmd2" class="headerlink" title="(cmd1; cmd2)"></a>(cmd1; cmd2)</h3><p><code>(cmd1; cmd2)</code>：注意cmd2后面没有分号，<code>()</code> 将command group置于sub-shell(子shell) 中去执行，也称 nested sub-shell。<br>括号内对环境变量的修改，不会影响括号外面。</p><h3 id="cmd1-cmd2-1"><a href="#cmd1-cmd2-1" class="headerlink" title="{cmd1; cmd2;}"></a>{cmd1; cmd2;}</h3><p><code>{cmd1; cmd2;}</code>：注意最后一个语句后有分号，<code>{}</code> 则是在同一个shell内完成，也称 non-named command group。<br>Shell的函数跟 non-named command group 是类似的，每个命令之间可以用分号或者换行符隔开。</p><h2 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a>if-then-else</h2><ul><li><code>[</code> 和<code>]</code>前后都要有空格, <code>if</code>与<code>[</code>之间也需要有空格(好操蛋的语法):</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d /root/fff ]; <span class="keyword">then</span></span><br><span class="line">    do_something</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$timeofday</span> = <span class="string">"no"</span> ]; <span class="keyword">then</span></span><br><span class="line">    do_something2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    do_something3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>if [ $a == &quot;true&quot; ]; then</code> 中的then可以写在第二行, 下面的语法也是正确的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ status ]</span><br><span class="line">then</span><br><span class="line">    do_something</span><br><span class="line">else</span><br><span class="line">    do_something2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>多重条件if判断:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ "$bool1" == true ] || [ "$bool1" == true ] &amp;&amp; [ "$bool1" != true ]; then echo 7; fi #1, no output, due to &amp;&amp; IS NOT higher precedence than ||</span><br><span class="line">if [ "$bool1" == true ] || &#123; [ "$bool1" == true ] &amp;&amp; [ "$bool1" != true ] ;&#125;; then echo 7; fi #not same like #1</span><br><span class="line">if &#123; [ "$bool1" == true ] || [ "$bool1" == true ] ;&#125; &amp;&amp; [ "$bool1" != true ]; then echo 7; fi #same like #1</span><br><span class="line"></span><br><span class="line">if [[ "$bool1" == true || "$bool1" == true &amp;&amp; "$bool1" != true ]]; then echo 7; fi #1 #print 7, due to &amp;&amp; higher precedence than ||</span><br><span class="line">if [[ "$bool1" == true ]] || &#123; "$bool1" == true &amp;&amp; "$bool1" != true ;&#125;; then echo 7; fi #same like #1</span><br><span class="line">if &#123; "$bool1" == true ]] || "$bool1" == true ;&#125; &amp;&amp; [[ "$bool1" != true ]] ; then echo 7; fi #not same like #1</span><br></pre></td></tr></table></figure><h3 id="if-in-one-line"><a href="#if-in-one-line" class="headerlink" title="if in one line"></a>if in one line</h3><p><code>if [status]; then do_something; else do_something; fi</code></p><h2 id="for-do-done"><a href="#for-do-done" class="headerlink" title="for-do-done"></a>for-do-done</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> 1 2 3; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以写</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> 1 2 3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对ls返回的内容循环</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(ls);</span><br><span class="line">  <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$f</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环所有子目录</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> */; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$dir</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个文件每行循环</span></span><br><span class="line">cat file | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$line</span>;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个数组循环</span></span><br><span class="line">array=(1 2 3)</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">&#125; &amp; <span class="comment">## 并行执行</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="for-in-one-line"><a href="#for-in-one-line" class="headerlink" title="for in one line"></a>for in one line</h3><p>循环语句写为一行: <code>for var in a b c; do echo $var; done</code></p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>注意中括号<code>[</code>前后的空格:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$i</span>=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt 5 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    do_something</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $var in</span><br><span class="line">string1)</span><br><span class="line">    # do_something</span><br><span class="line">    ;;</span><br><span class="line">string2)</span><br><span class="line">    # do_something</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo "default"</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>shell中的函数都不带参数, 在函数内用<code>$1</code>…<code>$2</code>作为参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">doSomething() &#123;</span><br><span class="line">    echo "hello"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用</span></span><br><span class="line">doSomething param1 param2  # 没有分号!</span><br></pre></td></tr></table></figure><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><blockquote><p>详见:  [[../21.Operating-System/Linux.01.常用命令行#命令重定向]]</p></blockquote><p>Example:</p><ul><li><code>command &gt; outfile 2&gt;&amp;1 &amp;</code></li><li><code>command &lt; infile &gt; outfile</code></li><li>Here document:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -l &lt;&lt; EOF</span><br><span class="line">  hello</span><br><span class="line">  world</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><h1 id="Learn-Shell-in-Y-Minutes"><a href="#Learn-Shell-in-Y-Minutes" class="headerlink" title="Learn Shell in Y Minutes"></a>Learn Shell in Y Minutes</h1><p>【Learn Shell in Y Minutes】 是一个很有意思的项目, 用一段简单的代码介绍 Shell中的各种语法,<br>地址: <a href="https://learnxinyminutes.com/docs/zh-cn/bash-cn/" target="_blank" rel="noopener">Learn X in Y Minutes: Scenic Programming Language Tours</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义数组</span></span><br><span class="line"><span class="comment"># 变量定义,=号前后都不能有空格, 这奇葩语法规则...</span></span><br><span class="line">hosts=(10.10.2.58:8080 10.10.2.58:8090 10.10.50.71:8080)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问数组全部</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;hosts[@]&#125;</span> &gt; <span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;hosts[*]&#125;</span>&gt;&gt; <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令给变量赋值</span></span><br><span class="line">line=`cat <span class="built_in">test</span> | sed <span class="string">"s/ /\n/g"</span> | wc -l`</span><br><span class="line"><span class="comment"># 这是另一种:</span></span><br><span class="line">line=$(cat <span class="built_in">test</span> | sed <span class="string">"s/ /\n/g"</span> | wc -l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># if, 中括号[]前后要有空格</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$line</span> -gt 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'line='</span><span class="variable">$line</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt <span class="variable">$line</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;hosts[$i]&#125;</span></span><br><span class="line">    i=$((i+1))</span><br><span class="line">    <span class="comment"># i=`expr $i+1`</span></span><br><span class="line">    <span class="comment"># i=$(expr $i+1)</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;hosts[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ip=`<span class="built_in">echo</span> <span class="variable">$host</span> | cut -d : -f 1`</span><br><span class="line">    port=`<span class="built_in">echo</span> <span class="variable">$host</span> | cut -d : -f 2`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$ip</span> <span class="variable">$port</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言快速入门 </tag>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
            <tag> Shell </tag>
            
            <tag> 命令行] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP Tutorials</title>
      <link href="/11.Programming-Language/03.PHP-Tutorials/"/>
      <url>/11.Programming-Language/03.PHP-Tutorials/</url>
      
        <content type="html"><![CDATA[<h1 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h1><ul><li><code>$ref =&amp; $a</code> : <code>$ref</code>是一个引用, ‘ref’会被增加到符号表, 但不会新建一个zval, 而是<code>$ref</code>和<code>$a</code>指向同一个zval, <code>zval::is_ref</code>变为1, <code>zval::refcount</code>变为2</li><li>在函数内引用全局变量:</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$var1 = <span class="string">"hello world"</span>;</span><br><span class="line">$var2 = <span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 相当于$var1 =&amp; GLOBALS['var1'], 函数内新建一个本地的引用$var1指向全局变量</span></span><br><span class="line">    <span class="keyword">global</span> $var1,$var2;</span><br><span class="line">    $var2 =&amp; var1; <span class="comment">// 本地的引用$var2重新被指向</span></span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line">var_dump($var2); <span class="comment">// var2仍然是空字串</span></span><br></pre></td></tr></table></figure><p>下面的代码不会改变$bar的值:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(&amp;ref)</span> </span>&#123; <span class="comment">// 新建本地引用变量$ref, 指向$bar</span></span><br><span class="line">    $ref =&amp; GLOBALS[<span class="string">'xxx'</span>]; <span class="comment">// $ref被重新指向</span></span><br><span class="line">&#125;</span><br><span class="line">f($bar);</span><br></pre></td></tr></table></figure><p>unset一个引用, 只是断开了引用和实际变量的连接(php manual原话, 实际做了两件事情: 1从符号表删除这个引用变量的名字,2引用指向的zval的引用计数-1,当引用计数变为0时, zbal::is_ref也变为0), 引用指向的实际变量并不被销毁:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $var; <span class="comment">// 相当于$var &amp; = $GLOBALS['var']</span></span><br><span class="line">    <span class="keyword">unset</span> $var;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的$var不受影响</span></span><br></pre></td></tr></table></figure><p>引用计数: <a href="http://php.net/manual/zh/features.gc.refcounting-basics.php" target="_blank" rel="noopener">zval结构和引用计数</a> 对一个变量$a使用unset, refcount会减1,</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="string">"old string"</span>; <span class="comment">// 符号表里新增一个'a', 内存新建一个zval结构, 此时zal::is_ref是0,引用计数是1</span></span><br><span class="line">$c = $b = $a; <span class="comment">// 符号表新增b和c, 但为了效率没有给b和c新建zval, 而是指向同一个zval</span></span><br><span class="line">xdebug_debug_zval( <span class="string">'a'</span> ); <span class="comment">// a符号对应的zval的引用计数=3, is_ref变成1</span></span><br><span class="line">$c = <span class="string">"new string"</span>;  <span class="comment">// 发生写时复制, 这时候才给c新建一个zval</span></span><br><span class="line">xdebug_debug_zval( <span class="string">'a'</span> ); <span class="comment">// a引用计数=2</span></span><br><span class="line">xdebug_debug_zval( <span class="string">'c'</span> ); <span class="comment">// c是一个新的zval,c引用计数为1</span></span><br><span class="line"><span class="keyword">unset</span>( $b, $c ); <span class="comment">// 从符号表删除b和c, b和c指向的zval各自引用计数-1, 当引用计数减为1时is_ref变为0, 当引用计数减为0时被gc</span></span><br><span class="line">xdebug_debug_zval( <span class="string">'a'</span> ); <span class="comment">// 计数=1</span></span><br><span class="line">xdebug_debug_zval( <span class="string">'c'</span> ); <span class="comment">// 已从符号表删除</span></span><br></pre></td></tr></table></figure><h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><ul><li>在函数内调用全局变量时需要用global关键字声明: <code>global $x,$y;</code> , 注意这里的<code>global</code>是声明而不是定义.</li><li>全局变量: 在函数内<code>global $a</code> 和<code>$GLOBALS[&#39;a&#39;]</code>的区别:  <code>global $var;</code> 是 <code>$var = $GLOBALS[&#39;var&#39;];</code>的简写。所以<code>unset($var)</code>不会影响外面的global. 如果想要在函数中销毁全局变量可以用<code>unset($GLABOL[&#39;var&#39;])</code></li><li>Wordpress的全局变量$wpdb的定义: <code>require_wp_db()</code></li><li><p>常量定义:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&quot;CONST_STRING1&quot;, &quot;Hello world.&quot;);</span><br><span class="line">const CONST_STRING2 = &apos;Hi world&apos;; // 在PHP5.3之后可以用这种方法.</span><br></pre></td></tr></table></figure></li><li><p>如果常量名是动态的, 也可以用函数 <code>constant(&quot;常量名&quot;)</code>来获取常量的值.</p></li><li>用 <code>get_defined_constants()</code> 可以获得所有已定义的常量列表.</li><li>empty, isset, is_null ,is_object, is_array, is_string, is_resource, <a href="http://php.net/manual/en/types.comparisons.php" target="_blank" rel="noopener">参考PHP type comparison tables</a><ul><li><code>empty()</code> : 大致相当于<code>!isset($var) || is_null($var) || !$var</code>, 详见 empty函数说明和 (<a href="http://stackoverflow.com/questions/4559925/why-check-both-isset-and-empty" target="_blank" rel="noopener">http://stackoverflow.com/questions/4559925/why-check-both-isset-and-empty</a>)</li><li><code>isset($a)</code> : 当变量a被赋值, 并且不是null, 那么<code>isset($a)</code>为真.</li><li>如果在函数中<code>unset</code>一个全局变量, 那么仅仅在这个函数中全局变量被销毁了, 在此函数外面仍旧可以使用这个全局变量. 如果想要在函数中销毁全局变量, 需要用<code>unset(GLOBALS[&#39;ha&#39;])</code>来销毁;</li><li><code>is_resource()</code>可以判断<code>fopen</code>返回的文件句柄;</li></ul></li></ul><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul><li>PHP的基本类型有6种: boolean, integer, float, string, 复合类型: array, object;</li><li>在PHP中, 数组和字符串都属于”基本类型”, 基本类型的赋值/函数传递都是传值的;</li><li>(1) boolean: 整数(0)/浮点数(0.0)/对象(NULL)都被视作false, 可以使用<code>boolean is_bool($x)</code>判断是否是boolean型;</li><li>(2) integer: 类似C/C++, 0900, 0x900分别用来表示八进制, 十六进制.</li><li>(3) float: PHP的浮点数和C/C++中的双精度浮点数范围一样, 都是8字节.</li><li>(4) string: 可以使用<code>==</code>号比较两个字符串是否相同, 用<code>boolean is_string($x)</code>判断变量是否是字符串. PHP使用<code>[ ]</code> 或大括号访问字符串的单个字符, 例如<code>$str{0}</code>或<code>$str{$i}</code></li><li>除了单引号和双引号的字符串, PHP还支持nowdoc和heredoc来支持长字符串, nowdoc类似单引号, heredoc类似双引号:</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$nowdoc = &lt;&lt;&lt; <span class="string">'END'</span> <span class="comment">//结束符可以自定义</span></span><br><span class="line">...</span><br><span class="line">END;  <span class="comment">// 遇到结束符表示一段结束, 不要忘记分号</span></span><br><span class="line"></span><br><span class="line">$heredoc = &lt;&lt;&lt; END <span class="comment">// 结束符不带单引号</span></span><br><span class="line">...</span><br><span class="line">END; <span class="comment">// heredoc无法解析$</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><ul><li>参考: (<a href="https://php.net/ref.strings" target="_blank" rel="noopener">https://php.net/ref.strings</a>)</li><li>字符串空格、大小写：<code>trim</code>, <code>ltrim</code>, <code>rtrim</code>, <code>strtolower</code>, <code>strtoupper</code>;</li><li>字符串截取: <code>string substr($str,$start,$len)</code>,</li><li>查找字符串的首次出现: <code>string strstr(string,search)</code>, 如果只是想测试a是b的子串，请使用速度更快耗费内存更少的 strpos() 函数。</li><li>字符串分解: <code>list($a,$b,$c) = explode(&#39;,&#39;, $str)</code>;</li><li>字符串合并: <code>$str_imp = implode(&#39;,&#39;, $array)</code> 将数组的元素合并成一个字符串;</li></ul><h2 id="Web相关字符串处理函数"><a href="#Web相关字符串处理函数" class="headerlink" title="Web相关字符串处理函数"></a>Web相关字符串处理函数</h2><ul><li>HTML实体: <code>htmlentities</code> 区别<code>htmlspecialchars</code>, (<a href="http://www.w3school.com.cn/php/func_string_htmlentities.aspx" target="_blank" rel="noopener">http://www.w3school.com.cn/php/func_string_htmlentities.aspx</a>)</li><li>去除html标签 <code>string strip_tags($htmstr)</code>, 去除<code>&lt;p&gt;,&lt;i&gt;</code>等</li><li>获取HTML mate属性: <code>$arr = get_meta_tags($htmstr)</code></li><li>获取HTTP头: <code>array get_headers($url)</code></li><li>将当前的 QUERY_STRING解析到数组: <code>void parse_str(string,array)</code>, 将url的get参数解析到array,<ul><li>这个函数的输出受到<code>magic_quotes_gpc</code>的影响.</li></ul></li><li>与上面的<code>parse_str()</code>相反, 将array组装为get查询字符串<code>http_build_query($array)</code></li><li>解析URL的要素: <code>array parse_url($url)</code>, 返回包含host,port,user 等</li><li>对URL进行编码:  <code>urlencode($url)</code>: 将非字母字符转换为”%数字”, 空格编码为”+”, 对应解码为<code>urldecode($url)</code></li><li>对URL进行编码:  <code>rawurlencode($url)</code>: 与上面的区别是空格编码为”%20”, 对应解码是<code>rawurldecode($url)</code></li><li>问题: 为什么要对URL进行编码? 哪些需要编码? (<a href="http://www.blogjava.net/donghang73/archive/2011/08/10/356208.html" target="_blank" rel="noopener">http://www.blogjava.net/donghang73/archive/2011/08/10/356208.html</a>)</li><li>更多URL函数参考(<a href="http://php.net/manual/zh/book.url.php" target="_blank" rel="noopener">http://php.net/manual/zh/book.url.php</a>)</li><li>[注1] addslashes() / stripslashes() : (<a href="http://php.net/manual/zh/function.addslashes.php" target="_blank" rel="noopener">http://php.net/manual/zh/function.addslashes.php</a>)</li></ul><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><ul><li>在PHP中字符串是基本类型, 所以<code>==</code>是比较值, 而不是像Java比较字符串引用的指向, 另外int类型的1和”1”用<code>==</code>比较是相等的;</li><li>如果想严格比较字符串, 包括类型比较, 则使用<code>===</code>;</li><li><code>strcmp($1,$2)</code>, <code>strcasecmp($1,$2)</code></li></ul><h2 id="Perl风格正则"><a href="#Perl风格正则" class="headerlink" title="Perl风格正则"></a>Perl风格正则</h2><ul><li><code>boolean preg_match($pattern, $string, $array_match)</code>: 第三参数match也可以没有, match[0]存储完整的$string, match[1]存储…<br>正则表达式快速参考(<a href="https://msdn.microsoft.com/zh-cn/library/az24scfc(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/az24scfc(v=vs.110).aspx</a>)</li></ul><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>echo, print(), printf(), print_r(), var_dump():</p><ul><li><code>echo</code>和<code>print</code>都是语言结构, 有无括号均可使用, echo和print都不是函数所以没有返回值, 所以不要把echo当作if的判断条件;</li><li><code>echo</code>后面可以是一般的变量(包括类的成员), 但不能是array和object;</li><li><code>printf</code>是函数所以有返回值, 和C语言的printf基本一样.</li><li><code>print_r()</code>和<code>var_dump()</code>可以更详细的打印出类型和值;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;1&quot;, &quot;2&quot;, &quot;3&quot;; // echo可以一次输出多个字符</span><br><span class="line">echo (&quot;$var&quot;); // echo 也可以带括号</span><br><span class="line">echo (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); // error! echo不是函数</span><br><span class="line">echo &quot;$_GET[&apos;action&apos;]&quot;; // error!</span><br><span class="line">echo &quot;$&#123;_GET[&apos;action&apos;]&#125;&quot;; // $符号后加个大括号就正确了</span><br></pre></td></tr></table></figure><h1 id="PHP的数组"><a href="#PHP的数组" class="headerlink" title="PHP的数组"></a>PHP的数组</h1><ul><li>测试一个对象是否是数组: <code>is_array($x)</code></li><li>获取数组大小: <code>sizeof($arr)</code>和 <code>count($arr)</code>;</li><li>生成连续数组: <code>range()</code> 例如: <code>$arr = range(1,100)</code> 或者<code>$arr = range(&#39;a&#39;, &#39;z&#39;)</code>;</li><li>为数组元素赋值: <code>array_pad($arr,n,val)</code>, 注意<code>array_pad()</code>返回的是一个新数组, 在原数组$arr基础上,生成一个带有n个初值为val的数组;</li><li><p>从数组中析取多个值:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">list</span>($a,$b,$c) = $arr; <span class="comment">// 变量a,b,c的值分别为1,2,null</span></span><br></pre></td></tr></table></figure></li><li><p>获取子数组:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array_slice()返回是一个新数组, 当然也可以可以用list析取值:</span></span><br><span class="line"><span class="keyword">list</span>($a,$b) = array_slice($arr, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">//返回从$arr[1]开始, 包括arr[1]的3个元素</span></span><br></pre></td></tr></table></figure></li><li><p>检查数组里是否存在Key: <code>if(array_key_exists(&#39;name&#39;, $array))</code>, 能否用<code>if($array[&#39;name&#39;])</code>判断?</p></li><li>检查数组里是否存在Value: <code>if(in_array(&quot;abc&quot;,$array))</code>, 第三个参数可选,true或false表示是否判断类型;</li><li>迭代器(iterator), PHP有一些函数来移动迭代器, 并返回元素: <code>current()</code>, <code>reset()</code>, <code>next()</code>, <code>prev()</code>, <code>key()</code>,<ul><li>迭代器<code>each()</code>返回当前的k和v, 并指向下一个元素: <code>while(list($k, $v) = each($array))</code>;</li></ul></li><li>数组排序: <code>sort()</code>, <code>rsort()</code>,</li><li>翻转数组: <code>array_reverse($arr)</code>,</li><li>合并数组: <code>array_merge($arr1,$arr2)</code>: 对于数字索引的数组, 如果第二个数组有 <em>Key</em> 重复的元素, 这个元素会被分配一个新的索引; 对于字符串索引的数组则覆盖前面的值;<ul><li>思考: 如果两个数组一个是”数字索引”另一个是”字符串索引”, merge的结果是怎样的?</li></ul></li><li>数组相加: <code>$arr1 + $arr2</code>: 相同索引的元素会合并, 和merge的区别是, 如果有索引相同的元素, 加号是保留第一个数组的元素;</li><li>比较数组: <code>$arr_diff = array_diff($arr1,$arr2)</code>, 返回值是<code>$arr1</code>和<code>$arr2</code>的交集, 并且对于数组的value是用<code>===</code>比较的,所以<code>$arr1</code>和<code>$arr2</code>分别有int(1)和”1”也要被算作不同;</li><li>数组作为LIFO堆栈后进先出 : <code>array_push($arr,$elem)</code>和<code>array_pop()</code></li><li><p>更多数组函数参考(<a href="http://php.net/manual/zh/ref.array.php" target="_blank" rel="noopener">http://php.net/manual/zh/ref.array.php</a>)</p></li><li><p>PHP数组的key可以为integer(甚至是负数)和string, value可以为任意类型; key有如下几个转换规则:</p><ol><li>如果key是可以转换成integer的(例如字符型的”8”,布尔型的true), 那么key会被转换为integer;</li><li>当key是float型, 其小数部分会被舍去, 自动转换为integer;</li><li>定义数组时, 多个元素使用同一个key, 这些元素的值会被最后一个覆盖, 比如<code>arr = array(3.1 =&gt; &#39;3.1&#39;, &#39;3&#39; =&gt; &#39;three&#39;);</code>, 最终数组只有一个元素<code>k,v = 3,&#39;three&#39;</code>;</li><li>使用[]符号访问数组成员时, 也符合以上的转换规则, 例如arr[3.1]和arr[‘3’]都会被默认转换为arr[3];</li></ol></li></ul><h2 id="数组引用-references"><a href="#数组引用-references" class="headerlink" title="数组引用(references)"></a>数组引用(references)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$worker = <span class="keyword">array</span>(<span class="string">"Fred"</span>,<span class="string">"Willma"</span>);</span><br><span class="line">$Clone = $worker; <span class="comment">// worker的一份拷贝</span></span><br><span class="line">$Ref =&amp; $worker;  <span class="comment">// 不产生新的拷贝, 仅指向同一个对象</span></span><br><span class="line"></span><br><span class="line">$worker[<span class="number">1</span>] = <span class="number">37</span>;  <span class="comment">// $Clone发生写时复制</span></span><br><span class="line">var_dump($Clone); <span class="comment">// 值没有改变</span></span><br><span class="line">var_dump($Ref);  <span class="comment">// 值改变了</span></span><br></pre></td></tr></table></figure><p>原数组赋值null:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$worker = <span class="keyword">null</span>;</span><br><span class="line">var_dump($Clone); <span class="comment">// 正常访问</span></span><br><span class="line">var_dump($Ref);  <span class="comment">// NULL</span></span><br></pre></td></tr></table></figure><p>删除原数组:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unset</span>($worker); <span class="comment">// 删除原来的数组</span></span><br><span class="line">var_dump($Clone); <span class="comment">// 正常访问</span></span><br><span class="line">var_dump($Ref);  <span class="comment">// 正常访问</span></span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>Obj无论用<code>=</code> 还是<code>=&amp;</code>, 修改其中一个都会影响另一个, 因为Obj的赋值是按引用传递的.</li><li>但是Array和String属于基本类型, 使用<code>=</code>的时候是值传递, 改变一个另一个不受影响, 只有<code>=&amp;</code>按引用传递时才会改变另一个.</li><li><code>unset</code>一个引用只会断开引用和实际变量的连接, 并不会影响实际变量</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>使用<code>unset</code>和<code>$a=null</code>的区别是? (<a href="http://stackoverflow.com/questions/584960/whats-better-at-freeing-memory-with-php-unset-or-var-null" target="_blank" rel="noopener">http://stackoverflow.com/questions/584960/whats-better-at-freeing-memory-with-php-unset-or-var-null</a>)<ul><li><code>$a=null</code> 立即释放内存, 但没有把<code>$a</code>从符号表里删除;</li><li><code>unset($a)</code> 不会立即释放而是在适当时候释放内存(类似Java), 但会立即把<code>$a</code>从符号表删除, 此时再用<code>if($a==null)</code> 会得到一个”未定义变量”的错误.</li><li><code>array_key_exists(&#39;var_name&#39;, $var)</code></li></ul></li></ul><h3 id="引用计数和写时复制"><a href="#引用计数和写时复制" class="headerlink" title="引用计数和写时复制"></a>引用计数和写时复制</h3><ul><li>引用计数 : (<a href="http://php.net/manual/zh/features.gc.refcounting-basics.php" target="_blank" rel="noopener">http://php.net/manual/zh/features.gc.refcounting-basics.php</a>)</li><li>写时复制 : (<a href="http://www.php-internals.com/book/?p=chapt06/06-06-copy-on-write" target="_blank" rel="noopener">http://www.php-internals.com/book/?p=chapt06/06-06-copy-on-write</a>)</li></ul><h1 id="PHP的类型转换"><a href="#PHP的类型转换" class="headerlink" title="PHP的类型转换"></a>PHP的类型转换</h1><p>php中的强制转换和c的语法类似, 强转为string类型还可以使用strval()函数;</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$fst = (string) $foo; <span class="comment">// c风格转换</span></span><br><span class="line"><span class="keyword">echo</span> strval(pow(<span class="number">2</span>,<span class="number">50</span>)); <span class="comment">// 利用函数转换</span></span><br></pre></td></tr></table></figure><h2 id="转换为对象"><a href="#转换为对象" class="headerlink" title="转换为对象"></a>转换为对象</h2><ul><li>如果将一个对象转换成对象, 它将不会有任何变化.</li><li>数组转换成对象将使键名成为属性名并具有相对应的值.</li><li>如果基本类型的值被转换成对象, 将会创建一个内置类 <code>stdClass</code> 的实例. 如果该值为 NULL, 则新的实例为空. 名为 <code>scalar</code> 的成员变量将包含该值</li></ul><ol><li>基本类型转化为对象</li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$obj = (object) <span class="string">'abc'</span>;  <span class="comment">// 字符串转化为对象</span></span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;scalar;  <span class="comment">// outputs 'abc'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数组转换为对象:</li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"One"</span> =&gt; <span class="number">1</span>, <span class="string">"Two"</span> =&gt; <span class="number">2</span>);</span><br><span class="line">$obj = (object)$arr;</span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;One;</span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;Two;</span><br></pre></td></tr></table></figure><h2 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h2><p>对于任意 integer, float, string, boolean 和 resource 类型, 如果将一个值转换为数组, 将得到一个仅有一个元素的数组, 其下标为 0, 该元素即为此标量的值.<br>如果一个 object 类型转换为 array, 结果为一个数组, 其单元为该对象的属性. 键名将为成员变量名, 不过有几点例外：</p><ol><li>整数属性不可访问；私有变量前会加上类名作前缀；</li><li>保护变量前会加上一个 <code>*</code> 做前缀. 这些前缀的前后都各有一个 NULL 字符. 这会导致一些不可预知的行为：</li></ol><h1 id="PHP各种类型的比较"><a href="#PHP各种类型的比较" class="headerlink" title="PHP各种类型的比较"></a>PHP各种类型的比较</h1><p>PHP里的比较运算符<code>==</code>,<code>&gt;</code>,<code>&lt;</code>不区分类型, 只比较”值”, 如果比较符号两边不是同一类型(但是能转换为同一类型)也可以比较. 比如(int)1和(string)”1”用<code>==</code>比较是相等的;<br>如果要做严格的类型比较, 需要用全等于<code>===</code>, 当类型和值都相同时表达式才是true.</p><ul><li><p>PHP的<code>==</code> 和<code>===</code> :</p><ol><li>字符串: 作为PHP的基本类型, 字符串<code>==</code>是比较值而非引用, 所以<code>==</code>和<code>===</code>以及<code>strcmp()</code>都可以用来比较字符串;</li><li>数组<code>==</code>比较: 两个数组的key和value都相等则为true, 顺序可以不同, 类型不必严格相等;</li><li>数组<code>===</code>比较: 两个数组必须顺序一致, 并且key和value的类型也严格相等, 也可以使用<code>array_diff()</code>函数;</li><li>对象<code>==</code>比较: 成员的值相等, 并且两个对象是同一个class类型;</li><li>对象<code>===</code>比较: 必须指向同一个对象</li></ol></li><li><p>不同类型间的比较 :</p><ul><li>上面的情况1要注意: 当其中一个变量不确定类型时(来自用户的输入), 用<code>==</code>比较是危险的, 比如<code>if(0==&#39;pwd123&#39;)</code>是真, 所以strcmp和===才是妥当的字符串比较.</li><li>int/string/array/obj 同boolean比较?  # int(非0), 非空的string(‘false’和’true’), 非空array, 同true做<code>==</code>比较都是真</li><li>int/string/array/obj 同null比较? # int(0),空字符串string(‘’),空数组array() 与null做<code>==</code>比较都是真, if(‘’ == null)是真</li><li>空字符串<code>$b=&#39;&#39;</code>和null用<code>==</code>比较返回真, 用<code>===</code>比较返回假; 只有<code>$b=null</code>之后, <code>if($b === null)</code>才是真</li></ul></li></ul><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li>if-else嵌入到html: (<a href="http://stackoverflow.com/questions/722379/can-html-be-embedded-inside-php-if-statement" target="_blank" rel="noopener">http://stackoverflow.com/questions/722379/can-html-be-embedded-inside-php-if-statement</a>)</li></ul><h1 id="函数-方法"><a href="#函数-方法" class="headerlink" title="函数(方法)"></a>函数(方法)</h1><ul><li>类对象作为参数/返回值: 都是按照引用的方式传递参数.</li><li>函数返回引用:</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> &amp;<span class="title">returns_reference</span><span class="params">()</span> // 函数名前要带一个&amp;符号</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $someref; <span class="comment">// 没有&amp;</span></span><br><span class="line">&#125;</span><br><span class="line">$newref =&amp; returns_reference(); <span class="comment">// 注意这里也需要&amp;符号</span></span><br></pre></td></tr></table></figure><ul><li>函数按引用传参:</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(&amp;$var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $var++;</span><br><span class="line">&#125;</span><br><span class="line">$a=<span class="number">5</span>;</span><br><span class="line">foo($a); <span class="comment">// $a is 6 here</span></span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul><li>“魔术方法” : <code>__sleep()</code>, <code>__wakeup()</code>, <code>__invoke()</code>, 这个函数实际是如何使用的?</li><li>“后期静态绑定”: 在继承中使用<code>self::</code>或者<code>__CLASS__</code>, 取决于函数的定义是由基类or派生类, 如果用<code>static::</code>代替<code>self::</code></li><li>C++具有abstract方法和类, 但没有interface; Java有abstract方法, 但没有抽象类, Java用interface替代抽象类; 但PHP同时具有以上;</li><li>C++用const可以修饰方法和属性, Java没有const关键字而用final修饰常量, 同时final还可以修饰属性(常量),方法和类(不可继承), 形参(同C++的const);</li><li>PHP同时拥有<code>const</code>和<code>final</code>关键字, <code>const</code>修饰常量和类成员常量, <code>final</code>和<code>abstract</code>都可以修饰抽象类和函数</li></ul><p>上代码: 参考(<a href="http://learnxinyminutes.com/docs/zh-cn/php-cn/" target="_blank" rel="noopener">http://learnxinyminutes.com/docs/zh-cn/php-cn/</a>)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyAbstractClass</span> <span class="keyword">implements</span> <span class="title">InterfaceTwo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> MY_CONST      = <span class="string">'value'</span>; <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">static</span> $staticVar   = <span class="string">'static'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $property    = <span class="string">'public'</span>; <span class="comment">// 在这里可以初始化</span></span><br><span class="line">    <span class="keyword">public</span> $instanceProp; <span class="comment">// 类成员要在构造函数里初始化</span></span><br><span class="line">    <span class="keyword">protected</span> $prot = <span class="string">'protected'</span>; <span class="comment">// 当前类和子类可访问</span></span><br><span class="line">    <span class="keyword">private</span> $priv   = <span class="string">'private'</span>;   <span class="comment">// 仅当前类可访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造可以有不同的参数列表, 类似于C++的构造函数重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($instanceProp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::__construct(); <span class="comment">// 要手动调用父类的构造</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;instanceProp = $instanceProp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可被改写的方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">function</span> <span class="title">youCannotOverrideMe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名空间:</span></span><br><span class="line"><span class="comment">// 类会被默认的放在全局命名空间中，可以被一个\来显式调用</span></span><br><span class="line">$cls = <span class="keyword">new</span> \MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为一个文件设置一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">My</span>\<span class="title">Namespace</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以为命名空间起一个别名</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">My</span>\<span class="title">Other</span>\<span class="title">Namespace</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">My</span>\<span class="title">Namespace</span> <span class="title">as</span> <span class="title">SomeOtherNamespace</span>;</span><br><span class="line">$cls = <span class="keyword">new</span> SomeOtherNamespace\MyClass();</span><br></pre></td></tr></table></figure><h2 id="类自省"><a href="#类自省" class="headerlink" title="类自省"></a>类自省</h2><ul><li>类检验: <code>class_exists(&#39;className&#39;)</code>, <code>get_class_methods(&#39;className&#39;)</code>, <code>get_class_vars(&#39;className&#39;)</code>, <code>get_parent_class(&#39;className&#39;)</code>, for example:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$methods_arr = get_class_methods(&apos;ChangyanHandler&apos;); // 返回数组</span><br><span class="line">if(!count($methods_arr)) &#123; ... &#125;</span><br><span class="line">$vars_arr = get_class_vars(&apos;Class&apos;); // 注意只返回有默认值的属性, 数组</span><br><span class="line">// 用foreach(...)遍历类的属性</span><br></pre></td></tr></table></figure><ul><li>对象检验: <code>is_object($obj)</code>, <code>get_class($obj)</code>, <code>bool method_exists(obj, method_name)</code>, <code>get_object_vars($obj)</code>, for example:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$class_name = get_class($obj); // 由类实例获取类名</span><br><span class="line">$vars_arr = get_object_vars($obj); // 只返回有默认值的属性, 数组</span><br></pre></td></tr></table></figure><ul><li><code>if($obj instanceof ChangyanHandler)</code></li></ul><h1 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h1><p><code>$str = serialize($mixed)</code>串行化对象或者数组, <code>$mixed = unserialize($str)</code>从字符串恢复对象或者数组, 在串行化和反串行化操作一个object时, 有两个钩子函数:</p><ul><li><code>__sleep()</code> : 在<code>serialize()</code>之前调用, 在这个函数里你需要关闭已达开的资源, 并返回array, 包含需要串行化的成员名字;</li><li><code>__wakeup()</code> : 在<code>unserialize()</code>之后调用, 在这个函数里你需要重新打开资源;</li></ul><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>引用其他文件：</p><ul><li><code>include &#39;globals.php&#39;</code> :</li><li><code>require &#39;globals.php&#39;</code> : 如果不能被导入时，会抛出错误</li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>@todo</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><p>[注1] 对输入进行安全处理: <code>addslashes()</code>函数对<code>_COOKIE[]</code>, <code>_GET[]</code>, <code>_POST[]</code>的输入进行去引号以及斜线进行转义处理, 注意, <code>magic_quotes_gpc</code>设置为On的时候默认对上面的输入自动进行<code>addslashes()</code>, 不要在该值为On的时候重复调用<code>addslashes</code>, 稳妥的做法是:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (get_magic_quotes_gpc()) &#123;</span><br><span class="line">    $lastname = stripslashes($_POST[&apos;lastname&apos;]); //得到原始的输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性<code>magic_quotes_gpc</code>自从5.4起被移除, 不再推荐使用</p></li><li><p>对于5.4之前的版本也要注意, magic_quotes_gpc只对GET/SET/COOKIE有效, 但没有转义<code>$_SERVER[]</code></p></li><li><p>建议使用 DBMS 指定的转义函数（比如 MySQLi 是 <code>mysqli_real_escape_string()</code>, 但是如果你使用的 DBMS 没有一个转义函数才选择使用使用<code>addslashes()</code>;</p></li><li>Mysqli和PDO都提供了预处理语句<code>prepare()</code>和<code>bind_param()</code>, 使用预处理语句的优点? PDO参数化查询</li><li>对于非array或obj的输入, 可以用<code>intval()</code>转换.</li><li><a href="http://blog.csdn.net/treesky/article/details/7286098" target="_blank" rel="noopener">PDO vs. MySQLi 选择哪一个？</a></li></ul><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><ul><li>全局数组: <code>_COOKIE[]</code>, <code>_GET[]</code>, <code>_POST[]</code>, <code>_FILES</code>, <code>_SERVER[]</code>, <code>_ENV[]</code>:</li><li>数组<code>$_SERVER[]</code>包括的全局变量有:<ul><li>REQUEST_METHOD: 访问页面时的请求方法.例如: “GET”. “HEAD”. “POST”. “PUT”.</li><li>REQUEST_TIME: 请求开始时的时间戳.</li><li>QUERY_STRING: 查询（query）的字符串（URL中第一个问号？之后的内容）.</li><li>DOCUMENT_ROOT: 当前运行脚本所在的文档根目录.在服务器配置文件中定义.</li><li>HTTP_ACCEPT: 当前请求的Accept头信息的内容.</li><li>HTTP_ACCEPT_CHARSET: 当前请求的Accept-Charset头信息的内容.</li><li>SERVER_PROTOCOL: 请求页面时通信协议的和版本, 例如:Http/1.0;</li><li>REQUEST_METHOD: 访问页面时的请求方法.例如:”GET”. “HEAD”. “POST”. “PUT”.</li><li>获取SSL状态 <code>if($_SERVER[&#39;HTTPS&#39;] != &#39;on&#39;) { .. }</code></li></ul></li></ul><h2 id="Http-Header"><a href="#Http-Header" class="headerlink" title="Http Header"></a>Http Header</h2><ul><li>HTTP响应头的设置: 在用<code>header()</code>前不能有任何html输出<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header(&apos;Location: http://segmentfault.com/&apos;); // 重定向</span><br><span class="line">header(&quot;HTTP/1.0 404 Not Found&quot;); // 返回404</span><br><span class="line">header(&apos;Content-type: application/pdf&apos;); // 页面将输出pdf</span><br><span class="line">header(&apos;Content-Type: text/html; charset=utf-8&apos;); // 设置输出html和编码</span><br></pre></td></tr></table></figure></li></ul><p>在任何输出之前, 应该使用<code>header()</code></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h2><p>跨域种Cookie<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 文件a.com/setcookie.php</span><br><span class="line">header(&apos;P3P: CP=&quot;CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR&quot;&apos;);</span><br><span class="line">setcookie(&quot;TestCookie&quot;, $value, time()+3600, &quot;/rasmus/&quot;, &quot;example.com&quot;, 1); // 1小时, &quot;example.com/rasmus&quot;及其子目录有效, Https Only</span><br><span class="line"></span><br><span class="line">// 文件b.com/b_setcookie.php</span><br><span class="line">&lt;script src=&quot;http://a.com/setcookie.php&quot;&gt;&lt;/script&gt;</span><br><span class="line">//访问b.com/b_setcookie.php 能设置a.com的cookie</span><br></pre></td></tr></table></figure></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul><li>session的实现: 在当前域下种”PHPSESSIONID”的cookie, 这个cookie的值就是服务器端对应session的文件名, 可以使用<code>session_save_path()</code>获取设置session存储路径.</li><li>session_start()都做了什么?</li><li>session的同步: NFS, Memcached</li><li><a href="www.infoq.com/cn/news/2015/01/php-session-concurrency-problems">PHP Session可能会引起并发问题</a></li></ul><h2 id="发送Http请求"><a href="#发送Http请求" class="headerlink" title="发送Http请求"></a>发送Http请求</h2><ul><li>Wordpress 支持两种, stream和curl方式, 分别使用<code>stream_context_create</code>和<code>curl_exec</code>实现 具体参考代码<code>WP_Http_Streams::request()</code> 和<code>WP_Http_Curl::request()</code></li><li>安全问题: <code>fsockopen</code>和<code>pfsockopen</code>, 后者是打开一个持续的连接, 在php.ini的选项<code>disable_functions</code>增加”fsockopen” 和<code>allow_url_fopen=Off</code></li><li><a href="http://www.webcrafter.org/2015/01/IDC为什么禁用fsockopen、pfsockopen函数/" target="_blank" rel="noopener">IDC为什么禁用fsockopen、pfsockopen函数</a></li><li>异步请求: <code>curl_multi</code></li></ul><h1 id="php-ini配置"><a href="#php-ini配置" class="headerlink" title="php.ini配置"></a>php.ini配置</h1><ul><li>获取php.ini的设置: <code>$val = ini_get(&#39;magic_quotes_gpc&#39;)</code>;</li><li>php.ini 配置选项列表: (<a href="http://php.net/manual/zh/ini.list.php" target="_blank" rel="noopener">http://php.net/manual/zh/ini.list.php</a>)</li><li>php.ini 安全最佳实践: expose_php, display_errors, log_errors/error_log (<a href="http://www.cyberciti.biz/tips/php-security-best-practices-tutorial.html" target="_blank" rel="noopener">http://www.cyberciti.biz/tips/php-security-best-practices-tutorial.html</a>)</li></ul><h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><ul><li><code>error_reporting=E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT</code> :</li><li><code>display_errors=On</code> : 是否将错误信息作为输出的一部分显示到屏幕</li><li><code>error_log=&quot;D:\xampp\php\logs\php_error_log&quot;</code> : 设置脚本错误将被记录到的文件</li></ul><h1 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h1><p>参考<a href="http://www.ruanyifeng.com/notes/2007/10/php_utf8.html" target="_blank" rel="noopener">十步解决Php Utf-8编码</a>:</p><ol><li>php文件本身必须是UTF-8编码. 不像Java会生成class文件, 避免这个问题</li><li>php要输出头：<code>header(&quot;Content-Type: text/html; charset=UTF-8&quot;)</code></li><li>meta标签无所谓, 有header所有浏览器就会按header来解析</li><li>所有外围都得用UTF8, 包括数据库. *.js, *.css(CSS影响倒不大)</li><li>php本身不是Unicode的, 所有substr之类的函数需改为<code>mb_substr</code>（需要装mbstring扩展）；或者用 <a href="https://www.php.net/manual/en/ref.iconv.php" target="_blank" rel="noopener">iconv functions</a>转码</li></ol><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>参考 (<a href="http://www.imooc.com/video/4169" target="_blank" rel="noopener">http://www.imooc.com/video/4169</a>)</p><ul><li>apache benchmark</li><li>php解析-&gt; 解释器</li><li>内置函数的性能, 实现</li><li>少用魔法函数</li><li>禁用@错误抑制, @是如何实现的?</li><li>及时<code>unset()</code>不使用的, Google: unset会有无法注销变量的情况</li><li>正则对性能的影响</li><li>数组的查找, map</li><li>IO: 磁盘, 数据库, 内存, 网络</li><li>网络请求并行: <code>curl_multi_*</code>,</li></ul><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><ol><li>使用<code>echo</code>,<code>print</code>,<code>var_dump</code>等在页面上显示错误, 需要修改php.ini的<code>display_errors</code>等选项,  <a href="http://www.ibm.com/developerworks/cn/opensource/os-debug/" target="_blank" rel="noopener">参考</a>, 额外的:<a href="http://www.w3school.com.cn/php/func_error_debug_backtrace.asp" target="_blank" rel="noopener">debug_backtrace()</a></li><li>输出到文件: <code>file_put_contents(&#39;debug.log&#39;,&quot;msg...&quot;,FILE_APPEND)</code> , 或者<code>error_log($str, 3, &#39;errors.log&#39;)</code>, 用法<a href="http://www.webkaka.com/tutorial/php/2013/061837/" target="_blank" rel="noopener">参考</a></li><li>线上环境调试: phpstrom+xdebug + chrome（debug helper） or firefox (easy xdebug)</li><li>zend studio + zend debugger , 或者<a href="https://netbeans.org/kb/docs/php/debugging_zh_CN.html" target="_blank" rel="noopener">在 NetBeans IDE PHP 编辑器中调试 PHP 源代码</a></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://php.net/manual/zh/index.php" target="_blank" rel="noopener">PHP: PHP 手册 - Manual</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 11.Programming-Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言快速入门 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alg.LeetcodePattern</title>
      <link href="/01.Algorithm/Alg.LeetcodePattern/"/>
      <url>/01.Algorithm/Alg.LeetcodePattern/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-字符串-数组-链表"><a href="#LeetCode-字符串-数组-链表" class="headerlink" title="#LeetCode 字符串,数组,链表"></a>#LeetCode 字符串,数组,链表</h2><p>➤ 字符串, 数组, 链表 通用指针解法:</p><ul><li>快慢指针: 判断链表是环, 找链表中间</li><li>左右指针: 反转数组, 二分查找</li><li>滑动窗口: 子串</li></ul><h2 id="LeetCode-二叉树"><a href="#LeetCode-二叉树" class="headerlink" title="#LeetCode 二叉树"></a>#LeetCode 二叉树</h2><p>➤ 使用非递归(栈)遍历二叉树有两种:</p><ul><li><code>while(root != null &amp;&amp; !stack.empty())</code> : 适合先序遍历, 思路是 root!=null 则一直向左, 并把遍历到的放入stack, 当从stack中pop出节点时, 意味着节点的左已经遍历过了, 右还没有遍历, 故应把节点的右再进行一轮上面的过程</li><li><code>while(!stack.empty())</code>: 这种每次出栈1个, 处理这个出栈的节点, 然后把该节点的左右子节点加入栈, 适合层序遍历, 也可以用来实现后序遍历;</li></ul><h2 id="LeetCode-滑动窗口-todo"><a href="#LeetCode-滑动窗口-todo" class="headerlink" title="#LeetCode 滑动窗口 @todo"></a>#LeetCode 滑动窗口 @todo</h2>]]></content>
      
      
      <categories>
          
          <category> 01.Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Alg.LeetcodeEtudes</title>
      <link href="/01.Algorithm/Alg.LeetcodeEtudes/"/>
      <url>/01.Algorithm/Alg.LeetcodeEtudes/</url>
      
        <content type="html"><![CDATA[<h2 id="排序-外部排序"><a href="#排序-外部排序" class="headerlink" title="排序 外部排序"></a>排序 外部排序</h2><ul><li>按照内存大小, 文件分块, 每块在内存中排序, 然后写入外存;</li><li>两两归并或者多路归并;</li><li>对于外部排序, 时间花费跟访问外存的次数有关, 访问外存的次数 = 归并的次数 = $logkN$, N是数据规模, k是归并路数;</li></ul><blockquote><p>@ref <a href="http://data.biancheng.net/view/76.html" target="_blank" rel="noopener">一眨眼的功夫了解什么是外部排序算法</a></p></blockquote><h2 id="排序-快速排序"><a href="#排序-快速排序" class="headerlink" title="排序 快速排序"></a>排序 快速排序</h2><blockquote><p>实现快速排序算法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序, 从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> pivotPos = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, pivotPos-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotPos+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotKey = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pivotPointer = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)</span><br><span class="line">            right --;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)</span><br><span class="line">            left ++;</span><br><span class="line">        swap(arr, left, right); <span class="comment">//把大的交换到右边，把小的交换到左边。</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivotPointer, left); <span class="comment">//最后把pivot交换到中间</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索-704-查找有序数组中是否存在给定数字"><a href="#二分搜索-704-查找有序数组中是否存在给定数字" class="headerlink" title="二分搜索 704. 查找有序数组中是否存在给定数字"></a>二分搜索 704. 查找有序数组中是否存在给定数字</h2><blockquote><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找 - 力扣（LeetCode）</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (array[middle] &gt; value)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (array[middle] &lt; value)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表-146-LRU缓存机制"><a href="#哈希表-146-LRU缓存机制" class="headerlink" title="哈希表 146. LRU缓存机制"></a>哈希表 146. LRU缓存机制</h2><blockquote><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制 - 力扣（LeetCode）</a></p></blockquote><p>➤ 解法:</p><ul><li>Node, 包含next, pre两个指针</li><li>Node类型的 head 和 tail // 假设head 是最新访问过的, tail是最旧访问过的</li></ul><blockquote><p>@ref <a href="https://zhuanlan.zhihu.com/p/34133067" target="_blank" rel="noopener">LRU原理和Redis实现</a></p></blockquote><h2 id="哈希表-460-LFU"><a href="#哈希表-460-LFU" class="headerlink" title="哈希表 460. LFU"></a>哈希表 460. LFU</h2><blockquote><p><a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU缓存 - 力扣（LeetCode）</a></p></blockquote><p>➤ 解法:</p><ul><li>双哈希表 + 最小频次计数</li><li>哈希表1, FreqMap, Key=Freq, Val=所有频率为freq的Node (Node 包括k, v, freq)组成的双向链表</li><li>哈希表2, KVMap, Key=k, Val=Node引用</li><li>get():<ul><li>从哈希表2 通过key 获取到 node地址, node.freq++, 复杂度<code>O(1)</code></li><li>在哈希表1 中, 将node从双向链表中删除, 通过node.freq在哈希表1 找到新的位置, 插入双向链表的头部. 复杂度近似<code>O(1)</code></li><li>淘汰: 通过最小频次计数, 从FrepMap 中找到对应的链表, 淘汰链表上所有Node</li></ul></li><li>set():  set的时候才可能出现最小Freq, 相反get的时候可能出现最小频次<ul><li>最小频次的维护: 每次插入的时候, 检查node的freq和最小频次</li></ul></li></ul><h2 id="字符串-14-最长公共前缀"><a href="#字符串-14-最长公共前缀" class="headerlink" title="字符串 14. 最长公共前缀"></a>字符串 14. 最长公共前缀</h2><blockquote><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></p></blockquote><blockquote><p>给一个字符串数组, 求数组中, 所有字符串的最长公共前缀</p></blockquote><p>➤ 解法1: 多路扫描</p><p>➤ 解法2, 纵向扫描</p><p>➤ 解法3:</p><ul><li>设最长公共前缀为 字符串 ans;</li><li>把第一个字符串赋给 ans;</li><li>ans 依次与每个字符串比较, 找出最大公共前缀, 存入ans</li><li>提前终止条件: ans.empty()</li></ul><h2 id="字符串-151-翻转字符串里的单词"><a href="#字符串-151-翻转字符串里的单词" class="headerlink" title="字符串 151. 翻转字符串里的单词"></a>字符串 151. 翻转字符串里的单词</h2><blockquote><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a><br>输入: “the sky is blue”<br>输出: “blue is sky the”</p></blockquote><p>➤ 解法1: // 类似滑动窗口, 双指针</p><ul><li>从数组尾开始双指针, i向前, 直到遇到空格, 记录下i,j的位置(即单词的起止字母), 输出第一个单词</li><li>i,j继续向前扫描</li></ul><p>➤ 解法2: 利用api</p><ul><li>原字符串按空格split, 得到数组</li><li>reverse数组</li><li>遍历数组, append到新串</li></ul><h2 id="字符串-滑动窗口-3-无重复字符的最长子串"><a href="#字符串-滑动窗口-3-无重复字符的最长子串" class="headerlink" title="字符串 #滑动窗口 3. 无重复字符的最长子串"></a>字符串 #滑动窗口 3. 无重复字符的最长子串</h2><blockquote><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p></blockquote><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>输入: “abcabcbb”, 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>➤ 滑动窗口解法:</p><ul><li>开始窗口的左右指针都在0处;</li><li>右指针开始向右走, 遍历到的字符, 先判断是否存在于hashMap, 如果还不存在, 把该字符放入hashMap, k=字符, v=出现的位置, 同时 最长字串的长度++;</li><li>如果右指针遍历到的字符(假设是a[i]), 已经在hashmap, 则”可能”需要改变左指针的位置, 为什么是可能, 因为左指针可能因为几次移动, 被移动到”上次出现a[i]重复字符”的右边了, 这种情况, 虽然map里找到了, 但不需要动左指针</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123; <span class="comment">// i=窗口右指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 右指针i 指向的元素, 是否在map</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">            <span class="comment">// 如果i字符重复, 则判断是否需要移动窗口的左指针</span></span><br><span class="line">            <span class="comment">// 如果left在左, 重复的i在右. 这种情况下需要动左指针</span></span><br><span class="line">            <span class="comment">// 如果重复的i在左, left在右, 这种情况下就不需要动左指针了</span></span><br><span class="line">            left = Math.max(left, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(s.charAt(i),i);</span><br><span class="line">        max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串-滑动窗口-567-字符串的排列"><a href="#字符串-滑动窗口-567-字符串的排列" class="headerlink" title="字符串 #滑动窗口 567. 字符串的排列"></a>字符串 #滑动窗口 567. 字符串的排列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></p></blockquote><blockquote><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的 排列之一 是第二个字符串的子串。<br>s1 = “ab”,  s2 = “eidbaooo”, 结果就是 Ture<br>注意, 可以有重复字符, 比如”aab”</p></blockquote><p>➤ 解法1: 滑动窗口 <a href="https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-muyids-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-muyids-4/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// S2是否包含</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    Map&lt;Char, Integer&gt; map = <span class="keyword">new</span> HashMap(s1.length());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; s1.length(); i++) &#123;</span><br><span class="line">        Char c = s1.charAt(i);</span><br><span class="line">        map[c]++;  <span class="comment">// 伪码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.length()) &#123;</span><br><span class="line"></span><br><span class="line">        Char c = s2.getAt(right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map.existKey(c) &amp;&amp; map.get(c) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右指针找到一个不符合的字符</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s2.getAt(left++) == c) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-121-买卖股票的最佳时机"><a href="#数组-121-买卖股票的最佳时机" class="headerlink" title="数组 121. 买卖股票的最佳时机"></a>数组 121. 买卖股票的最佳时机</h2><blockquote><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p></blockquote><blockquote><p>用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p></blockquote><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><h2 id="数组-122-买卖股票的最佳时机-II"><a href="#数组-122-买卖股票的最佳时机-II" class="headerlink" title="数组 122. 买卖股票的最佳时机 II"></a>数组 122. 买卖股票的最佳时机 II</h2><blockquote><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/best-time-to-buy-and-sell-stock-ii-zhuan-hua-fa-ji/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p></blockquote><blockquote><p>遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。</p></blockquote><h2 id="数组-215-数组中的第K个最大元素"><a href="#数组-215-数组中的第K个最大元素" class="headerlink" title="数组 215. 数组中的第K个最大元素"></a>数组 215. 数组中的第K个最大元素</h2><blockquote><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/?utm_source=LCUS&amp;utm_medium=ip_redirect_q_uns&amp;utm_campaign=transfer2china" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></p></blockquote><p>➤ 解法1:</p><ul><li>创建大小为k的小顶堆, a[0]~a[k-1]放入</li><li>遍历a[k]~a[n-1], 记为a[i]</li><li>如果a[i] 大于 堆顶, 移除堆顶, 放入a[i]</li></ul><p>➤ 解法2:</p><ul><li>类似快排的partition, 找出枢纽: 选取第1个元素作为基准, 左右指针分别指向数组的左右两端, 相向扫描, 交换元素(使左边的都小于基准, 右边大于基准), 最后交换基准和枢纽(指针相遇)</li><li>第一轮得到的枢纽 同k比较,<ul><li>如果枢纽=k, 找到结果</li><li>如果枢纽小于k, 则开始在{k, array.right}区间继续寻找</li><li>如果枢纽大于k, 则在{array.left, k}区间继续寻找</li></ul></li></ul><h2 id="数组-2-1-寻找最小的-k-个数"><a href="#数组-2-1-寻找最小的-k-个数" class="headerlink" title="数组 2.1 寻找最小的 k 个数"></a>数组 2.1 寻找最小的 k 个数</h2><blockquote><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/02.01.html" target="_blank" rel="noopener">2.1 寻找最小的 k 个数</a></p></blockquote><p>➤ 解法1:</p><ul><li>数组a[N]的前k个放入 数组k[]</li><li>遍历k 选出最大的一个记为kmax</li><li>遍历a[] 剩下的 N-k个元素, 如果a[i] &lt; kmax, 用 a[i]  替换K[] 数组里的 kmax, 然后重新第二步..</li><li>复杂度: 步骤2最坏=k, 步骤三里循环 N-k次, 复杂度=<code>O(k*(N-k))</code></li></ul><p>➤ 解法2:</p><ul><li>新建大顶堆, 大小=k, 遍历剩下的 N-k个元素, 大于堆顶则插入堆中,</li><li>复杂度 <code>O((n-k)*logK)</code></li></ul><h2 id="数组-2-2-寻找和为定值的两个数"><a href="#数组-2-2-寻找和为定值的两个数" class="headerlink" title="数组 2.2 寻找和为定值的两个数"></a>数组 2.2 寻找和为定值的两个数</h2><blockquote><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/02.02.html" target="_blank" rel="noopener">2.2 寻找和为定值的两个数</a><br>输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。</p></blockquote><p>➤ 解法1:</p><ul><li>排序数组a, 依次求出a每个的差值, 记为数组b;</li><li>指针i 和 j 分表指向数组 a, b的头和尾,</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: 1、 2、 4、 7、11、15</span><br><span class="line">b: 14、13、11、8、4、 0</span><br></pre></td></tr></table></figure><p>➤ 解法2:</p><ul><li>与上面类似, 构建”a[]每个元素的差”的HashSet, 然后遍历 a[] 查询是否在HashSet.</li><li>复杂度O(2n)</li></ul><p>➤ 解法3:</p><ul><li>先排序, 双端指针</li></ul><h2 id="数组-15-三数之和"><a href="#数组-15-三数之和" class="headerlink" title="数组 15. 三数之和"></a>数组 15. 三数之和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/" target="_blank" rel="noopener">15. 三数之和</a><br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p></blockquote><p>➤ 解法1:</p><ul><li>排序数组</li><li>设三个数的下标为ijk, 遍历数组, 遍历元素设为a[i], jk分别指向 a[i] 后面的数组两端</li><li>如果a[i] &gt; sum, 后面的可以放弃遍历</li></ul><h2 id="数组-18-四数之和"><a href="#数组-18-四数之和" class="headerlink" title="数组 18. 四数之和"></a>数组 18. 四数之和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/4sum/solution/shuang-zhi-zhen-jie-fa-can-zhao-san-shu-zhi-he-ge-/" target="_blank" rel="noopener">18. 四数之和</a><br>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p></blockquote><p>➤ 解法1:</p><ul><li>排序数组</li><li>四个数的下标分别是 ijkl,</li><li>ij在数组最左, k=j+1, l=n-1, k和l开始相向包夹移动</li><li>k和l相遇, 或者终止, 此轮结束</li><li>i不动, j++, 再来一次k和l相向包夹移动求解, 重复这个过程, 直到j移动到数组右端;</li><li>总结: i是外层循环, j是内层循环, a[i]和a[j]的确定四数中的两个, 另外两个数由k, l相向移动求得</li><li>复杂度: O(n^3)</li></ul><h2 id="数组-2-3-寻找和为定值的多个数"><a href="#数组-2-3-寻找和为定值的多个数" class="headerlink" title="数组 2.3 寻找和为定值的多个数"></a>数组 2.3 寻找和为定值的多个数</h2><blockquote><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/02.03.html" target="_blank" rel="noopener">2.3 寻找和为定值的多个数</a><br>输入两个整数: n和sum，从数列1，2，3…….n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。</p></blockquote><h2 id="数组-53-最大子序和"><a href="#数组-53-最大子序和" class="headerlink" title="数组 53. 最大子序和"></a>数组 53. 最大子序和</h2><blockquote><p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/" target="_blank" rel="noopener">53. 最大子序和</a><br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例, 输入: [-2,1,-3,4,-1,2,1,-5,4], 则连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><p>➤ 解法1: 三层循环, 复杂度 O(n^3)</p><ul><li>最外层循环是i // 以a[i]开头的子数组</li><li>第二层循环是j // 以a[i]开头, 结尾分别为a[j]的子数组</li><li>第三层循环是k // 循环a[i]-a[j], 求和</li></ul><p>➤ 解法1: 使用动态规划</p><ul><li>定义 F（i） = 以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变;</li><li>那么有 F（i）= max（F（i-1）+array[i] ，array[i]） ;</li><li>意思是: array[i] 可以加入前面的序列组成新子序列, 或者扔掉前面, array[i]自己组成一个新子序列;</li><li>array[i] 是否加入前面的子序列, 取决于 F（i-1）大于or小于0</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxAns = array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i; i&lt;array.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre &lt; <span class="number">0</span>) pre = <span class="number">0</span>;</span><br><span class="line">    pre += array[i];</span><br><span class="line">    maxAns = max(pre, maxANs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组-128-最长连续序列"><a href="#数组-128-最长连续序列" class="headerlink" title="数组 128. 最长连续序列"></a>数组 128. 最长连续序列</h2><blockquote><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a><br>给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。<br>数组 [100, 4, 200, 1, 3, 2], 最长连续序列是 [1, 2, 3, 4]</p></blockquote><p>➤ 解法1:</p><ul><li>注意这道题不是找子数组, 所以不用滑动窗口;</li><li>开始需要将array 所有元素放入一个HashSet</li><li>遍历array, 设下标0-i循环,  每次都是一个从a[i]开头的序列, 如果数组中存在值为 a[i]+1, 则继续在数组里寻找. 直到找不到连续的 a[i] + x, 记录下长度</li><li>继续从array取出下一个元素, 开始「以a[i+1]为开头的连续子序列」, 这里有个可以降低复杂度的点: 如果数组中不存在值为 a[i] - 1， 则a[i-1]可以跳过</li></ul><p>➤ 解法2: <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/hashsetyi-dan-yi-ge-shu-bei-sao-miao-zhi-jie-jiang/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/hashsetyi-dan-yi-ge-shu-bei-sao-miao-zhi-jie-jiang/</a></p><ul><li>与上面解法类似, 放入HashSet</li><li>从array[0]开始, 在HashSet中寻找比array[0]小的连续元素(往前找), 再在HashSet寻找比array[0]大的连续元素(往后找), 找到的元素从array踢出, 为什么? 假设我们先把array排个序, 假设a[i]~a[j]是一个连续子序列, 但a[j]到a[j+1]不再连续, 那么下个连续子序列肯定从 a[j+1] 开始, 不再包括 a[i]~a[j]了</li></ul><p>➤ 解法3: 并查集 @todo</p><h2 id="数组-滑动窗口-1343-大小为-K-且平均值大于等于阈值的子数组数目"><a href="#数组-滑动窗口-1343-大小为-K-且平均值大于等于阈值的子数组数目" class="headerlink" title="数组 #滑动窗口 1343. 大小为 K 且平均值大于等于阈值的子数组数目"></a>数组 #滑动窗口 1343. 大小为 K 且平均值大于等于阈值的子数组数目</h2><blockquote><p><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/" target="_blank" rel="noopener">1343. 大小为 K 且平均值大于等于阈值的子数组数目</a><br>给一个整数数组 arr 和两个整数 k 和 threshold 。<br>请返回长度为 k 且平均值大于等于 threshold 的子数组数目。</p></blockquote><p>➤ 解法1: <a href="https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/solution/ci-ti-zui-you-jie-hua-dong-chuang-kou-jia-dong-tai/" target="_blank" rel="noopener">此题最优解，滑动窗口加动态规划。时间空间100%打败全用户。 - 大小为 K 且平均值大于等于阈值的子数组数目</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sum存储当前子序列的和, result存储符合条件的子数组数目</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span> ,result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标总和</span></span><br><span class="line">    <span class="keyword">int</span> sumTarget = k*threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出初始状态下, 窗口内的sum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果初始窗口的和, 已经大于sum了, 符合条件, result++</span></span><br><span class="line">    <span class="keyword">int</span> adder = sum - sumTarget;</span><br><span class="line">    <span class="keyword">if</span> (adder &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于是固定窗口大小, 只维护一个指针即可, 这里只对左指针++(这里是i)</span></span><br><span class="line">    <span class="keyword">int</span> pos = k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-k; i++) &#123;</span><br><span class="line">        adder = adder+arr[pos]-arr[i];</span><br><span class="line">        <span class="keyword">if</span> (adder&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 扩展: <a href="https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/solution/zi-shu-zu-ru-guo-gai-cheng-sui-ji-cong-shu-zu-chou/" target="_blank" rel="noopener">子数组如果改成“随机从数组抽k个数组成新数组” - 大小为 K 且平均值大于等于阈值的子数组数目</a></p><h2 id="数组-295-数据流的中位数"><a href="#数组-295-数据流的中位数" class="headerlink" title="数组 295. 数据流的中位数"></a>数组 295. 数据流的中位数</h2><blockquote><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></p></blockquote><p>➤ 解法1: <a href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--54/" target="_blank" rel="noopener">详细通俗的思路分析，多解法 - 数据流的中位数</a></p><p>➤ 解法2: <a href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/295shu-ju-liu-de-zhong-wei-shu-by-zhangyang-11/" target="_blank" rel="noopener">使用大小堆</a></p><ul><li>中位数需要考虑: 数字的总个数是多少, 如果是偶数个, 中位数是N/2, 如果奇数个, 则中位数在N/2 + 1处;</li><li>维护两个堆, 一个大顶堆, 一个小顶堆,</li><li>同时为了方便”数据流共有奇数个数字”的时候, 规定大顶堆永远比小顶堆的容量大1, 或者相等;</li></ul><h2 id="数组-1505-最多-K-次交换相邻数位后得到的最小整数-todo"><a href="#数组-1505-最多-K-次交换相邻数位后得到的最小整数-todo" class="headerlink" title="数组 1505. 最多 K 次交换相邻数位后得到的最小整数 @todo"></a>数组 1505. 最多 K 次交换相邻数位后得到的最小整数 @todo</h2><blockquote><p><a href="https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/" target="_blank" rel="noopener">1505. 最多 K 次交换相邻数位后得到的最小整数 - 力扣（LeetCode）</a><br>给你一个字符串 num 和一个整数 k 。其中，num 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 数位 。<br>你可以交换这个整数相邻数位的数字 最多 k 次。<br>请你返回你能得到的最小整数，并以字符串形式返回。</p></blockquote><h2 id="链表-206-反转链表"><a href="#链表-206-反转链表" class="headerlink" title="链表 206. 反转链表"></a>链表 206. 反转链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Node pre = head;</span><br><span class="line">  head = head.next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node tmp = head.next;</span><br><span class="line">    head.next = pre;</span><br><span class="line">    head = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表-160-相交链表"><a href="#链表-160-相交链表" class="headerlink" title="链表 160. 相交链表"></a>链表 160. 相交链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></p></blockquote><blockquote><p>编写一个程序，找到两个单链表相交的起始节点。如下面的两个链表：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list: 1, 2, 7 \</span><br><span class="line">                -- 18, 2, 9</span><br><span class="line">list: 4, 3, 9 /</span><br></pre></td></tr></table></figure><p>➤ 双指针法:</p><ul><li>第一链表指针a, 第二链表指针b, a/b依次++移动, a移动到末尾指向b开头, b移动到末尾指向a开头, 如果a和b相遇, 则是…</li><li>分析: 这种情况下a走的路径 和 b走的路径相等</li></ul><h2 id="树-144-145-二叉树遍历"><a href="#树-144-145-二叉树遍历" class="headerlink" title="树 144. 145. 二叉树遍历"></a>树 144. 145. 二叉树遍历</h2><blockquote><p>二叉树递归遍历, 非递归(先/中/后序遍历)</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;T&gt; n)</span> </span>&#123;</span><br><span class="line">    System.out.println(n.data);  <span class="comment">// 先序</span></span><br><span class="line">    <span class="keyword">if</span> (n.left != <span class="keyword">null</span>)</span><br><span class="line">        preOrder(n.left);</span><br><span class="line">    <span class="keyword">if</span> (n.right != <span class="keyword">null</span>)</span><br><span class="line">        preOrder(n.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 先序-非递归, 最简单的一种:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        Node n = s.pop();</span><br><span class="line">        System.out.println(n.data);</span><br><span class="line">        <span class="keyword">if</span>(n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(n.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(n.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤︎ 先序、中序(模拟递归)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(root.data); <span class="comment">// 先序</span></span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = s.pop();</span><br><span class="line">            <span class="comment">// System.out.println(root.data); // 中序</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤︎ 后序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack s1 = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack s2 = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    s1.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty) &#123;</span><br><span class="line">        Node curr = s1.pop();</span><br><span class="line">        s2.push(curr);</span><br><span class="line">        <span class="keyword">if</span>(curr.left !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(curr.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr.right !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s2.isEmpty()) &#123;</span><br><span class="line">        Node curr = s2.pop();</span><br><span class="line">        System.out.println(cur.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树-102-二叉树的层序遍历"><a href="#树-102-二叉树的层序遍历" class="headerlink" title="树 102. 二叉树的层序遍历"></a>树 102. 二叉树的层序遍历</h2><blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; currentLevel = <span class="keyword">new</span> Queue();</span><br><span class="line">    Queue&lt;Node&gt; nextLevel = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    currentLevel.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!currentLevel.isEmpty()) &#123;</span><br><span class="line">        currNode = currentLevel.poll();</span><br><span class="line">        <span class="keyword">if</span>(currNode) &#123;</span><br><span class="line">            print(currNode);</span><br><span class="line">            nextLevel.offer(currNode.left);</span><br><span class="line">            nextLevel.offer(currNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(currentLevel.isEmpty()) &#123;</span><br><span class="line">            print(<span class="string">"/n"</span>);</span><br><span class="line">            swap(currentLevel, nextLevel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树-226-翻转二叉树"><a href="#树-226-翻转二叉树" class="headerlink" title="树 226. 翻转二叉树"></a>树 226. 翻转二叉树</h2><blockquote><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p></blockquote><p>➤ 示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">   4</span><br><span class="line">  /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p>➤ 解法1: 递归后序遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invert</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    invert(root.left);</span><br><span class="line">    invert(root.right);</span><br><span class="line"></span><br><span class="line">    Node tmp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树-114-二叉树展开为链表"><a href="#树-114-二叉树展开为链表" class="headerlink" title="树 114. 二叉树展开为链表"></a>树 114. 二叉树展开为链表</h2><blockquote><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></p></blockquote><p>➤ 递归方式:</p><p>利用后序遍历, 处理节点root的右子树, 处理节点root的左子树, 然后处理root 的顺序( 当运行到root代码时, 意味着root的左右都已经处理好了, 或者root是叶子, 左右都是null );<br>每一个后序遍历到的节点都暂存在pre, 遍历下一个节点(实际是递归栈逐层退出), 直接把下个节点的right 指向pre即可;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归右, 左:</span></span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到这里, 说明root的右左都已经完成链化</span></span><br><span class="line">    root.right = pre;</span><br><span class="line">    <span class="comment">// 用担心左孩子丢失，因为是后序遍历，左孩子已经遍历过了</span></span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    pre = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 后序遍历方法2: 不用pre记录上次递归的节点,<br>而是在右左子树都遍历完成后, 先用temp记录左子树, 然后while 找到最右叶子节点, 把(已经链化的左子树挂在这个叶子的right)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将根节点的左子树变成链表</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    <span class="comment">//将根节点的右子树变成链表</span></span><br><span class="line">    flatten(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理本节点</span></span><br><span class="line">    TreeNode temp = root.right;</span><br><span class="line">    <span class="comment">//把树的右边换成左边的链表</span></span><br><span class="line">    root.right = root.left;</span><br><span class="line">    <span class="comment">//记得要将左边置空</span></span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//找到树的最右边的节点</span></span><br><span class="line">    <span class="keyword">while</span>(root.right != <span class="keyword">null</span>) root = root.right;</span><br><span class="line">    <span class="comment">//把右边的链表接到刚才树的最右边的节点</span></span><br><span class="line">    root.right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树-34-二叉树中和为某一值的路径"><a href="#树-34-二叉树中和为某一值的路径" class="headerlink" title="树 34. 二叉树中和为某一值的路径"></a>树 34. 二叉树中和为某一值的路径</h2><blockquote><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">34. 二叉树中和为某一值的路径</a></p></blockquote><blockquote><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p></blockquote><p>➤ 解题1: // 回溯方法</p><ul><li>前序遍历二叉树, 遍历到的节点放入vector(用来存储遍历的路径), 再声明一个Result存储所有符合的路径</li><li>判断vector的和, 与给定的整数是否相等; // 这里为了避免遍历Vector求和, 采用每次记录整数与root.val的差, 并传递</li><li>如果相等, 把vector复制一份, 并存入结果Result, 然后递归返回(不再处理当前节点的左和右子树), 返回的过程中从vector中pop出当前节点</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Vector&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">public</span> Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(Node root, <span class="keyword">int</span> want)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    vector.push(root);</span><br><span class="line">    <span class="keyword">if</span>(root.val == want &amp;&amp; root.l == <span class="keyword">null</span> &amp;&amp; root.r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> List(vector));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pathSum(root.l, want - root.v);</span><br><span class="line">    pathSum(root.r, want - root.v);</span><br><span class="line"></span><br><span class="line">    vector.pop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树-236-二叉树的最近公共祖先"><a href="#树-236-二叉树的最近公共祖先" class="headerlink" title="树 236. 二叉树的最近公共祖先"></a>树 236. 二叉树的最近公共祖先</h2><blockquote><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/c-jing-dian-di-gui-si-lu-fei-chang-hao-li-jie-shi-/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></p></blockquote><blockquote><p>给定一个二叉树, 找到该树中两个指定节点值的最近公共祖先。</p></blockquote><p>➤ 解法1: 后序遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">findLowestCommon</span><span class="params">(Node root, Node p, Node q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == q || root == p) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    Node l = findLowestCommon(root.left, p, q);</span><br><span class="line">    Node r = findLowestCommon(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到这里, 意味着左右子树都已经搜寻完了,</span></span><br><span class="line">    <span class="comment">// 有几种可能:</span></span><br><span class="line">    <span class="comment">// 1 左或右子树中, 只找到p/q中的一个, 另一个没找到(返null)</span></span><br><span class="line">    <span class="comment">// 2 左或右子树中, 找到了p和q</span></span><br><span class="line">    <span class="comment">// 3 左或右子树中, p/q都没找到</span></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="keyword">null</span>) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">if</span>(l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 01.Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>影响程序员发展的十类算法（zz）</title>
      <link href="/01.Algorithm/Alg.IntroductionToAlgorithm/"/>
      <url>/01.Algorithm/Alg.IntroductionToAlgorithm/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>基本思想</strong>（时空复杂度，规约，枚举，贪心，分治，递推与递归，构造，模拟）</li><li><strong>排序</strong>（冒泡，选择，插入，归并，堆，快速，桶，基数，希尔，Timsort）（Top K）</li><li><strong>经典数据结构</strong>（栈，队列，链表，哈希，单调队列，优先队列，平衡树，线段树，并查集）</li><li><strong>搜索</strong>（BFS，DFS，A*搜索)</li><li><strong>基础数学算法</strong>（二分查找算法，欧几里得算法，快速幂算法）</li><li><strong>图论基础算法</strong>（拓扑排序，最小生成树算法，最短路径算法）</li><li><strong>动态规划算法</strong>（最长上升子序列，最长公共子序列，最大连续子段和，背包问题）</li><li><strong>计算几何算法</strong>（线段交，凸包，平面最近点对）</li><li><strong>字符串匹配算法</strong>（KMP算法，Trie树）</li><li><strong>网络流算法</strong>（最大流算法，最小费用最大流算法）</li></ol><hr><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>问题：如果某个问题已经找到了一种解法，如何证明这个问题可解决的时间下界。<br>解法：用归约，从已知证未知。<br><img src="https://lh3.googleusercontent.com/8_ey6ghEP-ijKNZ4rqIYMpRF8h586T0Ar6BAWliK4TrzD-CpbO1VfgI_2xCxMIVj_C0oEfaS2k3Z=s0" alt="enter image description here" title="Linear-time Reduction"><br>A问题可以线性归约到B问题的转化是单向的，是<strong>从已知问题到未知问题</strong>，从难度更低的问题转化为难度更高的问题。如：一元一次方程可以归约到一元二次方程。<br>题目：使用排序算法对求凸包下界进行评估：<br><img src="https://lh3.googleusercontent.com/v0GunSGbRGIZDR9-FFxsEmhcivH6LD8RsF61TA1szPDGypY27x-1XMY9YT-6G9vOvA-_LqQitZqL=s0" alt="Sorting reduct to 2dCH" title="Sorting reduct to 2dCH.png"></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p><img src="/images/alg/IntroductionToAlgorithm/divide-and-conquer.png" alt="Divide_and_Conquer"></p><h3 id="递推与递归"><a href="#递推与递归" class="headerlink" title="递推与递归"></a>递推与递归</h3><p>题目：求第$n$个斐波那契数<br>$$ f(n)=f(n-1)+f(n-2), f(1)=1, f(2)=1 $$</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>题目：各阶幻方的构造算法</p><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>题目：给定麻将规则，问至少还需几轮能够胡牌</p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>归并排序</li><li>堆排序</li><li>快速排序</li><li>桶排序：将数组分到有限数量的桶里，每个桶再个别排序。题目：小学生成绩排名</li><li>基数排序：将整数按位数切割成不同的数字，然后按每个位数分别比较。可以看做是从低位到高位进行的桶排序。</li><li>希尔排序：也称递减增量排序算法，是插入排序的一种更高效的改进版本。</li><li>Timsort：一种混合的稳定的排序算法，派生自归并排序和插入排序。<ul><li>Pyhton自从2.3版以来一直采用Timsort算法排序，Java SE7，Android，GNU Octave也采用Timsort算法对数组排序。</li></ul></li></ul><p><img src="/images/alg/IntroductionToAlgorithm/sorting-algorithm-timsort.png" alt="Sorting_algorithm_Timsort"></p><p>题目：从$n$个数中找到前$k$大的数</p><hr><h2 id="经典数据结构"><a href="#经典数据结构" class="headerlink" title="经典数据结构"></a>经典数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>题目：存在一个系数和变量都是整数的等式:<br>$$ a_1 x_1^3 + a_2 x_2^3 + a_3 x_3^3 + a_4 x_4^3 + a_5 x_5^3 = 0  $$<br>$\forall i∈{1,2,3,4,5}, x_i∈[-50,50], a_i∈[-50,50]$，问有多少组解。<br>解法：将变量分成两部分，先hash一部分的结果，另一部分计算出结果再去查找。</p><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>题目：长度为$n$的数组上有个长度为$k$的滑窗从左向右移动，求每次移动后滑窗区间的最小值和最大值。输出两行，第一行所有最小值，第二行所有最大值。</p><p><img src="/images/alg/IntroductionToAlgorithm/monotone-queue-notes.png" alt="monotone-queue-notes"></p><p>解法：可以用线段树来做，复杂度O(nlogn)，但是使用单调队列更简单，复杂度是O(n)。</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>堆的核心操作函数，维护堆:</p><p><img src="/images/alg/IntroductionToAlgorithm/priority-queue.png" alt="Priority_Queue"></p><p>BUILD: O(n), for (i=n/2; i&gt;0; i–) max_heap(i);<br>UPDATE: O(logn)<br>INSERT: 先插入到堆的最后一个元素，然后不断和其父亲(/2)比较大小，一个for循环维护堆<br>DELETE: O(logn) 删除堆顶元素，把最后一个元素拿到堆顶，然后维护堆</p><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><h4 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h4><p>一种典型适度平衡的二叉搜索树。<br>需要为其中的每一个节点引入一个名为平衡因子的指标，节点的平衡因子是它的左子树的高度减去它的右子树的高度。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。</p><blockquote><p><strong>高度为$h$的AVL树，至少包含$S(h)=fib(h+3)-1$个节点</strong></p></blockquote><p>INSERT: O(1)<br>DELETE: O(logn)<br>优点: 无论查找、插入或删除，最坏情况下的复杂度均为O(logn)时间复杂度,O(n)的存储空间。<br>缺点:</p><ul><li>借助高度或平衡因子，为此需改造元素结构，或额外封装；</li><li>实测复杂度与理论值尚有差距；</li><li>单次动态调整后，全数拓扑结构的变化量可能高达O(logn) 。</li></ul><h4 id="RB-Tree（红黑树，即是B-树-2-4-）"><a href="#RB-Tree（红黑树，即是B-树-2-4-）" class="headerlink" title="RB-Tree（红黑树，即是B-树(2,4)）"></a>RB-Tree（红黑树，即是B-树(2,4)）</h4><p>引入“颜色”的目的在于使得红黑树的平衡条件得以简化，与B树对应。<br>INSERT: O(logn)<br>DELETE: O(logn)<br>优点:</p><ul><li>任何一次动态操作引发的结构变化量不超过O(1)，特别适合用来实现持久化的搜索树，作为可持久化数据结构比较好；</li><li>红黑树每个节点只需要1-bit附加空间。</li></ul><p>缺点:</p><ul><li>太复杂，插入有5种情况，删除有6种情况，代码量大，编写容易出错。</li><li>红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。</li></ul><h4 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h4><p>节点$V$一旦被访问，随即转移至树根，“一步一步往上爬”。<br>效率取决于：树的初始形态以及节点访问次序。可以做到单趟伸展操作，分摊O(logn)时间！<br>INSERT:O(logn)<br>DELETE:O(logn)<br>优点:</p><ul><li>无需记录节点高度或平衡因子；</li><li>编程实现简单易行–优于AVL树，分摊复杂度O(logn)。</li><li>局部性强、缓存命中率极高时，效率更好。</li></ul><p>缺点: 仍不能杜绝单次最坏情况的出现，不适用于对效率敏感的场合。</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>也叫区间树，是一棵二叉树，适用于和区间统计有关的问题。</p><p><img src="/images/alg/IntroductionToAlgorithm/segment-tree.png" alt="Segment_Tree"></p><p>经典的问题模型：</p><ul><li>单点修改，区间查询</li><li>区间修改，单点查询</li><li>区间修改，区间查询</li></ul><p>题目：给定原始数组$a[]={2,5,3,4,1}, a[i] &lt;= n$，求$b[i]$=位置$i$左边小于等于$a[i]$的数的个数。如样例中$b[]={0,1,1,2,0}$。</p><p>解法：初始化线段树$1..n$位置上的数都为$0$，然后从左到右遍历数组，对于每个位置的数$a[i]$，$b[i]=sum(1, a[i]-1)$，然后在$a[i]$值所在的位置增加1。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。<br>经典应用：Kruskal算法求最小生成树中判断新加入的边是否在同一棵树内部。</p><p><img src="/images/alg/IntroductionToAlgorithm/union-find-set.png" alt="union_find_set"></p><hr><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h3 id="A-搜索"><a href="#A-搜索" class="headerlink" title="A*搜索"></a>A*搜索</h3><p>In the standard terminology used when talking about A<em>, $g(n)$ represents the exact cost of the path from the starting point to any vertex $n$, and $h(n)$ represents the heuristic estimated cost from vertex $n$ to the goal.<br>A</em> balances the two as it moves from the starting point to the goal. Each time through the main loop, it examines the vertex $n$ that has the lowest $f(n) = g(n) + h(n)$.<br><img src="http://ourjs.github.io/static/images/path.png" alt="enter image description here"><br>A*算法和DFS、BFS有着较深关系，其中的$g(n)$和$h(n)$作为两个不同的代价:</p><ol><li>在DFS的搜索中，其关注的主要是邻居节点与当前节点的距离开销，此时可将$g(n)$认为是0；</li><li>在BFS中进行分层搜索时，以层次距离为主，此时可将$h(n)$认为是0。而且，当$h(n)$认为是0，则转换为单源最短路径计算。</li></ol><p>题目：八数码问题</p><hr><h2 id="基础数学算法"><a href="#基础数学算法" class="headerlink" title="基础数学算法"></a>基础数学算法</h2><h3 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h3><p>问题：在一个给定的升序数组array中，找到第一个大于或者等于x的数的位置，没有则返回-1。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int search(int[] array, int low, int high, int x) &#123;</span><br><span class="line">  int ans = -1;</span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line">    int mid = low + (high - low) / 2;</span><br><span class="line">    if (judge(mid)) &#123;</span><br><span class="line">      ans = mid;</span><br><span class="line">      high = mid - 1;</span><br><span class="line">    &#125; else low = mid + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题变形：</p><ul><li>求第一个大于x的数的位置</li><li>求最后一个小于x的数的位置</li><li>求最后一个小于或者等于x的数的位置</li><li>如果当前数组不是升序而是降序的话</li></ul><p>题目：给定$n$个木棍，每个木棍有一个长度（精确到两位小数），需要把他们截成$k$个长度相同的小木棍，求小木棍的最大长度。</p><p>解答：把最大长度的小木棍的值作为二分变量，进行浮点数的二分。</p><p>题目：一条长为L（1~1,000,000,000）的河中，有$n$(1~50,000)块可垫脚的石头，<br>给出它们与起始点的距离$rock[i]$，移除其中的$m$块使得具有最小间距的相邻两块石头之间的距离最大。</p><p>解答：二分最终的结果，用上述整数二分的写法进行处理，每一次判断使用贪心策略，记录每次符合条件的策略，二分最后得到的就是最终的答案。</p><blockquote><p>二分经典应用：求上（下）界的最小（大）值</p></blockquote><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>求两个整数的最大公约数－－辗转相除法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">if (a == 0) return b;</span><br><span class="line">return gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h3><p>问题：$a, b$都是整数，如何快速求$a^b$</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fpow(int a, int b)&#123;</span><br><span class="line">    int result = 1;</span><br><span class="line">    for (; b; b &gt;&gt;= 1) &#123;</span><br><span class="line">    if (b &amp; 1) result = result * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">｝</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目：快速求第$n$个斐波那契数。</p><p>解法：<br>经典的矩阵快速幂，下面这个式子是成立的：<img src="https://pic1.zhimg.com/50/d900e0509f9d056286ff9455e7706f90_hd.jpg" alt="enter image description here"><br>不停地利用这个式子迭代右边的列向量，会得到下面的式子：<img src="https://pic3.zhimg.com/50/c564ec78cf8008541bc1bbcfd4a70dea_hd.jpg" alt="enter image description here"><br>这样，问题就转化为如何计算这个矩阵的$n$ 次方了。</p><hr><h2 id="图论基础算法"><a href="#图论基础算法" class="headerlink" title="图论基础算法"></a>图论基础算法</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。</p><p><img src="/images/alg/IntroductionToAlgorithm/dag.png" alt="DAG"></p><h3 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><table><thead><tr><th>最小边、权的数据结构</th><th>时间复杂度（总计）</th></tr></thead><tbody><tr><td>邻接矩阵、搜索</td><td>$O(V^2)$</td></tr><tr><td>二叉堆（后文伪代码中使用的数据结构）、邻接表</td><td>$O((V + E) log(V)) = O(E log(V))$</td></tr><tr><td>斐波那契堆、邻接表</td><td>$O(E + V log(V))$</td></tr></tbody></table><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>kruskal算法的基本思想（使用到了并查集）：</p><ol><li>首先将$G$的$n$个顶点看成$n$个孤立的连通分支（$n$个孤立点）并将所有的边按权从小大排序。</li><li>按照边权值递增顺序，如果加入边后存在圈则这条边不加，直到形成连通图</li></ol><p>时间复杂度：$\mathrm {O} (Elog_{2}E) E$为图中的边数</p><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>对于不含负权的有向图，这是目前已知的最快的单源最短路径算法。<br>不采用最小优先级队列，时间复杂度是 ${\displaystyle O(|V|^{2})} )$(其中 $\displaystyle |V|$为图的顶点个数)。<br>用邻接表+二叉堆或者斐波纳契堆用作优先队列来查找最小的顶点时，时间复杂度是$O(|E|+|V|\log |V|) $(其中$\displaystyle |E|$是边数)</p><h4 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h4><p>任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包。<br>Floyd-Warshall算法的时间复杂度为 $\displaystyle O(N^{3})$，空间复杂度为 $\displaystyle O(N^{2})$。</p><p><img src="/images/alg/IntroductionToAlgorithm/floyd-warshall.png" alt="Floyd_Warshall"></p><p><strong>核心思想是动态规划算法</strong>，其中$dist[i][j]$表示由点 $\displaystyle i$到点 $\displaystyle j$的代价，∞ 表示两点之间没有任何连接。</p><hr><h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><h3 id="数字三角形-IOI-1994"><a href="#数字三角形-IOI-1994" class="headerlink" title="数字三角形[IOI 1994]"></a>数字三角形[IOI 1994]</h3><p>题目：有一个数字三角形，从最顶层出发，每一步只能向左下或右下方向走。编程求从最顶层到最底层的一条路所经过位置上的数字之和的最大值。</p><p><img src="/images/alg/IntroductionToAlgorithm/dp1.png" alt="DP1"></p><p><strong>动态规划核心思想：</strong></p><ul><li><strong>最优子结构</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。</li><li><strong>重叠子问题</strong>：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存起来，当再次需要计算已经计算过的子问题时，从保存的记录中查看一下结果，从而获得较高的效率。</li></ul><p><img src="/images/alg/IntroductionToAlgorithm/dp2.png" alt="DP2"></p><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h3 id="最大连续子段和"><a href="#最大连续子段和" class="headerlink" title="最大连续子段和"></a>最大连续子段和</h3><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul><li>01背包</li><li>完全背包</li><li>多重背包</li><li>混合三种背包</li><li>二维费用背包</li><li>分组背包</li></ul><hr><h2 id="计算几何算法"><a href="#计算几何算法" class="headerlink" title="计算几何算法"></a>计算几何算法</h2><h3 id="向量性质"><a href="#向量性质" class="headerlink" title="向量性质"></a>向量性质</h3><h4 id="向量点积"><a href="#向量点积" class="headerlink" title="向量点积"></a>向量点积</h4><p>向量的点积结果跟两个向量之间的角度有关<br><img src="http://img.my.csdn.net/uploads/201211/05/1352080679_6613.jpg" alt="enter image description here"><br><img src="http://img.my.csdn.net/uploads/201211/05/1352080779_4529.jpg" alt="enter image description here"></p><h4 id="向量叉积"><a href="#向量叉积" class="headerlink" title="向量叉积"></a>向量叉积</h4><p>向量积可以被定义为：$a \times b = absin\theta$（在这里$θ$表示两向量之间的夹角(共起点的前提下)（$0° ≤ θ ≤ 180°$）</p><p><img src="/images/alg/IntroductionToAlgorithm/cross-product.png" alt="Cross_Product"></p><p><img src="/images/alg/IntroductionToAlgorithm/向量积（叉积、外积）的坐标表达式.png" alt="向量积（叉积、外积）的坐标表达式"></p><blockquote><p>$c$的长度在数值上等于以$a$，$b$，夹角为$θ$组成的平行四边形的面积。</p></blockquote><h4 id="To-Left-Test"><a href="#To-Left-Test" class="headerlink" title="To-Left Test"></a>To-Left Test</h4><p>问题：给定三个二维平面的点，$p,q,r$，问$\overrightarrow{pr}$向量是否在$\overrightarrow{pq}$向量的左侧</p><p>解答：使用叉乘，结果大于0时在左侧，等于0时共线，小于0时在右侧。</p><p>问题：如何判断一个点是否在一个三角形内部</p><p>解答：$InTriangle(p,q,r,k)$当且仅当<br>$$ToLeft(p,q,k) == ToLeft(q,r,k) == ToLeft(r,p,k)$$<br>问题：如何判断一个点是否在一个凸多边形内部</p><p>解答：看所有的ToLeft值是否都大于0<br>问题：求给定多边形的面积</p><p>解答：把多边形分成若干个三角形，按照逆时针依次求每个三角形的有向面积。对用 $\displaystyle (x_{1},y_{1}),(x_{2},y_{2}),\dots ,(x_{n},y_{n})$（按逆时针排列）描述的多边形，其面积为：<br>$$\displaystyle A={\frac {1}{2}}\left({\begin{vmatrix}x_{1}&amp;y_{1}\x_{2}&amp;y_{2}\end{vmatrix}}+{\begin{vmatrix}x_{2}&amp;y_{2}\x_{3}&amp;y_{3}\end{vmatrix}}+\dots +{\begin{vmatrix}x_{n}&amp;y_{n}\x_{1}&amp;y_{1}\end{vmatrix}}\right)$$</p><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>点集Q的凸包（convex hull）是指一个最小凸多面体，满足Q中的点或者在多面体边上或者在其内。</p><p><img src="/images/alg/IntroductionToAlgorithm/convex-hull.png" alt="Convex_Hull"></p><p>经典算法：</p><ul><li>增量式算法：逐次将点加入，然后检查之前的点是否在新的凸包上，时间复杂度为 $\displaystyle O(n^{2})$。</li><li>包裹法（Jarvis步进法）。时间复杂度为 $\displaystyle O(kn)$，$k$表示输出的面的数量，$n$表示点集的个数，复杂度与输出凸包的面相关。</li><li><strong>葛立恒（Graham）扫描法</strong>，算法的整体时间复杂度是 $\displaystyle O(n\log {n})$，缺点是只能处理二维情况。<img src="http://dl2.iteye.com/upload/attachment/0078/0473/e4911d9e-ad3d-306c-8d58-8ae34c9ceb7c.jpg" alt="enter image description here"></li><li>分治法：将点集$X$分成两个不相交子集。求得两者的凸包后，计算这两个凸包的凸包，该凸包就是$X$的凸包。时间复杂度是$\displaystyle O(n\log {n})$。<blockquote><p>解决三维凸包问题，主要有包裹法、分治法、随机增量算法、快速凸包算法。</p></blockquote></li></ul><h3 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a>平面最近点对</h3><p>给定平面上$n$个点，找其中的一对点，使得在$n$个点的所有点对中，该点对的距离最小。<br>经典算法：</p><ul><li>分治法，时间复杂度O(nlogn)</li><li>随机增量法，时间复杂度O(n)，且向高维扩展容易</li></ul><hr><h2 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>问题：在一个主文本字符串S内查找一个词W的出现位置。<br>思想：通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。<br><img src="https://lh3.googleusercontent.com/--RRz9U4CNjg/Wg5ObvdXO1I/AAAAAAAAHZc/rhufTVQwzGkhiCRbrvad6xwyHF5sKzktACLcBGAs/s0/kmpexample.jpg" alt="enter image description here" title="kmpexample.jpg"><br>next[j]取决于模式串中T[0 ~ j-1]中前缀和后缀相等部分的长度，并且next[j]恰好等于这个最大长度；此外在j位匹配出错，刚好是从next[j]位开始重新匹配；next[j]在j-1处产生。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getnxt(char *t,int *f)&#123; //字符串长度至少为1，求nxt数组</span><br><span class="line">int i,j,len=strlen(t);</span><br><span class="line">f[0]=f[1]=0;</span><br><span class="line">for (i=1; i&lt;len; i++)&#123;</span><br><span class="line">j=f[i];</span><br><span class="line">while (j &amp;&amp; t[i]!=t[j]) j=f[j];</span><br><span class="line">f[i+1]= t[i]==t[j] ? j+1 : 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int kmp(char *s,char *t,int *f)&#123; //这里肯定是O(n+m)的</span><br><span class="line">int i,j,tem,n=strlen(s),m=strlen(t);</span><br><span class="line">getnxt(t,f);</span><br><span class="line">for (i=j=0; i&lt;n; i++)&#123;</span><br><span class="line">while (j &amp;&amp; s[i]!=t[j]) j=f[j];</span><br><span class="line">if (s[i]==t[j]) j++;</span><br><span class="line">if (j==m) return i-m+1;</span><br><span class="line">//if (j==m) num++,j=f[j]; //若统计有多少个</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度分析：在kmp函数中，每一次while 循环$j$的值都会减小（至少为1），然而每一次j++都伴随一次i++，所以总的复杂度是O(n)。在getnxt函数中过程类似。</p></blockquote><p>题目：找出第一个字符串在第二个字符串中出现次数。</p><p>题目：求既是前缀串儿又是后缀串儿的不同子串的长度，长度从小到大输出。</p><p>解答：next数组的性质是，该字符之前的字符串的最大相同前缀后缀。既然知道了最大的，即next[len]，递归一次next[ next[len] ]，就能求得更小的前缀。不断的递归把所有所有可能的长度找出来，然后递归输出即可。</p><p>题目：给出一个字符串，求出这个字符串最多能够由多少个子串首尾连接而成。比如“ababab”就是由3个“ab”相连而成，所以输出3，“abcdef”只能看作一个“abcdef”所以输出1。</p><p>解答：KMP中next数组的巧妙运用。在这里我们假设这个字符串的长度是len，那么如果len可以被len-next[len]整除的话，我们就可以说len-next[len]就是那个最短子串的长度。</p><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>问题：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。<br>又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。<br><img src="https://i.stack.imgur.com/EyFvY.png" alt="enter image description here"><br>题目：设计一个算法可以自动列出以输入字符串为前缀的单词中最频繁查找的前10个单词。</p><blockquote><p>注：类似google搜索框中输入要查找的单词，输入前缀google会自动列出同一前缀的所有查找单词中top 10的</p></blockquote><p>解答：</p><ol><li>节点上记录每个单词被查找的次数</li><li>对于给定的输入词，找到其在Trie中的位置，设为节点K</li><li>搜索以节点K为根的子树，用一个最小堆记录top10</li></ol><h3 id="Trie树＋KMP"><a href="#Trie树＋KMP" class="headerlink" title="Trie树＋KMP"></a>Trie树＋KMP</h3><p>问题：在输入的一串字符串中匹配有限组“字典”中的子串。<br>AC自动机算法算是比较简单直观的字符串匹配自动机，它其实就是在一颗Trie树上建一些失配指针，当失配时只要顺着失配指针走，就能避免一些重复的计算。算法均摊情况下具有近似于线性的时间复杂度。</p><p><img src="/images/alg/IntroductionToAlgorithm/trie-tree.png" alt="Trie_Tree"></p><p>应用：多模式串匹配问题。当一个字典串集合是已知的(例如一个计算机病毒库), 就可以以离线方式先将自动机求出并储存以供日后使用。</p><ul><li>UNIX系统中的一个命令fgrep就是以AC自动机算法作为基础实现的。</li><li>nginx模块用于判断User-Agent（用户的浏览器信息）的核心算法就是AC自动机</li></ul><hr><h2 id="网络流算法"><a href="#网络流算法" class="headerlink" title="网络流算法"></a>网络流算法</h2><h3 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h3><p>在优化理论中,最大流问题涉及到在一个单源点、单汇点的网络流中找到一条最大的流。</p><p><img src="/images/alg/IntroductionToAlgorithm/maximum-flow-problem.png" alt="Maximum_flow_problem"></p><h4 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h4><p>核心是将一条边的单向残留容量的减少看做反向残留流量的增加，然后每次寻找增广路径（就是新的流量），直到无法找到增广路径为止。</p><p><img src="/images/alg/IntroductionToAlgorithm/残留网络.png" alt="残留网络"></p><ul><li>Edmonds–Karp算法：使用广度优先搜索寻找增广路径。</li><li>Dinic算法</li><li>SAP算法</li></ul><p>题目：有N个牛，F个食物，D个饮料，每个牛喜欢一些食物和饮料，现在要给牛分发食物和饮料，当一个牛得到一个喜欢的食物和一个喜欢的饮料的时候，就说这个牛被满足了。求最多可以满足多少个牛。每个饮料和食物只能被分给一个牛，每个牛也只能拿到一个饮料和食物。</p><p><img src="http://i.imgur.com/hkRDu4q.png" alt="enter image description here"><br>解法：一头牛贡献一单位的流量，所以把牛拆了，中间加一个1容量的边，然后起点到所有饮料连1容量边，饮料到喜欢自己的牛连1容量边，牛到他喜欢的食物连1容量的边，所有食物向终点连1容量的边。</p><p>题意：有N个农场，P条无向路连接。要从1到N不重复走一条路地走T次，求所经过的直接连接两个区域的道路中最长道路的最小值。</p><p>解法：源点向1连容量T的边。二分最小长度，长度超过mid的边容量为0，否则为1，用最大流判可行性。</p><h3 id="最小费用最大流算法"><a href="#最小费用最大流算法" class="headerlink" title="最小费用最大流算法"></a>最小费用最大流算法</h3><p>最小费用最大流问题是经济学和管理学中的一类典型问题。<br>在一个网络中每段路径都有“容量”和“费用”两个限制的条件下，此类问题的研究试图寻找出：流量从A到B，如何选择路径、分配经过路径的流量，可以达到所用的费用最小的要求。<br>在实际中：$n$辆卡车要运送物品，从A地到B地。由于每条路段都有不同的路费要缴纳，每条路能容纳的车的数量有限制，如何分配卡车的出发路径可以达到费用最低，物品又能全部送到。</p><blockquote><p>最小费用最大流与一般增广路的区别在于，每次寻找的增广路都是代价最小的路径。以代价为边的权重，求单源最短路径。</p></blockquote><p><img src="/images/alg/IntroductionToAlgorithm/minimumcostmaximums-tflow.png" alt="MinimumCostMaximums-tFlow"></p><p>题目：给出一个无向图，求从1到N走两次的最短路，每条路不能重复走。</p><p>解法：S向1连容量2，费用0的边，N向T连容量2，费用0的边，节点间连容量1，费用为边权的边。一次费用流。</p><p>题目：给出一个n*n的矩阵,每一格有一个非负整数Aij,(Aij &lt;= 1000)现在从(1,1)出发,可以往右或者往下走,最后到达(n,n),每达到一格,把该格子的数取出来,该格子的数就变成0,这样一共走K次,现在要求K次所达到的方格的数的和最大</p><p>解法：$k$为１或者２时可以动态规划<br><img src="http://img.voidcn.com/vcimg/000/006/386/599_c3b_0d5.png" alt="enter image description here"></p><p>$k$为２时：</p><ul><li>四维dp，$dp[x_1][y_1][x_2][y_2]$表示从起点（1，1）开始到点$（x_1，y_1）（x_2，y_2）$的最优路线</li><li>三维dp，因为$x_1+y_1=x_2+y_2=k$(当前走的步数)，所以$dp[k][x_1][x_2]$表示走了$k$步第一个人停留在$x_1$位置，第二个人停留在$x_2$的位置（对应的$y$值可以算出来）。</li></ul><p>解法：用最小费用最大流来解<br>对于每一个格子，我们拆成两个点（因为要限制流量）；每一个格子可以取一次，但是每一个格子是可以走多次的，那么我们在两个点中建两种边：</p><ol><li>费用为权值，流量为１</li><li><p>费用为0，流量为$\infty$（或$k-1$, $k$都行）</p><p><img src="https://lh3.googleusercontent.com/-ZjQ1MZnRLKo/Wg50x9HRElI/AAAAAAAAHZw/Nm2BrtXMRnEBplAv_ymfoNc_aSQoAzBywCLcBGAs/s0/67607011hafbade7b1dd9%2526690.jpeg" alt="enter image description here" title="67607011hafbade7b1dd9&amp;690.jpeg"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 01.Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 欧几里得算法 </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/01.Algorithm/Alg.03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/01.Algorithm/Alg.03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul><li>交换排序: 冒泡, 快排</li><li>插入排序: 简单插入排序, 希尔排序</li><li>选择排序: 简单选择排序, 堆排序</li><li>归并排序: 归并排序</li><li>基数排序:</li></ul><p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，泡排序、插入排序、归并排序和基数排序是稳定的排序算法。</p><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><p><img src="/images/alg/Bubble_sort_animation.gif" alt="使用冒泡排序为一列数字进行排序的过程"></p><p>最原始的交换类排序方式。遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就交换位置。时间复杂度平均情况<code>O(n^2)</code>，最坏也是<code>O(n^2)</code>，最好时间复杂度是<code>O(n)</code>，解释一下最好时间复杂度：改进的冒泡算法增加一个标志位（是否发生了swap）,如果这次循环完毕检查标志仍是false，说明这次已经是排好序的，直接return。<br>当数组是已经排好序的，这种冒泡的时间复杂度是<code>O(n)</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i∈[0,N-1)       //循环N-1遍</span><br><span class="line">  j∈[0,N-1-i)   //每遍循环要处理的无序部分</span><br><span class="line">    swap(j,j+1) //两两排序（升序/降序）</span><br></pre></td></tr></table></figure><p><img src="/images/alg/Bubble-sort-example-300px.gif" alt="冒泡示意图"></p><ul><li>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了，结束。</li><li>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</li></ul><h2 id="快排-Quick-Sort"><a href="#快排-Quick-Sort" class="headerlink" title="快排(Quick Sort)"></a>快排(Quick Sort)</h2><p><img src="/images/alg/Sorting_quicksort_anim.gif" alt="快速排序"></p><p>快速排序（QuickSort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要 <code>(nlog n)</code>次比较。在最坏状况下则需要 <code>n^2</code>次比较。</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li><li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li></ol><p>举例：对5，3，8，6，4这个无序序列进行快速排序(小→大)，右指针找比基准数小的，左指针找比基准数大的，然后交换位置。</p><ul><li>用数组第一个元素最为基准值(pivotKey)</li><li>5，3，8，6，4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</li><li>5，3，8，6，4 首先设置i，j两个指针分别指向左右两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i，j位置。</li><li>5，3，4，6，8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</li><li>4，3，5，6，8 一次划分后达到了左边比5小，右边比5大的目的。</li><li>以5 为分界点, 左序列 4, 3 和 右序列 6, 8 递归的进行排序</li></ul><p><del>上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</del></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序, 从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> pivotPos = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, pivotPos-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotPos+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotKey = arr[left];</span><br><span class="line">    <span class="keyword">int</span> pivotPointer = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)</span><br><span class="line">            right --;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)</span><br><span class="line">            left ++;</span><br><span class="line">        swap(arr, left, right); <span class="comment">//把大的交换到右边，把小的交换到左边。</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivotPointer, left); <span class="comment">//最后把pivot交换到中间</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度平均<code>O(n log n)</code>，最坏<code>O(n^2)</code>。因为快排的实现是递归调用的， 而且每次函数调用中只使用了常数的空间，因此空间复杂度等于递归深度<code>O(log n)</code>。<br>分析过程参考<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">快速排序 </a> “正规分析”。</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h2><p><img src="/images/alg/insertion-sort.png" alt="insertion_sort"></p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123; <span class="comment">//假设第一个数位置时正确的；要往后移，必须要假设第一个。</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> target = arr[i]; <span class="comment">//待插入的</span></span><br><span class="line">        <span class="comment">//后移</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; target &lt; arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        arr[j] = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度最坏和平均坏都是<code>O(n^2)</code>, 如果基本是已经排序的数列, 最好是<code>O(n)</code></p><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。与插入排序一样，最好的复杂度可以达到<code>O(n)</code>。<br>原始的插入算法实现在最坏的情况下需要进行<code>O(n^2)</code>的比较和交换。<br>步长的选择直接决定了希尔排序的复杂度，如果用<code>n/2^i</code>作为步长，希尔排序可以使得最坏情况提升至<code>O(n*log2n)</code>。这比最好的比较算法的<code>O(n*logn)</code>要差一些。希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到<code>O(n^1.3)</code>。</p><p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>然后我们对每列进行排序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>排序之后变为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure><p>最后以1步长进行排序（此时就是简单的插入排序了）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i - d;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];    <span class="comment">//记录要插入的数据</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp) &#123;  <span class="comment">//从后向前，找到比其小的数的位置</span></span><br><span class="line">            arr[j+d] = arr[j];    <span class="comment">//向后挪动</span></span><br><span class="line">            j -= d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j != i - d)    <span class="comment">//存在比其小的数</span></span><br><span class="line">            arr[j+d] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> d = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        shellInsert(arr, d);</span><br><span class="line">        d /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面源码的步长的选择是从<code>n/2</code>开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在<a href="[希尔排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">维基百科</a>)上有对于步长串行的详细介绍。</p><p>从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。<br>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到<code>O(n^1.3)</code>。</p><p><img src="/images/alg/Sorting_shellsort_anim.gif" alt="希尔排序"></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h2><p>选择排序的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。<br>如果移动元素的代价非常大，使用选择排序可以保证最少次数的数据移动。<br>选择排序的时间复杂度为<code>O(n^2)</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length<span class="number">-1</span>; i++) &#123; <span class="comment">//只需要比较n-1次</span></span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++) &#123; <span class="comment">//从i+1开始比较，因为minIndex默认为i了，i就没必要比了。</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minIndex != i) &#123; <span class="comment">//如果minIndex不为i，说明找到了更小的值，交换之。</span></span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h2><p>堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。<br>首先，实现堆排序需要解决两个问题：</p><ol><li>如何由一个无序序列键成一个堆？</li><li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</li></ol><p>第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。<br>第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。</p><p>从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举例：<br>49,38,65,97,76,13,27,49 序列的堆排序建初始堆和调整的过程如下：</p><p>输出堆顶元素并调整建新堆的过程：<br><img src="/images/alg/Sorting_heapsort_1.png" alt="输出堆顶"></p><p>建初始堆过程：<br><img src="/images/alg/Sorting_heapsort_2.png" alt="建初始堆"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆筛选，除了start之外，start~end均满足大顶堆的定义。</span></span><br><span class="line"><span class="comment">     * 调整之后start~end称为一个大顶堆。</span></span><br><span class="line"><span class="comment">     * @param arr 待调整数组</span></span><br><span class="line"><span class="comment">     * @param start 起始指针</span></span><br><span class="line"><span class="comment">     * @param end 结束指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*start+<span class="number">1</span>; i&lt;=end; i*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//左右孩子的节点分别为2*i+1,2*i+2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择出左右孩子较小的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; end &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= arr[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//已经为大顶堆，=保持稳定性。</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[start] = arr[i]; <span class="comment">//将子节点上移</span></span><br><span class="line">            start = i; <span class="comment">//下一轮筛选</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[start] = temp; <span class="comment">//插入正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            heapAdjust(arr, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h1><p><img src="/images/alg/Merge_sort_animation.gif" alt="一个归并排序的例子：对一个随机点的链表进行排序"></p><p>如何合并两个有序数组？</p><ul><li>首先申请一个空间, 大小等于两个数组大小的和；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针移动到下一个元素；</li><li>重复步骤直到某一指针达到序列尾；</li></ul><p>归并排序就是用递归的方式，把待排序数组递归分解为left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p><p><img src="/images/alg/Merge-sort-example-300px.gif" alt="归并示意图"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    mSort(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归分治</span></span><br><span class="line"><span class="comment"> * @param arr 待排数组</span></span><br><span class="line"><span class="comment"> * @param left 左指针</span></span><br><span class="line"><span class="comment"> * @param right 右指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    mSort(arr, left, mid); <span class="comment">//递归排序左边</span></span><br><span class="line">    mSort(arr, mid+<span class="number">1</span>, right); <span class="comment">//递归排序右边</span></span><br><span class="line">    merge(arr, left, mid, right); <span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序数组</span></span><br><span class="line"><span class="comment"> * @param arr 待合并数组</span></span><br><span class="line"><span class="comment"> * @param left 左指针</span></span><br><span class="line"><span class="comment"> * @param mid 中间指针</span></span><br><span class="line"><span class="comment"> * @param right 右指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//[left, mid] [mid+1, right]</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">//中间数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;temp.length; p++) &#123;</span><br><span class="line">        arr[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均时间复杂度<code>O(nlogn)</code>，最好时间复杂度<code>O(n)</code>，同一时刻需要一个大小为n的额外空间, 空间复杂度<code>O(n)</code></p><p><a href="http://blog.csdn.net/u013074465/article/details/42043967" target="_blank" rel="noopener">归并排序及其空间复杂度的思考 - CSDN博客</a></p><h1 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h1><p>用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。复杂度<code>O(n)</code></p><h1 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序(Bucket Sort)"></a>桶排序(Bucket Sort)</h1><p>先了解”桶”(Bucket)的概念, 有一个数组, 数组的每个元素都是一个线性链表, 那么这个数组被称为桶数组，数组里每个元素被称为”桶”。</p><p>假设有一组长度为N的待排关键字序列<code>K[N]</code>。申请一个M大小的数组<code>B[M]</code>作为“桶数组”。然后基于某种映射函数 ，将待排序列<code>K[k]</code>映射到桶<code>B[i]</code>中 ，<br><code>K[N]</code>的规模是大于<code>B[M]</code>的，所以多个K中的元素可能放入B的一个桶位，放入时K的元素需要排序。<br>接着对每个桶<code>B[i]</code>中的所有元素进行比较排序(可以使用快排)。<br>元素<code>K[k]</code>需要映射到桶数组<code>B[i]</code>的位置上，其中<code>i=f(K[k])</code>，并且如果有<code>K[i] &lt; K[j]</code>，那么<code>f(K[i]) &lt; f[K[j]]</code>，也就是说B[i]中的最小数据都要大于B[i-1]中最大数据。很显然，映射函数的选择非常重要。</p><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。　</p><p>复杂度分析:</p><ol><li>循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</li><li>利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 <code>∑ O(Ni*logNi)</code> 。其中<code>Ni</code>为第i个桶的数据量。</li></ol><p>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：</p><ul><li>映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。</li><li>尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</li></ul><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O(N) + O(M*(N/M)*log(N/M)) = O(N + N*(logN-logM)) = O(N + N*logN - N*logM)</span><br></pre></td></tr></table></figure><p>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到<code>O(N)</code>。</p><h1 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h1><p>基数排序是非比较排序算法,算法的时间复杂度是O(n)。<br>基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。主要思路是，将所有待比较数值(注意,必须是正整数)统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始, 依次进行一次稳定排序，这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>比如这样一个数列排序: <code>342 ，58， 576， 356</code>, 以下描述演示了具体的排序过程</p><p>第一次排序(个位):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">5 7 6</span><br><span class="line">3 5 6</span><br><span class="line">0 5 8</span><br></pre></td></tr></table></figure><p>第二次排序(十位):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">3 5 6</span><br><span class="line">0 5 8</span><br><span class="line">5 7 6</span><br></pre></td></tr></table></figure><p>第三次排序(百位):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 5 8</span><br><span class="line">3 4 2</span><br><span class="line">3 5 6</span><br><span class="line">5 7 6</span><br></pre></td></tr></table></figure></p><p>结果: <code>58 342 356 576</code></p><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><blockquote><p><a href="http://data.biancheng.net/view/76.html" target="_blank" rel="noopener">一眨眼的功夫了解什么是外部排序算法</a></p></blockquote><h1 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h1><table><thead><tr><th>排序方法</th><th>平均时间</th><th>最坏情况</th><th>额外存储</th></tr></thead><tbody><tr><td>插入排序</td><td>n^2</td><td>n^2</td><td>1</td></tr><tr><td>冒泡排序</td><td>n^2</td><td>n^2</td><td>1</td></tr><tr><td>快速排序</td><td>nlogn</td><td>n^2</td><td>logn</td></tr><tr><td>归并排序</td><td>nlogn</td><td>nlogn</td><td>n</td></tr><tr><td>堆排序</td><td>nlogn</td><td>nlogn</td><td>1</td></tr><tr><td>希尔(n/2步长)</td><td>nlogn</td><td>nlogn</td><td>1</td></tr></tbody></table><ol><li>从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。</li><li>上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</li><li>从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择</li></ol><h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p><code>稳定排序</code>能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。<br>基数排序就是这样，先按低位排序，逐次按高位排序，那么，低位相同的数据元素其先后位置顺序即使在高位也相同时是不会改变的</p><hr><ul><li><a href="http://www.raychase.net/1814" target="_blank" rel="noopener">排序算法一览（上）：交换类、选择类和插入类排序</a></li><li><a href="http://www.raychase.net/1876" target="_blank" rel="noopener">排序算法一览（下）：归并类、分布类和混合类排序</a></li><li><a href="https://www.cnblogs.com/wxisme/p/5243631.html" target="_blank" rel="noopener">面试中的排序算法总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 01.Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 希尔排序 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法概述</title>
      <link href="/01.Algorithm/Alg.02.%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
      <url>/01.Algorithm/Alg.02.%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>@todo:</p><ul><li>算法设计:  排序, 贪心, 分治, 动态规划, 回溯, 随机化</li><li>数学基础: 二分查找, 欧几里得算法, 快速幂算法</li><li>字符串匹配算法: KMP</li><li>图论算法:<ul><li>拓扑顺序</li><li>最短路径: Dijkstra算法, Floyd-Warshall算法</li><li>最小生成树: Prim, Kruskal</li></ul></li><li>搜索算法: BFS, DFS, A*搜索</li><li>几何算法: 向量, 凸包</li><li>快速傅里叶变换(FFT): 离散傅里叶变换</li></ul><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="几何级数-amp-算数级数"><a href="#几何级数-amp-算数级数" class="headerlink" title="几何级数 &amp; 算数级数"></a>几何级数 &amp; 算数级数</h2><ul><li>几何级数: $$ 1 + 2^1 + 2^2 + … + 2^N = 2^(N+1) -1 ≈ 2^N $$</li><li>算术级数: $$ 1 + 2 + 3 + … + N = N(N+1)/2  ≈ N^2/2 $$</li></ul><h2 id="复杂度表示法"><a href="#复杂度表示法" class="headerlink" title="复杂度表示法"></a>复杂度表示法</h2><p>▶ 大O符号（英语：Big O notation） 用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。<br>设函数 $f(n)$ 代表某一算法在输入大小为n的情况下的工作量（效率），<br>我们将 $f(n)$ 与另一行为已知的函数 $g(n)$ 进行比较，<br>如果存在正数 C 和 n0，使得对于一切 $ n &gt;= n0 $ 有： $ 0 &lt;= f(n) &lt;= C g(n) $，<br>则可以称 $f(n)$ 的渐进上界是 $g(n)$，记做 $ f(n) = O(g(n)) $，</p><p>▶ 小O符号： 类似大O，也用来表示「渐近上界」，<br>对于任意正数 C 和 n0，使得对于一切 $ n &gt;= n0 $ 有： $ 0  &lt;= f(n) &lt; C g(n) $，<br>则可以称 $f(n)$ 的渐进下界是 $g(n)$，记做 $ f(n) = o(g(n)) $。<br>注意与大O定义的不同：</p><ul><li>大O:「只要存在一个正数C」以及 $ f(n) &lt;= C g(n) $。</li><li>小O:「任意正数C」以及 $ f(n) &lt; C g(n) $。</li><li>两者都描述上限，但小O是更强有力的陈述，如果f∈o(g)，则f和g的增长率之间的差距比f∈O(g)时大得多。</li></ul><p>例如, $ f(n) = n^2 + n $，则 $ f(n) $ 的复杂度可以记为 $ o(n^3) $</p><p><img src="/images/alg/big-o.png" alt="Big-O"></p><p>▶ 大Ω符号，读音：big omega，用另一个（通常更简单的）函数来描述一个函数数量级的「渐进下界」。<br>如果存在正数 C 和 n0，使得对于一切 $ n &gt;= n0 $ 有： $ 0  &lt;= C g(n) &lt;= f(n) $，<br>则可以称 $f(n)$ 的渐进下界是 $g(n)$，记做 $ f(n) = Ω(g(n)) $</p><p><img src="/images/alg/big-omega.png" alt="big-omega"></p><p>@ref: <a href="https://www.coursera.org/lecture/algorithms/007han-shu-de-jian-jin-de-jie-bnDM3" target="_blank" rel="noopener">007函数的渐近的界 - 算法基础 | Coursera</a></p><h2 id="常用算法复杂度分析"><a href="#常用算法复杂度分析" class="headerlink" title="常用算法复杂度分析"></a>常用算法复杂度分析</h2><p>算法中 $log$ 级别的时间复杂度都是由于使用了分治思想, 这个底数直接由分治的复杂度决定:</p><ul><li>如果采用二分法, 那么就是 $$ log_2n $$, 三分法就是 $log_3 n$, 其他亦然;</li><li>不过无论底数是什么, 对数函数的渐进趋势是一样的, 所以通常忽略底数只用 $logn$ 表示;</li></ul><p>场景复杂度的增长趋势如下图: $O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$</p><p><img src="/images/alg/Big-O-Chart.png" alt="时间复杂度增长趋势"></p><h3 id="排序算法复杂度"><a href="#排序算法复杂度" class="headerlink" title="排序算法复杂度"></a>排序算法复杂度</h3><p><img src="/images/alg/sorting-algorithms-complexity.png" alt="Sorting_Algorithms_Complexity"></p><h3 id="数据结构复杂度"><a href="#数据结构复杂度" class="headerlink" title="数据结构复杂度"></a>数据结构复杂度</h3><p><img src="/images/alg/common-data-structure-operations-complexity.png" alt="Common_Data_Structure_Operations"></p><h3 id="Big-O-Cheat"><a href="#Big-O-Cheat" class="headerlink" title="Big-O Cheat"></a>Big-O Cheat</h3><p><img src="/images/alg/big-o-cheat-sheet-poster.png" alt="bigocheatsheet"></p><p>@ref： <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell</a></p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><h2 id="贪婪"><a href="#贪婪" class="headerlink" title="贪婪"></a>贪婪</h2><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/77429266" target="_blank" rel="noopener">贪心算法详解</a></li></ul><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/77427116" target="_blank" rel="noopener">分治算法详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/26033061" target="_blank" rel="noopener">map-reduce中的分治思想</a></li></ul><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>@todo</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/77435778" target="_blank" rel="noopener">动态规划详解</a></li></ul><h1 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h1><h2 id="深度优先-amp-广度优先"><a href="#深度优先-amp-广度优先" class="headerlink" title="深度优先 &amp; 广度优先"></a>深度优先 &amp; 广度优先</h2><p>==&gt; [[数据结构#图]]</p><blockquote><p>图(Graph)是一种灵活的数据结构，一般作为一种模型用来定义对象之间的关系或联系。对象由顶点（V）表示，而对象之间的关系或者关联则通过图的边（E）来表示。图可以分为有向图和无向图，一般用 $ G=(V,E) $ 来表示图。</p></blockquote><blockquote><p>深度优先(DFS) vs 广度优先(BFS)</p><ul><li><strong>深度优先</strong> 算法是一种优先遍历子节点而不是回溯的算法，时间复杂度: O(|V| + |E|)</li><li><strong>广度优先</strong> 搜索是优先遍历邻居节点而不是子节点的图遍历算法，时间复杂度: O(|V| + |E|)</li></ul></blockquote><p><img src="/images/alg/graph-dfs-and-bfs.png" alt="Graph_DFS_and_BFS"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>@todo</p><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>@todo</p><h3 id="无权最短路径"><a href="#无权最短路径" class="headerlink" title="无权最短路径"></a>无权最短路径</h3><p>@todo</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>@todo</p><h2 id="网络流问题"><a href="#网络流问题" class="headerlink" title="网络流问题"></a>网络流问题</h2><p>@todo</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>@todo</p><hr>]]></content>
      
      
      <categories>
          
          <category> 01.Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用数据结构</title>
      <link href="/01.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/01.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>@todo</p><ul><li>链表, 队列</li><li>平衡树, 红黑树</li><li>哈希</li><li>优先队列</li><li>并查集Union-find(不相交集,第8章)</li><li>补充: 线段树</li></ul><hr><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>树的阶: 一个节点拥有的子节点最大值, 二叉树的阶是2</li><li>树的度: 同阶的概念, <a href="https://www.zhihu.com/question/19836260" target="_blank" rel="noopener">为什么 B-tree 在不同著作中度的定义有一定差别？ - 知乎</a></li><li>叶子节点: 没有子节点的节点,称为叶子节点</li><li>节点的高度: 到最深树叶的路径长度</li><li>节点的深度: 节点到根节点的距离(根节点深度为0)</li><li>树的高度: 根节点的高度</li></ul><h2 id="常用树结构简述"><a href="#常用树结构简述" class="headerlink" title="常用树结构简述"></a>常用树结构简述</h2><p><img src="/images/alg/tree.png" alt="Tree"></p><p>➤ 二叉树: 每个节点的叶子不超过2</p><p>➤ 完全二叉树: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树</p><p><img src="/images/alg/完全二叉树.png" alt="完全二叉树"></p><p>➤ 二叉搜索树（BST / BinarySearchTree）:</p><ul><li>对于树中某个节点X, 左子树中所有值都小于X, 右子树所有值都大于X; 不足: 但是当原序列有序时二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。时间复杂度:<ul><li>索引: <code>O(log(n))</code></li><li>搜索: <code>O(log(n))</code></li><li>插入: <code>O(log(n))</code></li><li>删除: <code>O(log(n))</code></li></ul></li></ul><p><img src="/images/alg/二叉搜索树.png" alt="二叉搜索树"></p><p>➤ 平衡二叉树(AVL): 任何节点的左右子树高度差不超过1;</p><p>➤ 红黑树: 红黑树是一种自平衡”二叉查找树”。红黑树在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。</p><ul><li>通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍.</li><li>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</li></ul><p>➤ 二叉堆(Binary Heap) :二叉堆是”完全二叉树”或者是”近似完全二叉树”, 父节点的键值总是小于或等于子节点(根节点的值是最小的)</p><p><img src="/images/alg/二叉堆.png" alt="二叉堆"></p><p>➤ B-树: “Balance Tree”, 阶为<code>M</code>的树, 满足:</p><ul><li>每个非叶子节点由 n 个关键字和 n+1 个指针构成,</li><li>所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>根节点的子节点数在 2 ~ M 之间</li><li>其他节点的子节点数在 M/2 ~ M 之间</li><li>所有叶子节点在相同的高度</li><li>一个度为 M 的 B-Tree，设其索引 N个key，则其树高h的上限为 $\log_d((N+1)/2)$，检索一个key复杂度为 $\log_d N$。</li></ul><p>➤ B+树:</p><ul><li>要存储的数据只在叶子节点中, 非叶子节点不存储数据, 只有关键字;</li><li>相邻的叶子节点之间都有一个链指针，不需要遍历整棵树就可以得到所存储的全部数据// Mysql执行range-query扫库很方便</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul><li>先序(preOrder): 中-左-右</li><li>中序(inOrder):</li><li>后序(postOrder):</li></ul><p>➤ 先序遍历(递归):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;T&gt; n)</span> </span>&#123;</span><br><span class="line">    System.out.println(n.data);  <span class="comment">// 先序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n.left != <span class="keyword">null</span>)</span><br><span class="line">        preOrder(n.left);</span><br><span class="line">    <span class="keyword">if</span> (n.right != <span class="keyword">null</span>)</span><br><span class="line">        preOrder(n.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 先序-非递归, 最简单的一种:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        Node n = s.pop(); <span class="comment">// 刚开始就pop了, 这种只能用来做先序</span></span><br><span class="line">        System.out.println(n.data); <span class="comment">// 先序</span></span><br><span class="line">        <span class="keyword">if</span>(n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(n.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(n.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ ✨先序-非递归(方法2), 使用栈模拟递归:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(root.data); <span class="comment">// 先序</span></span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = s.pop();</span><br><span class="line">            <span class="comment">// System.out.println(root.data); // 中序</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 中序-非递归与上面类似</p><p>➤ ✨后序-非递归(需要辅助栈):</p><ul><li>Push根结点到第一个栈s1中。</li><li>从第一个栈s1中Pop出一个结点，并将其Push到第二个栈output中。</li><li>然后Push该结点的左孩子和右孩子到第一个栈s中。</li><li>重复过程2和3直到栈s为空。</li><li>完成后，所有结点已经Push到栈output中，且按照后序遍历的顺序存放，直接全部Pop出来即是二叉树后序遍历结果。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack s1 = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack s2 = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    s1.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty) &#123;</span><br><span class="line">        Node curr = s1.pop();</span><br><span class="line"></span><br><span class="line">        s2.push(curr);</span><br><span class="line">        <span class="keyword">if</span>(curr.left !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(curr.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr.right !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s2.isEmpty()) &#123;</span><br><span class="line">        Node curr = s2.pop();</span><br><span class="line">        System.out.println(cur.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ ✨层序遍历（非递归算法）:<br>第一个队列currentLevel用于存储当前层的结点，第二个队列nextLevel用于存储下一层的结点。当前层currentLevel为空时，表示这一层已经遍历完成，可以打印换行符了。<br>然后将第一个空的队列currentLevel与队列nextLevel交换，然后重复该过程直到结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; currentLevel = <span class="keyword">new</span> Queue();</span><br><span class="line">    Queue&lt;Node&gt; nextLevel = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    currentLevel.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!currentLevel.isEmpty()) &#123;</span><br><span class="line">        currNode = currentLevel.poll();</span><br><span class="line">        <span class="keyword">if</span>(currNode) &#123;</span><br><span class="line">            print(currNode);</span><br><span class="line">            nextLevel.offer(currNode.left);</span><br><span class="line">            nextLevel.offer(currNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(currentLevel.isEmpty()) &#123;</span><br><span class="line">            print(<span class="string">"/n"</span>);</span><br><span class="line">            swap(currentLevel, nextLevel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/sgbfblog/article/details/7773103" target="_blank" rel="noopener">https://blog.csdn.net/sgbfblog/article/details/7773103</a></p></blockquote><h3 id="节点删除-插入"><a href="#节点删除-插入" class="headerlink" title="节点删除/插入"></a>节点删除/插入</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/24873443?refer=hinus" target="_blank" rel="noopener">数据结构（七）：二叉树的删除和应用举例</a></li></ul><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><blockquote><p>任何节点的左右子树高度差不超过1</p></blockquote><ul><li><a href="https://zhuanlan.zhihu.com/p/25239615?refer=hinus" target="_blank" rel="noopener">平衡二叉树</a></li><li><a href="https://zhuanlan.zhihu.com/p/25320155?refer=hinus" target="_blank" rel="noopener">代码实现平衡二叉树</a></li></ul><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>AVL树在插入/删除节点后, 需要用旋转的操作重新平衡;</p><blockquote><p>概念: 「节点的平衡因子」 每个结点的平衡因子就是该结点的左子树的高度减去右子树的高度，平衡二叉树的每个结点的平衡因子的绝对值不会超过2</p></blockquote><p>以下图表以4列表示4种需要重新做平衡的情况, Root是失去平衡树的根节点(左右子树高度差大于1)</p><ul><li>左左: 失衡节点root的左子树更高, root左子树的左子树更高</li><li>右右:</li><li>左右: 失衡节点root的左子树更高, root左子树的右子树更高</li><li>右坐:</li></ul><p>图: 四种情况的旋转(Root是失去平衡树的根节点，Pivot是旋转后重新平衡树的根节点),<br>可以看到需要<strong>1~2次</strong>旋转即可使不平衡节点重新平衡:<br><img src="/images/alg/Tree_Rebalancing.png" alt="Rotate"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>查找: 可以像普通二叉查找树一样的进行，所以耗费O(log n)时间，因为AVL树总是保持平衡的</li><li>插入: 向AVL树插入，可以透过如同它是未平衡的二叉查找树一样，把给定的值插入树中，接着自底往上向根节点折回，于在插入期间成为不平衡的所有节点(平衡因子&gt;1, 即左右子树高度差)上进行旋转来完成。上面分析了四种情况, 旋转1~2次即可完成, 所以也是 <code>O(log n)</code></li></ul><ul><li>删除:<ul><li>先看二叉查找树(BST)的删除操作: 当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的…的右叶子结点与P互换(左的右右右, 也即比P小但是p最大的孩子 )，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过 <code>O(logN)</code>。</li><li>从AVL树中删除，AVL删除结点的算法可以参见上面BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为 O(2logN)</li></ul></li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树的5个性质:</p><ul><li>每个结点要么是红的要么是黑的。</li><li>根结点是黑的。</li><li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。</li><li>如果一个结点是红的，那么它的两个儿子都是黑的。</li><li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</li></ul><blockquote><p>正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。</p></blockquote><p> 下图中，”叶结点” 或着叫”NULL结点”，它不包含数据而只充当树在此结束的指示，这些节点在绘图中经常被省略<br><img src="/images/alg/rbtree.png" alt="RBTree"></p><h3 id="如何平衡"><a href="#如何平衡" class="headerlink" title="如何平衡"></a>如何平衡</h3><p>@todo</p><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>查找代价：由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。</li><li>插入代价：RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。</li><li>删除代价：RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</li></ul><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/30248914" target="_blank" rel="noopener">数据结构：线段树</a></li></ul><h2 id="几种树的复杂度比较"><a href="#几种树的复杂度比较" class="headerlink" title="几种树的复杂度比较"></a>几种树的复杂度比较</h2><ul><li><a href="https://blog.csdn.net/keda8997110/article/details/45057081" target="_blank" rel="noopener">二叉查找树(BST)，平衡二叉查找树(AVL)，红黑树(RBT)，B~/B+树(B-tree）的比较</a></li></ul><h1 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列(堆)"></a>优先队列(堆)</h1><p>二叉堆就结构性质上来说就是一个完全填满的二叉树，满足树的结构性和堆序性。堆序性指的是：父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/25820535" target="_blank" rel="noopener">数据结构：堆</a></li><li><a href="https://zhuanlan.zhihu.com/p/25843530" target="_blank" rel="noopener">堆排序和PriorityQueue源码解析</a></li></ul><h1 id="散列表-Hash-Table"><a href="#散列表-Hash-Table" class="headerlink" title="散列表(Hash Table)"></a>散列表(Hash Table)</h1><ul><li>解决冲突<ol><li>链表分离: Java的HashMap</li><li>开放定址:</li></ol></li></ul><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/26810667" target="_blank" rel="noopener">图算法：图的表达</a></li></ul><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27829340" target="_blank" rel="noopener">图的非递归遍历</a></li></ul><h2 id="深度优先和广度优先"><a href="#深度优先和广度优先" class="headerlink" title="深度优先和广度优先"></a>深度优先和广度优先</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26987139" target="_blank" rel="noopener">图的深度优先搜索</a></li><li><a href="https://zhuanlan.zhihu.com/p/26855400" target="_blank" rel="noopener">图的广度优先搜索</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 01.Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/99.Journal/2022.10%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89II/"/>
      <url>/99.Journal/2022.10%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89II/</url>
      
        <content type="html"><![CDATA[<p>人生的意义是？不否认，世间本无意义。</p><p>但人可以选择是否要赋予其意义。这种动机可以看成是一种“西西弗式的 英勇的虚无主义”。罗素在自传写过《What I Have Lived for》，如果让我回答 这个问题<br>—— 让我感受到生命和其意义的，应该是那些最简单、最自然、能带给自己好的感受的事物（感谢里尔克）</p><blockquote><p>它们看起来是正确的、美好的；它们提供内在的满足，而不需要别的动机来支持<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p></blockquote><p>一. 对知识的追求。它们帮我找回我那属于理性的另一半灵魂、帮我消除偏见，解答我的疑惑，也给予我开放和容纳的心态。知识帮我理解我所<strong>触碰</strong>到的世界。<br>缮写室、毕达哥拉斯的金诗、卡尔达诺书……无论迷茫曾把我带向何处，当我翻开书时，我总能找到这片<strong>居心地</strong></p><p>二. 自身价值得到实现。因为<strong>利他性</strong>的内核，我是乐于助人的。相比直接的帮助，我更希望自己的建议和观点有助于人。对于亲密的人，除了陪伴，也希望自己对彼此内心成长性有所裨益。这些让我直观地感受到存在的价值。<br>  “知识和观点应该是被这样使用，而不是写入卷轴然后束之高阁”</p><p>三. 那些打动内心的生活体验。<br>  我曾在黎明时刻路过海边的红树林，那那里 我听到千万只海鸟的鸣叫，如此近距离地触摸到鲜活又真实的生命力，那一刻我感受到周身被一种<strong>明澈</strong>的希望的感觉托起。没人比《我在荒岛迎接黎明》里写得更好… “十万支金喇叭又一次齐鸣，我忽然泪下如雨，但是我心底在欢歌 ”；<br>  曾偶然路过的街巷，我听到  树叶在风中的飒响、还有树荫下洗麻将的声音，那一刻我能真诚地感受到生活的美好，像《黄昏黎明》的歌词：“缓 缓 说 起 以 后 ，在 什 么 城 市 ， 进怎样的门，People talk and talk，love is found and lost”<br>  —— 这些微小的体验都曾打动我。</p><p>四. 可能还有.. 对感情的渴望，无需用其他方式证明，只需当我心甘情愿地说出“无论什么时候，我都愿意站在你这一边”。以及… 当我面对你时，终于可以把<strong>内心的柔软</strong> 自然地表达。过去我有一瓶香水叫「无论如何」，意思是无论如何都要找到爱的人</p><p>五. 被打动、不可言说的情节 … 比如不适合这个时代的英雄主义，殉道者们 etc.</p><p>以上几种，在我不同的时期可能有不同的次序和重要性，或者有些曾在我的生活里消失很久。但我知道它们无论何时出现，都会令我欣喜 或触动。人生是一条自我完善（Ego Integrity）的旅途</p><p>我还是爱这个世界的</p><hr><p>@update:</p><p>人是种追求意义的动物，却生在一个本没有意义的世界中，这么说是因为在宇宙中并没有宏大的设计，世界也不会告知你我意义的方向，它们同样冷漠且客观，对人类的追寻意义的期望无动于衷。就像加缪所说，世界是荒谬的。</p><p>我曾经不喜欢身上感性的那部分，因为它太柔软，且容易产生情绪，所以我选择有棱角也不容易被撼动的理性，当时的我为找到了正确道路自喜。<br>但当我面对虚无主义的时候，理性却无能为力，因为选择理性等同于承认客观世界的无意义，所以当时的我只好把“人生的意义是什么”看做一个黑洞问题 —— 因为黑洞无法直视，无尽的虚空吞噬投向它的一切。我知道，有许多为此饱受折磨的人。我相信罗素所描写的正是这种感受：“在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊”<br>我可以做的，只有尽快把自己投入进繁忙的工作，选择暂时远离和忘记。这很可笑，提出这个问题和面对这个问题的方式同样可笑</p><p>既然理性无法给我以解答，那就去问自己的感受 ——那些 自然的、正确的、美好的、打动内心的东西，是什么</p><blockquote><p>假如可以带粉笔进入迷宫，以纯蓝<br>标记每一处通往灾祸的岔口：“我到过这儿<br>必将永不再受诱”，它们将变得可以承受。<br>假如我尝过的每种汞与砷<br>能使你免于读懂这首诗<br>——它们将变得可以承受，</p></blockquote><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://book.douban.com/subject/26304954/" target="_blank" rel="noopener">欧文·亚隆 - 存在主义心理治疗</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> 人生的意义 </tag>
            
            <tag> 虚无主义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步 VSCode 配置文件（macOS）</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%E5%90%8C%E6%AD%A5VSCode%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%E5%90%8C%E6%AD%A5VSCode%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="方法1-使用Dropbox同步"><a href="#方法1-使用Dropbox同步" class="headerlink" title="方法1) 使用Dropbox同步"></a>方法1) 使用Dropbox同步</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/Library/Application\ Support/Code</span><br><span class="line">mv -f User ~/Dropbox/VSCode/</span><br><span class="line">ln -s ~/Dropbox/VSCode/User User</span><br></pre></td></tr></table></figure><h1 id="方法2-使用-Microsoft-账号同步"><a href="#方法2-使用-Microsoft-账号同步" class="headerlink" title="方法2) 使用 Microsoft 账号同步"></a>方法2) 使用 Microsoft 账号同步</h1><p><a href="https://code.visualstudio.com/docs/editor/settings-sync" target="_blank" rel="noopener">Settings Sync in Visual Studio Code</a></p><h1 id="方法3-使用-Settings-Sync-扩展"><a href="#方法3-使用-Settings-Sync-扩展" class="headerlink" title="方法3) 使用 Settings Sync 扩展"></a>方法3) 使用 Settings Sync 扩展</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">Settings Sync - Visual Studio Marketplace</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> OSX </tag>
            
            <tag> macOS </tag>
            
            <tag> VSCode </tag>
            
            <tag> Dropbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OKR是什么</title>
      <link href="/51.Productivity/OKR%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/51.Productivity/OKR%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="vs-KPI"><a href="#vs-KPI" class="headerlink" title="vs KPI"></a>vs KPI</h1><p>KPI只有数据指标, 没有目标（Objective）</p><p>KPI还有一个更严重的问题，那就是为了完成可测量的目标，有可能实际执行手段与该目标要达到的不可测量愿景正好相反。举个例子来说，我们希望用户更喜欢使用我们的产品，因为喜欢无法测量，所以把PV写进了KPI里面。但在实际执行过程中，我们可以把用户原本在一个页面上就能完成的事情分到几个页面上来完成，结果PV达到了KPI指定的目标，但用户其实更讨厌我们的产品了。</p><p>OKR解决了KPI的种种缺陷。首先它和绩效考核分离，把绩效考核交给peerreview（相当于中国公司的360度评价）来做。</p><h1 id="制定"><a href="#制定" class="headerlink" title="制定"></a>制定</h1><blockquote><p>制定OKR的基本方法是：<br>首先，要设定一个“目标”（Objective），这个目标不必是确切的、可衡量的，例如“我想让我的网站更好”；<br>然后，设定若干可以量化的“关键结果”（Key Results），用来帮助自己实现目标，例如“让网站速度加快30%”或者“融入度提升15%”之类的具体目标。</p></blockquote><p>目标（Objective）要是有野心的，有一些挑战的，有些让你不舒服的。<br>一般来说，1为总分的评分，达到0.6-0.7是较好的了，这样你才会不断为你的目标而奋斗，而不会出现期限不到就完成目标的情况。</p><p>关键结果（Key Results）所谓的KR就是为了完成这个目标我们必须做什么，KR是必须具备以下特点的行动：</p><ul><li>必须是能直接实现目标的；</li><li>必须具有进取心、敢创新的，可以不是常规的；</li><li>必须是以产出或者结果为基础的、可衡量的，设定评分标准；</li><li>不能太多，一般每个目标的KR不超过4个；</li><li>必须是和时间相联系的。</li></ul><p>常见的KR分为三种类型：积极的、有效的、临界值, 举例:</p><ul><li>积极的：6月底前完成40篇博客撰写。</li><li>消极的：40篇内容错别字不超过2处。</li><li>临界值：咨询转化率保证在60%以上。</li></ul><p>建议你尽可能的设定积极的KR，我们应该试图去获得好的成绩，而不是避免不好的事情发生。</p><h1 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h1><p>@TODO</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>Objective设定为：提升每位用户的平均观看时间</p><p>那么Key Results可以设定为：</p><p>•提升每天XX分钟的观看时间<br>•推出两个新的操作系统的YouTube客户端<br>•降低X%的视频加载时间</p>]]></content>
      
      
      <categories>
          
          <category> 51.Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新裤子年鉴</title>
      <link href="/63.Culture-and-Arts/%E6%96%B0%E8%A3%A4%E5%AD%90%E5%B9%B4%E9%89%B4/"/>
      <url>/63.Culture-and-Arts/%E6%96%B0%E8%A3%A4%E5%AD%90%E5%B9%B4%E9%89%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="专辑list"><a href="#专辑list" class="headerlink" title="专辑list"></a>专辑list</h1><p>乐评from： <a href="https://www.huxiu.com/article/308640.html" target="_blank" rel="noopener">新裤子：北京旧浪潮-虎嗅网</a></p><p><img src="/images/新裤子年鉴/新裤子.png" alt="新裤子"></p><ul><li>1998年：<a href="https://music.douban.com/subject/1406354/" target="_blank" rel="noopener">同名专辑《新裤子》</a> #Punk<ol start="2"><li>我们的时代</li><li>嘿！你</li><li>我不想失去你</li><li>猴子</li><li>过时</li></ol></li></ul><p><img src="/images/新裤子年鉴/disco-girl.png" alt="Disco Girl"></p><ul><li><a href="https://music.douban.com/subject/3576615/" target="_blank" rel="noopener">2000年：《Disco Girl》</a>  #Punk #Disco #新浪潮<ol><li>流行一代</li><li>Disco Girl</li><li>我爱你</li><li>计算机</li><li>Modern Sky</li><li>我们明天就分手</li></ol></li></ul><p><img src="/images/新裤子年鉴/我们是自动的.png" alt="我们是自动的"></p><ul><li><p>2002年：《我们是自动的》 #new_wave</p><ol start="2"><li>她是自动的</li></ol><blockquote><p>2002 年，新裤子朋克时期的最后一张专辑《我们是自动的》封面还是星球大战主题，乐队在《Fashion1983》中唱着“Western style minds feels so great／Everybody living in a fashion magazine”，仿佛那个美好的彼岸即将成为此岸。</p></blockquote></li></ul><p><img src="/images/新裤子年鉴/龙虎人丹.png" alt="龙虎人丹"></p><ul><li><p><a href="https://music.douban.com/subject/3254345/" target="_blank" rel="noopener">2006年：《龙虎人丹》</a> #new_wave</p><ol><li>你就是我的明星</li><li>Bye Bye Disco</li><li>两个男朋友</li><li>神秘的香波</li><li>龙虎人丹</li><li>爱瑞巴迪</li><li>我想她</li></ol><blockquote><p>庞宽刚写出《龙虎人丹》时，取名《法国夜生活》，中间取样阿兰·德龙；后来彭磊一听，觉得调子那么老和巴黎一点关系也没有，给安个中国名儿，把阿兰·德龙的采样换成了李小龙。唱片整体设计也因此走向复古，没想到大获成功。</p></blockquote></li></ul><p><img src="/images/新裤子年鉴/野人也有爱.png" alt="野人也有爱"></p><ul><li>2008年：《野人也有爱》； #土摇<br>  02.金色偶像<br>  03.两个女朋友<br>  04.大熊猫<br>  08.伤心招待所<br>  11.我们可以在一起</li></ul><p><img src="/images/新裤子年鉴/go-east.png" alt="GO EAST"></p><ul><li><p>2009年：《Go East》</p><ol><li>Go East - 新裤子</li><li>野人也有爱 - 新裤子</li><li>我不想失去你 - 新裤子</li></ol><blockquote><p>到了 2009 年的《Go East》，彭磊和庞宽已经穿上了中山装：“I saw tears on your face／Western life is the dead／When we stand in Tian An Men Square／We can feel the happiness”。无论这是真心话还是政治波普，新裤子创作场域显然已经聚焦于中国。《我不想模仿你》中，他们又表现了一种自省而无奈的态度：“我们不是雷蒙斯，我们不是 Joy Division。”</p></blockquote></li></ul><p><img src="/images/新裤子年鉴/sex-drugs-internet.png" alt="Sex Drugs Internet"></p><ul><li>2011年：《SEX DRUGS INTERNET》 #新浪潮<br>  2.你還記得那個電影演員嗎？<br>  4.總有一天我會欺騙你<br>  7.After party<br>  10.別再問我什麽是迪斯科</li></ul><ul><li><p>2014年：《弹着吉他的少年》??</p><blockquote><p>再往后，乐队进入“土摇”时期，甚至连挣扎的迹象都不再表露于音乐中。直截了当的本土青年关怀替代了国际化前卫乐队之梦，而这些追随新裤子的本土青年又何尝不是世纪之交最先追随王小波的媒体精英的投射，只是这世界比二十年前又下沉了一点而已。</p></blockquote></li></ul><p><img src="/images/新裤子年鉴/你要跳舞吗.png" alt="你要跳舞吗"></p><ul><li>2016年：《生命因你而火热》#土摇<br>  01 你要跳舞吗<br>  02 我们最好的时光 就是现在<br>  03 没有理想的人不伤心<br>  04 每一次我们开始争吵<br>  05 生活因你而火热<br>  07 关于夜晚和失眠的世界 (album version)</li></ul><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><blockquote><p>不止《流行一代》，这张专辑还有一首超级市场乐队成员 —— 羽伞制作的赛博浪漫曲目《计算机》，更与朋克少年无涉。在即将跨入新千年的时候，电脑代表着 “青年人、神秘的事物与打开的眼睛”，对新生活敏感的 “北京新声” 乐队对此多有涉及，连主打英式摇滚的麦田守望者乐队，当时也有描写电子邮件发来生日信的《电子祝福》，甚至连专辑都命名为《Save As…》。当《计算机》在 2009年的《Go East》中被 Sulumi 重新混音时，你更能看到那首歌的超前敏感度，当时被指为不知所云的它，直接指出了之后十几年年轻人们的情感寄托。<br>《Disco Girl》的变化只是 “新裤子背叛史” 中具有代表性的一个小节，关于 “改变” 的争议贯穿了这个乐队成立以来的每个重要时点。当2006年的《龙虎人丹》彻底倒向 New Wave 与合成器流行后，连创始成员 —— 刘葆都觉得他们 “变成了一支娘娘腔的同性恋乐队”，于是加盟蜜三刀，玩回自己的 Oi Punk。新裤子则继续输出着青年人的慵懒的快乐、忧伤的嘶吼。到2013年的《没有理想的人不伤心》之后，彭磊甚至用 Shoegazing 风格的噪音音墙或 Sigur Ros 式的钢琴旋律来表达。</p></blockquote><blockquote><p>2006 年，加入 WTO 后中国的全球化之路已经走了5年，人们的生活被更多更便宜的国际品牌笼罩，人们用诺基亚和索尼爱立信的手机，用戴尔和 IBM 的笔记本电脑， 穿 Levi’s 和 G2000 的牛仔裤与都市休闲装。80年代的国货在并购潮下被冲击不小，当时网上最热的帖子是：《震惊！中华牙膏竟然不是中国货！》。 娃哈哈集团的董事长宗庆后，因为本土品牌的使用权和控股娃哈哈的达能集团打起了用民族主义当大棒的舆论战。<br>新裤子当然对民族主义没兴趣，他们是被改革开放后、商品社会前的生活趣味浸淫的一代人。2006年初，《龙虎人丹》横空出世，彭磊、庞宽、刘葆三人穿着极其 80年代的彩色条纹运动裤与皮衣，站在与全球化丝毫无关的前门大栅栏古街上 “凹造型”，发廊、舞厅、彩色墨镜、迪斯科球、合成器、紧身裤与老运动服成了这张专辑的重要意象，封面的设计也完全仿制了古早中式产品的样子 —— “龙虎人丹” 本身就是一味古老的中成药。</p></blockquote><p>@Ref <a href="https://www.sohu.com/a/203723832_119079" target="_blank" rel="noopener">除了新裤子，中国从未有一支可以影响每一代年轻人的摇滚乐队</a></p><blockquote><p>“想扭屁股”是张蔷启蒙了张晓舟那一代人的荷尔蒙的身体反应，在《别再问我什么是Disco》发布后，张晓舟在《大家》专栏上写道：<br>“在我少时的想象中，张蔷是扭着屁股唱歌的，但现在才发现，即便是在唱迪斯科劲歌的时候，她的歌唱，也多少是与身体脱节的，她的下半身还是如此的温良恭俭让。八十年代对于五千年文明来说是石破天惊的，但对于虾米陌陌时代来说，却又老派得令人发指。是历史的一阵恼人的秋风，把张蔷忽然刮到时代的前列，而她还没有做好准备，就红遍天下了，同样还没做好准备，就又被九十年代淡忘了。就像驾着手扶拖拉机一下闯进了凯宾斯基——所谓的现代性，往往是在知识分子尚未意识到、更没来得及命名的时候，便悍然发生了。张蔷的回归不仅仅具有音乐的意义——音乐美学上的价值也确实有限——而且还提供一个机会，让不同年代的人们重新认识八十年代。八十年代的中国，就像是一块古老的沉重的石头在跳舞，而张蔷们，是在用口红胡涂乱抹在XXXX上。</p></blockquote><p>@Ref <a href="http://blog.sina.com.cn/s/blog_14dd813960102xtx1.html" target="_blank" rel="noopener">DISCO is OUT , So TM What ?<em>OPEN开腔</em>新浪博客</a></p><blockquote><p>作者：Rosasinespina<br>博尔赫斯有一句诗叫，“我试图用困惑，危险，失败打动你”，我被危险打动过一次，被失败打动过一次，这次估计是新裤子独有的傻了吧唧朋克青年的困惑打动了我吧。不知为何，觉得这张专辑的好多歌词，都用一种极其无聊又刻骨的方式解构了失败与人生的困惑，比如不放开，比如总有一天我会欺骗你。要说是一种什么感觉呢，以前提过一个概念是“末日温情”，类似于杀猪之前要把猪喂饱这种心情，又或者，用一个很雷的比喻，就像是后会无期里马浩汉对江河说“我这个人朋友多，不像你”，结果最后连狗都没跟他。第一次听到“我相信明天会失败 不代表我心里没有爱”的时候简直觉得迷一样感动，当时我宿醉头晕了两天，躺在床上，正在权衡是把鞋盒里的打火机拿出来但是又担心被脚气熏死的利弊，突然就，那么一下，正中红心了，那种感觉就是，愿意用下半辈子的性生活换取此刻。（虽然下半辈子可能不会有性生活。<br>总有一天我会欺骗你，我觉得这个根本就是我的爱情观。活这么大岁数虽然情商有点跟不上但好歹也经历过一点东西了，也大概在刚开始喜欢一个人的时候就知道自己距离把他的电话号码放进黑名单还剩多久了。在我看来爱就是一个装傻装久了慢慢变成真傻的过程，享受的就是当下被骗蒙圈的感觉，等到觉得没病可以站起来走两步了，也就是时候抛弃对方了，换句话说，抛弃也算爱的一种组成部分，这个部分时时刻刻提示着人们当下的感觉才是最重要的，反正大家都在说假话，只要说的那一刻心甘情愿上当就可以了，用冯金线的话说就是，它们都存在，那时那刻，此时此刻，实在，不空。</p></blockquote><p>@Ref <a href="https://www.zhihu.com/question/21762859/answer/30447101" target="_blank" rel="noopener">新裤子乐队的彭磊是一个怎么样的人？ - Rosasinespina的回答- 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 63.Culture-and-Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流行文化 </tag>
            
            <tag> 新裤子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSX（macOS）开发环境配置 and Tweaks</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91OSX%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91OSX%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="安装OSX"><a href="#安装OSX" class="headerlink" title="安装OSX"></a>安装OSX</h1><ul><li>从OSX制作启动U盘: <a href="http://www.iplaysoft.com/osx-yosemite-usb-install-drive.html" target="_blank" rel="noopener">http://www.iplaysoft.com/osx-yosemite-usb-install-drive.html</a></li><li>从WIN制作启动U盘: <a href="http://www.cnblogs.com/maybego/p/3266528.html" target="_blank" rel="noopener">http://www.cnblogs.com/maybego/p/3266528.html</a></li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li><code>Command + Option + Esc</code> : 相当于Windows上的 Ctrl + Alt + Del，或者点击左上角图标-强制退出</li></ul><blockquote><p>参考 <a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT201236</a></p></blockquote><h1 id="开发工具-amp-常用软件"><a href="#开发工具-amp-常用软件" class="headerlink" title="开发工具 &amp; 常用软件"></a>开发工具 &amp; 常用软件</h1><h2 id="常用软件-DMG安装文件"><a href="#常用软件-DMG安装文件" class="headerlink" title="常用软件(DMG安装文件)"></a>常用软件(DMG安装文件)</h2><ul><li>Shadowsocks: <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help</a></li><li>Google Chrome: <a href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" rel="noopener">https://www.google.com/intl/zh-CN/chrome/</a></li><li>Dropbox: <a href="https://www.dropbox.com/zh_CN/install" target="_blank" rel="noopener">https://www.dropbox.com/zh_CN/install</a></li><li>1Password: <a href="https://1password.com/zh-cn/downloads/mac/" target="_blank" rel="noopener">https://1password.com/zh-cn/downloads/mac/</a></li></ul><h2 id="英雄留步"><a href="#英雄留步" class="headerlink" title="英雄留步"></a>英雄留步</h2><p>关于Xcode, 不做iOS开发也要安装, Xcode作用相当于Windows上的.NET Framework, 直接在App Store上安装即可, 下载时间很长, 可以先睡一会, 醒来就装好了.</p><p>安装完Xcode后, 命令行执行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install  # 安装 Command Line Tools</span><br><span class="line">sudo xcodebuild -license accept  # 同意协议, 不用再打开一次 Xcode了</span><br></pre></td></tr></table></figure><h2 id="Homebrew-amp-cask"><a href="#Homebrew-amp-cask" class="headerlink" title="Homebrew &amp; cask"></a>Homebrew &amp; cask</h2><ul><li>Homebrew 官网: <a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a> , 安装方式:</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><ul><li>Homebrew-cask 官网: <a href="https://caskroom.github.io/" target="_blank" rel="noopener">https://caskroom.github.io/</a> , 安装方式:</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap caskroom/cask</span><br></pre></td></tr></table></figure><blockquote><p>brew 和 brew cask 的区别:</p><blockquote><ol><li>brew 是从下载源码解压然后 <code>./configure &amp;&amp; make install</code>, brew主要用来安装不带UI的命令行或者库, brew安装的程序包在<code>/usr/local/Cellar/</code>, 可执行文件链接到<code>/usr/local/bin/</code></li><li>brew cask 是安装已经编译好了的应用包, brew cask主要用来下载一些带界面的应用软件, 安装目录默认在<code>/usr/local/Caskroom/</code></li></ol></blockquote></blockquote><p>安装了 Homebrew 和 Homebrew-cask 之后就可以用<code>brew install</code>和<code>brew cask install</code>命令安装其他程序,<br>brew 命令参考: <a href="https://docs.brew.sh/Manpage" target="_blank" rel="noopener">https://docs.brew.sh/Manpage</a></p><h3 id="替换为国内镜像"><a href="#替换为国内镜像" class="headerlink" title="替换为国内镜像"></a>替换为国内镜像</h3><blockquote><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git" target="_blank" rel="noopener">替换及重置Homebrew默认源</a></p></blockquote><p>替换为 USTC 镜像：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;/Library/Taps/caskroom/homebrew-cask</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure><p>重置为官方地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;/Library/Taps/caskroom/homebrew-cask</span><br><span class="line">git remote set-url origin https://github.com/caskroom/homebrew-cask</span><br></pre></td></tr></table></figure><h3 id="Homebrew常用命令"><a href="#Homebrew常用命令" class="headerlink" title="Homebrew常用命令"></a>Homebrew常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install xxx   # 按名称安装</span><br><span class="line">brew uninstall xxx # 按名称卸载</span><br><span class="line">brew list          # 列出已安装的包</span><br><span class="line">brew outdated      # 列出可更新的包</span><br><span class="line">brew update        # 更新Homebrew自身</span><br><span class="line">brew upgrade xxx   # 升级某个软件包</span><br><span class="line">brew upgrade       # 升级全部软件包</span><br><span class="line">brew pin/unpin xxx # 锁定或者解锁软件包版本，防止误升级</span><br><span class="line">brew search xxx    # 按名称搜索</span><br><span class="line">brew info xxx      # 查看包信息</span><br><span class="line">brew doctor        # 诊断关于Homebrew的问题(Homebrew 有问题时请用它)</span><br><span class="line">brew cleanup       # 清理老版本软件包或者无用的文件</span><br><span class="line"></span><br><span class="line"># 第三方Repositories相关:</span><br><span class="line">brew tap              # 列出所有安装的第三方Repositories</span><br><span class="line">brew tap &lt;user/repo&gt;  # 安装第三方Repositories</span><br></pre></td></tr></table></figure><h3 id="Homebrew-Cask常用命令"><a href="#Homebrew-Cask常用命令" class="headerlink" title="Homebrew-Cask常用命令"></a>Homebrew-Cask常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注: 不再支持 brew cask xx命令, 改为: brew xx --cask</span><br><span class="line"></span><br><span class="line">brew cask install xxx   # 安装软件</span><br><span class="line">brew cask uninstall xxx # 卸载软件</span><br><span class="line">brew cask search xxx    # 模糊搜索软件</span><br><span class="line">brew cask info xxx      # 显示软件的详细信息</span><br><span class="line">brew cask list          # 列出所有已安装的软件</span><br><span class="line">brew cask upgrade       # 更新所有已安装的软件</span><br></pre></td></tr></table></figure><h3 id="安装统计"><a href="#安装统计" class="headerlink" title="安装统计"></a>安装统计</h3><p>在<a href="https://brew.sh/analytics/install/" target="_blank" rel="noopener">Homebrew Analytics Install Events — Homebrew</a>可以看到被安装的app排名</p><p>使用命令<code>brew analytics off</code>来退出 Homebrew 的分析。</p><h2 id="Zsh-和终端替代品iTerm2"><a href="#Zsh-和终端替代品iTerm2" class="headerlink" title="Zsh 和终端替代品iTerm2"></a>Zsh 和终端替代品iTerm2</h2><ul><li><p>Zsh:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>终端替代品iTerm2: <code>brew cask install iterm2</code></p></li><li><p>Zsh插件 <code>brew install autojump zsh-syntax-highlighting zsh-autosuggestions</code><br>并在~/.zshrc下增加:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh`</span><br></pre></td></tr></table></figure></li><li><p>补充, 如果使用了Oh-my-zsh就不用上面这么麻烦了, 直接在~/.zshrc里这样enable插件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins=(git autojump osx mvn gradle zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure></li></ul><h2 id="编辑器-Vim-amp-Sublime"><a href="#编辑器-Vim-amp-Sublime" class="headerlink" title="编辑器(Vim &amp; Sublime)"></a>编辑器(Vim &amp; Sublime)</h2><ul><li>MacVim: <code>brew cask install macvim</code></li><li>Sublime text: <code>brew cask install sublime-text</code></li></ul><h2 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap caskroom/versions</span><br><span class="line">brew cask install java8</span><br></pre></td></tr></table></figure><p>或者直接在Oracle官网下载, 并在.bashrc（如果你用的zsh，则是.zshrc）添加<code>$JAVA_HOME</code>环境变量：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure></p><h3 id="Mac上Java的安装目录"><a href="#Mac上Java的安装目录" class="headerlink" title="Mac上Java的安装目录"></a>Mac上Java的安装目录</h3><p>在终端输入<code>which java</code>, 返回的是: “/usr/bin/java” ,<br>/usr/bin/java 是个链接, 指向: “/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java” ,<br>但是我输入<code>echo $JAVA_HOME</code>, 返回”/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home” ,<br>那么 <strong>/System/Library/Frameworks/JavaVM.framework/</strong> 和 <strong>/Library/Java/JavaVirtualMachines</strong> 哪个才是真正的Java安装目录?</p><p><img src="/images/Java_home-20190404-005514.png" alt=""></p><p>答案是后者, 我发现 “/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/“ 下所有的可执行文件大小都是完全相同的,<br>该目录中的二进制文件是确定要使用哪个Java VM的存根应用程序, 可以使用<code>dtrace</code>查看<code>java -version</code>命令调用的全过程:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dtrace -n 'syscall::posix_spawn:entry &#123; trace(copyinstr(arg1)); &#125;' -c "/usr/bin/java -version"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回如下:</span></span><br><span class="line">dtrace: description 'syscall::posix_spawn:entry ' matched 1 probe</span><br><span class="line">dtrace: pid 44727 has exited</span><br><span class="line">CPU     ID                    FUNCTION:NAME</span><br><span class="line">  8    619                posix_spawn:entry   /System/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home/bin/java</span><br></pre></td></tr></table></figure><h3 id="多版本Java共存"><a href="#多版本Java共存" class="headerlink" title="多版本Java共存"></a>多版本Java共存</h3><p>管理多版本Java的工具: <a href="http://www.jenv.be/" target="_blank" rel="noopener">jEnv</a></p><p>安装 &amp; 配置:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 jenv</span></span><br><span class="line">brew install jenv</span><br><span class="line">mkdir -p ~/.jenv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加到你的 shell profile文件:</span></span><br><span class="line">echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>添加 jdk:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> jenv add 会在 ~/.jenv/versions 下建立对应 jdk的软链</span></span><br><span class="line">jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Home</span><br><span class="line">jenv add /Library/Java/JavaVirtualMachines/jdk-12.0.2.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>How to Use:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有的 jdk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jenv versions</span></span><br><span class="line">  system</span><br><span class="line">  openjdk12.0.2</span><br><span class="line">  oraclejdk1.8.0_172</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用jdk 12(全局生效)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jenv global openjdk12.0.2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用jdk 12(当前shell生效)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jenv shell openjdk12.0.2</span></span><br></pre></td></tr></table></figure><blockquote><p>jenv 在我的MBP上一直有问题, <code>jenv global</code>无效, 港真我还是觉得自己手动修改 <code>$JAVA_HOME</code> 的方式比较好</p></blockquote><h2 id="python环境"><a href="#python环境" class="headerlink" title="python环境"></a>python环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install python ## will install python &amp; pip</span><br></pre></td></tr></table></figure><p>由于 macOS 10.13已经预安装了Python 2.7.10, 上面的命令会安装Python3 到<code>/usr/local/Cellar/python/Version</code>并在<code>/usr/local/bin/</code>创建链接:<br>python3, pip3, easy_install-3.6</p><p>对于用系统默认easy_install安装的包, 会放在<code>/Library/Python/2.7/site-packages</code>, 所以需要sudo:<br><code>sudo easy_install tornado</code></p><p>如果不喜欢sudo, 则可以用pip仅在当前用户下安装, 尤其对于需要升级系统自带的package时:<br><code>pip install --user --upgrade matplotlib</code></p><blockquote><p>easy_install和pip<br>两者都是 setuptools 基础上的工具，pip 比 easy_install 提供更多高级选项, 比如uninstall, freeze</p></blockquote><h2 id="php环境"><a href="#php环境" class="headerlink" title="php环境"></a>php环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap homebrew/php</span><br><span class="line">brew install php70</span><br><span class="line">brew install mcrypt php70-mcrypt</span><br><span class="line">brew install composer</span><br></pre></td></tr></table></figure><p>Add PATH:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;$(brew --prefix homebrew/php/php70)/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><h2 id="node环境"><a href="#node环境" class="headerlink" title="node环境"></a>node环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node ## will install node &amp; npm</span><br></pre></td></tr></table></figure><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>安装aira2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install aria2</span><br><span class="line"></span><br><span class="line">touch ~/.aria2/aria2.conf</span><br></pre></td></tr></table></figure><ul><li>使用aria2下载单个文件: <code>/usr/local/bin/aria2c -s10 -x10 &lt;下载url&gt;</code></li><li>启动 aria2 demon: <code>/usr/local/bin/aria2c --conf-path=/Users/heisenbug/.aria2/aria2.conf -D</code></li></ul><ul><li>配置文件：<code>~/.aria2/aria2.conf</code></li><li>UI 配置：<ul><li><a href="https://token:thats_a_token@localhost:6800/jsonrpc" target="_blank" rel="noopener">https://token:thats_a_token@localhost:6800/jsonrpc</a></li></ul></li></ul><p><a href="https://localhost:6800/jsonrpc" target="_blank" rel="noopener">https://localhost:6800/jsonrpc</a></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul><li>常用开发套件: <code>brew install ctags cscope wget watch tmux cmake openssl geoip automake autoconf</code></li><li>虚拟机: <code>brew cask install virtualbox</code></li><li>压缩工具: <code>brew cask install the-unarchiver</code></li></ul><h2 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h2><ul><li>生成ssh key <code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code></li><li>添加到系统: <code>ssh-add ~/.ssh/你的私钥</code></li></ul><h2 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h2><p>macOS 中 Curl 的版本针对 SSL/TLS 验证使用安全传输。<br>如果你更愿意使用 OpenSSL，用 <code>brew install curl --with-openssl</code> 安装并通过 <code>brew link --force curl</code> 确保它是默认的。</p><h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><p>升级python3、pip3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure><p>安装:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab</span><br><span class="line">pip install notebook</span><br></pre></td></tr></table></figure><p>修改默认目录:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config # 生成一个新配置文件</span><br><span class="line">gvim ~/.jupyter/jupyter_notebook_config.py</span><br><span class="line"># 找到c.NotebookApp.notebook_dir 并修改路径, 这里是相对路径(当前用户$HOME)</span><br></pre></td></tr></table></figure><p>启动:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>入门:</p><ul><li><a href="https://www.dataquest.io/blog/jupyter-notebook-tutorial/" target="_blank" rel="noopener">How to Use Jupyter Notebook in 2020: A Beginner’s Tutorial</a></li><li><a href="https://pythonforundergradengineers.com/plotting-sin-cos-with-matplotlib.html" target="_blank" rel="noopener">Plotting sine and cosine with Matplotlib and Python - Python for Undergraduate Engineers</a></li></ul><h1 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h1><h2 id="Launchpad"><a href="#Launchpad" class="headerlink" title="Launchpad"></a>Launchpad</h2><p><img src="/images/mac-os-x-launchpad.jpg" alt=""></p><p>重置 Launchpad 图标数据库：在 Terminal 中键入<br><code>defaults write com.apple.dock ResetLaunchPad -bool true &amp;&amp; killall Dock</code></p><p>配置文件位置:<br><code>~/Library/Application\ Support/Dock/desktoppicture.db</code></p><h2 id="Menu-Bar"><a href="#Menu-Bar" class="headerlink" title="Menu Bar"></a>Menu Bar</h2><p><img src="/images/mac-os-x-menu-bar.png" alt="mac-os-x-menu-bar"></p><ul><li><a href="https://sspai.com/post/39036" target="_blank" rel="noopener">Vanilla，精简 Mac 菜单栏应用图标，小巧轻量还免费丨App+1 - 少数派</a></li></ul><h2 id="Dock"><a href="#Dock" class="headerlink" title="Dock"></a>Dock</h2><p><img src="/images/mac-os-x-dock.jpg" alt=""></p><p>重置Dock<br><code>defaults delete com.apple.dock; killall Dock</code></p><h2 id="Notification-Center"><a href="#Notification-Center" class="headerlink" title="Notification Center"></a>Notification Center</h2><p>@todo</p><h2 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a>Finder</h2><p>@todo</p><h2 id="Spotlight"><a href="#Spotlight" class="headerlink" title="Spotlight"></a>Spotlight</h2><p>@todo</p><h2 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h2><p>重启airportd:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">airportd_pid=`ps -ef | grep airportd | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`; echo $&#123;airportd_pid&#125;; sudo kill -9 $&#123;airportd_pid&#125;;</span><br></pre></td></tr></table></figure><h2 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h2><p>如何清理DNS缓存:</p><p>如果操作系统是Lion、Mountain Lion和Mavericks+：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure></p><p>如果操作系统是Leopard和Snow Leopard：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure></p><h2 id="定时任务-launchd"><a href="#定时任务-launchd" class="headerlink" title="定时任务(launchd)"></a>定时任务(launchd)</h2><blockquote><p>launchctl 是一个统一的服务管理框架，可以启动、停止和管理进程、应用程序、脚本等。<br>参考: <a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" target="_blank" rel="noopener">Creating Launch Daemons and Agents</a></p></blockquote><ul><li>创建可执行脚本 task.sh</li><li>在 ~/Library/LaunchAgents 目录下创建 plist文件: <code>touch ~/Library/LaunchAgents/com.myMac.cron.task.plist</code></li><li><p>编辑 plist 文件如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">    &lt;!-- 唯一plist名字 --&gt;</span><br><span class="line">    &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;com.myMac.cron.task&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 可执行命令， 第一个为命令，其它为参数 --&gt;</span><br><span class="line">    &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">    &lt;array&gt;</span><br><span class="line">      &lt;string&gt;/Users/xxx/Scripts/task.sh&lt;/string&gt;</span><br><span class="line">    &lt;/array&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定时执行 这里的例子每天22点 --&gt;</span><br><span class="line">    &lt;key&gt;StartCalendarInterval&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">      &lt;key&gt;Minute&lt;/key&gt;</span><br><span class="line">      &lt;integer&gt;0&lt;/integer&gt;</span><br><span class="line">      &lt;key&gt;Hour&lt;/key&gt;</span><br><span class="line">      &lt;integer&gt;22&lt;/integer&gt;</span><br><span class="line">      &lt;key&gt;Weekday&lt;/key&gt;</span><br><span class="line">      &lt;integer&gt;0&lt;/integer&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 标准输出和错误输出 --&gt;</span><br><span class="line">    &lt;key&gt;StandardOutPath&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;/tmp/cron-task.log&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;StandardErrorPath&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;/tmp/cron-task.log&lt;/string&gt;</span><br><span class="line">  &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></li><li><p>加载到系统: <code>launchctl load com.myMac.cron.task.plist</code>;</p></li><li>如果查看所有载入的: <code>launchctl list</code>;</li><li>如果需要移除: <code>launchctl unload com.myMac.cron.task.plist</code>;</li><li><code>StartCalendarInterval</code>项的解释:<ul><li><code>&lt;key&gt;Hour&lt;/key&gt;</code>: Hour of the day (0-24).</li><li><code>&lt;key&gt;Weekday&lt;/key&gt;</code>: Weekday is the day of the week (0 and 7 == Sunday).</li><li><code>&lt;key&gt;Day&lt;/key&gt;</code>: Day is the day of the month.</li></ul></li></ul><h2 id="operation-not-permitted"><a href="#operation-not-permitted" class="headerlink" title="operation not permitted"></a>operation not permitted</h2><p>升级后发现的，原本正常执行的shell 脚本 报错 operation not permitted，更改为 chmod 777也不行，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l@ script.sh # 查看隐藏的@属性</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">xattr -l script.sh</span><br><span class="line"></span><br><span class="line"># 发现多了一行 com.apple.quarantine，删除：</span><br><span class="line">sudo xattr -d com.apple.quarantine script.sh</span><br></pre></td></tr></table></figure><h1 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h1><p>推荐扩展:</p><ul><li>AdBlock: 拦截广告</li><li>webQR: 当前的地址转换为二维码</li><li>Tab Lister: Chrome上的 OneTab, 可以将打开的标签页收纳到一个标签页, 关闭所有标签页节省资源</li><li>sVim: 为Safari增加Vim的快捷键 <a href="https://safari-extensions.apple.com/details/?id=com.flipxfx.svim-6Q2K7JYUZ6" target="_blank" rel="noopener">链接</a></li><li>AutoPagerize: 自动再入”下一页” <a href="https://safari-extensions.apple.com/details/?id=net.autopagerize.autppagerizeforsafari-XH6FQ533G6" target="_blank" rel="noopener">链接</a></li><li>Reverse Image Search : 图片上右键搜索相似图 <a href="https://safari-extensions.apple.com/details/?id=cf.mattijs.reverseimagesearch-7G36RSR4E4" target="_blank" rel="noopener">链接</a></li></ul><h1 id="macOS-Mojave-10-14"><a href="#macOS-Mojave-10-14" class="headerlink" title="macOS Mojave(10.14)"></a>macOS Mojave(10.14)</h1><h2 id="开启子像素抗锯齿"><a href="#开启子像素抗锯齿" class="headerlink" title="开启子像素抗锯齿"></a>开启子像素抗锯齿</h2><p>升级 macOS Mojave 新系统后，苹果默认关闭了子像素抗锯齿(也称为字体平滑)，导致字体变细锯齿增多。在连接到非Retina显示屏的MacBook Air或桌面Mac上，升级会使您的字体看起来更糟。<br>如果您的Mac带有Retina显示屏，我们不建议启用亚像素抗锯齿功能。 即使没有亚像素抗锯齿，字体在Retina显示屏上看起来也应该看起来不错且可读。 但是，如果您有非Retina显示屏，我们建议您重新启用此功能。<br>像素抗锯齿是一种技巧，旨在使字体在较低分辨率的显示器上看起来更好。 如果默认情况下未启用此功能，则macOS Mojave会使非Retina显示屏上的文本看起来更薄更模糊。<br>虽然默认情况下禁用子像素字体平滑，但您可以使用terminal命令重新启用它。 有四种可能的设置：0（禁用），1（光平滑），2（中等平滑）和3（重平滑）。</p><p>打开 【终端】应用，输入下面命令，全局启用 次像素抗锯齿 渲染： <code>defaults write -g CGFontRenderingFontSmoothingDisabled -bool NO</code></p><p>设置字体 次像素抗锯齿 级别 (类似 Linux 的 hintstyle 微调样式) 的命令： <code>defaults -currentHost write -globalDomain AppleFontSmoothing -int 3</code></p><p>查看设置后的选项值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ defaults read -g CGFontRenderingFontSmoothingDisabled</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">$ defaults -currentHost read -globalDomain AppleFontSmoothing</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>参考: <a href="https://lvii.github.io/system/2018-09-26-setting-macos-mojave-font-rendering-from-grayscale-to-subpixel-antialiasing/" target="_blank" rel="noopener">macOS Mojave 字体渲染由默认的灰度抗锯齿改回之前的次像素抗锯齿</a></p><h1 id="macOS-Catalina-10-15"><a href="#macOS-Catalina-10-15" class="headerlink" title="macOS Catalina(10.15)"></a>macOS Catalina(10.15)</h1><p>升级到 10.15后要做的:</p><ul><li><code>xcode-select --install</code></li><li><code>sudo xcodebuild -license accept</code></li><li><code>brew update &amp;&amp; brew upgrade</code></li><li>type <code>reload</code> into Alfred to refresh the application cache</li></ul><p>APFS 文件系统下, macOS的系统路径有了一些变化, 可能对使用者造成困扰:<br><a href="https://zhuanlan.zhihu.com/p/72025286" target="_blank" rel="noopener">更新 macOS 10.15 你需要知道的APFS 磁盘格式的变化 - 系统分区独立加密 - 知乎</a></p><h1 id="macOS-Big-Sur-11"><a href="#macOS-Big-Sur-11" class="headerlink" title="macOS Big Sur(11)"></a>macOS Big Sur(11)</h1><p>TODO</p><hr><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="OSX系统目录"><a href="#OSX系统目录" class="headerlink" title="OSX系统目录"></a>OSX系统目录</h2><ul><li>当前用户的软件数据目录: <code>~/Library/Application\ Support</code></li><li>系统的软件数据目录: <code>/Library/Application\ Support</code></li><li>iCloud云盘在本地的路径:   <code>~/Library/Mobile\ Documents/com~apple~CloudDocs</code></li><li>App 在 iCloud中的文档路径:<ul><li>Obsidian: <code>~/Library/Mobile\ Documents/iCloud~md~obsidian/Documents</code></li><li>Surge: <code>~/Library/Mobile\ Documents/iCloud~run~surge/Documents</code></li><li>MWeb: <code>~/Library/Mobile\ Documents/iCloud~com~coderforart~iOS~MWeb/Documents</code></li><li>自带TextEdit: <code>~/Library/Mobile\ Documents/com~apple~TextEdit/Documents</code></li><li>自带Knote: <code>~/Library/Mobile\ Documents/com~apple~Keynote/Documents</code></li><li>自带Page: <code>~/Library/Mobile\ Documents/com~apple~Pages/Documents</code></li></ul></li></ul><h2 id="自启动程序目录"><a href="#自启动程序目录" class="headerlink" title="自启动程序目录"></a>自启动程序目录</h2><ul><li>~/Library/LaunchAgents/</li><li>/Library/LaunchAgents/</li><li>/Library/LaunchDaemons/</li><li>/Library/StartupItems/</li></ul><p>参考:  <a href="http://www.freebuf.com/articles/system/108732.html" target="_blank" rel="noopener">解剖最近被发现的Mac OS木马 – OSX/Keydnap</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> OSX </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《缮写室》 Quick view</title>
      <link href="/64.Novel-and-Poesy/%E3%80%8A%E7%BC%AE%E5%86%99%E5%AE%A4%E3%80%8B%20Quick-view/"/>
      <url>/64.Novel-and-Poesy/%E3%80%8A%E7%BC%AE%E5%86%99%E5%AE%A4%E3%80%8B%20Quick-view/</url>
      
        <content type="html"><![CDATA[<p>《缮写室》 Quick view</p><p><img src="/images/IMG2019-05-03.png" alt=""></p><ul><li>天堂是缮写室的模样<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：缮写士、旷野恐惧症 （ [[../53.Photograph/使用谷歌街景进行街拍]] 中提到了摄影师 Jacqui Kenny 的“广场恐惧症”）</li><li>《世界之步: 中世纪地图鸟瞰》某种地图并非为了指路, 而是为了让人迷失在符号和色彩之中：中世纪的【T-O地图】，地图边缘的插画是欧洲版本的《山海经》</li><li>《无处流浪的吉普赛人》:  gyp词根、罗姆人，大篷车、集体回忆口授之书</li><li>《不要在中世纪花园入眠》: 中世纪出现的”梦幻诗”, 可能是在宗教夹缝中 冒出来的对<strong>孤独和自恰这种完美状态</strong>的渴望的隐喻表达</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="/64.Novel-and-Poesy/S01.博尔赫斯/" title="S01.博尔赫斯">S01.博尔赫斯</a>：“关于天赐的诗——天堂应该是图书馆的模样”</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 64.Novel-and-Poesy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitBook 使用指北</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91GitBook%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91GitBook%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>安装cli: <code>mkdir GitBook &amp;&amp; cd GitBook &amp;&amp; npm install gitbook-cli -g</code></p><p>查看是否安装成功: <code>gitbook -V</code></p><p>创建书籍目录:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bookRoot</span><br><span class="line">├── 1-FirstChapter   // The first chapter，format: &#123;orderNumber or alphabet&#125;-&#123;chapterName&#125;.md</span><br><span class="line">├────── 1-FirstDocument.md</span><br><span class="line">├────── 5-SecondDocument.md  // concentrating solely on the order, not the numbers.</span><br><span class="line">├── 3-SecondChapter                     // Focus only on the order, not the numbers.</span><br><span class="line">├────── 1-FirstDocumentOfSecondChapter.md</span><br><span class="line">├────── 2-SecondDocumentOfSecondChapter.md</span><br><span class="line">├── 7-ThirdChapter</span><br><span class="line">├── FourthChapter  // May have no order</span><br><span class="line">├── README.md // In addition to readme.md, not to put other markdown documents</span><br><span class="line">└── book.json     // Set up the book</span><br></pre></td></tr></table></figure><p>安装SUMMARY.md自动生成插件: <code>npm install -g gitbook-summary</code></p><p>执行 <code>book sm</code> , 自动生成 SUMMARY.md</p><p>创建 book.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line">    <span class="attr">"ignores"</span>: [</span><br><span class="line">        <span class="string">"_book"</span>,</span><br><span class="line">        <span class="string">"node_modules"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        <span class="string">"outline"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成html: <code>gitbook build</code> ,运行该命令后会生成 _book 文件夹, 里面的内容即为生成的 html 文件</p><p>本地预览: <code>gitbook serve</code>，然后在浏览器地址栏中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><p>生成pdf:</p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
            <tag> GitBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Macbook上使用Surge</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E5%9C%A8Macbook%E4%B8%8A%E4%BD%BF%E7%94%A8surge/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E5%9C%A8Macbook%E4%B8%8A%E4%BD%BF%E7%94%A8surge/</url>
      
        <content type="html"><![CDATA[<h1 id="安装surge"><a href="#安装surge" class="headerlink" title="安装surge"></a>安装surge</h1><p>Surge for Mac并不提供公开下载, 只对已经在手机上购买过Surge for iPhone的用户提供beta版本,<br>在Surge for iPhone的’More’标签找到<code>Surge Mac</code>, 下载链接会被发送到注册邮箱.</p><h1 id="导出Surge-iPhone的配置文件"><a href="#导出Surge-iPhone的配置文件" class="headerlink" title="导出Surge iPhone的配置文件"></a>导出Surge iPhone的配置文件</h1><p>Surge iPhone的配置文件是通用的, 可以直接使用在Surge for Mac上.<br>导出方法很多, 可以通过url共享, dropbox, 或者iTunes导出.</p><h1 id="配置Surge"><a href="#配置Surge" class="headerlink" title="配置Surge"></a>配置Surge</h1><p>第一次启动Surge会询问配置文件保存在哪里, 我直接选择的”Documents”,<br>进入<code>~/Documents/Surge/</code>目录, 把配置文件覆盖为Default.conf.</p><p>状态栏点击surge图标, 有下面几个选项 :</p><ul><li>Switch configuration: 可以重新选择surge配置的保存路径.</li><li>Reload configuration: 如果修改了配置文件, 需要reload一下.</li><li>Set as System Proxy: 选中此选项后, Surge会成为默认的http和socks代理.</li></ul><p>surge在Macbook本地启动两个端口,6152和6153, 前者是http/https代理端口, 后者是socks5代理端口.</p><p>可以通过命令 <code>lsof -i :6152</code>确认这两个端口有没有被打开.</p><h1 id="第三方应用的设置"><a href="#第三方应用的设置" class="headerlink" title="第三方应用的设置"></a>第三方应用的设置</h1><ul><li>Dropbox: 代理设置为socks, 127.0.0.1:6153</li><li>Chrome SwitchyOmega: 设置为”系统代理”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSX </tag>
            
            <tag> macOS </tag>
            
            <tag> Surge </tag>
            
            <tag> Proxy </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用fluentd,kafka,mongodb搭建日志处理系统</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E4%BD%BF%E7%94%A8fluentd,kafka,mongodb%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E4%BD%BF%E7%94%A8fluentd,kafka,mongodb%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><ul><li>采集: 可选的有fluentd, td-agent(fluentd的稳定版本, 二者区别), Apache flume.</li><li>消息持久化队列: <a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a> (分布式消息队列),<ul><li>数据源进行topic分流，实现Category</li><li>作为一层buffer来适配输入输出的消息速率，解除系统耦合度</li><li>作用类似于缓存，即活跃的数据和离线处理系统之间的缓存</li><li>kafka是显式分布式架构，producer、broker（Kafka）和consumer都可以有多个。Kafka的作用类似于缓存，即活跃的数据和离线处理系统之间的缓存。几个基本概念：<ol><li>message（消息）是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。如果consumer订阅了这个主题，那么新发布的消息就会广播给这些consumer。</li><li>Kafka是显式分布式的，多个producer、consumer和broker可以运行在一个大的集群上，作为一个逻辑整体对外提供服务。对于consumer，多个consumer可以组成一个group，这个message只能传输给某个group中的某一个consumer.</li></ol></li></ul></li><li>存储: mongo</li></ul><h1 id="Fluentd-td-agent"><a href="#Fluentd-td-agent" class="headerlink" title="Fluentd(td-agent)"></a>Fluentd(td-agent)</h1><p>Fluentd内置三种日志采集, file-tail, tcp, http-url, 通过插件可以支持更多的采集方式.</p><h2 id="Install-fluentd-td-agent-by-RPM"><a href="#Install-fluentd-td-agent-by-RPM" class="headerlink" title="Install fluentd(td-agent) by RPM"></a>Install fluentd(td-agent) by RPM</h2><p>$ curl -L <a href="http://toolbelt.treasuredata.com/sh/install-redhat.sh" target="_blank" rel="noopener">http://toolbelt.treasuredata.com/sh/install-redhat.sh</a> | sh</p><h2 id="Install-plugins"><a href="#Install-plugins" class="headerlink" title="Install plugins"></a>Install plugins</h2><p>参考 <a href="http://blog.csdn.net/virusfu/article/details/9023237" target="_blank" rel="noopener">http://blog.csdn.net/virusfu/article/details/9023237</a><br>安装插件: $ /usr/lib64/fluent/ruby/bin/gem install fluent-plugin-kafka<br>查看已安装的插件: $ /usr/lib64/fluent/ruby/bin/gem list | grep fluent-plugin-</p><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>参考 <a href="http://docs.fluentd.org/articles/config-file" target="_blank" rel="noopener">http://docs.fluentd.org/articles/config-file</a> and <a href="http://www.r66r.net/?p=504" target="_blank" rel="noopener">http://www.r66r.net/?p=504</a></p><p>编辑 /etc/td-agent/td-agent.conf<br>td-agent和fluent不同之一就是: td配置文件默认输出到Treasure Data, 需要去掉配置文件里这部分.<br>td配置文件里重要的标签有三种:</p><ul><li>source： 输入源</li><li>match ：输出目的地</li><li>include：包含其它配置文件等<br>下面是一个采集source(file-tail日志)的例子:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  type tail</span><br><span class="line">  format apache</span><br><span class="line">  path /etc/httpd/logs/access_log</span><br><span class="line">  pos_file /tmp/td-agent/access_access.pos</span><br><span class="line">  tag apache.access</span><br><span class="line">&lt;/source&gt;</span><br></pre></td></tr></table></figure><p>解释:</p><ul><li>type: tail文件追加, 或者http, forward等, 也可以使用插件输入: type tail_ex</li><li>format: 使用td-agent内置的apach日志解析规则</li><li>patch: 日志文件路径</li><li>post_file: 建议使用这个参数, post_file保存读取log的长度, 在下次宕机重启后能继续收集</li><li>tag: 用于match</li></ul><p>td-agent支持三种形式的日志采集, 不同的日志source配置也不同, 上面是file-tail的方式采集日志, 如果用http方式采集日志, 参考 <a href="http://docs.fluentd.org/articles/in_http" target="_blank" rel="noopener">http://docs.fluentd.org/articles/in_http</a> ;<br>source配置如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  type http</span><br><span class="line">  port 8994  # td-agent采集监听的port</span><br><span class="line">  tag http8994.access</span><br><span class="line">&lt;/source&gt;</span><br></pre></td></tr></table></figure></p><p>测试命令: <code>curl -X POST -d &#39;json={&quot;action&quot;:&quot;login&quot;,&quot;user&quot;:2}&#39; http://10.11.0.9:8994/forum.php</code></p><p>match:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;match apache.access&gt;</span><br><span class="line">  type file</span><br><span class="line">  path /tmp/td-agent/access_access.match</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure></p><p>解释:<br>path输出的文件名, 默认生成名为”$path.日期.xxxx” 的文件.</p><h2 id="Start-up"><a href="#Start-up" class="headerlink" title="Start up"></a>Start up</h2><ul><li>$ /etc/init.d/td-agent start //启动</li><li>$ /etc/init.d/td-agent status //状态查看</li><li>$ /etc/init.d/td-agent reload //不重启重新载入配置<br>td-agent执行日志在: /var/log/td-agent/td-agent.log</li></ul><h2 id="附例"><a href="#附例" class="headerlink" title="附例:"></a>附例:</h2><p>下面是一个输出到mongo的match例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;match mongo.**&gt;</span><br><span class="line"># plugin type</span><br><span class="line">type mongo</span><br><span class="line"># mongodb db + collection</span><br><span class="line">database apache</span><br><span class="line">collection access</span><br><span class="line"># mongodb host + port</span><br><span class="line">host localhost</span><br><span class="line">port 27017</span><br><span class="line"># interval</span><br><span class="line">flush_interval 10s</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><h3 id="fluent-plugin-kafka"><a href="#fluent-plugin-kafka" class="headerlink" title="fluent-plugin-kafka"></a>fluent-plugin-kafka</h3><p><a href="https://github.com/htgc/fluent-plugin-kafka" target="_blank" rel="noopener">https://github.com/htgc/fluent-plugin-kafka</a></p><h3 id="例-match使用grep过滤-并用tag发送到Kafka"><a href="#例-match使用grep过滤-并用tag发送到Kafka" class="headerlink" title="例:  match使用grep过滤, 并用tag发送到Kafka"></a>例:  match使用grep过滤, 并用tag发送到Kafka</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">type tail</span><br><span class="line">path  /home/wyyhzc/webApp.log</span><br><span class="line">pos_file /home/wyyhzc/webApp.log.pos</span><br><span class="line">tag webapp</span><br><span class="line">format  /^(?&lt;message&gt;(.*))$/</span><br><span class="line">&lt;/source&gt;</span><br></pre></td></tr></table></figure><p>过滤一次:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;match webapp.**&gt;       // 注意&quot;webapp.*&quot;符合&quot;webapp.a&quot;, 但不符合&quot;webapp&quot;和&quot;webapp.a.b&quot;. &quot;webapp.**&quot;符合前面所有</span><br><span class="line">type    grep            // fluent-plugin-grep插件</span><br><span class="line">regexp1 code ^4\d\d$</span><br><span class="line">exclude1 referer ^https?://yourdomain.com</span><br><span class="line">add_tag_prefix webapp_filtered  // 为这个match加tag</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><h3 id="发送到kafka"><a href="#发送到kafka" class="headerlink" title="发送到kafka"></a>发送到kafka</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;match webapp_filtered.**&gt;     // 对应上面的tag</span><br><span class="line">type             kafka</span><br><span class="line">brokers          hadoopdn1:9092 // kafka-server</span><br><span class="line">default_topic    webapp_log     // topic</span><br><span class="line">output_data_type json           // 可选(json|ltsv|msgpack|attr:&lt;record name&gt;)</span><br><span class="line">output_include_tag  false</span><br><span class="line">output_include_time flase</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><p>Apache Kafka是用于发布—订阅消息传递，实现了分布式提交日志，适用于离线和在线消息消费。</p><ul><li>消息的发布（publish）称作producer生产者，消息的订阅（subscribe）称作consumer消费者，中间的存储阵列称作broker。生产者将消息发布到Kafka主题，消费者订阅这些主题并消费这些消息。</li><li>多个broker协同合作，producer、consumer和broker三者之间通过zookeeper来协调请求和转发</li><li>producer产生和推送(push)数据到broker，consumer从broker拉取(pull)数据并进行处理</li></ul><h2 id="Install-kafka-参考http-kafka-apache-org-documentation-html"><a href="#Install-kafka-参考http-kafka-apache-org-documentation-html" class="headerlink" title="Install kafka (参考http://kafka.apache.org/documentation.html)"></a>Install kafka (参考<a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">http://kafka.apache.org/documentation.html</a>)</h2><p>安装方式有两种, 自己通过源码编译kafka, 或者直接在apache下载编译好的二进制文件.</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装:"></a>编译安装:</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xzf kafka-&lt;VERSION&gt;.tgz</span><br><span class="line">cd kafka-&lt;VERSION&gt;</span><br><span class="line">sbt update</span><br><span class="line">sbt package</span><br><span class="line">sbt assembly-package-dependency</span><br><span class="line">Kafka是用Scala写的，SBT是Simple Build Tool的简称，类似于Java的Maven。</span><br></pre></td></tr></table></figure><h3 id="下载二进制文件"><a href="#下载二进制文件" class="headerlink" title="下载二进制文件"></a>下载二进制文件</h3><p><code>wget http://apache.mirrors.hoobly.com/kafka/0.8.1.1/kafka_2.8.0-0.8.1.1.tgz</code><br>通过<code>java -version</code>查看JVM是32bit or 64 bit, 如果安装了32位的HotSpot VM，需要修改/bin/kafka-run-class.sh文件 去掉KAFKA_JVM_PERFORMANCE_OPTS的”-XX:+UseCompressedOops” 参数.</p><h3 id="启动zookeeper和kafka进程"><a href="#启动zookeeper和kafka进程" class="headerlink" title="启动zookeeper和kafka进程"></a>启动zookeeper和kafka进程</h3><p>Kafka需要zookeeper服务, 如果没有安装zookeeper, 可以启动kafka自带的单点zookeeper:</p><ul><li>启动zookeeper:  <code>$ nohup bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</code></li><li>启动kafka: $ <code>nohup bin/kafka-server-start.sh config/server.properties &amp;</code><br>停止kafka: <code>bin/kafka-server-stop.sh</code><br>停止zookeeper: <code>bin/zookeeper-server-stop.sh</code></li></ul><p>Zookeeper集群部署参考:</p><ul><li><a href="http://cn.soulmachine.me/blog/20140207/" target="_blank" rel="noopener">http://cn.soulmachine.me/blog/20140207/</a></li><li><a href="http://blog.csdn.net/shirdrn/article/details/7183503" target="_blank" rel="noopener">http://blog.csdn.net/shirdrn/article/details/7183503</a></li></ul><h3 id="单机测试命令-可略过"><a href="#单机测试命令-可略过" class="headerlink" title="单机测试命令(可略过)"></a>单机测试命令(可略过)</h3><ol><li><p>创建topic<br>message以topic(主题)为单位, productor可以向某个topic发送消息, consumer可以订阅topic;<br>bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test # 连接本机2181端口的zookeeper-serve<br>bin/kafka-topics.sh –list –zookeeper localhost:2181 # 查看已创建的topic<br>bin/kafka-topics.sh –describe –zookeeper localhost:2181 –topic test  # 查看topic的描述</p></li><li><p>启动msg消费者<br>bin/kafka-console-consumer.sh –zookeeper localhost:2181 –topic test –from-beginning  #</p></li><li><p>启动msg生产者<br>新启动Terminal输入:<br>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test<br>然后输入一些测试消息并回车, 可以看到消费者log对msg进行消费.<br>测试完成.</p></li></ol><h2 id="kafka和zookeeper集群"><a href="#kafka和zookeeper集群" class="headerlink" title="kafka和zookeeper集群"></a>kafka和zookeeper集群</h2><p>参考 <a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">http://kafka.apache.org/documentation.html</a><br>修改./config/server.properties下列参数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">broker.id=0  # 区分多个Kafka</span><br><span class="line">port=9092  #</span><br><span class="line">log.dir=/tmp/kafka-logs  #</span><br><span class="line">zookeeper.connect=nutch1:2181  # zookeeper集群地址</span><br></pre></td></tr></table></figure><ul><li>kafka-server配置文件参考 <a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">http://kafka.apache.org/documentation.html</a> // Broker Configs</li><li>Topic配置参考 <a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">http://kafka.apache.org/documentation.html</a>  // Topic-level configuration</li><li>Consumer配置参考:  <a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">http://kafka.apache.org/documentation.html</a>  // Consumer Configs , 重要参数group.id / zookeeper.connect</li><li>Producer配置参考:  <a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">http://kafka.apache.org/documentation.html</a>   // Producer Configs,</li></ul><p>启动kafka : <code>bin/kafka-server-start.sh config/server.properties</code></p><p>当然也可以在一台机器上启动多个kafka-server, 要修改上面的port和log.dir以区分不同的kafka-server, 步骤:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp config/server.properties config/server-1.properties</span><br><span class="line">cp config/server.properties config/server-2.properties</span><br></pre></td></tr></table></figure><p>修改上面两个properties文件, 启动:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server-1.properties &amp;</span><br><span class="line">bin/kafka-server-start.sh config/server-2.properties &amp;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><ul><li>fluentd+kafka+mongo: <a href="http://noops.me/?p=1325" target="_blank" rel="noopener">http://noops.me/?p=1325</a></li><li>Fluentd + MongoDB <a href="http://blog.nosqlfan.com/html/3521.html" target="_blank" rel="noopener">http://blog.nosqlfan.com/html/3521.html</a></li><li>kafka介绍:<ul><li><a href="http://dongxicheng.org/search-engine/kafka/" target="_blank" rel="noopener">http://dongxicheng.org/search-engine/kafka/</a></li><li><a href="http://my.oschina.net/ielts0909/blog/92972" target="_blank" rel="noopener">http://my.oschina.net/ielts0909/blog/92972</a></li><li><a href="http://www.biaodianfu.com/kafka.html" target="_blank" rel="noopener">http://www.biaodianfu.com/kafka.html</a></li></ul></li><li>kafka部署: <a href="http://shift-alt-ctrl.iteye.com/blog/1930791" target="_blank" rel="noopener">http://shift-alt-ctrl.iteye.com/blog/1930791</a></li><li>tdagent: <a href="http://www.r66r.net/?p=504" target="_blank" rel="noopener">http://www.r66r.net/?p=504</a></li></ul><ul><li>flume-ng+Kafka+Storm+HDFS 实时系统搭建 <a href="http://blog.csdn.net/weijonathan/article/details/18301321" target="_blank" rel="noopener">http://blog.csdn.net/weijonathan/article/details/18301321</a></li><li>flume+kafka+storm+mysql架构设计 <a href="http://blog.csdn.net/mylittlered/article/details/20810265" target="_blank" rel="noopener">http://blog.csdn.net/mylittlered/article/details/20810265</a></li><li>基于Flume的美团日志收集系统(一)架构和设计 <a href="http://tech.meituan.com/mt-log-system-arch.html" target="_blank" rel="noopener">http://tech.meituan.com/mt-log-system-arch.html</a></li><li>使用Fluentd + MongoDB构建实时日志收集系统 <a href="http://blog.nosqlfan.com/html/3521.html" target="_blank" rel="noopener">http://blog.nosqlfan.com/html/3521.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kafka </tag>
            
            <tag> 日志处理 </tag>
            
            <tag> Fluentd </tag>
            
            <tag> Flume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Eclipse安装 Terminal</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%E4%B8%BAEclipse%E5%AE%89%E8%A3%85Remote-System-Explorer/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%E4%B8%BAEclipse%E5%AE%89%E8%A3%85Remote-System-Explorer/</url>
      
        <content type="html"><![CDATA[<p>IDEA的Terminal很方便, 但Eclipse没有.<br>还是比较习惯敲命令行.</p><p>Eclipse工具栏 -&gt; Run -&gt; Extrnal Tools -&gt; Configurations , 新建一个:<br>Location填入<code>C:\Windows\System32\cmd.exe</code>, Working Directory : <code>${project_loc}</code></p><ul><li>参考<a href="http://stackoverflow.com/questions/1562600/is-there-an-eclipse-plugin-to-run-system-shell-in-the-console" target="_blank" rel="noopener">Is there an Eclipse plugin to run system shell in the Console?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Windows 下使用 vim grep 的正确姿势</title>
      <link href="/50.Farbox-Blog/%E3%80%90Vim%E3%80%91%E5%9C%A8Windows%E4%B8%8B%E4%BD%BF%E7%94%A8vim-grep%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>/50.Farbox-Blog/%E3%80%90Vim%E3%80%91%E5%9C%A8Windows%E4%B8%8B%E4%BD%BF%E7%94%A8vim-grep%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>首先, 开发环境是Windows,<br>然后, 我又是一个信仰坚定的Vimer,<br>所以就出现了<code>Windows + Gvim</code>这个有些不太协调的组合, 想在盖茨叔叔的视窗OS上稍微正常的使用Gvim还是有些小麻烦, 可是这都难不倒一个有信仰的Vimer.</p><p>PS 如果你使用Osx or Linux, 大可不必这样折腾, 直接使用<a href="https://github.com/mileszs/ack.vim" target="_blank" rel="noopener">ack.vim</a> 或 <a href="www.vim.org/script.php?script_id=311">grep.vim</a>吧, 简单的配置就可以搞定.</p><h1 id="在Win上使用grep的可选方案"><a href="#在Win上使用grep的可选方案" class="headerlink" title="在Win上使用grep的可选方案"></a>在Win上使用grep的可选方案</h1><p>在Windows上使用grep搜索文本有以下几种方案:</p><ol><li>使用<code>grep</code>命令, 虽是GNU下的工具, 但也有Win移植版;</li><li>使用vim内置的<code>vimgrep</code>命令, 速度最慢但是兼容性相对好;</li><li>使用Win下的原生命令<code>findstr</code>;</li><li>使用Win移植版的ack, 这种方法我没尝试过, 如果你用过了, 请一定告诉我:P</li></ol><h2 id="使用-grep-vim"><a href="#使用-grep-vim" class="headerlink" title="使用 grep.vim"></a>使用 grep.vim</h2><p>虽然grep.vim插件也可以在Windows上使用, 插件也提供了一些Win下使用的选项, 但grep.vim这款插件调用的是grep命令, Win上没有grep, 怎么办?<br>后来找到了grep在Win平台的<a href="http://gnuwin32.sourceforge.net/" target="_blank" rel="noopener">移植版: GnuWin</a><br>相关设置选项参考这里: <a href="http://www.vim.org/scripts/script.php?script_id=311" target="_blank" rel="noopener">grep.vim : Grep search tools integration with Vim </a>, 在页面上搜索”MS-Windows”就可以看到for Windows的特殊选项.<br>不过,移植版的grep也有很多兼容问题, 略过不表233<br>什么, 你问我为什么不早说, 因为我一写博客就容易啰嗦…<br>好吧. 接下来说另一种使用vimgrep的方案:</p><h2 id="使用-EasyGrep"><a href="#使用-EasyGrep" class="headerlink" title="使用 EasyGrep"></a>使用 EasyGrep</h2><p>之前有过一篇介绍: <a href="http://zuyunfei.com/2013/08/25/vim-plugin-easy-grep/" target="_blank" rel="noopener">vim中的杀手级插件: EasyGrep</a>,<br>EasyGrep使用的是vim内置的搜索命令vimgrep, 相比上面说的移植版grep, vimgrep 在Win上兼容性要大大好于上面的grep移植版.<br>不过EasyGrep提供了一个比较友好的搜索选项界面, 就像下面这个样子, 调整搜索选项是不是要比grep.vim直观许多?<br><img src="https://cloud.githubusercontent.com/assets/2375604/9804914/d0c39ff0-5800-11e5-8e7d-b77543bf2dcf.gif" alt="EasyGrep Options"><br>vimgrep的最大问题是搜索效率, 真的很差, 尤其你要搜索的目录里有成百上千的文件时.<br>这时候可以切到Chrome里刷一会知乎…<br>但刷完知乎后却发现vimgrep仍旧在努力的转动你的硬盘… 所以我又放弃了EasyGrep.</p><h2 id="使用-findstr-vim"><a href="#使用-findstr-vim" class="headerlink" title="使用 findstr.vim"></a>使用 findstr.vim</h2><p>Windows下提供了一个原生命令<code>findstr</code>, 相当于Linux下的grep.<br>如果你想了解一下findstr命令的使用姿势, 可以看这里: <a href="https://technet.microsoft.com/en-us/library/bb490907.aspx" target="_blank" rel="noopener">Findstr - TechNet - Microsoft</a><br>在vim.org上也找了一个为findstr写的插件 – <a href="http://www.vim.org/scripts/script.php?script_id=1575" target="_blank" rel="noopener">findstr.vim : Using MS-Windows findstr utility to search for text with Vim </a><br>看来在Windows上用Vim的可怜人儿还不少, 我觉得这款插件的作者就是一个:(<br>不过这插件简直可算得上朴素, 只提供了四个插件命令, 我觉得跟手动敲findstr命令行效率差不多, 可是我懒且健忘, 记不住这么多findstr参数,<br>等等, 刚才聊到的EasyGrep的搜索选项界面不是挺方便的嘛, 所以, 为什么不能把EasyGrep的搜索界面搬到findstr.vim上来?<br>恩, 对于程序员来说这并不难, vimscript似乎有些像shell和php的结合语言. 所以…</p><h2 id="改进后的findstr-vim"><a href="#改进后的findstr-vim" class="headerlink" title="改进后的findstr.vim"></a>改进后的findstr.vim</h2><p>靠着google和勤勉的copy, 一个带有良好人机交互的多功能<code>findstr.vim</code>被提交到了github上(666)<br>Github repository在这里: <a href="https://github.com/whatrtos/findstr.vim" target="_blank" rel="noopener">https://github.com/whatrtos/findstr.vim</a><br><img src="https://raw.githubusercontent.com/whatrtos/findstr.vim/test/screenshot.png" alt="findstr"></p><p>在vimrc里新增一行配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap &lt;leader&gt;gg :VimFindstr&lt;CR&gt;</span><br></pre></td></tr></table></figure></p><p>这样, 在普通模式按下<code>\gg</code>就可以愉快的使用findstr了.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://zuyunfei.com/2013/08/25/vim-plugin-easy-grep/" target="_blank" rel="noopener">vim中的杀手级插件: EasyGrep</a></li><li><a href="http://vim.wikia.com/wiki/Find_in_files_within_Vim" target="_blank" rel="noopener">Find in files within Vim</a></li></ul><h1 id="附-vimgrep命令"><a href="#附-vimgrep命令" class="headerlink" title="附: vimgrep命令"></a>附: vimgrep命令</h1><p>vimgrep命令格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimgrep /搜索字符串/gj 文件</span><br></pre></td></tr></table></figure></p><p>上面的<code>g</code>和<code>j</code>参数都是可选的,</p><ul><li>/g : 加上g参数的话, 如果一行有多个匹配, 那么这些匹配会都出现在搜索结果里, 所以一般不用加<code>/g</code>参数;</li><li>/j : 如果不加j参数, 执行完vimgrep会自动跳转到第一个匹配处, 所以一般都会加上<code>/j</code>参数;</li></ul><p>比如<code>vimgrep /keyword/j *.php</code>表示仅在当前目录下的所有php文件里搜索”keyword”, 且不自动跳转到搜索结果.<br>如果也要在子目录递归搜索, <code>**</code>表示在当前目录以及子目录递归, 比如<code>**/*.php</code></p><p>一些栗子:</p><ul><li>当前目录下递归搜索: <code>vimgrep /字符串/j **/*.php</code></li><li>仅当前目录, 不递归: <code>vimgrep /字符串/g *.php</code></li><li>如果要搜索多个文件扩展名, 用空格分开即可: <code>vimgrep /字符串/j **/*.cpp **/*.php</code></li><li>Linux绝对路径, 递归搜索: <code>vimgrep /字符串/j /home/user/**/*.cpp</code></li><li>Win绝对路径, 递归搜索: <code>vimgrep /字符串/j D:\home\user/**/*.cpp</code></li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>@2016-08-01 发现一个问题, findstr.vim试用的是<code>system(cmd)</code>来执行findstr命令, 正常情况下这是没什么问题的, 但当遇到中文目录的时候, <code>system</code>执行的结果中的中文会变成”<3b><4a>“这样的代码. 所以搜索在中文目录会很蛋疼, 在quickfix里跳转不到正确的文件.<br>折中的办法是, 插件新增一个选项, 可以在使用findstr和vimgrep之间切换(最终还是没能摆脱vimgrep), 一般情况下推荐使用效率更高的findstr, 只有当遇到上面的问题时才使用”slowly but compatible”的vimgrep.</4a></3b></p><p>findstr迭代了几个版本, 修改了一些bug和改进易用性, 欢迎fork, 提交pr和issue:)</p><hr><blockquote><p>讲一个笑话, 从前森林里有只猴子, 为了能更方便的吃到樱桃, 所以这只猴子自己种了一棵樱桃树.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> Vim </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkEditor使用体验</title>
      <link href="/50.Farbox-Blog/%E3%80%90Markdown%E3%80%91MarkEditor%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
      <url>/50.Farbox-Blog/%E3%80%90Markdown%E3%80%91MarkEditor%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2016-07-28/sublime_dropbox2.jpg" alt="sublime+dropbox"></p><p>一直用<code>Sublime + Dropbox</code>的组合来写Markdown笔记. 这个组合看起来有点怪异,<br><strong>Sublime</strong>是使用体验最好的编辑器(安装了MarkdownEditting和MarkdownPreview插件),<br><strong>Dropbox</strong>是使用体验最好的同步工具,<br>但”最佳编辑器”+”最佳同步工具”的组合并非那样无懈可击.<br>相比Evernote,有道云笔记, Sublime+Dropbox的组合在移动端阅读和检索略有不便, 但同步速度和编辑体验简直甩大象有道这两位”全职笔记”几条街.</p><p>试用了farbox.com推出的markdown编辑器–<a href="http://markeditor.farbox.com/" target="_blank" rel="noopener">MarkEditor</a>使用体验非常棒, 几乎是我使用过的最好的markdown编辑器</p><ul><li>支持工作目录和标签, 对于我这种经常要在多个Markdown笔记来回切换的人来说, 非常方便.</li><li>漂亮的语法高亮.</li><li>方便的TOC导航侧边栏</li><li>图片管理</li></ul><p>但也有一些Bug和功能上的不完备, 这也是让我最终决定暂不购买<a href="http://markeditor.farbox.com/" target="_blank" rel="noopener">MarkEditor</a>付费版的原因:</p><ul><li>在日间/夜间模式切换, 光标君偶尔会消失, 没了闪烁的光标君我真不知道写到哪儿了</li><li>缺少整个目录的搜索功能;</li><li>偶然的卡顿;</li></ul><p>所以, 还是继续用<code>Sublime+Dropbox</code>写笔记吧😁</p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于闪光灯你应该知道的一些事</title>
      <link href="/53.Photograph/%E5%85%B3%E4%BA%8E%E9%97%AA%E5%85%89%E7%81%AF%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
      <url>/53.Photograph/%E5%85%B3%E4%BA%8E%E9%97%AA%E5%85%89%E7%81%AF%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-快门的前帘与后帘"><a href="#一-快门的前帘与后帘" class="headerlink" title="(一) 快门的前帘与后帘"></a>(一) 快门的前帘与后帘</h2><p>单反上的快门都属于<code>焦平面快门</code>(区别镜间快门)，了解闪光同步速度之前，要先了解单反的快门的工作原理。<br>快门的机械部件最高可以在1/200秒内扫过整个感光元件 ，这个1/200s大概是目前单反的快门的极限，也叫<code>闪光同步速度</code>。<br>所以，<code>闪光同步速度</code>是<strong>单反机身的</strong>性能参数，而不是闪光灯的性能参数。<br>如果单反的同步速度只有1/200秒，那么如若需要更高速度的快门，比如1/4000或更高的快门速度，应该如何实现呢?</p><p>如果把快门做成一条狭缝，这个狭缝扫过整个感光元件需要1/200秒，感光元件上每行像素点受到光照时间就可以做到小于1/200秒了，只要狭缝做的足够窄，也可以实现1/4000秒的高速快门。<br>焦平面快门有两个门帘，第一个门帘先移动，第二门帘立刻跟上，就相当于上面的”狭缝”了。</p><p>假设机身的快门机械部分扫过整个CMOS的最短需要1/200秒，那么低于1/200的快门速度，我们称之为”低速快门”，高于1/200的快门就需要以前后帘以”狭缝”的方式实现，也叫”高速快门”。</p><ul><li><code>低速快门</code>：前帘落下，快门完全打开，CMOS完全曝光，然后后帘落下。</li><li><code>高速快门</code>：前帘落下，后帘立刻跟上，前后帘之间只有一条狭缝，相当于光线通过狭缝，从上至下扫描过CMOS，这整个扫描过程大约是1/200秒。这里的1/200秒就是单反机身的闪光同步速度。</li></ul><p>图1：低速（左）和高速快门（右）示意图:<br><img src="/images/摄影/fastshutteranimation.gif" alt="图1"></p><p>图2：看个更直观的不同快门速度拍摄过程的示意图（第一行的是高速快门，第二行是低速快门）：<br><img src="/images/摄影/10-54-15.jpg" alt="图2"></p><p>了解了单反的闪光同步速度，我们再聊闪光系统。</p><h2 id="二-闪光灯的特性"><a href="#二-闪光灯的特性" class="headerlink" title="(二) 闪光灯的特性"></a>(二) 闪光灯的特性</h2><p>闪光灯并不是一瞬间就能达到最高亮度的，电容充放电需要时间，来看下图中闪光强度和时间的关系，下图中纵坐标是闪光强度，横坐标是持续时间，大约为<strong>1/1000秒</strong>数量级，远远小于快门的1/200秒 ：</p><p><img src="/images/摄影/10-56-54.jpg" alt="Image"></p><blockquote><p>我们在使用闪光灯时经常接触到的一个参数: <code>闪光持续时间（T=0.5）</code><br>T=1的时候闪光灯达到最大亮度，T=0.5被称作<code>半峰值</code>。<br>纵坐标第二次到达T=0.5光强度时所需时间，即被称作<code>闪光持续时间（T=0.5）</code>。<br>但是要注意，上面的“闪光持续时间”并不是真正的闪光持续时间，从上图可以看到第二次T=0.5之后，还有相当的光照强度，直到T=0.1剩下的光量才忽略不计。这段时间大约为3倍闪光持续时间（T=0.5）</p></blockquote><p>除了强度上的波形变化，闪光的色温也在随电流能力的高低发生着漂移。所有的闪光灯会在闪光开始的瞬间产生色温相对高的蓝色光，转而是色温低的红色光。<br>高色温是短波蓝光偏多，低色温则反之。若一只闪光灯的闪光持续时间（T=0.5） 整体超越了快门时间（假设快门为1/200），后期的低色温便不能进入相机曝光，闪光在整体上就出现了色温偏高（冷）的现象。</p><h2 id="三-闪光灯和快门速度的关系"><a href="#三-闪光灯和快门速度的关系" class="headerlink" title="(三) 闪光灯和快门速度的关系"></a>(三) 闪光灯和快门速度的关系</h2><p>上面了解到，单反无论使用低速快门还是高速快门，整个过程都不会小于1/200秒，也就是机械部分的极限。<br>但是要知道，闪光灯发光的持续时间是很短的，大约为1/1000秒。试想一下，如果闪光持续时间不够1/200秒就结束了，机械狭缝还没来得及走完整个感光元件，会导致什么样的情况？</p><p>比如下图：<br><img src="/images/摄影/10-54-36.jpg" alt="Image"><br>左边两张，快门速度低于1/200秒的情况下，整个画面都能被闪光灯打亮。<br>当快门速度高于1/200以后（右边几张更明显），会出现黑色的欠曝区域。在前帘刚刚打开，狭缝刚刚通过CMOS最左的时候，闪光灯开始闪光，画面左侧被打亮，然后闪光灯结束，剩下的右半边CMOS都没有被闪光灯打到，所以是黑色。</p><h2 id="四-闪光灯的高速同步"><a href="#四-闪光灯的高速同步" class="headerlink" title="(四) 闪光灯的高速同步"></a>(四) 闪光灯的高速同步</h2><p>如果要使用高速快门，又要闪光灯把整个CMOS区域都照亮，这里就要用到闪光灯的<code>高速同步模式</code>，注意区别上面的“闪光同步速度”。<br><code>闪光高速同步</code>指的是，前后帘运行期间这1/200秒内，闪光灯以每秒5W次的频率高速闪光，直至后帘完全关闭。</p><p>闪光灯正常模式和高速同步的工作模式如下图所示</p><p><img src="/images/摄影/10-55-06.jpg" alt="Image"></p><p>以上图为例：<br>上面一组是低于1/200快门速度的正常闪光模式。<br>下面一组是闪光灯的高速同步模式，闪光灯发出高频闪光，在快门狭缝扫过整个CMOS期间一直频闪，使整个CMOS都被照亮。<br>因为高频闪光的强度远低于瞬间闪光，所以高速同步模式下闪光强度非常小，远不如第一种普通闪光。</p><blockquote><p>闪光灯高速同步最常见的作用，比如在大晴天的正午下拍摄大光圈的糖水片，这种情况下光线非常充足，又要使用大光圈拍摄（获得浅景深的虚化效果），快门速度会非常快，大约1/4000秒，这个速度高于闪光同步速度（1/200秒），这时候就需要闪光灯的高速同步来补光。</p></blockquote><p>来举个例子：例如一张照片的正确曝光值为：ISO 100， F16， 1/125秒， 闪灯TTL自动补光。如果我们想要得到一定的背景虚化效果，我们可以使用高速同步，将参数设置为: ISO 100， F2.8， 1/4000秒，闪光灯TTL高速模式进行补光。 这时将得到一个正常曝光背景虚化的画面。<br><img src="/images/摄影/HSS-MEDSB-Horiz-200h.jpg" alt="hss"></p><p>注意上面最右边的一张，这张图片非常有意思，明明是在晴朗的户外拍摄，但是背景显得非常昏暗，看起来像是夜晚。<br>如果拍出了这样的照片一定不要惊奇，这是因为你的快门速度太快了，环境光不足以正常曝光，所以背景显得昏暗，但是拍摄主体被闪光灯打亮，所以得到一张背景欠曝，主体正常曝光的图片，这也就是常说的用闪光灯进行“压光”。</p><p>所以，关于闪光灯的高速同步，不具备高速同步的闪光灯快门速度一般只能上到200-250的样子，而具备此功能的闪光灯可以同步快门速度至4000-8000甚至更高。</p><h2 id="五-使用闪光灯拍摄高速运动的物体"><a href="#五-使用闪光灯拍摄高速运动的物体" class="headerlink" title="(五) 使用闪光灯拍摄高速运动的物体"></a>(五) 使用闪光灯拍摄高速运动的物体</h2><p>这种情况下真的不能用<code>高速同步（HSS）</code>了，而要使用闪光灯的<code>高速闪光</code>模式，<br>这种情况下，闪光灯要作为主光源，闪光灯在千分之一秒内完成闪光，闪光的一瞬间水滴被照亮，这样运动的物体就被“凝固”了下来。<br>并且快门速度不能高于1/200秒（相机的闪光同步速度），否则画面边缘会出现未被照亮的黑边。<br>同时要达到暗背景的效果，要使用小光圈和低ISO，闪光灯完全可以把环境光线压下去，并且水滴是正常曝光的。<br>给出一组参考值：ISO 100，F16，320秒。所以，使用闪光灯的情况下拍摄高速运动的物体，并不一定需要1/8000这样的高速快门，而是用“慢速快门”+“闪光灯作为主光源”</p><p><img src="/images/摄影/10-56-55.jpg" alt="使用闪光灯凝固水滴"></p><h2 id="六-闪光灯的前帘同步和后帘同步"><a href="#六-闪光灯的前帘同步和后帘同步" class="headerlink" title="(六) 闪光灯的前帘同步和后帘同步"></a>(六) 闪光灯的前帘同步和后帘同步</h2><p><code>前帘同步</code>就是指前帘打开的瞬间开始闪光，<code>后帘同步</code>就是后帘快要关闭之前开始闪光。<br>简单粗暴的举个栗子，假设闪光灯能持续1s，设置10s的快门，前帘同步就是第一秒闪，后帘同步就是最后一秒闪。<br>前帘同步和后帘同步都属于<strong>慢门同步</strong>, 快门速度都低于1/200秒（单反的同步速度），所以前后帘同步只能在夜间或者光线较差的情况下使用，这时候闪光灯是作为主光源。<br><img src="/images/摄影/10-54-49.jpg" alt="Image"></p><p>如果被摄物体在运动，采用前帘同步会使物体的初始位置被照亮，留下清晰的影响，之后移动的轨迹由于曝光不够形成虚影。如果采用后帘同步则正好相反，物体前面移动的轨迹由于曝光不足形成虚影，在最后的位置被照亮，形成清晰的影像，如下图所示：</p><p><img src="/images/摄影/10-54-55.jpg" alt="Image"></p><p>如果快门速度低于闪光同步速度，比如夜间拍摄时快门大约1/100秒，这个时候快门不是狭缝的，而是整个CMOS完全打开曝光，这个时候应该选择后帘同步，闪光持续时间在整个CMOS在完全打开状态下。<br>如果快门速度高于闪光同步速度，比如白天的逆光拍摄大约1/2000秒快门，这时候快门会以狭缝的方式扫过CMOS，这个时候应该怎么办？</p><h2 id="选购闪光灯时应该注意的参数"><a href="#选购闪光灯时应该注意的参数" class="headerlink" title="选购闪光灯时应该注意的参数"></a>选购闪光灯时应该注意的参数</h2><ul><li>TTL功能：通过镜头测量曝光方式自动控制闪光灯功率，打开TTL的闪光过程是2次闪光的过程。第一次，闪光灯预闪一下，预闪的光线照射到被摄物体上，反射回来进入相机。相机的感光元件根据反摄回的光线经过复杂的计算，输出一个指令给闪光灯，闪光灯调整自己的输出强度在闪一次。这一次才是真正的曝光。</li><li>高速同步：可以理解为在大太阳下快门速度可以超过1/160或者1/200，比如4000-8000的快门速度（机顶普通闪光灯快门超过1/160或者1/200就没法闪光了），常用的场景是大光圈在大逆光下补光。</li><li>闪光指数：简称GN，闪光灯的功率，越大越好，但也越贵。<code>闪光指数 = 摄距 x 光圈</code>，GN也不能单单只看数值的大小，因为闪光指数还要说明焦距和ISO，比如尼康SB-800的闪光指数标着53，实际是”53@85mm ISO 100”，如果在35mm镜头下，GN就变成了38，这是因为越广的镜头要求闪光灯散射面积越大，强度也降低了。</li></ul><h2 id="闪光灯的其他知识tips"><a href="#闪光灯的其他知识tips" class="headerlink" title="闪光灯的其他知识tips"></a>闪光灯的其他知识tips</h2><ul><li>前帘同步和后帘同步，如果快门够快，拍摄的主体不动，那么拍出来的效果没有什么区别。换句话说，后帘同步总是和慢速快门一起使用的，主体应该是运动中（或者相机晃动），前后帘同步的情况下闪光灯是作为主光源的。</li><li>用闪光灯可以极大提高进光量，提高快门速度，这样就可以拍摄凝固水滴这种高速运动，当然这种情况下你不能用高速同步闪光，因为功率太低不够亮。</li><li>如果在电灯下拍摄，照片很容易呈现偏黄、红色的暖色调，因为钨丝灯的色温低，而加用闪光灯，就可以有效地调整色温，使被摄物色彩正确还原。</li><li>高速同步的意义在于，可以在光线强烈的环境下，使用大光圈拍摄出浅景深的效果，这时候闪光灯不是作为主光源，而是用来给主体补光。</li><li>如果在晴天环境下使用大光圈，最好是使用中性密度滤镜，这样可以不必使用高速闪光模式。</li><li>能不用高速闪光同步就不用，因为此模式下闪光灯浪费太多能量。特别是，不要想用高速闪光同步来克服较硬的日光，这做不到，因为在高速闪光同步模式下闪光灯的功率是很低的，用大功率外拍灯吧。</li><li>在明亮环境下使用闪光灯，可以设置快门速度在最高闪光同步速度或略微比最高闪光同步速度慢一点，这样能发挥闪光灯的最大效率。这是因为更慢的快门速度意味着使用更小的光圈，而更小的光圈导致闪光灯的有效照明距离的更短（闪光指数＝光圈值×照明距离）。</li><li>如果没有保护措施，连续使用1/1闪光能把某些闪光灯的灯头透镜（塑料）烧到局部熔化。</li><li>关于指数（GN）：不要只看GN的数值，还要看他的测试条件，同一只灯，如果它的灯头能变焦，在长焦端的指数就比广角端要大。按ISO200来测试也比ISO100测试的数值大</li></ul><h2 id="闪光灯使用入门"><a href="#闪光灯使用入门" class="headerlink" title="闪光灯使用入门"></a>闪光灯使用入门</h2><ul><li>一盏灯的时候，那么闪光灯尽量作为补充光源来使用的，主光一定是环境光。这种闪光方式叫做填充闪光。</li><li>填充闪光：先测量环境光线,比如现场光线iso1600 f2.8 1/60,这是个常见的室内拍摄环境。在这个基础上不做锁定曝光。用外闪在这个基础进行-1档TTL闪光。基本就是填充闪光了。-1档经验习惯。让闪光痕迹尽量减少些。填充闪光的原则就是一定要兼顾现场光线，闪光灯只是为了对暗部进行轻微的补光。</li><li>平衡闪光是闪光将照亮主体使其达到背景光的水平。这种方法应用于如下情况：主体处于阴影中，并且/或者背景非常明亮。使用闪光灯让主体的光与环境光平衡。</li><li>完全闪光：完全闪光通常用在室内狭小空间内，光线非常差的情况下。这种情况也不能使用直接闪光的方式，而应使用常用的“跳灯”</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www2.xitek.com/info/showarticle.php?id=1082" target="_blank" rel="noopener">关于电子闪光灯的一些概念 - 色影无忌文章</a></li><li><a href="http://post.smzdm.com/p/40732/" target="_blank" rel="noopener">职业摄影师永远不会告诉你的拍摄技巧 篇三：闪光灯拍摄技巧</a></li><li><a href="http://www.56.com/u84/v_NTc2MzYxMTM.html#fromoutpvid=NTc2MzYxMTM" target="_blank" rel="noopener">NIKON.SCHOOL-Guide-to-Creative-Lighting 摄影闪光教程</a></li><li><a href="http://www.56.com/u78/v_NjY1MzI0Njc.html#fromoutpvid=NjY1MzI0Njc" target="_blank" rel="noopener">大卫·豪比《逐层布光》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 闪光灯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Windows 和 macOS 之间同步 Sublime 配置文件</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%E5%9C%A8Windows%E5%92%8COSX%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5Sublime%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91%E5%9C%A8Windows%E5%92%8COSX%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5Sublime%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>下面介绍如何把Windows上的Sublime设置同步到OSX</p><h3 id="Windows设置"><a href="#Windows设置" class="headerlink" title="Windows设置"></a>Windows设置</h3><ul><li>关闭Sublime;</li><li>以administrator打开PowerShell, 输入以下命令:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &quot;%appdata%\Sublime Text 3\Packages\&quot;</span><br><span class="line">mkdir &apos;X:\Dropbox\SublimeText3&apos;</span><br><span class="line">mv User &apos;X:\Dropbox\SublimeText3\&apos;</span><br><span class="line">cmd /c mklink /D User &quot;X:\Dropbox\SublimeText3\User&quot;</span><br></pre></td></tr></table></figure><p>注意, 根据情况替换上面的<code>X:\Dropbox\SublimeText3</code>路径;<br>第三行<code>mv</code>命令只能在相同盘符的目录之间移动, 如果你的Dropbox同步目录不是在C盘, 手动打开<code>%AppData%\Sublime Text 3\Packages\\</code>, 把下面的User目录移动到Dropbox同步目录中.</p><h3 id="OSX设置"><a href="#OSX设置" class="headerlink" title="OSX设置"></a>OSX设置</h3><ul><li>关闭Sublime;</li><li>打开终端, 输入以下命令:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/</span><br><span class="line">mv User User.deprecated</span><br><span class="line">ln -s ~/Dropbox/SublimeText3/User User</span><br></pre></td></tr></table></figure><p>根据情况替换上面的<code>~/Dropbox/SublimeText3</code>路径.</p><p>请确保OSX上也安装了Sublime设置中引用的字体.</p><h3 id="关于User目录下的文件"><a href="#关于User目录下的文件" class="headerlink" title="关于User目录下的文件"></a>关于User目录下的文件</h3><ul><li><code>User/Package Control.sublime-settings</code>: Package Control的配置文件, 安装的所有插件列表;</li><li><code>User/Preferences.sublime-settings</code>: Sublime text的一般配置;</li></ul><h3 id="一些bug的解决方法"><a href="#一些bug的解决方法" class="headerlink" title="一些bug的解决方法"></a>一些bug的解决方法</h3><ul><li><a href="https://github.com/wbond/package_control/issues/1075" target="_blank" rel="noopener">每次打开sublime弹出提示”the following incompatible dependency was found installed: user”</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> OSX </tag>
            
            <tag> macOS </tag>
            
            <tag> Sublime </tag>
            
            <tag> Dropbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影笔记</title>
      <link href="/53.Photograph/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/"/>
      <url>/53.Photograph/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="色调"><a href="#色调" class="headerlink" title="色调"></a>色调</h2><ul><li><a href="http://vod.sjtu.edu.cn/help/Article_Show.asp?ArticleID=1622" target="_blank" rel="noopener">色彩系列教程(2)：色系和色调</a><br>色调指的是一幅画中画面色彩的总体倾向, 色调指的是一幅画中画面色彩的总体倾向.<br>比如这样的画面: 不同颜色的物体或被笼罩在一片金色的阳光之中, 或被笼罩在一片轻纱薄雾似的、淡蓝色的月色之中;或被秋天迷人的金黄色所笼罩; 或被统一在冬季银白色的世界之中.<br>这种在不同颜色的物体上, 笼罩着某一种色彩, 使不同颜色的物体都带有同一色彩倾向, 这样的色彩现象就是色调.</li></ul><h2 id="色温"><a href="#色温" class="headerlink" title="色温"></a>色温</h2><h3 id="自然界的色温"><a href="#自然界的色温" class="headerlink" title="自然界的色温"></a>自然界的色温</h3><p>色温的单位是K(开耳文), K值越高色温越高. 色温越高表现为画面偏冷; 色温越低画面偏暖.</p><h4 id="自然界常见的色温表"><a href="#自然界常见的色温表" class="headerlink" title="自然界常见的色温表"></a>自然界常见的色温表</h4><ul><li>蜡烛光: 1000K, 暖色</li><li>钨丝灯: 2000K, 暖色</li><li>朝阳夕阳: 3000K, 暖色</li><li>闪光灯: 5000K</li><li>晴天阳光: 5600K</li><li>阴天: 6000K+, 冷</li><li>晴天时阴影: 7000K, 冷</li><li>雪天: 10000K, 冷</li></ul><h3 id="单反的色温标准"><a href="#单反的色温标准" class="headerlink" title="单反的色温标准"></a>单反的色温标准</h3><p>单反里使用哪个场景, 就是”弥补”该场景下的色温. 比如在单反的”钨丝灯”模式下, 拍出的画面实际是偏冷的, 为了中和钨丝灯的暖色.</p><h4 id="K值"><a href="#K值" class="headerlink" title="K值"></a>K值</h4><p>单反里的K值, 与自然界色温标准是”相反”的, 比如选择10000k的K值, 画面实际是偏暖, 为了中和自然界10000K色温场景下(晴空)的冷色.</p><hr><h1 id="后期-Lightroom"><a href="#后期-Lightroom" class="headerlink" title="后期(Lightroom)"></a>后期(Lightroom)</h1><p><img src="https://helpx.adobe.com/content/dam/help/en/lightroom/help/applying-adjustments-develop-module-basic/_jcr_content/main-pars/image_0/wf_devmodule_1000.png" alt="lr"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>对比原始和修改后: /</li><li>分栏显示修改前后照片: Y</li><li>进入”修改照片”模式: D</li><li>进入”图库”模式: G</li><li>全屏显示: F</li></ul><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>直方图左端表示明亮度为 0% 的像素, 右端表示明亮度为 100% 的像素.<br>直方图由三个颜色层组成, 分别表示红色、绿色和蓝色通道.<br>这三个通道发生重叠时将显示灰色；RGB 通道中任两者发生重叠时, 将显示黄色、洋红或青色：黄色相当于“红色”+“绿色”通道, 洋红相当于“红色”+“蓝色”通道, 而青色则相当于“绿色”+“蓝色”通道.</p><h3 id="直方图”剪切”的概念"><a href="#直方图”剪切”的概念" class="headerlink" title="直方图”剪切”的概念"></a>直方图”剪切”的概念</h3><p>直方图左上和右上角各有一个三角按钮, 分别表示”黑色剪切”和”白色剪切”, 这里以黑色剪切为例:<br>点击左上角的”黑色剪切”按钮, 画面上将会把纯黑色的区域用蓝色色块标识出来, 当所有通道中均发生了剪切时, 指示器之一将呈白色. 如果剪切指示器呈彩色, 则表明剪切了一个或两个通道.<br>如果在按下”黑色剪切”后, 发现画面出现很多蓝色色块, 则说明欠曝区域太多.<br>白色剪切同上.<br>调整方法一般为: 调整高光, 让红色色块减少(过曝), 调整阴影, 让蓝色色块减少(欠曝)</p><h2 id="基本面板"><a href="#基本面板" class="headerlink" title="基本面板"></a>基本面板</h2><ul><li>白平衡: 吸管, 选择灰色部分(最好), 其次是黑/白</li><li>对比度: 白色更白, 黑色更黑</li><li>白色色阶: 调整画面浅色的部分, 类似高光, 其调整的范围比高光更大, 调整白色色阶会对整个画面影响</li><li>黑色色阶: 调整画面深色的部分, 类似阴影, 其调整的范围比阴影更大</li></ul><h2 id="色调曲线面板"><a href="#色调曲线面板" class="headerlink" title="色调曲线面板"></a>色调曲线面板</h2><p>面板<code>左上</code>有一个”在照片中拖动来调整色调曲线”, 比在曲线上调整更形象一点<br>面板<code>右下</code>有一个”点曲线”, 在曲线上设置锚点, 比”拉曲线”更精确. 有两个预设”中度对比”和”强度对比”</p><h2 id="HSL"><a href="#HSL" class="headerlink" title="HSL"></a>HSL</h2><ul><li>色相: 挑出你喜欢的预设, 观察他的HSL是怎么调的</li><li>饱和度: 原则: 颜色溢出的,降饱和, 非拍摄主体,降饱和</li><li>明亮度: 调整某个颜色的曝光, 比如蓝色负值可以拉蓝天, 也可以拉高阴影部位曝光, 类似阴影补偿.</li></ul><h2 id="色调分离面板"><a href="#色调分离面板" class="headerlink" title="色调分离面板"></a>色调分离面板</h2><p>分离色调是整体调色,而HSL是单独调色.</p><ul><li>经验: <a href="https://www.zhihu.com/question/27310858" target="_blank" rel="noopener">扫街作品</a> 高光增加黄色, 阴影增加蓝绿色, 制造”冷暖交替”的氛围, 然后HSL增加黄色饱和度</li></ul><h2 id="渐变滤镜"><a href="#渐变滤镜" class="headerlink" title="渐变滤镜"></a>渐变滤镜</h2><p>新建快捷键<code>M</code>, “反向蒙版”打勾可以选择滤镜范围(以内)</p><h2 id="径向滤镜"><a href="#径向滤镜" class="headerlink" title="径向滤镜"></a>径向滤镜</h2><p>新建快捷键<code>Shift+M</code>, “反向蒙版”打勾可以选择滤镜范围(以内)</p><h2 id="肤色调整"><a href="#肤色调整" class="headerlink" title="肤色调整"></a>肤色调整</h2><ol><li>HSL/颜色/黑白 提高组成肤色的红色和橙色的明亮度</li><li>降低橙色的饱和度</li><li>径向滤镜, 降低清晰度, 提曝光, 提高白色色阶</li></ol><h1 id="使用手机修图"><a href="#使用手机修图" class="headerlink" title="使用手机修图"></a>使用手机修图</h1><ul><li><a href="/53.Photograph/VSCO滤镜使用指南/" title="VSCO滤镜使用指南">VSCO滤镜使用指南</a></li></ul><hr><h1 id="拍摄技巧"><a href="#拍摄技巧" class="headerlink" title="拍摄技巧"></a>拍摄技巧</h1><h2 id="夜间人像"><a href="#夜间人像" class="headerlink" title="夜间人像"></a>夜间人像</h2><ul><li>后帘同步</li><li>背景正确曝光</li><li>缩小光圈,主体对焦</li></ul><h2 id="找机位"><a href="#找机位" class="headerlink" title="找机位"></a>找机位</h2><ul><li>北京爬楼党: <a href="http://cityclimbers.tuchong.com/" target="_blank" rel="noopener">http://cityclimbers.tuchong.com/</a></li><li>北京自然风光: <a href="https://beijingcity.tuchong.com/" target="_blank" rel="noopener">https://beijingcity.tuchong.com/</a></li><li>立交桥攻略: <a href="https://sramx9.tuchong.com/6077961/" target="_blank" rel="noopener">https://sramx9.tuchong.com/6077961/</a></li></ul><hr><h1 id="器材"><a href="#器材" class="headerlink" title="器材"></a>器材</h1><h2 id="镜头"><a href="#镜头" class="headerlink" title="镜头"></a>镜头</h2><p><img src="http://media.the-digital-picture.com/Images/Recommended-Lenses.jpg" alt="Canon Lens"></p><ul><li>佳能50mm f1.8 STM: <a href="http://www.irentals.cn/article.php?id=102" target="_blank" rel="noopener">兰拓科技 —— 佳能、尼康、索尼50（55）mm f/1.8镜头横评</a></li><li>适马50mm f1.8 EX: 光圈收到1.8可用, 5.6中心分辨率最佳, 参考<a href="http://www.dpreview.com/reviews/sigma-50-1p4-c16/5" target="_blank" rel="noopener">Sigma 50mm F1.4 EX DG HSM review</a></li><li>适马35mm f1.4 ART: <a href="http://www.irentals.cn/article.php?id=60" target="_blank" rel="noopener">兰拓科技 —— 35mm f/1.4规格自动镜头横评</a></li><li>佳能24-70mm f4 is: 参考<a href="http://digi.163.com/12/1231/06/8K1IEGC6001624J3_all.html" target="_blank" rel="noopener">微距+防抖 佳能24-70mm f4 IS镜头评测</a></li><li>佳能70-200mm f4 is: <a href="http://www.dxomark.com/Lenses/Canon/EF70-200mm-f-4L-IS-USM-mounted-on-Canon-EOS-5DS-R---Measurements__1009" target="_blank" rel="noopener">Canon EF 70-200mm f/4L IS USM mounted on Canon EOS 5DS R : Measurements</a></li></ul><h3 id="如何看镜头的MTF曲线图"><a href="#如何看镜头的MTF曲线图" class="headerlink" title="如何看镜头的MTF曲线图"></a>如何看镜头的MTF曲线图</h3><ul><li>横轴是距镜片中心的距离, x=0处是镜头中心的分辨率, x=20处是距离镜头中心20mm处的分辨率.</li><li>纵轴是分辨率高低, 越接近1画质越好.</li><li>10线/毫米和30线/毫米:  </li><li>MTF曲线中实线为S方向(水平)测得, 虚线为M方向(竖直)测得, 黑色曲线为最大光圈测得, 蓝色曲线为F8光圈测得, 粗线是空间频率为10线对/毫米时测得, 细线是空间频率为30线对/毫米时测得</li></ul><h3 id="MTF最佳光圈"><a href="#MTF最佳光圈" class="headerlink" title="MTF最佳光圈"></a>MTF最佳光圈</h3><ul><li>佳能50mm f1.8 STM:  光圈f5.6最好, 参考<a href="http://www.photozone.de/canon_eos_ff/905-canon_50_18stm?start=1" target="_blank" rel="noopener">这里</a></li></ul><p><img src="http://www.photozone.de/images/8Reviews/lenses/canon_50_18stm/mtf.png" alt="50f1.8stm"></p><ul><li>腾龙35mm f1.8 VC:  光圈f2.8最好, 参考<a href="http://www.photozone.de/canon_eos_ff/970-tamron35f18vc?start=1" target="_blank" rel="noopener">这里</a></li></ul><p><img src="http://www.photozone.de/images/8Reviews/lenses/tamron_35_18vc/mtf.png" alt="35f1.8"></p><ul><li>佳能24-70mm f4 is: 每个焦段(24mm,40mm,70mm)均是f5.6最好, 参考<a href="http://www.photozone.de/canon_eos_ff/798-canon2470f4?start=1" target="_blank" rel="noopener">这里</a></li></ul><p><img src="http://www.photozone.de/images/8Reviews/lenses/canon_2470_4/mtf.png" alt="2470f4"></p><ul><li>佳能70-200mm f4 is: 每个焦段(70mm,135mm,200mm)均是f5.6最好, 参考<a href="http://www.photozone.de/canon_eos_ff/431-canon_70200_4is_5d?start=1" target="_blank" rel="noopener">这里</a></li></ul><p><img src="http://www.photozone.de/images/8Reviews/lenses/canon_70200_4is_5d/mtf.gif" alt="70200f4"></p><h2 id="渣能EOS-5D3被忽视的菜单"><a href="#渣能EOS-5D3被忽视的菜单" class="headerlink" title="渣能EOS 5D3被忽视的菜单"></a>渣能EOS 5D3被忽视的菜单</h2><p>佳能5D mark iii是我目前使用的设备. 对焦性能基本继承了旗舰1DX还算好, 连拍6张/秒还不错, 高感还可以, 宽容度不太好, 像素偏低属于上一代水准, 没Wifi, 很重, 镜头很多.<br><img src="http://www.blogcdn.com/cn.engadget.com/media/2013/05/leaddsc09420-1332363400.jpg" alt="5d3"></p><ul><li>拍摄菜单4: 实时拍摄(使用液晶屏拍摄), 自动对焦模式<ul><li>实时模式: 相当于无反相机的反差式对焦, 但是5D3的反差式对焦特别慢, 能听到镜头里的镜组反复推移的声音.</li><li>人脸实时模式: 也是反差式对焦, 增加一个人脸识别.</li><li>快速模式: 实际是用反光板下面的对焦模块进行相位对焦, 也是我们最熟悉的单反的对焦模式, 第一次按下快门会放下反光板, 这时液晶屏黑屏并且对焦模块进行对焦, 保持按住快门才会进行拍摄, 所以会听到相机两次响声, 一次是反光板放下的声音一次是快门的声音. 这种模式的对焦速度快于第一种, 但是实际使用体验并不好, 一是拍摄期间液晶屏会黑一次, 二是要听到两次声音, 很多人都误以为第一次声音(反光板放下)时已经拍摄了, 进入照片预览发现并没有拍摄照片-__- 切记这个模式要响两次才算是拍摄完成.</li></ul></li><li>高ISO降噪: <code>SHOOT3</code> -&gt; <code>高ISO感光度降噪功能</code></li><li>关于”点测联动”: 5D3没有点测联动,  所以对焦点不在画面中央并且使用点测光的时候,  需要手动: 半按快门对被摄主体测光,  点<code>*</code>锁定曝光,  重新构图后拍摄.</li><li>曝光锁定键一直按住,  可以持续按快门拍摄.</li><li>包围曝光(AEB): <code>SHOOT2</code> -&gt; <code>曝光补偿/AEB</code>,  进入后用前拨轮选择包围步长(最小1/3EV).  如果开启了包围的同时也开启了连拍模式,  按下快门键会连拍三张后停止.  如果是单拍,  需要按快门三次生成三张不同曝光的图片.  开启包围后,  在曝光标尺上有三个标记(注意).  </li><li>白平衡包围(WB-BKT): <code>SHOOT2</code> -&gt; <code>白平衡偏移/包围</code>: 打开后,  按一次快门会生成三张不同白平衡的照片,  连拍数量会减少</li><li>焦距包围(景深合成): 5D3没有,  貌似只有奥林巴斯EM1和EM5ii有这种功能,  微距爱好者福音.  </li></ul><ul><li>以上几种包围拍摄选项均没有快捷按键,  需要进入几层菜单设置,  叹气5D3完全不是专业机身.</li></ul><ul><li>HDR: <code>SHOOT3</code> -&gt; <code>HDR模式</code> ,  <code>自动对齐图像</code>仅在手持时打开,  使用三脚架时关闭此选项.</li></ul><ul><li>HDR的局限性: 不能拍摄移动物体,  快门速度不能过慢,  不能使用闪光灯,  无法在曝光包围,  WB包围的情况下使用</li></ul><ul><li>多重曝光: 待补充</li><li>闪光灯: 待补充</li><li>自定义拍摄模式C1: 追焦连拍(伺服自动, 61点, 连拍H, 快门优先1/500起, 评价测光, 画质L),  记录空间<strong>需要手动调整到CF卡</strong>,  如果设置为SD卡会拖慢连拍速度.</li><li>自定义拍摄模式C2: 待补充</li></ul><h2 id="器材评测"><a href="#器材评测" class="headerlink" title="器材评测"></a>器材评测</h2><ul><li><a href="http://www.dpreview.com/reviews/image-comparison?attr18=daylight&amp;attr13_0=oly_em5ii&amp;attr13_1=fujifilm_xt10&amp;attr13_2=sony_a6000&amp;attr13_3=sony_a7_ii&amp;attr15_0=jpeg&amp;attr15_1=jpeg&amp;attr15_2=jpeg&amp;attr15_3=jpeg&amp;attr16_0=200&amp;attr16_1=200&amp;attr16_2=200&amp;attr16_3=200&amp;attr126_0=normal&amp;attr171_3=off&amp;normalization=full&amp;widget=1&amp;x=0.3382667194301544&amp;y=-0.35447226313205704" target="_blank" rel="noopener">dpreview样张比较(EM5ii/XT10/A6000/A7)</a></li><li><a href="http://www.dpreview.com/reviews/image-comparison?attr18=daylight&amp;attr13_0=canon_eos5dmkiii&amp;attr13_1=nikon_d810&amp;attr13_2=nikon_d750&amp;attr13_3=sony_a7rii&amp;attr15_0=jpeg&amp;attr15_1=jpeg&amp;attr15_2=jpeg&amp;attr15_3=jpeg&amp;attr16_0=200&amp;attr16_1=200&amp;attr16_2=100&amp;attr16_3=200&amp;attr126_0=normal&amp;attr126_2=highres&amp;attr171_3=off&amp;normalization=full&amp;widget=1&amp;x=0.12899742005159887&amp;y=-0.9824897064088793" target="_blank" rel="noopener">样张比较(5D3/D810/D750/A7R2)</a></li><li><a href="http://www.irentals.cn/article.php?id=100" target="_blank" rel="noopener">兰拓科技_佳能、尼康、索尼（FE）24-70mm f/2.8镜头横评</a></li><li><a href="http://www.irentals.cn/article.php?id=101" target="_blank" rel="noopener">兰拓科技_佳能1DX2 vs 尼康D5全面测评</a></li><li><a href="http://xjrumo.com/2016/07/28/canon-eos-1d-x-mark-ii-dpreview-conclusion/" target="_blank" rel="noopener">相机入魔_佳能EOS 1D X Mark II DPReview测评结论</a></li></ul><h2 id="M43镜头选择"><a href="#M43镜头选择" class="headerlink" title="M43镜头选择"></a>M43镜头选择</h2><p>没错我还玩M43…<br><img src="http://photorumors.com/wp-content/uploads/2016/01/olympus-mft-lenses.jpg" alt="zuiko"></p><ul><li><a href="https://www.zhihu.com/question/28286943" target="_blank" rel="noopener">M4/3镜头群有哪些值得买的？</a></li><li><a href="http://www.chiphell.com/thread-291646-1-1.html" target="_blank" rel="noopener">M43党福利镜头群总结以及简单点评</a></li></ul><h2 id="相机说明书"><a href="#相机说明书" class="headerlink" title="相机说明书"></a>相机说明书</h2><ul><li><a href="/53.Photograph/相机manual.索尼α7m3/" title="相机manual.索尼α7m3">相机manual.索尼α7m3</a></li><li><a href="/53.Photograph/相机manual.富士X100F/" title="相机manual.富士X100F">相机manual.富士X100F</a></li><li><a href="/53.Photograph/相机manual.TT350s闪光灯/" title="相机manual.TT350s闪光灯">相机manual.TT350s闪光灯</a></li></ul><h1 id="胶片摄影"><a href="#胶片摄影" class="headerlink" title="胶片摄影"></a>胶片摄影</h1><ul><li><a href="/53.Photograph/film.宾得SPII使用手册/" title="film.宾得SPII使用手册">film.宾得SPII使用手册</a></li><li><a href="/53.Photograph/film.胶片测光经验表/" title="film.胶片测光经验表">film.胶片测光经验表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 53.Photograph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cygwin食用指南</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91Cygwin%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91Cygwin%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="国内镜像"><a href="#国内镜像" class="headerlink" title="国内镜像"></a>国内镜像</h1><p>网易: <a href="http://mirrors.163.com/.help/cygwin.html" target="_blank" rel="noopener">http://mirrors.163.com/.help/cygwin.html</a></p><h1 id="选择的包"><a href="#选择的包" class="headerlink" title="选择的包"></a>选择的包</h1><ul><li>Archive: bzip2 p7zip zip</li><li>Base: 全选</li><li>Devel: autoconf automake cmake cvs cscope ctags git gdb make</li><li>Editor: vim vim-common</li><li>Interpreters: php php-devel python</li><li>Net: curl openssl ping putty openssh</li><li>Web: wget</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>安装完成Cygwin之后, 如果想要再安装新软件, 可以使用官网下载的<code>setup-x86.exe</code>, 命令: <code>setup-x86.exe -q -P packagename1,packagename2</code></li><li>选择之二: <a href="https://github.com/transcode-open/apt-cyg" target="_blank" rel="noopener">apt-cyg</a> , 使用方法类似ubuntu 的apt-get <code>apt-cyg install yourPackage</code></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>把windows的盘符链接为<code>/c</code>, <code>/d</code>这样的路径: <code>ln -s /cygdrive/c /c</code></li><li><p>alias:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias ll=&apos;ls -alh&apos;</span><br><span class="line">alias ls=&apos;ls --color=tty&apos;</span><br><span class="line">alias yum=&apos;apt-cyg&apos;</span><br></pre></td></tr></table></figure></li></ul><h1 id="如何删除Cygwin"><a href="#如何删除Cygwin" class="headerlink" title="如何删除Cygwin"></a>如何删除Cygwin</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">takeown /f C:\cygwin /r /d y</span><br><span class="line">icacls c:\cygwin /t /grant everyone:F</span><br></pre></td></tr></table></figure><p>删除整个Cygwin安装目录.</p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Cygwin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Atom For Windows</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91Github-Atom-for-Windows/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91Github-Atom-for-Windows/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/378023/49132477-f4b77680-f31f-11e8-8357-ac6491761c6c.png" alt=""></p><p>本文介绍用 Chocolatey 在 Windows上安装 Atom编辑器.</p><blockquote><p>Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持macOS、Windows和Linux操作系统，支持Node.js所写的插件，并内置由Github提供的Git版本控制系统。多数的延伸包皆为开放源代码授权，并由社群建置与维护。</p></blockquote><h1 id="Chocolatey-for-Windows"><a href="#Chocolatey-for-Windows" class="headerlink" title="Chocolatey for Windows"></a>Chocolatey for Windows</h1><p>简单的说, Chocolatey相当于Windows上的yum和apt-get, Chocolatey这套包管理系统目前已经包含了近500 多款常用软件.</p><p>安装Chocolatey:<br>以管理员身份打开 PowerShell输入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))</span><br></pre></td></tr></table></figure><h1 id="Chocolatey使用方法"><a href="#Chocolatey使用方法" class="headerlink" title="Chocolatey使用方法"></a>Chocolatey使用方法</h1><ul><li>列出已安装的包：<code>choco list</code></li><li>安装软件包：<code>choco install 软件包名</code></li><li>升级软件包: <code>choco upgrade 软件包名</code></li><li>卸载软件包: <code>choco uninstall 软件包名</code></li></ul><h1 id="安装Atom"><a href="#安装Atom" class="headerlink" title="安装Atom"></a>安装Atom</h1><p>打开cmd命令行或者PowerShell, <code>choco install atom</code></p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>@ref [[AppSolution]]</p><ul><li><a href="https://atom.io/packages/context-menu-manager" target="_blank" rel="noopener">context-menu-manager</a>： 管理Atom的右键，删除无用的item &amp; 也可以查看某个item是哪个插件加上去的</li><li>✔︎<a href="https://atom.io/packages/highlight-selected" target="_blank" rel="noopener">highlight-selected</a></li><li>✔︎<a href="https://atom.io/packages/document-outline" target="_blank" rel="noopener">document-outline</a></li><li>✔︎<a href="https://atom.io/packages/autocomplete-paths" target="_blank" rel="noopener">autocomplete-paths</a></li><li>✔︎<a href="https://atom.io/packages/autocomplete-python" target="_blank" rel="noopener">autocomplete-python</a></li><li>✔︎<a href="https://atom.io/packages/vim-mode-plus" target="_blank" rel="noopener">vim-mode-plus</a></li><li>✔︎<a href="https://atom.io/packages/highlight-registered-keyword" target="_blank" rel="noopener">highlight-registered-keyword</a> : 自定义高亮 Keyword</li><li>✔︎<a href="https://atom.io/packages/file-icons" target="_blank" rel="noopener">file-icons</a>:  图标</li><li>✘<a href="https://atom.io/packages/symbol-gen" target="_blank" rel="noopener">symbol-gen</a>:  快捷键<code>Ctrl-Cmd-G</code>, 生成项目的符号到.tag文件, 可以使用<code>Cmd+Shift+R</code>搜索项目中的符号(类似VSCOde的<code>Cmd+P</code>)</li><li>✘<a href="https://atom.io/packages/cursor-history" target="_blank" rel="noopener">cursor-history</a>: 快捷键 <code>C-O</code>, <code>C-I</code></li></ul><h2 id="highlight-registered-keyword"><a href="#highlight-registered-keyword" class="headerlink" title="highlight-registered-keyword"></a>highlight-registered-keyword</h2><p>This package highlights registered keyword, regardless of file extension.</p><p>$ cat ~/.atom/PatternsFilePath<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;highlight-registered-keyword&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    class: &quot;mkdtask-done&quot;</span><br><span class="line">    pattern: &quot;/✔︎/g&quot;</span><br><span class="line">    fileTypes:[&quot;md&quot;, &quot;mkd&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    class: &quot;mkdtask-delay&quot;</span><br><span class="line">    pattern: &quot;/✘/g&quot;</span><br><span class="line">    fileTypes:[&quot;md&quot;, &quot;mkd&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    class: &quot;mkdtask-snooze&quot;</span><br><span class="line">    pattern: &quot;/→/g&quot;</span><br><span class="line">    fileTypes:[&quot;md&quot;, &quot;mkd&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    class: &quot;ISBN&quot;</span><br><span class="line">    pattern: &quot;/(ISBN-13 ?((978)|(979))-\\d&#123;1,9&#125;-\\d&#123;1,9&#125;-\\d&#123;1,9&#125;-\\d)|(ISBN-10 ?\\d&#123;1,9&#125;-\\d&#123;1,9&#125;-\\d&#123;1,9&#125;-\\d)/g&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>$ cat ~/.atom/styles.less<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">atom-text-editor .highlight &#123;</span><br><span class="line">  &amp;.highlight-registered-keyword &#123;</span><br><span class="line">   .region &#123;</span><br><span class="line">      background-color: hsla(180, 60%, 50%, 0.5);</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.mkdtask-done &#123;</span><br><span class="line">      .region &#123;</span><br><span class="line">        background-color: hsla(130, 60%, 50%, 0.5);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.mkdtask-delay &#123;</span><br><span class="line">      .region &#123;</span><br><span class="line">        background-color: hsla(350, 60%, 50%, 0.5);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.mkdtask-snooze &#123;</span><br><span class="line">      .region &#123;</span><br><span class="line">        background-color: hsla(200, 60%, 50%, 0.5);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;.ISBN &#123;</span><br><span class="line">      .region &#123;</span><br><span class="line">        background-color: hsla(60, 60%, 50%, 0.5);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>(<a href="https://chocolatey.org/packages/Atom" target="_blank" rel="noopener">https://chocolatey.org/packages/Atom</a>)</li><li>(<a href="http://www.oschina.net/p/chocolatey" target="_blank" rel="noopener">http://www.oschina.net/p/chocolatey</a>)</li><li><a href="https://chocolatey.org/packages" target="_blank" rel="noopener">更多Choco的工具</a></li></ul><hr><p>其他有用的packages：</p><ul><li><a href="https://chocolatey.org/packages/easy.install" target="_blank" rel="noopener">Easy Install</a></li><li><a href="https://chocolatey.org/packages/pip" target="_blank" rel="noopener">Pip</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> Windows </tag>
            
            <tag> Atom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text 3 扩展和快捷键</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91Sublime-Text-3%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91Sublime-Text-3%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Package-Control"><a href="#安装-Package-Control" class="headerlink" title="安装 Package Control"></a>安装 Package Control</h1><p>Sublime text 3安装<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">Package Control</a>的方法:<br>View -&gt; Show Console, 输入:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;2deb499853c4371624f5a07e27c334aa&apos; + &apos;bf8c4e67d14fb0525ba4f89698a6d7e1&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure></p><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><ul><li>SideBarEnhancements : 侧边栏右键增强, 配置参考<a href="https://github.com/titoBouzout/SideBarEnhancements/#f12-key-conflict" target="_blank" rel="noopener">这里</a></li><li>Emmet: 前身是”Zen Coding”, 可以更高效地编写HTML和CSS, 比如输入<code>html:5</code>然后按 <code>Tab</code> 就能自动产生代码段, <a href="http://docs.emmet.io/cheat-sheet/" target="_blank" rel="noopener">速查表在这里</a></li><li><a href="https://github.com/SublimeLinter/SublimeLinter3" target="_blank" rel="noopener">SublimeLinter</a>: 语法错误检查, 安装完SublimeLinter后还要安装对应语言的扩展, 在Package Control搜索”SublimeLinter-“即可.<ol><li><a href="https://github.com/SublimeLinter/SublimeLinter-php" target="_blank" rel="noopener">SublimeLinter-php</a>: 需要安装php</li><li><a href="https://github.com/SublimeLinter/SublimeLinter-pep8" target="_blank" rel="noopener">SublimeLinter-pep8</a>:</li><li><a href="https://github.com/SublimeLinter/SublimeLinter-jshint" target="_blank" rel="noopener">SublimeLinter-jshint</a>: 需要安装jshint: <code>npm install -g jshint</code></li><li><a href="https://github.com/nirm03/SublimeLinter-clang" target="_blank" rel="noopener">SublimeLinter-clang</a>: 需要安装clang, Windows用户请安装”mingw with clang”</li></ol></li><li><a href="https://github.com/SublimeCodeIntel/SublimeCodeIntel" target="_blank" rel="noopener">SublimeCodeIntel</a>: 函数定义跳转, 支持Js,Py,PHP等等, 但是不支持C/C++.</li><li><a href="https://github.com/SublimeText/CTags" target="_blank" rel="noopener">Ctags</a>: 也是作为函数定义跳转, 快捷键<code>ctrl+t, ctrl+t</code>跳转到定义, <code>ctrl+t, ctrl+b</code>跳转回. 对于有多个相似定义的函数, sublime里默认列出所有的tags, 和vim的<code>g + ]</code>类似. 使用起来感觉Ctags比SublimeCodeIntel跳转的更快, 因为SublimeCodeIntel总是动态的更新索引导致, Ctags不会自动更新tags文件里的索引.</li><li>Snippets:</li><li><a href="https://github.com/jdc0589/JsFormat" target="_blank" rel="noopener">JsFormat</a>: js格式化, <code>ctrl+alt+f</code>, 或者<code>ctrl + shift + p</code>, 打开控制台输入<code>Format: Javascript</code></li><li>phpfmt : php格式化, 在控制台输入<code>phpfmt: format now</code></li><li>ConvertToUTF8:</li><li>SublimeClang: C/C++的代码补全, 现在只支持ST2并且作者好久没更新了, 用ST3的洗洗睡吧. SublimeClang的static analyzer功能需clang的支持, 在Windows上安装clang又是喜闻乐见的困难, so~Windows用户也可以洗洗睡了.</li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h2 id="1-跳转"><a href="#1-跳转" class="headerlink" title="1. 跳转"></a>1. 跳转</h2><ul><li><code>Ctrl+P</code> : 快速打开文件</li><li><code>Ctrl+R</code> : 快速搜索函数</li><li><code>Ctrl+G</code> : 跳转到行</li><li><code>Alt + -</code> : Navigate Backwards</li><li><code>Alt + Shift + -</code> : Navigate Forwards</li><li><code>Ctrl + Left/Right</code> : 类似Vim的<code>w</code> 和 <code>b</code></li><li><code>Ctrl + Shift + Left</code> : 向左单位性地选中文本</li><li><code>Ctrl + Shift + Right</code> : 向右单位性地选中文本</li><li><code>Ctrl+Shift+M</code> : 选择括号</li><li><code>Ctrl+M</code> : 括号跳转</li><li><code>Ctrl+Shift+M</code> : 选中当前括号内容，重复可选着括号本身</li></ul><h2 id="2-编辑"><a href="#2-编辑" class="headerlink" title="2. 编辑"></a>2. 编辑</h2><ul><li><code>Ctrl+Alt+上下</code> : 列模式</li><li><code>Ctrl+D</code> : 多处同步编辑, 继续按Ctrl+D可以持续选中下一处.</li><li><code>Ctrl + Backspace</code> : 向前删除一个单词</li><li><code>Ctrl + Delete</code> : 向后删除一个单词</li><li><code>Ctrl+L</code> : 选中整行，继续操作则继续选择下一行，效果和<code>Shift + ↓</code>效果一样</li><li><code>Ctrl+Shift+L</code> : 在选中的行每行行尾插入光标，即可同时编辑这些行</li><li><code>Ctrl+X</code> : 删除当前行</li><li><code>Ctrl+Z</code> : 撤消操作, 同<code>Ctrl+U</code></li><li><code>Ctrl+Y</code> : 恢复撤销</li><li><code>Ctrl+Enter</code> : 在下一行插入新行</li><li><code>Ctrl+Shift+Enter</code> : 在上一行插入新行</li></ul><h2 id="3-搜索替换"><a href="#3-搜索替换" class="headerlink" title="3. 搜索替换"></a>3. 搜索替换</h2><ul><li><code>Ctrl+Shift+F</code> : 搜索状态下Ctrl+E,</li><li><code>Ctrl+F</code> : <code>Enter</code>查找下一个, <code>Shift+Enter</code>查找上一个</li><li><code>Ctrl+H</code> : 替换</li></ul><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h2><ul><li><code>Ctrl+K+B</code> : 关闭侧边栏</li><li><code>Ctrl+/</code> : 注释当前行</li><li><code>Ctrl+Alt+/</code> : 插入注释</li></ul><h2 id="5-SublimeCodeIntel"><a href="#5-SublimeCodeIntel" class="headerlink" title="5. SublimeCodeIntel:"></a>5. SublimeCodeIntel:</h2><ul><li>Jump to definition = <code>Control + Windows + Alt + Up</code> or <code>Alt + Click</code></li><li>Go back = <code>Control + Windows + Alt + Left</code></li><li>Manual Code Intelligence = <code>Control + Shift + space</code></li></ul><h2 id="6-CTags"><a href="#6-CTags" class="headerlink" title="6. CTags"></a>6. CTags</h2><ul><li>Rebuild ctags = <code>ctrl+t, ctrl+r</code></li><li>Jump to definition =  <code>ctrl+t, ctrl+t</code></li><li>Jump back = <code>ctrl+t, ctrl+b</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> Sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在树莓派上安装Samba和Ftp服务</title>
      <link href="/50.Farbox-Blog/%E3%80%90Raspberry%E3%80%91%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85Samba%E5%92%8CFTP%E6%9C%8D%E5%8A%A1/"/>
      <url>/50.Farbox-Blog/%E3%80%90Raspberry%E3%80%91%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85Samba%E5%92%8CFTP%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h1><ul><li><p>安装: <code>sudo apt-get install samba samba-common-bin</code></p></li><li><p>修改配置文件: <code>sudo /etc/samba/smb.conf</code>, 修改如下:</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workgroup = WORKGROUP # !根据实际情况填写&quot;域名&quot;或者&quot;工作组名&quot;</span><br><span class="line"></span><br><span class="line">wins support = yes # !打开对Win支持</span><br><span class="line"></span><br><span class="line">security = user    # !每个samba用户对应linux的用户</span><br><span class="line"></span><br><span class="line"># 找到 Share Definitions 部分, 删除不使用的定义, 并添加:</span><br><span class="line">[pi]</span><br><span class="line">    comment= Raspberry SMB</span><br><span class="line">    path=/home/raspsmb/share</span><br><span class="line">    browseable=Yes</span><br><span class="line">    writeable=Yes</span><br><span class="line">    write list = root,raspsmb</span><br><span class="line">    create mask=0777</span><br><span class="line">    irectory mask=0777</span><br></pre></td></tr></table></figure><ul><li><p>添加用户, 和samba目录:<br>  <code>sudo useradd raspsmb &amp;&amp; sudo mkdir -p /home/raspsmb/share &amp;&amp; sudo chown -R raspsmb:raspsmb /home/raspsmb/</code><br>  <code>sudo smbpasswd -a raspsmb</code> 设置samba密码</p></li><li><p>重启samba服务<code>sudo service samba restart</code> </p></li><li><p>创建链接: <code>sudo ln -s /home/raspsmb/share /smb</code></p></li><li><p>在Windows上访问: <code>\\ipaddress\pi</code>, “pi”是在配置文件smb.conf中Share Definitions部分定义的<code>[pi]</code>, 用户名是上面创建的”raspsmb”用户. 注意Windows上要保证服务TCP/IP (NetBT) 和Workgroup打卡. </p></li><li><p>参考:<br>  <a href="http://raspberrywebserver.com/serveradmin/share-your-raspberry-pis-files-and-folders-across-a-network.html" target="_blank" rel="noopener">http://raspberrywebserver.com/serveradmin/share-your-raspberry-pis-files-and-folders-across-a-network.html</a><br>  <a href="http://www.ttlsa.com/linux/install-samba-on-linux/" target="_blank" rel="noopener">http://www.ttlsa.com/linux/install-samba-on-linux/</a></p></li></ul><h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><ul><li><p>安装: <code>sudo apt-get install vsftpd</code></p></li><li><p>修改配置文件: <code>sudo vim /etc/vsftpd.conf</code>, 修改如下: </p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">user_sub_token=$USER</span><br><span class="line">local_root=/home/raspftp/share</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure><ul><li><p>添加用户, 和samba目录:<br>  <code>sudo useradd raspftp &amp;&amp; sudo mkdir -p /home/raspftp/share &amp;&amp; sudo chown -R raspftp:raspftp /home/raspftp/</code><br>  <code>sudo passwd raspftp</code></p></li><li><p>重启ftp服务: <code>sudo service vsftpd restart</code></p></li><li><p>创建链接: <code>sudo ln -s /home/raspftp/share /ftp</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> Samba </tag>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在树莓派上安装无线网卡</title>
      <link href="/50.Farbox-Blog/%E3%80%90Raspberry%E3%80%91%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/"/>
      <url>/50.Farbox-Blog/%E3%80%90Raspberry%E3%80%91%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="测试驱动"><a href="#测试驱动" class="headerlink" title="测试驱动"></a>测试驱动</h2><p>为了省事，我买了EP-N8508GS无线网卡，因为能免去编译驱动的麻烦。<br>确认你的Kernel支持那些无线网卡:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /lib/modules/`uname -r`/kernel/drivers/net/wireless -name &quot;*.ko&quot;</span><br><span class="line">/lib/modules/3.12.35+/kernel/drivers/net/wireless/rtl8192cu/8192cu.ko</span><br><span class="line">/lib/modules/3.12.35+/kernel/drivers/net/wireless/rtl818x/rtl8187/rtl8187.ko</span><br></pre></td></tr></table></figure><p>查看识别的usb设备:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi ~ $ lsusb</span><br><span class="line">Bus 001 Device 002: ID 0424:9512 Standard Microsystems Corp.</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line">Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp.</span><br><span class="line">Bus 001 Device 004: ID 0bda:8176 Realtek Semiconductor Corp. RTL8188CUS 802.11n WLAN Adapter</span><br></pre></td></tr></table></figure><p>注意最后一行的Realtek设备就是无线网卡.</p><p>查看Kernel载入的模块: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsmod</span><br><span class="line">8192cu                550797  0</span><br><span class="line">leds_gpio               2079  0</span><br><span class="line">led_class               4118  1 leds_gpio</span><br></pre></td></tr></table></figure><p>上面的8192cu就是我的无线网卡的芯片型号.</p><p>执行命令: <code>sudo iwlist wlan0 scan</code> , 看看能否手动扫描周围的ESSID.</p><h2 id="无线配置"><a href="#无线配置" class="headerlink" title="无线配置"></a>无线配置</h2><p>修改配置文件: <code>sudo vim /etc/network/interfaces</code>, 如果需要自动IP, 增加如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wifi (dhcp config) :</span><br><span class="line">auto wlan0</span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>如果需要固定IP, 增加的内容如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet static</span><br><span class="line">wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line">address 192.168.1.12</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.1.1</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/wpa_supplicant/wpa_supplicant.conf</code>, 增加如下几行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;ssid1&quot;</span><br><span class="line">    psk=&quot;密码&quot;</span><br><span class="line">&#125;</span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=&quot;ssid2&quot;</span><br><span class="line">    psk=&quot;密码&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存的是明文密码, 如果需要存储加密后的密码, 执行命令<code>wpa_passphrase ssid password</code>, 替换上面的psk密码.<br>wpa_supplicant.conf里面更多参数详情, 请参考man手册<a href="http://linux.die.net/man/5/wpa_supplicant.conf" target="_blank" rel="noopener">链接</a>, 上面的配置能应付大多数路由器了. </p><h2 id="重启wlam0"><a href="#重启wlam0" class="headerlink" title="重启wlam0"></a>重启wlam0</h2><p>重启无线网卡: <code>sudo ifdown wlan0</code> and then  <code>sudo ifup wlan0</code><br>然后运行<code>ifconfig wlan0</code> 查看无线网卡是否获能够取到了IP.</p><p>DONE.</p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 无线网卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Xdebug调试PHP</title>
      <link href="/50.Farbox-Blog/%E3%80%90PHP%E3%80%91%E4%BD%BF%E7%94%A8Xdebug%E8%B0%83%E8%AF%95PHP/"/>
      <url>/50.Farbox-Blog/%E3%80%90PHP%E3%80%91%E4%BD%BF%E7%94%A8Xdebug%E8%B0%83%E8%AF%95PHP/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）-Server端安装xdebug"><a href="#（一）-Server端安装xdebug" class="headerlink" title="（一） Server端安装xdebug:"></a>（一） Server端安装xdebug:</h1><h2 id="Windows服务器"><a href="#Windows服务器" class="headerlink" title="Windows服务器"></a>Windows服务器</h2><p>For windows的xdebug都是预编译好的binary包, 根据PHP版本下载对应的xdebug: <a href="http://xdebug.org/download.php" target="_blank" rel="noopener">下载地址</a></p><h2 id="Linux服务器"><a href="#Linux服务器" class="headerlink" title="Linux服务器"></a>Linux服务器</h2><p>(1) 安装<br>最简单的安装方法是通过PECL安装: <code>pecl install xdebug</code></p><p>如果你的服务器上没有PECL, 可以通过源码编译安装xdebug:</p><ol><li>在(<a href="http://xdebug.org/download.php#releases)下载source" target="_blank" rel="noopener">http://xdebug.org/download.php#releases)下载source</a></li><li>解压源码包: <code>tar -xzf xdebug-2.2.5.tgz</code> , and <code>cd xdebug-2.2.5</code></li><li>继续终端执行: <code>phpize</code> , and then <code>./configure --enable-xdebug</code>, <code>make &amp;&amp; make install</code></li></ol><p>(2) 配置<br>编辑服务端的php.ini, 增加:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zend_extension=&quot;/usr/local/php/modules/xdebug.so&quot;</span><br><span class="line">xdebug.remote_autostart = 1</span><br><span class="line">xdebug.remote_enable=1</span><br><span class="line">xdebug.remote_handler = &quot;dbgp&quot;</span><br><span class="line">xdebug.remote_host = &quot;127.0.0.1&quot; # 允许指定IP的调试客户端连接</span><br><span class="line">xdebug.remote_port=9000 # 监听的端口</span><br><span class="line">xdebug.trace_output_dir = &quot;/tmp/xampp/trace&quot;</span><br><span class="line">;xdebug.profiler_enable=1 # 性能分析, 非常占资源, 暂关</span><br><span class="line">;xdebug.profiler_output_dir = &quot;/tmp/xampp/profile&quot;</span><br></pre></td></tr></table></figure><p>(3) 测试xdebug server<br>重启web server, 然后新建一个test.php, 内容<code>&lt;?php phpinfo(); ?&gt;</code>, 如果访问这个test.php能看到<code>xdebug</code>相关, 说明安装完成.</p><h1 id="（二）PC端安装xdebug-client"><a href="#（二）PC端安装xdebug-client" class="headerlink" title="（二）PC端安装xdebug client"></a>（二）PC端安装xdebug client</h1><h2 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h2><p>Chrome安装”debug helper”, 火狐安装”The easiest Xdebug”, 并在插件在设置<code>IDE Key</code>为”PHPSTORM” (这里名字随便设, 但是记住要与IDE里的设置一致).</p><h2 id="IDE设置"><a href="#IDE设置" class="headerlink" title="IDE设置"></a>IDE设置</h2><p>这里xdebug client根据你的IDE有多个版本可以选择: Eclipse , NetBeans, Vim, 选择自己喜欢的开发环境, 下面是Vim设置xdebug的例子, 其他的IDE可以参考链接:</p><ul><li>[Xdebug Client for Phpstorm] (<a href="https://www.jetbrains.com/phpstorm/help/configuring-xdebug.html" target="_blank" rel="noopener">https://www.jetbrains.com/phpstorm/help/configuring-xdebug.html</a>)</li><li>[Xdebug Client for Eclipse] (<a href="https://wiki.eclipse.org/Debugging_using_XDebug" target="_blank" rel="noopener">https://wiki.eclipse.org/Debugging_using_XDebug</a>)</li><li>[Xdebug Client for vim] (<a href="http://thorpesystems.com/blog/debugging-php-in-vim/" target="_blank" rel="noopener">http://thorpesystems.com/blog/debugging-php-in-vim/</a>)</li></ul><h3 id="在Vim中安装vdebug"><a href="#在Vim中安装vdebug" class="headerlink" title="在Vim中安装vdebug"></a>在Vim中安装vdebug</h3><ul><li>在_vimrc中增加如下配置:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bundle &apos;joonty/vdebug.git&apos;</span><br><span class="line">&quot; 以下选项的说明在 https://github.com/joonty/vdebug/blob/master/doc/Vdebug.txt</span><br><span class="line">let g:vdebug_options = &#123;</span><br><span class="line">  \    &quot;port&quot; : 9000,</span><br><span class="line">  \    &quot;timeout&quot; : 10,</span><br><span class="line">  \    &quot;break_on_open&quot; : 0,</span><br><span class="line">  \    &quot;ide_key&quot; : &apos;PHPSTORM&apos;</span><br><span class="line">  \&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行<code>:BundleInstall</code>安装vdebug</p></li><li><p>vdebug默认按键:</p><ul><li><code>&lt;F5&gt;</code>: start/run (to next breakpoint/end of script)</li><li><code>&lt;F2&gt;</code>: step over</li><li><code>&lt;F3&gt;</code>: step into</li><li><code>&lt;F4&gt;</code>: step out</li><li><code>&lt;F6&gt;</code>: stop debugging</li><li><code>&lt;F7&gt;</code>: detach script from debugger</li><li><code>&lt;F9&gt;</code>: run to cursor</li><li><code>&lt;F10&gt;</code>: toggle line breakpoint</li></ul></li></ul><h3 id="在Vim中使用vdebug"><a href="#在Vim中使用vdebug" class="headerlink" title="在Vim中使用vdebug"></a>在Vim中使用vdebug</h3><ul><li>在Vim打开test.php并按下F5, 状态栏会提示”Waiting for a connection…”并持续20秒等待, 在20秒之内通过浏览器访问test.php, vdebug会自动定位在test.php第一行.</li><li>注: 上面的20秒等待时间是通过<code>timeout</code>参数设置的, <code>break_on_open</code>参数决定是否自动断在脚本第一行</li><li>如果按下F5后没有反应, 可以尝试在Vim中执行<code>:python debugger.run()</code>, 看是否有错误提示;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Xdebug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署和使用指北(Windows)</title>
      <link href="/50.Farbox-Blog/%E3%80%90Markdown%E3%80%91Hexo%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
      <url>/50.Farbox-Blog/%E3%80%90Markdown%E3%80%91Hexo%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<h1 id="静态博客对比"><a href="#静态博客对比" class="headerlink" title="静态博客对比"></a>静态博客对比</h1><ul><li>Hugo: 基于Golang <a href="https://gohugo.io/" target="_blank" rel="noopener">The world’s fastest framework for building websites | Hugo</a></li><li>Jekyll: 基于Ruby / 支持 GitHub Pages 部署 <a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll • Simple, blog-aware, static sites | Transform your plain text into static websites and blogs</a></li><li>Hexo: 基于Node.js / 支持 GitHub Pages 部署 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></li></ul><h1 id="安装-Step-by-Step"><a href="#安装-Step-by-Step" class="headerlink" title="安装 Step by Step"></a>安装 Step by Step</h1><p>安装<a href="http://git-scm.com/downloads" target="_blank" rel="noopener">Git客户端</a>和<a href="http://nodejs.org/download/" target="_blank" rel="noopener">node.js</a>环境, 然后你还要有一个Github帐号.<br>安装完node.js之后, 不要忘记把<code>User/AppData/Roaming/npm</code>添加到PATH.</p><ul><li>安装hexo: 打开Git CMD（因为），输入: <code>npm install -g hexo-cli</code></li><li>初始化hexo: <code>hexo init BLOG</code>, 将在当前目录建立”BLOG”为名的目录并在此初始化, Hexo 即会自动在目标文件夹建立网站所需要的所有文件.</li><li>安装依赖包: <code>cd BLOG &amp;&amp; npm install</code>,<ul><li>如果需要把Blog部署到Github上, 还需要安装hexo-git模块: <code>npm install hexo-deployer-git --save</code> (这一步可选);</li><li>如果需要Blog主页不显示全文而是摘要, 需要安装<code>npm install --save hexo-excerpt</code> (这一步可选);</li></ul></li><li>本地启动测试: <code>hexo server</code>, 然后访问<a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">127.0.0.1:4000</a>查看.</li><li>Github上新建一个repository, 名字为<code>yoursite.github.io</code></li><li><p>修改本地的<code>_config.yml</code>文件, 找到<code>#site</code>一栏, 修改博客的title, 然后在最后的<code>deploy:</code>处增加下面几行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: github</span><br><span class="line">repository: https://github.com/Your_Github_Account/yoursite.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li><li><p>添加评论系统: 国外比较常用的评论系统有disqus等, 这个在hexo中也是默认开启的, 如果我们要添加其他的评论系统, 还需要做一点修改.<br>在国内推荐使用搜狐畅言: <img src="http://changyan.sohu.com/platformstatic/images/pic/f02.jpg" alt="搜狐畅言-专业的社会化评论系统">.<br>首先需要在配置文件中禁用disqus, 编辑根目录的_config.yml文件: 查找并注释掉<code>disqus_shortname</code>一行.<br>然后编辑 <code>themes\landscape\layout\_partial\article.ejs</code>文件, 在文件最后找到<code>section id=&quot;comments&quot;</code>一段, 修改为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (!index)&#123; %&gt;</span><br><span class="line">&lt;section id=&quot;comments&quot;&gt;</span><br><span class="line">    &lt;%- partial(&apos;comment&apos;) %&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>编辑<code>themes\landscape\layout\_partial\comment.ejs</code> 并添加<a href="http://changyan.sohu.com/" target="_blank" rel="noopener">畅言</a>的Js代码:</p></li></ul><h2 id="附-hexo命令列表"><a href="#附-hexo命令列表" class="headerlink" title="附: hexo命令列表"></a>附: hexo命令列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;post title with whitespace&quot;</span><br><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br><span class="line">hexo deploy</span><br><span class="line">hexo clean: 清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)</span><br><span class="line">hexo version</span><br></pre></td></tr></table></figure><h2 id="附-npm命令列表"><a href="#附-npm命令列表" class="headerlink" title="附: npm命令列表"></a>附: npm命令列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm ls</span><br><span class="line">npm outdated</span><br><span class="line">npm update  # npm update [-g] [&lt;pkg&gt;...]</span><br><span class="line">npm install [-g] moduleName [--save]  # -g 全局安装 , --save将被写入package.json的dependencies</span><br><span class="line">npm uninstall [&lt;pkg&gt;...]</span><br><span class="line">npm cache clean</span><br></pre></td></tr></table></figure><h1 id="使用NexT主题"><a href="#使用NexT主题" class="headerlink" title="使用NexT主题"></a>使用NexT主题</h1><p>下载NexT主题:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd BLOG</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>修改<code>_config.yml</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><p>如果使用了<code>NexT</code>主题, 第三方评论系统需要在<code>themes/nextlayout/_partials/comments.swig</code>修改, 增加畅言评论的js</p><h1 id="添加-修改文章"><a href="#添加-修改文章" class="headerlink" title="添加/修改文章"></a>添加/修改文章</h1><ol><li>打开Git Bash并执行:<ul><li><code>hexo n 文章名</code> 新建文章, 这将在hexo\source_posts\目录下新建同名的Markdown文件, 用你喜欢的markdown编辑器写博客…</li><li><code>hexo g</code> : 这将在hexo.deploy目录下生成静态页面.</li><li><code>hexo d</code> : 把文章推到到Github上.</li></ul></li><li>部署完成后, 访问<code>yoursite.github.io</code>就能看到自己搭建的博客了.</li></ol><blockquote><p>注意, Hexo解析某些含有 <code>{＃</code>, <code>{％</code>的代码块会有问题, 在执行<code>hexo g</code>的时候会抛错, 折中解决办法就是..用全角字符😁</p></blockquote><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Hexo 的 YAML Front-matter 支持的属性：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span><span class="string">标题</span><span class="string">文章的文件名</span></span><br><span class="line"><span class="attr">date:</span><span class="string">建立日期</span><span class="string">文件建立日期</span></span><br><span class="line"><span class="attr">updated:</span><span class="string">更新日期</span><span class="string">文件更新日期</span></span><br><span class="line"><span class="attr">comments:</span><span class="string">开启文章的评论功能</span><span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span><span class="string">标签（不适用于分页）</span></span><br><span class="line"><span class="attr">categories:</span><span class="string">分类（不适用于分页）</span></span><br><span class="line"><span class="attr">permalink:</span><span class="string">覆盖文章网址</span></span><br><span class="line"><span class="attr">excerpt:</span><span class="string">Page</span> <span class="string">excerpt</span> <span class="string">in</span> <span class="string">plain</span> <span class="string">text.</span> <span class="string">Use</span> <span class="string">this</span> <span class="string">plugin</span> <span class="string">to</span> <span class="string">format</span> <span class="string">the</span> <span class="string">text</span></span><br></pre></td></tr></table></figure><h1 id="为Hexo增加更多特性…"><a href="#为Hexo增加更多特性…" class="headerlink" title="为Hexo增加更多特性…"></a>为Hexo增加更多特性…</h1><h2 id="SEO推广"><a href="#SEO推广" class="headerlink" title="SEO推广"></a>SEO推广</h2><h3 id="生成sitemap"><a href="#生成sitemap" class="headerlink" title="生成sitemap"></a>生成sitemap</h3><p>Sitemap用于通知搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。</p><ul><li>安装插件hexo-generator-sitemap，用于生成sitemap：<code>npm install hexo-generator-sitemap --save</code></li><li>在 <strong>站点配置文件</strong> _config.yml中添加如下字段：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果post标题中有<code>&amp;</code> <code>&gt;</code>等符号，可能会导致sitemap生成有问题，浏览器打开后可看到 “xmlParseEntityRef: no name”的错误提示</p></blockquote><h3 id="添加-robots-txt"><a href="#添加-robots-txt" class="headerlink" title="添加 robots.txt"></a>添加 robots.txt</h3><p>网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。robots.txt 通常存放于网站根目录。<br>在source文件夹下新建robots.txt文件，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /lib/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Sitemap: https://your_site.com/sitemap.xml</span><br></pre></td></tr></table></figure><h2 id="Hexo正文中标题自动编号"><a href="#Hexo正文中标题自动编号" class="headerlink" title="Hexo正文中标题自动编号"></a>Hexo正文中标题自动编号</h2><ul><li>安装heading-index: <code>npm install hexo-heading-index --save</code></li><li><p>修改顶层_config.yml</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">heading_index:</span><br><span class="line">  enable: true</span><br><span class="line">  index_styles: &quot;&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;&quot;</span><br><span class="line">  connector: &quot;.&quot;</span><br><span class="line">  global_prefix: &quot;&quot;</span><br><span class="line">  global_suffix: &quot;: &quot;</span><br></pre></td></tr></table></figure></li><li><p>修改Hexo主题下的_config.yml， 避免侧边栏重复自动生成编号，禁用侧边栏自动编号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: false</span><br></pre></td></tr></table></figure></li></ul><!-- /TOC --><h2 id="Hexo处理锚点的问题"><a href="#Hexo处理锚点的问题" class="headerlink" title="Hexo处理锚点的问题"></a>Hexo处理锚点的问题</h2><p>Markdown文章里的锚点,<br>如果是本文内的锚点, 可以用<code>[锚点名称](#章节)</code>,<br>如果是章节外的锚点, 可以用<code>https://URI/#章节</code></p><p>但是需要注意的是:</p><ul><li>如果标题里带标点符号, 大多数情况下(比如常用的Hexo, Github, Gitlab的解析器)Markdown解析成html锚点后都会把标题里的英文标点符号转换成<code>-</code>, 但中文标题里的标点不会被转换.</li><li>英文字母要全部小写.</li></ul><p>比如本文中的<code>### 添加 robots.txt</code>标题, 转成html后锚点变成<code>添加-robots-txt</code>:</p><blockquote><p><code>https://whatsrtos.github.io/blog_archive/Hexo部署和使用指北/#添加-robots-txt</code></p></blockquote><h2 id="NexT-主题修改Toc"><a href="#NexT-主题修改Toc" class="headerlink" title="NexT 主题修改Toc"></a>NexT 主题修改Toc</h2><p>NexT主题的Toc列表是在sidebar显示的, 如果在手机或平板等小屏幕设备上不显示sidebar,<br>如何在手机浏览时可以显示sidebar的Toc可以参考:<br><a href="https://blog.zzbd.org/2017/06/10/keep-sidebar/" target="_blank" rel="noopener">Next主题小屏幕下保留侧边栏 | J.F’s BLOG</a></p><h2 id="NexT-主题自定义css"><a href="#NexT-主题自定义css" class="headerlink" title="NexT 主题自定义css"></a>NexT 主题自定义css</h2><p>NexT的自定义文件在: source/css/_custom/custom.styl</p><h2 id="NexT-主题支持数学公式"><a href="#NexT-主题支持数学公式" class="headerlink" title="NexT 主题支持数学公式"></a>NexT 主题支持数学公式</h2><p>安装:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure></p><p>在站点配置文件 _config.yml 中添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  engine: &apos;mathjax&apos; # or &apos;katex&apos;</span><br><span class="line">  mathjax:</span><br><span class="line">    # src: custom_mathjax_source</span><br><span class="line">    config:</span><br><span class="line">    # MathJax config</span><br></pre></td></tr></table></figure></p><p>在 next 主题配置文件中 themes/next-theme/_config.yml 添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></p><p>使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行内公式: $数学公式$</span><br><span class="line">行间公式, 独占一行: $$数学公式$$</span><br></pre></td></tr></table></figure></p><h1 id="自定义post排序"><a href="#自定义post排序" class="headerlink" title="自定义post排序"></a>自定义post排序</h1><p>主页的post 默认是按创建时间排序，主页文章排序在配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 0</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure><p>order_by 可以是 yaml front matter里定义的属性（没测试）</p><p>但是 category 页面的 post 排序没有可配置选项，需要直接改代码 <code>node_modules/hexo-generator-category/lib/generator.js</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var posts = category.posts.sort(&apos;title&apos;);  // 按 yaml front matter 里的title排序</span><br></pre></td></tr></table></figure><h1 id="插件列表"><a href="#插件列表" class="headerlink" title="插件列表"></a>插件列表</h1><ul><li>[x] hexo-generator-index-pin-top: 增加文章置顶功能, 在文章 front-matter 里增加<code>top: True</code>即可</li><li>[ ] hexo-heading-index : 为标题(headings)添加自动编号</li><li>[x] hexo-generator-sitemap: 生成sitemap</li><li>[x] hexo-excerpt: 主页显示文章摘要而不是全文</li><li>[ ] hexo-toc: 将markdown代码中的 <code>&lt;!-- toc --&gt;</code> 替换为TOC（Table Of Content） // 已知的问题: 会导致NexT的边栏TOC不可用</li><li>[x] hexo-math: mathjax 数学公式渲染</li><li>[x] hexo-backlink 将obsidian的双链转换为hexo链接</li></ul><h1 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h1><h2 id="node版本导致hexo-g生成静态文件size-0"><a href="#node版本导致hexo-g生成静态文件size-0" class="headerlink" title="node版本导致hexo g生成静态文件size=0"></a>node版本导致hexo g生成静态文件size=0</h2><p>降级node:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall node</span><br><span class="line">brew install node@12</span><br><span class="line">brew link --overwrite --force node@12</span><br></pre></td></tr></table></figure><p>参考:</p><ul><li><a href="https://magi003769.github.io/post/MAC-hexo/" target="_blank" rel="noopener">MAC上配置Hexo部署GitHub Page | QueinDecim</a></li><li><a href="https://www.haoyizebo.com/posts/710984d0/" target="_blank" rel="noopener">解决 Hexo 在使用 Node.js 14 时的 Accessing non-existent property ‘xxx’ of module exports inside circular dependency 问题 - 好一则博</a></li></ul><h2 id="hexo-renderer-marked版本导致图片解析问题"><a href="#hexo-renderer-marked版本导致图片解析问题" class="headerlink" title="hexo-renderer-marked版本导致图片解析问题"></a>hexo-renderer-marked版本导致图片解析问题</h2><p>发现有些博文里的markdown图片没有正常解析, 看起来像是render的问题, 因为最近重新安装过hexo-renderer-marked,<br>我的Hexo还是3.5版本,  在hexo-renderer-marked的github页面看到 0.2+版本适用于Hexo 3,<br>用npm list 查看目前安装的hexo-renderer-marked版本, 已经是2.0.0了,<br>所以试试降低hexo-renderer-marked的版本.</p><p>使用<code>npm view hexo-renderer-marked versions</code>命令查看所有已发布版本, 然后使用<code>npm install hexo-renderer-marked@0.2.11 --save</code>安装0.2版本的.<br>ps: hexo-renderer-ejs, hexo-renderer-stylus 也需要降级</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm view hexo-renderer-stylus  versions</span><br><span class="line"></span><br><span class="line">npm uninstall hexo-renderer-marked &amp;&amp; npm uninstall hexo-renderer-ejs &amp;&amp; npm uninstall hexo-renderer-stylus</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-marked@0.2.11 --save &amp;&amp; npm install hexo-renderer-stylus@0.2.3 --save &amp;&amp; npm install hexo-renderer-ejs@0.2.0 --save</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><ul><li><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">http://www.jianshu.com/p/05289a4bc8b2</a></li><li><a href="http://segmentfault.com/blog/zhongbaitu/1190000000458953" target="_blank" rel="noopener">http://segmentfault.com/blog/zhongbaitu/1190000000458953</a></li><li><a href="http://www.wuxubj.cn/2016/08/Hexo-nexT-build-personal-blog/" target="_blank" rel="noopener">http://www.wuxubj.cn/2016/08/Hexo-nexT-build-personal-blog/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyGrep使用简介</title>
      <link href="/50.Farbox-Blog/%E3%80%90Vim%E3%80%91EasyGrep%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/50.Farbox-Blog/%E3%80%90Vim%E3%80%91EasyGrep%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>Linux上使用Vim进行文件搜一般使用grep命令+grep.vim插件完成, 但在Windows上使用grep就有些不方便了, <a href="http://gnuwin32.sourceforge.net/" target="_blank" rel="noopener">GnuWin32</a>和<a href="http://sourceforge.net/projects/unxutils/" target="_blank" rel="noopener">UnxUtils</a>虽然都提供了Windows移植版本的Grep.exe, 但都有bug, 比如:</p><ul><li><a href="http://stackoverflow.com/questions/3995493/gnuwin32-find-exe-expands-wildcard-before-performing-search" target="_blank" rel="noopener">Gnuwin32 find.exe expands wildcard before performing search</a></li><li><a href="http://sourceforge.net/p/unxutils/bugs/58/" target="_blank" rel="noopener">UnxUtils: #58 xargs: cannot fork</a></li></ul><p>在Windows上使用grep还有一个折衷的办法: 使用Cygwin环境, 不过今天这里不讨论Cygwin…<br>偶然在这个博客上发现了EasyGrep插件的介绍: <a href="http://zuyunfei.com/2013/08/25/vim-plugin-easy-grep/" target="_blank" rel="noopener">vim中的杀手级插件: EasyGrep</a>, 当时我是多么执着于在Windows上移植Grep和ack啊… 浪费了不少时间之后才发现还是使用现成的工具比较好-.-</p><h2 id="EasyGrep的安装"><a href="#EasyGrep的安装" class="headerlink" title="EasyGrep的安装"></a>EasyGrep的安装</h2><p>如果你已经使用了Vundle管理Vim插件, 只需要在.vimrc里增加<code>Bundle &#39;EasyGrep&#39;</code>然后使用<code>:BundleInstall</code>安装即可.</p><h2 id="How-To-Use"><a href="#How-To-Use" class="headerlink" title="How To Use"></a>How To Use</h2><ul><li><code>\vv</code> or <code>:Grep</code>: <code>\vv</code>命令将在文件中搜索当前光标下的单词, <code>:Grep word</code>将搜索”word”, 如果加叹号<code>:Grep !word</code>表示全词匹配的方式搜索, Grep也可以带参数, 比如<code>:Grep -ir word</code>, r表示递归目录. i表示不区分大小写.</li><li><code>\vV</code> : 全词匹配搜索, 同<code>:Grep !word</code>;</li><li><code>\va</code> : 与<code>vv</code>相似, 搜索结果append在上次搜索结果之后;</li><li><code>\vA</code> : 与<code>vV</code>相似, 搜索结果append在上次搜索结果之后;</li><li><code>\vr</code> or <code>:Replace</code> :替换;</li><li><code>\vo</code> or <code>:GrepOptions</code>: 打开选项菜单;</li></ul><p>GrepOptions打开的界面:<br><img src="/images/2014-10-24/EasyGrep.png" alt="图1: GrepOptions打开的界面"><br>上方红色的是快捷键help, 比如<code>q</code>是退出GrepOptions, <code>r</code>是开启递归搜索…<br>下方兰色的可以选择搜索范围(回车选择): All表示全部搜索, Buffer表示只搜索当前打开的buff, TrackExt几乎包括所有常见的文件类型, 比如C++, PHP, Lisp等源文件. User是自己制定文件类型.</p><h2 id="Options-Details"><a href="#Options-Details" class="headerlink" title="Options Details"></a>Options Details</h2><p>每个Option的解释可以参考Github上的<a href="https://github.com/vim-scripts/EasyGrep/blob/master/doc/EasyGrep.txt" target="_blank" rel="noopener">README</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &quot; plugin::EasyGrep &#123;</span><br><span class="line">   let g:EasyGrepCommand = 1    &quot; vimgrep:0, grep:1 #vimgrep搜索较慢, 在Win上无需安装grep.exe</span><br><span class="line">   let g:EasyGrepMode = 2       &quot; All:0, Open Buffers:1, TrackExt:2 # 1表示在已打开的buff中搜索, 2表示在当前文件相同扩展名的文件中搜索</span><br><span class="line">   let g:EasyGrepRecursive  = 1 &quot; Recursive searching 递归搜索</span><br><span class="line">let g:EasyGrepRoot = cwd &quot; 设置搜索根路径, cwd:current dir</span><br><span class="line">   let g:EasyGrepRoot = &quot;search:.git,.svn&quot; 设置搜索根路径为git/svn repos的根路径</span><br><span class="line">let g:EasyGrepRoot = &quot;search:.project&quot; 设置搜索根路径为包含.project文件的目录,这个文件需手动创建</span><br><span class="line">   let g:EasyGrepIgnoreCase = 1 &quot; Not ignore:0, ignore:1 大小写敏感</span><br><span class="line">   let g:EasyGrepFilesToExclude = &quot;tags, *.bak, *~, cscope.*, *.a, *.o, *.pyc, *.bak, *.swp&quot;</span><br><span class="line">   &quot; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> EasyGrep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还是告别 Linux Desktop了</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91%E8%BF%98%E6%98%AF%E5%91%8A%E5%88%ABLinux-Desktop%E4%BA%86/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91%E8%BF%98%E6%98%AF%E5%91%8A%E5%88%ABLinux-Desktop%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>用了几年Ubuntu,还有Fedora.曾经认为*nix的一切概念都比Windows更加合理. 但是… 折腾了这么久, 我还是决定换回Windows了.</p><p>至于原因,简单的解释就是: 无论哪个桌面OS都只是工具而已,在”折腾工具”上花费太多时间本身已经违背了工具被设计出来的初衷, 无论那个Linux桌面发行版(作为日常使用OS)距离”好用”还是有相当的差距.</p><ul><li>比如Chrome for Linux版本播放flash的渣性能;</li><li>功耗控制的不完善,就算装了Tlp/Powertop,仍旧比不上Windows上Thinkpad自带的PowerManager;</li><li>双显卡虽然有Bumblebee,但性能还是比不上NVIDIA Optimus一半;</li><li>多少开源的中文字体, 在Chrome上居然都不如微软的雅黑表现出色…</li><li>此外,还有Thinkpad的指纹识别,APS硬盘保护(老朽的HDAPS已经不能支持新款的Tp了). 值得吐槽的地方还有很多很多, 没法一一举例.</li></ul><p>当你在google,stackexchange上查了好多答案,折腾了许久,却发现只实现了Windows上同等功能(可能还不及),这是多么败兴的事情-.-</p><p>上面提到的,或许有些人不赞同是Linux自身的原因,而是因为”大多数硬件厂商对Linux支持不够”. 唉,说直白一点, 桌面Linux败就败在了生态环境上. 无论Linux在服务器上表现如何, 都救不了Linux Desktop.</p><p>据说DELL有一款XPS开发者版本预装Ubuntu,不知道DELL和 Canonical最终合作的如何, 我猜很可能不了了之, 双方都没有动力和理由花费太多的时间和精力把这个做好. 唉.</p><hr><p>顺带吐槽几个著名发行版:</p><ul><li>因为Ubuntu的淳朴乡村风紫棕配色感到烦恼，并且Unity的Lens Dash让我不胜其烦，除了会让我硬盘转个不停泄露我的隐私之外几乎没任何作用。格了，重装。</li><li>Gnome3,又是一个不想多评价的东西, Active简直就是设计中的败笔, 非得按一下Alt+Tab键才能看到正在运行的程序, 或者委屈一下右手里捂着的鼠标不辞千里从屏幕的某个角落飞奔到屏幕右上角。艹，如果我一次开了十个程序，切换一次简直就是灾难。难道非得让我回到石器时代的Gnome Classic ???</li><li>OK, No Ubuntu，No Gnome，那就尝试下Fedora 21 KDE, 但Fedora 21仍旧采用上世纪90年代城乡接合范儿金属拉丝style的UIKDE4。并且Fedora的KDE版本大有向Kubuntu靠拢的趋势，从Fedora 21 KDE让我感觉到了KDE正在被Fedora社区渐渐冷落，等到新版本发布时连个像样的KDE Spin都拿不出来，正当我看着几年都无长进的Fedora KDE寻思着要不要继续重装时，KDE挂掉了，，，</li><li>Gentoo和Arch就是给整天不用上班的重装系统爱好者们折腾消遣的小玩具。</li></ul><p>彻底死心透透的，还是回到Windows7吧, 加上Cygwin足够了<br><code>Linux for Desktop</code>只是一种情怀而已. OS X才是<code>*uix for desktop</code>的最终形态.</p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Desktop </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 的进化 - Zsh</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91Shell%E7%9A%84%E8%BF%9B%E5%8C%96-Zsh/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91Shell%E7%9A%84%E8%BF%9B%E5%8C%96-Zsh/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Zsh和Oh-my-zsh的安装"><a href="#1-Zsh和Oh-my-zsh的安装" class="headerlink" title="(1) Zsh和Oh-my-zsh的安装"></a>(1) Zsh和Oh-my-zsh的安装</h1><h2 id="1-1-install-zsh"><a href="#1-1-install-zsh" class="headerlink" title="(1.1) install zsh"></a>(1.1) install zsh</h2><p>OSX自带了zsh，不必再安装. 对于Redhat系/Debian系的Linux，使用yum/apt-get工具安装: <code>sudo -c &#39;yum install zsh&#39;</code>.</p><h2 id="1-2-install-oh-my-zsh"><a href="#1-2-install-oh-my-zsh" class="headerlink" title="(1.2) install oh-my-zsh"></a>(1.2) install oh-my-zsh</h2><p>方式1 自动安装:<br><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code><br>方式2 手动安装:<br><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code><br><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></p><h1 id="2-切换到zsh"><a href="#2-切换到zsh" class="headerlink" title="(2) 切换到zsh"></a>(2) 切换到zsh</h1><p>已经安装完了zsh和oh-my-zsh，接下来在终端里输入<code>zsh</code>就可以进入了.<br>然后输入<code>chsh</code>把默认的bash切换到zsh，<code>chsh</code>的具体用法可以man.</p><h1 id="3-zsh的简单体验"><a href="#3-zsh的简单体验" class="headerlink" title="(3) zsh的简单体验"></a>(3) zsh的简单体验</h1><p>zsh的自动补全很强大，所有你能想象到的都可以用<code>tab</code>触发补全，甚至kill这样的命令也支持补全了-.-! 比如想kill掉fcitx，直接输入<code>kill fcitx</code>再加<code>tab</code>就可以了，你会看到zsh已经把有关fcitx的进程id都列出来，我觉得时间久了会被zsh的智能补全惯坏，对不对？<br>在.zshrc里加入<code>alias -s c=gvim</code>，就相当于把*.c文件和gvim关联起来了，假如我当前目录下有个test.c文件，在终端直接输入<code>test.c</code>+回车，gvim就自动打开这个文件了，很方便.<br>当然，还支持</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias -s tgz='tar -xzvf'</span><br><span class="line">alias -s bz2='tar -xjvf'</span><br></pre></td></tr></table></figure><p>这样的关联，你再也不必记住<code>tar</code>的z和j参数了!</p><h1 id="4-zsh的主题-插件"><a href="#4-zsh的主题-插件" class="headerlink" title="(4) zsh的主题/插件"></a>(4) zsh的主题/插件</h1><p>zsh的配置文件在<code>~/.zshrc</code>，打开后找到”ZSH_THEME”一行:  <code>ZSH_THEME=&quot;robbyrussell&quot;</code> 修改这里可以改变zsh的主题.<br>更多的主题可以在~/.oh-my-zsh/themes目录找到.</p><p>再找到”plugin”一行:<br><code>plugins=(git ruby autojump mvn gradle)</code><br>上面分别启用了git，ruby，autojump等几个插件. 其中git是默认已经安装的，下面介绍autojump:</p><h2 id="4-1-插件之一autojump"><a href="#4-1-插件之一autojump" class="headerlink" title="(4.1) 插件之一autojump"></a>(4.1) 插件之一autojump</h2><p><a href="https://github.com/joelthelion/autojump" target="_blank" rel="noopener">autojump</a>提供了一个快速切换当前目录的功能，比如我经常使用的目录是~/workspace，在任何目录下只要输入<code>j wo</code>就能自动跳转到~/workspace了.<br>安装步骤:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/joelthelion/autojump.git</span><br><span class="line">cd autojump</span><br><span class="line">python ./install.py</span><br></pre></td></tr></table></figure><p>不要忘记在.zshrc中启用autojump这个插件，并且在.zshrc里加入一行: <code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh</code><br>之后你就能用<code>j 目录名</code>快速切换目录了，甚至不用输入完整的目录名，autojump会根据你的使用习惯记录下常用目录，关于目录优先权重可以用<code>autojump -s</code>查看:</p><blockquote></blockquote><p>22.4:   /home/xxx/Dropbox/Fedora One<br>22.4:   /home/xxx/Github<br>26.5:   /home/xxx/Dropbox</p><h1 id="5-bye，bash"><a href="#5-bye，bash" class="headerlink" title="(5) bye，bash"></a>(5) bye，bash</h1><p>bash再见了，最后备份一下bash的配置<code>cp ~/.bashrc ~/Dropbox/</code><br>我的bash里还有一些有用的东西，比如<a href="https://github.com/dangoakachan/mark-directory" target="_blank" rel="noopener">mark-directory</a>，这个工具有些类似autojump，也是方便你在各个常用目录间跳来跳去的，只不过需要在目录下运行一下<code>mark</code>加”书签”，然后<code>j dir_name</code>跳转，当然也是支持tab补全的，食用方式也很简单，在.bashrc加入下面的配置:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mark-directory: provide a quick way to change directory from the <span class="built_in">command</span> line</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> github.com/dangoakachan/mark-directory</span></span><br><span class="line">export MARKPATH=$HOME/.marks</span><br><span class="line">function j &#123;</span><br><span class="line">    cd -P "$MARKPATH/$1" 2&gt;/dev/null || echo "No such mark: $1"</span><br><span class="line">&#125;</span><br><span class="line">function mark &#123;</span><br><span class="line">    mkdir -p "$MARKPATH"; ln -s "$(pwd)" "$MARKPATH/$1"</span><br><span class="line">&#125;</span><br><span class="line">function unmark &#123;</span><br><span class="line">    rm -i "$MARKPATH/$1"</span><br><span class="line">&#125;</span><br><span class="line">function marks &#123;</span><br><span class="line">    ls -l "$MARKPATH" | sed 's/  / /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' &amp;&amp; echo</span><br><span class="line">&#125;</span><br><span class="line">_completemarks() &#123;</span><br><span class="line">    local curw=$&#123;COMP_WORDS[COMP_CWORD]&#125;</span><br><span class="line">    local wordlist=$(find $MARKPATH -type l -printf "%f\n")</span><br><span class="line">    COMPREPLY=($(compgen -W '$&#123;wordlist[@]&#125;' -- "$curw"))</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line">complete -F _completemarks j unmark</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
            <tag> Zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Linux 上安装 BitTorrent Sync</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E5%9C%A8Linux%E4%B8%8A%E5%AE%89%E8%A3%85BitTorrent-Sync/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E5%9C%A8Linux%E4%B8%8A%E5%AE%89%E8%A3%85BitTorrent-Sync/</url>
      
        <content type="html"><![CDATA[<p>BitTorrent Sync是一款同步工具，和Dropbox/Google Drive这些云存储的区别是，BitTorrent Sync不用连接服务器，而是基于P2P分布式进行设备和设备之间的文件同步，支持PC（Win/Linux/Mac），FreeBSD，Android，iOS设备。<br>用BitTorrent Sync可以方便的在同一局域网里的PC/智能设备之间同步文件。</p><h2 id="1-下载-amp-安装："><a href="#1-下载-amp-安装：" class="headerlink" title="1.下载&amp;安装："></a>1.下载&amp;安装：</h2><p>两种安装方式：通过PPA安装，或直接下载二进制文件。</p><h3 id="1-1-方式1"><a href="#1-1-方式1" class="headerlink" title="1.1 方式1"></a>1.1 方式1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:tuxpoldo/btsync</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install btsync-user</span><br></pre></td></tr></table></figure><h3 id="1-2-方式2"><a href="#1-2-方式2" class="headerlink" title="1.2 方式2"></a>1.2 方式2</h3><p>在<a href="http://www.bittorrent.com/sync/downloads" target="_blank" rel="noopener">BitTorrent Sync官网</a>下载对应的二进制包，然后解压：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Downloads</span><br><span class="line">tar xvzf btsync_x64.tar.gz -C /opt</span><br></pre></td></tr></table></figure></p><h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2.启动"></a>2.启动</h2><p>如果用1.2的方式安装，需要把对应路径加入$PATH,<br>然后在终端输入<code>btsync</code>即可启动；</p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><p>完整的config可以参考：<code>btsync  --dump-sample-config</code><br>在浏览器内打开：<code>http://127.0.0.1:8888/gui/</code><br>或者编辑<code>/etc/btsync/</code>下的配置文件</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://askubuntu.com/questions/284683/how-to-run-bittorrent-sync/296130#296130" target="_blank" rel="noopener">How to run BitTorrent Sync?</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> BitTorrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的编译与链接 - gcc,ld,ar等工具的介绍</title>
      <link href="/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
      <url>/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>这篇半成品已经在硬盘上放了好久了, 今天终于忍无可忍, 熬夜也要写完(▔皿▔)<br>起因是因为一个makefile引起的 <code>undefined reference</code> 问题, 下面贴出出错的makefile:</p><h1 id="起因：Makefile错误"><a href="#起因：Makefile错误" class="headerlink" title="起因：Makefile错误"></a>起因：Makefile错误</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line">LD = ldd</span><br><span class="line"></span><br><span class="line">$(CPP_OBJS): $(DIR_OBJ)/%.o: %.cpp</span><br><span class="line">$(CXX) $(CFLAGS) -o $@ $&lt; $(INCLUDE)</span><br><span class="line"></span><br><span class="line">$(OBJS): $(DIR_OBJ)/%.o: %.c</span><br><span class="line">$(CC) -c $(CFLAGS) -o $@ $&lt; $(INCLUDE)</span><br><span class="line"></span><br><span class="line">$(APP): $(OBJS) $(CPP_OBJS)</span><br><span class="line">$(CC) $^ -o $(APP) $(LDFLAGS) $(INCLUDE)</span><br></pre></td></tr></table></figure><p>这个makefile很简单，g++将<em>.cpp文件编译为 \</em>.o, gcc将 *.c 文件编译为 *.o, 最后 gcc链接所有的 *.o生成可执行程序.<br>但是上面这个简单的 makefile, 执行make时却报错了:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gcc   -o _test_code.o _test_code.c -I.</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.7.2/../../../../lib64/crt1.o: In function &apos;_start&apos;:</span><br><span class="line">(.text+0x20): undefined reference to &apos;main&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h1 id="错误分析-amp-解决"><a href="#错误分析-amp-解决" class="headerlink" title="错误分析 &amp; 解决"></a>错误分析 &amp; 解决</h1><p>要解释上面的问题, 先来回顾下gcc是如何将*.c编译为可执行程序的, 共4个步骤:</p><ol><li>预编译: <code>gcc -E test.c -o test.i</code></li><li>生成汇编代码: <code>gcc -S test.i -o test.s</code></li><li>编译 x.s为 x.o:  <code>gcc -c test.s -o test.o</code> 当然 x.c也可以用 <code>-c</code>参数一步编译为 x.o</li><li>链接为可执行文件: <code>gcc test.o -o test</code></li></ol><p>报错很明确的告诉我: lib64/crt1.o 里的<code>_start</code>函数调用了<code>main()</code>函数, 但<code>main()</code>函数缺少定义.<br>工程中<code>main()</code>函数的定义放在源文件 main.cpp中, 为什么还报 undefined reference to ‘main’呢?<br>看仔细了, 是在将 test_code.cpp编译为 test_code.o的时候报错, test_code.cpp里没有<code>main()</code>的定义,<br>这个 makefile的”本意”是这样的: 第一步 g++将 x.cpp文件编译为 x.o, 第二步 gcc将 x.c文件编译为 x.o, 最后 gcc链接所有的 x.o生成可执行程序.<br>按道理说, 第一步编译只是进行语法分析并生成中间文件, 并不会去找函数有没有定义, 只有在三步链接所有 x.o的时候才可能报出 undefined reference func的错误.<br>再仔细看看上面的 makefile: <code>$(CXX) $(CFLAGS) -o $@ $&lt; $(INCLUDE)</code><br>是没有加 <code>-c</code>参数的, 相当于让 g++一步编译出最终文件(可执行文件), 当然会报 undefined reference 的错误了.<br>原来是一个笔误🙃</p><p>修改也很简单, x.c/x.cpp编译为x.o的过程加上 <code>-c</code>参数就可以了, 正确的 makefile如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(CPP_OBJS): $(DIR_OBJ)/%.o: %.cpp</span></span><br><span class="line"><span class="meta">$</span><span class="bash">(CXX) -c $(CFLAGS) -o <span class="variable">$@</span> $&lt; $(INCLUDE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(OBJS): $(DIR_OBJ)/%.o: %.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash">(CC) -c $(CFLAGS) -o <span class="variable">$@</span> $&lt; $(INCLUDE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(APP): $(OBJS) $(CPP_OBJS)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">(CC) $^ -o $(APP) $(LDFLAGS) $(INCLUDE)</span></span><br></pre></td></tr></table></figure><h1 id="错误日志里的新发现"><a href="#错误日志里的新发现" class="headerlink" title="错误日志里的新发现"></a>错误日志里的新发现</h1><p>再回头看看上面的报错里有一句:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lib64/crt1.o: In function &apos;_start&apos;:</span><br><span class="line">(.text+0x20): undefined reference to &apos;main&apos;</span><br></pre></td></tr></table></figure><p>这个 crt1.o是什么? 这个function <code>_start</code> 又是什么🤔?</p><p>从上面的打印信息可以知道, gcc先编译出 xxx.o然后再做 Link, 这时候 gcc会对 /usr/lib/crt1.o和我们的 main.o做链接 (因为 crt1.o里的<code>_start</code>函数调用了我们的 <code>main()</code>函数).<br>由此可见, 可自行文件真正的”入口”并不是 <code>main()</code>, 而是 ctr1.o里的<code>_start</code>, 事实上这个库的名字里 “crt”就是 “startup routine”的意思.<br>所以, gcc在链接所有的 x.o时, 还会把 /usr/lib/crt1.o也链接进来.<br>此外gcc有一个默认参数<code>-lc</code>, 表示动态链接 libc库.</p><blockquote><p>扩展阅读: <a href="https://blog.csdn.net/farmwang/article/details/73477276" target="_blank" rel="noopener">crt1.o,crti.o,crtbegin.o,crtend.o ,crtn.o 与libc.so 的关系 - farmwang的专栏 - CSDN博客</a></p></blockquote><h1 id="编译过程中的链接-ld"><a href="#编译过程中的链接-ld" class="headerlink" title="编译过程中的链接: ld"></a>编译过程中的链接: ld</h1><p>下面是一个分三步编译出 a.out的例子</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -S main.c -o main.s</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c main.s -o main.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc main.o -o a.out</span></span><br></pre></td></tr></table></figure><p>我们知道在编译汇编程序时, 也是分compile,link两个步骤:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br><span class="line">ld hello.o -o hello</span><br></pre></td></tr></table></figure><p>c程序用 gcc链接, 汇编程序用 ld来做链接, 那么这个 ld能不能直接用于 c程序的链接呢?<br>我们可以试一下, 用 ld去链接所有的 x.o : <code>$(LD) $^ -o $(APP) $(LDFLAGS) $(INCLUDE)</code><br>然后<code>make clean &amp;&amp; make all</code>, 会报错:<br>ld: cannot find -lstdc++</p><p>@ref (<a href="http://sp1.wikidot.com/gnulinker" target="_blank" rel="noopener">http://sp1.wikidot.com/gnulinker</a>)</p><h1 id="附录-I"><a href="#附录-I" class="headerlink" title="附录 I"></a>附录 I</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>“编译”的概念： 1、利用编译程序从源语言编写的源程序产生目标程序的过程。 2、用编译程序产生目标程序的动作，编译就是把高级语言变成计算机可以识别的2进制语言。</p><p>编译程序把一个源程序翻译成目标程序的工作分为5个阶段：词法分析、语法分析、语义检查和中间代码生成、代码优化、目标代码生成。主要是进行词法分析和语法分析。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接就是对.o文件进行符号解析和重定位的过程，链接器就是用来完成不同模块之间的链接问题。</p><ul><li><p>符号解析：<br>当一个模块使用了在该模块中没有没有定义过的函数或者全局变量时，编译器生成的符号表会标记出所有这样的函数或者全局变量。而连接器的责任就是要到别的模块中去查找它们的定义，如果没有找到适合的定义或者找到的合适定义不唯一，符号解析就无法正常完成。</p></li><li><p>重定位：<br>编译器在编译生成目标文件时，通常都使用从零开始的相对地址。然而，在链接过程中，连接器将从一个指定的地址开始，根据输入的目标文件的顺序以段为单位将它们一个接一个拼接起来。除了目标文件的拼装之外，在重定位的过程中还完成了两个任务：一是生成最终的符号表；二是对代码段的某些位置进行修改，所有需要修改的位置都由编译器生成的重定位表指出。</p></li></ul><hr><h1 id="附录-II"><a href="#附录-II" class="headerlink" title="附录 II"></a>附录 II</h1><h2 id="GNU-GCC简介："><a href="#GNU-GCC简介：" class="headerlink" title="GNU GCC简介："></a>GNU GCC简介：</h2><p>GNU GCC是一套面向嵌入式领域的交叉编译工具，支持多种编程语言、多种优化选项并且能够支持分步编译、支持多种反汇编方式、支持多种调试信息格式，目前支持X86、ARM7、StrongARM、PPC4XX、MPC8XX、MIPS R3000等多种CPU。<br>GNU GCC的基本功能包括：</p><ol><li>输出预处理后的C/C++源程序（展开头文件和替换宏）</li><li>输出C/C++源程序的汇编代码</li><li>输出二进制目标文件</li><li>生成静态库</li><li>生成可执行程序</li><li>转换文件格式</li></ol><h2 id="GCC-组成："><a href="#GCC-组成：" class="headerlink" title="GCC 组成："></a>GCC 组成：</h2><ul><li><p>(1) C/C++交叉编译器gcc<br>gcc是编译的前端程序，它通过调用其他程序来实现将程序源文件编译成目标文件的功能。<br>编译时，它首先调用预处理程序(cpp)对输入的源程序进行处理，然后调用 cc1 将预处理后的程序编译成汇编代码，最后由as将汇编代码编译成目标代码。gcc具有丰富的命令选项，可以控制编译的各个阶段，满足用户的各种编译需求。</p></li><li><p>(2) 汇编器 as<br>as将汇编语言程序转换为ELF (Executable and Linking Format，执行时链接文件格式)格式的可重定位目标代码，这些目标代码同其它目标模块或函数库易于定位和链接。<br>as产生一个交叉参考表和一个标准的符号表，产生的代码和数据能够放在多个区 (Section)中。</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">as hello.s -o hello.o  #这一步将汇编源码*.s编译为*.o</span><br><span class="line">ld hello.o -o hello    #这一步将*.o链接, 生成ELF</span><br></pre></td></tr></table></figure><ul><li><p>(3) 连接器ld<br>ld根据链接定位文件Linkcmds中的代码区、数据区、BSS区和栈区等定位信息，将可重定位的目标模块链接成一个单一的、绝对定位的目标程序。该目标程序是ELF格式，并且可以包含调试信息。<br>ld会产生一个内存映象文件Map.txt,该文件显示所有目标模块、区和符号的绝对定位地址。它也产生交叉参考列表，显示参考每个全局符号的目标模块。<br>ld支持将多个目标模块链接成一个单一的、绝对定位的目标程序，也能够依此对目标模块进行链接，这个特性称为增量链接(Incremental Linking)。<br>假如输入文件是一个函数库，ld会自动从函数库装载被其它目标模块参考的函数模块。ld与其它链接程序相比，能提供更有帮助的诊断信息。许多链接器遇到第一个错误即放弃链接，而ld只要有可能都继续执行，帮助用户识别其它错误，有时甚至能获得输出代码。</p></li><li><p>(4) 库管理器ar<br>ar将多个可重定位的目标模块归档为一个函数库文件。采用函数库文件，应用程序能够从该文件中自动装载要参考的函数模块，同时将应用程序中频繁调用的函数放入函数库文件中，易于应用程序的开发管理。ar支持ELF格式的函数库文件.</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -c 1.c 2.c 3.c   # 生成1.o, 2.o, 3.o</span><br><span class="line">$ ar rs lib123.a 1.o 2.o 3.o # 将所有*.o打包成lib123.a:</span><br></pre></td></tr></table></figure><ul><li>(5) 工程管理器MAKE<br>Make是用于自动编译、链接程序的实用工具,使用make后就不需要手工的编译每个程序文件。要使用make,首先要编写makefile。<br>Makefile描述程序文件之间的依赖关系，并提供更新文件的命令。在一个程序中，可执行文件依赖于目标文件,而目标文件依赖于源文件。如果makefile文件存在,每次修改完源程序后，用户通常所需要做的事情就是在命令行敲入“make”,然后所有的事情都由make来完成。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终端复用软件 - tmux</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E8%BD%AF%E4%BB%B6-Tmux/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E8%BD%AF%E4%BB%B6-Tmux/</url>
      
        <content type="html"><![CDATA[<h2 id="（一）What‘s-tmux？"><a href="#（一）What‘s-tmux？" class="headerlink" title="（一）What‘s tmux？"></a>（一）What‘s tmux？</h2><p>”tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再”浪费”多余的终端来连接这台远程主机；当然其功能远不止于此。”</p><h2 id="（二）一些概念"><a href="#（二）一些概念" class="headerlink" title="（二）一些概念"></a>（二）一些概念</h2><p>tmux使用C/S模型构建，主要包括以下单元模块：<br>server服务：输入tmux命令时就开启了一个服务器。<br>session会话： 一个服务器可以包含多个会话。<br>window窗口：一个会话可以包含多个窗口。<br>pane面板：一个窗口可以包含多个面板。</p><h2 id="（三）命令-amp-快捷键"><a href="#（三）命令-amp-快捷键" class="headerlink" title="（三）命令&amp;快捷键"></a>（三）命令&amp;快捷键</h2><h3 id="3-1命令参数："><a href="#3-1命令参数：" class="headerlink" title="3.1命令参数："></a>3.1命令参数：</h3><p><code>tmux</code> ： 打开tmux，退出是<code>Ctrl+D</code> ；<br><code>tmux new-session -s &quot;sessionX&quot; -d</code>  ： 开启一个名字为”sessionX”会话，-d参数是将此会话放入后台不显示；<br><code>tmux new-window -n &quot;Win1&quot; -t sessionX &#39;top&#39;</code>   ： -t是指定名为”sessionX”的会话，在这个会话上开启一个窗口并将此窗口命名为”Win1”，并在此窗口执行top命令；<br><code>tmux split-window -h</code>  ： 开启一个竖屏<br><code>tmux split-window -v &quot;top&quot;</code> ： 开启一个横屏,并执行top命令<br><code>tmux attach -t sessionX</code>    ： 重新attach上会话”sessionX”</p><h3 id="3-2快捷键："><a href="#3-2快捷键：" class="headerlink" title="3.2快捷键："></a>3.2快捷键：</h3><p>以下列出的所有命令都需要先按下<code>Ctrl+b</code>，如果你不习惯这个绑定，可以在~/.tmux.conf文件中修改，下面会提及。<br>Now， 打开终端输入<code>tmux</code> ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本快捷键：</span><br><span class="line">---------</span><br><span class="line">?列出所有快捷键；按q返回</span><br><span class="line">d脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话</span><br><span class="line">s选择并切换会话；在同时开启了多个会话时使用</span><br><span class="line">D选择要脱离的会话；在同时开启了多个会话时使用</span><br><span class="line">:进入tmux命令行模式；此时可输入支持的命令，例如kill-server所有tmux会话</span><br><span class="line">[复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出</span><br><span class="line">]进入粘贴模式，粘贴之前复制的内容，按q/Esc退出</span><br><span class="line">~列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</span><br><span class="line">t显示当前的时间</span><br><span class="line">Ctrl+z挂起当前会话</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">窗口操作:</span><br><span class="line">--------</span><br><span class="line">c创建新窗口</span><br><span class="line">&amp;关闭当前窗口</span><br><span class="line">数字键切换到指定窗口</span><br><span class="line">p切换至上一窗口</span><br><span class="line">n切换至下一窗口</span><br><span class="line">l前后窗口间互相切换</span><br><span class="line">w通过窗口列表切换窗口</span><br><span class="line">,重命名当前窗口，便于识别</span><br><span class="line">.修改当前窗口编号，相当于重新排序</span><br><span class="line">f在所有窗口中查找关键词，便于窗口多了切换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">面板操作:</span><br><span class="line">-------</span><br><span class="line">”将当前面板上下分屏</span><br><span class="line">%将当前面板左右分屏</span><br><span class="line">x关闭当前分屏</span><br><span class="line">方向键移动光标选择对应面板</span><br><span class="line">空格键可以在默认面板布局中切换，试试就知道了</span><br><span class="line">!将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板</span><br><span class="line">Ctrl+方向键以1个单元格为单位移动边缘以调整当前面板大小</span><br><span class="line">Alt+方向键以5个单元格为单位移动边缘以调整当前面板大小</span><br><span class="line">q显示面板编号</span><br><span class="line">o选择当前窗口中下一个面板</span><br><span class="line">&#123;向前置换当前面板</span><br><span class="line">&#125;向后置换当前面板</span><br><span class="line">Alt+o逆时针旋转当前窗口的面板</span><br><span class="line">Ctrl+o顺时针旋转当前窗口的面板</span><br><span class="line">ztmux 1.8新特性，最大化当前所在面板</span><br></pre></td></tr></table></figure></p><h3 id="粘贴-amp-复制："><a href="#粘贴-amp-复制：" class="headerlink" title="粘贴&amp;复制："></a>粘贴&amp;复制：</h3><p>请参考：<a href="http://jasonwryan.com/blog/2011/06/07/copy-and-paste-in-tmux/" target="_blank" rel="noopener">Copy &amp; Paste in tmux</a></p><h3 id="滚屏："><a href="#滚屏：" class="headerlink" title="滚屏："></a>滚屏：</h3><p><code>Ctrl+b，pageUp/pageDown</code>进入翻页模式，此模式下可以用”上下翻页键”or”上下方向键”翻页，<code>q</code>是退出翻页模式。</p><h2 id="（四）配置文件"><a href="#（四）配置文件" class="headerlink" title="（四）配置文件"></a>（四）配置文件</h2><p>用户配置文件在~/.tmux.conf ，下面是一个示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#此类配置可以在命令行模式中输入show-options -g查询</span><br><span class="line">set-option -g base-index 1                        #窗口的初始序号；默认为0，这里设置为1</span><br><span class="line">set-option -g display-time 5000                   #提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒</span><br><span class="line">set-option -g repeat-time 1000                    #控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒</span><br><span class="line">set-option -g status-keys vi                      #操作状态栏时的默认键盘布局；可以设置为vi或emacs</span><br><span class="line">set-option -g status-right &quot;#(date +%H:%M&apos; &apos;)&quot;    #状态栏右方的内容；这里的设置将得到类似23:59的显示</span><br><span class="line">set-option -g status-right-length 10              #状态栏右方的内容长度；建议把更多的空间留给状态栏左方（用于列出当前窗口）</span><br><span class="line">set-option -g status-utf8 on                      开启状态栏的UTF-8支持</span><br><span class="line"></span><br><span class="line">#此类设置可以在命令行模式中输入show-window-options -g查询</span><br><span class="line">set-window-option -g mode-keys vi    #复制模式中的默认键盘布局；可以设置为vi或emacs</span><br><span class="line">set-window-option -g utf8 on         #开启窗口的UTF-8支持</span><br><span class="line"></span><br><span class="line">#将激活控制台的快捷键由Ctrl+b修改为Ctrl+a</span><br><span class="line">set-option -g prefix C-a</span><br><span class="line">unbind-key C-b</span><br><span class="line">bind-key C-a send-prefix</span><br><span class="line"></span><br><span class="line">#添加自定义快捷键</span><br><span class="line">bind-key z kill-session                     #按z结束当前会话；相当于进入命令行模式后输入kill-session</span><br><span class="line">bind-key h select-layout even-horizontal    #按h将当前面板布局切换为even-horizontal；相当于进入命令行模式后输入select-layout even-horizontal</span><br><span class="line">bind-key v select-layout even-vertical      #按v将当前面板布局切换为even-vertical；相当于进入命令行模式后输入select-layout even-vertical</span><br></pre></td></tr></table></figure></p><h2 id="（五）远程使用tmux"><a href="#（五）远程使用tmux" class="headerlink" title="（五）远程使用tmux"></a>（五）远程使用tmux</h2><p>例如我已经在树莓派服务器上打开了一个tmux session，然后detach session；当再次SSH登录树莓派的时候可以用下面的命令重新attach上去，以便恢复上次的工作状态。：<br><code>ssh pi@192.168.1.107 -t &#39;tmux list-session; if [[ $? -eq  0 ]]; then tmux attach; else tmux;fi&#39;</code></p><p>参考： <a href="https://wiki.freebsdchina.org/software/t/tmux" target="_blank" rel="noopener">FreeBSDChina Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的 SSH KEY 配置</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%91Git%E7%9A%84SSH%20Key%E9%85%8D%E7%BD%AE/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%91Git%E7%9A%84SSH%20Key%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h3><ul><li>生成SSH KEY: <code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code> , 然后会提示输入公钥的名字，如果你需要多个SSH-KEY（比如有多个github帐号）就需要在命名的时候区分一下，这样在/用户HOME目录/.ssh/文件夹下生成两个文件：xxx_rsa.pub和 xxx_rsa，分别是你的公钥和私钥。</li><li>生成SSH KEY的时候还要求输入私钥密码 “Enter passphrase (empty for no passphrase):”， 请记住私钥的密码，后面会用到。</li><li>将SSH 私钥增加到ssh-agent: <code>ssh-add ~/.ssh/id_rsa</code>， 这里会提示输入一次私钥的密码;</li><li>查看已经add的SSH KEY： <code>ssh-add -l</code>；</li><li>如果提示 ssh agent没启动: eval <code>ssh-agent -s</code></li><li>非必要步骤: <del>安装xclip(终端到剪切板的工具)</del>: <code>sudo yum install xclip</code> , <del>将公钥内容拷贝到剪切板</del>: <code>xclip -sel clip &lt; ~/.ssh/id_rsa.pub</code></li><li>浏览器登录自己的github页面，进入”Account Settings”，再点击左边的”SSH Key”可以看到自己上传过的SSH公钥列表。再点击”Add SSH Key”新增一个公钥，把公钥(~/.ssh/id_rsa.pub) 文件内容粘贴过来。</li></ul><h3 id="测试SSH-Key登录"><a href="#测试SSH-Key登录" class="headerlink" title="测试SSH Key登录"></a>测试SSH Key登录</h3><ul><li>打开终端, 测试: <code>ssh -T git@github.com</code>;<br>你可能会看到下面的错误信息:</li></ul><blockquote><p>Agent admitted failure to sign using the key.<br>debug1: No more authentication methods to try.<br>Permission denied (publickey).</p></blockquote><p>上面的错误在某些Linux发行版（比如我的Fedora 17）是一个已知的错误， 可以忽略。<br>然后会看到打印出公钥的指纹，请确认此指纹和你公钥的一致，然后输入”yes”确认。</p><blockquote><p>“ Hi your_name! You’ve successfully authenticated, but GitHub does not provide shell access.”</p></blockquote><p>如果your_name正确显示你的ID，则说明成功设置了SSH公钥.</p><h3 id="一台机器上管理多个SSH-Key"><a href="#一台机器上管理多个SSH-Key" class="headerlink" title="一台机器上管理多个SSH Key"></a>一台机器上管理多个SSH Key</h3><p>如果你在一台机器使用两个github账号（比如私人账号和工作账号）, 两个帐号用不同的SSH KEY，还需要编辑一下配置文件~/.ssh/config:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host code.company.com</span><br><span class="line">    HostName code.company.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/key_for_company</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/key_for_github</span><br></pre></td></tr></table></figure><p>解释此配置文件：</p><ul><li>HostName：比如我工作的git仓储地址是<a href="mailto:`git@code.company.com" target="_blank" rel="noopener">`git@code.company.com</a>:username/repo_name.git<code>, 那么我的HostName就要填</code>code.company.com`;</li><li>IdentityFile： 所使用的公钥文件;</li></ul><p>配置完毕，用下面的命令测试一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -vT git@github.com</span><br><span class="line">Hi xyz! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>注： @符号后面的”github.com”就是在~/.ssh/config文件中指定的<code>Host</code>项</p><h4 id="1-为已经clone下来的repos指定ssh-key："><a href="#1-为已经clone下来的repos指定ssh-key：" class="headerlink" title="(1) 为已经clone下来的repos指定ssh-key："></a>(1) 为已经clone下来的repos指定ssh-key：</h4><p>在已经检出的repos目录下执行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config user.name your_name &amp;&amp; git config user.email your_email</span><br></pre></td></tr></table></figure><p>上面<code>git config</code>只对该项目生效</p><p>修改.git/config并找到<code>[remote &quot;origin&quot;]</code>,修改<code>url</code>的值为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:&lt;user_name&gt;/&lt;repos_name&gt;.git</span><br></pre></td></tr></table></figure><h4 id="2-使用指定ssh-key-重新clone一个reop"><a href="#2-使用指定ssh-key-重新clone一个reop" class="headerlink" title="(2) 使用指定ssh-key 重新clone一个reop:"></a>(2) 使用指定ssh-key 重新clone一个reop:</h4><ol><li>使用指定账号clone:<br>执行<code>git clone git@github.com:user_name/repos_name.git</code></li></ol><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:user_name/repos_name.git<br>Cloning into ‘repos_name’…</p></blockquote><ol start="2"><li>然后还需要config一下user.name和user.email, 进入本地git仓库目录执行:</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config user.name your_name &amp;&amp; git config user.email your_email</span><br></pre></td></tr></table></figure><p>以后在此repos下执行<code>git push origin master</code>就是使用指定的用户push.</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://code.tutsplus.com/tutorials/quick-tip-how-to-work-with-github-and-multiple-accounts--net-22574" target="_blank" rel="noopener">《Quick Tip: How to Work with GitHub and Multiple Accounts》</a><br><a href="https://gist.github.com/jexchan/2351996" target="_blank" rel="noopener">《Multiple SSH Keys settings for different github account》</a><br><a href="http://www.cnblogs.com/mackxu/p/ssh-keygen.html" target="_blank" rel="noopener">《多个github帐号的SSH key切换》</a><br><a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="noopener">《GitHub: Generating SSH Keys》</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> SSH </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 协议简介</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91SSH%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91SSH%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="关于SSH协议"><a href="#关于SSH协议" class="headerlink" title="关于SSH协议:"></a>关于SSH协议:</h1><p>Secure Shell（缩写为SSH）,SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。<br>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。<br>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。<br>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。</p><p>以上来自 <a href="http://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">维基百科:SSH</a></p><h1 id="SSH的应用"><a href="#SSH的应用" class="headerlink" title="SSH的应用"></a>SSH的应用</h1><p>SSH最常见的就是远程登录了，替代了不安全的telnet方式，使用ssh远程登录的方式很简单，在终端输入<code>ssh user@host</code>就可以登录到远程主机了。<br>除了“远程登录”这个基本功能之外，SSH还有端口转发、口令登录、公钥登录等用途。</p><h2 id="（一）SSH端口转发"><a href="#（一）SSH端口转发" class="headerlink" title="（一）SSH端口转发"></a>（一）SSH端口转发</h2><p>SSH 还同时提供了一个非常有用的功能，这就是端口转发。SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。SSH 端口转发能够提供两大功能：</p><ol><li>加密 SSH Client 端至 SSH Server 端之间的通讯数据。</li><li>突破防火墙的限制完成一些之前无法建立的 TCP 连接。</li></ol><h3 id="1-1例：使用SSH端口转发翻越GFW"><a href="#1-1例：使用SSH端口转发翻越GFW" class="headerlink" title="1.1例：使用SSH端口转发翻越GFW"></a>1.1例：使用SSH端口转发翻越GFW</h3><p>首先， 你要现在互联网上申请一个免费的SSH, 我用的是<a href="http://shell.cjb.net/" target="_blank" rel="noopener">cjb</a> . 申请完成后会得到邮件发来的 <em>SSH主机地址</em> 和 <em>帐号密码</em> , 然后打开终端输入<code>ssh -D 9999 xxxxx@216.194.70.6</code>：</p><blockquote></blockquote><p>$ ssh -D 9999 <a href="mailto:xxxxx@216.194.70.6" target="_blank" rel="noopener">xxxxx@216.194.70.6</a><br>The authenticity of host ‘216.194.70.6 (216.194.70.6)’ can’t be established.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘216.194.70.6’ (RSA) to the list of known hosts.<br><a href="mailto:xxxx@216.194.70.6" target="_blank" rel="noopener">xxxx@216.194.70.6</a>‘s password:</p><p>参数<code>-D</code>的意思就是bind，端口绑定。上面<code>ssh -D 9999</code>即是指明将SSH数据转发到端口9999。<br>顺带一提，由于shell.cjb.net的域名被污染, 所以上面SSH登录时没有使用cjb.net的域名只能用ip地址。<br>浏览器以Firefox为例，在代理设置中新增一个SOCKS主机 127.0.0.1，端口9999，类型SOCKS v5。<br>此外开启Firefox的用隧道解析DNS开关：在FF地址栏输入<code>about:config</code>，搜索并设置参数<code>network.proxy.socks_remote_dns</code>的值为<code>true</code>(双击即可改变其值)。<br>现在打开<a href="twitter.com">Twitter</a>测试一下吧。</p><p>有关SSH端口转发的内容还可以IBM developerworks上的参考:<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/index.html" target="_blank" rel="noopener">实战 SSH 端口转发</a></p><h2 id="（二）口令登录"><a href="#（二）口令登录" class="headerlink" title="（二）口令登录"></a>（二）口令登录</h2><p>整个过程简单描述如下：<br>（1）远程主机收到用户的登录请求，把自己的公钥发给用户。<br>（2）用户使用这个公钥，将登录密码加密后，发送回来。<br>（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p><p>使用命令<code>ssh user@host</code> 或者<code>ssh -p 指定端口 user@host</code>命令登录, 如果是第一次登录, 会收到下面的警告:</p><blockquote></blockquote><p>The authenticity of host ‘host (12.18.429.21)’ can’t be established.<br>RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.<br>Are you sure you want to continue connecting (yes/no)?</p><p>上面一段话的意思是: 无法确认host主机的真实性，只知道它的公钥指纹，是否继续?<br>用户可以从host的网站或者其他公开信息的地方获取其公钥的指纹, 然后自己核对.</p><p>当用户接受connect后, 就相当于远程主机host的公钥被接受了，远程主机的公钥就会被保存在本机文件$HOME/.ssh/known_hosts之中。下次再连接这台远程主机就会跳过上面的警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h2 id="（三）公钥登录"><a href="#（三）公钥登录" class="headerlink" title="（三）公钥登录"></a>（三）公钥登录</h2><p>过程如下:<br>(1)用户将自己的公钥储存在远程主机上。<br>(2)用户登录的时候，远程主机会向用户发送一段验证字符串，<br>(3)用户用自己的私钥加密后，再发回远程主机。远程主机用事先储存的用户的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>公钥登录的使用也相当广泛，比如Github就使用“公钥登录”的方式, 使用户可以不用输入密码就可以<code>git push</code>代码</p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">阮一峰的博客: SSH原理与运用（一）：远程登录</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> 端口转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非对称加密算法 RSA 简介以及 GPG 工具的使用</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95RSA%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8AGPG%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E3%80%91%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95RSA%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8AGPG%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="非对称加密算法RSA简介"><a href="#非对称加密算法RSA简介" class="headerlink" title="非对称加密算法RSA简介"></a>非对称加密算法RSA简介</h1><p>先来回顾一下”非对称加密算法”的概念, 以下引用自<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">阮一峰的博客</a>:</p><blockquote></blockquote><p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。<br>（2）甲方获取乙方的公钥，然后用它对信息加密。<br>（3）乙方得到加密后的信息，用私钥解密。</p><p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p><p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。</p><h2 id="一-使用GnuPG"><a href="#一-使用GnuPG" class="headerlink" title="一, 使用GnuPG"></a>一, 使用GnuPG</h2><p>GnuPG（英文：GNU Privacy Guard，简称：GPG）<br>GnuPG使用用户自行生成的非对称密钥对来加密信息，由此产生的公钥可以同其他用户以各种方式交换，如密钥服务器。GnuPG还可以向信息添加一个加密的数字签名，这样，收件人可以验证信息完整性和发件人。 (来自维基百科)</p><p>下面介绍使用GnuPG 实现电子邮件加密和数字签名, 参考了<a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">阮一峰的博客</a>, 注意下面关于gpg工具的介绍都是基于命令行的, 其实Gnome和KDE都自带了图形化的密钥管理工具(分别是Seahorse和Kgpg), 这样在新建/管理自己的密钥&amp;&amp; 使用他人的公钥会更加简单, 但是下面我们介绍的还是使用命令行的gpg.</p><h3 id="1-1-安装GnuPG"><a href="#1-1-安装GnuPG" class="headerlink" title="1.1 安装GnuPG"></a>1.1 安装GnuPG</h3><p>在Fedora/CentOS上使用yum安装GnuPG: <code>sudo yum install gnupg</code><br>如果通过源码编译的方式, 可以在这里<a href="http://www.gnupg.org/download/index.en.html" target="_blank" rel="noopener">获取源码</a>. 编译方式三步:</p><blockquote></blockquote><p>./configure<br>make<br>make install</p><h3 id="1-2-生成密钥"><a href="#1-2-生成密钥" class="headerlink" title="1.2 生成密钥:"></a>1.2 生成密钥:</h3><p>输入<code>gpg --gen-key</code>命令生成密钥, 回车后会提示需要生成的密钥类型, 例如:</p><blockquote></blockquote><p>(1) RSA and RSA (default)<br>(2) DSA and Elgamal<br>(3) DSA (仅用于签名)<br>(4) RSA (仅用于签名)</p><p>选择第一个, 表示加密和签名都是RSA算法. 然后命令行提示所需密钥的长度(1024~4096位), 我们这里选择2048(默认值).</p><p>接着是设定密钥有效期, 这里选择”0”, 表示永不过期.</p><p>然后是提供个人信息, 包括 <em>姓名</em>, <em>邮箱</em>, <em>注释</em>, 其中前两项姓名 &amp;&amp; 邮箱是必要的, 注释可以不填写, 输入完成之后gpg会生成一个”用户ID”, 下面是一个生成ID的范例:</p><blockquote><p>“Heinrich Heine <a href="mailto:&#x68;&#x65;&#x69;&#x6e;&#114;&#105;&#99;&#104;&#104;&#64;&#100;&#x75;&#101;&#x73;&#115;&#101;&#x6c;&#100;&#x6f;&#x72;&#102;&#46;&#100;&#x65;" target="_blank" rel="noopener">&#x68;&#x65;&#x69;&#x6e;&#114;&#105;&#99;&#104;&#104;&#64;&#100;&#x75;&#101;&#x73;&#115;&#101;&#x6c;&#100;&#x6f;&#x72;&#102;&#46;&#100;&#x65;</a>“</p></blockquote><p>确认自己的”用户ID”之后, 系统还会要求输入一个私钥的密码, 防止他人使用自己的私钥.</p><blockquote></blockquote><p>You need a Passphrase to protect your secret key.<br>Enter passphrase: </p><p>最后系统开始生成密钥, 期间可能要求你产生一些”随机数”, 解释如下:</p><blockquote></blockquote><p>  我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。</p><p>几分钟后密钥生成, 然后会提示如下:</p><blockquote></blockquote><p>gpg: key 9A69C57C marked as ultimately trusted<br>public and secret key created and signed.</p><p>注意上面的字符串”9A69C57C”，这是我的”用户ID”的Hash字符串，可以用来替代”用户ID”。</p><h3 id="1-3-管理密钥"><a href="#1-3-管理密钥" class="headerlink" title="1.3 管理密钥"></a>1.3 管理密钥</h3><h4 id="1-3-1-查看-删除密钥"><a href="#1-3-1-查看-删除密钥" class="headerlink" title="1.3.1 查看/删除密钥"></a>1.3.1 查看/删除密钥</h4><p>列出系统中存储的密钥: <code>gpg --list-keys</code><br>删除某个密钥: <code>gpg --delete-key [用户ID]</code> , “用户ID”可以是邮件地址或者Hash字符串.</p><h4 id="1-3-2-密钥的导出和存储"><a href="#1-3-2-密钥的导出和存储" class="headerlink" title="1.3.2 密钥的导出和存储"></a>1.3.2 密钥的导出和存储</h4><p>公钥的二进制文件存储在~/.gnupg/pubring.gpg<br>将公钥以ASCII码显示并存储到文本文件public-key.txt中: <code>gpg --armor --output public-key.txt --export [用户ID]</code></p><p>备份自己的公钥: <code>gpg -o public-key --export [用户ID]</code> , 其中-o参数后面是导出的公钥文件名字.<br>备份自己的私钥 : <code>gpg -oa seckey.asc --export-secret-keys [用户ID]</code> ,其中-oa参数后面就是导出的私钥, 可以在其他机器上通过<code>gpg --import seckey.asc</code>导入.</p><h4 id="1-3-3-发布公钥"><a href="#1-3-3-发布公钥" class="headerlink" title="1.3.3 发布公钥"></a>1.3.3 发布公钥</h4><p>因特网上有很多免费的公钥服务器, 你可以把自己的公钥发布到任意一个服务器, 这些服务器之间会互相同步. 命令<code>gpg --send-keys [用户ID] --keyserver hkp://subkeys.pgp.net</code></p><h4 id="1-3-4-获取他人的公钥"><a href="#1-3-4-获取他人的公钥" class="headerlink" title="1.3.4 获取他人的公钥"></a>1.3.4 获取他人的公钥</h4><p>通过email地址获取他人的公钥, <code>gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户ID]</code> .<br>由于公钥服务器没有审查机制, 也就是说任何人都能用你的email名义上传公钥, 获取到他人的公钥后, 还要验证下此公钥的指纹: <code>gpg --fingerprint [用户ID]</code>, 然后可以通过电话/短信/QQ向对方确认指纹, 如果指纹一致就能确认这个公钥是对方所分发的.</p><h3 id="1-4-使用密钥"><a href="#1-4-使用密钥" class="headerlink" title="1.4 使用密钥"></a>1.4 使用密钥</h3><h4 id="1-4-1-使用公钥加密文件"><a href="#1-4-1-使用公钥加密文件" class="headerlink" title="1.4.1 使用公钥加密文件"></a>1.4.1 使用公钥加密文件</h4><p>使用对方的公钥加密文件:<br><code>gpg --recipient [用户ID] --output file.en.txt --encrypt file.txt</code> .<br>参数解释: recipient参数指定接收者的公钥，output参数指定加密后的文件名，encrypt参数指定源文件。</p><h4 id="1-4-2-解密文件"><a href="#1-4-2-解密文件" class="headerlink" title="1.4.2 解密文件"></a>1.4.2 解密文件</h4><p>对方收到加密文件以后用自己的私钥解密:<br><code>gpg --decrypt file.en.txt --output file.de.txt</code><br>参数解释: decrypt参数指定需要解密的文件，output参数指定解密后生成的文件。</p><h4 id="1-4-3-对文件进行签名"><a href="#1-4-3-对文件进行签名" class="headerlink" title="1.4.3  对文件进行签名"></a>1.4.3  对文件进行签名</h4><p>签名的意思就是”证明是公钥所有者分发的”, 命令为<code>gpg --sign file.txt</code> . 运行上面的命令后，当前目录下生成file.txt.gpg文件，这就是签名后的文件.</p><h4 id="1-4-4-验证签名"><a href="#1-4-4-验证签名" class="headerlink" title="1.4.4 验证签名"></a>1.4.4 验证签名</h4><p><code>gpg --verify file.txt.asc file.txt</code></p><h4 id="1-4-4-密钥和邮件客户端的使用"><a href="#1-4-4-密钥和邮件客户端的使用" class="headerlink" title="1.4.4 密钥和邮件客户端的使用"></a>1.4.4 密钥和邮件客户端的使用</h4><p>使用Gnome邮件客户端Evo对邮件进行加密和签名: 参考<a href="http://archboy.org/2013/04/18/gnupg-pgp-encrypt-decrypt-message-and-email-and-digital-signing-easy-tutorial/" target="_blank" rel="noopener">使用 GnuPG 实现电子邮件加密和数字签名——PGP 30分钟简明教程</a>第四部分.</p><p>以及<a href="https://securityinabox.org/zh/thuderbird_encryption" target="_blank" rel="noopener">如何在Thunderbird使用GPG</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
            <tag> RSA </tag>
            
            <tag> GPG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派手动玩(开启SSH,VNC)</title>
      <link href="/50.Farbox-Blog/%E3%80%90Raspberry%E3%80%91%E6%A0%91%E8%8E%93%E6%B4%BE%E6%89%8B%E5%8A%A8%E7%8E%A9/"/>
      <url>/50.Farbox-Blog/%E3%80%90Raspberry%E3%80%91%E6%A0%91%E8%8E%93%E6%B4%BE%E6%89%8B%E5%8A%A8%E7%8E%A9/</url>
      
        <content type="html"><![CDATA[<p>半年前败了一个树莓派，因为工作很忙所以没时间折腾一下。<br>最近换工作，确认了offer，赋闲在家，也终于有空摆弄一下树莓派。</p><h1 id="（一）启用SSH"><a href="#（一）启用SSH" class="headerlink" title="（一）启用SSH"></a>（一）启用SSH</h1><p>我的环境为：Thinkpad（Fedora）， TP-Link无线路由，树莓派（debian）一只。<br>树莓派通过网线连接到无线路由器和电脑处于同一网段，没有显示器的情况下如何确定树莓派的IP呢？ 这时候nmap登场：</p><p><code>nmap -v -sP 192.168.1.1/10</code>稍等片刻，然后可以看到Raspberry Pi的设备。</p><p>或者用手机上的一款应用<a href="https://play.google.com/store/apps/details?id=com.overlook.android.fing&amp;hl=zh_CN" target="_blank" rel="noopener">Fing</a>也可以扫描本网段的端口。</p><p>树莓派默认安装了SSH服务，SSH登录的方式为：<code>ssh pi@树莓派ip地址</code>，默认密码为：<em>raspberry</em></p><p>为了安全, 推荐关闭root用户ssh登录, 方法为修改”/etc/ssh/sshd_config”, 将 <code>PermitRootLogin yes</code> 改为 <code>PermitRootLogin no</code><br>重启ssh服务: <code>service ssh restart</code><br><img src="/images/2014-05-09/ssh-login.png" alt="SSH登录"></p><h1 id="（二）树莓派初始化设置并安装VNC"><a href="#（二）树莓派初始化设置并安装VNC" class="headerlink" title="（二）树莓派初始化设置并安装VNC"></a>（二）树莓派初始化设置并安装VNC</h1><ul><li>SSH上去之后第一件事就是更新debian: <code>sudo apt-get update</code>, 升级完成后重启一下;</li><li><p>在SSH终端输入<code>sudo raspi-config</code>, 这里需要打开几个选项:</p><ol><li>expand_rootfs – 将根分区扩展到整张SD卡;</li><li>change_pass – 默认的用户名是pi，密码是raspberry;</li><li>change_timezone – 更改时区, 选择Asia – Shanghai;</li><li>configure_keyboard, 选English（US）;</li><li>change_locale – 更改语言设置，选择en_US.UTF-8和zh_CN.UTF-8</li><li>设置完成后，选择Finish，会提示是否重启，选择Yes</li></ol></li><li><p>在树莓派上安装vnc服务端（debian）：<code>sudo apt-get install tightvncserver</code></p></li><li>在PC上安装vnc客户端（fedora）：<code>sudo yum -y install tigervnc</code></li><li>如果你的PC是Windows系统, 可以下载<a href="http://www.tightvnc.com/download.php" target="_blank" rel="noopener">TightVNC</a></li><li>安装其他常用软件: <code>sudo apt-get install -y git build-essential vim tmux curl</code></li></ul><h2 id="2-1-在树莓派上配置VNC"><a href="#2-1-在树莓派上配置VNC" class="headerlink" title="2.1 在树莓派上配置VNC"></a>2.1 在树莓派上配置VNC</h2><ul><li>首先要修改vnc密码：SSH终端里执行<code>vncpasswd</code>，然后输入两遍密码。</li><li>创建vnc-server配置文件：<code>sudo vi /etc/init.d/tightvncserver</code> ,在这个文件里输入如下内容：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### BEGIN INIT INFO</span><br><span class="line"># Provides:          tightvncserver</span><br><span class="line"># Required-Start:    $local_fs</span><br><span class="line"># Required-Stop:     $local_fs</span><br><span class="line"># Default-Start:     2 3 4 5</span><br><span class="line"># Default-Stop:      0 1 6</span><br><span class="line"># Short-Description: Start/stop tightvncserver</span><br><span class="line">### END INIT INFO</span><br><span class="line"></span><br><span class="line"># More details see:</span><br><span class="line"># http://www.penguintutor.com/linux/tightvnc</span><br><span class="line"></span><br><span class="line">### Customize this entry</span><br><span class="line"># Set the USER variable to the name of the user to start tightvncserver under</span><br><span class="line">export USER=&apos;pi&apos;</span><br><span class="line">### End customization required</span><br><span class="line"></span><br><span class="line">eval cd ~$USER</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">    su $USER -c &apos;/usr/bin/tightvncserver -depth 16 -geometry 800x600 :1&apos;</span><br><span class="line">    echo &quot;Starting TightVNC server for $USER &quot;</span><br><span class="line">    ;;</span><br><span class="line">  stop)</span><br><span class="line">    su $USER -c &apos;/usr/bin/tightvncserver -kill :1&apos;</span><br><span class="line">    echo &quot;Tightvncserver stopped&quot;</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    echo &quot;Usage: /etc/init.d/tightvncserver &#123;start|stop&#125;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>然后给增加执行权限，并启动服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /etc/init.d/tightvncserver</span><br><span class="line">sudo service tightvncserver stop</span><br><span class="line">sudo service tightvncserver start</span><br></pre></td></tr></table></figure><p>安装chkconfig， 并将vnc服务设为开机启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install chkconfig</span><br><span class="line">chkconfig --add tightvncserver</span><br><span class="line">chkconfig tightvncserver on</span><br></pre></td></tr></table></figure><h2 id="2-2-PC端连接树莓派"><a href="#2-2-PC端连接树莓派" class="headerlink" title="2.2 PC端连接树莓派"></a>2.2 PC端连接树莓派</h2><p>打开VNC Viewer， 输入“IP地址:1”，（这里冒号后面的1是指终端号，如果不填则是终端0）然后回车输入密码。<br><img src="/images/2014-05-09/vnc-viewer-input-ip.png" alt="输入IP：终端号"></p><p>注：如果使用终端0，可能会导致下面的错误</p><blockquote><p>unable connect to socket connection refused 111</p></blockquote><p><img src="/images/2014-05-09/raspiberry-vnc.png" alt="VNC-Viewer"></p><h1 id="（三）摄像头"><a href="#（三）摄像头" class="headerlink" title="（三）摄像头"></a>（三）摄像头</h1><p>树莓派支持两种摄像头，官方的raspberry camera和任何符合UVC标准的USB摄像头。如果要支持摄像头，需要在<code>sudo raspi-config</code>时选择”enable camera”.</p><p>测试摄像头:</p><ul><li>拍摄一张照片<code>raspistill -o cam.jpg</code></li><li>拍摄视频<code>raspivid -o vid.h264</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 简易指北</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%91Git%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%91Git%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>推荐先阅读一下在线版本<em>Git简明指南</em>  <a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">http://rogerdudler.github.io/git-guide/index.zh.html</a></p><p>如果你的一台电脑上管理多个Github帐号的SSH Keys，请参照<a href="http://geeksafari.farbox.com/post/tools/sshxie-yi-de-ying-yong" target="_blank" rel="noopener">SSH协议的应用 &amp;为Github配置SSH Key</a></p><p>Git工作流的概念<br>你的本地仓库由 git 维护的三棵“树”组成。<br>第一个是你的 工作目录，它持有实际文件；<br>第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；<br>最后是 HEAD，它指向你最后一次提交的结果。<br>盗用一下别人的图:<br><img src="http://rogerdudler.github.io/git-guide/img/trees.png" alt=""></p><h2 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1.新建仓库"></a>1.新建仓库</h2><p>首先在github上创建一个新的repository，然后<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/repos_name/</span><br><span class="line">$ touch README.md</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"first commit"</span></span><br><span class="line">$ git remote add origin https://github.com/username/repos_name.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></p><p>如果是已有项目:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd existing_git_repo</span><br><span class="line">git remote add origin https://git.oschina.net/whatsdjgpp/CodeBox.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><h2 id="2-提交代码"><a href="#2-提交代码" class="headerlink" title="2.提交代码"></a>2.提交代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git commit -m <span class="string">"代码提交信息"</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>执行git commit之后只是将改提交到了本地的HEAD, 而git push将改动提交到远端仓库, 可以把 master 换成你想要推送的任何分支.</p><p>如果你还没有克隆现有仓库，又想将代码改动某个远程服务器，你可以使用如下命令添加：<br>git remote add origin <server></server></p><h2 id="3-修改默认值"><a href="#3-修改默认值" class="headerlink" title="3.修改默认值"></a>3.修改默认值</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"xxx"</span></span><br><span class="line">$ git config --global user.email xxx@gmail.com</span><br><span class="line">$ git config --global core.editor gvim</span><br><span class="line">$ git config --global merge.tool gvimdiff</span><br></pre></td></tr></table></figure><p>注意， 这里加了“–global”参数，设置参数会存储在～/.git/config。<br>如果要针对某个仓库进行设置，则是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd repos_dir</span><br><span class="line">git config  user.name &quot;your-id&quot;</span><br><span class="line">git config  user.email &quot;your-id@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>配置会写入“仓库目录/.git/config”</p><h2 id="4-从Git上删除文件"><a href="#4-从Git上删除文件" class="headerlink" title="4.从Git上删除文件"></a>4.从Git上删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">$ rm <span class="string">'test.txt'</span></span><br><span class="line">$ git commit -m <span class="string">"remove test.txt"</span></span><br></pre></td></tr></table></figure><h2 id="5-从服务器获取最新代码"><a href="#5-从服务器获取最新代码" class="headerlink" title="5.从服务器获取最新代码"></a>5.从服务器获取最新代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>相当于两个命令 Git fetch + Git merge, 从服务器的仓库中获取代码，和本地代码合并.</p><h2 id="6-对比代码"><a href="#6-对比代码" class="headerlink" title="6.对比代码"></a>6.对比代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><h2 id="7-检出别人的仓库"><a href="#7-检出别人的仓库" class="headerlink" title="7.检出别人的仓库"></a>7.检出别人的仓库</h2><p>执行如下命令以创建一个本地仓库的克隆版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone /path/to/repository</span><br></pre></td></tr></table></figure></p><p>如果是远端服务器上的仓库，你的命令会是这个样子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone username@host:/path/to/repository</span><br></pre></td></tr></table></figure></p><h2 id="如何让git忽略某些文件"><a href="#如何让git忽略某些文件" class="headerlink" title="如何让git忽略某些文件"></a>如何让git忽略某些文件</h2><p>在本地仓库目录新建.gitignore文件并添加以下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj\</span><br><span class="line">*.so</span><br><span class="line">*.o</span><br><span class="line">*.swp</span><br></pre></td></tr></table></figure></p><p>将会自动忽略目录“obj”，以及<em>.so，</em>.o等类型的文件</p><h2 id="如果你手误了…"><a href="#如果你手误了…" class="headerlink" title="如果你手误了…"></a>如果你手误了…</h2><p>干掉本地的改动, 以服务器上的代码为准:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></p><h2 id="分支概念"><a href="#分支概念" class="headerlink" title="分支概念"></a>分支概念</h2><p>Git在创建仓储的时候, 默认有一个”master”分支, 可以在”master”上拉出分支, 修改完成后再merge到master上.<br>创建一个叫做“feature_x”的分支，并切换过去：git checkout -b feature_x<br>切换回主分支：git checkout master<br>再把新建的分支删掉：  git branch -d feature_x<br>除非你将分支推送到远端仓库，不然该分支就是不为他人所见的：git push origin <branch><br><img src="http://rogerdudler.github.io/git-guide/img/branches.png" alt=""></branch></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> SSH </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下配置 NFS 服务</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91Linux%E4%B8%8B%E9%85%8D%E7%BD%AENFS%E6%9C%8D%E5%8A%A1/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91Linux%E4%B8%8B%E9%85%8D%E7%BD%AENFS%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>环境: Fedora &amp; Ubuntu</p><h2 id="安装NFS服务"><a href="#安装NFS服务" class="headerlink" title="安装NFS服务"></a>安装NFS服务</h2><blockquote><p>yum -y install nfs-utils</p></blockquote><p>对于Ubuntu则是:</p><blockquote><p>apt-get install nfs-kernel-server nfs-common</p></blockquote><p>以上都需要root权限.</p><h2 id="配置NFS"><a href="#配置NFS" class="headerlink" title="配置NFS"></a>配置NFS</h2><p>编辑 /etc/exports, 添加如下内容:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/steffan/nfs *(insecure,rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure></p><p>注意星号<code>*</code>表示允许所有ip访问, 可以改为自己的ip. 且<code>*</code>后不能有空格, 带空格的话mount的时候会有错误提示<code>mount.nfs: access denied by server while mounting</code></p><p>编辑 /etc/idmapd.conf<br>搜索并修改为Domain为自己的主机名.</p><h2 id="启动NFS"><a href="#启动NFS" class="headerlink" title="启动NFS"></a>启动NFS</h2><p>为了方便做了一个启动NFS的脚本xNFS(适用于Fedora):</p><blockquote></blockquote><p>touch /usr/local/xNFS<br>chmod a+x /usr/local/xNFS</p><p>在xNFS脚本增加以下内容:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;start service...&quot;</span><br><span class="line">systemctl start rpcbind.service</span><br><span class="line">systemctl start nfs-server.service</span><br><span class="line">systemctl start nfs-lock.service</span><br><span class="line">systemctl start nfs-idmap.service</span><br><span class="line"></span><br><span class="line">echo &quot;enable service...&quot;</span><br><span class="line">systemctl enable rpcbind.service</span><br><span class="line">systemctl enable nfs-server.service</span><br><span class="line">systemctl enable nfs-lock.service</span><br><span class="line">systemctl enable nfs-idmap.service</span><br><span class="line"></span><br><span class="line">echo &quot;check service status&quot;</span><br><span class="line">systemctl status rpcbind.service</span><br><span class="line">systemctl status nfs-server.service</span><br><span class="line">systemctl status nfs-lock.service</span><br><span class="line">systemctl status nfs-idmap.service</span><br></pre></td></tr></table></figure><p>对于Ubuntu,用下面的命令启动NFS服务:</p><blockquote></blockquote><p>sudo /etc/init.d/portmap start<br>sudo /etc/init.d/nfs-kernel-server start</p><h2 id="测试NFS"><a href="#测试NFS" class="headerlink" title="测试NFS"></a>测试NFS</h2><p>以NFS将本地目录挂载到/mnt:</p><blockquote></blockquote><p>mount -t nfs localhost:/home/steffan/nfs /mnt/nfs</p><p>测试下/mnt/nfs是否能正常读写.</p><p>如果在树莓派等开发板上挂载NFS目录:</p><blockquote></blockquote><p>mount x.x.x.x:/home/steffan/nfs /mnt/nfs</p><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><p>Fedora上可以安装图形化NFS配置工具:</p><blockquote></blockquote><p>yum search system-config-nfs</p><p>如果mount失败, 可以考虑暂时关闭防火墙:<br>开启： <code>service iptables start</code><br>关闭： <code>service iptables stop</code><br>或者这样关闭: <code>/etc/init.d/iptables stop</code></p><p>参考:<br><a href="http://www.server-world.info/en/note?os=Fedora_17&amp;p=nfs" target="_blank" rel="noopener">http://www.server-world.info/en/note?os=Fedora_17&amp;p=nfs</a><br><a href="http://blog.csdn.net/dos5gw/article/details/5787914" target="_blank" rel="noopener">http://blog.csdn.net/dos5gw/article/details/5787914</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 入门指北</title>
      <link href="/50.Farbox-Blog/%E3%80%90Markdown%E3%80%91Markdown%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/"/>
      <url>/50.Farbox-Blog/%E3%80%90Markdown%E3%80%91Markdown%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<h1 id="几种不同的Markdown语法标准"><a href="#几种不同的Markdown语法标准" class="headerlink" title="几种不同的Markdown语法标准"></a>几种不同的Markdown语法标准</h1><ul><li>原生Markdown</li><li>GFM（Github Flavored Markdown）:<ul><li>采用围栏式（Fenced式）区块代码：在代码的上下一行用3个反引号，可选择性定义代码语种，并支持代码高亮。</li><li>列表嵌套方法：改为每次嵌套缩进两个空格。</li><li>支持任务列表：在每个列表项目加入<code>[ ]</code>，完成任务用 <code>[x]</code></li><li>支持简单表格</li></ul></li><li>PFM（Pandoc Flavored Markdown）:<ul><li>支持简单表格、多行表格、格框表格和管线表格四种表格样式</li><li>支持文件标题区块（类似元数据）</li><li>支持上标、下标</li><li>支持数字公式</li><li>支持内嵌TeX</li><li>…</li></ul></li><li>MultiMarkdown<ul><li>支持元数据：标题、作者、日期等信息，兼容部分YAML。</li><li>支持添加链接和图片的属性。</li><li>支持部分复杂表格：兼容PHP Markdown Extra的表格，同时可以——多行表头，单元格横向合并，表格分区，表格下行表格说明等。</li><li>支持脚注：同PHP Markdown Extra中的脚注。</li><li>支持参考文献（Citations）</li><li>…</li></ul></li></ul><p>参考:</p><ul><li><a href="https://sspai.com/post/37270" target="_blank" rel="noopener">不同的Markdown语法 - 少数派</a></li><li><a href="https://www.cnblogs.com/36bian/p/7568015.html" target="_blank" rel="noopener">GFM(GitHub Flavored Markdown)与标准Markdown的语法区别 - 三十六变 - 博客园</a></li></ul><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="0-换行和转义"><a href="#0-换行和转义" class="headerlink" title="(0)换行和转义"></a>(0)换行和转义</h2><p>换行: 文字末尾两个或以上的空格.<br>转义: \</p><h2 id="1-一级-二级题目"><a href="#1-一级-二级题目" class="headerlink" title="(1)一级/二级题目"></a>(1)一级/二级题目</h2><p>一级题目和正文之间用”====”分开<br>如果是二级题目，则用“—-”分开</p><pre><code>题目=====正文</code></pre><h2 id="2-标题"><a href="#2-标题" class="headerlink" title="(2) 标题"></a>(2) 标题</h2><p>Atx-风格的标题在每行的开头使用1－6个#号字符，分别对应标题级别1－6</p><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="(3) 列表"></a>(3) 列表</h2><p>无序列表可使用星号“*”、加号“+”和连字符 “-”</p><pre><code>*   Red*   Green*   Blue</code></pre><p>有序列表用“数字. ”的方式</p><pre><code>1. RED2. GREEN</code></pre><h2 id="4-代码块"><a href="#4-代码块" class="headerlink" title="(4)代码块"></a>(4)代码块</h2><p>在行内插入一句代码的话，将代码用两个<code>包括起来即可</code>，这是夹杂着<code>一些代码</code>的文字内容。<br>在每行开头，或者段落开头使用<code>&gt;</code>符号也可以引用一个段落，直到遇到空行段落结束。<br>如果是代码块，可以在行首增加Tab，注意除了每行开头都有Tab之外， 每行结束也要有两个及以上空格表示一行结束。 代码块在遇到没有TAB缩进的一行，或者文件末尾时自动结束。<br>除此之外还有使用三个”`”，或者<code> </code>的方式包围代码块：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _DEBUG_ENTER(bubble_sort);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;size<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;size-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap_array(&amp;a[j],&amp;a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="(5)引用"></a>(5)引用</h2><p>只需要在行开头增加<code>&gt;</code>符号+空格即可：</p><blockquote><p>这是一行引用的文字</p></blockquote><p>引用结束前要有包括两个以上空格的“空行”作为引用结束的标记。</p><h2 id="6-强调"><a href="#6-强调" class="headerlink" title="(6)强调"></a>(6)强调</h2><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转为粗斜体. 例如:<br><em>强调</em> 或者 _强调_<br><strong>加重强调</strong> 或者 <strong>加重强调</strong></p><h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="(7)超链接"></a>(7)超链接</h2><p>使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接,例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[微博](http://weibo.com)  效果是这样的：</span><br></pre></td></tr></table></figure></p><p><a href="http://weibo.com" target="_blank" rel="noopener">微博</a></p><h2 id="8-图片"><a href="#8-图片" class="headerlink" title="(8)图片"></a>(8)图片</h2><p>使用！[]来放置图片， 例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![sebug.net](http://ssvq5.sinaapp.com/sv4/img/ssv_logo_3ee2.png &quot;sebug.net&quot;) 效果如下</span><br></pre></td></tr></table></figure></p><p><img src="http://ssvq5.sinaapp.com/sv4/img/ssv_logo_3ee2.png" alt="sebug.net" title="sebug.net"></p><h1 id="Markdown历史"><a href="#Markdown历史" class="headerlink" title="Markdown历史"></a>Markdown历史</h1><p>Markdown是一种轻量级标记语言，创始人为John Gruber。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。</p><p>自从John Gruber2004年发布Markdown之后，Markdown进入了自由生长的状态，因为创始人John Gruber打自2004年之后就没有更新过Markdown。因为原生Markdown只是一个轻量级的标记语言，很多功能不具备。为了扩充Markdown的功能，很多Markdown拓展语法被开发出来，其中著名的有GFM、PHP Markdown Extra、MultiMarkdown、Pandoc Markdown（PFM）等等:</p><ul><li>GFM: Github扩展的Markdown语法，这种衍生Markdown叫做Github Flavored Markdown，简称 GFM。与原生Markdown主要区别：<ul><li>采用围栏式（Fenced式）区块代码：在代码的上下一行用3个反引号 ```，可选择性定义代码语种，并支持代码高亮；</li><li>列表嵌套缩进两个空格；</li><li>支持任务列表：<code>[x]</code></li><li>支持简单表格<ul><li>删除线（新增）：用两个波浪号<code>~~</code></li></ul></li></ul></li><li>MultiMarkdown: 原生markdown文档只能从纯文本转换HTML。而MultiMarkdown则是扩大了原生markdown的转换范围，让其可以方便的转换成：HTML/XHTML、LaTeX、OPML。与原生Markdown主要区别：<ul><li>支持YAML元数据</li><li>支持脚注</li><li>支持部分复杂表格</li><li>支持参考文献（Citations）</li><li>支持栅栏式区块代码：上下行3到5个反引号包裹代码</li><li>支持MathJax公式（区块与行内）</li><li>支持上标与下标</li><li>支持目录：<code></code>添加目录</li></ul></li><li>Pandoc’s Markdown（PFM）<ul><li>围栏式区块代码</li><li>区块引用之前一定要预留空行</li><li>…</li></ul></li></ul><p>参考:</p><ul><li><a href="http://www.towdium.me/2016/04/13/about-markdown-pandoc-latex/" target="_blank" rel="noopener">关于 markdown， pandoc 和 LaTeX 的入门安利 - Towdium’s here | A personal blog</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言里面的一些陷阱</title>
      <link href="/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91C%E8%AF%AD%E8%A8%80%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%99%B7%E9%98%B1/"/>
      <url>/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91C%E8%AF%AD%E8%A8%80%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<p>C语言里面的陷阱非常多, 多到写了几年C之后还是会不断的踩, 首先, 本文没多少原创内容, 大部分都来自笔记整理.<br>我们先看几个有关Printf函数的坑：</p><h1 id="坑-Printf（一）"><a href="#坑-Printf（一）" class="headerlink" title="坑: Printf（一）"></a>坑: Printf（一）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面一段代码的打印是什么？</span></span><br><span class="line">   <span class="keyword">int64_t</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a,b);</span><br></pre></td></tr></table></figure><p>运行一下这段代码, 发现打印出来的结果并不是期望的“1 2”, 而是“1 0”, why？<br>这就涉及到 printf 的设计了, printf的第一个参数是字符串, 上面代码中第一个参数是“%d %d”, printf会解析每一个%d这样的结构, 然后将指针做偏移, 偏移的字节数与%后面的类型有关, 例如%d是4字节, %lld是8字节, %c是偏移1字节.<br>所以, 在上面代码中printf(“%d, %d\n”, a, b)实际两个%d分别取得是 a 的低4字节和高4字节, 从而分别是1和0（测试环境是小端, 所以低地址的是LSB）.</p><h2 id="参考-ref"><a href="#参考-ref" class="headerlink" title="参考 @ref"></a>参考 @ref</h2><ul><li><a href="http://www.cnblogs.com/rollenholt/articles/2196492.html" target="_blank" rel="noopener">printf-小代码, 大问题</a></li><li><a href="http://www.cppblog.com/woaidongmao/archive/2009/08/12/93023.html" target="_blank" rel="noopener">从printf谈可变参数函数的实现</a></li></ul><h1 id="坑-Printf（二）"><a href="#坑-Printf（二）" class="headerlink" title="坑:  Printf（二）"></a>坑:  Printf（二）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面一段代码的打印是什么？</span></span><br><span class="line">   <span class="keyword">char</span> c1 = <span class="number">0x70</span>; <span class="comment">// 0111 0000</span></span><br><span class="line">   <span class="keyword">char</span> c2 = <span class="number">0xe0</span>; <span class="comment">// 1111 0000</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"0x%x 0x%x"</span>,c1,c2);</span><br></pre></td></tr></table></figure><p>打印出来的结果并不是期望的“0x70 0xe0”, 而是“70 ffffffe0”,  为什么0x70打印正常, 0xe0打印出的数值前面多了很多ffff呢？<br>原因是： 变参函数, 比如printf, 会把所有精度小于int的参数提升为int, char是有符号8位数, 所以被提升为4字节的int,由于c2的最高位是1（负数）, 所以被提升为ffffffe0<br> 所以, 对于用%x 格式打印下面几个char型都会被提升为int：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char    int</span><br><span class="line">c0 -&gt; ffffffc0</span><br><span class="line">80 -&gt; ffffff80</span><br><span class="line">61 -&gt; 00000061</span><br></pre></td></tr></table></figure><p>解决方法就是用“位与”截取第8位：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="number">0xC0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, ch &amp; <span class="number">0xff</span>);</span><br></pre></td></tr></table></figure><h2 id="参考-ref-1"><a href="#参考-ref-1" class="headerlink" title="参考 @ref"></a>参考 @ref</h2><ul><li><a href="http://stackoverflow.com/questions/8060170/printing-hexadecimal-characters-in-c" target="_blank" rel="noopener">《Printing hexadecimal characters in C》</a></li><li><a href="http://stackoverflow.com/questions/7188919/the-x-format-specifier-with-an-unsigned-char-in-c" target="_blank" rel="noopener">《The %x format specifier with an unsigned char in C》</a></li></ul><h1 id="坑-隐式类型提升"><a href="#坑-隐式类型提升" class="headerlink" title="坑: 隐式类型提升"></a>坑: 隐式类型提升</h1><ol><li>什么是<code>类型提升</code>: 变量由低精度提升到高精度类型, 这个不多解释.<br>整型提升: char/short/enum(无论符号)在可能的情况下会提升为int, 如果int能够完整的表示源类型的所有值, 那么就先提升为int, 如果不能则提升为unsigned int, 需要注意的一点是, 这个提升顺序和有无符号没有关系, unsigned char会先提升到int(有符号), 如果int无法完整表示源数据再尝试unsigned int.<br>从上面可以得知, <code>整形提升</code>可以看作有两种情况: 1是char/short提升到int, 2是int提升到unsigned int, 有符号int有时候会提升为unsigned int, 例如int型的-1(负数为补码存放1111..110), 提升为无符号int后就变成了4294967295, 最高位符号位也被当作自身的值了…<br>看到下面的代码运行结果请不要惊奇:</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1000 &lt; -1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析: 上面的例子中的if表达式是int和unsigned int的比较,由于后者精度更高, 导致int类型的-1先被转换位unsigned int类型. 有符号的-1在内存中存储为”1000…01”, 转换为无符号整形是一个很大的数.</p><blockquote><p>在 AnsiC 标准中提出的原则是，优先使用 int，并尽量保证提升后值的含义不变。也就是：如果 int 可以表达转换前的类型，则转换为 int，否则转换为 unsigned int。</p></blockquote><h2 id="在哪些情况下会产生隐式类型提升"><a href="#在哪些情况下会产生隐式类型提升" class="headerlink" title="在哪些情况下会产生隐式类型提升?"></a>在哪些情况下会产生隐式类型提升?</h2><p>有些类型提升是在我们”预料之内”的, 比如char型和int型相加操, 但还有一些”隐式”的类型提升在我们的”预料之外”, 当char、short int或者int（无论signed或unsigned）以及枚举类型出现在”可以使用int或者unsigned int的表达式”中, 则会导致<code>整形提升</code>.</p><ul><li>if里的表达式: 如果<code>if(char)</code>则括号里的被提升为int, 如果<code>if(a&lt;b)</code>中a和b类型不一致也会自动提升为精度更高的类型.</li><li>函数入参: 定义函数<code>void func(unsigned int)</code>, 当传入参数是int时.</li><li>有<code>size_t</code>类型的形参, 比如<code>memcpy(mybuf, buf, len)</code>, 不慎把一个int型的len传入, 长度有可能转成一个很大的整数, 如果mybuf的尺寸不够大则会…</li></ul><blockquote><p>以下摘自The C Programming Language, 第一版, P39 :</p><blockquote><p>在表达式中，每个 char 都被转换为 int ···注意所有位于位于表达式中的 float 都被转换为 double ···由于<br>函数参数也是一个表达式，所以当参数传递给函数时也会发生类型转换。具体地说， char 和 short 转换为 int, 而 float 转换为 double。</p></blockquote></blockquote><p>比如两个char型相加, 实际上是两个char都转换为int执行加法, 如果相加的结果要作为右值而同时左值是char类型, 则对结果进行剪裁(到char类型),如果两个char相加的结果不会溢出(即不会超过char的范围), 那么可以省略类型提升.<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a,b;</span><br><span class="line"><span class="built_in">printf</span> ( <span class="string">" the size of the result of a+b :%d "</span> ,<span class="keyword">sizeof</span>( a+b) );  <span class="comment">//输出4</span></span><br></pre></td></tr></table></figure></p><p>在K&amp;R C中，由于函数的参数也是表达式，所以也会发生类型提升, 在被调用函数内部，提升后的参数被裁剪为原先声明的大小, 这就是为什么单个的printf()格式字符串%d能适用于几个不同类型，short，char或int，而不论实际传递的是上述类型的哪一个。函数从堆栈中取出的参数总是int类型，并在printf或其他或其他被调用的函数里按统一格式处理.<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">0x70</span>; <span class="comment">// 0111 0000</span></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="number">0xe0</span>; <span class="comment">// 1111 0000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%x 0x%x"</span>,c1,c2); <span class="comment">// 输出"70 ffffffe0"</span></span><br></pre></td></tr></table></figure></p><p>原因是函数入参会把所有小于int的参数提升为int, char被提升为4字节的int, 由于c2的最高位是1（负数）, 所以被提升为ffffffe0.<br>比如sizeof, sizeof返回类型是size_t, 其实就是unsigned int, 看到unsigned你又腿抖了吧.</p><h1 id="坑-整形-char-short-int-long-溢出"><a href="#坑-整形-char-short-int-long-溢出" class="headerlink" title="坑: 整形(char/short/int/long)溢出"></a>坑: 整形(char/short/int/long)溢出</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> x = <span class="number">0xff</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ++x);</span><br></pre></td></tr></table></figure><ul><li>无符号整型溢出: 对于unsigned整型溢出，C的规范是有定义的——“溢出后的数会以<code>2^(8*sizeof(type))</code>作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。</li><li>有符号整型溢出: 发生溢出后变成什么要看编译器的实现, 大部分编译器的做法是算出什么是什么.</li></ul><p>上面的代码会输出：0 （因为0xff + 1是256，与2^8求模后就是0）</p><p>@ref</p><ul><li><a href="http://coolshell.cn/articles/11466.html" target="_blank" rel="noopener">C语言的整型溢出问题</a></li><li><a href="https://www.zhihu.com/question/30526656" target="_blank" rel="noopener">编程语言中，取余和取模的区别到底是什么？ - 知乎</a></li></ul><h1 id="坑-unsigned类型下溢"><a href="#坑-unsigned类型下溢" class="headerlink" title="坑: unsigned类型下溢"></a>坑: unsigned类型下溢</h1><p>size_t是标准C库中定义的，在32位系统为unsigned int，在64位系统中为 long unsigned int。分别为4字节和8字节。<br>unsigned类型的0再做–运算，会发生什么？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例一:</span></span><br><span class="line"><span class="keyword">size_t</span> num;</span><br><span class="line"><span class="keyword">while</span>(num-- &gt; <span class="number">0</span>) &#123;...&#125; <span class="comment">// 当0--时会产生下溢, 变成4294967294导致死循环</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例二:</span></span><br><span class="line"><span class="keyword">short</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(len&lt; MAX_LEN) &#123;</span><br><span class="line">    len += readFromInput(fd, buf);</span><br><span class="line">    buf += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="坑-指针和数组的区别"><a href="#坑-指针和数组的区别" class="headerlink" title="坑: 指针和数组的区别"></a>坑: 指针和数组的区别</h1><p>先看下面的代码, 在哪一行会coredown ?</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">str</span> *<span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">f</span>=&#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (f.a-&gt;s) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( f.a-&gt;s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译一下上面的代码，在VC++和GCC下都会在14行的printf处crash掉你的程序。<br>把源代码中的struct str结构体中的<code>char s[0];</code>改成<code>char *s;</code>试试看，你会发现，在13行if条件的时候，程序因为Cannot access memory就直接挂掉了。<br>为什么声明成<code>char s[0]</code>，程序会在14行挂掉，而声明成<code>char *s</code>，程序会在13行挂掉呢？那么char *s 和 char s[0]有什么差别呢？</p><p>在说明这个事之前，有必要看一下汇编代码，用GDB查看后发现：</p><ul><li>对于char s[0]来说，汇编代码用了lea指令，<code>lea   0x04(%rax),   %rdx</code></li><li>对于char*s来说，汇编代码用了mov指令，<code>mov 0x04(%rax),   %rdx</code></li><li>lea全称load effective address，是把地址放进去，而mov则是把地址里的内容放进去。所以，就crash了。</li></ul><p>从这里，我们可以看到，访问成员数组名其实得到的是数组的相对地址，而访问成员指针其实是相对地址里的内容（这和访问其它非指针或数组的变量是一样的）</p><p>换句话说，<strong>对于数组 char s[10]来说，数组名 s 和 &amp;s 都是一样的</strong>（不信你可以自己写个程序试试）。在我们这个例子中，也就是说，都表示了偏移后的地址。这样，如果我们访问 指针的地址（或是成员变量的地址），那么也就不会让程序挂掉了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h2><ul><li>指针和数组的区别不仅仅是”指针p定义后可以改变其值, 而数组a[]一旦定义后无法改变a的值”;</li><li>不管结构体的实例是什么——访问其成员其实就是加成员的偏移量;</li><li>int array[], 数组名array和&amp;array是一样的;</li></ul><p>@ref:  <a href="http://coolshell.cn/articles/11377.html" target="_blank" rel="noopener">C语言结构体里的成员数组和指针</a></p><p>指针和数组名的区别, 用下面的代码再解释一遍:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure></p><ul><li>数组a被定义后, a即为数组名, 其值不能再改变, 而指针p的值可以改变;</li><li>在代码中使用a[3]时, 直接从&amp;a[0] 向后寻找3个字节并取出那个字节;</li><li>而编译器看到p[3]时, 先生成代码找到p的位置, 取出其中的指针值, 在指针值上+3再取出该字节.</li><li>a[3]和p[3], 编译器解释不同, 取出字节的方式也不同. 换言之, a[3]是名为a的对象(起始位置)之后的第3个字节, p[3]是p指向的对象向后的第3个字节.</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><ul><li><a href="http://coolshell.cn/articles/5761.html" target="_blank" rel="noopener">深入理解C语言</a></li><li><a href="http://coolshell.cn/articles/830.html" target="_blank" rel="noopener">语言的歧义</a></li><li><a href="http://coolshell.cn/articles/873.html" target="_blank" rel="noopener">谁说C语言很简单？</a></li><li><a href="http://coolshell.cn/articles/945.html" target="_blank" rel="noopener">C语言的谜题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim入门指北</title>
      <link href="/50.Farbox-Blog/%E3%80%90Vim%E3%80%91Vim%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/"/>
      <url>/50.Farbox-Blog/%E3%80%90Vim%E3%80%91Vim%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/vi-vim-cheat-sheet-sch1.gif" alt="vim cheat sheet"></p><h1 id="plugin-2020"><a href="#plugin-2020" class="headerlink" title="plugin @2020"></a>plugin @2020</h1><ul><li>C++补全: 仍然是YCM</li><li>自动生成tag: vim-gutentags 或  gen_tags.vim</li><li>动态检查: ale(替代syntastic)</li><li>函数列表: LeaderF(替代 tagbar)</li><li>快速打开文件: LeaderF</li></ul><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><ul><li>operator（操作符）: 例如命令<code>d</code>, <code>y</code>, <code>c</code>等;</li><li>motion（移动）: 例如移动光标的命令<code>h j k l</code>, <code>w</code>, <code>e</code>, <code>b</code>等;</li><li>text-objects（文本对象）: 例如<code>s</code>(表示句子sentence)， <code>w</code>表示单词，<code>p</code>表示段落（Paragraphs）等等。</li></ul><blockquote><p>除了hjkl这些基本命令之外， 你还要知道“更高级的”组合命令： “operator + motion” 组合的方式，例如：</p></blockquote><ul><li><code>ct.</code> 将字符’.’前面的所有都删除.</li><li><code>y^</code>  复制到行首.</li></ul><blockquote><p>“operator + text-objects” 的命令组合方式, 例如:</p></blockquote><ul><li><code>ciw</code> : 剪切光标处单词, 不包括空格</li><li><code>caw</code> : 剪切光标处单词, 包括空格</li><li><code>dip</code> : 删除一段</li></ul><h1 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h1><p>下上左右：<code>ＪＫＨＬ</code><br>移动到上一个单词首<code>b</code><br>移动到下一个单词首<code>w</code>，移动3个单词<code>3w</code><br>    <----b w----=""></----b></p><p><code>w</code> / <code>b</code>是在单词首部移动，在单词尾部移动为<code>ge</code> / <code>e</code><br>    <----ge e----=""></----ge></p><p>如果是大写的<code>B</code>，<code>W</code>，<code>gE</code>，<code>E</code>，则只将“空格”作为单词分隔符，例如’gloal.member’被当作一个完整的词。</p><p><code>^</code> 光标移动到行开头<br><code>$</code> 光标移动到行结尾<br><code>fx</code> 光标移动到下一个x处，3fx移动到第三个x处<br><code>Fx</code> 光标移动到前面的x处<br><code>tx</code>，<code>Tx</code>类似，移动到x之前<br><code>ma</code> 标记当前行， 标签可以是a-z任意字符<br><code>~a</code> 跳转到a标签</p><p>跳转到上次编辑位置: <code>C-O</code><br>跳转到匹配的括号<code>%</code><br>移动到文件首<code>gg</code><br>有趣的命令: <code>9999k</code>作用也是移动到文件首<br>移动到文件尾<code>G</code><br>跳转到第33行<code>33G</code><br>或者输入 <code>:33</code> 也可以跳转<br>如移动到文档1/3处 ，直接输入<code>33%</code><br>将当前光标所在的行移到屏幕中间 <code>zz</code><br>当前光标所在的行移到屏幕顶，<code>zt</code> 助记t=top 。<br>当前光标所在的行移到屏幕底，<code>zb</code> 助记b=bottom 。<br>分别为移动到文档的head, middle, last的位置 <code>H, M, L</code>。<br> 向前向后翻页 <code>C-F</code> , <code>C-B</code></p><blockquote><p>Linux 终端( Terminal)中常用的快捷键</p><blockquote><p>ctrl+f 向前移动一个字符<br>ctrl+b 向后移动一个字符<br>alt+f 向前移动一个单词<br>alt+b 向后移动一个单词<br>ctrl+a 移动到当前行首<br>ctrl+e 移动到当前行尾</p></blockquote></blockquote><h2 id="vim-whith-ctags"><a href="#vim-whith-ctags" class="headerlink" title="vim whith ctags"></a>vim whith ctags</h2><ul><li>基于tags定义跳转: <code>C-]</code></li><li>在新 Window 打开tag的定义: <code>C-W-]</code></li><li>在新的预览 Window 里打开tag的定义:  <code>C-W-}</code></li><li>如果tags找到多个定义, 用 <code>g-]</code> 可以列出所有找到的tag;</li><li>跳转回 <code>C-O</code> 或 <code>C-T</code> 或按两下 <code>～</code></li><li><code>Ctrl + 左/右键</code> 也可以跳转/返回</li></ul><blockquote><p><code>CTRL-T</code> is working with tags stack<br><code>CTRL-O</code> is working with jumplist<br>Tag stack and jumplist are different list in vim, but they might have same items when you jumping through tags (eg. using <code>CTRL-]</code> )</p></blockquote><h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><p>使用<code>c</code>，<code>d</code>和<code>x</code>删除的字符仍然存在寄存器中，用<code>p</code>可以粘贴出来。</p><ul><li><code>c</code> = 替换（change），删除文本并进入插入模式，</li><li><code>d</code> =删除（delete），一般组合使用，</li><li><code>y</code> =复制（yank），</li><li><code>p</code> = 粘贴（paste），</li><li><code>x</code> = 删除字符；</li></ul><p>删除,剪切, 复制一行= <code>ｃｃ</code>，<code>ｄｄ</code>，<code>ｙｙ</code><br>删除,剪切, 复制多行= <code>３ｃｃ</code>，<code>４ｄｄ</code>，<code>５ｙｙ</code><br>删除,剪切, 复制到行尾= <code>ｃ＄</code>，<code>ｄ＄</code>，<code>ｙ＄</code><br>或者大写C, D, Y, 也是到行尾<br>删除,剪切,复制到行开头= <code>ｃ＾</code>，<code>ｄ＾</code>，<code>ｙ＾</code> 或者<code>ｃ０</code>，<code>ｄ０</code>，<code>ｙ０</code></p><p>从光标开始, 删除,剪切,复制到单词尾＝<code>cw</code>，<code>dw</code>，<code>yw</code><br>删除,剪切,复制整个单词= <code>daw</code>, <code>caw</code>, <code>yaw</code><br>注意区别<code>yw</code>和<code>yaw</code>, 例如光标在＂test＂ 的e位置, <code>yaw</code>复制整个单词, <code>yw</code>只复制est。</p><blockquote><p>tips: 重复操作的快捷键是”.”, 比如daw删除一个单词后想继续删除下一个单词，就可以按”.”</p></blockquote><p>删除换行符（两行合并为一行）： <code>J</code><br>撤销上次操作（还原）： <code>u</code><br>反撤销（重做）： <code>Ctrl+r</code><br>撤销对一行的所有操作（还原一行）： <code>U</code>，第二次按U会撤销上一次Ｕ的操作。<br>只用u和C-R即可回到任何一个操作状态。<br>可视模式下的U/u是大小写转换。</p><ul><li>光标前插入 = <code>i</code></li><li>光标后插入 = <code>a</code></li><li>行首插入 = <code>I</code></li><li>行尾插入 = <code>A</code></li></ul><p>在当前行的下面另起一行，并进入插入状态<code>o</code><br>在当前行的前面另起一行，并进入插入状态<code>O</code></p><h2 id="外部程序的粘贴-amp-复制"><a href="#外部程序的粘贴-amp-复制" class="headerlink" title="外部程序的粘贴&amp;复制"></a>外部程序的粘贴&amp;复制</h2><p>GVIM的“+号寄存器”可以与外部程序复制/粘贴:</p><ul><li>复制<code>&quot;+y</code></li><li>粘贴<code>&quot;+p</code></li><li>剪切<code>&quot;+x</code><br>注: 以上快捷键在命令可视模式/模式有效，先按双引号进入寄存器模式,再按加号,然后按<code>y/p/x</code><br>如果在插入模式, 先按<code>ctrl+R</code>进入寄存器模式（会出现<code>&quot;</code>号）, 再按对应的寄存器编号，系统共享寄存器编号是+号.<br>在VIM正常模式下,<code>ctrl+r</code> 是重做。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; 加入到_vimrc文件中:</span><br><span class="line">map &lt;C-c&gt; &quot;+y &quot;加号寄存器-复制</span><br><span class="line">map &lt;C-v&gt; &quot;+p &quot;加号寄存器-复制</span><br><span class="line">map &lt;CTRL-X&gt; &quot;+x &quot;加号寄存器-复制</span><br><span class="line">map &lt;C-s&gt; :w&lt;cr&gt; &quot; 保存</span><br></pre></td></tr></table></figure><h1 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h1><ul><li>关闭分屏窗口: <code>Ctrl+W c</code> 或 <code>Ctrl+W q</code></li><li>上下分割窗口: <code>Ctrl+W s</code></li><li>左右分割窗口: <code>Ctrl+W v</code><br><code>Ctrl+w Ctrl+]</code> 在新窗口打开定义</li></ul><h1 id="多文件buff操作"><a href="#多文件buff操作" class="headerlink" title="多文件buff操作"></a>多文件buff操作</h1><p><code>:E</code> 或者<code>:Explore</code> 浏览目录<br><code>:edit filename</code> 编辑文件；<br><code>:ls</code> 列出所有buffer；<br><code>:b 2</code>或<code>:buffer 2</code>将切换到相关的buffer<br><code>:b2</code> 关闭buff=2的文件；<br><code>:bn</code> 删除文件缓冲(关闭文件)。<br><code>zz</code> 将当前编辑的行置于屏幕中间。<br><code>ZZ</code> 保存退出。<br><code>:q!</code> 不保存退出, <code>:qa!</code>表示退出所有buff并不保存<br><code>:wq</code> 保存退出</p><h1 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h1><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><code>/include</code> 正向搜索，n下一个，N上一个<br><code>?include</code> 反向搜索<br><code>/\&lt;the\&gt;</code> 全词匹配搜索单词＂the＂，助记开头\&lt;，结尾><br><code>#</code>号是向后搜索匹配单词，<code>*</code>向前搜索匹配单词, <code>gd</code>类似*号的功能.</p><h2 id="正则搜索"><a href="#正则搜索" class="headerlink" title="正则搜索"></a>正则搜索</h2><p><code>/^the</code> 搜索the开头的行（针对行，而非单词）<br><code>/here$</code> 搜索here结尾的行<br>点号匹配任何单字符，如果要搜索的内容本身包含点号，则用.代替，比如：<br><code>/the.</code> 搜索＂the＂匹配的内容<br><code>/the\.</code> 搜索＂the.＂匹配的内容</p><p>正则表达式教程参考： [[../41.Uncategorized/正则表达式-RegExp]]</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>最常用的替换命令就是<code>:%s/1/2/g</code>了, 其中%符号表示范围整个文件, s表示搜索, 最后的g表示全局替换.<br>如果要制定范围内替换, 比如在31~文件尾范围内替换: <code>:31,$s/hello/world/gc</code>, 最后的c参数表示替换过程中需要确认(confirm).</p><h1 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h1><p><code>shift + v</code>: 行选择模式<br>大写<code>V</code>同上<br>所选择区域转换为大写<code>U</code>，转换为小写<code>u</code><br><code>x</code>和<code>d</code>在可视模式都是删除<br><code>&gt;</code>和<code>&lt;</code>在可视模式为右移,左移</p><h1 id="列模式"><a href="#列模式" class="headerlink" title="列模式"></a>列模式</h1><p><code>Ctrl+v</code> (Windows上是<code>Ctrl+Q</code>)进入列模式,<br>使用方向键或<code>H J K L</code>选择行, 用<code>c</code>或<code>d</code>删除, shift+i插入(大写I键),<br>插入完成后, 按esc后生效.</p><h1 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h1><p>可以<code>zf</code>进行折叠, 用<code>zo</code>打开折叠,也可以方向键向右打开折叠,<code>zc</code> 关闭折叠.</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session可以保存此次编辑的状态, 比如已经打开的文件, 当前编辑位置等.</p><ul><li>保存Session: <code>mksession session.vim</code></li><li>载入Session: <code>source session.vim</code></li></ul><h1 id="补全"><a href="#补全" class="headerlink" title="补全"></a>补全</h1><ul><li><code>CTRL-X CTRL-N</code>和<code>CTRL-X CTRL-P</code> : 关键字补全</li><li><code>CTRL-X CTRL-K</code> : 字典补全</li><li><code>CTRL-X CTRL-L</code> : 整行补全</li><li><code>CTRL-X CTRL-F</code> : 文件名补全</li><li><code>CTRL-X CTRL-O</code> : OmniComplete</li></ul><p>[Evernote]<a href="https://www.evernote.com/shard/s120/sh/4e8424bf-6c54-4f2e-a9a5-d4641127c615/ed07f657e1eccd05e81947e2e008c8a9" target="_blank" rel="noopener">https://www.evernote.com/shard/s120/sh/4e8424bf-6c54-4f2e-a9a5-d4641127c615/ed07f657e1eccd05e81947e2e008c8a9</a></p><h1 id="配置文件-vimrc"><a href="#配置文件-vimrc" class="headerlink" title="配置文件.vimrc"></a>配置文件.vimrc</h1><p>=&gt; <a href="/50.Farbox-Blog/【Vim】我的Vim配置文件/" title="【Vim】我的Vim配置文件">【Vim】我的Vim配置文件</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 Vim 配置文件</title>
      <link href="/50.Farbox-Blog/%E3%80%90Vim%E3%80%91%E6%88%91%E7%9A%84Vim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/50.Farbox-Blog/%E3%80%90Vim%E3%80%91%E6%88%91%E7%9A%84Vim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="插件"><a href="#插件" class="headerlink" title="插件:"></a>插件:</h1><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul><li>color: solarized/molokai/phd</li><li>vim-airline : 状态栏</li><li>Nerd_tree : 文件浏览</li><li>vim-startify : vim的起始页</li></ul><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><ul><li>EasyMotion : 快速在代码中移动光标</li><li>The-NERD-Commenter : 注释</li><li>vim-markdown</li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li>CtrlP（更快的查找文件）</li><li>grep.vim (Windows下使用findstr.vim)</li><li>EasyGrep</li></ul><h2 id="补全"><a href="#补全" class="headerlink" title="补全"></a>补全</h2><ul><li>YouCompleteMe: for Linux users</li><li>neocomplcache: for Windows users</li><li>OmniCppComplete: for Windows users</li></ul><h2 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h2><ul><li>SnipMate + honza/vim-snippets : Just Press Tab!</li></ul><h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><ul><li>scrooloose-syntastic: 支持C/C++(需要cppcheck或clang),php,Python(需要flake8或python),JavaScript(需要jshint或jslint), <a href="https://github.com/scrooloose/syntastic/wiki/Syntax-Checkers" target="_blank" rel="noopener">参考:syntastic支持的语言列表</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Conque-Shell : 在Vim的buff里执行命令行</li></ul><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h1><p>Github更新在这里: <a href="https://github.com/WhatsDJGPP/ah-my-vim.git" target="_blank" rel="noopener">https://github.com/WhatsDJGPP/ah-my-vim.git</a></p><ul><li>覆盖当前Vim配置: <code>cp ~/ah-my-vim/_vimrc ~/.vimrc &amp;&amp; cp -fr ~/ah-my-vim/* ~/.vim/</code></li><li>安装 Vundle: <code>mkdir -p ~/.vim/bundle/vundle/ &amp;&amp; git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</code></li><li>打开Vim并输入<code>:BundleInstall</code>安装插件.</li><li>如果在Windows上使用, 还需要下载<a href="http://sourceforge.net/projects/unxutils/" target="_blank" rel="noopener">UnxUtils</a>, 并注释掉<code>g:CygwinToolPath</code>一行;</li></ul><hr><h1 id="Custom-Shortcut-Keys"><a href="#Custom-Shortcut-Keys" class="headerlink" title="Custom Shortcut Keys :"></a>Custom Shortcut Keys :</h1><ul><li><code>\fc</code> / <code>F1</code>: Toggle TagList</li><li><code>\bb</code> / <code>F2</code>: Toggle BufExplorer</li><li><code>\ft</code> / <code>F3</code>: Toggle NERDTree</li><li><code>\/</code> / <code>F4</code> : Findstring or Rgrep</li><li><code>\co</code> : Open Quickfix</li><li><code>\cx</code> : Close Quickfix</li><li><code>\cc</code> : Comment Lines</li><li><code>\cu</code> : Uncomments Lines</li><li><code>\c&lt;space&gt;</code> : Toggles the comment state</li><li><code>&lt;C-\&gt;c</code> : Find functions calling this function</li><li><code>&lt;C-\&gt;g</code> : Find this definition</li><li><code>&lt;C-\&gt;s</code> : Find this C symbol</li><li>fold for C/C++:  <code>zo</code> and <code>zf%</code></li><li>fold fpr Py: <code>zo</code> and <code>zc</code></li></ul><h2 id="Shortcut-for-plugins"><a href="#Shortcut-for-plugins" class="headerlink" title="Shortcut for plugins:"></a>Shortcut for plugins:</h2><ul><li>NERD-Commenter: <code>\cc</code>或<code>\cs</code>添加注释, <code>\cm</code>多行注释, <code>\cu</code>取消注释</li><li>EasyMotion: <code>\\w</code>, if you want find ‘o’, use <code>\\fo</code></li><li>EasyGrep:  <code>\vv</code>在文件中搜索, <code>\vV</code>在文件中全词匹配, <code>\vr</code> 在文件中替换, <code>\vo</code>打开选项</li></ul><h2 id="VIMRC文件"><a href="#VIMRC文件" class="headerlink" title="_VIMRC文件"></a>_VIMRC文件</h2><p>点此查看: <a href="https://raw.githubusercontent.com/WhatsDJGPP/ah-my-vim/master/.vimrc" target="_blank" rel="noopener">github.com/WhatsDJGPP/ah-my-vim</a></p><p><img src="/images/2014-01-08/vim.png" alt="vim.png"></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> Vim </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Vundle 管理 Vim 插件（Windowns 7）</title>
      <link href="/50.Farbox-Blog/%E3%80%90Vim%E3%80%91%E4%BD%BF%E7%94%A8vundle%E7%AE%A1%E7%90%86vim%E6%8F%92%E4%BB%B6/"/>
      <url>/50.Farbox-Blog/%E3%80%90Vim%E3%80%91%E4%BD%BF%E7%94%A8vundle%E7%AE%A1%E7%90%86vim%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装win版本的gvim"><a href="#1-安装win版本的gvim" class="headerlink" title="(1)安装win版本的gvim:"></a>(1)安装win版本的gvim:</h3><p>下载地址 <a href="http://www.vim.org/download.php" target="_blank" rel="noopener">http://www.vim.org/download.php</a><br>比如安装目录是F:\Program Files (x86)\Vim,  并在此目录下新建”bundle\vundle”目录.</p><h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="(2)安装git"></a>(2)安装git</h3><p>安装git命令行: <a href="http://git-scm.com/" target="_blank" rel="noopener">http://git-scm.com/</a> (已被长城)<br>或者github带GUI的版本: <a href="http://windows.github.com/" target="_blank" rel="noopener">http://windows.github.com/</a><br>并且把git所在的目录加进环境变量PATH中.</p><h3 id="3-安装vundle"><a href="#3-安装vundle" class="headerlink" title="(3) 安装vundle"></a>(3) 安装vundle</h3><p>打开cmd, 输入以下:</p><blockquote><p>git clone <a href="https://github.com/gmarik/vundle" target="_blank" rel="noopener">https://github.com/gmarik/vundle</a> “F:\Program Files (x86)\Vim\vimfiles\bundle\vundle”</p></blockquote><p>保证git.exe在你的环境变量中.</p><h3 id="4-在-vimrc添加vundle"><a href="#4-在-vimrc添加vundle" class="headerlink" title="(4)在_vimrc添加vundle:"></a>(4)在_vimrc添加vundle:</h3><p>打开C:\Users\xxx_vimrc, 添加如下配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set rtp+=$VIM/vimfiles/bundle/vundle/</span><br><span class="line">call vundle#rc(&apos;$VIM/vimfiles/bundle/&apos;)</span><br><span class="line"></span><br><span class="line">Bundle &apos;gmarik/vundle&apos;</span><br><span class="line">&quot; original repos on github &#123;</span><br><span class="line"> &quot; Bundle &apos;tpope/vim-fugitive&apos;</span><br><span class="line"> &quot; Bundle &apos;Lokaltog/vim-easymotion&apos;</span><br><span class="line"> &quot; Bundle &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;</span><br><span class="line"> &quot; Bundle &apos;tpope/vim-rails.git&apos;</span><br><span class="line"> Bundle &apos;kien/ctrlp.vim&apos;</span><br><span class="line"> Bundle &apos;Lokaltog/vim-powerline&apos;</span><br><span class="line"> &quot;Bundle &apos;Valloric/YouCompleteMe&apos;</span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; vim-scripts repos &#123;</span><br><span class="line"> Bundle &apos;bufexplorer.zip&apos;</span><br><span class="line"> Bundle &apos;grep.vim&apos;</span><br><span class="line"> Bundle &apos;taglist.vim&apos;</span><br><span class="line"> Bundle &apos;The-NERD-tree&apos;</span><br><span class="line"> Bundle &apos;Markdown&apos;</span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; non github reposo &#123;</span><br><span class="line"> &quot; Bundle &apos;git://git.wincent.com/command-t.git&apos;</span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Brief help &#123;</span><br><span class="line"> &quot; :BundleList          - list configured bundles</span><br><span class="line"> &quot; :BundleInstall(!)    - install(update) bundles</span><br><span class="line"> &quot; :BundleSearch(!) foo - search(or refresh cache first) for foo</span><br><span class="line"> &quot; :BundleClean(!)      - confirm(or auto-approve) removal of unused bundles</span><br><span class="line">&quot; &#125;</span><br><span class="line">filetype plugin indent on       &quot; automatically detect file types.</span><br></pre></td></tr></table></figure></p><h3 id="5-通过vundle-安装vim-插件"><a href="#5-通过vundle-安装vim-插件" class="headerlink" title="(5) 通过vundle 安装vim 插件"></a>(5) 通过vundle 安装vim 插件</h3><p>在git shell 执行gvim, 然后在gvim内执行 :BundleInstall<br>done!</p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> Vim </tag>
            
            <tag> 编辑器 </tag>
            
            <tag> vundle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU的obj分析工具的使用 - nm,objdump</title>
      <link href="/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91GNU%E7%9A%84obj%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/50.Farbox-Blog/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91GNU%E7%9A%84obj%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>linux GUN工具链中二进制文件分析工具：</p><ul><li><code>nm</code>/<code>objdump</code>用来列出目标文件（object files）的符号表（symbols）；</li><li><code>readelf</code>用来分析elf文件；</li><li><code>ldd</code>用来分析程序运行时需要依赖的动态库。</li></ul><p>先来回顾一下Linux进程内存布局：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----高地址----</span><br><span class="line">&lt;栈stack&gt;</span><br><span class="line">  |</span><br><span class="line">&lt;堆heap&gt;</span><br><span class="line">&lt;.bss&gt;  未初始化的全局变量</span><br><span class="line">&lt;.data&gt; 已初始化的全局变量,static变量</span><br><span class="line">  &lt;.rodata&gt; 属于.data, 存放const, char*字符串</span><br><span class="line">&lt;.txt&gt;  代码段</span><br><span class="line">----低地址----</span><br></pre></td></tr></table></figure></p><p>本文中使用的示例代码:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *global_string1 = <span class="string">"abc"</span>; <span class="comment">// 4字节</span></span><br><span class="line"><span class="keyword">char</span> *global_string2 = <span class="string">"Hello World!!!"</span>; <span class="comment">// 15字节</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> global_const_int = <span class="number">0x81</span>; <span class="comment">// 129</span></span><br><span class="line"><span class="keyword">int</span> global_int = <span class="number">0x3FF</span>; <span class="comment">// 1023</span></span><br><span class="line"><span class="keyword">int</span> global_uninit_int;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stack_int = <span class="number">0x1F</span>; <span class="comment">// 31</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stack_uninit_static_int;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stack_inited_static_int = <span class="number">0x1B</span>; <span class="comment">// 27</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *stack_string1 = <span class="string">"Hello World!!!"</span>; <span class="comment">// 同global_string2, 15字节</span></span><br><span class="line">    <span class="keyword">char</span> *stack_string2 = <span class="string">"Hello"</span>; <span class="comment">// 6字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先看一下环境是多少位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int is %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印地址, 从低地址到高地址:</span></span><br><span class="line">    <span class="comment">// 全局定义字符串和函数内定义的字符串:</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr of global_string1 is 0x%x\n \</span></span><br><span class="line"><span class="string">        addr of global_string2 is 0x%x\n \</span></span><br><span class="line"><span class="string">        addr of stack_string1 is 0x%x\n \</span></span><br><span class="line"><span class="string">        addr of stack_string2 is 0x%x\n"</span>, global_string1, global_string2, stack_string1, stack_string2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局const常量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr of global_const_int is 0x%x\n"</span>, &amp;global_const_int);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已初始化static变量(全局变量默认是static的, 以及函数内static变量)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr of global_int is 0x%x\n \</span></span><br><span class="line"><span class="string">        addr of stack_inited_static_int is 0x%x\n"</span>, &amp;global_int, &amp;stack_inited_static_int);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static但未初始化变量(全局的和函数内的)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr of global_uninit_int is 0x%x\n \</span></span><br><span class="line"><span class="string">        addr of stack_uninit_static_int is 0x%x\n"</span>, &amp;global_uninit_int, &amp;stack_uninit_static_int);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addr of stack_int is 0x%x\n"</span>, &amp;stack_int);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译: <code>gcc -g  test.c -o test &amp;&amp; ./test</code> ，程序的输出如下, <code>#</code>后面是我的注释：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sizeof int is 4</span><br><span class="line">addr of global_string1 is 0x9343df2 # 4字节的字符串</span><br><span class="line">         addr of global_string2 is 0x9343df6 # 15字节的字符串</span><br><span class="line">         addr of stack_string1 is 0x9343df6 # 函数内字符串&quot;Hello World!!!&quot;, 跟全局指向同一个</span><br><span class="line">         addr of stack_string2 is 0x9343e05 # global_string2后面15字节就是stack_string2</span><br><span class="line"></span><br><span class="line">addr of global_const_int is 0x9343f94 # 全局常量在字面量字符串更高一点的位置</span><br><span class="line"></span><br><span class="line">addr of global_int is 0x9344028   # 全局/局部的static变量</span><br><span class="line">         addr of stack_inited_static_int is 0x934402c</span><br><span class="line"></span><br><span class="line">addr of global_uninit_int is 0x9344034  # 未初始化static</span><br><span class="line">         addr of stack_uninit_static_int is 0x9344030</span><br><span class="line"></span><br><span class="line">addr of stack_int is 0x568bc598</span><br></pre></td></tr></table></figure></p><blockquote><p>“全局变量”默认是static的, 无论加不加static关键字, 全局变量存储在data区<br>“局部定义的static变量”, 跟全局变量都在data区</p></blockquote><p>在内存的布局从大约是(非相邻的有<code>|</code>隔开了, 没有<code>|</code>表示相邻的区域):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 高地址 --</span><br><span class="line"></span><br><span class="line">---- [栈区] -----</span><br><span class="line">  函数内定义的非static变量(栈变量)</span><br><span class="line">       |</span><br><span class="line">       |</span><br><span class="line">       |</span><br><span class="line">----- [BSS] -----</span><br><span class="line">  未初始化static变量(包括全局定义和函数内定义的)</span><br><span class="line"></span><br><span class="line">---- [data区] ----</span><br><span class="line">  全局非const变量</span><br><span class="line"></span><br><span class="line">-- [data.rodata区]--</span><br><span class="line">  全局const常量</span><br><span class="line">  字面量的字符串(包括&quot;全局区定义的&quot;以及&quot;在函数内定义的&quot;)</span><br><span class="line"></span><br><span class="line">-- 低地址 --</span><br></pre></td></tr></table></figure></p><p>注意：全局字符串char*类型和char[]类型是有区别的，前者的字符不允许被修改，而后者的字符可以被修改。 未初始化的栈变量其值是随机的。而未初始化的全局变量被放入<code>.bss</code>段，被初始化为zero。</p><blockquote></blockquote><p><a href="http://en.wikipedia.org/wiki/Data_segment#BSS" target="_blank" rel="noopener">Wiki: Data segment</a>:<br> The BSS segment ( Block Started by Symbol), also known as uninitialized data, is usually adjacent to the data segment and contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code. For instance a variable declared static int i; would be contained in the BSS segment.<br> The data area contains global and static variables used by the program that are explicitly initialized with a non-zero (or non-NULL) value.</p><h1 id="nm的使用"><a href="#nm的使用" class="headerlink" title="nm的使用"></a>nm的使用</h1><p>nm用来列出目标文件的符号(symbol)清单: 在当前目录下输入<code>nm hello</code>，返回如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000601054 B __bss_start</span><br><span class="line">0000000000601054 b completed.6972</span><br><span class="line">000000000040063c R const_num  // 全局const常量，注意地址</span><br><span class="line">0000000000601030 D __data_start</span><br><span class="line">0000000000601030 W data_start</span><br><span class="line">...</span><br><span class="line">0000000000601054 D _edata</span><br><span class="line">0000000000601060 B _end</span><br><span class="line">...</span><br><span class="line">0000000000601050 D global_num  //全局int变量，注意地址</span><br><span class="line">0000000000601000 d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000601040 D global_string  //全局char*字符串，注意地址</span><br><span class="line">0000000000601048 D global_string2 //全局charp[]字符串</span><br><span class="line">0000000000601058 B global_uninit_num   // 全局未初始化</span><br><span class="line">...</span><br><span class="line">000000000040052d T main</span><br><span class="line">                 U printf@@GLIBC_2.2.5</span><br><span class="line">00000000004004a0 t register_tm_clones</span><br><span class="line">0000000000400440 T _start</span><br><span class="line">0000000000601058 D __TMC_END__</span><br></pre></td></tr></table></figure><p>解释下<code>nm</code>返回的格式, 共3列,分别是”符号在文件里的偏移”,”符号的类型”,”符号名称”.<br>其中“符号类型”有下面几种：</p><blockquote></blockquote><p>A :该符号的值是绝对的，在以后的链接过程中，不允许进行改变。<br>B :该符号的值出现在非初始化数据段(.bss)中。例如，比如全局没初始值的变量global_uninit_num;<br>D :该符号放在普通的数据段(.data)中，通常是那些已经初始化的全局变量；<br>R :The symbol is in a read only data section，比如全局的const_num；<br>T :该符号放在代码段中，通常是那些全局非静态函数, 上面可以看到main/_start等都是T类型；<br>U :该符号未定义过，需要自其他对象文件中链接进来, 上面可以看到printf函数是 printf@@GLIBC；</p><p>程序打印的变量内存地址（运行时），和可执行文件符号表的地址，并不完全相同。比如全局字符串global_string，（和全局int相比）全局字符串在程序运行时会放到.data段更低的位置。详细的解释见后面readelf的说明。</p><p>然后回到上面的一个问题，为什么全局字符串<code>char *global_string = &quot;abc&quot;</code>和全局常量<code>const int const_num =128</code>在内存中的地址比全局变量<code>int global_num = 1024</code>的地址要低很多？ 并且看到上面nm分析的obj符号地址，全局变量/常量在符号表里的地址其实差不多。<br>原因（我猜的）是，编译器在链接时会对“不可改变的”常量做特殊的优化，比如上面的<code>char*</code>类型的字符串，把这些不可改变的常量（.rodata段）存放在代码段（.text段），防止意外改写。</p><h2 id="nm的常用参数"><a href="#nm的常用参数" class="headerlink" title="nm的常用参数:"></a>nm的常用参数:</h2><p>-C : 加上此参数, 会让符号变成”适合阅读”的样式；<br>-A 在每个符号信息的前面打印所在对象文件名称；<br>-l 使用对象文件中的调试信息打印出所在源文件及行号, gcc -g参数可以让打印更为详尽；</p><h2 id="nm可以用来"><a href="#nm可以用来" class="headerlink" title="nm可以用来:"></a>nm可以用来:</h2><ol><li>判断指定程序中有没有某个符号 (比较常用的方式：<code>nm -C a.out | grep symbol</code>)</li><li>解决程序编译时undefined reference的错误，以及mutiple definition的错误</li><li>查看某个符号的地址，以及在进程空间的大概位置（bss, data, text区，具体可以通过第二列的类型来判断）</li></ol><p>有关<code>nm</code>更详细的说明可以参考 @ref <a href="http://sourceware.org/binutils/docs-2.17/binutils/nm.html" target="_blank" rel="noopener">sourceware.org</a>。</p><h1 id="objdump的使用"><a href="#objdump的使用" class="headerlink" title="objdump的使用"></a>objdump的使用</h1><p><code>objdump</code>命令是Linux下的反汇编目标文件或者可执行文件的命令，可以看作是<code>nm</code>的增强型。<br><code>objdump -d out</code> :反汇编test中的需要执行指令的那些section；<br><code>objdump -x out</code> :以某种分类信息的形式把目标文件的数据组成输出；<br><code>objdump -t out</code> :输出目标文件的符号表；<br><code>objdump -h out</code> :输出目标文件的所有段概括;<br><code>objdump -j ./text/.data -S out</code> : 输出指定段的信息（反汇编源代码）;<br><code>objdump -S out</code>  :输出目标文件的符号表（）  当gcc -g时打印更明显；<br><code>objdump -j .text -Sl stack1 | more</code>:<br><code>-S</code> 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。<br><code>-l</code> 用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用。使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。</p><h1 id="readelf的使用"><a href="#readelf的使用" class="headerlink" title="readelf的使用"></a>readelf的使用</h1><p><code>objdump</code>和<code>readelf</code>都可以用来查看二进制文件的一些内部信息. 区别在于:</p><ul><li><code>objdump</code>借助BFD而更加通用一些, 可以应付不同文件格式</li><li><code>readelf</code>则并不借助BFD, 而是直接读取ELF格式文件的信息, 按<code>readelf</code>手册页上所说,得到的信息也略细致一些.</li></ul><p>用<code>readelf</code>可以很方便的查看elf文件的布局: <code>readelf -ahW hello</code></p><p>详细的介绍请参考, 这里就不再复制粘贴了-.-<br>@ref <a href="http://sourceware.org/binutils/docs/binutils/readelf.html" target="_blank" rel="noopener">readelf - GNU Binary Utilities</a></p><p>参数-a表述输出所有elf信息, h表示打印出elf head, W表示打印出的内容太长(&gt;80字)不换行, 方便查看；</p><p><code>readelf -ahW test</code> 打印出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">[11] .init             PROGBITS        00000000004003e0 0003e0 00001a 00  AX  0   0  4</span><br><span class="line">[12] .plt              PROGBITS        0000000000400400 000400 000040 10  AX  0   0 16</span><br><span class="line">[13] .text             PROGBITS        0000000000400440 000440 0001e2 00  AX  0   0 16</span><br><span class="line">[14] .fini             PROGBITS        0000000000400624 000624 000009 00  AX  0   0  4</span><br><span class="line">[15] .rodata           PROGBITS        0000000000400630 000630 000165 00   A  0   0  8</span><br><span class="line">[24] .data             PROGBITS        0000000000601030 001030 000024 00  WA  0   0  8</span><br><span class="line">[25] .bss              NOBITS          0000000000601054 001054 00000c 00  WA  0   0  4</span><br><span class="line">[26] .comment          PROGBITS        0000000000000000 001054 000024 01  MS  0   0  1</span><br></pre></td></tr></table></figure><p>Key to Flags:</p><blockquote></blockquote><p>W (write), A (alloc), X (execute), M (merge), S (strings), l (large)<br>I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)<br>O (extra OS processing required) o (OS specific), p (processor specific)</p><p>根据上面的打印, 第三列就是elf文件中每段的起始address, 可以看到分别是(地址低-高)：</p><blockquote></blockquote><p>.text: 0x400440,<br>.rodata： 0x400630,<br>.data(已初始化的全局和static变量): 0x601030,<br>.bss(未初始化的全局)：0x601054</p><ul><li>“.text”段即为代码段，是存储指令的段，为防止在运行过程中指令被修改，该段是只读的</li><li>“.bss段”：未初始化的全局变量。在目标文件中这个段不占据实际的空间，在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。从上面的 readelf输出可以看到，“.data”和“.bss”在加载时合并到一个Segment中，这个Segment是可读可写的。“.bss段”和“.data段”的不同之处在于，.bss段在文件中不占存储空间，在加载时这个段用0填充。</li></ul><blockquote><p> 为什么未初始化的数据称为.bss？<br>用术语.bss来表示未初始化的数据是很普遍的。它起始于IBM704汇编语言中的“块存储开始(Block Storage Start)”指令的首字母缩写，并沿用至今，一个记住区分.data和.bss节的简单方法是把“bss”看成是“更好地节省空间(Better Save Space)”的缩写。</p></blockquote><p>Ok, 我们再来看一下<code>readelf -ahW</code>的其他输出:</p><blockquote></blockquote><p>50: 000000000040064c     4 OBJECT  GLOBAL DEFAULT   15 const_num<br>64: 0000000000601048     8 OBJECT  GLOBAL DEFAULT   24 global_string2<br>65: 0000000000601040     8 OBJECT  GLOBAL DEFAULT   24 global_string</p><p>可以看到代码里的<code>int const const_num</code>在0x40064c这个地址, 正好处在.rodata区域, 我们用hexdump命令来查看这个段的内容, 发现”hello world”字符串也在这个区域. 在链接时，“.rodata”和“.text”合并到Text Segment中，在加载运行时，操作系统将Text Segment设为只读保存起来，防止意外改写。<br>需要注意的是，象<code>const int A</code>这样的变量在定义时必须进行初始化，因为只有初始化时才有机会给它一个值，一旦定义之后就不能再改写了，也就是不能再赋值了。</p><h1 id="ldd的使用"><a href="#ldd的使用" class="headerlink" title="ldd的使用"></a>ldd的使用</h1><p>ldd工具用来查看程序所依赖的动态库，在命令行输入 <code>ldd hello</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux-vdso.so.1 =&gt;  (0x00007fff36450000)</span><br><span class="line">libc.so.6 =&gt; /lib64/libc.so.6 (0x000000355d800000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x000000355d000000)</span><br></pre></td></tr></table></figure><p>说明: 上面最后一列十六进制数,  就是库加载的开始地址.</p><p>@ref 参考 <a href="http://akaedu.github.io/post/13/13.1.html" target="_blank" rel="noopener">http://akaedu.github.io/post/13/13.1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> nm </tag>
            
            <tag> objdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装 tpacpi-bat 控制 thinkpad 充电阈值</title>
      <link href="/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91Linux%E4%B8%8B%E5%AE%89%E8%A3%85tpacpi-bat%E6%8E%A7%E5%88%B6thinkpad%E5%85%85%E7%94%B5%E9%98%88%E5%80%BC/"/>
      <url>/50.Farbox-Blog/%E3%80%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%91Linux%E4%B8%8B%E5%AE%89%E8%A3%85tpacpi-bat%E6%8E%A7%E5%88%B6thinkpad%E5%85%85%E7%94%B5%E9%98%88%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.thinkwiki.org/wiki/Tp_smapi" target="_blank" rel="noopener">tp_smapi</a> 是一套适用于ThinkPad的驱动程序集, 包括了电池阈值设置, 风扇转速控制, 以及HDAPS(类似APS硬盘保护)几个功能.  但是 2013新出的几款Ivy Bridge 平台的thinkpad(X230,T430,T530)上已经无法使用tp_smapi了. 在github上可以看到tp_smapi 项目也有两年多没有更新: <a href="https://github.com/evgeni/tp_smapi" target="_blank" rel="noopener">tp_smapi地址</a></p><p>所以对于T430等Ivy平台的Thinkpad, 推荐使用<a href="https://github.com/teleshoes/tpacpi-bat" target="_blank" rel="noopener">tpacpi-bat</a>调整电池充电阈值.</p><p>安装过程:</p><h3 id="1-安装acpidump-iasl工具"><a href="#1-安装acpidump-iasl工具" class="headerlink" title="(1) 安装acpidump , iasl工具"></a>(1) 安装acpidump , iasl工具</h3><blockquote><p>sudo yum install pmtools iasl</p></blockquote><h3 id="2-acpidump"><a href="#2-acpidump" class="headerlink" title="(2) acpidump"></a>(2) acpidump</h3><blockquote><p>sudo acpidump -b -t DSDT -o /tmp/dsdt.aml<br>可能会返回Wrong checksum for FADT!错误, 忽略.<br>iasl -d /tmp/dsdt.aml<br>cat /tmp/dsdt.dsl | grep \\_SB.PCI.*HKEY -amlo | uniq<br>记住输出的字符串, 我的T430输出是”_SB.PCI0.LPC.EC.HKEY”</p></blockquote><h3 id="3-编译acpi-call"><a href="#3-编译acpi-call" class="headerlink" title="(3) 编译acpi_call"></a>(3) 编译acpi_call</h3><p>下载代码并编译: <a href="https://github.com/mkottman/acpi_call" target="_blank" rel="noopener">https://github.com/mkottman/acpi_call</a></p><blockquote><p>sudo make<br>sudo make install<br>sudo depmod -a<br>sudo modprobe acpi_call</p></blockquote><p>最后一步载入acpi_call.ko之后,会多出一个 /proc/acpi/call “文件”, 通过写入参数到这个文件, 实现与acpi_call的交互.tpacpi-bat就是通过这种方式控制电池阈值. 当然也可以通过acpi_call控制独立显卡的关闭(双显卡的机型).</p><h3 id="4-安装tpacpi-call"><a href="#4-安装tpacpi-call" class="headerlink" title="(4) 安装tpacpi_call"></a>(4) 安装tpacpi_call</h3><p>下载代码并编译: <a href="https://github.com/teleshoes/tpacpi-bat" target="_blank" rel="noopener">https://github.com/teleshoes/tpacpi-bat</a><br>需要手动编辑一下 vim  tpacpi-bat<br>找到 “my $aslBases = …” 并改为自己的配置, 例如我的T430改为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my $aslBases = &#123;</span><br><span class="line">  &apos;default&apos;              =&gt; &apos;\_SB.PCI0.LPC.EC.HKEY&apos;,</span><br><span class="line">  &apos;ThinkPad W520&apos;        =&gt; &apos;\_SB.PCI0.LPC.EC.HKEY&apos;,</span><br><span class="line">  &apos;ThinkPad T430&apos;        =&gt; &apos;\_SB.PCI0.LPC.EC.HKEY&apos;,</span><br><span class="line">  &apos;ThinkPad T430u&apos;       =&gt; &apos;\_SB.PCI0.LPCB.EC.HKEY&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后把tpacpi-bat 移动到/usr/local/bin .</p><h3 id="5-增加到开机脚本中"><a href="#5-增加到开机脚本中" class="headerlink" title="(5) 增加到开机脚本中"></a>(5) 增加到开机脚本中</h3><p>编辑/etc/rc.local, 增加两行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/tpacpi-bat -s ST 0 70</span><br><span class="line">/usr/local/bin/tpacpi-bat -s SP 0 90</span><br></pre></td></tr></table></figure></p><p>上面两行分别将<em>开始充电</em>和<em>停止充电</em>设置为70%和90%.</p><h3 id="6-查询充电阈值"><a href="#6-查询充电阈值" class="headerlink" title="(6) 查询充电阈值"></a>(6) 查询充电阈值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tpacpi-bat -v -g ST 1</span><br><span class="line">tpacpi-bat -v -g SP 1</span><br></pre></td></tr></table></figure><p>参考:<br><a href="http://ubuntuforums.org/showthread.php?t=2148044" target="_blank" rel="noopener">http://ubuntuforums.org/showthread.php?t=2148044</a><br><a href="http://smitran.com/centos-6-thinkpad-t530-prolong-battery-life-with-tpacpi-bat/" target="_blank" rel="noopener">http://smitran.com/centos-6-thinkpad-t530-prolong-battery-life-with-tpacpi-bat/</a><br><a href="http://blog.thekondor.net/2012/09/make-new-thinkpads-charge-thresholds.html" target="_blank" rel="noopener">http://blog.thekondor.net/2012/09/make-new-thinkpads-charge-thresholds.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 50.FarBox博客备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinkpad </tag>
            
            <tag> Linux Desktop </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
