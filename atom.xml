<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扔掉笔记 ᐛ</title>
  
  <subtitle>dropNotes</subtitle>
  <link href="https://beefyheisenberg.github.io/atom.xml" rel="self"/>
  
  <link href="https://beefyheisenberg.github.io/"/>
  <updated>2023-05-09T04:45:03.503Z</updated>
  <id>https://beefyheisenberg.github.io/</id>
  
  <author>
    <name>beefyheisenberg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://beefyheisenberg.github.io/Excalidraw/Drawing%202023-05-07%2017.08.31.excalidraw/"/>
    <id>https://beefyheisenberg.github.io/Excalidraw/Drawing%202023-05-07%2017.08.31.excalidraw/</id>
    <published>2023-05-09T04:45:03.502Z</published>
    <updated>2023-05-09T04:45:03.503Z</updated>
    
    <content type="html"><![CDATA[<p>==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==</p><h1 id="Text-Elements"><a href="#Text-Elements" class="headerlink" title="Text Elements"></a>Text Elements</h1><p>测试1 ^2Nwalz2U</p><p>测试2 ^47KCljVa</p><p>%%</p><h1 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"excalidraw"</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">"source"</span>: <span class="string">"https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.26"</span>,</span><br><span class="line"><span class="attr">"elements"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"tadpJA1GcRMufcf_IJFhf"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"rectangle"</span>,</span><br><span class="line"><span class="attr">"x"</span>: <span class="number">-398.03416442871094</span>,</span><br><span class="line"><span class="attr">"y"</span>: <span class="number">-352.8992385864258</span>,</span><br><span class="line"><span class="attr">"width"</span>: <span class="number">73</span>,</span><br><span class="line"><span class="attr">"height"</span>: <span class="number">36</span>,</span><br><span class="line"><span class="attr">"angle"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"strokeColor"</span>: <span class="string">"#000000"</span>,</span><br><span class="line"><span class="attr">"backgroundColor"</span>: <span class="string">"transparent"</span>,</span><br><span class="line"><span class="attr">"fillStyle"</span>: <span class="string">"hachure"</span>,</span><br><span class="line"><span class="attr">"strokeWidth"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"strokeStyle"</span>: <span class="string">"solid"</span>,</span><br><span class="line"><span class="attr">"roughness"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"opacity"</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">"groupIds"</span>: [],</span><br><span class="line"><span class="attr">"roundness"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="number">3</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"seed"</span>: <span class="number">687088878</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="number">63</span>,</span><br><span class="line"><span class="attr">"versionNonce"</span>: <span class="number">2131402866</span>,</span><br><span class="line"><span class="attr">"isDeleted"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"boundElements"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"2Nwalz2U"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">"updated"</span>: <span class="number">1683450571063</span>,</span><br><span class="line"><span class="attr">"link"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"locked"</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"2Nwalz2U"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line"><span class="attr">"x"</span>: <span class="number">-384.2441635131836</span>,</span><br><span class="line"><span class="attr">"y"</span>: <span class="number">-347.3992385864258</span>,</span><br><span class="line"><span class="attr">"width"</span>: <span class="number">45.41999816894531</span>,</span><br><span class="line"><span class="attr">"height"</span>: <span class="number">25</span>,</span><br><span class="line"><span class="attr">"angle"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"strokeColor"</span>: <span class="string">"#000000"</span>,</span><br><span class="line"><span class="attr">"backgroundColor"</span>: <span class="string">"transparent"</span>,</span><br><span class="line"><span class="attr">"fillStyle"</span>: <span class="string">"hachure"</span>,</span><br><span class="line"><span class="attr">"strokeWidth"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"strokeStyle"</span>: <span class="string">"solid"</span>,</span><br><span class="line"><span class="attr">"roughness"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"opacity"</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">"groupIds"</span>: [],</span><br><span class="line"><span class="attr">"roundness"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"seed"</span>: <span class="number">279477042</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="number">44</span>,</span><br><span class="line"><span class="attr">"versionNonce"</span>: <span class="number">1153652654</span>,</span><br><span class="line"><span class="attr">"isDeleted"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"boundElements"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"updated"</span>: <span class="number">1683450571063</span>,</span><br><span class="line"><span class="attr">"link"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"locked"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"text"</span>: <span class="string">"测试1"</span>,</span><br><span class="line"><span class="attr">"rawText"</span>: <span class="string">"测试1"</span>,</span><br><span class="line"><span class="attr">"fontSize"</span>: <span class="number">20</span>,</span><br><span class="line"><span class="attr">"fontFamily"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"textAlign"</span>: <span class="string">"center"</span>,</span><br><span class="line"><span class="attr">"verticalAlign"</span>: <span class="string">"middle"</span>,</span><br><span class="line"><span class="attr">"baseline"</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">"containerId"</span>: <span class="string">"tadpJA1GcRMufcf_IJFhf"</span>,</span><br><span class="line"><span class="attr">"originalText"</span>: <span class="string">"测试1"</span>,</span><br><span class="line"><span class="attr">"lineHeight"</span>: <span class="number">1.25</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"6VmOilS8H0yBBNSX3ogOD"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"rectangle"</span>,</span><br><span class="line"><span class="attr">"x"</span>: <span class="number">-302.7958068847656</span>,</span><br><span class="line"><span class="attr">"y"</span>: <span class="number">-331.47459411621094</span>,</span><br><span class="line"><span class="attr">"width"</span>: <span class="number">72</span>,</span><br><span class="line"><span class="attr">"height"</span>: <span class="number">35</span>,</span><br><span class="line"><span class="attr">"angle"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"strokeColor"</span>: <span class="string">"#000000"</span>,</span><br><span class="line"><span class="attr">"backgroundColor"</span>: <span class="string">"transparent"</span>,</span><br><span class="line"><span class="attr">"fillStyle"</span>: <span class="string">"hachure"</span>,</span><br><span class="line"><span class="attr">"strokeWidth"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"strokeStyle"</span>: <span class="string">"solid"</span>,</span><br><span class="line"><span class="attr">"roughness"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"opacity"</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">"groupIds"</span>: [],</span><br><span class="line"><span class="attr">"roundness"</span>: &#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="number">3</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"seed"</span>: <span class="number">1233354926</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="number">80</span>,</span><br><span class="line"><span class="attr">"versionNonce"</span>: <span class="number">1562487986</span>,</span><br><span class="line"><span class="attr">"isDeleted"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"boundElements"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"47KCljVa"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">"updated"</span>: <span class="number">1683450574401</span>,</span><br><span class="line"><span class="attr">"link"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"locked"</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"47KCljVa"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line"><span class="attr">"x"</span>: <span class="number">-293.9158020019531</span>,</span><br><span class="line"><span class="attr">"y"</span>: <span class="number">-326.47459411621094</span>,</span><br><span class="line"><span class="attr">"width"</span>: <span class="number">54.239990234375</span>,</span><br><span class="line"><span class="attr">"height"</span>: <span class="number">25</span>,</span><br><span class="line"><span class="attr">"angle"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"strokeColor"</span>: <span class="string">"#000000"</span>,</span><br><span class="line"><span class="attr">"backgroundColor"</span>: <span class="string">"transparent"</span>,</span><br><span class="line"><span class="attr">"fillStyle"</span>: <span class="string">"hachure"</span>,</span><br><span class="line"><span class="attr">"strokeWidth"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"strokeStyle"</span>: <span class="string">"solid"</span>,</span><br><span class="line"><span class="attr">"roughness"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"opacity"</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">"groupIds"</span>: [],</span><br><span class="line"><span class="attr">"roundness"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"seed"</span>: <span class="number">2045260146</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="number">44</span>,</span><br><span class="line"><span class="attr">"versionNonce"</span>: <span class="number">1084370798</span>,</span><br><span class="line"><span class="attr">"isDeleted"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"boundElements"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"updated"</span>: <span class="number">1683450574401</span>,</span><br><span class="line"><span class="attr">"link"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"locked"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"text"</span>: <span class="string">"测试2"</span>,</span><br><span class="line"><span class="attr">"rawText"</span>: <span class="string">"测试2"</span>,</span><br><span class="line"><span class="attr">"fontSize"</span>: <span class="number">20</span>,</span><br><span class="line"><span class="attr">"fontFamily"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"textAlign"</span>: <span class="string">"center"</span>,</span><br><span class="line"><span class="attr">"verticalAlign"</span>: <span class="string">"middle"</span>,</span><br><span class="line"><span class="attr">"baseline"</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">"containerId"</span>: <span class="string">"6VmOilS8H0yBBNSX3ogOD"</span>,</span><br><span class="line"><span class="attr">"originalText"</span>: <span class="string">"测试2"</span>,</span><br><span class="line"><span class="attr">"lineHeight"</span>: <span class="number">1.25</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="string">"bbC4ie8Z"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line"><span class="attr">"x"</span>: <span class="number">-174.98568725585938</span>,</span><br><span class="line"><span class="attr">"y"</span>: <span class="number">-264.9309387207031</span>,</span><br><span class="line"><span class="attr">"width"</span>: <span class="number">10</span>,</span><br><span class="line"><span class="attr">"height"</span>: <span class="number">25</span>,</span><br><span class="line"><span class="attr">"angle"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"strokeColor"</span>: <span class="string">"#000000"</span>,</span><br><span class="line"><span class="attr">"backgroundColor"</span>: <span class="string">"transparent"</span>,</span><br><span class="line"><span class="attr">"fillStyle"</span>: <span class="string">"hachure"</span>,</span><br><span class="line"><span class="attr">"strokeWidth"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"strokeStyle"</span>: <span class="string">"solid"</span>,</span><br><span class="line"><span class="attr">"roughness"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"opacity"</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">"groupIds"</span>: [],</span><br><span class="line"><span class="attr">"roundness"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"seed"</span>: <span class="number">176070062</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">"versionNonce"</span>: <span class="number">597657074</span>,</span><br><span class="line"><span class="attr">"isDeleted"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"boundElements"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"updated"</span>: <span class="number">1683450548240</span>,</span><br><span class="line"><span class="attr">"link"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"locked"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"text"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"rawText"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"fontSize"</span>: <span class="number">20</span>,</span><br><span class="line"><span class="attr">"fontFamily"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"textAlign"</span>: <span class="string">"center"</span>,</span><br><span class="line"><span class="attr">"verticalAlign"</span>: <span class="string">"middle"</span>,</span><br><span class="line"><span class="attr">"baseline"</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">"containerId"</span>: <span class="string">"6VmOilS8H0yBBNSX3ogOD"</span>,</span><br><span class="line"><span class="attr">"originalText"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"lineHeight"</span>: <span class="number">1.25</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="attr">"appState"</span>: &#123;</span><br><span class="line"><span class="attr">"theme"</span>: <span class="string">"light"</span>,</span><br><span class="line"><span class="attr">"viewBackgroundColor"</span>: <span class="string">"#ffffff"</span>,</span><br><span class="line"><span class="attr">"currentItemStrokeColor"</span>: <span class="string">"#000000"</span>,</span><br><span class="line"><span class="attr">"currentItemBackgroundColor"</span>: <span class="string">"transparent"</span>,</span><br><span class="line"><span class="attr">"currentItemFillStyle"</span>: <span class="string">"hachure"</span>,</span><br><span class="line"><span class="attr">"currentItemStrokeWidth"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"currentItemStrokeStyle"</span>: <span class="string">"solid"</span>,</span><br><span class="line"><span class="attr">"currentItemRoughness"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"currentItemOpacity"</span>: <span class="number">100</span>,</span><br><span class="line"><span class="attr">"currentItemFontFamily"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"currentItemFontSize"</span>: <span class="number">20</span>,</span><br><span class="line"><span class="attr">"currentItemTextAlign"</span>: <span class="string">"left"</span>,</span><br><span class="line"><span class="attr">"currentItemStartArrowhead"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"currentItemEndArrowhead"</span>: <span class="string">"arrow"</span>,</span><br><span class="line"><span class="attr">"scrollX"</span>: <span class="number">443.4810256958008</span>,</span><br><span class="line"><span class="attr">"scrollY"</span>: <span class="number">427.26140213012695</span>,</span><br><span class="line"><span class="attr">"zoom"</span>: &#123;</span><br><span class="line"><span class="attr">"value"</span>: <span class="number">2</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"currentItemRoundness"</span>: <span class="string">"round"</span>,</span><br><span class="line"><span class="attr">"gridSize"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"colorPalette"</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">"currentStrokeOptions"</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">"previousGridSize"</span>: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"files"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%%</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==&lt;/p&gt;
&lt;h1 id=&quot;Text-Elements&quot;&gt;&lt;a href=&quot;#Text-Elements&quot; class=&quot;headerlink&quot; title=&quot;Text Elements&quot;&gt;&lt;/a&gt;Text Elements&lt;/h1&gt;&lt;p&gt;测试1 ^2Nwalz2U&lt;/p&gt;
&lt;p&gt;测试2 ^47KCljVa&lt;/p&gt;
&lt;p&gt;%%&lt;/p&gt;</summary>
    
    
    
    
    <category term="excalidraw" scheme="https://beefyheisenberg.github.io/tags/excalidraw/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-03b-索引-BTree</title>
    <link href="https://beefyheisenberg.github.io/32.Database/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>https://beefyheisenberg.github.io/32.Database/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</id>
    <published>2023-05-09T04:45:01.960Z</published>
    <updated>2023-05-09T04:45:01.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h1><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>B-Tree 不是 Binary Tree（二叉树，每个节点最多有两个子树），B 的意思是 Balance, 一棵 <strong>M 阶的 B-Tree </strong> 满足以下条件：</p><p>B 树的节点包含两部分：</p><ol><li>关键字，k 个关键字构成了 k+1 个开区间，指向 k+1 个孩子节点 </li><li>数据</li></ol><p>B 树的特点：</p><ul><li>树的根，孩子节点数量子在 2- M 之间；</li><li>除根外，每个非叶子节点数量在 M/2 - M 之间；</li><li>所有叶子节点都在相同的深度，且叶子节点不包含<strong>关键字</strong>；</li><li>一个非叶子节点如果包含 k 个关键字，那么它有 k+1 个孩子节点；</li></ul><p>一个 4 阶 B 树：</p><p><img src="/images/b-tree.png" alt="../_images/b-tree.png"></p><h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>针对 m 阶高度 h 的 B 树，插入一个元素时，首先在 B 树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。</p><ul><li>若该节点元素个数小于m-1，直接插入；</li><li>若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；</li><li>重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1；</li></ul><p>插入的例子（为了直观而先插入元素，然后判断是否要分裂）：</p><p>（1）5 阶 B 树，插入前：<br><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-1.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-1.png"></p><p>（2）插入 19，引起 14、16、17、18 的节点分裂，把中间元素【17】上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素【13】上移到新形成的根结点中，这样具体插入操作的完成。</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-2.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-2.png"></p><h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><p>首先，查找 B 树中需删除的元素，如果该元素在 B 树中存在，则将该元素在其节点中进行删除；删除该元素后，首先判断该元素是否有左右孩子节点， 如果有，则上移孩子节点中的某相近元素（「左孩子最右边的节点」或「右孩子最左边的节点」）到父节点中，然后是移动之后的情况；如果没有，直接删除。</p><ol><li>某节点中元素数目小于 m/2-1，m/2 向上取整，则需要看其某相邻兄弟节点是否丰满。</li><li>如果丰满（节点中元素个数大于 m/2-1），则向父节点借一个元素来满足条件。</li><li>如果其相邻兄弟都不丰满，即其节点数目等于 m/2-1，则该节点与其相邻的某一兄弟节点进行「合并」成一个节点。</li></ol><p>接下来用一个 5 阶 B 树为例，详细讲解删除的操作。</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-6.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-6.png"><br>如图所示，接下来要依次删除 8，20，18，5。 首先要删除元素 8。先查找到元素 8 在叶子节点中，删除 8 后叶子节点的元素个数为 2，符合 B 树的规则。然后需要把元素 11 和 12 都向前移动一位。完成后如图所示。</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-7.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-7.png"></p><p>下一步，删除 20，因为 20 没有在叶子节点中，而是在中间节点中找到，可以发现 20 的继承者是 23（字母升序的下个元素），然后需要将 23 上移到 20 的位置，之后将孩子节点中的 23 进行删除。 删除后检查一下，该孩子节点中元素个数大于 2，无需进行合并操作。</p><p>所以这一步之后，B 树如下图所示。</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-9.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-9.png"></p><p>下一步删除 18，18 在叶子节点中，但是该节点中元素数目为 2，删除导致只有 1 个元素，已经小于最小元素数目 2。而由前面已经知道：如果其某个相邻兄弟节点中比较丰满（元素个数大于 5/2），则可以向父节点借一个元素，然后将最丰满的相邻兄弟节点中上移最后或最前一个元素到父节点中。在这个实例中，右相邻兄弟节点中比较丰满（3 个元素大于 2），所以先向父节点借一个元素 23 下移到该叶子节点中，代替原来 19 的位置。19 前移。然后 24 在相邻右兄弟节点中，需要上移到父节点中。最后在相邻右兄弟节点中删除 24，后面的元素前移。</p><p>这一步之后，B 树如下图所示。</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-10.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-10.png"></p><p>最后一步需要删除元素 5，但是删除后会导致很多问题。因为 5 所在的节点数目刚好达标也就是刚好满足最小元素个数 2。 而相邻的兄弟节点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟节点进行合并操作；首先移动父节点中的元素（该元素在两个需要合并的两个节点元素之间）下移到其子节点中。 然后将这两个节点进行合并成一个节点。所以在该实例中，首先将父节点中的元素 4 下移到已经删除 5 而只有 6 的节点中，然后将含有 4 和 6 的节点和含有 1，3 的相邻兄弟节点进行合并成一个节点。</p><p>这一步之后，B 树如下图所示。</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-11.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-11.png"></p><p>但是这里观察到父节点只包含了一个元素 7，这就没有达标（因为非根节点包括叶子节点的元素数量 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="" title="K"> 必须满足于[2, 4] <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="" title="K=1">）。如果这个问题节点的相邻兄弟比较丰满，则可以向父节点借一个元素。而此时兄弟节点元素刚好为 2，刚刚满足，只能进行合并，而根节点中的唯一元素 13 下移到子节点。这样，树的高度减少一层。</p><p>所以最终的效果如下图。</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-12.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-12.png"></p><h2 id="B-Tree-的复杂度分析"><a href="#B-Tree-的复杂度分析" class="headerlink" title="B-Tree 的复杂度分析"></a>B-Tree 的复杂度分析</h2><p>B 树高度的证明过程：</p><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-3.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-3.png"></p><p><strong>结论</strong> 对于一颗数阶=M, 高度=h, 索引了 N 个元素的 B 树:</p><ul><li>树高 h 的上限:  $\log_M ((N+1)/2)$</li><li>查找一个元素 的时间复杂度为: $O\log_M N$</li><li>插入复杂度: 插入会发生结点的分裂操作。分裂操作可以认为是常数级别, 所以插入时间复杂度基本等于 $O\log_M N$, 当然这是 B-Tree 节点都在内存中的情况</li><li>删除复杂度: 理想情况下 $O\log_M N$,</li><li>删除操作的磁盘 IO 次数:  B-Tree 的删除会发生结点合并操作。最坏情况下磁盘访问次数是 3h ＝（找到包含被删除元素需要 h 次读访问）+（获取第 2 至 h 层的最相邻兄弟需要 h-1 次读访问）+（在第 3 至 h 层的合并需要 h-2 次写访问）+（对修改过的根节点和第 2 层的两个节点进行3次写访问）</li></ul><p>实际情况下, 数据库的 B-Tree 的节点并不都是在内存中, <strong>插入操作</strong>会引起磁盘 IO, 所以分析 MySQL 的 B-Tree 的插入代价还有考虑磁盘 IO: 当插入操作引起了 s 个节点的分裂时，磁盘访问的次数为 <code>h(读取搜索路径上的节点)＋2s(更新两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）</code>。因此，所需要的磁盘访问次数是 h+2 s+1，最多可达到 3 h+1。因此插入的代价是很大的。</p><blockquote><p>一般实际应用中，M 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3），业界公认 MySQL 单表容量在 1KW 以下是最佳状态，因为这时它的 BTREE 索引树高在3~5之间。</p></blockquote><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li>有 k 个子树的中间节点包含有 k 个关键字（B 树中是 k-1个）@doubt</li><li>非叶子节点没有 data, 只存储关键字和关键字对应的指针（非叶子节点仅存索引）;</li><li>叶子节点存储了所有的关键字和关键字对应的 data（叶子节点包含所有的关键字和数据）；</li><li>相邻的叶子节点按顺序形成单链表（叶子节点在一条链表中）;</li></ul><p><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-4.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-4.png"></p><p>各种资料上 B+树的定义各有不同，上面的定义方式是关键字个数和孩子结点个数相同，这里我们采取维基百科上所定义的方式，即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的（<a href="https://en.wikipedia.org/wiki/B%2B_tree" target="_blank" rel="noopener">B+ tree - Wikipedia</a>）：<br><img src="/images/MySQL-02b-BTree%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86-2023-05-08-5.png" alt="../_images/MySQL-02b-BTree索引原理-2023-05-08-5.png"></p><p>➤ <strong>为什么说 B+树比 B 树更适合数据库索引？</strong></p><p>1）B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；</p><p>2）B+树查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p><p>3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态）</p><p>B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。</p><blockquote><p>补充：B树的范围查找用的是中序遍历，而B+树用的是在链表上遍历</p></blockquote><h2 id="MySQL如何使用索引"><a href="#MySQL如何使用索引" class="headerlink" title="MySQL如何使用索引"></a>MySQL如何使用索引</h2><p>MySQL 使用 B+Tree 作为索引，数据库表中每个索引都可以认为是一个 B+Tree 结构</p><ul><li><p>聚集索引，B+Tree 的叶子节点存储的内容是每一行的数据，所以表在磁盘上的存储顺序与索引的顺序一致</p></li><li><p>非聚集索引，叶子节点存储的内容不是真实行数据，而是主键的值表，所以数据存储顺序与索引顺序无关。通过非聚簇索引查询要再回主键的 B 树查询才能得到数据（<strong>回表</strong>）, 所以也叫<strong>二级索引</strong></p></li></ul><h2 id="MyISAM和InnoDB索引区别"><a href="#MyISAM和InnoDB索引区别" class="headerlink" title="MyISAM和InnoDB索引区别"></a>MyISAM和InnoDB索引区别</h2><ul><li>MyISAM的 主键or非主键索引, 叶子节点存储的都是数据的地址, 因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</li><li>InnoDB: 主键的索引B+Tree, 叶子节点存储的数据即一条完整记录(聚集索引), InnoDB的辅助索引的叶子节点存储的是 <strong>主键的值</strong> (非聚集索引)</li></ul><hr><p>@ref:</p><ul><li><a href="https://github.com/wardseptember/notes/blob/master/docs/B%E6%A0%91%E5%92%8CB%2B%E6%A0%91%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">notes/B树和B+树详解.md at master · wardseptember/notes</a></li><li><a href="https://oi-wiki.org/ds/bplus-tree/" target="_blank" rel="noopener">B+ 树 - OI Wiki</a></li><li><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree" target="_blank" rel="noopener">B+树详解 | Ivanzz</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;索引原理&quot;&gt;&lt;a href=&quot;#索引原理&quot; class=&quot;headerlink&quot; title=&quot;索引原理&quot;&gt;&lt;/a&gt;索引原理&lt;/h1&gt;&lt;h2 id=&quot;B-Tree&quot;&gt;&lt;a href=&quot;#B-Tree&quot; class=&quot;headerlink&quot; title=&quot;B-Tree&quot;&gt;&lt;/a&gt;B-Tree&lt;/h2&gt;&lt;p&gt;B-Tree 不是 Binary Tree（二叉树，每个节点最多有两个子树），B 的意思是 Balance, 一棵 &lt;strong&gt;M 阶的 B-Tree &lt;/strong&gt; 满足以下条件：&lt;/p&gt;
&lt;p&gt;B 树的节点包含两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关键字，k 个关键字构成了 k+1 个开区间，指向 k+1 个孩子节点 &lt;/li&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="32.Database" scheme="https://beefyheisenberg.github.io/categories/32-Database/"/>
    
    
    <category term="后端架构" scheme="https://beefyheisenberg.github.io/tags/后端架构/"/>
    
    <category term="数据库" scheme="https://beefyheisenberg.github.io/tags/数据库/"/>
    
    <category term="MySQL" scheme="https://beefyheisenberg.github.io/tags/MySQL/"/>
    
    <category term="索引" scheme="https://beefyheisenberg.github.io/tags/索引/"/>
    
  </entry>
  
  <entry>
    <title>C100K系统设计</title>
    <link href="https://beefyheisenberg.github.io/31.Backend/SystemDesign-01-C100K/"/>
    <id>https://beefyheisenberg.github.io/31.Backend/SystemDesign-01-C100K/</id>
    <published>2023-05-09T04:45:01.657Z</published>
    <updated>2023-05-09T04:45:01.658Z</updated>
    
    <content type="html"><![CDATA[<p>本篇只讨论<strong>OS 级别的并发优化</strong>，不包括<strong>语言层面对并发的支持特性</strong>，C10 K / C100 K / C1000 K（百万） 都是指单服务器下，能够支持的空闲长连接的数量。</p><p>一般情况下服务端达到 C10K 连接时，大多数连接都是空闲连接，少数的活跃连接有数据读写，<strong>这种情况下讨论 C10K 的瓶颈在于“如何管理 10K-100K 级别的连接数”</strong>。</p><p>如果 C10K 的连接情况下，每个链接还有大量的读写数据，瓶颈就不仅仅是上面的“单机管理 10k-100k 数量级的 Connection”了，这种情况下，网卡、带宽都可能成为瓶颈，所以本文只考虑上面的情况“连接大多空闲、少数活跃”。</p><h1 id="有关-Linux-系统的限制"><a href="#有关-Linux-系统的限制" class="headerlink" title="有关 Linux 系统的限制"></a>有关 Linux 系统的限制</h1><p>服务器能支持建立连接数由几个决定：</p><ul><li>建立 TCP 连接最大并发数：TCP 连接四元组是由源 IP 地址、源端口、目的 IP 地址和目的端口构成，理论上是无上限的；</li></ul><ul><li>端口数限制：参考 [[#系统端口限制]]</li></ul><ul><li>Linux 文件描述符数量限制：打开一个 socket 要创建多个结构体（参考《深入理解 Linux 内核》），占用内存，所以 linux 系统出于安全角度的考虑，在多个位置都限制了可打开的文件描述符的数量，包括系统级、进程级、用户进程级，参考 [[#系统最大文件数]]</li><li>TCP 连接的内存开销：Linux 为内核对象申请空间使用 Slab 机制，在 Linux 3.10.0 版本中，创建一个 socket 需要消耗 densty、flip、sock_inode_cache、TCP 四个内核对象。这些对象加起来总共需要消耗大约 3 KB 多一点的内存。</li><li>服务器端应用层设置：Nginx、Apache、Tomcat 都有各自的最大并发数限制选项</li></ul><h2 id="系统最大文件数"><a href="#系统最大文件数" class="headerlink" title="系统最大文件数"></a>系统最大文件数</h2><p>使用 <code>ulimit</code> 设置最多能打开文件数:</p><blockquote><ul><li>查看所有的限制: <code>ulimit -a</code></li><li>设置最大打开文件句柄数: <code>ulimit -n 65535</code>, 65535 = 2^16 = 0 xFFFF</li><li>设置 <strong>每个用户的</strong> 最大进程数: <code>ulimit -u 32768</code></li><li>设置线程栈的大小: <code>ulimit -s 10240</code></li><li>设置最大线程数数: <code>ulimit -T</code> (在 Unix 上可能不同)</li><li>设置产生 core 文件大小: <code>ulimit -c xxx</code></li><li>不限制 core 的大小: <code>ulimit -c unlimited</code></li></ul></blockquote><p>ulimit 起作用的范围是”当前 Shell”, 并不是作用于”当前用户”, 如要对”用户”级别做限制, 则需要修改系统文件 <code>/etc/security/limits.conf</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># * 表示所有用户, nofile表示限制文件打开数, 限制在100</span><br><span class="line"># 注意 [hard nofile]一定要比 fs.nr_open 要小，否则可能导致用户无法登陆</span><br><span class="line">* soft  nofile  55000  </span><br><span class="line">* hard  nofile 100</span><br></pre></td></tr></table></figure><p>如果是针对整个系统, 则需要使用 <code>sysctl</code> 修改, 命令格式为: <code>sysctl -w fs.nr_open=10000000</code>, 每个系统参数对应一个/proc 下的文件, <code>fs.nr_open</code> 对应的文件路径是 <code>/proc/sys/fs/nr_open</code><br>系统最大打开文件数相关的参数有两个:</p><ul><li>fs.nr_open，进程级别</li><li>fs.file-max，系统级别</li></ul><p>至此总结一下, “Linux 系统最多能打开文件数” 有当前 shell, 进程, 用户, 系统三个级别,<br>shell 级别的更改限制命令是 ulimit, 更改系统级别限制的命令是 sysctl, 用户级别<br>限制优先级最大的是 fs.file-max, 假如 fs.file-max 设置为 100 万, ulimit 是不能超过 100万的.</p><blockquote><p>cat /proc/sys/fs/file-nr, 输出 9344 0 592026，分别为：1.已经分配的文件句柄数，2.已经分配但没有使用的文件句柄数，3.最大文件句柄数<br>file-nr 不是单个进程的限制, 是系统级的, 最后一个数字与 <code>file-max</code> 相同</p></blockquote><p>➤ 系统打开文件数有上限吗？<br>还没查到靠谱的资料，参考 RH6 手册，对于文件的限制，只有最大文件大小、最多子目录的数量等待，没有提到打开文件数 <a href="https://access.redhat.com/zh_CN/articles/3482381" target="_blank" rel="noopener">Red Hat Enterprise Linux 的技术能力和限制 - Red Hat Customer Portal</a></p><p>➤ 如何查看已创建文件描述符数?</p><ul><li>某进程打开文件数 <code>ll /proc/1599/fd | wc -l</code></li><li>某进程打开 socket 的数量: <code>ll /proc/1599/fd | grep socket | wc -l</code>  # nginx 一个 worker 打开了 200-300 个 socket</li><li>系统全部打开的文件数 <code>lsof | wc -l</code></li><li>系统全部打开的 TCP 连接数 <code>lsof | grep TCP | wc -l</code></li><li>查看 tcp 不同状态连接数: <code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code><ul><li>注意处于 TIME_WAIT 的链接, 如果这个数过高会占用大量连接, 应该调整参数尽快的释放 time_wait 连接</li></ul></li></ul><p>在 Nginx 机器上测试:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@zw_85_63 ~]# netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br><span class="line">TIME_WAIT 37968</span><br><span class="line">SYN_SENT 1</span><br><span class="line">FIN_WAIT1 5</span><br><span class="line">FIN_WAIT2 4</span><br><span class="line">ESTABLISHED 2725</span><br><span class="line">SYN_RECV 18</span><br><span class="line">LAST_ACK 4</span><br></pre></td></tr></table></figure><h2 id="系统端口限制"><a href="#系统端口限制" class="headerlink" title="系统端口限制"></a>系统端口限制</h2><p>TCP 协议规定的端口数量有 65535 个，但是一般的系统里 1024 以下的端口都是保留的，可用的大约就是 64 k 个. 默认情况下，Linux 只开启了 3 万多个可用端口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#vi /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_local_port_range = 5000 65000</span><br></pre></td></tr></table></figure><p>但对于服务端，端口数不是问题，因为一个监听的端口可以复用，<br>对于客户端，端口其实也是可以复用的，但还是有<strong>四元组</strong>的限制（举例，如果 Client 用一个端口，那么 dst_ip dst_port 的组合不能相同）</p><blockquote><p>四元组相关的代码, 参考 net/ipv4/inet_hashtables.c 下的 INET_MATCH 宏</p></blockquote><p>如果 Client 只连接一个 Server（这种情况下 dst_ip 和 dst_port 被固定了），那么作为 Client 只能一个 port 建立一个连接了，也就受到 TCP 协议端口数上限的限制。如果 Client 启动大量并发线程去连接 Server，这时候可能遇到一个问题：TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。 </p><p>但有个优化选项：打开 <code>net.ipv4.tcp_tw_reuse</code> 这个内核参数，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。</p><h2 id="系统最大进线程数"><a href="#系统最大进线程数" class="headerlink" title="系统最大进线程数"></a>系统最大进线程数</h2><p>某些服务程序(Apache, Tomcat) 采用 “Thread Per Request”, 系统的进线程最大数也会影响并发性能.</p><p>Linux 没有 <strong>直接限制</strong> 每个进程能够创建线程数, 仅限制了系统最大进线程数, 相关的配置有 :</p><ul><li>仅对当前 shell 有效: <code>ulimit -u 102400</code>, <code>-u</code> 表示 “max user processes”;</li><li>系统级别有效:<ol><li>临时生效: <code>echo 102400 &gt; /proc/sys/kernel/threads-max</code> 或 <code>sysctl -w sys.kernel.threads-max=10240</code> ;</li><li>永久生效: 修改 /etc/sysctl.conf 文件;</li></ol></li></ul><blockquote><p>这里的 threads-max 不是指进程, 是 “maximum number of threads that can be created using fork()”,<br>@ref <a href="https://www.kernel.org/doc/Documentation/sysctl/kernel.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/sysctl/kernel.txt</a></p></blockquote><p>每个进程能创建的最大线程数, 是由 total virtual memory 和 stack size 共同决定的, <code>number of threads = total virtual memory / stack size</code><br>这两个参数分别用 <code>ulimit -v xxx</code> 和 <code>ulimit -s xxx</code> 设置</p><p>此外系统能创建最大进程数还受 <code>kernel.pid_max</code> 影响:</p><ul><li>方式1 运行时限制,临时生效 <code>echo 999999 &gt; /proc/sys/kernel/pid_max</code></li><li>方式2 修改/etc/sysctl.conf，永久生效 <code>sys.kernel.pid_max = 999999</code></li></ul><p>但是线程数没限制不代表”Thread Per Request”可以行得通，如果创建了百万级的线程，上下文切换对 CPU 的调度也是考验</p><h1 id="应用程序的设置"><a href="#应用程序的设置" class="headerlink" title="应用程序的设置"></a>应用程序的设置</h1><p>首先考虑，服务端程序（Ngx、Redis、Tomcat 等）采用哪种 IO 线程模型？</p><p>如果是 BIO（比如较早版本的 Tomcat ，当然现在很少有 BIO 实现的服务了），一般采用的是 Connection pre thread 的方式，意味着需要起 10K-100K 线程，所以 BIO 模式直接 pass</p><p>如果是多路复用，那还要看是用的 select ？poll？epoll？<br>select 和 poll 都无法胜任 C10K，只有 epoll 可以，原因见 [[../21.Operating-System/APUE.07b.网络编程-多路复用epoll]]，</p><p>当然现在的服务端 Ngx、Redis 、Java 的 Netty 等都用的是 epoll，少数系统上可能会用 select、kqueue 等，Nginx &amp; Redis 的线程模型解析=&gt; [[../21.Operating-System/APUE.07d.服务端常用IO模型]]</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><ul><li>worker_rlimit_nofile 65535; // 一个 nginx 进程打开的最多文件描述符数目</li><li><p>listen 8080 backlog=168888; // accept 成功队列长度，用于 listen(int sockfd, int backlog)，默认值 511</p></li><li><p>worker_connections= //每个 worker 线程能创建的连接数</p></li><li>upstream 可以使用 http 1.1的 keepalive //与后端服务器创建的连接池大小</li><li>worker_processes 8; // nginx 进程数，一般等于 cpu core 数量</li><li>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000; // 每个进程分配到 cpu 的 core 上</li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>@todo</p><h2 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h2><p>默认是多进程同步处理 request, 所以思路和 Nginx 每个 Core 一个进程 epoll 轮询的方式不同, apache 应该增加”系统创建进程数上限”, 并且减小进程栈内存</p><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>Tomcat 也提供 NIO 模式（epoll + 非阻塞 IO），但 Tomcat 是个“跑业务代码”的服务，业务代码比较耗费时间（各种 CRUD），所以 Tomcat 注定不能像 Nginx 那样，在 epoll 线程里处理所有。</p><p>Tomcat 采用的是 1 个线程 accept，多个线程（ core 数的 2 倍个）监听<strong>已建连接</strong>的 IO 事件，收到一个 Http Req 则扔进线程池处理，线程池大小默认几百。参考 [[[../13.JavaEE-Framework/JavaEE.Tomcat]]]</p><ul><li>maxThreads=500 最大线程数，此值限制了 bio 的最大连接数<ul><li>一般的当一个进程有 500 个线程在跑的话，那性能已经是很低很低了。Tomcat 默认配置的最大请求数是 150。当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。</li></ul></li><li>maxConnection=8192: 使用 nio 或者 apr 时，最大连接数受此值影响。</li></ul><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><ul><li>fastcgi_connect_timeout 300;</li></ul><h1 id="高并发配置-无废话总结"><a href="#高并发配置-无废话总结" class="headerlink" title="高并发配置-无废话总结"></a>高并发配置-无废话总结</h1><ol><li>应用程序的并发设置: 主要是 timeout, 进/线程数这几类参数</li><li>操作系统打开文件数量限制:  <code>ulimit -n</code> 单个 Shell 环境的限制, <code>sysctl -w fs.file-max</code> 修改系统打开文件限制</li><li>操作系统打开端口数量限制: 最大端口数 65535(2^16), 但 1024 以后的端口是给系统用的</li><li></li><li>sysctl 修改的 TCP 协议栈参数</li></ol><h1 id="并发性能测试工具"><a href="#并发性能测试工具" class="headerlink" title="并发性能测试工具"></a>并发性能测试工具</h1><h2 id="ab-Apache-Bench"><a href="#ab-Apache-Bench" class="headerlink" title="ab(Apache Bench)"></a>ab(Apache Bench)</h2><p>1000并发, 总共20000次请求: <code>ab -n 20000 -c 1000 &lt;url&gt;</code></p><h2 id="http-load"><a href="#http-load" class="headerlink" title="http_load"></a>http_load</h2><p>30个并发线程, 共60秒测试: <code>http_load -p 30 -s 60 Url.txt</code></p><h2 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>@todo</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>@todo</p><h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p>在聚合报告中，会显示一行数据，共有 10 个字段，含义分别如下。</p><ul><li>Label：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值</li><li>Samples：表示你这次测试中一共发出了多少个请求，如果模拟 10 个用户，每个用户迭代 10 次，那么这里显示 100</li><li>Average：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以 Transaction 为单位显示平均* 响应时间</li><li>Median：中位数，也就是 50％ 用户的响应时间</li><li>90% Line：90％ 用户的响应时间</li><li>Min：最小响应时间</li><li>Max：最大响应时间</li><li>Error%：本次测试中出现错误的请求的数量/请求的总数</li><li>Throughput：吞吐量——默认情况下表示每秒完成的请求数（Request per Second）</li><li>KB/Sec：每秒从服务器端接收到的数据量，相当于 LoadRunner 中的 Throughput/Sec</li></ul><p>参考: <a href="http://www.importnew.com/13876.html" target="_blank" rel="noopener">使用JMeter进行负载测试——终极指南 - ImportNew</a> @ref</p><h2 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h2><p><a href="https://github.com/wg/wrk" target="_blank" rel="noopener">wg/wrk: Modern HTTP benchmarking tool</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.rowkey.me/blog/2015/09/09/load-analysis/" target="_blank" rel="noopener">系统负载能力浅析</a></li><li><a href="https://www.zhihu.com/question/361111920" target="_blank" rel="noopener">一台主机上只能保持最多 65535 个 TCP 连接吗？ - 知乎</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/" target="_blank" rel="noopener">通过 ulimit 改善系统性能</a> @Archived</li><li><a href="http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/" target="_blank" rel="noopener">怎样增大 Linux 系统的 open file(s) 上限</a></li><li><a href="http://www.cnblogs.com/sxlfybb/archive/2011/09/15/2178160.html" target="_blank" rel="noopener">nginx优化 突破十万并发</a></li><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-libev/" target="_blank" rel="noopener">使用 libevent 和 libev 提高网络应用性能</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇只讨论&lt;strong&gt;OS 级别的并发优化&lt;/strong&gt;，不包括&lt;strong&gt;语言层面对并发的支持特性&lt;/strong&gt;，C10 K / C100 K / C1000 K（百万） 都是指单服务器下，能够支持的空闲长连接的数量。&lt;/p&gt;
&lt;p&gt;一般情况下服务端达到 C10K 连接时，大多数连接都是空闲连接，少数的活跃连接有数据读写，&lt;strong&gt;这种情况下讨论 C10K 的瓶颈在于“如何管理 10K-100K 级别的连接数”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果 C10K 的连接情况下，每个链接还有大量的读写数据，瓶颈就不仅仅是上面的“单机管理 10k-100k 数量级的 Connection”了，这种情况下，网卡、带宽都可能成为瓶颈，所以本文只考虑上面的情况“连接大多空闲、少数活跃”。&lt;/p&gt;
&lt;h1 id=&quot;有关-Linux-系统的限制&quot;&gt;&lt;a href=&quot;#有关-Linux-系统的限制&quot; class=&quot;headerlink&quot; title=&quot;有关 Linux 系统的限制&quot;&gt;&lt;/a&gt;有关 Linux 系统的限制&lt;/h1&gt;&lt;p&gt;服务器能支持建立连接数由几个决定：&lt;/p&gt;</summary>
    
    
    
    <category term="31.Backend" scheme="https://beefyheisenberg.github.io/categories/31-Backend/"/>
    
    
    <category term="后端架构" scheme="https://beefyheisenberg.github.io/tags/后端架构/"/>
    
    <category term="并发" scheme="https://beefyheisenberg.github.io/tags/并发/"/>
    
    <category term="性能测试" scheme="https://beefyheisenberg.github.io/tags/性能测试/"/>
    
    <category term="C10K" scheme="https://beefyheisenberg.github.io/tags/C10K/"/>
    
    <category term="C100K" scheme="https://beefyheisenberg.github.io/tags/C100K/"/>
    
    <category term="ulimit" scheme="https://beefyheisenberg.github.io/tags/ulimit/"/>
    
  </entry>
  
  <entry>
    <title>网络协议-IP</title>
    <link href="https://beefyheisenberg.github.io/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE2-IP/"/>
    <id>https://beefyheisenberg.github.io/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE2-IP/</id>
    <published>2023-05-09T04:45:01.498Z</published>
    <updated>2023-05-09T04:45:01.499Z</updated>
    
    <content type="html"><![CDATA[<p>@todo： DNS、ARP、DHCP、NAT、ICMP、IGMP</p><h2 id="IP-地址的划分"><a href="#IP-地址的划分" class="headerlink" title="IP 地址的划分"></a>IP 地址的划分</h2><p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了<strong>分类地址</strong>。IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类：</p><ul><li>A类地址： 网络地址1字节，主机地址3字节，其中网络地址最高1位必须是0<ul><li>网络地址占1位，范围是1 — 126（开区间 0000 0000 — 0111 1111）不包括0000 0000 和 0111 111，前者用于表示未知地址，后者表示回环地址</li><li>主机地址占3位，表示一个网络地址中最大主机数是<code>2^24 - 2</code>（主机地址全0表示网络地址，全1表示广播地址，所以减2）</li><li>A类地址范围： <code>1.0.0.1</code> — <code>126.255.255.254</code></li><li>默认子网掩码255.0.0.0</li><li>在A类地址中，10.0.0.0到10.255.255.255是私有地址（所谓的私有地址=只能在局域网络中使用）</li></ul></li><li>B类地址： 网络地址2字节，主机地址2字节，其中网络地址最高2位必须是10<ul><li>B类地址范围：<code>128.0.0.1</code> — <code>191.255.255.254</code>，每个网络中最大主机数65534</li><li>默认子网掩码255.255.0.0</li><li>在B类地址中，172.16.0.0 — 172.31.255.255是私有地址</li></ul></li><li>C类地址： 网络地址3字节，主机地址1字节，其中网络地址最高3位必须是110<ul><li>C类地址范围：<code>192.0.0.1</code> — <code>223.255.255.254</code>，每个网络中最大主机数254</li><li>默认子网掩码255.255.255.0</li><li>在C类地址中，192.168.0.0 — 192.168.255.255是私有地址</li></ul></li><li>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。<br><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP-2023-04-26-1.png" alt="../_images/网络协议-IP-2023-04-26-1.png"></li></ul><p>因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和全为 0 地址：</p><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络（子网）</li></ul><p>➤  子网掩码：subnet mask，掩码的意思就是掩盖掉主机号，剩余的就是网络号。将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</p><p>子网掩码可以把（一个网络号表示的）网络更加细化：假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 （192 = 1100 0000）对其进行子网划分。C 类地址中前 24 位是网络号，最后 8 位是主机号，根据子网掩码可知<strong>从 8 位主机号中借用 2 位作为子网号</strong>：所以192.168.1.0这个网络被分为 4 个子网：分别是 00、01、10、11。</p><p>➤  A、B、C 类有个尴尬处境，就是<strong>不能很好的与现实网络匹配</strong>。</p><ul><li>C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。</li><li>而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</li></ul><p>这两个缺点，都可以在 <code>CIDR</code> 无分类地址解决</p><p>➤  <em>CIDR(Classless Inter-Domain Routing)</em>: 这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p><p>比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul><li>IPv4 地址是 32 位，8 位为一组，共 4 组，约提供 42 亿个地址，在 2011 年 IPv4 地址已经被分配完了；</li><li>IPv6 地址是 128 位，16 位为一组，共 8 组，用 <code>:</code> 隔开，如果出现连续的 0 还可以将这些 0 省略，但<code>:</code>不可省略，且一个 IPv6 只能出现一次两个连续 <code>::</code></li></ul><p><img src="/images/IPv6-Example.png" alt="../_images/IPv6-Example.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;@todo： DNS、ARP、DHCP、NAT、ICMP、IGMP&lt;/p&gt;
&lt;h2 id=&quot;IP-地址的划分&quot;&gt;&lt;a href=&quot;#IP-地址的划分&quot; class=&quot;headerlink&quot; title=&quot;IP 地址的划分&quot;&gt;&lt;/a&gt;IP 地址的划分&lt;/h2&gt;&lt;p&gt;互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了&lt;strong&gt;分类地址&lt;/strong&gt;。IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A类地址： 网络地址1字节，主机地址3字节，其中网络地址最高1位必须是0&lt;ul&gt;
&lt;li&gt;网络地址占1位，范围是1 — 126（开区间 0000 0000 — 0111 1111）不包括0000 0000 和 0111 111，前者用于表示未知地址，后者表示回环地址&lt;/li&gt;
&lt;li&gt;主机地址占3位，表示一个网络地址中最大主机数是&lt;code&gt;2^24 - 2&lt;/code&gt;（主机地址全0表示网络地址，全1表示广播地址，所以减2）&lt;/li&gt;
&lt;li&gt;A类地址范围： &lt;code&gt;1.0.0.1&lt;/code&gt; — &lt;code&gt;126.255.255.254&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认子网掩码255.0.0.0&lt;/li&gt;
&lt;li&gt;在A类地址中，10.0.0.0到10.255.255.255是私有地址（所谓的私有地址=只能在局域网络中使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B类地址： 网络地址2字节，主机地址2字节，其中网络地址最高2位必须是10&lt;ul&gt;
&lt;li&gt;B类地址范围：&lt;code&gt;128.0.0.1&lt;/code&gt; — &lt;code&gt;191.255.255.254&lt;/code&gt;，每个网络中最大主机数65534&lt;/li&gt;
&lt;li&gt;默认子网掩码255.255.0.0&lt;/li&gt;
&lt;li&gt;在B类地址中，172.16.0.0 — 172.31.255.255是私有地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C类地址： 网络地址3字节，主机地址1字节，其中网络地址最高3位必须是110&lt;ul&gt;
&lt;li&gt;C类地址范围：&lt;code&gt;192.0.0.1&lt;/code&gt; — &lt;code&gt;223.255.255.254&lt;/code&gt;，每个网络中最大主机数254&lt;/li&gt;
&lt;li&gt;默认子网掩码255.255.255.0&lt;/li&gt;
&lt;li&gt;在C类地址中，192.168.0.0 — 192.168.255.255是私有地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于&lt;strong&gt;多播&lt;/strong&gt;，E 类是预留的分类，暂时未使用。&lt;br&gt;&lt;img src=&quot;/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP-2023-04-26-1.png&quot; alt=&quot;../_images/网络协议-IP-2023-04-26-1.png&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和全为 0 地址：&lt;/p&gt;</summary>
    
    
    
    <category term="22.Network-Protocol" scheme="https://beefyheisenberg.github.io/categories/22-Network-Protocol/"/>
    
    
    <category term="网络协议" scheme="https://beefyheisenberg.github.io/tags/网络协议/"/>
    
    <category term="IP" scheme="https://beefyheisenberg.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>APUE.07d.服务端常用IO模型</title>
    <link href="https://beefyheisenberg.github.io/21.Operating-System/APUE.07d.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B8%B8%E7%94%A8IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://beefyheisenberg.github.io/21.Operating-System/APUE.07d.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B8%B8%E7%94%A8IO%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-05-09T04:45:01.407Z</published>
    <updated>2023-05-09T04:45:01.408Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx:</p><ul><li>基于 epoll 监听多个连接(50000 个并发连接数的响应), 当某个连接有数据准备好的时候再通知, 这样一个进程能处理多个连接</li><li>大于 5 k 并发的时候, Nginx 才明显比 apache 有更好的表现</li></ul><p>Redis</p><ul><li>Redis 使用单线程的 I/O 复用模型, 自己封装了一个简单的 AeEvent 事件处理框架, 主要实现了 epoll、kqueue 和 select.</li><li>优势: 对于单纯只有 I/O 操作来说, 单线程可以将速度优势发挥到最大. 且无需考虑同步问题</li><li>缺陷：Redis 排序、聚合、大 Key 操作、Flush 等, 对于这些耗时较高操作, 单线程模型实际会严重影响整体吞吐量, CPU 计算过程中, 整个 I/O 调度都是被阻塞住的</li></ul><p>Apache: 默认是每个请求启动一个线程处理, 并不适合高并发</p><ul><li>缺陷:<ul><li>有多少并发就需要多少进程, 最大进程数</li><li>在进程创建很多的情况下, 系统切换进程的代价很高, 进程运行的时间很少</li><li>实际上本机处理数据的时间很短, 大多数时间都是在”等待数据准备好”的阶段, 效率低</li></ul></li><li>新版的 Apache 的改进, 支持多种 MPM(Multi-Processing Model)<ul><li>prefork: 古老</li><li>worker: 多进程(注意并不是每个请求一个线程), 每个进程多个线程</li><li>event: epoll</li></ul></li></ul><p>Tomcat: </p><ul><li>BIO 模式每个请求启动一个线程处理</li><li>但 Tomcat 从 JDK 1.6 支持开始支持 NIO，这种方式同 Netty 的“主从 Reactor” 类似，这种模式下，只有一个 Acceptor 线程用于 accept 新请求，Poller 线程相当于 Netty 的 sub Reactor 线程（默认 process x 2 个）只负责已建立的连接 IO 事件，业务放入 exector 线程池处理业务（包括对 socket 流的 decode，业务代码指的是 servlet.service） @link <a href="/21.Operating-System/APUE.07c.网络编程-Reactor&Proactor模型/" title="APUE.07c.网络编程-Reactor&Proactor模型">APUE.07c.网络编程-Reactor&Proactor模型</a></li></ul><hr><p>@ref: <a href="https://cloud.tencent.com/developer/beta/article/1488120" target="_blank" rel="noopener">https://cloud.tencent.com/developer/beta/article/1488120</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 epoll 监听多个连接(50000 个并发连接数的响应), 当某个连接有数据准备好的时候再通知, 这样一个进程能处理多个连接&lt;/li&gt;
&lt;li&gt;大于 5 k 并发的时候, Nginx 才明显比 apache 有更好的表现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 使用单线程的 I/O 复用模型, 自己封装了一个简单的 AeEvent 事件处理框架, 主要实现了 epoll、kqueue 和 select.&lt;/li&gt;
&lt;li&gt;优势: 对于单纯只有 I/O 操作来说, 单线程可以将速度优势发挥到最大. 且无需考虑同步问题&lt;/li&gt;
&lt;li&gt;缺陷：Redis 排序、聚合、大 Key 操作、Flush 等, 对于这些耗时较高操作, 单线程模型实际会严重影响整体吞吐量, CPU 计算过程中, 整个 I/O 调度都是被阻塞住的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apache: 默认是每个请求启动一个线程处理, 并不适合高并发&lt;/p&gt;</summary>
    
    
    
    <category term="21.Operating-System" scheme="https://beefyheisenberg.github.io/categories/21-Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>APUE.07c.网络编程-Reactor vs Proactor</title>
    <link href="https://beefyheisenberg.github.io/21.Operating-System/APUE.07c.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor&amp;Proactor%E6%A8%A1%E5%9E%8B/"/>
    <id>https://beefyheisenberg.github.io/21.Operating-System/APUE.07c.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Reactor&amp;Proactor%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-05-09T04:45:01.398Z</published>
    <updated>2023-05-09T04:45:01.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O-多路复用模式：Reactor-amp-Proactor"><a href="#I-O-多路复用模式：Reactor-amp-Proactor" class="headerlink" title="I/O 多路复用模式：Reactor &amp; Proactor"></a>I/O 多路复用模式：Reactor &amp; Proactor</h2><p>一般地,I/O 多路复用机制（I/O multiplexing mechanisms）都依赖于一个事件多路分离器(Event Demultiplexer)。<br>我们常见的事件多路分用器包括：Linux 的 epoll 和 Windows 的 IOCP。</p><p><strong>事件多路分离器</strong>（Event Demultiplexer）可将来自事件源的 I/O 事件分离出来，并分发到对应的 <strong>事件处理器</strong> (Event Handler)进行 read/write。</p><p>两个与事件分离器有关的模式是 Reactor 和 Proactor，Reactor 模式采用同步 IO，而 Proactor 采用异步 IO。</p><h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>在 Reactor 中，<strong>事件多路分离器</strong> 等待文件描述符状态变为读写操作准备就绪状态，然后将就绪事件传递给对应的 <strong>处理器</strong>，最后由 <strong>处理器</strong> 负责完成实际的读写工作。</p><p>Linux epoll 使用 Reactor 模式，Reactor 模式使用同步 I/O（一般来说）。Reactor 的标准（典型）的工作方式是：</p><ul><li>Reactor 线程中, epoll 注册读/写等等事件</li><li>epoll 等待事件到来</li><li>事件到来，Reactor 把事件分发给处理器(往往使用线程池跑处理器)</li><li>处理器线程: 读写数据（调用 read/write, 从内核 buff 将数据拷贝到用户态 buff)</li><li>处理器线程进行处理(decode 数据, 执行业务代码, encode 数据)</li></ul><p><strong>Netty 的 Reactor 线程模型</strong> @link: [[../12.Java/Java-Tutorials.09.NIO&amp;Netty#Reactor三种常见线程模型]]</p><h2 id="Proactor-模式"><a href="#Proactor-模式" class="headerlink" title="Proactor 模式"></a>Proactor 模式</h2><p>而在 Proactor 模式中，<strong>处理器</strong> 只负责发起异步读写操作。 <strong>处理器</strong> 传递给操作系统 <strong>用户态的数据缓冲区</strong>，之后的 IO 操作、以及内核态缓冲区→ 用户态缓冲区操作，这些都由操作系统来完成。</p><p>比如，在 windows 上，处理器发起一个异步 IO 操作，再由事件分离器等待 IOCompletion 事件。IOCompletion 通知的时候, 数据已经被拷贝到处理器的 buff 了.<br>典型的异步模式实现，都建立在操作系统支持异步 API 的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的 IO 工作。</p><p>Windows IOCP 使用 Proactor 模式，Proactor 模式使用异步 I/O。Proactor 的标准（典型）的工作方式是：</p><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步 IO）。在这种情况下，处理器无视 IO 就绪事件，它关注的是完成事件。</li><li>事件分离器等待操作完成事件</li><li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li><li>事件分离器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li></ul><p>以上参考: <a href="https://blog.csdn.net/robinjwong/article/details/50117091" target="_blank" rel="noopener">Reactor VS Proactor 模式</a> @ref</p><h2 id="两种模式的比较"><a href="#两种模式的比较" class="headerlink" title="两种模式的比较"></a>两种模式的比较</h2><h3 id="比较实现"><a href="#比较实现" class="headerlink" title="比较实现"></a>比较实现</h3><ul><li>在 Reactor 模式，用户代码的责任是： 在收到 IO事件后进行实际的 IO 操作；</li><li>在 Proactor 模式，用户代码需要负责收到 IO事件后的所有操作；</li></ul><h3 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h3><p><strong>✔︎ Reactor 优势</strong></p><ul><li>Reactor 实现相对简单，对于耗时短的处理场景处理高效；</li><li>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；</li><li>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</li><li>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，</li></ul><p><strong>× Reactor 劣势</strong></p><ul><li>Reactor 处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</li></ul><p><strong>✔︎ Proactor 优势</strong></p><ul><li>Proactor 性能更高，能够处理耗时长的并发场景；</li></ul><p><strong>× Proactor 劣势</strong></p><ul><li>Proactor 依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，比较优秀的如 windows IOCP（完成端口），但由于其 windows 系统用于服务器的局限性，目前应用范围较小；<br>而 Unix/Linux 系统对纯异步的支持尚不成熟，应用事件驱动的主流还是通过 select/epoll 来实现；</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；</li><li>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</li></ul><h3 id="在实际工程中的使用"><a href="#在实际工程中的使用" class="headerlink" title="在实际工程中的使用"></a>在实际工程中的使用</h3><ul><li>Reactor: libevent / libev /libuv / ZeroMQ / Event Library in Redis</li><li>Proactor: Windows IOCP / Boost.Asio</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/161214505" target="_blank" rel="noopener">System|IO|Proactor - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/161159888" target="_blank" rel="noopener">System|IO|Reactor - 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;I-O-多路复用模式：Reactor-amp-Proactor&quot;&gt;&lt;a href=&quot;#I-O-多路复用模式：Reactor-amp-Proactor&quot; class=&quot;headerlink&quot; title=&quot;I/O 多路复用模式：Reactor &amp;amp; Proactor&quot;&gt;&lt;/a&gt;I/O 多路复用模式：Reactor &amp;amp; Proactor&lt;/h2&gt;&lt;p&gt;一般地,I/O 多路复用机制（I/O multiplexing mechanisms）都依赖于一个事件多路分离器(Event Demultiplexer)。&lt;br&gt;我们常见的事件多路分用器包括：Linux 的 epoll 和 Windows 的 IOCP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件多路分离器&lt;/strong&gt;（Event Demultiplexer）可将来自事件源的 I/O 事件分离出来，并分发到对应的 &lt;strong&gt;事件处理器&lt;/strong&gt; (Event Handler)进行 read/write。&lt;/p&gt;
&lt;p&gt;两个与事件分离器有关的模式是 Reactor 和 Proactor，Reactor 模式采用同步 IO，而 Proactor 采用异步 IO。&lt;/p&gt;
&lt;h2 id=&quot;Reactor-模式&quot;&gt;&lt;a href=&quot;#Reactor-模式&quot; class=&quot;headerlink&quot; title=&quot;Reactor 模式&quot;&gt;&lt;/a&gt;Reactor 模式&lt;/h2&gt;</summary>
    
    
    
    <category term="21.Operating-System" scheme="https://beefyheisenberg.github.io/categories/21-Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>APUE.07b.网络编程-多路复用</title>
    <link href="https://beefyheisenberg.github.io/21.Operating-System/APUE.07b.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8epoll/"/>
    <id>https://beefyheisenberg.github.io/21.Operating-System/APUE.07b.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8epoll/</id>
    <published>2023-05-09T04:45:01.382Z</published>
    <updated>2023-05-09T04:45:01.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五种-I-O-模型"><a href="#五种-I-O-模型" class="headerlink" title="五种 I/O 模型"></a>五种 I/O 模型</h2><ol><li><strong>阻塞 IO</strong>: 调用 read, 如果内核数据未就绪, 调用 read 的进程进入阻塞状态。应用程序调用一个 IO 函数，导致应用程序阻塞并等待数据准备就绪。如果数据没有准备好，一直等待。如果数据准备好了，则从内核拷贝到用户空间拷贝数据，IO 函数返回成功指示。<br><img src="/images/operating_system/Linux-IO-Blocked.png" alt=""></li><li><strong>非阻塞 IO</strong>: nonblocking IO 的特点是用户进程需要不断的主动询问 kernel 数据是否准备好. 当所请求的 I/O 操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的 I/O 操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用 CPU 的时间。<br><img src="/images/operating_system/Linux-IO-NonBlocking.png" alt=""></li><li><strong>多路复用 IO</strong>: 复用模型会用到 select 或者 poll 函数，这两个函数也会使进程阻塞，但是和阻塞 I/O 所不同的的，这两个函数可以同时阻塞多个 I/O 操作。而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。从而使得系统在单线程的情况下可以同时处理多个客户端请求. 与传统的多线程/多进程模型比, I/O 多路复用的最大优势是系统开销小。<br>和阻塞 IO 模型相比，selectI/O 复用模型相当于提前阻塞了。等到有数据到来时，再调用 recv 就不会因为要等数据就绪而发生阻塞。<ul><li>select: 一般采用 select + no-block, select 返回后要遍历所有阻塞在 select 上的 IO 句柄，找到数据就绪的那一个 IO 句柄后, 应用程序调用 recvfrom 将数据从内核区拷贝至用户区；</li><li>epoll : 比 select 更高效，无需轮询全部句柄，epoll 只返回数据 ready 的 IO 句柄<br><img src="/images/operating_system/Linux-IO-Multiplexing.png" alt=""></li></ul></li><li><strong>信号驱动 IO</strong>：让内核在数据就绪时用信号 SIGIO 通知我们，将此方法称为信号驱动 I/O。首先，我们允许套接字进行信号驱动 I/O，并通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的。当数据报准备好被读时，就为该进程生成一个 SIGIO 信号。我们随即可以在信号处理程序中调用 recvfrom 来取读数据报。</li><li><strong>异步 IO</strong>: 我们让内核启动操作，并在整个操作完成后（包括将数据从内核拷贝到我们自己的缓冲区）通知我们。<br>调用 aio_read 函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。<br>上面其它四种模型，至少都会在由 kernel copy data to appliction 时阻塞。而该模型是当 copy 完成后才通知 application，可见是纯异步的。<br>很少有 <code>*nix</code> 系统支持，windows 的 IOCP（完成端口）则是此模型<br><img src="/images/operating_system/Linux-IO-Async.png" alt=""></li></ol><p>Linux I/O 模型的发展技术是： select -&gt; poll -&gt; epoll -&gt; aio -&gt; libevent -&gt; libuv。另外还有 Windows 的 Completion Port。</p><blockquote><p>提供一致的接口，IO Design Patterns<br>实际上，不管是哪种模型，都可以抽象一层出来，提供一致的接口，广为人知的有 ACE,Libevent 这些，他们都是跨平台的，而且他们自动选择最优的 I/O 复用机制，用户只需调用接口即可。说到这里又得说说2个设计模式，Reactor and Proactor。有一篇经典文章<a href="http://www.artima.com/articles/io_design_patterns.html" target="_blank" rel="noopener">http://www.artima.com/articles/io_design_patterns.html</a>值得阅读，Libevent 是 Reactor 模型，ACE 提供 Proactor 模型。实际都是对各种 I/O 复用机制的封装。</p></blockquote><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><code>int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p><p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述副就绪（有数据可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。<br>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p><code>int poll (struct pollfd *fds, unsigned int nfds, int timeout);</code></p><p>不同与 select 使用三个位图来表示三个 fdset 的方式，poll 使用一个 pollfd 的指针实现。<br>pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select“参数-值”传递的方式。同时，pollfd 并没有最大数量限制（但是数量过大后性能也是会下降）。和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是在 2.6 内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 来说，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><ol><li><p><code>int epoll_create(int size);</code><br>创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 select()中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>当创建好 epoll 句柄后，它就会占用一个 fd 值，在 linux 下如果查看/proc/进程 id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 close()关闭，否则可能导致 fd 被耗尽。</p></li><li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</code><br>函数是对指定描述符 fd 执行 op 操作。</p></li></ol><ul><li>epfd：是 epoll_create()的返回值。</li><li>op：表示 op 操作，用三个宏来表示：添加 EPOLL_CTL_ADD，删除 EPOLL_CTL_DEL，修改 EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件。</li><li>fd：是需要监听的 fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事件</li></ul><ol start="3"><li><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br>等待 epfd 上的 io 事件，最多返回 maxevents 个事件。<br>参数 events 用来从内核得到事件的集合，maxevents 告之内核这个 events 有多大，这个 maxevents 的值不能大于创建 epoll_create()时的 size，参数 timeout 是超时时间（毫秒，0 会立即返回，-1 将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li></ol><h2 id="select-amp-poll-amp-epoll-内部实现"><a href="#select-amp-poll-amp-epoll-内部实现" class="headerlink" title="select &amp; poll &amp; epoll 内部实现"></a>select &amp; poll &amp; epoll 内部实现</h2><h3 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h3><p>select 的实现：</p><ul><li><p>当用户线程调用完 <code>select</code> 后开始进入阻塞状态，<code>内核</code> 开始轮询遍历 <code>fd数组</code>，查看数组里的每个 fd 对应的 Socket 的接收缓冲区否有数据。如果有数据到来，则将 <code>fd</code> 对应值设置为 <code>1</code>。如果没有数据到来，则保持值为 <code>0</code>。</p></li><li><p>内核遍历一遍 <code>fd数组</code> 后，如果发现有些 <code>fd</code> 上有 IO 数据到来，则将修改后的 <code>fd数组</code> 返回给用户线程。此时，会将 <code>fd数组</code> 从 <code>内核空间</code> 拷贝到 <code>用户空间</code>。</p></li><li><p>当内核将修改后的 <code>fd数组</code> 返回给用户线程后，用户线程解除 <code>阻塞</code>，由用户线程开始工作：遍历 <code>fd数组</code> 然后找出 <code>fd数组</code> 中值为 <code>1</code> 的 <code>Socket</code> 文件描述符…</p></li><li><p>由于内核在遍历的过程中已经修改了 <code>fd数组</code>，所以在用户线程遍历完 <code>fd数组</code>，就需要重置 fd 数组，并重新调用 <code>select</code> 传入重置后的 <code>fd数组</code>，让内核发起新的一轮遍历轮询。</p></li></ul><p>select 的不足：</p><ul><li>在发起 <code>select</code> 系统调用以及返回时，用户线程各发生了一次 <code>用户态</code> 到 <code>内核态</code> 以及 <code>内核态</code> 到 <code>用户态</code> 的上下文切换开销。<strong>发生 2 次上下文 <code>切换</code></strong></li><li><code>fd集合</code> 从用户空间 <code>拷贝</code> 到内核空间的拷贝次数：</li><li><code>内核</code> 会对内核态的 <code>fd集合</code> 进行修改。导致每次在用户空间重新发起 <code>select</code> 调用时，都需要对 <code>fd集合</code> 进行 <code>重置</code>。</li><li><code>fd集合</code> 长度为固定的 <code>1024</code>,所以只能监听 <code>0~1023</code> 的文件描述符。</li><li><code>select</code> 系统调用不是线程安全的。</li></ul><p>很明显 <code>select</code> 也不能解决 <code>C10K</code> 问题，只适用于 <code>1000</code> 个左右的并发连接场景。</p><h3 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h3><p>poll 相比 select 的改进：</p><ul><li><code>select</code> 中使用的 <code>fd集合</code> 是采用的固定长度为 1024 的数组，而 <code>poll</code> 换成了一个 <code>pollfd</code> 结构没有固定长度的数组，这样就没有了最大描述符数量的限制（当然还会受到系统文件描述符限制）</li></ul><p>所以 <code>poll</code> 只解决了 <code>select</code> 最大监听数的限制，但 <code>poll</code> 的 fd 组织是用的线性数据结构，遍历性能在 fd 数量很多的时候不足。依然无法解决 <code>C10K</code> 问题。</p><h3 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h3><p>复习一下阻塞模式 recv：</p><blockquote><p>阻塞 recv 场景下，服务端 sock 的 <strong>等待队列</strong>，队列里的 <strong>等待项（wait_queue_t）</strong>保存了两个重要数据：1）阻塞在此 sock 上的进程描述符， 2）就绪回调函数 <code>autoremove_wake_function</code>，这个函数的作用是当 sock 可读时，调用这个就绪函数；<br>那么当此 sock 的<strong>接收队列</strong> 有数据时，系统内核会从 <strong>等待队列</strong> 取出 <strong>等待项（wait_queue_t）</strong> ，通过 <code>autoremove_wake_function</code> 唤醒线程（注意，即使是有多个进程都阻塞在同一个 sock 上，也只唤醒 1 个进程，避免惊群。）</p></blockquote><p>对于 epoll + 非阻塞 recv 的模式，上面提到的 <strong>等待项（wait_queue_t）</strong> 的回调函数变成了 epoll 的 <code>ep_poll_callback</code></p><p>➤ epoll 调用过程如下：</p><p>（1）调用 epoll_create 创建 epoll 对象：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct eventpoll &#123;</span><br><span class="line"></span><br><span class="line">  //等待队列，阻塞在epoll上的进程会放在这里</span><br><span class="line">  wait_queue_head_t wq;</span><br><span class="line"></span><br><span class="line">  //就绪队列，IO就绪的socket连接会放在这里</span><br><span class="line">  struct list_head rdllist;</span><br><span class="line"></span><br><span class="line">  //红黑树用来管理所有监听的socket连接</span><br><span class="line">  struct rb_root rbr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>等待队列：区别 sock 对象的等待队列，epoll 的等待队列里，存放是阻塞于 epoll 的进程；</li><li>就绪队列：只有就绪的 sock 被放入，这也是比 select 效率高的改进；</li><li>红黑树： epoll 监听的所有 sock 连接，都存于红黑树里，对于海量链接，红黑树比数组&amp;链表的性能都更好；</li></ul><p>epoll 的红黑树中保存的是，fd 作为查找 key ?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct epitem &#123;</span><br><span class="line">　　//指向epoll中对应的红黑树节点</span><br><span class="line">　　struct rb_node rbn;</span><br><span class="line">　　</span><br><span class="line">　　//指向epoll对象中的就绪队列</span><br><span class="line">　　struct list_head rdllink;</span><br><span class="line">　　</span><br><span class="line">　　//指向epitem所表示的socket-&gt;file结构以及对应的fd</span><br><span class="line">　　struct epoll_filefd ffd;</span><br><span class="line">　　</span><br><span class="line">　　//指向其所属的eventepoll对象</span><br><span class="line">　　struct eventpoll *ep;</span><br><span class="line">　　</span><br><span class="line">　　//期待的事件类型</span><br><span class="line">　　struct epoll_event event;</span><br><span class="line">   </span><br><span class="line">   //下一个epitem实例</span><br><span class="line">   struct epitem *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）调用 epoll_ctl 向添加监听的 Socket：</p><ul><li>sock 对象的 <strong>等待队列</strong>中，插入等待项（wait_queue_t 对象），这个等待项的回调函数是 epoll 的 <code>ep_poll_callback</code>，而不再是阻塞模式下的 <code>autoremove_wake_function</code></li><li>sock 对象被包装为 epitem 类型，加入红黑树管理；</li></ul><p>（3）调用 epoll_wait 同步阻塞：</p><ul><li>用户代码调用 epoll_wait 后，内核首先会查找 epoll 中的就绪队列（rdllist）是否有 IO 就绪的 sock；</li><li>如果就绪队列（rdllist）没有就绪的 sock，那么会向 epoll 的等待队列中插入当前用户进程的信息，此等待项（wait_queue_t）的回调是 <code>default_wake_function</code>，然后用户进程让出 CPU，进入阻塞；</li></ul><p>➤ sock 的<strong>接收队列</strong>有数据可读时：</p><ul><li>内核调用此 sock <strong>等待队列</strong>上等待项的回调函数，这里是 epoll 的 <code>ep_poll_callback</code>，此函数中，把就绪的 sock 插入到 epoll 的<strong>就绪队列（rdllist）</strong>中</li><li>随后查看 <code>epoll</code> 中的等待队列中是否有等待项，也就是说查看是否有进程阻塞在 <code>epoll_wait</code> 上，如果没有等待项，则软中断处理完成。</li><li>如果有等待项，则回到注册在等待项中的回调函数 <code>default_wake_function</code>,在回调函数中唤醒 <code>阻塞进程</code>，并将就绪队列 <code>rdllist</code> 中的 <code>epitem</code> 的 <code>IO就绪</code> socket 信息封装到 <code>struct epoll_event</code> 中返回。</li><li>用户进程拿到 <code>epoll_event</code>，取出就绪的socket</li></ul><p>下图是 epoll 等待数据到来的完整工作流程：</p><p><img src="/images/APUE.07b.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8epoll-2023-05-04-2.png" alt="../_images/APUE.07b.网络编程-多路复用epoll-2023-05-04-2.png"></p><p>➤ 为什么是红黑树？</p><p>这里我们再聊聊为啥要用红黑树，很多人说是因为效率高。其实我觉得这个解释不够全面，要说查找效率树哪能比的上 HASHTABLE。我个人认为觉得更为合理的一个解释是为了让 epoll 在查找效率、插入效率、内存开销等等多个方面比较均衡，最后发现最适合这个需求的数据结构是红黑树。  </p><ul><li><a href="https://mp.weixin.qq.com/s/OmRdUgO1guMX76EdZn11UQ" target="_blank" rel="noopener">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247483737&amp;idx=1&amp;sn=7ef3afbb54289c6e839eed724bb8a9d6" target="_blank" rel="noopener">聊聊Netty那些事儿之从内核角度看IO模型</a></li></ul><h3 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h3><p><strong>再谈水平触发（LT）和边缘触发（ET）</strong>：</p><p>网上有大量的关于这两种模式的讲解，大部分讲的比较模糊，感觉只是强行从概念上进行描述，看完让人难以理解。所以在这里，笔者想结合上边 epoll 的工作过程，再次对这两种模式做下自己的解读，力求清晰的解释出这两种工作模式的异同。</p><p>水平触发和边缘触发最关键的区别就在于 <strong>当 socket 中的接收缓冲区还有数据可读时。epoll_wait 是否会清空 rdllist</strong>。</p><ul><li><p><strong>水平触发（LT）</strong>：在这种模式下，用户线程调用 epoll_wait 获取到 IO 就绪的 socket 后，对 Socket 进行系统 IO 调用读取数据，假设 socket 中的数据只读了一部分没有全部读完，<strong>用户再次调用 epoll_wait 不会直接清空 rdllist</strong>，而是 epoll_wait 会检查这些 Socket 中的接收缓冲区是否还有数据可读，如果还有数据可读，就将 socket 重新放回 rdllist。所以当 socket 上的 IO 没有被处理完时，再次调用 epoll_wait 依然可以获得这些 socket，用户进程可以接着处理 socket 上的 IO 事件。</p></li><li><p><strong>边缘触发（ET）</strong>： 在这种模式下，<strong>用户再次 epoll_wait 就会直接清空 rdllist</strong>，不管 socket 上是否还有数据可读。所以在边缘触发模式下，当你没有来得及处理 socket 接收缓冲区的剩下可读数据时，再次调用 epoll_wait，因为这时 rdlist 已经被清空了，socket 不会再次从 epoll_wait 中返回，所以用户进程就不会再次获得这个 socket 了，也就无法在对它进行 IO 处理了。除非，这个 socket 上有新的 IO 数据到达，根据 epoll 的工作过程，该 socket 会被再次放入 rdllist 中。</p></li></ul><p><strong>如果你在边缘触发模式下，处理了部分 socket 上的数据，那么想要处理剩下部分的数据，就只能等到这个 socket 上再次有网络数据到达</strong>。</p><p>在 Netty 中实现的 EpollSocketChannel 默认的就是<strong>边缘触发</strong>模式。JDK 的 NIO 默认是<strong>水平触发</strong>模式。</p><blockquote><p>epoll 默认也是 LT <a href="https://stackoverflow.com/questions/24400941/how-do-we-know-whether-call-to-epoll-wait-is-edge-triggered-or-level-triggered" target="_blank" rel="noopener">https://stackoverflow.com/questions/24400941/how-do-we-know-whether-call-to-epoll-wait-is-edge-triggered-or-level-triggered</a></p></blockquote><p>@ref: <a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247483737&amp;idx=1&amp;sn=7ef3afbb54289c6e839eed724bb8a9d6" target="_blank" rel="noopener">聊聊Netty那些事儿之从内核角度看IO模型</a></p><hr><p>比较 ET 和 LT 的性能：</p><ul><li>如果数据处理和 epoll 同一线程，LT 和 ET 区别不大，如果用 LT 会从 epoll_wait 醒来更频繁，对消息处理时效性更好；</li><li>如果数据处理和 epoll 不在同一线程（例如更高并发的 RPC 实现中, 为了对大消息的反序列化也可以并行），这种情况下，如果数据处理的线程池被打满，那么 epoll_wait 所在的线程就会陷入疯狂的旋转（醒来-没有空闲的线程可以处理数据-再次 wait-唤醒），而 ET 是有消息来时才触发，和及时处理与否无关，频率低很多。</li></ul><p>@ref: <a href="https://www.zhihu.com/question/20502870" target="_blank" rel="noopener"> epoll的边沿触发模式(ET)真的比水平触发模式(LT)快吗？(当然LT模式也使用非阻塞IO，重点是要求ET模式下的代码不能造成饥饿) - 知乎</a></p><hr><p><strong>水平触发（LT）和边缘触发（ET）名字的来历？</strong>：</p><p>为了弄明白 LT（Level Triggered，水平触发） 和 ET（Edge Triggered，边沿触发），我们先要了解，这个 Level 和 Edge 是什么涵义，Level 翻译成中文这里准确的涵义应该是电平； Edge 是边沿。</p><p>这两个词曾经是电子信号领域的一个专有名词。如果，用时序图来标示一个数字电信号“010”，应该是类似下图所示：</p><p><img src="/images/APUE.07b.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8epoll-2023-05-04-1.png" alt="../_images/APUE.07b.网络编程-多路复用epoll-2023-05-04-1.png"></p><ul><li>低电平表示0，高电平表示1。</li><li>0向1变化的竖线就是上升沿，1向0变化的竖线就是下降沿。</li><li>在0或者1的情况下触发的信号就是 LT（Level Triggered，水平触发）</li><li>在0向1、1向0变化的过程中触发的信号就是 和 ET（Edge Triggered，边沿触发）</li></ul><p>0或1都是一个状态，而0向1、1向0变化则只是一个事件。</p><p>我们很直观的就可以得出结论，LT是一个持续的状态，ET是个事件性的一次性状态。</p><p>二者的差异在于：</p><ul><li><p>Level Triggered 模式下只要某个 socket 处于 readable/writable 状态，无论什么时候进行 epoll_wait 都会返回该 socket；</p></li><li><p>而 Edge Triggered 模式下只有某个 socket 从 unreadable 变为 readable 或从 unwritable 变为 writable 时，epoll_wait 才会返回该 socket。</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/20315482" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20315482</a></p><h2 id="epoll-example"><a href="#epoll-example" class="headerlink" title="epoll example"></a>epoll example</h2><p><a href="https://github.com/onestraw/epoll-example/blob/master/epoll.c" target="_blank" rel="noopener">https://github.com/onestraw/epoll-example/blob/master/epoll.c</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">listen_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">set_sockaddr(&amp;srv_addr);</span><br><span class="line">bind(listen_sock, (struct sockaddr *)&amp;srv_addr, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line"></span><br><span class="line">setnonblocking(listen_sock);</span><br><span class="line">listen(listen_sock, MAX_CONN);</span><br><span class="line"></span><br><span class="line">epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">epoll_ctl_add(epfd, listen_sock, EPOLLIN | EPOLLOUT | EPOLLET);</span><br><span class="line"></span><br><span class="line">socklen = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (events[i].data.fd == listen_sock) &#123;</span><br><span class="line"><span class="comment">/* handle new connection */</span></span><br><span class="line">conn_sock =</span><br><span class="line">    accept(listen_sock,</span><br><span class="line">   (struct sockaddr *)&amp;cli_addr,</span><br><span class="line">   &amp;socklen);</span><br><span class="line"></span><br><span class="line">inet_ntop(AF_INET, (<span class="keyword">char</span> *)&amp;(cli_addr.sin_addr),</span><br><span class="line">  buf, <span class="keyword">sizeof</span>(cli_addr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] connected with %s:%d\n"</span>, buf,</span><br><span class="line">       ntohs(cli_addr.sin_port));</span><br><span class="line"></span><br><span class="line">setnonblocking(conn_sock);</span><br><span class="line">epoll_ctl_add(epfd, conn_sock,</span><br><span class="line">      EPOLLIN | EPOLLET | EPOLLRDHUP |</span><br><span class="line">      EPOLLHUP);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="comment">/* handle EPOLLIN event */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">n = read(events[i].data.fd, buf,</span><br><span class="line"> <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span> <span class="comment">/* || errno == EAGAIN */</span> ) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] data: %s\n"</span>, buf);</span><br><span class="line">write(events[i].data.fd, buf,</span><br><span class="line">      <span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] unexpected\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* check if the connection is closing */</span></span><br><span class="line"><span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] connection closed\n"</span>);</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_DEL,</span><br><span class="line">  events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">close(events[i].data.fd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;五种-I-O-模型&quot;&gt;&lt;a href=&quot;#五种-I-O-模型&quot; class=&quot;headerlink&quot; title=&quot;五种 I/O 模型&quot;&gt;&lt;/a&gt;五种 I/O 模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;阻塞 IO&lt;/strong&gt;: 调用 read, 如果内核数据未就绪, 调用 read 的进程进入阻塞状态。应用程序调用一个 IO 函数，导致应用程序阻塞并等待数据准备就绪。如果数据没有准备好，一直等待。如果数据准备好了，则从内核拷贝到用户空间拷贝数据，IO 函数返回成功指示。&lt;br&gt;&lt;img src=&quot;/images/operating_system/Linux-IO-Blocked.png&quot; alt&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非阻塞 IO&lt;/strong&gt;: nonblocking IO 的特点是用户进程需要不断的主动询问 kernel 数据是否准备好. 当所请求的 I/O 操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的 I/O 操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用 CPU 的时间。&lt;br&gt;&lt;img src=&quot;/images/operating_system/Linux-IO-NonBlocking.png&quot; alt&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多路复用 IO&lt;/strong&gt;: 复用模型会用到 select 或者 poll 函数，这两个函数也会使进程阻塞，但是和阻塞 I/O 所不同的的，这两个函数可以同时阻塞多个 I/O 操作。而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。从而使得系统在单线程的情况下可以同时处理多个客户端请求. 与传统的多线程/多进程模型比, I/O 多路复用的最大优势是系统开销小。&lt;br&gt;和阻塞 IO 模型相比，selectI/O 复用模型相当于提前阻塞了。等到有数据到来时，再调用 recv 就不会因为要等数据就绪而发生阻塞。&lt;ul&gt;
&lt;li&gt;select: 一般采用 select + no-block, select 返回后要遍历所有阻塞在 select 上的 IO 句柄，找到数据就绪的那一个 IO 句柄后, 应用程序调用 recvfrom 将数据从内核区拷贝至用户区；&lt;/li&gt;
&lt;li&gt;epoll : 比 select 更高效，无需轮询全部句柄，epoll 只返回数据 ready 的 IO 句柄&lt;br&gt;&lt;img src=&quot;/images/operating_system/Linux-IO-Multiplexing.png&quot; alt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号驱动 IO&lt;/strong&gt;：让内核在数据就绪时用信号 SIGIO 通知我们，将此方法称为信号驱动 I/O。首先，我们允许套接字进行信号驱动 I/O，并通过系统调用 sigaction 安装一个信号处理程序。此系统调用立即返回，进程继续工作，它是非阻塞的。当数据报准备好被读时，就为该进程生成一个 SIGIO 信号。我们随即可以在信号处理程序中调用 recvfrom 来取读数据报。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步 IO&lt;/strong&gt;: 我们让内核启动操作，并在整个操作完成后（包括将数据从内核拷贝到我们自己的缓冲区）通知我们。&lt;br&gt;调用 aio_read 函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。&lt;br&gt;上面其它四种模型，至少都会在由 kernel copy data to appliction 时阻塞。而该模型是当 copy 完成后才通知 application，可见是纯异步的。&lt;br&gt;很少有 &lt;code&gt;*nix&lt;/code&gt; 系统支持，windows 的 IOCP（完成端口）则是此模型&lt;br&gt;&lt;img src=&quot;/images/operating_system/Linux-IO-Async.png&quot; alt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux I/O 模型的发展技术是： select -&amp;gt; poll -&amp;gt; epoll -&amp;gt; aio -&amp;gt; libevent -&amp;gt; libuv。另外还有 Windows 的 Completion Port。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提供一致的接口，IO Design Patterns&lt;br&gt;实际上，不管是哪种模型，都可以抽象一层出来，提供一致的接口，广为人知的有 ACE,Libevent 这些，他们都是跨平台的，而且他们自动选择最优的 I/O 复用机制，用户只需调用接口即可。说到这里又得说说2个设计模式，Reactor and Proactor。有一篇经典文章&lt;a href=&quot;http://www.artima.com/articles/io_design_patterns.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.artima.com/articles/io_design_patterns.html&lt;/a&gt;值得阅读，Libevent 是 Reactor 模型，ACE 提供 Proactor 模型。实际都是对各种 I/O 复用机制的封装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;select&quot;&gt;&lt;a href=&quot;#select&quot; class=&quot;headerlink&quot; title=&quot;select&quot;&gt;&lt;/a&gt;select&lt;/h2&gt;</summary>
    
    
    
    <category term="21.Operating-System" scheme="https://beefyheisenberg.github.io/categories/21-Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>算法概述</title>
    <link href="https://beefyheisenberg.github.io/19.Algorithm/Alg.02.%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>https://beefyheisenberg.github.io/19.Algorithm/Alg.02.%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</id>
    <published>2023-05-09T04:45:01.227Z</published>
    <updated>2023-05-09T04:45:01.228Z</updated>
    
    <content type="html"><![CDATA[<p>@todo:</p><ul><li>算法设计:  排序, 贪心, 分治, 动态规划, 回溯, 随机化</li><li>数学基础: 二分查找, 欧几里得算法, 快速幂算法</li><li>字符串匹配算法: KMP</li><li>图论算法:<ul><li>拓扑顺序</li><li>最短路径: Dijkstra算法, Floyd-Warshall算法</li><li>最小生成树: Prim, Kruskal</li></ul></li><li>搜索算法: BFS, DFS, A*搜索</li><li>几何算法: 向量, 凸包</li><li>快速傅里叶变换(FFT): 离散傅里叶变换</li></ul><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="几何级数-amp-算数级数"><a href="#几何级数-amp-算数级数" class="headerlink" title="几何级数 &amp; 算数级数"></a>几何级数 &amp; 算数级数</h2><ul><li>几何级数: $$ 1 + 2^1 + 2^2 + … + 2^N = 2^(N+1) -1 ≈ 2^N $$</li><li>算术级数: $$ 1 + 2 + 3 + … + N = N(N+1)/2  ≈ N^2/2 $$</li></ul><h2 id="复杂度表示法"><a href="#复杂度表示法" class="headerlink" title="复杂度表示法"></a>复杂度表示法</h2><p>▶ 大O符号（英语：Big O notation） 用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。<br>设函数 $f(n)$ 代表某一算法在输入大小为n的情况下的工作量（效率），<br>我们将 $f(n)$ 与另一行为已知的函数 $g(n)$ 进行比较，<br>如果存在正数 C 和 n0，使得对于一切 $ n &gt;= n0 $ 有： $ 0 &lt;= f(n) &lt;= C g(n) $，<br>则可以称 $f(n)$ 的渐进上界是 $g(n)$，记做 $ f(n) = O(g(n)) $，</p><p>▶ 小O符号： 类似大O，也用来表示「渐近上界」，<br>对于任意正数 C 和 n0，使得对于一切 $ n &gt;= n0 $ 有： $ 0  &lt;= f(n) &lt; C g(n) $，<br>则可以称 $f(n)$ 的渐进下界是 $g(n)$，记做 $ f(n) = o(g(n)) $。<br>注意与大O定义的不同：</p><ul><li>大O:「只要存在一个正数C」以及 $ f(n) &lt;= C g(n) $。</li><li>小O:「任意正数C」以及 $ f(n) &lt; C g(n) $。</li><li>两者都描述上限，但小O是更强有力的陈述，如果f∈o(g)，则f和g的增长率之间的差距比f∈O(g)时大得多。</li></ul><p>例如, $ f(n) = n^2 + n $，则 $ f(n) $ 的复杂度可以记为 $ o(n^3) $</p><p><img src="/images/alg/big-o.png" alt="Big-O"></p><p>▶ 大Ω符号，读音：big omega，用另一个（通常更简单的）函数来描述一个函数数量级的「渐进下界」。<br>如果存在正数 C 和 n0，使得对于一切 $ n &gt;= n0 $ 有： $ 0  &lt;= C g(n) &lt;= f(n) $，<br>则可以称 $f(n)$ 的渐进下界是 $g(n)$，记做 $ f(n) = Ω(g(n)) $</p><p><img src="/images/alg/big-omega.png" alt="big-omega"></p><p>@ref: <a href="https://www.coursera.org/lecture/algorithms/007han-shu-de-jian-jin-de-jie-bnDM3" target="_blank" rel="noopener">007函数的渐近的界 - 算法基础 | Coursera</a></p><h2 id="常用算法复杂度分析"><a href="#常用算法复杂度分析" class="headerlink" title="常用算法复杂度分析"></a>常用算法复杂度分析</h2><p>算法中 $log$ 级别的时间复杂度都是由于使用了分治思想, 这个底数直接由分治的复杂度决定:</p><ul><li>如果采用二分法, 那么就是  $log_2n$, 三分法就是 $log_3n$, 其他亦然;</li><li>不过无论底数是什么, 对数函数的渐进趋势是一样的, 所以通常忽略底数只用 $logn$ 表示;</li></ul><p>场景复杂度的增长趋势如下图: $O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$</p><p><img src="/images/alg/Big-O-Chart.png" alt="时间复杂度增长趋势"></p><h3 id="排序算法复杂度"><a href="#排序算法复杂度" class="headerlink" title="排序算法复杂度"></a>排序算法复杂度</h3><p><img src="/images/alg/sorting-algorithms-complexity.png" alt="Sorting_Algorithms_Complexity"></p><h3 id="数据结构复杂度"><a href="#数据结构复杂度" class="headerlink" title="数据结构复杂度"></a>数据结构复杂度</h3><p><img src="/images/alg/common-data-structure-operations-complexity.png" alt="Common_Data_Structure_Operations"></p><h3 id="Big-O-Cheat"><a href="#Big-O-Cheat" class="headerlink" title="Big-O Cheat"></a>Big-O Cheat</h3><p><img src="/images/alg/big-o-cheat-sheet-poster.png" alt="bigocheatsheet"></p><p>@ref： <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell</a></p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><h2 id="贪婪"><a href="#贪婪" class="headerlink" title="贪婪"></a>贪婪</h2><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/77429266" target="_blank" rel="noopener">贪心算法详解</a></li></ul><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/77427116" target="_blank" rel="noopener">分治算法详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/26033061" target="_blank" rel="noopener">map-reduce中的分治思想</a></li></ul><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>@todo</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="https://blog.csdn.net/Chenyukuai6625/article/details/77435778" target="_blank" rel="noopener">动态规划详解</a></li></ul><h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><h2 id="深度优先-amp-广度优先"><a href="#深度优先-amp-广度优先" class="headerlink" title="深度优先 &amp; 广度优先"></a>深度优先 &amp; 广度优先</h2><p>@todo</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>@todo</p><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>@todo</p><h3 id="无权最短路径"><a href="#无权最短路径" class="headerlink" title="无权最短路径"></a>无权最短路径</h3><p>@todo</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>@todo</p><h2 id="网络流问题"><a href="#网络流问题" class="headerlink" title="网络流问题"></a>网络流问题</h2><p>@todo</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>@todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;@todo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法设计:  排序, 贪心, 分治, 动态规划, 回溯, 随机化&lt;/li&gt;
&lt;li&gt;数学基础: 二分查找, 欧几里得算法, 快速幂算法&lt;/li&gt;
&lt;li&gt;字符串匹配算法: KMP&lt;/li&gt;
&lt;li&gt;图论算法:&lt;ul&gt;
&lt;li&gt;拓扑顺序&lt;/li&gt;
&lt;li&gt;最短路径: Dijkstra算法, Floyd-Warshall算法&lt;/li&gt;
&lt;li&gt;最小生成树: Prim, Kruskal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;搜索算法: BFS, DFS, A*搜索&lt;/li&gt;
&lt;li&gt;几何算法: 向量, 凸包&lt;/li&gt;
&lt;li&gt;快速傅里叶变换(FFT): 离散傅里叶变换&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;复杂度分析&quot;&gt;&lt;a href=&quot;#复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;复杂度分析&quot;&gt;&lt;/a&gt;复杂度分析&lt;/h1&gt;&lt;h2 id=&quot;几何级数-amp-算数级数&quot;&gt;&lt;a href=&quot;#几何级数-amp-算数级数&quot; class=&quot;headerlink&quot; title=&quot;几何级数 &amp;amp; 算数级数&quot;&gt;&lt;/a&gt;几何级数 &amp;amp; 算数级数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;几何级数: $$ 1 + 2^1 + 2^2 + … + 2^N = 2^(N+1) -1 ≈ 2^N $$&lt;/li&gt;
&lt;li&gt;算术级数: $$ 1 + 2 + 3 + … + N = N(N+1)/2  ≈ N^2/2 $$&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="19.Algorithm" scheme="https://beefyheisenberg.github.io/categories/19-Algorithm/"/>
    
    
    <category term="数据结构与算法" scheme="https://beefyheisenberg.github.io/tags/数据结构与算法/"/>
    
    <category term="排序" scheme="https://beefyheisenberg.github.io/tags/排序/"/>
    
    <category term="贪心" scheme="https://beefyheisenberg.github.io/tags/贪心/"/>
    
    <category term="分治" scheme="https://beefyheisenberg.github.io/tags/分治/"/>
    
    <category term="动态规划" scheme="https://beefyheisenberg.github.io/tags/动态规划/"/>
    
    <category term="回溯" scheme="https://beefyheisenberg.github.io/tags/回溯/"/>
    
    <category term="二分查找" scheme="https://beefyheisenberg.github.io/tags/二分查找/"/>
    
    <category term="KMP" scheme="https://beefyheisenberg.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>Alg.01.数据结构-4图</title>
    <link href="https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE/"/>
    <id>https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE/</id>
    <published>2023-05-09T04:45:01.218Z</published>
    <updated>2023-05-09T04:45:01.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><p>在图中的数据元素通常称为结点，<strong>V</strong> 是所有顶点的集合，<strong>E</strong> 是所有边的集合。如果两个顶点 v, w，只能由 v 向 w，而不能由 w 向 v，那么我们就把这种情况叫做一个从 v 到 w 的有向边。v 也被称做初始点，w 也被称为终点。这种图就被称做<strong>有向图</strong>。</p><p>如果v和w是没有顺序的，从v到达w和从w到达v是完全相同的，这种图就被称为<strong>无向图</strong>。</p><p>假如，图中的结点个数为 n，那么在一个无向图，假设每对结点之间只能有一条边，那么这个无向图中的边数最多只有 $ 1/2 n (n-1) $。边数最多的无向图也叫<strong>完全图</strong>。</p><p>同样的，对于有向图，边数最多有 $ n(n-1) $ 个，边数最多的有向图叫<strong>有向完全图</strong>。</p><p>如果图中的边数很少，这种图也被叫<strong>稀疏图</strong>。稀疏图是一种大约的概念，并没有一定的数值，说边数低于这个数值的时候就是稀疏图，在不同的场景下，稀疏图的定义会不一样。反之，如果边数比较多，就称为<strong>稠密图</strong>。</p><p>有时图的边具有与它相关的数，这种与图的边相关的数就叫做<strong>权</strong>。例如，从A地到B地的车票是80块钱，那这个80就是这条路上的耗费，我们如果把这样的交通网做成一个图，就变成了一个<strong>带权有向图</strong>。这种图也被称为<strong>网络</strong>。</p><p>一个顶点如果有多个边与其相联，那么这些相联的边数就称为点的<strong>度</strong>。如果是有向图，那么初始点就有<strong>出度</strong>，而终点则有<strong>入度</strong>。</p><p><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-1.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-1.png"></p><h3 id="图的表达-amp-邻接表"><a href="#图的表达-amp-邻接表" class="headerlink" title="图的表达 &amp; 邻接表"></a>图的表达 &amp; 邻接表</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>使用二维数组来表示一个图：</p><p>对于图 G，假如其中有 n 个结点，我们可以定义一个二维数组 <code>A[n][n]</code>，如果顶点 Vi 和顶点 Vj 之间存在边 Eij，那么就将 <code>A[i][j]</code> 设为1，否则设为0。就称二维数组 A 是图 G 的<strong>邻接矩阵</strong>。</p><p><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-5.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-5.png"></p><p>如果图 G 是无向图，那么，如果 <code>A[i][j]</code> 为1，可以推知 <code>A[j][i]</code> 也为1（对称）。如果 G 是有向图（见下图），则不存在这个规律。</p><p><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-4.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-4.png"></p><p>如果 G 的边上有权重，图 G 是一个带权有向图，顶点顶点 Vi 和顶点 Vj 之间存在边 Eij，且 Eij 的权重为 Wij，就令 <code>A[i][j]</code> 的值为 Wij。如果两个顶点 Vi 和顶点 Vj 之间不存在边，那么就记 <code>A[k][l]</code>为无穷大。在实际的实现中可以使用整型的最大值代替。</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>显然，用邻接矩阵并不适合表达一个稀疏图，不仅有空间上的浪费，另外二维数组的时间 &amp; 空间复杂度都是 N^2</p><p>另外一种比较直接的思路就是使用多向链表。<br>用一个结构体表示图的一个节点，结构体中包含数据域和多个指针，其中数据域存储该顶点的信息，指针指向有连接的其他节点。</p><p>这样做的一个缺点是，由于图中各个节点的<strong>度数</strong>各不相同，最大度数和最小度数可能相差很多，因此，若按度数最大的顶点设计结点结构，则会浪费很多存储单元。而如果按照每个顶点自己的度数设计不同的结点结构，所带来的编程的复杂度得不偿失。</p><p>所以，我们就用一种改进的方案：使用链表代表一个结点，这种方案被称为<strong>邻接表</strong>。</p><p>在邻接表中，图中的每一个节点都用一个链表表示。设链表 i 对应节点 i，链表 i 中每个元素都表示节点 i 的一条边。<br>链表中的每个结点都由 3 个域组成：链表中的每个结点都由3个域组成，其中邻接点域表示与vi 相邻的点，例如与vi相 邻的vj，这个结点就是vj；链(nextArc)代表顶点i与顶点j之间的边eij；数据域(info)存储和边 相关的信息，例如权重等。</p><p>例如下面一个图：<br><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-2.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-2.png"></p><p>用邻接表表示则为：<br><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-3.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-3.png"></p><p>上面这种实现方法为图中的每一个顶点（左边部分）都建立了一个单链表（右边部分）。这样我们就可以通过遍历每个顶点的链表，从而得到该顶点所有的边了。</p><p>通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而上面的邻接表只能表示顶点的“出度”，但没有表示“入度”。</p><p>这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><p>➤  <strong>逆邻接表</strong></p><p>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-6.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-6.png"></p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表：</p><p><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-7.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-7.png"></p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><blockquote><p><strong>data</strong>：用于存储该顶点中的数据； <strong>firstin指针</strong>：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点； <strong>firstout指针</strong>：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；</p></blockquote><p>边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><blockquote><p><strong>tailvex</strong>：用于存储作为弧尾的顶点的编号； <strong>headvex</strong>：用于存储作为弧头的顶点的编号； <strong>headlink 指针</strong>：用于链接下一个存储作为弧头的顶点的节点； <strong>taillink 指针</strong>：用于链接下一个存储作为弧尾的顶点的节点；</p></blockquote><p><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844-%E5%9B%BE-2023-05-08-8.png" alt="../_images/Alg.01.数据结构4-图-2023-05-08-8.png"></p><p>以上图为例子，对于顶点 A 而言，其作为起点能够到达顶点 E。因此在邻接表中顶点 A 要通过边 <code>AE</code>（即边04）指向顶点 E，顶点 A 的 <code>firstout</code> 指针需要指向边04的 <code>tailvex</code>。同时，从 B 出发能够到达 A，所以在逆邻接表中顶点 A 要通过边 <code>AB</code>（即边10）指向 B，顶点 A 的 <code>firstin</code> 指针需要指向边10的弧头，即 <code>headlink</code> 指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><hr><p>@ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/26810667" target="_blank" rel="noopener">图算法：图的表达</a></li><li><a href="https://developer.aliyun.com/article/333511" target="_blank" rel="noopener">图的存储结构之邻接表(详解)-阿里云开发者社区</a></li></ul><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27829340" target="_blank" rel="noopener">图的非递归遍历</a></li></ul><h2 id="深度优先和广度优先"><a href="#深度优先和广度优先" class="headerlink" title="深度优先和广度优先"></a>深度优先和广度优先</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26987139" target="_blank" rel="noopener">图的深度优先搜索</a></li><li><a href="https://zhuanlan.zhihu.com/p/26855400" target="_blank" rel="noopener">图的广度优先搜索</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;图的概念&quot;&gt;&lt;a href=&quot;#图的概念&quot; class=&quot;headerlink&quot; title=&quot;图的概念&quot;&gt;&lt;/a&gt;图的概念&lt;/h2&gt;&lt;p&gt;在图中的数据元素通常称为结点，&lt;strong&gt;V&lt;/strong&gt; 是所有顶点的集合，&lt;strong&gt;E&lt;/strong&gt; 是所有边的集合。如果两个顶点 v, w，只能由 v 向 w，而不能由 w 向 v，那么我们就把这种情况叫做一个从 v 到 w 的有向边。v 也被称做初始点，w 也被称为终点。这种图就被称做&lt;strong&gt;有向图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果v和w是没有顺序的，从v到达w和从w到达v是完全相同的，这种图就被称为&lt;strong&gt;无向图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假如，图中的结点个数为 n，那么在一个无向图，假设每对结点之间只能有一条边，那么这个无向图中的边数最多只有 $ 1/2 n (n-1) $。边数最多的无向图也叫&lt;strong&gt;完全图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;同样的，对于有向图，边数最多有 $ n(n-1) $ 个，边数最多的有向图叫&lt;strong&gt;有向完全图&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="19.Algorithm" scheme="https://beefyheisenberg.github.io/categories/19-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Alg.01.数据结构-3a散列函数-MD5算法原理及实现</title>
    <link href="https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843a-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0-MD5/"/>
    <id>https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843a-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0-MD5/</id>
    <published>2023-05-09T04:45:01.208Z</published>
    <updated>2023-05-09T04:45:01.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p><strong>散列函数，也称作哈希函数，消息摘要函数，单向函数或者杂凑函数</strong>。散列函数主要用于验证数据的完整性。通过散列函数，可以创建消息的“数字指纹”，消息接收方可以通过校验消息的哈希值来验证消息的完整性，防止消息被篡改。散列函数具有以下特性：</p><ol><li>散列函数的运算过程是不可逆的，这个称为散列函数的单向性。</li><li>对于一个已知的消息及其散列值，要找到另外一个消息使其获得相同的散列值是不可能的，这个特性称为散列函数的弱碰撞性。这个特性可以用来防止消息伪造。</li><li>任意两个不同消息的散列值一定不同。</li><li>对原始消息长度没有限制。</li></ol><p>任何消息经过散列函数处理后，都会产生一个唯一的散列值，这个散列值可以用来验证消息的完整性。计算消息散列值的过程被称为“消息摘要”，计算消息散列值的算法被称为消息摘要算法。常使用的消息摘要算法有：MD—消息摘要算法，SHA—安全散列算法，MAC—消息认证码算法。本文主要来了解MD算法。</p><h2 id="MD5算法原理"><a href="#MD5算法原理" class="headerlink" title="MD5算法原理"></a>MD5算法原理</h2><p>假设原始消息长度是b（以bit为单位），注意这里b可以是任意长度，并不一定要是8的整数倍。计算该消息MD5值的过程如下：</p><h3 id="1-填充信息"><a href="#1-填充信息" class="headerlink" title="1.填充信息"></a>1.填充信息</h3><p>在计算消息的MD5值之前，首先对原始信息进行填充，这里的信息填充分为两步。<br>第一步，对原始信息进行填充，填充之后，要求信息的长度对512取余等于448。填充的规则如下：假设原始信息长度为b bit，那么在信息的b+1 bit位填充1，剩余的位填充0，直到信息长度对512取余为448。这里有一点需要注意，如果原始信息长度对512取余正好等于448，这种情况仍然要进行填充，很明显，在这时我们要填充的信息长度是512位，直到信息长度对512取余再次等于448。所以，填充的位数最少为1，最大为512。<br>第二步，填充信息长度，我们需要把原始信息长度转换成以bit为单位，然后在第一步操作的结果后面填充64bit的数据表示原始信息长度。第一步对原始信息进行填充之后，信息长度对512取余结果为448，这里再填充64bit的长度信息，整个信息恰好可以被512整除。其实从后续过程可以看到，计算MD5时，是将信息分为若干个分组进行处理的，每个信息分组的长度是512bit。</p><h3 id="2-分组处理"><a href="#2-分组处理" class="headerlink" title="2.分组处理"></a>2.分组处理</h3><p>在进行MD5值计算之前，我们先来做一些定义。</p><ul><li><strong>信息分组定义</strong><br>原始信息经过填充之后，最终得到的信息长度（bit）是512的整数倍，我们先对信息进行分组，每512bit为一个分组，然后再将每个信息分组（512bit）再细分为16个小的分组，每个小分组的长度为32bit。规定如下<br>$M_p$ 代表经过填充之后的信息<br>$L_M$ 表示 $M_p$ 的长度（以 bit 为单位）<br>N 表示分组个数，$N = L_M/512$<br>$M[i]$ 表示将原始信息进行分组后的第 i 个信息分组，其中 i=1…N<br>$X[i]$ 表示将 $M[i]$ 进行分组后的第 i 个小分组，其中 i=1…16</li><li><strong>标准幻数定义</strong><br>现定义四个标准幻数如下，<br>A = 01 23 45 67<br>B = 89 ab cd ef<br>C = fe dc ba 98<br>D = 76 54 32 10<br>在计算机中存储时，采用小端存储方式，以A为例，A在Java中初始化的代码为为A=0x67452301</li><li><strong>常量表T</strong><br>T 是一个常量表，$T[i] = 4294967296 * abs(sin(i))$ 的运算结果取整，其中 i=1…64</li><li><strong>辅助方法</strong><br>我们定义四个辅助方法。<br>F(x,y,z) = (x &amp; y) | ((~x) &amp; z)<br>G(x,y,z) = (x &amp; z) | (y &amp; (~z))<br>H(x,y,z) = x ^ y ^ z<br>I(x,y,z) = y ^ (x | (~z))<br>其中，x，y，z长度为32bit</li></ul><p>下面就是最核心的信息处理过程，计算MD5的过程实际上就是轮流处理每个信息分组的过程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A=0x67452301</span><br><span class="line">B=0xefcdab89</span><br><span class="line">C=0x98badcfe</span><br><span class="line">D=0x10325476</span><br><span class="line">for( j=1;j&lt;=N;j++)&#123;  //依次处理每个分组，其中N代表分组个数</span><br><span class="line">      AA = A </span><br><span class="line">      BB = B </span><br><span class="line">      CC = C</span><br><span class="line">      DD = D</span><br><span class="line">      //开始处理分组，每个信息分组要经过4轮处理</span><br><span class="line">      /*第一轮</span><br><span class="line">      假设 [abcd k s i] 表示执行的运算是 a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中&lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺序从左到右。*/</span><br><span class="line">    [ABCD 0 7 1] [DABC 1 12 2] [CDAB 2 17 3] [BCDA 3 22 4]</span><br><span class="line">    [ABCD 4 7 5] [DABC 5 12 6] [CDAB 6 17 7] [BCDA 7 22 8]</span><br><span class="line">    [ABCD 8 7 9] [DABC 9 12 10] [CDAB 10 17 11] [BCDA 11 22 12]</span><br><span class="line">    [ABCD 12 7 13] [DABC 13 12 14] [CDAB 14 17 15] [BCDA 15 22 16]</span><br><span class="line"></span><br><span class="line">    /*第二轮</span><br><span class="line">    假设 [abcd k s i] 表示执行的运算是 a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中 &lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺 序从左到右。*/</span><br><span class="line">    [ABCD 1 5 17] [DABC 6 9 18] [CDAB 11 14 19] [BCDA 0 20 20]</span><br><span class="line">    [ABCD 5 5 21] [DABC 10 9 22] [CDAB 15 14 23] [BCDA 4 20 24]</span><br><span class="line">    [ABCD 9 5 25] [DABC 14 9 26] [CDAB 3 14 27] [BCDA 8 20 28]</span><br><span class="line">    [ABCD 13 5 29] [DABC 2 9 30] [CDAB 7 14 31] [BCDA 12 20 32]</span><br><span class="line"></span><br><span class="line">    /*第三轮</span><br><span class="line">    假设 [abcd k s i] 表示执行的运算是 a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中&lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺 序从左到右。*/</span><br><span class="line">    [ABCD 5 4 33] [DABC 8 11 34] [CDAB 11 16 35] [BCDA 14 23 36]</span><br><span class="line">    [ABCD 1 4 37] [DABC 4 11 38] [CDAB 7 16 39] [BCDA 10 23 40]</span><br><span class="line">    [ABCD 13 4 41] [DABC 0 11 42] [CDAB 3 16 43] [BCDA 6 23 44]</span><br><span class="line">    [ABCD 9 4 45] [DABC 12 11 46] [CDAB 15 16 47] [BCDA 2 23 48]</span><br><span class="line"></span><br><span class="line">    /*第四轮</span><br><span class="line">    假设 [abcd k s i] 表示执行的运算是 a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s)，其中&lt;&lt;&lt;表示循环移位。第一轮运算就是对分组执行以下所示的16次运算，运算的顺序从左到右。*/</span><br><span class="line">    [ABCD 0 6 49] [DABC 7 10 50] [CDAB 14 15 51] [BCDA 5 21 52]</span><br><span class="line">    [ABCD 12 6 53] [DABC 3 10 54] [CDAB 10 15 55] [BCDA 1 21 56]</span><br><span class="line">    [ABCD 8 6 57] [DABC 15 10 58] [CDAB 6 15 59] [BCDA 13 21 60]</span><br><span class="line">    [ABCD 4 6 61] [DABC 11 10 62] [CDAB 2 15 63] [BCDA 9 21 64]</span><br><span class="line">    </span><br><span class="line">    //将当前消息分组的运算结果和上一次的结果进行累加</span><br><span class="line">    A = A + AA</span><br><span class="line">    B = B + BB</span><br><span class="line">    C = C + CC</span><br><span class="line">    D = D + DD</span><br><span class="line">&#125;</span><br><span class="line">//最终我们按照低字节在前的顺序依次将A,B,C,D拼接起来，就是计算得到的MD5值，因此，MD5值的长度是固定的，为128bit。</span><br></pre></td></tr></table></figure><h2 id="JDK-中的-MD5实现"><a href="#JDK-中的-MD5实现" class="headerlink" title="JDK 中的 MD5实现"></a>JDK 中的 MD5实现</h2><p>Java提供的标准MD5算法实现如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Test</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//标准的幻数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> A=<span class="number">0x67452301</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> B=<span class="number">0xefcdab89</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> C=<span class="number">0x98badcfe</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> D=<span class="number">0x10325476</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S11 = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S12 = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S13 = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S14 = <span class="number">22</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S21 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S22 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S23 = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S24 = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S31 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S32 = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S33 = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S34 = <span class="number">23</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S41 = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S42 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S43 = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> S44 = <span class="number">21</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GROUP_LEN = <span class="number">64</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] digest(<span class="keyword">byte</span>[] input)&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] paddingData = getPaddingData(input); <span class="comment">//对原始数据进行补位       </span></span><br><span class="line">        <span class="keyword">return</span> process(paddingData);<span class="comment">//处理分组，核心算法</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getGroupData(<span class="keyword">byte</span>[] data,<span class="keyword">int</span> index)&#123;</span><br><span class="line">        <span class="keyword">int</span> [] groupData=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">            groupData[i] = (data[<span class="number">4</span>*i+index]&amp;<span class="number">0xFF</span>)| <span class="comment">//这里注意，在byte转int时一定要进行&amp;0xff操作</span></span><br><span class="line">                           (data[<span class="number">4</span>*i+<span class="number">1</span>+index]&amp;<span class="number">0xFF</span>)&lt;&lt;<span class="number">8</span>|</span><br><span class="line">                           (data[<span class="number">4</span>*i+<span class="number">2</span>+index]&amp;<span class="number">0xFF</span>)&lt;&lt;<span class="number">16</span>|</span><br><span class="line">                           (data[<span class="number">4</span>*i+<span class="number">3</span>+index]&amp;<span class="number">0xFF</span>)&lt;&lt;<span class="number">24</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> groupData;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getConstTable() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] T = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">64</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">65</span>;i++) &#123;</span><br><span class="line">            T[i-<span class="number">1</span>] = (<span class="keyword">int</span>)((<span class="keyword">long</span>)(Math.abs(Math.sin(i))*<span class="number">4294967296l</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getPaddingData(<span class="keyword">byte</span>[] input) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = input.length;</span><br><span class="line">        <span class="keyword">long</span> bitLength = length &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> rest = length % <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rest &lt; <span class="number">56</span>) &#123;</span><br><span class="line">            paddingLength = <span class="number">64</span>-rest;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            paddingLength = <span class="number">128</span> - rest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] paddingData = <span class="keyword">new</span> <span class="keyword">byte</span>[length+paddingLength];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">            paddingData[i] = input[i];</span><br><span class="line">        &#125;</span><br><span class="line">        paddingData[length] = (<span class="keyword">byte</span>)(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;paddingLength-<span class="number">8</span>;i++) &#123;</span><br><span class="line">            paddingData[length+i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            paddingData[length+paddingLength-<span class="number">8</span>+i]=(<span class="keyword">byte</span>)(bitLength&amp;<span class="number">0xFF</span>);</span><br><span class="line">            bitLength = bitLength &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paddingData;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] process(<span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">int</span> [] result = &#123;A,B,C,D&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = data.length; </span><br><span class="line">        <span class="keyword">int</span> groupCount = length/<span class="number">64</span>; <span class="comment">//计算分组数量,每组512位（64字节）</span></span><br><span class="line">        <span class="keyword">int</span>[] T = getConstTable();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> groupIndex=<span class="number">0</span>;groupIndex&lt;groupCount;groupIndex++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] x=getGroupData(data,groupIndex*GROUP_LEN);<span class="comment">//获取分组数据</span></span><br><span class="line">            <span class="keyword">int</span> a = result[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> b = result[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> c = result[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> d = result[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/*第一轮*/</span></span><br><span class="line">            a = FF(a, b, c, d, x[<span class="number">0</span>], S11, T[<span class="number">0</span>]); <span class="comment">//a = b + ((a + F(b,c,d) + X[0] + T[0]) &lt;&lt;&lt; 7)</span></span><br><span class="line">            d = FF(d, a, b, c, x[<span class="number">1</span>], S12, T[<span class="number">1</span>]); <span class="comment">//d = a + ((d + F(a,b,c) + X[1] + T[1]) &lt;&lt;&lt; 12)</span></span><br><span class="line">            c = FF(c, d, a, b, x[<span class="number">2</span>], S13, T[<span class="number">2</span>]); <span class="comment">//c = d + ((c + F(d,a,b) + X[2] + T[2]) &lt;&lt;&lt; 17)</span></span><br><span class="line">            b = FF(b, c, d, a, x[<span class="number">3</span>], S14, T[<span class="number">3</span>]); <span class="comment">//b = c + ((b + F(c,d,a) + X[3] + T[3]) &lt;&lt;&lt; 22)</span></span><br><span class="line">            a = FF(a, b, c, d, x[<span class="number">4</span>], S11, T[<span class="number">4</span>]); <span class="comment">//a = b + ((a + F(b,c,d) + X[4] + T[4]) &lt;&lt;&lt; 7)</span></span><br><span class="line">            d = FF(d, a, b, c, x[<span class="number">5</span>], S12, T[<span class="number">5</span>]); <span class="comment">//d = a + ((d + F(a,b,c) + X[5] + T[5]) &lt;&lt;&lt; 12)</span></span><br><span class="line">            c = FF(c, d, a, b, x[<span class="number">6</span>], S13, T[<span class="number">6</span>]); <span class="comment">//c = d + ((c + F(d,a,b) + X[6] + T[6]) &lt;&lt;&lt; 17)</span></span><br><span class="line">            b = FF(b, c, d, a, x[<span class="number">7</span>], S14, T[<span class="number">7</span>]); <span class="comment">//b = c + ((b + F(c,d,a) + X[7] + T[7]) &lt;&lt;&lt; 22)</span></span><br><span class="line">            a = FF(a, b, c, d, x[<span class="number">8</span>], S11, T[<span class="number">8</span>]); <span class="comment">//a = b + ((a + F(b,c,d) + X[8] + T[8]) &lt;&lt;&lt; 7)</span></span><br><span class="line">            d = FF(d, a, b, c, x[<span class="number">9</span>], S12, T[<span class="number">9</span>]); <span class="comment">//d = a + ((d + F(a,b,c) + X[9] + T[9]) &lt;&lt;&lt; 12)</span></span><br><span class="line">            c = FF(c, d, a, b, x[<span class="number">10</span>], S13, T[<span class="number">10</span>]); <span class="comment">//c = d + ((c + F(d,a,b) + X[10] + T[10]) &lt;&lt;&lt; 17)</span></span><br><span class="line">            b = FF(b, c, d, a, x[<span class="number">11</span>], S14, T[<span class="number">11</span>]); <span class="comment">//b = c + ((b + F(c,d,a) + X[11] + T[12]) &lt;&lt;&lt; 22)</span></span><br><span class="line">            a = FF(a, b, c, d, x[<span class="number">12</span>], S11, T[<span class="number">12</span>]); <span class="comment">//a = b + ((a + F(b,c,d) + X[12] + T[12]) &lt;&lt;&lt; 7)</span></span><br><span class="line">            d = FF(d, a, b, c, x[<span class="number">13</span>], S12, T[<span class="number">13</span>]); <span class="comment">//d = a + ((d + F(a,b,c) + X[13] + T[13]) &lt;&lt;&lt; 12)</span></span><br><span class="line">            c = FF(c, d, a, b, x[<span class="number">14</span>], S13, T[<span class="number">14</span>]); <span class="comment">//c = d + ((c + F(d,a,b) + X[14] + T[14]) &lt;&lt;&lt; 17)</span></span><br><span class="line">            b = FF(b, c, d, a, x[<span class="number">15</span>], S14, T[<span class="number">15</span>]); <span class="comment">//b = c + ((b + F(c,d,a) + X[15] + T[15]) &lt;&lt;&lt; 22)</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*第二轮*/</span></span><br><span class="line">            a = GG(a, b, c, d, x[<span class="number">1</span>], S21, T[<span class="number">16</span>]); <span class="comment">//a = b + ((a + G(b,c,d) + X[1] + T[16]) &lt;&lt;&lt; 5)</span></span><br><span class="line">            d = GG(d, a, b, c, x[<span class="number">6</span>], S22, T[<span class="number">17</span>]); <span class="comment">//d = a + ((d + G(a,b,c) + X[6] + T[17]) &lt;&lt;&lt; 9)</span></span><br><span class="line">            c = GG(c, d, a, b, x[<span class="number">11</span>], S23, T[<span class="number">18</span>]); <span class="comment">//c = d + ((c + G(d,a,b) + X[11] + T[18]) &lt;&lt;&lt; 14)</span></span><br><span class="line">            b = GG(b, c, d, a, x[<span class="number">0</span>], S24, T[<span class="number">19</span>]); <span class="comment">//b = c + ((b + G(c,d,a) + X[0] + T[19]) &lt;&lt;&lt; 20)</span></span><br><span class="line">            a = GG(a, b, c, d, x[<span class="number">5</span>], S21, T[<span class="number">20</span>]); <span class="comment">//a = b + ((a + G(b,c,d) + X[5] + T[20]) &lt;&lt;&lt; 5)</span></span><br><span class="line">            d = GG(d, a, b, c, x[<span class="number">10</span>], S22, T[<span class="number">21</span>]); <span class="comment">///d = a + ((d + G(a,b,c) + X[10] + T[21]) &lt;&lt;&lt; 9)</span></span><br><span class="line">            c = GG(c, d, a, b, x[<span class="number">15</span>], S23, T[<span class="number">22</span>]); <span class="comment">///c = d + ((c + G(d,a,b) + X[15] + T[22]) &lt;&lt;&lt; 14)</span></span><br><span class="line">            b = GG(b, c, d, a, x[<span class="number">4</span>], S24, T[<span class="number">23</span>]); <span class="comment">//b = c + ((b + G(c,d,a) + X[4] + T[23]) &lt;&lt;&lt; 20)</span></span><br><span class="line">            a = GG(a, b, c, d, x[<span class="number">9</span>], S21, T[<span class="number">24</span>]); <span class="comment">///a = b + ((a + G(b,c,d) + X[9] + T[24]) &lt;&lt;&lt; 5)</span></span><br><span class="line">            d = GG(d, a, b, c, x[<span class="number">14</span>], S22, T[<span class="number">25</span>]); <span class="comment">//d = a + ((d + G(a,b,c) + X[14] + T[25]) &lt;&lt;&lt; 9)</span></span><br><span class="line">            c = GG(c, d, a, b, x[<span class="number">3</span>], S23, T[<span class="number">26</span>]); <span class="comment">//c = d + ((c + G(d,a,b) + X[3] + T[26]) &lt;&lt;&lt; 14)</span></span><br><span class="line">            b = GG(b, c, d, a, x[<span class="number">8</span>], S24, T[<span class="number">27</span>]); <span class="comment">//b = c + ((b + G(c,d,a) + X[8] + T[27]) &lt;&lt;&lt; 20)</span></span><br><span class="line">            a = GG(a, b, c, d, x[<span class="number">13</span>], S21, T[<span class="number">28</span>]); <span class="comment">//a = b + ((a + G(b,c,d) + X[13] + T[28]) &lt;&lt;&lt; 5)</span></span><br><span class="line">            d = GG(d, a, b, c, x[<span class="number">2</span>], S22, T[<span class="number">29</span>]); <span class="comment">//d = a + ((d + G(a,b,c) + X[2] + T[29]) &lt;&lt;&lt; 9)</span></span><br><span class="line">            c = GG(c, d, a, b, x[<span class="number">7</span>], S23, T[<span class="number">30</span>]); <span class="comment">//c = d + ((c + G(d,a,b) + X[7] + T[30]) &lt;&lt;&lt; 14)</span></span><br><span class="line">            b = GG(b, c, d, a, x[<span class="number">12</span>], S24, T[<span class="number">31</span>]); <span class="comment">//b = c + ((b + G(c,d,a) + X[12] + T[31]) &lt;&lt;&lt; 20)</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*第三轮*/</span></span><br><span class="line">            a = HH(a, b, c, d, x[<span class="number">5</span>], S31, T[<span class="number">32</span>]); <span class="comment">//a = b + ((a + H(b,c,d) + X[5] + T[32])&lt;&lt;&lt; 4) </span></span><br><span class="line">            d = HH(d, a, b, c, x[<span class="number">8</span>], S32, T[<span class="number">33</span>]); <span class="comment">//d = a + ((d + H(a,b,c) + X[8] + T[33])&lt;&lt;&lt; 11)</span></span><br><span class="line">            c = HH(c, d, a, b, x[<span class="number">11</span>], S33, T[<span class="number">34</span>]); <span class="comment">//c = d + ((c + H(d,a,b) + X[11] + T[34])&lt;&lt;&lt; 16)</span></span><br><span class="line">            b = HH(b, c, d, a, x[<span class="number">14</span>], S34, T[<span class="number">35</span>]); <span class="comment">//b = c + ((b + H(c,d,a) + X[14] + T[35])&lt;&lt;&lt; 23)</span></span><br><span class="line">            a = HH(a, b, c, d, x[<span class="number">1</span>], S31, T[<span class="number">36</span>]); <span class="comment">//a = b + ((a + H(b,c,d) + X[1] + T[36])&lt;&lt;&lt; 4)</span></span><br><span class="line">            d = HH(d, a, b, c, x[<span class="number">4</span>], S32, T[<span class="number">37</span>]); <span class="comment">//d = a + ((d + H(a,b,c) + X[4] + T[37])&lt;&lt;&lt; 11)</span></span><br><span class="line">            c = HH(c, d, a, b, x[<span class="number">7</span>], S33, T[<span class="number">38</span>]); <span class="comment">//c = d + ((c + H(d,a,b) + X[7] + T[38])&lt;&lt;&lt; 16)</span></span><br><span class="line">            b = HH(b, c, d, a, x[<span class="number">10</span>], S34, T[<span class="number">39</span>]); <span class="comment">//b = c + ((b + H(c,d,a) + X[10] + T[39])&lt;&lt;&lt; 23)</span></span><br><span class="line">            a = HH(a, b, c, d, x[<span class="number">13</span>], S31, T[<span class="number">40</span>]); <span class="comment">//a = b + ((a + H(b,c,d) + X[13] + T[40])&lt;&lt;&lt; 4)</span></span><br><span class="line">            d = HH(d, a, b, c, x[<span class="number">0</span>], S32, T[<span class="number">41</span>]); <span class="comment">//d = a + ((d + H(a,b,c) + X[0] + T[41])&lt;&lt;&lt; 11)</span></span><br><span class="line">            c = HH(c, d, a, b, x[<span class="number">3</span>], S33, T[<span class="number">42</span>]); <span class="comment">//c = d + ((c + H(d,a,b) + X[3] + T[42])&lt;&lt;&lt; 16)</span></span><br><span class="line">            b = HH(b, c, d, a, x[<span class="number">6</span>], S34, T[<span class="number">43</span>]); <span class="comment">//b = c + ((b + H(c,d,a) + X[6] + T[43])&lt;&lt;&lt; 23)</span></span><br><span class="line">            a = HH(a, b, c, d, x[<span class="number">9</span>], S31, T[<span class="number">44</span>]); <span class="comment">//a = b + ((a + H(b,c,d) + X[9] + T[44])&lt;&lt;&lt; 4)</span></span><br><span class="line">            d = HH(d, a, b, c, x[<span class="number">12</span>], S32, T[<span class="number">45</span>]); <span class="comment">//d = a + ((d + H(a,b,c) + X[12] + T[45])&lt;&lt;&lt; 11)</span></span><br><span class="line">            c = HH(c, d, a, b, x[<span class="number">15</span>], S33, T[<span class="number">46</span>]); <span class="comment">//c = d + ((c + H(d,a,b) + X[15] + T[46])&lt;&lt;&lt; 16)</span></span><br><span class="line">            b = HH(b, c, d, a, x[<span class="number">2</span>], S34, T[<span class="number">47</span>]); <span class="comment">//b = c + ((b + H(c,d,a) + X[2] + T[47])&lt;&lt;&lt; 23)</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*第四轮*/</span></span><br><span class="line">            a = II(a, b, c, d, x[<span class="number">0</span>], S41, T[<span class="number">48</span>]); <span class="comment">//a = b + ((a + I(b,c,d) + X[0] + T[48]) &lt;&lt;&lt; 6)</span></span><br><span class="line">            d = II(d, a, b, c, x[<span class="number">7</span>], S42, T[<span class="number">49</span>]); <span class="comment">//d = a + ((d + I(a,b,c) + X[7] + T[49]) &lt;&lt;&lt; 10)</span></span><br><span class="line">            c = II(c, d, a, b, x[<span class="number">14</span>], S43, T[<span class="number">50</span>]); <span class="comment">//c = d + ((c + I(d,a,b) + X[14] + T[50]) &lt;&lt;&lt; 15)</span></span><br><span class="line">            b = II(b, c, d, a, x[<span class="number">5</span>], S44, T[<span class="number">51</span>]); <span class="comment">//b = c + ((b + I(c,d,a) + X[5] + T[51]) &lt;&lt;&lt; 21)</span></span><br><span class="line">            a = II(a, b, c, d, x[<span class="number">12</span>], S41, T[<span class="number">52</span>]); <span class="comment">//a = b + ((a + I(b,c,d) + X[12] + T[52]) &lt;&lt;&lt; 6)</span></span><br><span class="line">            d = II(d, a, b, c, x[<span class="number">3</span>], S42, T[<span class="number">53</span>]); <span class="comment">//d = a + ((d + I(a,b,c) + X[3] + T[53]) &lt;&lt;&lt; 10)</span></span><br><span class="line">            c = II(c, d, a, b, x[<span class="number">10</span>], S43, T[<span class="number">54</span>]); <span class="comment">//c = d + ((c + I(d,a,b) + X[10] + T[54]) &lt;&lt;&lt; 15)</span></span><br><span class="line">            b = II(b, c, d, a, x[<span class="number">1</span>], S44, T[<span class="number">55</span>]); <span class="comment">//b = c + ((b + I(c,d,a) + X[1] + T[55]) &lt;&lt;&lt; 21)</span></span><br><span class="line">            a = II(a, b, c, d, x[<span class="number">8</span>], S41, T[<span class="number">56</span>]); <span class="comment">//a = b + ((a + I(b,c,d) + X[8] + T[56]) &lt;&lt;&lt; 6)</span></span><br><span class="line">            d = II(d, a, b, c, x[<span class="number">15</span>], S42, T[<span class="number">57</span>]); <span class="comment">//d = a + ((d + I(a,b,c) + X[15] + T[57]) &lt;&lt;&lt; 10)</span></span><br><span class="line">            c = II(c, d, a, b, x[<span class="number">6</span>], S43, T[<span class="number">58</span>]); <span class="comment">//c = d + ((c + I(d,a,b) + X[6] + T[58]) &lt;&lt;&lt; 15)</span></span><br><span class="line">            b = II(b, c, d, a, x[<span class="number">13</span>], S44, T[<span class="number">59</span>]); <span class="comment">//b = c + ((b + I(c,d,a) + X[13] + T[59]) &lt;&lt;&lt; 21)</span></span><br><span class="line">            a = II(a, b, c, d, x[<span class="number">4</span>], S41, T[<span class="number">60</span>]); <span class="comment">//a = b + ((a + I(b,c,d) + X[4] + T[60]) &lt;&lt;&lt; 6)</span></span><br><span class="line">            d = II(d, a, b, c, x[<span class="number">11</span>], S42, T[<span class="number">61</span>]); <span class="comment">//d = a + ((d + I(a,b,c) + X[11] + T[61]) &lt;&lt;&lt; 10)</span></span><br><span class="line">            c = II(c, d, a, b, x[<span class="number">2</span>], S43, T[<span class="number">62</span>]); <span class="comment">//c = d + ((c + I(d,a,b) + X[2] + T[62]) &lt;&lt;&lt; 15)</span></span><br><span class="line">            b = II(b, c, d, a, x[<span class="number">9</span>], S44, T[<span class="number">63</span>]); <span class="comment">//b = c + ((b + I(c,d,a) + X[9] + T[63]) &lt;&lt;&lt; 21)</span></span><br><span class="line"> </span><br><span class="line">            result[<span class="number">0</span>] += a;</span><br><span class="line">            result[<span class="number">1</span>] += b;</span><br><span class="line">            result[<span class="number">2</span>] += c;</span><br><span class="line">            result[<span class="number">3</span>] += d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] resultByte = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                resultByte[i*<span class="number">4</span>+j] = (<span class="keyword">byte</span>) (result[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">                result[i]=result[i]&gt;&gt;<span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultByte;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &amp; y) | ((~x) &amp; z);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &amp; z) | (y &amp; (~z));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x ^ y ^ z;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">I</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y ^ (x | (~z));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FF</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        a += (F(b, c, d)&amp;<span class="number">0xFFFFFFFF</span>) + x + t;</span><br><span class="line">        a = ((a&amp;<span class="number">0xFFFFFFFF</span>)&lt;&lt; s) | ((a&amp;<span class="number">0xFFFFFFFF</span>) &gt;&gt;&gt; (<span class="number">32</span> - s)); <span class="comment">//循环位移</span></span><br><span class="line">        a += b;</span><br><span class="line">        <span class="keyword">return</span> (a&amp;<span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GG</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        a += (G(b, c, d)&amp;<span class="number">0xFFFFFFFF</span>) + x + t;</span><br><span class="line">        a = ((a&amp;<span class="number">0xFFFFFFFF</span>) &lt;&lt; s) | ((a&amp;<span class="number">0xFFFFFFFF</span>) &gt;&gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">        a += b;</span><br><span class="line">        <span class="keyword">return</span> (a&amp;<span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HH</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        a += (H(b, c, d)&amp;<span class="number">0xFFFFFFFF</span>) + x + t;</span><br><span class="line">        a = ((a&amp;<span class="number">0xFFFFFFFF</span>) &lt;&lt; s) | ((a&amp;<span class="number">0xFFFFFFFF</span>) &gt;&gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">        a += b;</span><br><span class="line">        <span class="keyword">return</span> (a&amp;<span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">II</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> x, <span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        a += (I(b, c, d)&amp;<span class="number">0xFFFFFFFF</span>) + x + t;</span><br><span class="line">        a = ((a&amp;<span class="number">0xFFFFFFFF</span>) &lt;&lt; s) | ((a&amp;<span class="number">0xFFFFFFFF</span>) &gt;&gt;&gt; (<span class="number">32</span> - s));</span><br><span class="line">        a += b;</span><br><span class="line">        <span class="keyword">return</span> (a&amp;<span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        MD5Test myMd5=<span class="keyword">new</span> MD5Test();</span><br><span class="line">        String testData = <span class="string">"hello,world"</span>;</span><br><span class="line">        System.out.println(<span class="string">"--------My MD5--------"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] myResult = myMd5.digest(testData.getBytes());</span><br><span class="line">        System.out.println(Arrays.toString(myResult));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"--------Java MD5--------"</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest javaMd5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] javaResult = javaMd5.digest(testData.getBytes());</span><br><span class="line">            System.out.println(Arrays.toString(javaResult)); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;散列函数&quot;&gt;&lt;a href=&quot;#散列函数&quot; class=&quot;headerlink&quot; title=&quot;散列函数&quot;&gt;&lt;/a&gt;散列函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;散列函数，也称作哈希函数，消息摘要函数，单向函数或者杂凑函数&lt;/strong&gt;。散列函数主要用于验证数据的完整性。通过散列函数，可以创建消息的“数字指纹”，消息接收方可以通过校验消息的哈希值来验证消息的完整性，防止消息被篡改。散列函数具有以下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;散列函数的运算过程是不可逆的，这个称为散列函数的单向性。&lt;/li&gt;
&lt;li&gt;对于一个已知的消息及其散列值，要找到另外一个消息使其获得相同的散列值是不可能的，这个特性称为散列函数的弱碰撞性。这个特性可以用来防止消息伪造。&lt;/li&gt;
&lt;li&gt;任意两个不同消息的散列值一定不同。&lt;/li&gt;
&lt;li&gt;对原始消息长度没有限制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任何消息经过散列函数处理后，都会产生一个唯一的散列值，这个散列值可以用来验证消息的完整性。计算消息散列值的过程被称为“消息摘要”，计算消息散列值的算法被称为消息摘要算法。常使用的消息摘要算法有：MD—消息摘要算法，SHA—安全散列算法，MAC—消息认证码算法。本文主要来了解MD算法。&lt;/p&gt;
&lt;h2 id=&quot;MD5算法原理&quot;&gt;&lt;a href=&quot;#MD5算法原理&quot; class=&quot;headerlink&quot; title=&quot;MD5算法原理&quot;&gt;&lt;/a&gt;MD5算法原理&lt;/h2&gt;</summary>
    
    
    
    <category term="19.Algorithm" scheme="https://beefyheisenberg.github.io/categories/19-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Alg.01.数据结构-3散列表</title>
    <link href="https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2023-05-09T04:45:01.197Z</published>
    <updated>2023-05-09T04:45:01.198Z</updated>
    
    
    
    
    <category term="19.Algorithm" scheme="https://beefyheisenberg.github.io/categories/19-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Alg.01.数据结构-2树</title>
    <link href="https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E6%A0%91/"/>
    <id>https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E6%A0%91/</id>
    <published>2023-05-09T04:45:01.191Z</published>
    <updated>2023-05-09T04:45:01.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单二叉树"><a href="#简单二叉树" class="headerlink" title="简单二叉树"></a>简单二叉树</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul><li>先序(preOrder): 中-左-右</li><li>中序(inOrder):</li><li>后序(postOrder):</li></ul><p>➤ 先序遍历(递归):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;T&gt; n)</span> </span>&#123;</span><br><span class="line">    System.out.println(n.data);  <span class="comment">// 先序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n.left != <span class="keyword">null</span>)</span><br><span class="line">        preOrder(n.left);</span><br><span class="line">    <span class="keyword">if</span> (n.right != <span class="keyword">null</span>)</span><br><span class="line">        preOrder(n.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 先序-非递归, 最简单的一种:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">        Node n = s.pop(); <span class="comment">// 刚开始就pop了, 这种只能用来做先序</span></span><br><span class="line">        System.out.println(n.data); <span class="comment">// 先序</span></span><br><span class="line">        <span class="keyword">if</span>(n.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(n.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(n.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ ✨先序-非递归(方法 2), 使用栈模拟递归:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span>(!s.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(root.data); <span class="comment">// 先序</span></span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = s.pop();</span><br><span class="line">            <span class="comment">// System.out.println(root.data); // 中序</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 中序-非递归与上面类似</p><p>➤ ✨后序-非递归(需要辅助栈):</p><ul><li>Push 根结点到第一个栈 s1中。</li><li>从第一个栈 s1 中 Pop 出一个结点，并将其 Push 到第二个栈 output 中。</li><li>然后 Push 该结点的左孩子和右孩子到第一个栈 s 中。</li><li>重复过程 2 和 3 直到栈 s 为空。</li><li>完成后，所有结点已经 Push 到栈 output 中，且按照后序遍历的顺序存放，直接全部 Pop 出来即是二叉树后序遍历结果。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack s1 = <span class="keyword">new</span> Stack();</span><br><span class="line">    Stack s2 = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    s1.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty) &#123;</span><br><span class="line">        Node curr = s1.pop();</span><br><span class="line"></span><br><span class="line">        s2.push(curr);</span><br><span class="line">        <span class="keyword">if</span>(curr.left !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(curr.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr.right !=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s2.isEmpty()) &#123;</span><br><span class="line">        Node curr = s2.pop();</span><br><span class="line">        System.out.println(cur.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ ✨层序遍历（非递归算法）:<br>第一个队列 currentLevel 用于存储当前层的结点，第二个队列 nextLevel 用于存储下一层的结点。当前层 currentLevel 为空时，表示这一层已经遍历完成，可以打印换行符了。<br>然后将第一个空的队列 currentLevel 与队列 nextLevel 交换，然后重复该过程直到结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; currentLevel = <span class="keyword">new</span> Queue();</span><br><span class="line">    Queue&lt;Node&gt; nextLevel = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">    currentLevel.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!currentLevel.isEmpty()) &#123;</span><br><span class="line">        currNode = currentLevel.poll();</span><br><span class="line">        <span class="keyword">if</span>(currNode) &#123;</span><br><span class="line">            print(currNode);</span><br><span class="line">            nextLevel.offer(currNode.left);</span><br><span class="line">            nextLevel.offer(currNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(currentLevel.isEmpty()) &#123;</span><br><span class="line">            print(<span class="string">"/n"</span>);</span><br><span class="line">            swap(currentLevel, nextLevel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/sgbfblog/article/details/7773103" target="_blank" rel="noopener">https://blog.csdn.net/sgbfblog/article/details/7773103</a></p></blockquote><h3 id="节点删除-插入"><a href="#节点删除-插入" class="headerlink" title="节点删除/插入"></a>节点删除/插入</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/24873443?refer=hinus" target="_blank" rel="noopener">数据结构（七）：二叉树的删除和应用举例</a></li></ul><h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><p>@ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/25239615?refer=hinus" target="_blank" rel="noopener">平衡二叉树</a></li><li><a href="https://zhuanlan.zhihu.com/p/25320155?refer=hinus" target="_blank" rel="noopener">代码实现平衡二叉树</a></li></ul><p>AVL 树（Adelson-Velsky and Landis Tree，发明者名字）的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p><p>AVL 树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有 LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。</p><p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于 1 时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用<strong>单旋转</strong>进行平衡化，如果这三个结点位于一条折线上，则采用<strong>双旋转</strong>进行平衡化</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>AVL 树在插入/删除节点后, 需要用旋转的操作重新平衡;</p><blockquote><p>概念: 「节点的平衡因子」 每个结点的平衡因子就是该结点的左子树的高度减去右子树的高度，平衡二叉树的每个结点的平衡因子的绝对值不会超过 2</p></blockquote><p>左旋：将当前结点 S 的左孩子旋转为当前结点父结点 E 的右孩子，同时将父结点 E 旋转为当前结点 S 的左孩子。可用动画表示：</p><p><img src="/images/bwwf75vdyg.gif" alt=""></p><p>右旋：将当前结点 S 的左孩子 E 的右孩子旋转为当前结点 S 的左孩子，同时将当前结点 S 旋转为左孩子 E 的右孩子。可用动画表示：</p><p><img src="/images/25stotndte.gif" alt=""></p><p>以下图表以 4 列表示 4 种需要重新做平衡的情况, Root 是失去平衡树的根节点(左右子树高度差大于 1)</p><ul><li>左左（LL）: 失衡节点 root 的左子树更高, root 左子树的左子树更高</li><li>右右（RR）:</li><li>左右（LR）: 失衡节点 root 的左子树更高, root 左子树的右子树更高</li><li>右左（RL）:</li></ul><p>图: 四种情况的旋转(Root 是失去平衡树的根节点，Pivot 是旋转后重新平衡树的根节点),<br>可以看到需要<strong>1~2 次</strong>旋转即可使不平衡节点重新平衡:<br><img src="/images/alg/Tree_Rebalancing.png" alt="Rotate"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>查找: 可以像普通二叉查找树一样的进行，所以耗费 O(log n)时间，因为 AVL 树总是保持平衡的</p></li><li><p>插入: 向 AVL 树插入，可以透过如同它是未平衡的二叉查找树一样，把给定的值插入树中，接着自底往上向根节点折回，于在插入期间成为不平衡的所有节点(平衡因子&gt;1, 即左右子树高度差)上进行旋转来完成。上面分析了四种情况, 旋转1~2次即可完成, 所以也是 <code>O(log n)</code></p></li></ul><ul><li>删除:<ul><li>先看二叉查找树(BST)的删除操作: 当删除一个结点 P，首先需要定位到这个结点 P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为 O(1)。如果被删除结点的左、右子树均存在，只需要将当 P 的左孩子的右孩子的右孩子的…的右叶子结点与 P 互换(左的右右右, 也即比 P 小但是 p 最大的孩子 )，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过 <code>O(logN)</code>。</li><li>从 AVL 树中删除，AVL 删除结点的算法可以参见上面 BST 的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要 O(logN)次旋转。因此，删除操作的时间复杂度为 O(2logN)</li></ul></li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树的 5 个性质:</p><ul><li>每个结点要么是红的要么是黑的。</li><li>根结点是黑的。</li><li>每个叶结点（叶结点即指树尾端 NIL 指针或 NULL 结点）都是黑的。</li><li>如果一个结点是红的，那么它的两个儿子都是黑的。</li><li>对于任意结点而言，其到叶结点树尾端 NIL 指针的每条路径都包含相同数目的黑结点。</li></ul><blockquote><p>正是红黑树的这 5 条性质，使一棵 n 个结点的红黑树始终保持了 logn 的高度，从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为 O(log n)”这一结论成立的原因。</p></blockquote><p>红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的 STL 就常用到红黑树作为底层的数据结构。</p><p>下图中，”叶结点” 或着叫”NULL 结点”，它不包含数据而只充当树在此结束的指示，这些节点在绘图中经常被省略<br><img src="/images/alg/rbtree.png" alt="RBTree"></p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>@ref: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd/blob/master/ebook/zh/03.01.md</a></p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>正是红黑树的这5条性质，使得一棵 n 个结点是红黑树始终保持了logn 的高度，从而也就解释了上面我们所说的“红黑树的查找、插入、删除的时间复杂度最坏为 O(log n)”这一结论的原因</p><h2 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树 &amp; B+树"></a>B 树 &amp; B+树</h2><p>[[../32.Database/MySQL-02b-BTree索引原理]]</p><h2 id="•-BST、AVL、RB-树、B-树复杂度比较"><a href="#•-BST、AVL、RB-树、B-树复杂度比较" class="headerlink" title="• BST、AVL、RB 树、B 树复杂度比较"></a>• BST、AVL、RB 树、B 树复杂度比较</h2><p>➤ 二叉查找树 (Binary Search Tree) ：</p><p>BST 的操作代价分析：</p><ul><li><p>(1) 查找代价： 任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。</p><p>当树中每个结点左右子树高度大致相同时，树高为 logN。则平均查找长度与 logN 成正比，查找的平均时间复杂度在 O(logN)数量级上。</p><p>当先后插入的关键字有序时，BST 退化成单支树结构。此时树高 n。平均查找长度为(n+1)/2，查找的平均时间复杂度在 O(N)数量级上。</p></li><li><p>(2) 插入代价： 新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。</p></li><li><p>(3) 删除代价： 当删除一个结点 P，首先需要定位到这个结点 P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为 O(1)。如果被删除结点的左、右子树均存在，只需要将当 P 的左孩子的右孩子的右孩子的…的右叶子结点与 P 互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过 O(logN)。</p></li></ul><p>BST 效率总结 : </p><ul><li>查找最好时间复杂度 O(logN)，最坏时间复杂度 O(N)。</li><li>插入删除操作算法简单，时间复杂度与查找差不多</li></ul><p>➤ 平衡二叉查找树 ( Balanced Binary Search Tree ) ：</p><blockquote><p>二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是 BST 不够平衡(左右子树高度差太大)。<br>既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL 树就诞生了。</p></blockquote><p>AVL 的操作代价分析：</p><ul><li><p>(1) 查找代价： AVL 是严格平衡的 BST（平衡因子不超过 1）。那么查找过程与 BST 一样，只是 AVL 不会出现最差情况的 BST(单支树)。因此查找效率最好、最坏情况都是 O(logN)数量级的。</p></li><li><p>(2) 插入代价： AVL 必须要保证严格平衡(|bf|&lt;=1)，那么每一次插入数据使得 AVL 中某些结点的平衡因子超过 1 就必须进行旋转操作。事实上，AVL 的每一次插入结点操作最多只需要旋转 1 次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在 O(logN)级别上(插入结点需要首先查找插入的位置)。</p></li><li><p>(3) 删除代价：AVL 删除结点的算法可以参见 BST 的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要 O(logN)次旋转。因此，删除操作的时间复杂度为 O(logN)+O(logN)=O(2logN)</p></li></ul><p>AVL 效率总结 : </p><ul><li>查找的时间复杂度维持在 O(logN)，不会出现最差情况</li><li>AVL 树在执行每个插入操作时最多需要 1 次旋转，其时间复杂度在 O(logN)左右。</li><li>AVL 树<strong>在执行删除时代价稍大</strong>，执行每个删除操作的时间复杂度需要 O(2logN)。</li></ul><p>➤ 红黑树 (Red-Black Tree )：</p><blockquote><p>二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的 O(logN) 的查找时间复杂度。但是这样做是否值得呢？ 能不能找一种折中策略，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率呢？ 答案就是：红黑树。</p></blockquote><p>RBT 的操作代价分析：</p><ul><li><p>(1) 查找代价：由于红黑树的性质(最长路径长度不超过最短路径长度的 2 倍)，可以说明红黑树虽然不像 AVL 一样是严格平衡的，但平衡性能还是要比 BST 要好。其查找代价基本维持在 O(logN)左右，但在最差情况下(最长路径是最短路径的 2 倍少 1)，比 AVL 要略逊色一点。</p></li><li><p>(2) 插入代价：RBT 插入结点时，需要旋转操作和变色操作。但由于只需要保证 RBT 基本平衡就可以了。因此插入结点最多只需要 2 次旋转，这一点和 AVL 的插入操作一样。虽然变色操作需要 O(logN)，但是变色操作十分简单，代价很小。</p></li><li><p>(3) 删除代价：RBT 的删除操作代价要比 AVL 要好的多，删除一个结点最多只需要 3 次旋转操作。</p></li></ul><p>RBT 效率总结 : </p><ul><li>查找效率最好情况下时间复杂度为 O(logN)，但在最坏情况下比 AVL 要差一些，但也远远好于 BST。</li><li>插入和删除操作改变树的平衡性的概率要远远小于 AVL（RBT 不是严格高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转 2 次，删除最多只需要旋转 3 次(小于 AVL 的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在 O(logN)，但是实际上这种操作由于简单所需要的代价很小。</li></ul><p>➤ B 树/B+树 (B-Tree ) ：</p><blockquote><p>对于在内存中的查找结构而言，红黑树的效率已经非常好了(实际上很多实际应用还对 RBT 进行了优化)。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成 RBT 结构显然是不实际的。<br>在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B 树很好的解决了这一个问题。</p></blockquote><p>B-Tree 的操作代价分析：</p><ul><li><p>(1) 查找代价： B-Tree 作为一个平衡多路查找树(m叉)。B 树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而 B 树的高度很小，因此在这一背景下，B 树比任何二叉结构查找树的效率都要高很多。而且 B+树作为 B 树的变种，其查找效率更高。</p></li><li><p>(2)插入代价： B-Tree 的插入会发生结点的分裂操作。当插入操作引起了 s 个节点的分裂时，磁盘访问的次数为 h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是 h+2s+1，最多可达到 3h+1。因此插入的代价是很大的。</p></li><li><p>(3)删除代价：B-Tree 的删除会发生结点合并操作。最坏情况下磁盘访问次数是 3h＝（找到包含被删除元素需要 h 次读访问）+（获取第 2 至 h 层的最相邻兄弟需要 h-1 次读访问）+（在第 3 至 h 层的合并需要 h-2次写<br>访问）+（对修改过的根节点和第 2 层的两个节点进行 3 次写访问）</p></li></ul><p>B-Tree 效率总结： 由于考虑磁盘储存结构，B 树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。</p><p>@ref: <a href="https://blog.csdn.net/keda8997110/article/details/45057081" target="_blank" rel="noopener">https://blog.csdn.net/keda8997110/article/details/45057081</a></p><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p><strong>字典树的构建</strong>：</p><ul><li>节点包含一个 size=26 的数组，下标对应 az，值是指向后续字符的指针，此外节点还有一个 flag 标识字符串是否结束（可选）</li><li>根节点不表示任何字符，但根节点的数组是指向子节点的；</li><li>每个子节点表示一个字符（有空间的浪费），改进方案是一个节点可以存储多个字符（压缩）</li></ul><p>下图是一个带压缩的字典树：<br><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E6%A0%91-2023-05-08-2.png" alt="../_images/Alg.01.数据结构2-树-2023-05-08-2.png"></p><p><strong>复杂度分析</strong>：</p><ul><li>空间：O(n) </li><li>增/删/查：O(n)</li></ul><p><strong>如何使用</strong>：</p><ul><li>一堆字符串构建为一棵 Tire Tree，公共的前缀被合并</li><li>查找：<ul><li>查找 string1 是否在一堆给定的字符串里：查找次数=字符串长度</li><li>查找 str1 前缀开头是否存在于（startWith）… </li></ul></li></ul><p><strong>问题实例</strong>：</p><p><strong>1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析</strong></p><p><strong>提示</strong>：用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平均长度），然后是找出出现最频繁的前10个词。当然，也可以用堆来实现，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p><p><strong>2、寻找热门查询</strong></p><p><strong>原题</strong>：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p><strong>提示</strong>：利用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><hr><p>@ref: <a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.09.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.09.html</a></p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/30248914" target="_blank" rel="noopener">数据结构：线段树</a></li></ul><h1 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列(堆)"></a>优先队列(堆)</h1><p>二叉堆就结构性质上来说就是一个完全填满的二叉树，满足树的结构性和堆序性。堆序性指的是：父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/25820535" target="_blank" rel="noopener">数据结构：堆</a></li><li><a href="https://zhuanlan.zhihu.com/p/25843530" target="_blank" rel="noopener">堆排序和PriorityQueue源码解析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简单二叉树&quot;&gt;&lt;a href=&quot;#简单二叉树&quot; class=&quot;headerlink&quot; title=&quot;简单二叉树&quot;&gt;&lt;/a&gt;简单二叉树&lt;/h2&gt;&lt;h3 id=&quot;二叉树遍历&quot;&gt;&lt;a href=&quot;#二叉树遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历&quot;&gt;&lt;/a&gt;二叉树遍历&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;先序(preOrder): 中-左-右&lt;/li&gt;
&lt;li&gt;中序(inOrder):&lt;/li&gt;
&lt;li&gt;后序(postOrder):&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;➤ 先序遍历(递归):&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;preOrder&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node&amp;lt;T&amp;gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(n.data);  &lt;span class=&quot;comment&quot;&gt;// 先序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n.left != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        preOrder(n.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n.right != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        preOrder(n.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="19.Algorithm" scheme="https://beefyheisenberg.github.io/categories/19-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Alg.01.数据结构-1线性结构</title>
    <link href="https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    <id>https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</id>
    <published>2023-05-09T04:45:01.184Z</published>
    <updated>2023-05-09T04:45:01.185Z</updated>
    
    <content type="html"><![CDATA[<p>@todo: 数组、链表、栈、队列、双向队列</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@todo: 数组、链表、栈、队列、双向队列&lt;/p&gt;
</summary>
      
    
    
    
    <category term="19.Algorithm" scheme="https://beefyheisenberg.github.io/categories/19-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>常用数据结构 Quick View</title>
    <link href="https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840-Quick%20View/"/>
    <id>https://beefyheisenberg.github.io/19.Algorithm/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840-Quick%20View/</id>
    <published>2023-05-09T04:45:01.176Z</published>
    <updated>2023-05-09T04:45:01.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-线性结构-Linear-structures"><a href="#1-线性结构-Linear-structures" class="headerlink" title="1.线性结构(Linear structures)"></a>1.线性结构(Linear structures)</h2><blockquote> <a href="/19.Algorithm/Alg.01.数据结构1-线性结构/" title="Alg.01.数据结构1-线性结构">Alg.01.数据结构1-线性结构</a></blockquote><p><strong>「逻辑结构」揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照顺序依次排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出祖先与后代之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。</p><p>逻辑结构通常分为「线性」和「非线性」两类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列，例如网状或树状结构。</p><ul><li><strong>线性数据结构</strong>：数组、链表、栈、队列；</li><li><strong>非线性数据结构</strong>：树、图、堆、哈希表；</li></ul><h2 id="2-树-Tree"><a href="#2-树-Tree" class="headerlink" title="2.树(Tree)"></a>2.树(Tree)</h2><blockquote> <a href="/19.Algorithm/Alg.01.数据结构2-树/" title="Alg.01.数据结构2-树">Alg.01.数据结构2-树</a></blockquote><h3 id="树相关概念"><a href="#树相关概念" class="headerlink" title="树相关概念"></a>树相关概念</h3><ul><li>树的阶: 一个节点拥有的子节点最大值, 二叉树的阶是 2</li><li>树的度: 同阶的概念, <a href="https://www.zhihu.com/question/19836260" target="_blank" rel="noopener">为什么 B-tree 在不同著作中度的定义有一定差别？ - 知乎</a></li><li>叶子节点: 没有子节点的节点,称为叶子节点</li><li>节点的高度: 到最深树叶的路径长度</li><li>节点的深度: 节点到根节点的距离(根节点深度为 0)</li><li>树的高度: 根节点的高度</li></ul><h3 id="常见树的分类"><a href="#常见树的分类" class="headerlink" title="常见树的分类"></a>常见树的分类</h3><p><img src="/images/alg/tree.png" alt="Tree"></p><p>➤ <strong>二叉树</strong>: 每个节点的叶子不超过2</p><p>➤ <strong>完全二叉树</strong>: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树</p><p><img src="/images/alg/完全二叉树.png" alt="完全二叉树"></p><p>➤ <strong>二叉搜索树</strong>（BST / BinarySearchTree）:</p><ul><li>对于树中某个节点X, 左子树中所有值都小于X, 右子树所有值都大于X; 不足: 但是当原序列有序时二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。时间复杂度:<ul><li>索引: <code>O(log(n))</code></li><li>搜索: <code>O(log(n))</code></li><li>插入: <code>O(log(n))</code></li><li>删除: <code>O(log(n))</code></li></ul></li></ul><p><img src="/images/alg/二叉搜索树.png" alt="二叉搜索树"></p><p>➤ <strong>平衡二叉树</strong>(AVL): </p><ul><li>极端情况下的 BST 可能退化为链表，AVL 即一种为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升[1]。为了实现更高效的查询，产生了平衡树。</li><li>平衡二叉树的特点：任何节点的左右子树高度差不超过1;</li><li>在构造平衡二叉树时，需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）</li></ul><p>➤ <strong>红黑树</strong>: </p><ul><li>红黑树也是一种 AVL（带平衡条件的搜索树）。</li><li>红黑树在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。</li></ul><p>➤ <strong>二叉堆</strong>(Binary Heap) :</p><ul><li>堆是一种特别的完全二叉树（除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。）；</li><li>如果父节点的键值总是小于或等于子节点（根节点的值是最小的）, 那么称为小顶堆（min heap），反正择称为大顶堆（max heap）</li><li>二叉堆是完全二叉树的特点，可以使用数组存储：<ul><li>根节点在位置0</li><li>任意一个父节点设在位置 i，那么左子节点在位置 2i+1，右子节点在位置 2i+2</li></ul></li></ul><p><img src="/images/BinaryHeapArray.png" alt="../_images/BinaryHeapArray.png"></p><p>➤ 字典树(Trie Tree): </p><ul><li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串</li><li>每个字符串的公共前缀作为一个字符节点保存</li></ul><p>例：如果我们有 and,as,at,cn,com 这些关键词，那么构建的 trie 树如下</p><p>![[../_images/TrieTreeExample.png]]</p><p>Trie 树就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</p><p>➤ <strong>B-树</strong>: “Balance Tree”, 阶为 M 的树, 满足:</p><p>@link: [[../32.Database/MySQL-02b-BTree索引原理]]</p><p>➤ <strong>B+树</strong>:</p><ul><li>要存储的数据只在叶子节点中, 非叶子节点不存储数据, 只有关键字;</li><li>相邻的叶子节点之间都有一个链指针，不需要遍历整棵树就可以得到所存储的全部数据// Mysql执行range-query扫库很方便</li></ul><h1 id="3-散列表-Hash-Table"><a href="#3-散列表-Hash-Table" class="headerlink" title="3.散列表(Hash Table)"></a>3.散列表(Hash Table)</h1><blockquote><a href="/19.Algorithm/Alg.01.数据结构3-散列表/" title="Alg.01.数据结构3-散列表">Alg.01.数据结构3-散列表</a></blockquote><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><a href="https://zh.wikipedia.org/zh-hans/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%93%88%E5%B8%8C%E8%A1%A8</a></p><h1 id="4-图-Graph"><a href="#4-图-Graph" class="headerlink" title="4.图(Graph)"></a>4.图(Graph)</h1><blockquote><a href="/19.Algorithm/Alg.01.数据结构4-图/" title="Alg.01.数据结构4-图">Alg.01.数据结构4-图</a></blockquote><p>图形结构是一种比树形结构更复杂的非线性结构。在树形结构中，结点间具有分支层次关系，每一层上的结点只能和上一层中的至多一个结点相关，但可能和下一层的多个结点相关。而在图形结构中，任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。</p><p><a href="https://zh.wikipedia.org/zh-hans/%E5%9B%BE_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%9B%BE_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)</a></p><h1 id="5-堆-Heap"><a href="#5-堆-Heap" class="headerlink" title="5.堆(Heap)"></a>5.堆(Heap)</h1><p>堆（Heap）是一种特别的<strong>完全二叉树</strong>。若是满足以下特性，即可称为堆积：“给定堆积中任意节点 P 和 C，若 P 是 C 的父节点，那么 P 的值总是小于等于（或大于等于）C 的值”。</p><ul><li>若父节点的值恒小于等于子节点的值，此堆积称为最小堆积（min heap）；</li><li>反之，若父节点的值恒大于等于子节点的值，此堆积称为最大堆积（max heap）；</li></ul><p><img src="/images/alg/二叉堆.png" alt="二叉堆"></p><p>JDK 中的 <code>PriorityQueue</code> 通过二叉堆实现 @link:  [[../12.Java/Java-Tutorials.02.集合]]</p><hr><p>二叉堆一般用<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84" title="数组" target="_blank" rel="noopener">数组</a>来表示。如果根<a href="https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9" title="节点" target="_blank" rel="noopener">节点</a>在数组中的位置是1，第_n_个位置的子节点分别在2_n_和 2_n_+1。因此，第1个位置的子节点在2和3，第2个位置的子节点在4和5。以此类推。这种基于1的数组存储方式便于寻找父节点和子节点。</p><p>如果存储数组的下标基于0，那么下标为 i 的节点的子节点是2i + 1与 2i + 2；其父节点的下标是 $ floor((i − 1) ∕ 2) $。</p><blockquote><p><em>floor</em>(_x_)的功能是“向下取整”，或者说“向下舍入”，即取不大于_x_的最大整数（与“四舍五入”不同，向下取整是直接取按照数轴上最接近要求值的左边值，即不大于要求值的最大的那个值）。比如 <em>floor</em>(1.1)、<em>floor</em>(1.9)都返回1。</p></blockquote><p>如下图的两个堆：</p><p><img src="/images/Alg.01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%840-Quick%20View-2023-05-09-1.png" alt="../_images/Alg.01.数据结构0-Quick View-2023-05-09-1.png"></p><p>将这两个堆保存在以1开始的数组中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">位置:  1  2  3  4  5  6  7  8  9 10 11</span><br><span class="line">左图:  1  2  3  4  5  6  7  8  9 10 11</span><br><span class="line">右图: 11  9 10  5  6  7  8  1  2  3  4</span><br></pre></td></tr></table></figure><p>对于一个很大的堆，这种存储是低效的。因为节点的子节点很可能在另外一个内存页中。<a href="https://zh.wikipedia.org/wiki/B-heap" title="B-heap" target="_blank" rel="noopener">B-heap</a>是一种效率更高的存储方式，把每个子树放到同一内存页。</p><p>@ref: <a href="https://zh.wikipedia.org/zh-sg/%E4%BA%8C%E5%8F%89%E5%A0%86" target="_blank" rel="noopener">二叉堆 - 维基百科，自由的百科全书</a></p><hr><p>➤ 常见的堆结构，除了上面提到的大小堆，还有斐波那契堆_(Fibonacci heap)：</p><blockquote><p>裴波那契堆（Fibonacci Heap）是由 Michael L. Fredman 和 Robert E. Tarjan 在 1984 年发明的一种数据结构，它是一种可合并堆 （mergeable heap）。</p></blockquote><p>裴波那契堆的特点是可以在 O(1)时间内插入单个元素，O(logn)时间内删除最小元素，O(1)时间内合并两个堆。同时，裴波那契堆的平均时间复杂度比二叉堆（Binary Heap）低，因此在某些应用中具有优势。</p><p>裴波那契堆的核心思想是利用裴波那契数列的特性来实现堆的操作。裴波那契数列是一个数列，其中每个数字都是前两个数字之和，数列的前几项为：0，1，1，2，3，5，8，13，21，34，…… 等。</p><p>裴波那契堆的节点中除了存储元素的值之外，还存储了节点的度数和父节点指针、左右子节点指针以及兄弟节点指针等信息。在堆的合并操作中，裴波那契堆采用了一种“合并根链”的方式，将两个堆中最小的根节点合并，并通过指针将两个堆的根链连接起来。</p><p>裴波那契堆的实现比较复杂，但是在某些应用场景下能够提供更好的效率。比如在 Prim 算法中，使用裴波那契堆可以将时间复杂度优化到 O(E+VlogV)。</p><ul><li><a href="https://redspider110.github.io/2018/09/25/0105-algorithms-fibonacci-heap/" target="_blank" rel="noopener">算法 - 优先队列 - 斐波那契堆 | Earth Guardian</a></li><li><a href="https://wangkuiwu.github.io/2013/03/05/fabonacci-java/" target="_blank" rel="noopener">斐波那契堆(三)之 Java语言详解 | skywang</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-线性结构-Linear-structures&quot;&gt;&lt;a href=&quot;#1-线性结构-Linear-structures&quot; class=&quot;headerlink&quot; title=&quot;1.线性结构(Linear structures)&quot;&gt;&lt;/a&gt;1.线性结构(Linear structures)&lt;/h2&gt;&lt;blockquote&gt;
 &lt;a href=&quot;/19.Algorithm/Alg.01.数据结构1-线性结构/&quot; title=&quot;Alg.01.数据结构1-线性结构&quot;&gt;Alg.01.数据结构1-线性结构&lt;/a&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;「逻辑结构」揭示了数据元素之间的逻辑关系&lt;/strong&gt;。在数组和链表中，数据按照顺序依次排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出祖先与后代之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。&lt;/p&gt;
&lt;p&gt;逻辑结构通常分为「线性」和「非线性」两类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列，例如网状或树状结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性数据结构&lt;/strong&gt;：数组、链表、栈、队列；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非线性数据结构&lt;/strong&gt;：树、图、堆、哈希表；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="19.Algorithm" scheme="https://beefyheisenberg.github.io/categories/19-Algorithm/"/>
    
    
    <category term="数据结构与算法" scheme="https://beefyheisenberg.github.io/tags/数据结构与算法/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中都用到了那些设计模式?</title>
    <link href="https://beefyheisenberg.github.io/14.Coding-Pattern/Pattern-in-Spring/"/>
    <id>https://beefyheisenberg.github.io/14.Coding-Pattern/Pattern-in-Spring/</id>
    <published>2023-05-09T04:45:01.135Z</published>
    <updated>2023-05-09T04:45:01.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>Spring 使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p><p><strong>两者对比：</strong></p><ul><li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于 <code>BeanFactory</code> 来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有 <code>BeanFactory</code> 的功能还有额外更多功能，所以一般开发人员使用 <code>ApplicationContext</code> 会更多。</li></ul><p>ApplicationContext 的三个实现类：</p><ol><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从 Web 系统中的 XML 文件载入上下文定义信息。</li></ol><p>Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line">                <span class="string">"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span>);</span><br><span class="line"></span><br><span class="line">        HelloApplicationContext obj = (HelloApplicationContext) context.getBean(<span class="string">"helloApplicationContext"</span>);</span><br><span class="line">        obj.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p><p><strong>使用单例模式的好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ul><p><strong>Spring 实现单例的方式：</strong></p><ul><li><p>xml:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"top.snailclimb.UserService"</span> scope=<span class="string">"singleton"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用<strong>Cglib</strong> ，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p><p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用 Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p><h3 id="Spring-事件驱动模型中的三种角色"><a href="#Spring-事件驱动模型中的三种角色" class="headerlink" title="Spring 事件驱动模型中的三种角色"></a>Spring 事件驱动模型中的三种角色</h3><h3 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h3><p><code>ApplicationEvent</code> (<code>org.springframework.context</code> 包下)充当事件的角色,这是一个抽象类，它继承了 <code>java.util.EventObject</code> 并实现了 <code>java.io.Serializable</code> 接口。</p><p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自 <code>ApplicationContextEvent</code>)：</p><ul><li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li><li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li><li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li><li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li></ul><p><img src="https://github.com/wardseptember/notes/raw/master/imgs/20201014141044.png" alt=""></p><h3 id="事件监听者角色"><a href="#事件监听者角色" class="headerlink" title="事件监听者角色"></a>事件监听者角色</h3><p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code> 方法来处理 <code>ApplicationEvent</code>。<code>ApplicationListener</code> 接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code> 就可以了。所以，在 Spring 中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件发布者角色"><a href="#事件发布者角色" class="headerlink" title="事件发布者角色"></a>事件发布者角色</h3><p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ApplicationEventPublisher &#123;</span><br><span class="line">    default void publishEvent(ApplicationEvent event) &#123;</span><br><span class="line">        this.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void publishEvent(Object var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationEventPublisher</code> 接口的 <code>publishEvent（）</code> 这个方法在 <code>AbstractApplicationContext</code> 类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过 <code>ApplicationEventMulticaster</code> 来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p><h3 id="Spring-的事件流程总结"><a href="#Spring-的事件流程总结" class="headerlink" title="Spring 的事件流程总结"></a>Spring 的事件流程总结</h3><ol><li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li><li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li><li>使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li></ol><p>Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;</span><br><span class="line">        String msg = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">"接收到的信息是："</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出: <code>接收到的信息是：你好</code> 。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><h3 id="spring-AOP-中的适配器模式"><a href="#spring-AOP-中的适配器模式" class="headerlink" title="spring AOP 中的适配器模式"></a>spring AOP 中的适配器模式</h3><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是 <code>AdvisorAdapter</code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code> (目标方法执行结束后，return 之前)等等。每个类型 Advice（通知）都有对应的拦截器: <code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring 预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code> 接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p><h3 id="spring-MVC-中的适配器模式"><a href="#spring-MVC-中的适配器模式" class="headerlink" title="spring MVC 中的适配器模式"></a>spring MVC 中的适配器模式</h3><p>在 Spring MVC 中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p><p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们再增加一个 <code>Controller</code> 类型就要在上面代码中再加入一行判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个 Decorator 套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code> 家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改 <code>InputStream</code> 代码的情况下扩展了它的功能。</p><p><img src="https://github.com/wardseptember/notes/raw/master/imgs/20201014141538.png" alt=""></p><p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code> 或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring 框架中用到了哪些设计模式：</p><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>装饰器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配 <code>Controller</code>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;Spring 使用工厂模式可以通过 &lt;code&gt;BeanFactory&lt;/code&gt; 或 &lt;code&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两者对比：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; ：延迟注入(使用到某个 bean 的时候才会注入),相比于 &lt;code&gt;BeanFactory&lt;/code&gt; 来说会占用更少的内存，程序启动速度更快。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt; ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。&lt;code&gt;BeanFactory&lt;/code&gt; 仅提供了最基本的依赖注入支持，&lt;code&gt;ApplicationContext&lt;/code&gt; 扩展了 &lt;code&gt;BeanFactory&lt;/code&gt; ,除了有 &lt;code&gt;BeanFactory&lt;/code&gt; 的功能还有额外更多功能，所以一般开发人员使用 &lt;code&gt;ApplicationContext&lt;/code&gt; 会更多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ApplicationContext 的三个实现类：&lt;/p&gt;</summary>
    
    
    
    <category term="14.Coding-Pattern" scheme="https://beefyheisenberg.github.io/categories/14-Coding-Pattern/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/</id>
    <published>2023-05-09T04:45:01.098Z</published>
    <updated>2023-05-09T04:45:01.102Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png" alt="Tomcat"></p><h1 id="为什么-Java-Web-开发需要Tomcat"><a href="#为什么-Java-Web-开发需要Tomcat" class="headerlink" title="为什么 Java Web 开发需要Tomcat"></a>为什么 Java Web 开发需要Tomcat</h1><ul><li><strong>Java EE</strong>（Java Platform Enterprise Edition，2018 年 3 月更名为<strong>Jakarta EE</strong>）</li><li>Servlet 是 Java EE 众多标准下的一个 （link <a href="/13.JavaEE-Framework/JavaEE.Servlet/" title="JavaEE.Servlet">JavaEE.Servlet</a>）</li></ul><p>一个 Servlet 的工作模式：</p><ul><li>创建并填充 Request 对象，包括：URI、参数、method、请求头信息、请求体信息等</li><li>创建 Response 对象</li><li>执行业务逻辑，将结果通过 Response 的输出流输出到客户端</li></ul><p>所以 Servlet 定义了众多规范：Request &amp; Response 对象、Servlet 生命周期（init &amp; service &amp; destory 方法）…<br>但 Servlet 没有 main 方法，需要在一个 Servlet 容器里面才能执行，Servlet 容器按照上述规范调用 Servlet 的方法，Tomcat 即是一个 Servlet 容器，在下面 Tomcat 源码分析可以看到 Tomcat 是如何使用 Servlet 规范处理一个 Http 请求的：</p><blockquote><ul><li>Tomcat 接到 Http 请求后，使用 Poller 线程来处理这个请求的 socket，在 Poller 线程没有太多的处理，只是确认收包完整，然后把请求丢给 executor（工作线程池）；</li><li>在工作线程，把 Socket 读取到的数据，按照 Http 协议进行解析，并生成 Request 对象（这里也是按照 Servlet Request 的标准），并最终调用了 <code>Servlet.service()</code></li><li>Tomcat 的一个 Context 对应一个 <strong>ServletContext</strong>，一个 Context 下有 1 个 or 多个 <strong>Servlet 实现</strong></li></ul></blockquote><p>回答最开是问题，为什么 Java Web 开发需要 Tomcat？<br>Java Web 一般要遵循 Servlet 规范，Tomcat 是一个 Servlet 容器的实现，所以~ Java Web 开发需要 Tomcat。<br>那么开发 Java Web 可以摆脱 Servlet 吗？也可以不用，比如使用</p><h1 id="Tomcat-整体架构"><a href="#Tomcat-整体架构" class="headerlink" title="Tomcat 整体架构"></a>Tomcat 整体架构</h1><p><img src="/images/JavaEE.Tomcat-2023-05-04-1.png" alt="../_images/JavaEE.Tomcat-2023-05-04-1.png"></p><p>Tomcat 的架构如上图，主要的组件如下：</p><ul><li><p><strong>Server</strong>: 表示服务器，它提供了一种优雅的方式来启动和停止整个系统，不必单独启停连接器和容器；它是 Tomcat 构成的顶级构成元素，所有一切均包含在 Server 中；</p></li><li><p><strong>Service</strong>: 表示服务，Server 可以运行多个服务。比如一个 Tomcat 里面可运行订单服务、支付服务、用户服务等等；Server 的实现类 StandardServer 可以包含一个到多个 Services, Service 的实现类为 StandardService 调用了容器(Container)接口，其实是调用了 Servlet Engine(引擎)，而且 StandardService 类中也指明了该 Service 归属的 Server;</p></li><li><p><strong>Container</strong>: 表示容器，可以看做 Servlet 容器；引擎(Engine)、主机(Host)、上下文(Context)和 Wraper 均继承自 Container 接口，所以它们都是容器。</p><ul><li>Engine – 引擎</li><li>Host – 主机</li><li>Context – 上下文</li><li>Wrapper – 包装器</li></ul></li><li><p><strong>Connector</strong>: 表示连接器, <strong>它将 Service 和 Container 连接起来</strong>，首先它需要注册到一个 Service，它的作用就是把来自客户端的请求转发到 Container(容器)，这就是它为什么称作连接器, 它支持的协议如下：</p><ul><li>支持 AJP 协议</li><li>支持 Http 协议</li><li>支持 Https 协议</li></ul></li><li><p><strong>Service 内部</strong>还有各种支撑组件，下面简单罗列一下这些组件</p><ul><li>Manager – 管理器，用于管理会话 Session</li><li>Logger – 日志器，用于管理日志</li><li>Loader – 加载器，和类加载有关，只会开放给 Context 所使用</li><li>Pipeline – 管道组件，配合 Valve 实现过滤器功能</li><li>Valve – 阀门组件，配合 Pipeline 实现过滤器功能</li><li>Realm – 认证授权组件</li></ul></li></ul><p>在下面讲解配置文件的时候可以看到，server.xml 里的元素，与上面的组件一一对应。</p><p>本节参考 @ref： <a href="https://pdai.tech/md/framework/tomcat/tomcat-x-arch.html" target="_blank" rel="noopener">https://pdai.tech/md/framework/tomcat/tomcat-x-arch.html</a></p><h1 id="配置文件-server-xml"><a href="#配置文件-server-xml" class="headerlink" title="配置文件 server.xml"></a>配置文件 server.xml</h1><p>一个配置文件实例:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JasperListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="server-xml配置元素分类"><a href="#server-xml配置元素分类" class="headerlink" title="server.xml配置元素分类"></a>server.xml配置元素分类</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>server.xml的整体结构如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 现在常常使用自动部署，不推荐配Context --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Context表示一个War应用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>该结构中只给出了Tomcat的核心组件，除了核心组件外，Tomcat还有一些其他组件，下面介绍一下组件的分类。</p><h3 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h3><p>server.xml文件中的元素可以分为以下4类：</p><ul><li>（1）顶层元素：<code>&lt;Server&gt;</code>和<code>&lt;Service&gt;</code></li></ul><p><code>&lt;Server&gt;</code>元素是整个配置文件的根元素，<code>&lt;Service&gt;</code>元素则代表一个Engine元素以及一组与之相连的Connector元素。</p><ul><li>（2）连接器：<code>&lt;Connector&gt;</code></li></ul><p><code>&lt;Connector&gt;</code>代表了外部客户端发送请求到特定Service的接口；同时也是外部客户端从特定Service接收响应的接口。</p><ul><li>（3）容器：<code>&lt;Engine&gt;</code> <code>&lt;Host&gt;</code> <code>&lt;Context&gt;</code></li></ul><p>容器的功能是处理Connector接收进来的请求，并产生相应的响应。Engine、Host和Context都是容器，都实现了Container接口，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。</p><ul><li>Engine 表示一个Servlet引擎，它可以包含一个或多个子容器，比如Host或者Context容器；</li><li>Host 表示一台虚拟的主机，它可以包含一系列Context容器；</li><li>Context 表示一个唯一的ServletContext，一个 Context 对应一个 Web 工程，它可以包含一个 或多个Wrapper容器；</li><li>Wrapper 表示一个独立的Servlet定义，即Wrapper本质就是对Servlet进行了一层包装。</li></ul><p>一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。</p><ul><li>（4）内嵌组件：</li></ul><p>可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host和Context是最重要的最核心的Tomcat组件，其他组件都可以归为内嵌组件。</p><p>下面将详细介绍Tomcat中各个核心组件的作用，以及相互之间的关系。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>本部分将分别介绍各个核心组件的作用、特点以及配置方式等。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server元素在最顶层，代表整个Tomcat容器，因此它必须是server.xml中唯一一个最外层的元素。一个Server元素中可以有一个或多个Service元素。</p><p>在第一部分的例子中，在最外层有一个<code>&lt;Server&gt;</code>元素，shutdown属性表示关闭Server的指令；port属性表示Server接收shutdown指令的端口号，设为-1可以禁掉该端口。</p><p>Server的主要任务，就是提供一个接口让客户端能够访问到这个Service集合，同时维护它所包含的所有的Service的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的Service。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service的作用，是在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；其中Connector的作用是从客户端接收请求，Engine的作用是处理接收进来的请求。</p><p>在第一部分的例子中，Server中包含一个名称为“Catalina”的Service。实际上，Tomcat可以提供多个Service，不同的Service监听不同的端口，后文会有介绍。</p><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector的主要功能，是接收连接请求，创建Request和Response对象用于和请求端交换数据；然后分配线程让Engine来处理这个请求，并把产生的Request和Response对象传给Engine。</p><p>通过配置Connector，可以控制请求Service的协议及端口号。在第一部分的例子中，Service包含两个Connector：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>（1）通过配置第1个Connector，客户端可以通过8080端口号使用http协议访问Tomcat。其中，protocol属性规定了请求的协议，port规定了请求的端口号，redirectPort表示当强制要求https而请求是http时，重定向至端口号为8443的Connector，connectionTimeout表示连接的超时时间。</li><li>（2）通过配置第2个Connector，客户端可以通过8009端口号使用AJP协议访问Tomcat。AJP协议负责和其他的HTTP服务器(如Apache)建立连接；在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。之所以使用Tomcat和其他服务器集成，是因为Tomcat可以用作Servlet/JSP容器，但是对静态资源的处理速度较慢，不如Apache和IIS等HTTP服务器；因此常常将Tomcat与Apache等集成，前者作Servlet容器，后者处理静态资源，而AJP协议便负责Tomcat和Apache的连接。Tomcat与Apache等集成的原理如下图(图片来源)：</li></ul><p><img src="/images/javaee/tomcat_ajp_apache.png" alt="tomcat_ajp_apache"></p><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine组件在Service组件中有且只有一个；Engine是Service组件中的请求处理组件。Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。</p><p>在第一部分的例子中，Engine的配置语句如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，name属性用于日志和错误信息，在整个Server中应该唯一。defaultHost属性指定了默认的host名称，当发往本机的请求指定的host名称不存在时，一律使用defaultHost指定的host进行处理；因此，defaultHost的值，必须与Engine中的一个Host组件的name属性值匹配。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><h4 id="Engine与Host"><a href="#Engine与Host" class="headerlink" title="Engine与Host"></a>Engine与Host</h4><p>Host是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。Host组件至少有一个，且其中一个的name必须与Engine组件的defaultHost属性相匹配。</p><h4 id="Host的作用"><a href="#Host的作用" class="headerlink" title="Host的作用"></a>Host的作用</h4><p>Host虚拟主机的作用，是运行多个Web应用（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。</p><p>Host组件代表的虚拟主机，对应了服务器中一个网络名实体(如”<a href="http://www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。" target="_blank" rel="noopener">www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。</a></p><h4 id="Host的配置"><a href="#Host的配置" class="headerlink" title="Host的配置"></a>Host的配置</h4><p>在第一部分的例子中，Host的配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面对其中配置的属性进行说明：</p><p>name属性指定虚拟主机的主机名，一个Engine中有且仅有一个Host组件的name属性与Engine组件的defaultHost属性相匹配；一般情况下，主机名需要是在DNS服务器中注册的网络名，但是Engine指定的defaultHost不需要，原因在前面已经说明。</p><p>unpackWARs指定了是否将代表Web应用的WAR文件解压；如果为true，通过解压后的文件结构运行该Web应用，如果为false，直接使用WAR文件运行Web应用。</p><p>Host的autoDeploy和appBase属性，与Host内Web应用的自动部署有关；此外，本例中没有出现的xmlBase和deployOnStartup属性，也与Web应用的自动部署有关；将在下一节(Context)中介绍。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="Context的作用"><a href="#Context的作用" class="headerlink" title="Context的作用"></a>Context的作用</h4><p>Context元素代表在特定虚拟主机上运行的一个Web应用。每个Web应用基于WAR文件，或WAR文件解压后对应的目录（这里称为应用目录）。</p><p>Context是Host的子容器，每个Host中可以定义任意多的Context元素。</p><p>在第一部分的例子中，可以看到server.xml配置文件中并没有出现Context元素的配置。这是因为，Tomcat开启了自动部署，Web应用没有在server.xml中配置静态部署，而是由Tomcat通过特定的规则自动部署。下面介绍一下Tomcat自动部署Web应用的机制。</p><h4 id="Web应用自动部署"><a href="#Web应用自动部署" class="headerlink" title="Web应用自动部署"></a>Web应用自动部署</h4><p>如何开启自动部署War:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外Context组件还有一个reloadable属性, <code>&lt;Context docBase=&quot;xxx&quot; path=&quot;/xxx&quot; reloadable=&quot;true&quot;/&gt;</code><br>替换WEB-INF/lib目录中的jar文件或WEB-INF/classes目录中的class文件时，reloadable=”true”会让修改生效（但代价不小），该选项适合调试。</p><p>autoDeploy和reloadable的区别是, 前者是Host的属性后者是Context的属性,<br>前者监控的是webapps目录下War包的改动, 后者监控的是webapps下面文件夹内jar或者class文件的变化;</p><p>一般线上环境会关闭这两个参数, 开发阶段可以通过这两个参数无需重启tomcat预览改变;</p><h5 id="自动部署的实现"><a href="#自动部署的实现" class="headerlink" title="自动部署的实现"></a>自动部署的实现</h5><blockquote><p>Tomcat的Engine会启动一个线程，该线程每10s会发送一个发送一个事件，监听到该事件的部署配置类, 会自动去扫描webapp文件夹下的war包，将其加载成一个Context，即启动一个web服务。</p></blockquote><p>Tomcat的<code>StandardEngine</code>会在<code>starInternal()</code>启动一个线程，该线程运行的是<code>ContainerBackgroundProcessor.run()</code>方法,<br>这个run每隔10s唤醒调用一次<code>processChildren()</code>, 继续跟踪该方法，会看到调用其子容器Engine、Host、Context、Wrapper各容器组件及与它们相关的其它组件的backgroundProcess方法。<br><code>backgroundProcess()</code>发送一个事件<code>Lifecycle.PERIODIC_EVENT</code>,<br>StandardHost通server.xml配置了HostConfig监听器，对该事件的响应方法是<code>HostConfig.lifecycleEvent()</code>,<br><code>lifecycleEvent()</code>会检查<code>autoDeploy=&quot;true&quot;</code>的配置, 如果开启了, 则调用<code>deployApps()</code>扫描webapp文件夹下的war包，将其加载成一个Context，即启动一个web服务。</p><h2 id="核心组件的关联"><a href="#核心组件的关联" class="headerlink" title="核心组件的关联"></a>核心组件的关联</h2><h3 id="整体关系"><a href="#整体关系" class="headerlink" title="整体关系"></a>整体关系</h3><p>核心组件之间的整体关系，在上一部分有所介绍，这里总结一下：</p><p>Server元素在最顶层，代表整个Tomcat容器；一个Server元素中可以有一个或多个Service元素。<br>Service在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。<strong>一个Service可以包含多个Connector，但是只能包含一个Engine；</strong>  Connector接收请求，Engine处理请求。<br>Engine、Host和Context都是容器，且 Engine包含Host，Host包含Context。每个Host组件代表Engine中的一个虚拟主机；每个Context组件代表在特定Host上运行的一个Web应用。</p><p><img src="/images/javaee/tomcat_architecture.png" alt=""></p><h3 id="如何确定请求由谁处理？"><a href="#如何确定请求由谁处理？" class="headerlink" title="如何确定请求由谁处理？"></a>如何确定请求由谁处理？</h3><p>当请求被发送到Tomcat所在的主机时，如何确定最终哪个Web应用来处理该请求呢？</p><ul><li>（1）根据协议和端口号选定Service和Engine</li></ul><p>Service中的Connector组件可以接收特定端口的请求，当请求进来时，Tomcat便可以根据协议和端口号选定处理请求的Service；Service一旦选定，Engine也就确定。</p><ul><li>（2）根据域名或IP地址选定Host</li></ul><p>Service确定后，Tomcat在Service中寻找名称与域名/IP地址匹配的Host处理该请求。如果没有找到，则使用Engine中指定的defaultHost来处理该请求。</p><ul><li>（3）根据URI选定Context/Web应用</li></ul><p>这一点在Context一节有详细的说明：Tomcat根据应用的 path属性与URI的匹配程度来选择Web应用处理相应请求，这里不再赘述。</p><ul><li>（4）举例</li></ul><p>以请求<a href="http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。" target="_blank" rel="noopener">http://localhost:8080/app1/index.html为例，首先通过协议和端口号（http和8080）选定Service；然后通过主机名（localhost）选定Host；然后通过uri（/app1/index.html）选定Web应用。</a></p><h3 id="如何部署多个war包项目"><a href="#如何部署多个war包项目" class="headerlink" title="如何部署多个war包项目"></a>如何部署多个war包项目</h3><p>@todo</p><h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是Tomcat的启动和停止。<br>监听器可以在Server、Engine、Host或Context中，本例中的监听器都是在Server中。实际上，本例中定义的6个监听器，都只能存在于Server组件中。监听器不允许内嵌其他组件。<br>监听器需要配置的最重要的属性是className，该属性规定了监听器的具体实现类，该类必须实现了<code>org.apache.catalina.LifecycleListener</code>接口。</p><h3 id="GlobalNamingResources与Realm"><a href="#GlobalNamingResources与Realm" class="headerlink" title="GlobalNamingResources与Realm"></a>GlobalNamingResources与Realm</h3><p>@todo</p><h3 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h3><p>在第一部分的例子中，Host元素内定义了Valve组件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>单词Valve的意思是“阀门”，在Tomcat中代表了请求处理流水线上的一个组件；Valve可以与Tomcat的容器(Engine、Host或Context)关联。<br>不同的Valve有不同的特性，下面介绍一下本例中出现的AccessLogValve。<br>AccessLogValve的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve放在Host下，便可以记录该Host处理的所有请求。AccessLogValve记录的日志就是访问日志，每天的请求会写到一个日志文件里。AccessLogValve可以与Engine、Host或Context关联；在本例中，只有一个Engine，Engine下只有一个Host，Host下只有一个Context，因此AccessLogValve放在三个容器下的作用其实是类似的。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="bin-catalina-sh"><a href="#bin-catalina-sh" class="headerlink" title="bin/catalina.sh"></a>bin/catalina.sh</h2><p>这里主要是对 JVM 参数的设置，主要修改 Xms, Xmx, PermSize 几个参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS="-Xms8g -Xmx8g -Xmn2g -server -DServer=mblog -XX:PermSize=128m -XX:MaxPermSize=128m -XX:MaxTenuringThreshold=4 -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=8 -XX:CMSInitiatingOccupancyFraction=70 -XX:+ExplicitGCInvokesConcurrent -XX:+PrintFlagsFinal -XX:+PrintCommandLineFlags -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -Xloggc:../gclogs/gc.log.$nowday"</span><br></pre></td></tr></table></figure><h2 id="conf-server-xml"><a href="#conf-server-xml" class="headerlink" title="conf/server.xml"></a>conf/server.xml</h2><p>这里主要是对 Connector 和线程池的设置</p><p>主要优化点 @tldr：</p><ul><li><strong>maxThreads</strong> = 业务线程池大小，一般几百~几 K，如果并发到来的请求数超过 maxThreads，再新来的请求不能被及时处理；</li><li><strong>maxConnections</strong>：意思是 Tomcat 维护的<strong>已建立连接数</strong>上限。当连接数达到 maxConnections，Tomcat 不会再 accept，而是直接 block 掉（这时候系统仍然能 accept，但 Tomcat 不会把新连接扔给 Poller 线程了，而是 block 掉新的连接），maxConnections 在 NIO 模式默认是 1W；</li><li><strong>acceptCount</strong>：如果所有的业务线程都在忙（ all possible request processing threads are in use），即并发处理中的请求数超过了 maxThreads。这时候新请会放入 accept 队列（区别 socket 的 accept），acceptCount 即是这个队列的长度；</li></ul><p>用 <a href="https://asciiflow.com/#/" target="_blank" rel="noopener">ASCIIFlow</a> 画图解释：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">新连接到来：</span><br><span class="line"></span><br><span class="line">[Acceptor] ────────────► [Poller] ──线程池是否满？────NO─────► [业务线程池]&lt;maxThreads limits&gt;</span><br><span class="line">      &lt;maxConnections limits&gt;            │                    ▲</span><br><span class="line">                                         │                    │</span><br><span class="line">                                         │                    │</span><br><span class="line">                                        Yes──►[accept queue]──┴</span><br><span class="line">                                          &lt;acceptCount limits&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图示：</span><br><span class="line">[ ] 表示对象实体</span><br><span class="line">&lt; &gt; 表示限制</span><br></pre></td></tr></table></figure><hr><p>Tomcat 采用 Request Per Thread 策略, 每个用户请求由一个线程处理, <code>&lt;Executor&gt;</code> 部分定义了该线程池, 该线程池被 多个<code>&lt;Connector&gt;</code> 共享, server.xml里的优化主要在<code>&lt;Connector&gt;</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.StandardThreadExecutor"</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxThreads</span>=<span class="string">"300"</span> <span class="attr">minSpareThreads</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定使用上面的线程池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">"8080"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"8000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptCount</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxThreads</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptorThreadCount</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">"utf-8"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"443"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">"on"</span> <span class="attr">compressionMinSize</span>=<span class="string">"1024"</span> <span class="attr">compressableMimeType</span>=<span class="string">"text/html,text/xml,text/javascript,text/css,text/plain,application/json,application/xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>Executor参数</p><ul><li><strong>maxThreads</strong>:  线程池最大线程数</li><li><strong>minSpareThreads</strong>: 线程池最小线程数(线程池初始化时), 默认25</li></ul></li><li><p>Connector 参数:</p><ul><li><strong>executor</strong>: 指明使用哪一个 Executor, 如果指定了,那么 Connector中所有关于线程的设定会被忽略, 如果没有指定 一个线程池, Connector将会创建一个私有的线程池.</li><li><strong>maxThreads</strong>: 用于处理客户端请求的最大线程数, 设置为多少视CPU处理能力而定, 一般单个应用不应该超过300, 如果超过300应考虑多个Tomcat组成集群方式</li><li>enableLookups: 是否开启域名反查，一般设置为false来提高处理能力，它的取值还有true，一般很少使用。若设为true, 则支持域名解析，可把 ip 地址解析为主机名</li><li>connectionTimeout: 网络连接超时，单位：毫秒。设置为 0 表示永不超时</li><li><strong>acceptorThreadCount</strong>: 默认为1，表示用于 accept 新 socket 连接的线程个数。一般跟监听端口数匹配。</li><li><strong>acceptCount</strong>: 当全部线程都在忙(意味着客户端并发数超过 maxThreads个线程), 新的请求会放入accept队列, 该值是队列的size, 默认100 (如果要增加Tomcat并发处理能力, 需要同时增加 acceptCount 和 maxThreads)</li><li><strong>maxConnections</strong>: Tomcat 能 accept 并 process 的最大连接数, 超过这个数 tomcat 不再 accept 新的连接, 但不会 process， For NIO and NIO2 the default is 10000. For APR/native, the default is 8192.</li><li>compressionMinSize: 大于这个数值讲开启压缩, 默认为2K</li><li>compressableMimeType: 压缩哪些类型</li><li><p><strong>protocol</strong>：协议类型，可选类型有四种，分别为 BIO（阻塞型IO），NIO，NIO2和APR。</p><ul><li>BIO：BIO(Blocking I/O)，顾名思义，即阻塞式I/O操作，表示Tomcat使用的是传统的Java I/O操作(即java.io包及其子包)。Tomcat在默认情况下，是以bio模式运行的。遗憾的是，就一般而言，bio模式是三种运行模式中性能最低的一种。BIO配置采用默认即可。</li><li>NIO：NIO(New I/O)，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，因此nio也被看成是non-blocking I/O的缩写。它拥有比传统I/O操作(bio)更好的并发运行性能。要让Tomcat以nio模式来运行也比较简单，我们只需要protocol类型修改为：<code>protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</code><br>对于互联网应用，我们应该在NIO、NIO2之间做选择，因为它能够有效的提升性能（主要是并发能力），其中NIO2即为AIO，需要JDK 1.7+、Linux 2.6+才能支持。<ul><li>NIO：JDK 1.6+，tomcat 6.x+</li><li>NIO2：JDK 1.7+，tomcat 7.x+</li></ul></li><li><p>APR: 通过Native实现的I/O库, Tomcat通过JNI调用;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Tomcat 支持的几种protocol:</span><br><span class="line">//NIO</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">//NIO2</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;</span><br><span class="line">//ARP</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>@ref: </p><ul><li><a href="https://www.cnblogs.com/zhanjindong/p/concurrent-and-tomcat-threads.html" target="_blank" rel="noopener">聊下并发和Tomcat线程数（Updated） - zhanjindong - 博客园</a></li><li><a href="https://www.zhihu.com/question/53498767" target="_blank" rel="noopener">tomcat 源码为啥不采用netty 处理并发？ - 知乎</a></li></ul><h3 id="附-Connector-和线程池参数解析"><a href="#附-Connector-和线程池参数解析" class="headerlink" title="附: Connector 和线程池参数解析"></a>附: Connector 和线程池参数解析</h3><ol><li><code>&lt;Executor&gt;</code> 部分, 参数说明: <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html</a><ul><li><strong>namePrefix</strong>: The name prefix for each thread created by the executor</li><li><strong>maxThreads</strong>: The max number of active threads in this pool, default is 200</li><li><strong>minSpareThreads</strong>: The minimum number of threads (idle and active) always kept alive, default is 25</li><li><strong>maxIdleTime</strong>: The number of milliseconds before an idle thread shutsdown, unless the number of active threads are less or equal to minSpareThreads. Default value is 60000(1 minute)</li><li><strong>maxQueueSize</strong>: The maximum number of runnable tasks that can queue up awaiting execution before we reject them. Default value is Integer.MAX_VALUE</li></ul></li><li><code>&lt;Connector&gt;</code> 部分, <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</a><ul><li><strong>executor</strong>: A reference to the name in an Executor element. If this attribute is set, and the named executor exists, the connector will use the executor, and all the other thread attributes will be ignored. Note that if a shared executor is not specified for a connector then the connector will use a private, internal executor to provide the thread pool.</li><li><strong>acceptCount</strong>: The maximum queue length for incoming connection requests when all possible request processing threads are in use. Any requests received when the queue is full will be refused. The default value is 100.</li><li><strong>connectionTimeout</strong>: The number of milliseconds this Connector will wait, after accepting a connection, for the request URI line to be presented. Use a value of -1 to indicate no (i.e. infinite) timeout. The default value is 60000 (i.e. 60 seconds) but note that the standard server.xml that ships with Tomcat sets this to 20000 (i.e. 20 seconds). Unless disableUploadTimeout is set to false, this timeout will also be used when reading the request body (if any).</li><li><strong>maxThreads</strong>: The maximum number of request processing threads to be created by this Connector, which therefore determines the maximum number of simultaneous requests that can be handled. If not specified, this attribute is set to 200. If an executor is associated with this connector, this attribute is ignored as the connector will execute tasks using the executor rather than an internal thread pool. Note that if an executor is configured any value set for this attribute will be recorded correctly but it will be reported (e.g. via JMX) as -1 to make clear that it is not used.</li><li><strong>acceptorThreadCount</strong>: The number of threads to be used to accept connections. Increase this value on a multi CPU machine, although you would never really need more than 2. Also, with a lot of non keep alive connections, you might want to increase this value as well. Default value is 1.</li><li><strong>maxConnections</strong>: The maximum number of connections that the server will accept and process at any given time. When this number has been reached, the server will accept, but not process, one further connection. This additional connection be blocked until the number of connections being processed falls below maxConnections at which point the server will start accepting and processing new connections again. Note that once the limit has been reached, the operating system may still accept connections based on the acceptCount setting. The default value varies by connector type. For NIO and NIO2 the default is 10000. For APR/native, the default is 8192.<br>Note that for APR/native on Windows, the configured value will be reduced to the highest multiple of 1024 that is less than or equal to maxConnections. This is done for performance reasons.</li></ul></li></ol><h3 id="Tomcat-在-NIO-模式下的线程模型"><a href="#Tomcat-在-NIO-模式下的线程模型" class="headerlink" title="Tomcat 在 NIO 模式下的线程模型"></a>Tomcat 在 NIO 模式下的线程模型</h3><p>Tomcat使用 Connector 完成整个 HTTP Request的处理流程, 包括 accept socket → NIO Selector处理 socket读事件 → 把可读Socket分发给 Work线程 → 从socket读取数据并解析为Http请求 → Http请求交给CoyoteAdaper处理, CoyoteAdaper 通过Mapper找到对应的Servlet.</p><p><img src="/images/javaee/tomcat-nio-connector-process.png" alt="Tomcat-NIO-Connector-Process"></p><p>在NIO实现的Connector中，处理请求的主要实体是NIoEndpoint对象。NIoEndpoint中除了包含Acceptor和Worker外，还是用了Poller，处理流程如下图所示:</p><p><img src="/images/javaee/tomcat-nioendpoint-poler-worker.png" alt="Tomcat-NioEndpoint-Poler-Worker"></p><ul><li>Acceptor accept 客户端请求, 这里虽然是基于NIO的connector，但是在接收socket方面还是传统的<code>serverSocket.accept()</code>方式, Acceptor 获取到 客户端请求的socket, 封装进 tomcat的实现类org.apache.tomcat.util.net.NioChannel对象中, 然后将NioChannel对象封装在一个PollerEvent对象中，并将 PollerEvent对象压入events queue</li><li>Poller 读取 events queue 取出PollerEvent,  Poller线程中维护了一个Selector对象, Poller 从Event中取出 客户端请求的socketChannel, 把这个channel的READ事件注册到 Selector上.</li><li>Poller 通过 <code>Selector.select()</code> 遍历可读的 socketChannel, 从Worker线程池中拿到可用的Worker线程,将socket传递给Worker处理</li><li>Worker 线程将socket封装在SocketProcessor对象中。然后从Http11ConnectionHandler中取出Http11NioProcessor对象，从Http11NioProcessor中调用CoyoteAdapter的逻辑</li></ul><p>本节参考:<br><a href="https://my.oschina.net/weiweiblog/blog/1830173" target="_blank" rel="noopener">https://my.oschina.net/weiweiblog/blog/1830173</a><br><a href="https://www.jianshu.com/p/f91f99610b9e" target="_blank" rel="noopener">https://www.jianshu.com/p/f91f99610b9e</a></p><h2 id="APR支持"><a href="#APR支持" class="headerlink" title="APR支持"></a>APR支持</h2><p>APR(Apache Portable Runtime)可移植运行库，它是Apache HTTP Server 2.x的核心。APR有很多用途，包括访问高级IO功能(例如sendfile,<br>epoll和OpenSSL)，OS级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT管道和UNIX sockets)。<br>这些功能可以使Tomcat作为一个通常的前台WEB服务器，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器平台而不是简单作为后台容器。</p><p>可以简单地理解为: Tomcat将以JNI的形式调用 APR库中的Native Method处理文件读取或网络传输操作，提升Tomcat对静态文件的处理性能</p><p>安装步骤:</p><ul><li>下载APR, 编译<code>make &amp;&amp; make install</code></li><li>安装Tomcat Native到Tomcat的安装目录下</li><li>修改conf/server.xml, 修改<code>&lt;Connector&gt;</code>的protocol</li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>参考: <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html" target="_blank" rel="noopener">日志机制 - Tomcat 8 权威指南 - 极客学院Wiki</a></p><p>在 Apache Tomcat 上运行的 Web 应用可以使用以下日志：</p><ul><li>任何自选的日志框架，如<code>log4j</code>；</li><li>使用JDK提供的日志<code>java.util.logging</code>；</li><li>Java Servlets 规范所提供的日志 API，如<code>javax.servlet.ServletContext.log(...)</code>；</li></ul><blockquote><p>当tomcat启动时会为每个app分配了一个WebappClassLoader ，这样来避免多个app会加载相同jar包的问题，<br>不同Web应用程序下使用的Servlet日志（或者日志框架提供的日志，如log4j等）是相互独立的（这与Tomcat的class loader有关，参考<a href="http://tomcat.apache.org/tomcat-6.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Class Loader HOW-TO</a> ）。<br>如果Web应用程序使用的是java.util.logging日志，那么它们并不相互独立，这是因为java.util.logging是由JAVA系统中的Bootstrap ClassLoader来加载的，因此它在各Web应用程序之间是共享的。</p></blockquote><h2 id="JULI-vs-JUL"><a href="#JULI-vs-JUL" class="headerlink" title="JULI vs JUL"></a>JULI vs JUL</h2><p>JUL API（<code>java.util.logging</code>）的默认实现功能有限，因此tomcat的默认配置中，新增了另一种日志实现 JULI API（<code>org.apache.juli</code>），</p><blockquote><p>可以在Tomcat的 logging.properties 里看到定义了两种日志:<br>java.util.logging 的 <code>java.util.logging.ConsoleHandler</code> ;<br>JULI的 <code>org.apache.juli.FileHandler</code> ;</p></blockquote><p><strong>JULI</strong> 同样支持标准JDK java.util.logging的配置机制（都默认使用logging.properties作为配置文件），不同的是JULI的每一个类加载属性文件都可以被设置，并可以在其中定义处理器，这样就给了开发者更大的自由度。<br>JULI 的日志配置分为 全局配置 和 WebApp项目配置。<br>全局配置位于tomcat的配置目录<code>${catalina.base}/conf/logging.properties</code>文件,<br>如果该文件未配置或不可读，那么tomcat将会使用JRE中的默认日志配置，可以在<code>${java.home}/lib/logging.properties</code>查看配置文件的内容；<br>项目配置则是针对不同的项目，配置文件位于<code>WEB-INFO/classes/logging.properties</code>.</p><p>JUL 和 JULI使用相同的日志级别：SEVERE (最高级别) &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST (所有内容,最低级别)</p><p>JULI 所使用的配置与 java.util.logging 所支持的配置基本相同，只不过使用了一些扩展，以便更灵活地配置 logger 和 handler。主要的差别在于：</p><ul><li>JULI 的 handler 名称前可以加上前缀，所以同一类可以实例化出多个 handler。前缀是一个以数字开头的字符串，并以 . 结尾。比如 22foobar. 就是个有效的前缀。</li><li>JULI 的 handler 支持额外的属性, 比如<code>bufferSize</code></li></ul><h2 id="Tomcat日志配置解析"><a href="#Tomcat日志配置解析" class="headerlink" title="Tomcat日志配置解析"></a>Tomcat日志配置解析</h2><p>以下是一个 <code>$CATALINA_BASE/conf</code> 中的默认 logging.properties 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span># 声明所有的handlers</span><br><span class="line">handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># RootLogger使用的handlers</span><br><span class="line">.handlers = 1catalina.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 定义了4个 org.apache.juli.FileHandler : 1catalina, 2localhost, 3manager, 4host-manager</span><br><span class="line">1catalina.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">1catalina.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">1catalina.org.apache.juli.FileHandler.prefix = catalina.</span><br><span class="line">1catalina.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">2localhost.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">2localhost.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">2localhost.org.apache.juli.FileHandler.prefix = localhost.</span><br><span class="line">2localhost.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">3manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">3manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">3manager.org.apache.juli.FileHandler.prefix = manager.</span><br><span class="line">3manager.org.apache.juli.FileHandler.bufferSize = 16384</span><br><span class="line">3manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">4host-manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.prefix = host-manager.</span><br><span class="line">4host-manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 定义 ava.util.logging.ConsoleHandler :</span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br><span class="line">java.util.logging.ConsoleHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 定义handlers, 使用上面定义的 FileHandler</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers = 2localhost.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers = 3manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers = 4host-manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> For example, set the org.apache.catalina.util.LifecycleBase logger to log</span><br><span class="line"><span class="meta">#</span> each component that extends LifecycleBase changing state:</span><br><span class="line"><span class="meta">#</span>org.apache.catalina.util.LifecycleBase.level = FINE</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> To see debug messages in TldLocationsCache, uncomment the following line:</span><br><span class="line"><span class="meta">#</span>org.apache.jasper.compiler.TldLocationsCache.level = FINE</span><br></pre></td></tr></table></figure><ul><li><code>java.util.logging.ConsoleHandler</code>:<br>When running Tomcat on unixes, the console output is usually redirected to the file named catalina.out.<br>The name is configurable using an environment variable. (See the startup scripts).<br>Whatever is written to System.err/out will be caught into that file. That may include:<ul><li>Uncaught exceptions printed by java.lang.ThreadGroup.uncaughtException(..)</li><li>Thread dumps, if you requested them via a system signal</li></ul></li></ul><blockquote><p>java.util.logging.ConsoleHandler 是java自带的日志处理系统（JUL）的控制台日志Handler,<br>Tomcat通过<code>System.err.println()</code>/<code>System.out.println()</code>打出的日志会通过 java.util.logging.ConsoleHandler 写入Tomcat进程的stdout/stderr,<br>并最终输出到文件”catalina.out”中, 这个文件名是在Tomcat启动脚本里定义的:</p></blockquote><ul><li><code>org.apache.juli.FileHandler</code>:<br>org.apache.juli.FileHandler supports buffering of the logs.<br>The buffering is not enabled by default. To configure it, use the bufferSize property of a handler.<br>The value of 0 uses system default buffering (typically an 8K buffer will be used).<br>A value of &lt; 0 forces a writer flush upon each log write.<br>A value &gt; 0 uses a BufferedOutputStream with the defined value but note that the system default buffering will also be applied.</li></ul><blockquote><p>org.apache.支持日志缓存。日志缓存默认是没有启用的。使用 handler 的 bufferSize 属性可以配置它：<br>属性值为 0 时，代表使用系统默认的缓存（通常使用 8k 缓存）；<br>属性值小于 0 时，将在每个日志写入上强制使用 writer flush（将缓存区中的数据强制写出到系统输出）功能；<br>属性值大于 0 时，则使用带有定义值的 BufferedOutputStream 类——但要注意的是，这也将应用于系统默认的缓存。</p></blockquote><h2 id="WebApp的日志配置解析"><a href="#WebApp的日志配置解析" class="headerlink" title="WebApp的日志配置解析"></a>WebApp的日志配置解析</h2><p>下例是一个用于 servlet-examples 应用的 WEB-INF/classes 中的 logging.properties 文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>###########################################################</span><br><span class="line"><span class="meta">#</span> Handler specific properties.</span><br><span class="line"><span class="meta">#</span> Describes specific configuration info for Handlers.</span><br><span class="line"><span class="meta">#</span>###########################################################</span><br><span class="line"></span><br><span class="line">org.apache.juli.FileHandler.level = FINE</span><br><span class="line">org.apache.juli.FileHandler.directory =  $&#123;catalina.base&#125;/logs</span><br><span class="line">org.apache.juli.FileHandler.prefix = $&#123;classloader.webappName&#125;.</span><br></pre></td></tr></table></figure><blockquote><p>Tomcat启动时报错 “SEVERE: Error listenerStart” 或者 “SEVERE: Error filterStart” 等, 但没有具体的错误日志:<br>这种一般是因为 Tomcat WebAppClassLoader 加载的<code>org.springframework</code>类的日志没有关联一个Handler,<br>可以修改 webapps/xxx/WEB-INF/classes/logging.properties, Tomcat就会在打印 org.springframework 类的详细的报错信息了.<br>注意, 老的应用可能还在使用 System.out 或 System.err，这种情况下还需要在web应用的classes/logging.properties 里增加 java.util.logging.ConsoleHandler:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line">## JULI.FileHandler 的设置</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">## JUL.ConsoleHandler 的设置</span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br></pre></td></tr></table></figure><blockquote><p>对于还在使用 System.out 或 System.err的应用:<br>可以通过在 Context 元素上设置 swallowOutput 属性来调整。如该属性设为 true，那么在请求阶段对 System.out/err 的调用就会被拦截，它们的输出也会通过 <code>javax.servlet.ServletContext.log(...)</code> 调用反馈给日志系统。</p></blockquote><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><ul><li>catalina.2017-08-29.log         //Cataline引擎的日志文件</li><li>localhost.2017-08-29.log        //Tomcat下内部代码抛出的日志jsp页面内部错误的异常</li><li>manager.2017-08-29.log          //Tomcat下默认 manager应用日志</li><li>host-manager.2017-08-29.log     //Tomcat下默认 manager应用日志</li><li>localhost_access_log.2017-08-29.txt  //访问日志记录</li><li>catalina.out                         //控制台输出的日志,Linux下默认重定向到catalina.out</li></ul><p>查看catalina.sh, 最终启动tomcat执行的命令行是 <code>java ${JAVA_OPTS} org.apache.catalina.startup.Bootstrap start</code></p><h2 id="生产环境中的日志"><a href="#生产环境中的日志" class="headerlink" title="生产环境中的日志"></a>生产环境中的日志</h2><p>可能需要注意以下方面：</p><ul><li>将 ConsoleHandler 从配置中移除。默认（ .handlers 设置）日志会使用 FileHandler 和 ConsoleHandler。<br>后者的输出经常会被捕获到一个文件中，比如 catalina.out。从而导致同一消息可能生成了两个副本。</li><li>对于不使用的应用(比如 host-manager)，可以考虑将 FileHandlers 移除。</li><li>handler 默认使用系统缺省编码来写入日志文件，通过 encoding 属性可以修改设置，详情查看相关的 javadoc 文档。</li><li>增加Access访问日志。</li></ul><h2 id="使用log4j"><a href="#使用log4j" class="headerlink" title="使用log4j"></a>使用log4j</h2><p>参考 <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html#usingLog4j" target="_blank" rel="noopener">使用 Log4j</a> @ref</p><ul><li>如果只是想在自己的 Web 应用上使用 log4j 时<ul><li>只需将 log4j.jar 和 log4j.properties 放到 Web 应用的 WEB-INF/lib 和 WEB-INF/classes 中即可</li></ul></li><li>如果想配置 Tomcat 以便利用 log4j 来进行自身日志记录时，下面的步骤都是必需的:<ul><li>创建一个包含下列配置的 log4j.properties 文件，将其保存到 $CATALINA_BASE/lib。<strong>Important!</strong></li><li>下载 log4j</li><li>下载或构建 tomcat-juli.jar 和 tomcat-juli-adapters.jar，以便作为 Tomcat 的额外组件使用。</li><li>将 log4j.jar 和 tomcat-juli-adapters.jar 从 extras 中放入 $CATALINA_HOME/lib 中。</li><li>用 extras 中的 tomcat-juli.jar 替换 $CATALINA_HOME/bin/tomcat-juli.jar。</li><li>删除 $CATALINA_BASE/conf/logging.properties，以防止 java.util.logging 生成零长度的日志文件。</li></ul></li></ul><h1 id="高级IO"><a href="#高级IO" class="headerlink" title="高级IO"></a>高级IO</h1><h2 id="推送-Comet-支持"><a href="#推送-Comet-支持" class="headerlink" title="推送: Comet 支持"></a>推送: Comet 支持</h2><p>施工中</p><h2 id="发送大型静态文件-sendfile"><a href="#发送大型静态文件-sendfile" class="headerlink" title="发送大型静态文件: sendfile"></a>发送大型静态文件: sendfile</h2><p>施工中</p><h1 id="How-to-deploy-war"><a href="#How-to-deploy-war" class="headerlink" title="How to deploy war"></a>How to deploy war</h1><p>有3中方式部署war包:</p><ol><li>在server.xml的<code>&lt;Host&gt;</code>标签中声明<code>&lt;Context&gt;</code>标签</li><li>在server.xml的<code>&lt;Host&gt;</code>标签中开启autoDeploy, 将war包放入webapps中会自动部署</li><li>context.xml配置方式</li></ol><h2 id="Using-the-UI-manager"><a href="#Using-the-UI-manager" class="headerlink" title="Using the UI manager"></a>Using the UI manager</h2><p>Tomcat提供了一个网页版的Manager App, 默认位置在webapps/manager, 也是一个web项目, 使用方式参考: <a href="http://tomcat.apache.org/tomcat-6.0-doc/manager-howto.html#Configuring_Manager_Application_Access" target="_blank" rel="noopener">Apache Tomcat 6.0 (6.0.53) - Manager App HOW-TO</a> @ref</p><p>Go to <code>[&lt;protocol&gt;://]localhost:&lt;port&gt;/manager/html/</code> (usually <code>localhost:8080/manager/html/</code>),<br>If you get:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">403 Access Denied</span><br></pre></td></tr></table></figure></p><p>go to <code>%CATALINA_HOME%\conf\tomcat-users.xml</code> and check that you have enabled a line like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;tomcat,role1,manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Using-maven"><a href="#Using-maven" class="headerlink" title="Using maven"></a>Using maven</h2><p>待补充…</p><h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><blockquote><p>@ref 参考: <a href="https://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Apache Tomcat 7 (7.0.93) - Class Loader HOW-TO</a></p></blockquote><p>与很多服务器应用一样，Tomcat 也安装了各种类加载器。借助类加载器，容器的不同部分以及运行在容器里的 Web Apps 就可以访问不同的仓库（保存着可使用的类和资源）。<br>// 这里英文原文是”different repositories of available classes and resources.” 不知道该怎么翻译这里的”repositories” ?</p><blockquote><p>在 Java 环境中，类加载器的布局结构是一种父子树的形式。通常，类加载器被请求加载一个特定的类或资源时，它会先把这一请求委托给它的父类加载器，只有（一个或多个）父类加载器无法找到请求的类或资源时，它才开始查看自身的仓库。</p></blockquote><p>注意，Web 应用的类加载器模式跟这个稍有不同，下文将详细介绍，但基本原理是一样。<br>当 Tomcat 启动后，它就会创建一组类加载器，这些类加载器被布局成如下图所示这种父子关系，父类加载器在子类加载器之上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Bootstrap</span><br><span class="line">        |</span><br><span class="line">     System</span><br><span class="line">        |</span><br><span class="line">     Common</span><br><span class="line">     /     \</span><br><span class="line">Webapp1   Webapp2 ..</span><br></pre></td></tr></table></figure><p>如上图所示，Tomcat 在初始化时会创建如下这些类加载器：</p><ul><li><strong>Bootstrap</strong> 这种类加载器包含 JVM 所提供的基本的运行时类，以及来自系统扩展目录（<code>$JAVA_HOME/jre/lib/ext</code>）里 JAR 文件中的类。<br>注意：在有些 JVM 的实现中，它的作用不仅仅是类加载器，或者它可能根本不可见（作为类加载器）。</li><li><strong>System</strong> 这种类加载器通常是根据 CLASSPATH 环境变量内容进行初始化的。所有的这些类对于 Tomcat 内部类以及 Web 应用来说都是可见的。<br>不过，标准的 Tomcat 启动脚本（<code>$CATALINA_HOME/bin/catalina.sh</code> 或 <code>%CATALINA_HOME%\bin\catalina.bat</code>）完全忽略了 CLASSPATH 环境变量自身的内容，相反从下列仓库来构建系统类加载器：<ul><li><code>$CATALINA_HOME/bin/bootstrap.jar</code> 包含用来初始化 Tomcat 服务器的 <code>main()</code> 方法，以及它所依赖的类加载器实现类。</li><li><code>$CATALINA_BASE/bin/tomcat-juli.jar</code> 或 <code>$CATALINA_HOME/bin/tomcat-juli.jar</code> 日志实现类。其中包括了对 <code>java.util.logging</code> API 的功能增强类（Tomcat JULI），以及对 Tomcat 内部使用的 Apache Commons 日志库的包重命名副本。详情参看 Tomcat 日志文档。<br>如果 <code>*$CATALINA_BASE/bin*</code> 中存在 <code>tomcat-juli.jar</code>，就不会使用 <em>$CATALINA_HOME/bin</em> 中的那一个。它有助于日志的特定配置。</li><li><code>$CATALINA_HOME/bin/commons-daemon.jar</code> Apache Commons Daemon 项目的类。该 JAR 文件并不存在于由 catalina.bat 或 catalina.sh 脚本所创建的 CLASSPATH 中，而是引用自 bootstrap.jar 的清单文件。</li></ul></li><li><strong>Common</strong> 这种类加载器包含更多的额外类，它们对于Tomcat 内部类以及所有 Web 应用都是可见的。<br>通常，应用类不会放在这里。该类加载器所搜索的位置定义在 <code>$CATALINA_BASE/conf/catalina.properties</code> 的 common.loader 属性中。默认的设置会搜索下列位置（按照列表中的上下顺序）。<ul><li><code>$CATALINA_BASE/lib</code> 中的解包的类和资源。</li><li><code>$CATALINA_BASE/lib</code> 中的 JAR 文件。</li><li><code>$CATALINA_HOME/lib</code> 中的解包类和资源。</li><li><code>$CATALINA_HOME/lib</code> 中的 JAR 文件。<br>默认，它包含以下这些内容：</li><li><em>annotations-api.jar</em> JavaEE 注释类。</li><li><em>catalina.jar</em> Tomcat 的 Catalina servlet 容器部分的实现。</li><li><em>jsp-api.jar</em> JSP 2.3 API</li><li><em>servlet-api.jar</em> Servlet 3.1 API</li><li><em>tomcat-api.jar</em> Tomcat 定义的一些接口</li><li><em>tomcat-dbcp.jar</em> 数据库连接池实现，基于 Apache Commons Pool 的包重命名副本和 Apache Commons DBCP。</li><li><em>tomcat-jdbc.jar</em> 一个数据库连接池替代实现，又被称作 Tomcat JDBC 池。详情参看 JDBC 连接池文档。</li><li>…</li></ul></li><li><strong>WebappX</strong> 为每个部署在单个 Tomcat 实例中的 Web 应用创建的类加载器。你的 Web 应用的 /WEB-INF/classes 目录中所有的解包类及资源，以及 /WEB-INF/lib 目录下 JAR 文件中的所有类及资源，对于该应用而言都是可见的，但对于其他应用来说则不可见。<br>如上所述，Web 应用类加载器背离了默认的 Java 委托模式（根据 Servlet 规范 2.4 版的 9.7.2 Web Application Classloader一节中提供的建议）。<br>当某个请求想从 Web 应用的 WebappX 类加载器中加载类时，该类加载器会先查看自己的仓库，而不是预先进行委托处理。<br>JRE 基类的部分类不能被重写。对于一些类（比如 J2SE 1.4+ 的 XML 解析器组件），可以使用 J2SE 1.4 支持的特性。<br>最后，类加载器会显式地忽略所有包含 Servlet API 类的 JAR 文件，所以不要在 Web 应用包含任何这样的 JAR 文件。Tomcat 其他的类加载器则遵循常用的委托模式。</li></ul><p>因此，从 Web 应用的角度来看，加载类或资源时，要查看的仓库及其顺序如下：</p><ol><li>JVM 的 Bootstrap 类</li><li>Web 应用的 /WEB-INF/classes 类</li><li>Web 应用的 /WEB-INF/lib/*.jar 类</li><li>System 类加载器的类（如上所述）</li><li>Common 类加载器的类（如上所述）</li></ol><p>如果 Web 应用类加载器配置有 <code>&lt;Loader delegate=&quot;true&quot;/&gt;</code> ，则顺序变为：</p><ol><li>JVM 的 Bootstrap 类</li><li>System 类加载器的类（如上所述）</li><li>Common 类加载器的类（如上所述）</li><li>Web 应用的 /WEB-INF/classes 类</li><li>Web 应用的 /WEB-INF/lib/*.jar 类</li></ol><h1 id="源码导读-Tomcat-8-5"><a href="#源码导读-Tomcat-8-5" class="headerlink" title="源码导读 (Tomcat 8.5)"></a>源码导读 (Tomcat 8.5)</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ant clean</span><br><span class="line">ant</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp ./output/classes -Dcatalina.home=./output/build org.apache.catalina.startup.Bootstrap</span><br></pre></td></tr></table></figure><h2 id="启动过程源码调用时序"><a href="#启动过程源码调用时序" class="headerlink" title="启动过程源码调用时序"></a>启动过程源码调用时序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Bootstrap.main // 入口方法</span><br><span class="line">  Bootstrap.init()</span><br><span class="line">    initClassLoaders()  // 初始化commonLoader, catalinaLoader, sharedLoader</span><br><span class="line">      commonLoader = createClassLoader(<span class="string">"common"</span>, null);</span><br><span class="line">        ClassLoaderFactory.createClassLoader(repositories, parent); // 该方法通过AccessController.doPrivileged创建了URLClassLoader, 并返回</span><br><span class="line">    catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>)` // 创建Catalina对象</span><br><span class="line">  Bootstrap.load(args)</span><br><span class="line">    Catalina.load()</span><br><span class="line">      Digester digester = createStartDigester() // 为digester 添加 Rule</span><br><span class="line">      Digester.parse(inputSource) // 解析 server.xml !!</span><br><span class="line">        Digester.startElement()</span><br><span class="line">          Rule.begin()</span><br><span class="line">            ObjectCreateRule.begin() // 这里通过反射调用了 Server &amp; Connector &amp; Context等类的构造方法</span><br><span class="line">              org.apache.catalina.core.StandardServer.StandardServer() // Server构造</span><br><span class="line">              org.apache.catalina.core.StandardService.StandardService() // Service构造</span><br><span class="line">            ConnectorCreateRule.begin</span><br><span class="line">              org.apache.catalina.connector.Connector.Connector()</span><br><span class="line">                // Connector构造, 根据配置中的 <span class="string">"protocol"</span> 设置创建不同的创建 ProtocolHandler:</span><br><span class="line">                Http11NioProtocol() // 默认的 ProtocolHandler</span><br><span class="line">                  AbstractHttp11Protocol(new NioEndpoint())</span><br><span class="line">                    NioEndpoint()</span><br><span class="line">                        AbstractEndpoint()  // 创建 worker 线程池</span><br><span class="line">  Bootstrap.start()</span><br><span class="line">    Catalina.start()</span><br><span class="line">      StandardServer.start() =&gt; LifecycleBase.start()</span><br><span class="line">        StandardServer.startInternal()</span><br><span class="line">          StandardService.start() =&gt; LifecycleBase.start()</span><br><span class="line">            StandardService.startInternal()</span><br><span class="line">              Engine.start() =&gt; LifecycleBase.start()   // 启动 Engine</span><br><span class="line">                StandardEngine.startInternal()</span><br><span class="line">                  ContainerBase.startInternal()</span><br><span class="line">                    StartChild.call()  // 多线程启动, 线程数=Host数量</span><br><span class="line">                      StandardHost.start() =&gt; LifecycleBase.start()</span><br><span class="line">                        StandardHost.startInternal()</span><br><span class="line">                          ContainerBase.startInternal() =&gt; LifecycleBase.setStateInternal()</span><br><span class="line">                            ContainerBase.setState(LifecycleState.STARTING)</span><br><span class="line">                              LifecycleBase.fireLifecycleEvent(lifecycleEvent, data)</span><br><span class="line">                                  HostConfig.start()</span><br><span class="line">                                    HostConfig.deployApps()</span><br><span class="line">                                      HostConfig.deployWARs() // 解析 web.xml !!</span><br><span class="line">              MapperListener.start() =&gt; LifecycleBase.start()  // 启动 MapperListener</span><br><span class="line">                MapperListener.startInternal()</span><br><span class="line">              Connector.start() =&gt; LifecycleBase.start()     // 启动(多个) Connector</span><br><span class="line">                Connector.startInternal()</span><br><span class="line">                  Http11NioProtocol.start() =&gt; AbstractProtocol.start()</span><br><span class="line">                    AbstractEndpoint.start() =&gt; NioEndpoint.startInternal()</span><br><span class="line">                      // 创建三个cache: processorCache, eventCache, nioChannels</span><br><span class="line">                      startAcceptorThreads()</span><br><span class="line">                    new AsyncTimeout(); // Start <span class="keyword">async</span> timeout thread</span><br><span class="line">      StandardServer.<span class="keyword">await</span>() // 创建一个在<span class="number">8005</span>监听的ServerSocket, 用于监听关闭</span><br><span class="line">        ServerSocket.accept // 阻塞在这里</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote><p>参考 <a href="https://blog.csdn.net/tjiyu/article/details/54590259" target="_blank" rel="noopener">Tomcat实现：源码分析Tomcat实现细节 </a> @Archived</p><pre><code>* Connect.start()—创建并发线程模型: Work线程, Poller线程, Acceptor线程, AsyncTimeout线程* 请求处理: Acceptor线程, Poller线程, Selector</code></pre></blockquote><h3 id="如何解析server-xml"><a href="#如何解析server-xml" class="headerlink" title="如何解析server.xml"></a>如何解析server.xml</h3><ul><li>在Catalina.load() 创建digester: <code>Digester digester = createStartDigester()</code></li><li><code>createStartDigester</code>方法创建了digester对象, 并给digester对象添加多种Rule, 每种Rule都对应server.xml里的一个节点类型, 比如<code>&lt;Server&gt;</code>, <code>&lt;Connector&gt;</code>;</li><li>digester对server.xml设置的标签动作有5种调用：<ul><li>addObjectCreate：遇到起始标签的元素，初始化一个实例对象入栈</li><li>addSetProperties：遇到某个属性名，使用setter来赋值</li><li>addSetNext：遇到结束标签的元素，调用相应的方法</li><li>addRule：调用rule的begin 、body、end、finish方法来解析xml，入栈和出栈给对象赋值</li><li>addRuleSet：调用addRuleInstances来解析xml标签</li></ul></li><li>从这些规则和xml中可以看到，Calatina的Server对象是StandardServer。 StandardService包含了多个Connector（xml中有2个connector）和一个StandardEngine Container。 StandardEngine包含了一个Host Container</li></ul><h3 id="初始化Connector"><a href="#初始化Connector" class="headerlink" title="初始化Connector"></a>初始化Connector</h3><p>根据配置文件 protocol = “HTTP/1.1”,”AJP/1.3” 创建对应 protocol, 默认是 Http11NioProtocol,<br>再由Http11NioProtocol 创建 NioEndpoint:</p><p>代码流程</p><ul><li>调用<code>Connector(String protocol)</code>, 构造函数<code>Connector</code>中默认创建<code>org.apache.coyote.http11.Http11NioProtocol</code></li><li>以<code>Http11NioProtocol</code>为例, <code>Http11NioProtocol.init()</code>最终调用到<code>NioEndpoint.bind()</code> =&gt; <code>NioEndpoint.initServerSocket()</code>  =&gt; <code>serverSock.socket().bind(addr,getAcceptCount())</code> 完成了对端口的绑定</li><li>bind()的最后调用了<code>NioSelectorPool.open()</code>, 这是一个存放Selector的池子,</li></ul><h3 id="启动Connector"><a href="#启动Connector" class="headerlink" title="启动Connector"></a>启动Connector</h3><p>Connector 主要功能实现都是在 <strong>NioEndpoint</strong>, NioEndpoint 包括x个Acceptor线程, x个 Poller线程;<br>Acceptor线程(默认一个)用于 accept 客户端请求, 并把 客户端请求socket 封装进event, 放入 events queue;<br>Poller线程池用于消费 events queue, 每个Poller 都有自己的 Selector对象, 不断取出event, 并从中解析出sockt, 并把socket 的 READ事件注册到自己的 Selector.</p><p>代码调用流程:</p><ul><li>Connector的启动会调用<code>start</code>方法, =&gt; <code>Connector.startInternal</code>方法 =&gt; <code>Http11NioProtocol.start()</code> =&gt; <code>AbstractProtocol.start()</code> =&gt; <code>NioEndpoint.start()</code> =&gt; <code>NioEndpoint.startInternal()</code></li><li>在<code>NioEndpoint.startInternal()</code>中,<ul><li>如果Worker线程池是空, 则自己创建: 调用了父类<code>AbstractEndpoint#createExecutor()</code>, 创建work线程池, 名称前缀 “-exec-“;</li><li>创建<code>NioEndpoint$Poller[]</code>数组, Poller是Runnable的实现, 然后所有的Poller线程都start起来, 线程名前缀是 “-ClientPoller-“, 数组的大小也就是Poller的数量是<code>Math.min(2,Runtime.getRuntime().availableProcessors())</code>, 可见 Poller数量 是 min(2, cpu的process数量)</li><li>调用<code>startAcceptorThreads()</code>,  创建 <code>Acceptor</code>线程, 默认一个(线程数是server.xml里的<code>acceptCount</code>), , 线程名前缀是”-Acceptor-“</li></ul></li></ul><h3 id="accept请求"><a href="#accept请求" class="headerlink" title="accept请求"></a>accept请求</h3><p>Acceptor 线程 accept , 并把 客户端请求socket 封装进event, 放入 events queue, 调用流程:</p><ul><li><p><code>Acceptor.run()</code>:</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (endpoint.isRunning()) &#123;</span><br><span class="line">    socket = endpoint.serverSocketAccept();</span><br><span class="line">    endpoint.setSocketOptions(socket) // 调用了 NioEndpoint.setSocketOptions()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再看 <code>NioEndpoint.setSocketOptions()</code>里做了什么:  把客户端请求的socket 封装进 NioChannel,<br>调用 Poller.register(NioChannel): 把 NioChannel 封装进PollerEvent,  每个 Poller都有一个 PollerEvent队列(events queue), 把PollerEvent放入这个队列 // Poller 有多个, 这里会轮询的方式选择出其中一个, <code>AtomicInteger.incrementAndGet()) % pollers.length</code></p></li></ul><h3 id="处理一次Req请求"><a href="#处理一次Req请求" class="headerlink" title="处理一次Req请求"></a>处理一次Req请求</h3><p>Poller线程用于消费 events queue, 代码调用流程:</p><ul><li><code>Poller.run()</code> while循环从 event queue取出 PollerEvent, 然后调用 <code>PollerEvent.run()</code><ul><li><code>PollerEvent.run()</code> // 主要是 在 Poller自己的Selector上注册 READ事件</li><li><code>Poller.processKey(SelectionKey , NioSocketWrapper)</code> 调用-&gt; <code>Poller.processSocket</code> // 处理 OPEN_READ/OPEN_WRITE等事件<ul><li>创建一个 SocketProcessorBase的实例, 把 socket 和 Event 封装进去, SocketProcessorBase 继承自Runnable</li><li>executor.execute(SocketProcessorBase) // 用Worker线程池运行这个 SocketProcessorBase<ul><li><code>SocketProcessorBase.run()</code> -&gt; <code>SocketProcessor.doRun()</code></li></ul></li></ul></li></ul></li></ul><p>再看SocketProcessor 调用流程:</p><ul><li><code>SocketProcessor.doRun()</code> :  // 调用SocketChannel.keyFor()<ul><li><code>AbstractProtocol$ConnectionHandler.process()</code><ul><li><code>NioEndpoint$SocketProcessor.doRun()</code><ul><li><code>Http11Processor.service()</code> : 处理Socket IO流, 解析为Http Request<ul><li><code>ApplicationFilterChain.internalDoFilter()</code>: 调用<code>Filter.doFilter()</code> ,以及<code>Servlet.service()</code>;</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="如何SHUTDOWN"><a href="#如何SHUTDOWN" class="headerlink" title="如何SHUTDOWN"></a>如何SHUTDOWN</h3><ul><li>StandardServer.await() 创建一个在8005监听的ServerSocket, 是用来监听关闭Tomcat命令的, 当执行shutdown.sh关闭tomcat时就是连接8005端口执行“SHUTDOWN”命令;</li><li>关闭请求发给Tomcat, 由StandardServer.await处理, await方法验证关闭请求是否有效, 如果有效则退出await方法, 进入Catalina.stop(), 调用<br>StandardServer.stop, StandardServer.destroy,  然后关闭Connector, Service</li></ul><p>从日志可以看到:</p><ul><li>WebappLoader.stopInternal -&gt; WebappClassLoaderBase.stop -&gt; WebappClassLoaderBase.clearReferences<ul><li>WebappClassLoaderBase.clearReferencesJdbc</li><li>WebappClassLoaderBase.clearReferencesThreads</li></ul></li><li>AbstractProtocol.pause Pausing ProtocolHandler [“http-nio-8080”]</li><li>AbstractProtocol.pause Pausing ProtocolHandler [“ajp-nio-8009”]</li><li>StandardService.stopInternal</li></ul><h2 id="Useful-Java-API-usage"><a href="#Useful-Java-API-usage" class="headerlink" title="Useful Java API usage"></a>Useful Java API usage</h2><ul><li>AsyncChannelWrapperSecure:<ul><li>Executors.newFixedThreadPool , shutdownNow</li><li>AsynchronousSocketChannel</li><li>ByteBuffer, flip, hasRemaining,</li><li>AtomicBoolean</li></ul></li><li>WsWebSocketContainer<ul><li>AsynchronousSocketChannel</li></ul></li></ul><h3 id="并发的处理代码"><a href="#并发的处理代码" class="headerlink" title="并发的处理代码"></a>并发的处理代码</h3><ul><li><p>用线程池启动容器内组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // Start our child containers, if any</span><br><span class="line">Container children[] = findChildren();</span><br><span class="line">List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">    results.add(startStopExecutor.submit(new StartChild(children[i])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean fail = false;</span><br><span class="line">for (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        result.get();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过Callable封装带返回值的任务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class StartChild implements Callable&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Container child;</span><br><span class="line"></span><br><span class="line">    public StartChild(Container child) &#123;</span><br><span class="line">        this.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void call() throws LifecycleException &#123;</span><br><span class="line">        child.start();</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://toutiao.io/u/176492?page=4" target="_blank" rel="noopener">Tomcat那些事儿的热门分享 - 开发者头条</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png&quot; alt=&quot;Tomcat&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;为什么-Java-Web-开发需要Tomcat&quot;&gt;&lt;a href=&quot;#为什么-Java-Web-开发需要Tomcat&quot; class=&quot;headerlink&quot; title=&quot;为什么 Java Web 开发需要Tomcat&quot;&gt;&lt;/a&gt;为什么 Java Web 开发需要Tomcat&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java EE&lt;/strong&gt;（Java Platform Enterprise Edition，2018 年 3 月更名为&lt;strong&gt;Jakarta EE&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;Servlet 是 Java EE 众多标准下的一个 （link &lt;a href=&quot;/13.JavaEE-Framework/JavaEE.Servlet/&quot; title=&quot;JavaEE.Servlet&quot;&gt;JavaEE.Servlet&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个 Servlet 的工作模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建并填充 Request 对象，包括：URI、参数、method、请求头信息、请求体信息等&lt;/li&gt;
&lt;li&gt;创建 Response 对象&lt;/li&gt;
&lt;li&gt;执行业务逻辑，将结果通过 Response 的输出流输出到客户端&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="13.J2EE" scheme="https://beefyheisenberg.github.io/categories/13-J2EE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Tomcat" scheme="https://beefyheisenberg.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringMVC/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringMVC/</id>
    <published>2023-05-09T04:45:01.090Z</published>
    <updated>2023-05-09T04:45:01.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Framework-框架图"><a href="#Spring-Framework-框架图" class="headerlink" title="Spring Framework 框架图"></a>Spring Framework 框架图</h1><p>下图是 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RC2/spring-framework-reference/overview.html" target="_blank" rel="noopener">Spring 官网</a>的一个架构图，介绍下其组成部分：</p><p><img src="/images/Spring-Framework-Runtime.png" alt="../_images/Spring-Framework-Runtime.png"></p><h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><p>由spring-core、spring-beans、spring-context、spring-context-support和spring-expression模块组成：</p><ul><li><p>spring-core 和 spring-beans 提供框架的基础部分，包括 IOC 功能，BeanFactory 是一个复杂的工厂模式的实现，将配置和特定的依赖从实际程序逻辑中解耦。</p></li><li><p>context 模块建立在 core 和 beans 模块的基础上，增加了对国际化的支持、事件广播、资源加载和创建上下文，ApplicationContext 是 context 模块的重点。</p></li><li><p>spring-context-support 提供对常见第三个库的支持，集成到 spring 上下文中，比如缓存(ehcache,guava)、通信(javamail)、调度(commonj,quartz)、模板引擎等(freemarker,velocity)。</p></li><li><p>spring-expression 模块提供了一个强大的表达式语言用来在运行时查询和操作对象图，这种语言支持对属性值、属性参数、方法调用、数组内容存储、集合和索引、逻辑和算数操作及命名变量，并且通过名称从 spring 的控制反转容器中取回对象。</p></li></ul><h2 id="AOP-和服务器工具"><a href="#AOP-和服务器工具" class="headerlink" title="AOP 和服务器工具"></a>AOP 和服务器工具</h2><ul><li><p>spring-aop 模块提供面向切面编程实现</p></li><li><p>单独的 spring-aspects 模块提供了 aspectj 的集成和适用。</p></li><li><p>spring-instrument 提供一些类级的工具支持和 ClassLoader 级的实现，用于服务器。spring-instrument-tomcat 针对 tomcat 的 instrument 实现。</p></li></ul><h2 id="消息组件"><a href="#消息组件" class="headerlink" title="消息组件"></a>消息组件</h2><p>包含了spring-messaging模块，从spring集成项目中抽象出来，比如Messge、MessageChannel、MessageHandler及其他用来提供基于消息的基础服务。</p><h2 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h2><p>数据访问和集成层由 JDBC、ORM、OXM、JMS 和 Transaction 模块组成。</p><ul><li><p>spring-jdbc 模块提供了不需要编写冗长的 JDBC 代码和解析数据库厂商特有的错误代码的 JDBC 抽象出。</p></li><li><p>spring-orm 模块提供了领先的对象关系映射 API 集成层，如 JPA、Hibernate 等。</p></li><li><p>spring-oxm 模块提供抽象层用于支持 Object/XML maping 的实现，如 JAXB、XStream 等。</p></li><li><p>spring-jms 模块包含生产和消费消息的功能，从 Spring4.1开始提供集成 spring-messaging 模块。</p></li><li><p>spring-tx 模块提供可编程和声明式事务管理。</p></li></ul><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>Web层包含spring-web、spirng-webmvc、spring-websocket和spring-webmvc-portlet模块组成。</p><ul><li><p>spring-web 模块提供了基本的面向 web 开发的集成功能，例如多文件上传、使用 servert listeners 和 web 开发应用程序上下文初始化 IOC 容器。也包含 HTTP 客户端以及 spring 远程访问的支持的 web 相关部分。</p></li><li><p>spring-webmvc 包含 spring 的 model-view-controller 和 REST web services 实现的 Web 应用程序。</p></li><li><p>spring-webmvc-portlet 模块提供了 MVC 模式的 portlet 实现，protlet 与 Servlet 的最大区别是请求的处理分为 action 和 render 阶段，在一个请求中，action 阶段只执行一次，但 render 阶段可能由于用户的浏览器操作而被执行多次。</p></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>spring-test模块支持通过组合Junit或TestNG来进行单元测试和集成测试，提供了连续的加载ApplicationContext并且缓存这些上下文。</p><h1 id="使用Spring-Context"><a href="#使用Spring-Context" class="headerlink" title="使用Spring Context"></a>使用Spring Context</h1><p>使用ClassPathXmlApplicationContext:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"META-INF/spring/spring-main.xml"</span>);</span><br><span class="line">A a = context.getBean(A.class);</span><br></pre></td></tr></table></figure><p>直接使用 DefaultListableBeanFactory:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"spring-core.xml"</span>);</span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br><span class="line">MyBean myBean = (MyBean) beanFactory.getBean(<span class="string">"myBean"</span>);</span><br><span class="line">myBean.sayHello();</span><br></pre></td></tr></table></figure><p>区分<strong>ApplicationContext</strong> and  <strong>ServletContext</strong> <a href="https://stackoverflow.com/questions/31931848/applicationcontext-and-servletcontext" target="_blank" rel="noopener">java - ApplicationContext and ServletContext - Stack Overflow</a></p><h1 id="使用Bean"><a href="#使用Bean" class="headerlink" title="使用Bean"></a>使用Bean</h1><p>Spring 基于 Ioc 和 DI 的方式 创建 &amp; 装配 Bean :</p><ul><li><p>控制反转(Inversion of Control): 使用者不自己创建依赖的对象, 而交由第三方(IoC容器)创建. 从IOC容器中获取（和自动注入）.而不必由用户调用 <code>new</code> 来创建 Bean 对象, 通过 IoC 则可以减少它们之间的耦合度.</p></li><li><p>依赖注入(Dependency Injection): 将依赖对象传递给使用者. 在 Spring 中, bean 的装配是依赖注入的具体行为，依赖注入的时候需要根据 bean 的名称或类型等进行装配。</p></li></ul><h2 id="创建Bean的几种方式"><a href="#创建Bean的几种方式" class="headerlink" title="创建Bean的几种方式"></a>创建Bean的几种方式</h2><h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><h4 id="①-基于-Component"><a href="#①-基于-Component" class="headerlink" title="① 基于 @Component"></a>① 基于 @Component</h4><ol><li><p>通过注解方式创建容器:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public interface ThisIsConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Configuration 来标注该接口是用于定义配置的, Spring 会视为该java文件为一个xml配置</li><li>@ComponentScan Spring 将会扫描该类所在的包下的所有 bean注解(@Component, @Service等等), 等同于在 Spring的xml里写:<br>  <code>&lt;context:component-scan base-package=&quot;com.bigdata&quot;&gt;&lt;/context:component-scan&gt;</code><br>  如果要指定要扫描的包的路径(而不是 这个类所在的包) 可以用 <code>@ComponentScan(value=&quot;包路径&quot;)</code> 指定;</li></ul></li><li>带有 <code>@Component</code>注解的类被Ioc方式创建:</li><li>通过 <code>@Autowired</code> 用 DI 方式进行装配:</li></ol><blockquote><p>关于@Component,@Service,@Controler,@Repository注解<br>这几个注解都是同样的功能，被注解的类将会被 Spring 容器创建<strong>单例</strong>对象。<br>@Component : 侧重于通用的Bean类<br>@Service：标识该类用于业务逻辑<br>@Controler：标识该类为Spring MVC的控制器类<br>@Repository: 标识该类是一个实体类，只有属性和Setter,Getter</p></blockquote><h4 id="②-基于-Bean"><a href="#②-基于-Bean" class="headerlink" title="② 基于 @Bean"></a>② 基于 @Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SwaggerSpringMvcPlugin <span class="title">customImplementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Bean</code> 注解在这里的意思是 : 该方法会返回一个 SwaggerSpringMvcPlugin 类型的 bean</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p>Component vs Bean 的区别，参考下面的 「 [[#注解(Annotation)]] 」一章</p><h3 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h3><p>① 基于构造器: 下面的类JedisPortsFactory 具有一个构造器(该构造器 有两个参数: config 和 autoFlush)<br>config 引用到了另一个bean, autoFlush 是个boolean型</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"jedisPortsFactory"</span> <span class="attr">class</span>=<span class="string">"com.bigdata.console.tools.online.JedisPortsFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"config"</span> <span class="attr">ref</span>=<span class="string">"jedisEvictionPoolConfig"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"autoFlush"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>② 基于 setter: CommonsMultipartResolver 要有<code>property</code>对应的 Setter方法</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"-1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>③ 基于静态工厂: 指定 工厂类的class, 适用于 静态工厂方法:</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jp_featurePv"</span> <span class="attr">class</span>=<span class="string">"com.bigdata.consoleJedisPortsFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getJedisMSServers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>④ 基于动态工厂: 指定 动态工厂的bean 和方法, 下面的例子中工厂方法 getJedisMSServers 有一个字符串型的参数, 适用于动态工厂方法:</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jp_featurePv"</span> <span class="attr">factory-bean</span>=<span class="string">"jedisPortsFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getJedisMSServers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="Bean的属性"><a href="#Bean的属性" class="headerlink" title="Bean的属性"></a>Bean的属性</h3><p>无论是基于@Component 还是 Xml 创建的 Bean ，属性都是通用的：</p><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><ul><li>scope=”singleton”: 单例,  Spring 在每次需要时都返回同一个bean实例</li><li>scope=”prototype”: Spring 在每次需要时都产生一个新的 bean 实例</li><li>scope=”request”</li><li>scope=”session”</li></ul><p>如果使用 @Service、@Controller … 等注解创建 Bean：</p><ul><li>@Component 注解默认实例化的对象是单例，如果想声明成多例对象可以使用@Scope(“prototype”)</li><li>@Repository 默认单例</li><li>@Service 默认单例</li><li>@Controller 默认单例</li></ul><h4 id="autowire"><a href="#autowire" class="headerlink" title="autowire"></a>autowire</h4><ul><li>autowire=”byName”: 只能用于setter注入。比如我们有方法“setHelloApi”，则“byName”方式Spring容器将查找名字为helloApi的Bean并注入</li><li>autowire=”no”: 意思是 Spring 将不自动装配这个Bean，必须明确指定依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"bean.HelloApiDecorator"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h4><p>Spring保证该Bean所依赖的其他bean已经初始化, 用<code>&lt;ref&gt;</code>元素建立对其他bean的依赖关系, Sprign 会确保创建 bean的顺序:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span> <span class="attr">class</span>=<span class="string">"helloworld.HelloImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"decorator"</span>  <span class="attr">class</span>=<span class="string">"helloworld.HelloApiDecorator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">depends-on</span>=<span class="string">"helloApi"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helloApi"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"helloApi"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h4><p>单例模式的beanA需要引用另外一个非单例模式的beanB，为了在我们每次引用的时候都能拿到最新的beanB</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"prototypeBean"</span> <span class="attr">class</span>=<span class="string">"bean.PrototypeBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span> <span class="attr">class</span>=<span class="string">"bean.SingletonBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SingletonBean.getBean()方法被代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getBean"</span> <span class="attr">bean</span>=<span class="string">"prototypeBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBean</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法, 每次获取一个新的PrototypeBean实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PrototypeBean <span class="title">getBean</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:resource/applicationContext.xml"</span>);</span><br><span class="line">SingletonBean single= (SingletonBean)app.getBean(<span class="string">"singletonBean"</span>);</span><br><span class="line">single.getBean();  <span class="comment">// 每次返回一个新的PrototypeBean</span></span><br></pre></td></tr></table></figure><h2 id="Bean的初始化-销毁回调"><a href="#Bean的初始化-销毁回调" class="headerlink" title="Bean的初始化/销毁回调"></a>Bean的初始化/销毁回调</h2><p><img src="/images/javaee/spring-bean-lifecycle.png" alt="Spring-Bean-Lifecycle"></p><h3 id="基于代码"><a href="#基于代码" class="headerlink" title="基于代码"></a>基于代码</h3><p>InitializingBean接口为bean提供了属性初始化后的处理方法，它只包括afterPropertiesSet方法，凡是继承该接口的类，在bean的属性初始化后都会执行该方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisposableBean接口为bean提供销毁方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="基于XML配置"><a href="#基于XML配置" class="headerlink" title="基于XML配置"></a>基于XML配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.dropNotes.HelloWorld"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的init-method属性和 destroy-method属性, 指定了HelloWorld类的初始化/销毁回调方法名字, 接下来在HelloWorld类中定义无参的方法即可.</p><h3 id="何时调用"><a href="#何时调用" class="headerlink" title="何时调用"></a>何时调用</h3><p>当<code>ApplicationContext.registerShutdownHook()</code>被调用时</p><h1 id="IOC-和-DI"><a href="#IOC-和-DI" class="headerlink" title="IOC 和 DI"></a>IOC 和 DI</h1><p>上面提到了 Spring 基于 Ioc 和 DI 的方式创建 &amp; 装配 Bean，总结一下 IoC 和 DI 的常用注解 :</p><ul><li>IoC 创建 Bean：@Bean、@Component、@Service、@Controller、@Repository …</li><li>DI 注入 Bean：@Autowired、@Resource …</li></ul><p>上面注解具体的区别参考下面的 「 [[#注解(Annotation)]] 」一章</p><h2 id="Spring-如何实现-IOC-和-DI"><a href="#Spring-如何实现-IOC-和-DI" class="headerlink" title="Spring 如何实现 IOC 和 DI"></a>Spring 如何实现 IOC 和 DI</h2><p>创建 bean（IoC），以 XML 方式为例，伪码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//解析&lt;bean .../&gt;元素的 id 属性得到该字符串值为“courseDao”  </span><br><span class="line">String idStr = &quot;courseDao&quot;; </span><br><span class="line"> </span><br><span class="line">//解析&lt;bean .../&gt;元素的class属性得到该字符串“com.xx.Dao.impl.CourseDaoImpl”  </span><br><span class="line">String classStr = &quot;com.xx.Dao.impl.CourseDaoImpl&quot;;  </span><br><span class="line"></span><br><span class="line">//利用反射创建对象  </span><br><span class="line">Class&lt;?&gt; cls = Class.forName(classStr);  </span><br><span class="line">Object obj = cls.newInstance();  </span><br><span class="line"></span><br><span class="line">//放入Spring容器保存</span><br><span class="line">container.put(idStr, obj);</span><br></pre></td></tr></table></figure><p>构造器注入（DI）实现的伪码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射获取当前类所有的构造方法信息（Constructor 对象）</span><br><span class="line">Constructor&lt;?&gt;[] candidates = beanClass.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">// 设置构造方法参数实例</span><br><span class="line">Object[] argsToUse = new Object[parameterTypes.length];</span><br><span class="line">argsToUse[i] = getBean(beanNames.get(i));</span><br><span class="line"></span><br><span class="line">// 使用带有参数的 Constructor 对象实现实例化 Bean</span><br><span class="line">return constructorToUse.newInstance(argsToUse);</span><br></pre></td></tr></table></figure><p>Autowired 注入（DI）实现的伪码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射得到当前类所有的字段信息（Field 对象）</span><br><span class="line">Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line"></span><br><span class="line">// 判断字段是否有 @Autowired 注解</span><br><span class="line">Annotation ann = field.getAnnotation(Autowired.class);</span><br><span class="line"></span><br><span class="line">// 设置字段可连接，相当于将非 public（private、default、protect）更改为 public field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 通过反射设置字段的值</span><br><span class="line">field.set(bean, getBean(field.getName()));</span><br></pre></td></tr></table></figure><p>@ref: <a href="https://juejin.cn/post/6844904148316471310#heading-1" target="_blank" rel="noopener">Spring 中的反射与反射的原理 - 掘金</a></p><h1 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h1><p>AOP(Aspect Oriented Program) ，<strong>面向切面编程</strong>:<br>主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p><h2 id="AOP的一些概念"><a href="#AOP的一些概念" class="headerlink" title="AOP的一些概念"></a>AOP的一些概念</h2><p><img src="/images/javaee/javaee_spring_mvc_aop.png" alt=""></p><ul><li>连接点（Jointpoint）连接点是能够插入切面的一个点，连接点可能是类初始化，可以是调某方法时，抛出异常时，修改某字段时</li><li>切入点（Pointcut）：一组连接点集合</li><li>通知（Advice）：定义在连接点上“要做什么”，以及“何时去做”<ul><li>包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice）</li></ul></li><li>切面（Aspect）：可以认为是”通知”和”切入点”的集合</li></ul><ul><li>目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁做”；</li><li>AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</li><li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</li><li>引入（inter-type declaration）：为已有的类添加额外新的字段或方法，Spring 允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在 AOP 中表示为“做什么”；</li></ul><h2 id="基于XML配置aspect"><a href="#基于XML配置aspect" class="headerlink" title="基于XML配置aspect"></a>基于XML配置aspect</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义了一个id="pointcut"的切点, 范围是com.javass包下的所有类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义切面的集合, ref="aspect"表示要引入"aspect"这个bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个切点, 包括用哪些切点, 以及在切点处要插入aspect.beforeAdvice()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"beforeAdvice"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义另一个切点, 在切点处要插入aspect.afterFinallyAdvice()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span> <span class="attr">method</span>=<span class="string">"afterFinallyAdvice"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于注解配置aspect"><a href="#基于注解配置aspect" class="headerlink" title="基于注解配置aspect"></a>基于注解配置aspect</h2><p>下面的代码定义一个切面(@Aspect): 哪里切入(@Pointcut), 切入的行为(@Advice)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerLogAspect</span> </span>&#123; <span class="comment">//定义了一个切面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点"logPointCut", 在哪些类里切入</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.xxx.*.controller..*.*(..)) &amp;&amp; "</span> +</span><br><span class="line">            <span class="string">"!execution(public * com.xxx.*.controller..CheckController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advice</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知, 在切点"logPointCut"之前</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"ret"</span>, pointcut = <span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-如何实现-AOP"><a href="#Spring-如何实现-AOP" class="headerlink" title="Spring 如何实现 AOP"></a>Spring 如何实现 AOP</h2><p>Spring 通过 <strong>jdk 动态代理</strong>和 <strong>cglib 动态代理</strong>实现 AOP.</p><p>Spring 的 AOP 是通过 Java 语言提供的 <strong>代理(Proxy)模式</strong> 实现的, Java 语言的代理包括如下 2种方式: JDK 动态代理, Cglib 动态代理. 实现过程参考 @link [[../12.Java/Java-Tutorials.14.代理]]</p><blockquote><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib ，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：</p></blockquote><p><img src="/images/JavaEE.SpringMVC-2023-05-08-1.png" alt="../_images/JavaEE.SpringMVC-2023-05-08-1.png"></p><h2 id="Spring-AOP-vs-AspectJ"><a href="#Spring-AOP-vs-AspectJ" class="headerlink" title="Spring AOP vs AspectJ"></a>Spring AOP vs AspectJ</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><blockquote><p>Servlet 规范、Servlet 容器、Spring 实现的 DispatcherServlet 关系，参考 <a href="/13.JavaEE-Framework/JavaEE.Tomcat/" title="JavaEE.Tomcat">JavaEE.Tomcat</a> 第一节</p></blockquote><p>要使用Spring MVC只需要在web.xml(Java Servlet 规范里Java Web项目的部署描述符文件)里增加一个Servlet:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:appcontext-core-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet-工作流程"><a href="#DispatcherServlet-工作流程" class="headerlink" title="DispatcherServlet 工作流程"></a>DispatcherServlet 工作流程</h2><p>DispatcherServlet处理一次 Req 的流程，伪码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">（1）Request → DispatcherServlet</span><br><span class="line"></span><br><span class="line">（2）DispatcherServlet 从 HandleMapping[] 查找匹配, 返回 HandlerExecutionChain &#123; HandlerInterceptor1,HandleInterceptor2..&#125;</span><br><span class="line"></span><br><span class="line">（3）HandleInterceptor → HandleAdaptor → Controller</span><br><span class="line"></span><br><span class="line">（4）Controller 返回 ModelAndView → ViewResolver</span><br><span class="line"></span><br><span class="line">（5）View</span><br></pre></td></tr></table></figure></p><ul><li><p>对于 Spring MVC 程序来说, 首先调用的是 <code>DispatcherServlet.service(ServletRequest, ServletResponse)</code>, 实现是在 <code>HttpServlet.service(ServletRequest req, ServletResponse resp)</code>, 这个方法里把 ServletRequest 对象转换为 HttpServletRequest, 在这个方法里又调用进了 <code>FrameworkServlet.service(HttpServletRequest req, HttpServletResponse resp)</code>, 在这个方法里如果 <code>method!=PATCH</code> 则调用进 <code>super.service(HttpServletRequest, HttpServletResponse)</code>, 也就是 <code>HttpServletservice(HttpServletRequest, HttpServletResponse)</code>, 这里根据不同的 method 调用不同的 <code>doX()</code> 方法</p></li><li><p>以 GET 方法为例，调用 <code>this.doGet()</code>, 因为在 <code>FrameworkServlet</code> 重写了 <code>doGet()</code>, 所以这里调用的代码是 <code>FrameworkServlet.doGet()</code>,  在这个方法里调用了<code>FrameworkServlet.processRequest()</code>, 然后又调用了<code>this.doService()</code>,</p></li><li><code>DispatcherServlet</code> 重写了 <code>doService()</code>, 所以最终调用到 <code>DispatcherServlet.doService()</code>, 该方法逻辑大致如下:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void doDispatch(HttpServletRequest request, HttpServletResponse response)  &#123;</span><br><span class="line">    HandlerExecutionChain mappedHandler = getHandler(processedRequest);</span><br><span class="line">    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>getHandler()</code>主要就是通过<code>this.handlerMappings</code>中的HandlerMapping实例来对具体request映射一个handler（Spring MVC中的Controller类） ;</li><li>如果看过<code>this.handlerMappings</code>的初始化，便知道HandlerMapping的具体实现有3个：<ul><li>RequestMappingHandlerMapping : 用来映射Controller和URL</li><li>BeanNameUrlHandlerMapping</li><li>SimpleUrlHandlerMapping</li></ul></li><li>……</li><li>……</li></ol><hr><p><img src="/images/javaee/javaee_spring_mvc_dispacher.png" alt="DispatcherServlet 工作流程"><br>上图中组件处理顺序分别是:</p><ul><li>Dispatcher Servlet分发器</li><li>Handler Mapping 处理器映射</li><li>Controller 控制器</li><li>ModelAndView 模型和视图对象</li><li>ViewResolver 视图解析器</li></ul><blockquote><p>@ref <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484846&amp;idx=1&amp;sn=490014ea65669c1a1e73e25d7b9fa569" target="_blank" rel="noopener">SpringMVC 工作原理详解</a></p></blockquote><h1 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器(Interceptor)"></a>拦截器(Interceptor)</h1><p>处理器映射处理过程配置的拦截器，必须实现 org.springframework.web.servlet包下的 <code>HandlerInterceptor</code>接口。<br>这个接口定义了三个方法：<br><code>preHandle(..)</code>，它在处理器实际执行 之前 会被执行；<br><code>postHandle(..)</code>，它在处理器执行 完毕 以后被执行；<br><code>afterCompletion(..)</code>，它在 整个请求处理完成 之后被执行。</p><h2 id="通过xml定义拦截器"><a href="#通过xml定义拦截器" class="headerlink" title="通过xml定义拦截器"></a>通过xml定义拦截器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"officeHoursInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"officeHoursInterceptor"</span> <span class="attr">class</span>=<span class="string">"samples.TimeBasedAccessInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"openingTime"</span> <span class="attr">value</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"closingTime"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过注解定义拦截器"><a href="#通过注解定义拦截器" class="headerlink" title="通过注解定义拦截器"></a>通过注解定义拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LocaleInterceptor());</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> ThemeInterceptor()).addPathPatterns(<span class="string">"/**"</span>).excludePathPatterns(<span class="string">"/admin/**"</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SecurityInterceptor()).addPathPatterns(<span class="string">"/secure/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器(Controller)"></a>控制器(Controller)</h1><h2 id="传入类型"><a href="#传入类型" class="headerlink" title="传入类型"></a>传入类型</h2><ul><li>@RequestParam注解: <code>@RequestParam(value = &quot;client_id&quot;) String appId</code></li><li>Model类型: 这种通常返回String类型的view路径</li><li>HttpServletResponse:</li><li>HttpServletRequest:</li></ul><h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><ul><li>返回ModelAndView: 返回视图<code>return new ModelView(&quot;/view/111&quot;, map)</code><ul><li>通过ModelAndView也可以重定向: <code>return new ModelAndView(&quot;redirect:/controller2&quot;);</code></li><li>如果modelView是以参数传入的: <code>model.setViewName(&quot;forward:index.jsp&quot;); return model;</code></li></ul></li><li>返回RedirectView: 专门用来处理转发的视图, 见后面的代码.</li><li>返回String: 返回字符串可以指定逻辑视图名, 通过视图解析器解析为物理视图地址<ul><li>通过String也可以重定向: <code>return &quot;redirect:/resource/page2.jsp&quot;;</code></li><li>如果Controller带有<code>@ResponseBody</code>注解, 可以直接返回String字面值;</li></ul></li><li>以json返回对象: 借助<code>@ResponseBody</code>注解, 项目导入Jackson.jar, 并且在Spring配置文件启用了<code>&lt;mvc:annotation-driven /&gt;</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li><li>返回Map:<ul><li>借助<code>@ResponseBody</code>注解, <code>return new HashMap&lt;&gt;();</code>会返回一个json</li><li>没有<code>@ResponseBody</code>注解, <code>map.put(&quot;key1&quot;, &quot;value-1&quot;); return map;</code>, 在jsp页面中可直通过<code>${key1}</code>获得到值</li></ul></li><li>返回void: 需要通过形参传入request和response<ul><li>使用request转向页面: <code>request.getRequestDispatcher(&quot;index.html&quot;).forward(request, response);</code></li><li>通过response页面重定向: <code>response.sendRedirect(&quot;http://www.xxx.com&quot;);</code></li><li>forward和Redirect的区别: forward是由Servlet直接转给另一个Controller处理, Redirect相当于302, 返回给浏览器, 然后浏览器再发一次新的请求到Controller2</li><li>通过response指定响应结果:<ul><li>返回json: <code>response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;this_is_json&quot;);</code></li><li>返回Html: <code>response.getWriter().println(&quot;&lt;title&gt;HelloWorld&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</code></li></ul></li></ul></li></ul><h3 id="用RedirectAttributes带参跳转"><a href="#用RedirectAttributes带参跳转" class="headerlink" title="用RedirectAttributes带参跳转:"></a>用RedirectAttributes带参跳转:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">hello</span><span class="params">(RedirectAttributes attrs)</span> </span>&#123;</span><br><span class="line">    attrs.addAttribute(<span class="string">"message"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    attrs.addFlashAttribute(<span class="string">"username"</span>, <span class="string">"sudoz"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">hello</span><span class="params">(@ModelAttribute(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">                              @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">    map.put(<span class="string">"username"</span>, username);</span><br><span class="line">    map.put(<span class="string">"message"</span>, message);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> mvc:annotation-driven是一种简写形式，完全可以手动配置替代这种简写形式，<code>&lt;mvc:annotation-driven /&gt;</code>会自动注册<code>DefaultAnnotationHandlerMapping</code>与<code>AnnotationMethodHandlerAdapter</code> 两个bean,是Spring MVC为<code>@Controllers</code>分发请求所必须的。<br>并提供了：数据绑定支持，<code>@NumberFormatannotation</code>支持，<code>@DateTimeFormat</code>支持，<code>@Valid支持</code>，读写XML的支持（JAXB），读写JSON的支持（Jackson）。</p><h3 id="Spring是如何处理返回类型的"><a href="#Spring是如何处理返回类型的" class="headerlink" title="Spring是如何处理返回类型的?"></a>Spring是如何处理返回类型的?</h3><p>DispatchServlet.viewResolvers的类型是<code>List&lt;ViewResolver&gt;</code>, Controller返回的类型转给DispatchServlet, 最终交给不同的ViewResolver处理的</p><h1 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h1><p>所有web应用的MVC框架都提供了视图相关的支持。Spring提供了一些视图解析器，它们让你能够在浏览器中渲染模型，并支持你自由选用适合的视图技术而不必与框架绑定到一起。<br>Spring原生支持JSP视图技术、Velocity模板技术和XSLT视图等。</p><p>有两个接口在Spring处理视图相关事宜时至关重要，分别是视图解析器接口ViewResolver和视图接口本身View。<br>视图解析器ViewResolver负责处理视图名与实际视图之间的映射关系。<br>视图接口View负责准备请求，并将请求的渲染交给某种具体的视图技术实现。</p><h2 id="使用ViewResolver接口解析视图"><a href="#使用ViewResolver接口解析视图" class="headerlink" title="使用ViewResolver接口解析视图"></a>使用ViewResolver接口解析视图</h2><p>Spring MVC中所有控制器的处理器方法都必须返回一个逻辑视图的名字，无论是显式返回（比如返回一个String、View或者ModelAndView）还是隐式返回（比如基于约定的返回）。<br>Spring中的视图由一个视图名标识，并由视图解析器来渲染。Spring有非常多内置的视图解析器。</p><h1 id="资源-Resource"><a href="#资源-Resource" class="headerlink" title="资源(Resource)"></a>资源(Resource)</h1><h2 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h2><p>Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。</p><p>路径通配符</p><ul><li><code>?</code>匹配一个字符，如<code>config?.xml</code>将匹配<code>config1.xml</code></li><li><code>*</code>匹配零个或多个字符串，如<code>cn/*/config.xml</code>将匹配<code>cn/javass/config.xml</code>，但不匹配匹配<code>cn/config.xml</code></li><li><code>**</code>匹配路径中的零个或多个目录，如<code>cn/**/config.xml</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Resource例子1:</span></span><br><span class="line">ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//只加载一个绝对匹配Resource，且通过ResourceLoader.getResource进行加载</span></span><br><span class="line">Resource[] resources=resolver.getResources(<span class="string">"classpath:META-INF/INDEX.LIST"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Resource例子2:</span></span><br><span class="line">ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//将加载多个绝对匹配的所有Resource</span></span><br><span class="line"><span class="comment">//将首先通过ClassLoader.getResources("META-INF")加载非模式路径部分</span></span><br><span class="line"><span class="comment">//然后进行遍历模式匹配</span></span><br><span class="line"><span class="comment">// classpath*： 用于加载类路径（包括jar包）中的所有匹配的资源</span></span><br><span class="line">Resource[] resources=resolver.getResources(<span class="string">"classpath*:META-INF/INDEX.LIST"</span>);</span><br></pre></td></tr></table></figure><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>静态资源包括：HTML、CSS、JS、图像、视频、PDF/Office等不需要服务器端处理的文件。</p><p>静态资源文件的位置:</p><ul><li>Java Web默认的静态资源文件夹是 src/main/webapp/</li><li>Spring Boot自动将src/main/resource/下的「/static」「/public」「/resources」「/META-INF/resources」识别为资源文件夹。 下面的css可以通过访问<code>http://localhost:8080/css/a.css</code>获取<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project Root</span><br><span class="line">└─src</span><br><span class="line">    └─ main</span><br><span class="line">        └─ resources</span><br><span class="line">            ├─ static</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ a.css</span><br><span class="line">            ├─ public</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ b.css</span><br><span class="line">            ├─ resources</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ b.css</span><br><span class="line">            └─ META-INF</span><br><span class="line">                └─ resources</span><br><span class="line">                    └─ css</span><br><span class="line">                        └─ d.css</span><br></pre></td></tr></table></figure></li></ul><h1 id="异常处理-Exception"><a href="#异常处理-Exception" class="headerlink" title="异常处理(Exception)"></a>异常处理(Exception)</h1><ol><li>Controller的匹配. 除了<code>value</code>指定url, 还可以通过<code>product</code>指定MIME-TYPE(参考网络协议HTTP)</li><li>调试的时候需要注意, <code>cURL</code>实际是使用了<code>Accept: */*</code>, 浏览器发出的请求是<code>Accept:text/html</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/return-text-plain"</span>, produces = MimeTypeUtils.TEXT_PLAIN_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">returnPlainText</span><span class="params">()</span> <span class="keyword">throws</span> SomeException </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> SomeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How to自定义Error页面:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDefaultErrorViewConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ThymeleafViewResolver thymeleafViewResolver;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> View <span class="title">error</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thymeleafViewResolver.resolveViewName(<span class="string">"custom-error-page/error"</span>, Locale.CHINA);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h1><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="IOC-注解-Service-Controller-Repository-Component-Bean"><a href="#IOC-注解-Service-Controller-Repository-Component-Bean" class="headerlink" title="IOC 注解: @Service, @Controller, @Repository, @Component, @Bean"></a>IOC 注解: @Service, @Controller, @Repository, @Component, @Bean</h3><ul><li>@Service: 用于注解Service层, 默认是单例的</li><li>@Controller: 定义控制器类一般这个注解在类中，通常方法需要配合注解 @RequestMapping</li><li>@RestController相当于<code>@ResponseBody</code>和<code>@Controller</code>的合集, 默认是单例的</li><li>@Repository用于注解DAO，这个注解修饰的DAO类会被ComponetScan发现并配置，同时也不需要为它们提供xml配置项</li><li>如果一个类不好归类, 则使用 <code>@Component</code> 注解</li><li><p>The default scope for the bean is <strong>a singleton</strong></p></li><li><p>@Bean: 区别与上面的注解，@Component 注解作用于类，而 @Bean 注解作用于方法, 该方法必须返回一个类型对象, 该对象被注册为 Spring 上下文中的 bean, 注意方法名字将会作为 bean 的 ID, 相当于在 xml 中定义 <code>&lt;bean&gt;</code></p><ul><li>@Bean(initMethod=”aa”,destroyMethod=”bb”): 指定 aa 和 bb 方法分别在在构造之后/销毁之前执行</li></ul></li></ul><blockquote><p>Spring 会自动扫描 <code>base-package</code> 指定的包下面用 <code>@Service</code> 注解的所有类, 并注册到 beans 容器里.<br>需要在 Spring 配置文件里增加: <code>&lt;context:component-scan base-package=&quot;com.xxx.product.core.service&quot;/&gt;</code> 来说明启用自动扫描</p></blockquote><h3 id="DI-注解-Autowired-Resource-Inject-Primary"><a href="#DI-注解-Autowired-Resource-Inject-Primary" class="headerlink" title="DI 注解: @Autowired, @Resource, @Inject, @Primary"></a>DI 注解: @Autowired, @Resource, @Inject, @Primary</h3><ul><li>@Autowired: 可以写在属性上, 和 setter 方法上, 或者构造函数上, 默认按照类型进行装配</li><li>@Autowired 和@Inject: 通过 <code>AutowiredAnnotationBeanPostProcessor</code> 来实现依赖注入, 顺序:<ol><li>按照类型匹配</li><li>使用限定符进行类型限定</li><li>按照名称匹配</li></ol></li><li>@Resource: 使用 <code>CommonAnnotationBeanPostProcessor</code> 来实现注入, 顺序:<ol><li>按照名称匹配</li><li>按照类型匹配</li><li>使用限定符进行类型限定</li></ol></li></ul><p>➤ 区别二者：</p><ul><li>@Resource 并不是 Spring 的注解，它的包是 javax.annotation.Resource， Spring 也支持该注解的注入；</li><li>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter 方法；</li></ul><h3 id="ComponentScan-amp-Component"><a href="#ComponentScan-amp-Component" class="headerlink" title="@ComponentScan &amp; @Component"></a>@ComponentScan &amp; @Component</h3><ul><li>@Component: 使用在类上, 表示可以被 <code>@ComponentScan</code> 标注的类扫描到</li><li>@ComponentScan: 使用在类上, 可以扫描到 <code>@Component</code> 注解的类</li></ul><blockquote><p>比较: <code>@Configuration</code> + <code>@Bean</code> 的方式需要在@Configuration 的类里定义”返回每种 Bean 类型的方法”, <code>@ComponentScan</code> + <code>@Component</code> 的方式省去了定义方法返回 Bean 的类型<br><code>@Configuration</code>, <code>@ComponentScan</code>, <code>@Component</code> 注解通常联合起来使用, 免去了在 xml 里定义 bean, 也不必写 <code>@Bean</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123; <span class="keyword">this</span>.cd = cd; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扫描到的Bean:</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContextConfiguration-amp-Configuration"><a href="#ContextConfiguration-amp-Configuration" class="headerlink" title="@ContextConfiguration &amp; @Configuration"></a>@ContextConfiguration &amp; @Configuration</h3><ul><li>@Configuration: 用于类上, 说明这个类可以使用 Spring IoC 容器作为 bean 定义的来源, 相当于在 xml 中定义 <code>&lt;beans&gt;</code></li><li>@ContextConfiguration(classes=KnightConfig.class) 使用在类上, 表示使用 <code>@Configuration</code> 标注的类当作 bean 的定义来源</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditorConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TextEditor <span class="title">textEditor</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TextEditor( spellChecker() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">spellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SpellChecker( );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的等同于在xml里定义了两个&lt;bean&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用从@Configuration标注类里注入的bean</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=KnightConfig.class,loader=AnnotationConfigContextLoader.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  TextEditor textEditor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpellChecker spellChecker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transcational-Cacheable"><a href="#Transcational-Cacheable" class="headerlink" title="@Transcational, @Cacheable"></a>@Transcational, @Cacheable</h3><ul><li>@Transcational : 事务处理</li><li>@Cacheable : 数据缓存</li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>默认是<code>@Scope(&quot;singleton&quot;)</code>单例的, 此外还有:</p><ul><li><code>singleton</code> 单例的</li><li><code>prototype</code> 表示每次获得bean都会生成一个新的对象</li><li><code>request</code> 表示在一次http请求内有效</li><li><code>session</code> 表示在一个用户会话内有效</li></ul><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"ImplementedClass"</span>)</span><br><span class="line">    <span class="keyword">private</span> AbstractClass a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当抽象类AbstractClass的实现类有多个时, 如果没有<code>Qualifier</code>注解则会报错, 因为Spring不知道应该注入哪个类型, 注意<code>@Qualifier()</code>括号里是类的名字</p><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h3><ul><li>@After @Before. @Around 定义切面,可以直接将拦截规则(切入点 PointCut)作为参数</li><li>@PointCut : 专门定义拦截规则 然后在 @After @Before. @Around 中调用</li><li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li></ul><h2 id="JDK注解"><a href="#JDK注解" class="headerlink" title="JDK注解"></a>JDK注解</h2><ul><li>@Resource: 可以写在属性上, 和setter方法上, 默认按照名称进行装配</li></ul><h1 id="Spring中的线程安全性"><a href="#Spring中的线程安全性" class="headerlink" title="Spring中的线程安全性"></a>Spring中的线程安全性</h1><blockquote><p>本节参考： <a href="https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/" target="_blank" rel="noopener">聊一聊Spring中的线程安全性 | SylvanasSun’s Blog</a></p></blockquote><p>Spring 作为一个 IOC/DI 容器，帮助我们管理了许许多多的“bean”。但其实，Spring 并没有保证这些对象的线程安全，需要由开发者自己编写解决线程安全问题的代码。</p><p>Spring对每个bean提供了一个<code>scope</code>属性来表示该bean的作用域。它是bean的生命周期。例如，一个<code>scope</code>为<code>singleton</code>的bean，在第一次被注入时，会创建为一个单例对象，该对象会一直被复用到应用结束。</p><blockquote><p>singleton：默认的scope，每个scope为singleton的bean都会被定义为一个单例对象，该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。<br>prototype：bean被定义为在每次注入时都会创建一个新的对象。<br>request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。<br>session：bean被定义为在一个session的生命周期内创建一个单例对象。<br>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。<br>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。</p></blockquote><p>我们交由Spring管理的大多数对象其实都是一些<strong>无状态的对象</strong>，这种不会因为多线程而导致状态被破坏的对象很适合Spring的默认scope，每个单例的无状态对象都是线程安全的（也可以说只要是无状态的对象，不管单例多例都是线程安全的，不过单例毕竟节省了不断创建对象与GC的开销）。</p><p><strong>无状态的对象</strong>即是自身没有状态的对象，自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题。无状态对象包括我们经常使用的DO、DTO、VO这些只作为数据的实体模型的贫血对象，还有Service、DAO和Controller，这些对象并没有自己的状态，它们只是用来执行某些操作的。例如，每个DAO提供的函数都只是对数据库的CRUD，而且每个数据库Connection都作为函数的局部变量（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题），用完即关（或交还给连接池）。</p><p>有人可能会认为，我使用 <code>scope=request</code> 作用域不就可以避免每个请求之间的安全问题了吗？这是完全错误的，因为 Controller 默认是单例的，一个 HTTP 请求是会被多个线程执行的，这就又回到了线程的安全问题。当然，你也可以把 Controller 的 scope 改成 prototype，实际上 Struts2就是这么做的，但有一点要注意，Spring MVC 对请求的拦截粒度是基于每个方法的，而 Struts2是基于每个类的，所以把 Controller 设为多例将会频繁的创建与回收对象，严重影响到了性能。</p><p>通过阅读上文其实已经说的很清楚了，Spring 根本就没有对 bean 的多线程安全问题做出任何保证与措施。对于每个 bean 的线程安全问题，根本原因是每个 bean 自身的设计。不要在 bean 中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用 <code>ThreadLocal</code> 把变量变为线程私有的，如果 bean 的实例变量或类变量需要在多个线程之间共享，那么就只能使用 <code>synchronized</code>、<code>lock</code>、<code>CAS</code> 等这些实现线程同步的方法了。ThreadLocal @link [[../12.Java/Java-Tutorials.07a2.ThreadLocal]] &amp; Servlet 规范的线程安全  @link [[JavaEE.Servlet#线程不安全]]</p><blockquote><p>本文作者为 <a href="https://github.com/SylvanasSun" target="_blank" rel="noopener">SylvanasSun(sylvanas.sun@gmail.com)</a>，首发于 <a href="https://sylvanassun.github.io/" target="_blank" rel="noopener">SylvanasSun’s Blog</a>。<br>原文链接：<a href="https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/" target="_blank" rel="noopener">https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/</a><br>（转载请务必保留本段声明，并且保留超链接。）</p></blockquote><h1 id="对“约定优于配置”的支持"><a href="#对“约定优于配置”的支持" class="headerlink" title="对“约定优于配置”的支持"></a>对“约定优于配置”的支持</h1><blockquote><p>约定优于配置（convention over configuration)，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。<br>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。<br>许多新的框架使用了约定优于配置的方法，包括：Spring，Ruby on Rails，Kohana PHP，Grails，Grok，Zend Framework，CakePHP，symfony，Maven，ASP.NET MVC，Web2py（MVC），Apache Wicket。<br>比如Maven对目录做了”约定优于配置”的设定:</p><blockquote><p>   src/main/resources: 资源文件目录;<br>   src/main/java: Java源码目录;<br>   src/main/webapp: web应用文件目录（当打包为war时），如WEB-INF/web.xml</p></blockquote></blockquote><h1 id="对JDBC的支持"><a href="#对JDBC的支持" class="headerlink" title="对JDBC的支持"></a>对JDBC的支持</h1><p>Spring主要提供JDBC模板方式、关系数据库对象化方式和SimpleJdbc方式三种方式来简化JDBC编程，这三种方式就是Spring JDBC的工作模式：</p><ul><li>JDBC模板方式：Spring JDBC框架提供以下几种模板类来简化JDBC编程，实现GoF模板设计模式，将可变部分和非可变部分分离，可变部分采用回调接口方式由用户来实现：如JdbcTemplate、NamedParameterJdbcTemplate、SimpleJdbcTemplate。</li><li>关系数据库操作对象化方式：Spring JDBC框架提供了将关系数据库操作对象化的表示形式，从而使用户可以采用面向对象编程来完成对数据库的访问；如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类。这些类的实现一旦建立即可重用并且是线程安全的。</li></ul><h2 id="JDBC模板"><a href="#JDBC模板" class="headerlink" title="JDBC模板"></a>JDBC模板</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;</span><br><span class="line">        jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                String value = rs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Column TABLENAME:"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert into test(name) values('name1')"</span>);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"delete from test where name=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">"name2"</span>&#125;);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update test set name='name3' where name=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">"name1"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关系数据库对象化"><a href="#关系数据库对象化" class="headerlink" title="关系数据库对象化"></a>关系数据库对象化</h2><h1 id="对MyBatis的支持"><a href="#对MyBatis的支持" class="headerlink" title="对MyBatis的支持"></a>对MyBatis的支持</h1><p>参考<a href="http://www.mybatis.org/spring/zh/getting-started.html" target="_blank" rel="noopener">mybatis-spring – MyBatis-Spring | 第二章 入门</a> @ref</p><h2 id="1-引入mybatis-spring依赖"><a href="#1-引入mybatis-spring依赖" class="headerlink" title="1. 引入mybatis-spring依赖"></a>1. 引入mybatis-spring依赖</h2><p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-SqlSessionFactoryBean-amp-Mapper"><a href="#2-SqlSessionFactoryBean-amp-Mapper" class="headerlink" title="2. SqlSessionFactoryBean &amp; Mapper"></a>2. SqlSessionFactoryBean &amp; Mapper</h2><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory</code> 和至少一个数据映射器。</p><ul><li><p>增加 sqlSessionFactory 的 bean，注意  sqlSessionFactory 还需要一个数据源（DataSource），下面的例子用了 DruidDataSource</p></li><li><p>这里使用了 <code>MapperScannerConfigurer</code>, 它将会查找类路径下的映射器并自动将它们创建成 MapperFactoryBean</p></li><li><p>（可选）增加 <code>transactionManager</code> 的 bean, 开启 Spring 事务</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 要注意 SqlSessionFactory 需要一个 dataSource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/**/*.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义注解驱动事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置扫描包，加载mapper代理对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.kuaizhan.kzweixin.dao.mapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="对Transaction的支持"><a href="#对Transaction的支持" class="headerlink" title="对Transaction的支持"></a>对Transaction的支持</h1><ul><li><code>@Transactional(value=&quot;transactionManagerPrimary&quot;, isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED)</code><ul><li>value: 事务管理器</li><li>隔离级别（isolation）:<ul><li>DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。</li><li>READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li><li>READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的<strong>推荐值</strong>。</li><li>REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li><li>SERIALIZABLE：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul></li><li>传播行为（Propagation）:所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。<ul><li>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>这是最常见的选择。</strong></li><li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。</li></ul></li></ul></li></ul><h1 id="Spring-MVC-Step-by-Step-Deprecated"><a href="#Spring-MVC-Step-by-Step-Deprecated" class="headerlink" title="Spring MVC Step by Step @Deprecated"></a>Spring MVC Step by Step @Deprecated</h1><ol><li>Pom.xml<ul><li>build - resources # 定义资源文件?</li></ul></li><li>webapp/WEB-INF/web.xml<ul><li>context-param: contextConfigLocation=classpath<em>:spring/appcontext-</em>.xml # 指定<code>Spring配置</code>路径</li><li>listener:  # listen优先级&gt;Servlet<ul><li>ContextLoaderListener=org.springframework.web.context.ContextLoaderListener</li><li>RequestContextListener=org.springframework.web.context.request.RequestContextListener</li></ul></li><li>servlet: org.springframework.web.servlet.DispatcherServlet<ul><li>init-param: contextConfigLocation=classpath:appcontext-core-web.xml # 指定<code>Servlet配置</code>路径</li></ul></li></ul></li><li>Spring配置xml: 默认去找classpath下的application-Context.xml,这是一种约定优于配置的概念<ul><li>context:property-placeholder: 指定<code>*.properties</code>位置</li><li>mvc:interceptors // 定义拦截器</li><li>mvc:annotation-driven // 注册DefaultAnnotationHandlerMapping/AnnotationMethodHandlerAdapter, 用于支持@Controller等注解风格</li><li>mvc:resources # css/js/htm等静态资源映射</li><li>增加View解析器:<ul><li>bean id=”velocityConfigurer” class=”org.springframework.web.servlet.view.velocity.VelocityConfigurer”</li><li>bean id=”viewResolver” class=”org.springframework.web.servlet.view.velocity.VelocityViewResolver”</li></ul></li><li>增加多数据源<ul><li>bean id=”parentDataSource” class=”org.springframework.jdbc.datasource.DriverManagerDataSource”</li><li>bean id=”adminDataSource” parent=”parentDataSource” # 数据源1</li><li>bean id=”userDataSource”  parent=”parentDataSource” # 数据源2</li><li>bean id=”dataSource” class=”com.frogking.datasource.DynamicDataSource” # 多数源映射关系, property增加上面两个bean</li><li>bean id=”sessionFactory” class=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</li></ul></li></ul></li></ol><h1 id="附-Configuration-XML说明"><a href="#附-Configuration-XML说明" class="headerlink" title="附: Configuration XML说明"></a>附: Configuration XML说明</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring/appcontext-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span> <span class="attr">id</span>=<span class="string">"ContextLoaderListener"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span> <span class="attr">id</span>=<span class="string">"RequestContextListener"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/2/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:appcontext-core-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>400<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-Framework-框架图&quot;&gt;&lt;a href=&quot;#Spring-Framework-框架图&quot; class=&quot;headerlink&quot; title=&quot;Spring Framework 框架图&quot;&gt;&lt;/a&gt;Spring Framework 框架图&lt;/h1&gt;&lt;p&gt;下图是 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.0.0.RC2/spring-framework-reference/overview.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 官网&lt;/a&gt;的一个架构图，介绍下其组成部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Spring-Framework-Runtime.png&quot; alt=&quot;../_images/Spring-Framework-Runtime.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心容器&quot;&gt;&lt;a href=&quot;#核心容器&quot; class=&quot;headerlink&quot; title=&quot;核心容器&quot;&gt;&lt;/a&gt;核心容器&lt;/h2&gt;&lt;p&gt;由spring-core、spring-beans、spring-context、spring-context-support和spring-expression模块组成：&lt;/p&gt;</summary>
    
    
    
    <category term="13.J2EE" scheme="https://beefyheisenberg.github.io/categories/13-J2EE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Spring MVC" scheme="https://beefyheisenberg.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringBoot/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringBoot/</id>
    <published>2023-05-09T04:45:01.084Z</published>
    <updated>2023-05-09T04:45:01.085Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://sdtimes.com/wp-content/uploads/2018/03/spring-boot-490x257.png" alt="Spring Boot"></p><h1 id="Spring-Boot-vs-Spring"><a href="#Spring-Boot-vs-Spring" class="headerlink" title="Spring Boot vs Spring"></a>Spring Boot vs Spring</h1><ul><li>内置了嵌入式的Tomcat、Jetty等Servlet容器，应用可以不用打包成War格式，而是可以直接以Jar格式运行</li><li>Spring Boot提倡无XML配置文件的理念，使用Spring Boot生成的应用完全不会生成任何配置代码与XML配置文件。</li><li>提供了多个可选择的「starter」:<ul><li>spring-boot-starter-data-redis:</li><li>spring-boot-starter-activemq:</li><li>spring-boot-starter-jdbc:</li><li>spring-boot-starter-web:</li><li>spring-boot-starter-actuator:</li></ul></li></ul><h1 id="Spring-Boot-全家桶"><a href="#Spring-Boot-全家桶" class="headerlink" title="Spring Boot 全家桶"></a>Spring Boot 全家桶</h1><p><img src="/images/JavaEE.springboot-bucket.png" alt="../_images/JavaEE.springboot-bucket.png"></p><p>@ref: <a href="https://gitee.com/yidao620/springboot-bucket" target="_blank" rel="noopener">https://gitee.com/yidao620/springboot-bucket</a></p><h1 id="Spring-Boot-的新注解"><a href="#Spring-Boot-的新注解" class="headerlink" title="Spring Boot 的新注解"></a>Spring Boot 的新注解</h1><ul><li><code>@SpringBootApplication</code>: 相当于 <code>@Configuration + @EnableAutoConfiguration + @ComponentScan</code><ul><li><code>@Configuration</code> : 指明是IOC容器的配置类, 被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。</li><li><code>@EnableAutoConfiguration</code>  : SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。</li><li><code>@ComponentScan</code> : 组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。</li></ul></li><li><code>@RestController</code>: 作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON或者是XML。使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，效果等同于通过向<code>response.getOutputStream()</code>写入数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:spring/spring-main.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApiApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApiApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p>Spring Cloud 主要组件：</p><ul><li>Spring Cloud Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Subversion。</li><li><p>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</p></li><li><p>Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</p></li><li>Ribbon：提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</li><li>Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li><li>Consul：封装了 Consul 操作，consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。</li><li><del>Eureka</del>：云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li><li>Spring Cloud Cluster：提供 Leadership 选举，如：Zookeeper, Redis, Hazelcast, Consul 等常见状态模式的抽象和实现。</li><li>Spring Cloud Zookeeper：操作 Zookeeper 的工具包，用于使用 zookeeper 方式的服务发现和配置管理。</li><li>Spring Cloud Task：提供云端计划任务管理、任务调度。</li></ul><ul><li>Spring Cloud Data Flow：大数据操作工具，作为 Spring XD 的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</li><li>Spring Cloud Stream：数据流操作开发包，封装了与 Redis,Rabbit、Kafka 等发送接收消息。</li></ul><p>@ref:  </p><ul><li><a href="https://www.zhihu.com/question/47304987" target="_blank" rel="noopener"> Spring boot与Spring cloud 是什么关系？ - 知乎</a></li><li><a href="https://www.springcloud.cc/" target="_blank" rel="noopener">https://www.springcloud.cc/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://sdtimes.com/wp-content/uploads/2018/03/spring-boot-490x257.png&quot; alt=&quot;Spring Boot&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Spring-Boot-vs-Spring&quot;&gt;&lt;a href=&quot;#Spring-Boot-vs-Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot vs Spring&quot;&gt;&lt;/a&gt;Spring Boot vs Spring&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;内置了嵌入式的Tomcat、Jetty等Servlet容器，应用可以不用打包成War格式，而是可以直接以Jar格式运行&lt;/li&gt;
&lt;li&gt;Spring Boot提倡无XML配置文件的理念，使用Spring Boot生成的应用完全不会生成任何配置代码与XML配置文件。&lt;/li&gt;
&lt;li&gt;提供了多个可选择的「starter」:&lt;ul&gt;
&lt;li&gt;spring-boot-starter-data-redis:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-activemq:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-jdbc:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-web:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-actuator:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Spring-Boot-全家桶&quot;&gt;&lt;a href=&quot;#Spring-Boot-全家桶&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 全家桶&quot;&gt;&lt;/a&gt;Spring Boot 全家桶&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/JavaEE.springboot-bucket.png&quot; alt=&quot;../_images/JavaEE.springboot-bucket.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="13.J2EE" scheme="https://beefyheisenberg.github.io/categories/13-J2EE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Spring Boot" scheme="https://beefyheisenberg.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Servelt and JSP</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Servlet/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Servlet/</id>
    <published>2023-05-09T04:45:01.078Z</published>
    <updated>2023-05-09T04:45:01.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Web应用"><a href="#Java-Web应用" class="headerlink" title="Java Web应用"></a>Java Web应用</h1><p>Java Web 应用是一个 servlets, HTML 页面,类,和其他资源的集合，用于一个在 Web 服务器的完成的应用。Web 应用可以捆绑和运行来自多个供应商的在多个容器。<br>servlet 容器必须强制 Web 应用程序和 ServletContext 之间一对一对应的关系。ServletContext 对象提供了一个 servlet 和它的应用程序视图。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>可以使用标准的 Java 归档工具把 Web 应用程序打包并签名到一个 Web 存档格式（WAR）文件中。例如，一个关于“issue tracking”的应用程序可以分布在一个称为 issuetrack.war 的归档文件中。</p><p>当打包成这种形式时，将生成一个 META-INF 目录，其中包含了对 java归档工具有用的信息。尽管这个目录的内容可以通过 servlet 代码调用ServletContext 的 getResource 和 getResourceAsStream 方法来访问，容器也不能把这个目录当作内容来响应客户端请求。此外，任何请求访问 META-INF 目录中的资源必须返回一个 SC_NOT_FOUND（404）的响应。常见的归档格式war 和 ear格式对比：</p><ul><li><p>war: Web Archive file, 结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webapp.war</span><br><span class="line">  |-index.jsp</span><br><span class="line">  |— META-INF</span><br><span class="line">    |-Manifest.mf</span><br><span class="line">  |— WEB-INF</span><br><span class="line">       |- web.xml</span><br><span class="line">       |— classes</span><br><span class="line">       |— lib  // 依赖的jar包</span><br></pre></td></tr></table></figure></li><li><p>ear: Enterprise ARchieve, 用于在Java EE中将一个或者多个模块封装到一个文件中, 这样, 多个不同模块在应用服务器上的部署就可以同时并持续的进行. 结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.ear</span><br><span class="line">   |- ejb.jar    // ejb-jar包</span><br><span class="line">   |- other.jar  // 普通jar包</span><br><span class="line">   |- webapp.war  // war包</span><br><span class="line">   |—META-INF</span><br><span class="line">        application.xml  // EAR描述文件</span><br></pre></td></tr></table></figure></li></ul><h2 id="Web-xml"><a href="#Web-xml" class="headerlink" title="Web.xml"></a>Web.xml</h2><blockquote><p>servlet3.*的规范已经支持不使用 web.xml了</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>HelloWorld Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">        This is a simple web application with a source code organization</span><br><span class="line">        based on the recommendations of the Application Developer's Guide.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.web.listener.MyServletRequestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.web.listener.MyServletContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ResponseFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.web.filter.ResponseFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ResponseFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.web.Servlet.Hello<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Servlet（Server-Applet）"><a href="#Servlet（Server-Applet）" class="headerlink" title="Servlet（Server Applet）"></a>Servlet（Server Applet）</h1><p>本节参考自: <a href="https://www.gitbook.com/book/waylau/servlet-3-1-specification/details" target="_blank" rel="noopener">Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a> @ref</p><h2 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h2><p>servlet 是基于 Java 的 Web 组件，由容器进行管理，来生成动态内容。像其他基于 Java 的组件技术一样，servlet 也是基于平台无关的 Java 类格式，被编译为平台无关的字节码，可以被基于 Java 技术的 Web 服务器动态加载并运行。容器（Container），有时候也叫做 servlet 引擎，是 Web 服务器为支持 servlet 功能扩展的部分。客户端通过 servlet 容器实现的 request/response paradigm（请求/应答模式） 与 Servlet 进行交互。</p><h2 id="什么是-Servlet-容器"><a href="#什么是-Servlet-容器" class="headerlink" title="什么是 Servlet 容器"></a>什么是 Servlet 容器</h2><p>Servlet Container（Servlet 容器） 是 Web 服务器或者应用服务器的一部分，用于提供基于请求/响应发送模式的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器同时也包含和管理他们的生命周期里 Servlet。<a href="/13.JavaEE-Framework/JavaEE.Tomcat/" title="JavaEE.Tomcat">JavaEE.Tomcat</a></p><p>Servlet 容器可以嵌入到宿主的 Web 服务器中，或者通过 Web 服务器的本地扩展 API 单独作为附加组件安装。Servelt 容器也可能内嵌或安装到启用 Web 功能的应用服务器中。</p><p>所有的 Servlet 容器必须支持 HTTP 协议用于请求和响应，但额外的基于请求/响应的协议，如 HTTPS (HTTP over SSL)的支持是可选的。对于 HTTP 规范需要版本，容器必须支持 HTTP/1.0 和 HTTP/1.1。因为容器或许支持 RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给 Servlet 处理之前修改它们，也可能在将 Servlet 生成的响应发送给客户端之前修改它们，或者可能根据 RFC2616 规范直接对请求作出响应而不交给 Servlet 进行处理。</p><p>Servlet 容器应该使 Servlet 执行在一个安全限制的环境中。在 Java 平台标准版（J2SE, v.1.3 或更高） 或者 Java 平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在 Java 平台定义的安全许可架构中。比如，高端的应用服务器为了保证容器的其他组件不受到负面影响可能会限制 Thread 对象的创建。</p><h2 id="Servlet-与其他技术的对比"><a href="#Servlet-与其他技术的对比" class="headerlink" title="Servlet 与其他技术的对比"></a>Servlet 与其他技术的对比</h2><p>从功能上看，servlet 位于 Common Gateway Interface（公共网关接口，简称 CGI）程序和私有的服务器扩展如 Netscape Server API（NSAPI）或 Apache Modules 这两者之间。<br>相对于其他服务器扩展机制 Servlet 有如下优势：</p><ul><li>它们通常比 CGI 脚本更快，因为采用不同的处理模型。</li><li>它们采用标准的 API 从而支持更多的Web 服务器。</li><li>它们拥有 Java 编程语言的所有优势，包括容易开发和平台无关。</li><li>它们可以访问 Java 平台提供的大量的 API。</li></ul><h2 id="与-Java-EE-的关系"><a href="#与-Java-EE-的关系" class="headerlink" title="与 Java EE 的关系"></a>与 Java EE 的关系</h2><p>Java Servlet API 3.1 版本是 Java 平台企业版 7 版本必须的 API。Servlet 容器和 servlet 被部署到平台中时，为了能在 Java EE 环境中执行，必须满足 JavaEE 规范中描述的额外的一些要求。</p><h2 id="与-Servlet-2-5-规范的兼容性"><a href="#与-Servlet-2-5-规范的兼容性" class="headerlink" title="与 Servlet 2.5 规范的兼容性"></a>与 Servlet 2.5 规范的兼容性</h2><p>在 Servlet 2.5 中, metadata-complete 只影响在部署时的注释扫描。 web-fragments 的概念在 servlet 2.5 并不存在。然而在 servlet 3.0 和之后,metadata-complete 影响扫描所有的在部署时指定部署信息和 web-fragments 注释。注释的版本的描述符必须不影响你扫描在一个web应用程序。除非 metadata-complete 指定，规范的一个特定版本的实现必须扫描所有配置的支持的注解。</p><h2 id="HttpServletRequest-–-请求"><a href="#HttpServletRequest-–-请求" class="headerlink" title="HttpServletRequest – 请求"></a>HttpServletRequest – 请求</h2><p>本节参考 <a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Request/3.%20The%20Request.html" target="_blank" rel="noopener">请求 · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a> @ref</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个请求对象只在一个 servlet 的 service 方法的作用域内，或过滤器的 doFilter 方法的作用域内有效，除非该组件启用了异步处理并且调用了请求对象的 startAsync 方法。<br>在发生异步处理的情况下，请求对象一直有效，直到调用 AsyncContext 的 complete 方法。容器通常会重复利用请求对象，以避免创建请求对象而产生的性能开销。<br>开发人员必须注意的是，不建议在上述范围之外保持 startAsync 方法还没有被调用的请求对象的引用，因为这样可能产生不确定的结果。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>ServletRequest 接口提供方法:</p><ul><li>getParameter</li><li>getParameterNames</li><li>getParameterValues</li><li>getParts</li><li>getPart</li><li>getAttribute</li><li>getHeader/getHeaders</li><li>getContextPath</li><li>…</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>当数据以multipart/form-data的格式发送时，servlet 容器支持文件上传。</p><h3 id="头"><a href="#头" class="headerlink" title="头"></a>头</h3><ul><li>getAttribute</li><li>getAttributeNames</li><li>setAttribute</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>getAttribute</li><li>getAttributeNames</li><li>setAttribute</li></ul><h3 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h3><ul><li>getContextPath</li><li>getServletPath</li><li>getPathInfo</li></ul><p>requestURI = contextPath + servletPath + pathInfo</p><h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><p><a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Request/3.7%20Non%20Blocking%20IO.html" target="_blank" rel="noopener">非阻塞 IO · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a></p><h2 id="ServletResponse-–-响应"><a href="#ServletResponse-–-响应" class="headerlink" title="ServletResponse – 响应"></a>ServletResponse – 响应</h2><p><a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Response/5%20The%20Response.html" target="_blank" rel="noopener">响应 · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a></p><h2 id="ServletContext-–-上下文"><a href="#ServletContext-–-上下文" class="headerlink" title="ServletContext – 上下文"></a>ServletContext – 上下文</h2><p>ServletContext 接口定义了 servlet 运行在的 Web 应用的视图。容器供应商负责提供 servlet 容器的 ServletContext 接口的实现。servlet 可以使用 ServletContext 对象记录事件，获取 URL 引用的资源，存取当前上下文的其他 servlet 可以访问的属性。<br>ServletContext 是 Web 服务器中已知路径的根。例如，servlet 上下文可以从 <a href="http://www.mycorp.com/catalog" target="_blank" rel="noopener">http://www.mycorp.com/catalog</a> 找出，/catalog 请求路径称为上下文路径，所有以它开头的请求都会被路由到与 ServletContext 相关联的 Web 应用。</p><h2 id="Filter-–-过滤器"><a href="#Filter-–-过滤器" class="headerlink" title="Filter – 过滤器"></a>Filter – 过滤器</h2><p>过滤器是一种代码重用的技术，它可以转换 HTTP 请求的内容，响应，及头信息。过滤器通常不产生响应或像 servlet 那样对请求作出响应，而是修改或调整到资源的请求，修改或调整来自资源的响应。</p><p>在web.xml中声明的每个<code>&lt;filter&gt;</code>在每个 JVM 的容器中仅实例化一个实例。容器提供了声明在过滤器的部署描述符的过滤器config（译者注：FilterConfig），对 Web 应用的 ServletContext 的引用，和一组初始化参数。<br>当容器接收到传入的请求时，它将获取列表中的第一个过滤器并调用<code>doFilter</code> 方法，传入 ServletRequest 和 ServletResponse，和一个它将使用的 FilterChain 对象的引用。</p><h3 id="过滤器组件示例"><a href="#过滤器组件示例" class="headerlink" title="过滤器组件示例"></a>过滤器组件示例</h3><ul><li>Authentication filters //用户身份验证过滤器</li><li>Logging and auditing filters //日志记录与审计过滤器</li><li>Image conversion filters //图片转换过滤器</li><li>Data compression filters //数据压缩过滤器</li><li>Encryption filters //加密过滤器</li><li>Tokenizing filters //分词过滤</li><li>Filters that trigger resource access events //触发资源访问事件过滤</li><li>XSL/T filters that transform XML content</li><li>MIME-type chain filters //MIME-TYPE 链过滤器</li><li>Caching filters //缓存过滤器</li></ul><h2 id="Listener-–-监听器"><a href="#Listener-–-监听器" class="headerlink" title="Listener – 监听器"></a>Listener – 监听器</h2><p>Listener 用于监听 java web程序中的事件，例如创建、修改、删除Session、request、context等，并触发响应的事件。<br>Listener 对应观察者模式，事件发生的时候会自动触发该事件对应的Listeer。 Listener 主要用于对 Session、Request、Context 进行监控。servlet2.5 规范中共有 8 种Listener 。</p><p>不同功能的Listener 需要实现不同的 Listener  接口，一个Listener也可以实现多个接口，这样就可以多种功能的监听器一起工作。监听器接口可以分为三类：</p><ul><li>1）监听 Session、Request、Context 的创建于销毁，分别为  <code>HttpSessionLister</code>、<code>ServletContextListener</code>、<code>ServletRequestListener</code></li><li>2）监听对象属性变化，分别为：<code>HttpSessionAttributeLister</code>、<code>ServletContextAttributeListener</code>、<code>ServletRequestAttributeListener</code></li><li>3）监听Session 内的对象，分别为<code>HttpSessionBindingListener</code> 和 <code>HttpSessionActivationListener</code>。与上面六类不同，这两类 Listener 监听的是Session 内的对象，而非 Session 本身，不需要在 <code>web.xml</code>中配置。</li></ul><h3 id="实现一个Listener"><a href="#实现一个Listener" class="headerlink" title="实现一个Listener"></a>实现一个Listener</h3><p>web.xml的Listener配置： <code>&lt;listener&gt;</code>标签与 <code>&lt;listener-class&gt;</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>servlet.listener.MyListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建 MyListener, 实现监听对Session, Context, Request对象的创建与销毁:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span>, <span class="title">ServletContextListener</span>, <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 session</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">log.info(<span class="string">"新创建一个session, ID为: "</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁 session</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">log.info(<span class="string">"销毁一个session, ID为: "</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 context</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">ServletContext servletContext = sce.getServletContext();</span><br><span class="line">log.info(<span class="string">"即将启动"</span> + servletContext.getContextPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载 context</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">ServletContext servletContext = sce.getServletContext();</span><br><span class="line">log.info(<span class="string">"即将关闭"</span> + servletContext.getContextPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpSession-–-会话"><a href="#HttpSession-–-会话" class="headerlink" title="HttpSession – 会话"></a>HttpSession – 会话</h2><p>会话跟踪机制:</p><ul><li>Cookie: 通过 HTTP cookie 的会话跟踪是最常用的会话跟踪机制，且所有 servlet 容器都应该支持。所有 servlet 容器必须提供能够配置容器是否标记会话跟踪 cookie 为HttpOnly的能力。</li><li>SSL会话: 安全套接字层(Secure Sockets Layer)，在 HTTPS 使用的加密技术，有一种内置机制允许多个来自客户端的请求被明确识别为同一会话。Servlet容器可以很容易地使用该数据来定义会话。</li><li>URL 重写: URL 重写是会话跟踪的最低标准。当客户端不接受 cookie 时，服务器可使用 URL 重写作为会话跟踪的基础。URL 重写涉及添加数据、会话 ID、容器解析 URL 路径从而请求与会话相关联。</li></ul><h2 id="Dispatcher-–-分发器"><a href="#Dispatcher-–-分发器" class="headerlink" title="Dispatcher – 分发器"></a>Dispatcher – 分发器</h2><p>RequestDispatcher 接口负责把请求转发给一个 servlet 处理；<br>当请求启用异步处理时，AsyncContext 允许用户将这个请求转发到servlet 容器。</p><p>可以通过<code>ServletContext.getRequestDispatcher()</code>获取 RequestDispatcher.</p><p>使用请求调度器:</p><ul><li><code>include</code> 方法: include 方法的目标 servlet 能够访问请求对象的各个方法（all aspects），但是使用响应对象的方法会受到更多限制。</li><li><code>forward</code> 方法: RequestDispatcher 接口的 <code>forward()</code> 方法，只有在没有输出提交到向客户端时，通过正在被调用的 servlet 调用。如果响应缓冲区中存在尚未提交的输出数据，这些数据内容必须在目标 servlet 的 <code>service()</code> 方法调用前清除。如果响应已经提交，必须抛出一个 <code>IllegalStateException</code> 异常。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String path = “/raisins.jsp”;</span><br><span class="line">RequestDispatcher rd = context.getRequestDispatcher(path);</span><br><span class="line">rd.include(request, response);</span><br></pre></td></tr></table></figure><h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><p>当容器启动后, 容器会判断内存中是否存在指定的 Servlet对象, 如果没有则创建它, 当容器停止或者重新启动, Servlet容器调用 Servlet对象的 destroy方法来释放资源;<br>Servlet生命周期分几个步骤: Servlet类加载 -&gt; 实例化 -&gt; 服务 -&gt; 销毁:</p><ul><li>Servlet容器 负责加载 Servlet类</li><li>Servlet容器 使用开始实例化 Servlet, 创建对象并调用 init()方法</li><li>响应客户请求阶段调用 service()方法</li><li>销毁阶段调用 destroy()方法</li></ul><h3 id="Request-生命周期"><a href="#Request-生命周期" class="headerlink" title="Request 生命周期"></a>Request 生命周期</h3><p>接收到HTTP请求后, 容器会创建 HttpServletRequest对象, 并传递给 Servlet, 在这次请求结束后, Request对象也被销毁;<br>每个请求对象只在一个 servlet 的 <code>service()</code> 方法的作用域内, 或过滤器的 <code>doFilter()</code> 方法的作用域内有效,<br>除非该组件启用了异步处理并且调用了请求对象的 <code>startAsync()</code> 方法. 在发生异步处理的情况下, 请求对象一直有效, 直到调用 AsyncContext 的 <code>complete()</code> 方法.</p><h2 id="并发-amp-多线程问题"><a href="#并发-amp-多线程问题" class="headerlink" title="并发 &amp; 多线程问题"></a>并发 &amp; 多线程问题</h2><p>因为 Servlet 规范的特点，Servlet 容器（如 Tomcat）一般采用多线程来处理多个请求同时访问，Servlet 容器维护了一个线程池来服务请求。<br>线程池实际上是等待执行代码的一组线程叫做工作者线程(WorkerThread)，Servlet容器使用一个调度线程来管理工作者线程(DispatcherThread)。<br>当容器收到一个访问Servlet的请求，调度者线程从线程池中选出一个工作者线程，将请求传递给该线程，然后由该线程来执行Servlet的<code>service()</code>方法。<br>当这个线程正在执行的时候，容器收到另外一个请求，调度者线程将从池中选出另外一个工作者线程来服务新的请求，容器并不关心这个请求是否访问的是同一个Servlet还是另外一个Servlet。当容器同时收到对同一Servlet的多个请求，那这个Servlet的<code>service()</code>方法将在多线程中并发的执行。</p><p>同步<code>service()</code>的两种方式:</p><ul><li>Servlet实现<code>SingleThreadModel</code>接口: 开发人员实现 SingleThreadModel 接口，由容器保证一个 <code>service()</code> 方法在同一个时间点仅被一个请求线程调用，但是此方案是不推荐的。servlet 容器可以通过串行化访问 servlet的请求，或者维护一个 servlet 实例池完成该需求。如果 Web 应用中的 servlet 被标注为分布式的，容器应该为每一个分布式应用程序的 JVM 维护一个 servlet 实例池。</li><li>synchronized同步<code>service()</code>方法, 不建议使用: 对于那些没有实现 <code>SingleThreadModel</code> 接口的 servlet，但是它的<code>service()</code> 方法（或者是那些 HttpServlet 中通过 service 方法分派的doGet、doPost 等分派方法）是通过 synchronized 关键词定义的，servlet 容器不能使用实例池方案，并且只能使用序列化请求进行处理。强烈推荐开发人员不要去同步 <code>service()</code> 方法（或者那些由 <code>service()</code> 分派的方法），因为这将严重影响性能。</li></ul><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>这就导致了Servlet里的实例变量是线程不安全的,多个线程（多个客户端的请求）共享这些实例变量，一个线程对这些实例变量的改变会影响其它线程的取值，Servlet规范已经声明Servlet不是线程安全的,包括jsp,Servlet,javabean等。</p><blockquote><p>ServletContext：（线程不安全）</p></blockquote><p>ServletContext是可以多线程同时读/写属性的，线程是不安全的。要对属性的读写进行同步处理或者进行深度Clon。所以在Servlet上下文中尽可能少量保存会被修改（写）的数据，可以采取其他方式在多个Servlet中共享，比方我们可以使用单例模式来处理共享数据。</p><blockquote><p>HttpSession：（线程不安全）</p></blockquote><p>HttpSession对象在用户会话期间存在，只能在处理属于同一个Session的请求的线程中被访问，因此Session对象的属性访问理论上是线程安全的。当用户打开多个同属于一个进程的浏览器窗口，在这些窗口的访问属于同一个Session，会出现多次请求，需要多个工作线程来处理请求，可能造成同时多线程读写属性。这时我们需要对属性的读写进行同步处理：使用同步块Synchronized和使用读/写器来解决。</p><blockquote><p>ServletRequest：（线程安全）</p></blockquote><p>对于每一个请求，由一个工作线程来执行，都会创建有一个新的ServletRequest对象，所以ServletRequest对象只能在一个线程中被访问。ServletRequest是线程安全的。ServletRequest对 象在service方法的范围内是有效的，不要试图在service方法结束后仍然保存请求对象的引用。</p><p><a href="http://wenboo.site/2016/11/14/Servlet-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">http://wenboo.site/2016/11/14/Servlet-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/</a></p><h2 id="异步-amp-AsyncContext"><a href="#异步-amp-AsyncContext" class="headerlink" title="异步 &amp; AsyncContext"></a>异步 &amp; AsyncContext</h2><p>@ref <a href="https://www.cnblogs.com/davenkin/p/async-servlet.html" target="_blank" rel="noopener">Servlet 3.0/3.1 中的异步处理</a></p><blockquote><p>在Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求，即每一次Http请求都由某一个线程从头到尾负责处理。如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待IO操作完成， 而IO操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。<br>为了解决这样的问题，Servlet 3.0引入了异步处理，然后在Servlet 3.1中又引入了非阻塞IO来进一步增强异步处理的性能。</p></blockquote><p>在Servlet 3.0中，<code>@WebServlet</code> 和 <code>@WebFilter</code> 注解有一个属性——<code>asyncSupported</code>，boolean 类型默认值为 false。<br>当 <code>asyncSupported</code> 设置为 true，我们可以从HttpServletRequest对象中通过<code>startAsync()</code>获得一个AsyncContext对象，AsyncContext对象构成了异步处理的上下文，Request和Response对象都可从中获取。<br>AsyncContext 可以从当前线程传给另外的线程，并在新的线程中完成对请求的处理并返回结果给客户端，当前请求的线程便可以还回给容器线程池以处理更多的请求。</p><p>一个有较长耗时操作的Servlet可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/simpleAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        asyncContext.start(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过<code>request.startAsync()</code>获取到该请求对应的<code>AsyncContext</code>，然后调用<code>AsyncContext</code>的<code>start()</code>方法进行异步处理，处理完毕后需要调用<code>AsyncContext.complete()</code>方法告知Servlet容器。<br><code>AsyncContext.start()</code>方法会向Servlet容器另外申请一个新的线程（可以是从Servlet容器中已有的主线程池获取，也可以另外维护一个线程池，不同容器实现可能不一样），然后在这个新的线程中继续处理请求，而原先的线程将被回收到主线程池中。<br>事实上，这种方式对性能的改进不大，因为如果新的线程和初始线程共享同一个线程池的话，相当于闲置下了一个线程，但同时又占用了另一个线程。</p><p>这里有一篇文章<a href="https://dzone.com/articles/limited-usefulness" target="_blank" rel="noopener">The Limited Usefulness of AsyncContext.start() - DZone Java</a>,<br>对该方法做了性能测试, 结论如下 :</p><ul><li>Tomcat 的 <code>AsyncContext.start</code> 实现是, 把处理 Request 的线程放入 Http work threadpool 线程池执行</li><li>在 Tomcat中使用 Servlet3.0 的 <code>AsyncContext.start</code> 不会带来任何 Tomcat并发性能改进</li><li>正确的办法是另外维护一个线程池，这个线程池不同于Servlet容器的主线程池（请求线程池），如下图：</li></ul><p><img src="/images/javaee/javaee_servlet_async.png" alt=""></p><p>在上图中，用户发起的请求首先交由Servlet容器主线程池（请求线程池）中的线程处理，在该线程中，我们获取到AsyncContext，然后将其交给异步处理线程池。<br><strong>请求线程</strong>可以被归还回主线程池，这样主线程池用来处理 Http请求的线程没有被长时间占用。<br>但是需要注意的是，这种做法可以及时归还<strong>请求线程</strong>，但在仍旧占用另一个线程，所以 JVM 的线程总数没有减少，系统瓶颈仍旧在 JVM 进程的最大线程数上（单个线程的栈大小默认是 <code>-Xss1M</code>）</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/threadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Requet-和-Response的非阻塞IO"><a href="#Requet-和-Response的非阻塞IO" class="headerlink" title="Requet 和 Response的非阻塞IO"></a>Requet 和 Response的非阻塞IO</h3><p>Servlet 3.0对请求的处理虽然是异步的，但是对<code>InputStream</code>和<code>OutputStream</code>的IO操作却依然是阻塞的，对于数据量大的请求体或者返回体，阻塞IO也将导致不必要的等待。因此在Servlet 3.1中引入了非阻塞IO（参考下图红框内容），通过在<code>HttpServletRequest</code>和<code>HttpServletResponse</code>中分别添加<code>ReadListener</code>和<code>WriterListener</code>方式，只有在IO数据满足一定条件时（比如数据准备好时），才进行后续的操作。</p><p><img src="/images/javaee/javaee_servlet_non_block_io.png" alt=""></p><p>对应的代码示例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/nonBlockingThreadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockingAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        ServletInputStream inputStream = request.getInputStream();</span><br><span class="line">        inputStream.setReadListener(<span class="keyword">new</span> ReadListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataAvailable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAllDataRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    asyncContext.complete();</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，我们为<code>ServletInputStream</code>添加了一个<code>ReadListener</code>，并在<code>ReadListener</code>的<code>onAllDataRead()</code>方法中完成了长时处理过程。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>servlet 在处理一个请求时可能抛出 <code>ServletException</code> 或<code>UnavailableException</code> 异常。</p><ul><li><code>ServletException</code> 表示在处理请求时出现了一些错误，容器应该采取适当的措施清理掉这个请求。</li><li><code>UnavailableException</code> 表示 servlet 目前无法处理请求，或者临时性的或者永久性的：<ul><li>如果 <code>UnavailableException</code> 表示的是一个永久性的不可用，servlet 容器必须从服务中移除这个 servlet，调用它的 destroy 方法，并释放servlet 实例。所有被容器拒绝的请求，都会返回一个 <code>SC_NOT_FOUND</code> (404) 响应。</li><li>如果 <code>UnavailableException</code> 表示的是一个临时性的不可用，容器可以选择在临时不可用的这段时间内路由任何请求到 Servlet。所以在这段时间内被容器拒绝的请求，都会返回一个 <code>SC_SERVICE_UNAVAILABLE</code> (503) 响应状态码，且同时会返回一个 Retry-After 头指示此 servlet 什么时候可用。容器可以选择忽略永久性和临时性不可用的区别，并把<code>UnavailableException</code> 视为永久性的，从而 servlet 抛出<code>UnavailableException</code> 后需要把它从服务中移除。</li></ul></li></ul><h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><p>@ref:</p><ul><li><a href="http://docs.oracle.com/javaee/6/api" target="_blank" rel="noopener">JavaTM Platform, Enterprise Edition 6 API Specificatio</a></li><li><a href="https://waylau.gitbooks.io/servlet-3-1-specification" target="_blank" rel="noopener">https://waylau.gitbooks.io/servlet-3-1-specification</a></li></ul><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ol><li>Servlet[I]: 属于<code>javax.servlet</code>包<ul><li><code>init()</code></li><li><code>destroy()</code></li><li><code>service(ServletRequest, ServletResponse)</code></li></ul></li><li>HttpServlet: 属于<code>javax.servlet.http</code>包<ul><li><code>service()</code>: 根据method调用: <code>doHead()</code>, <code>doGet()</code>, <code>doPost()</code> …</li></ul></li><li>DispatcherServlet : 属于<code>org.springframework.web.servlet</code>包<ul><li><code>doService()</code> : 调用了<code>doDispatch()</code></li><li><code>doDispatch()</code> : 从这里调用进<code>@Controller</code>中相关的方法</li></ul></li></ol><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>对应web.xml的<code>&lt;servlet&gt;</code>, ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过<code>ServletConfig.getServletContext</code>方法获得<code>ServletContext</code>对象<br>常用方法:</p><ul><li><code>getServletName</code>：</li><li><code>getServletContext</code>：</li></ul><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>对应web.xml的<code>&lt;context-param&gt;</code>, 容器中部署的每一个web应用都有一个ServletContext接口的实例对象与之关联<br>常用方法:</p><ul><li><code>getInitParameter</code> / <code>getInitParameterNames</code></li><li><code>addFilter</code></li><li><code>addListener</code></li><li><code>addServlet</code></li></ul><p>在任何Servlet实现类中可以使用<code>this.getServletContext</code>获取Context</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ul><li><code>init</code> / <code>destroy</code></li><li><code>doFilter</code></li><li><code>FilterChain</code></li></ul><h3 id="Response"><a href="#Response" class="headerlink" title="Response:"></a>Response:</h3><ol><li>ServletResponse[I]<ul><li><code>getOutputStream()</code> / <code>getWriter()</code></li><li><code>flushBuffer()</code></li></ul></li><li>HttpServletResponse[I]<ul><li><code>addCookie</code></li><li><code>setHeader</code></li></ul></li><li>HttpServletResponseWrapper</li></ol><h3 id="Request"><a href="#Request" class="headerlink" title="Request:"></a>Request:</h3><ol><li>ServletRequest[I]<ul><li><code>getInputStream()</code> / <code>getReader()</code></li><li><code>getParameter</code> / <code>getAttribute</code></li><li><code>startAsync()</code></li></ul></li><li>HttpServletRequest[I]<ul><li><code>getContextPath()</code>, <code>getServletPath()</code>, <code>getPathInfo()</code></li><li><code>getRequestURI()</code> / <code>getRequestURL()</code></li></ul></li><li>HttpServletRequestWrapper</li></ol><h3 id="IO-Stream"><a href="#IO-Stream" class="headerlink" title="IO Stream"></a>IO Stream</h3><ol><li>ServletInputStream:<ul><li><code>readLine</code></li></ul></li><li>ServletOutputStream:<ul><li><code>print</code> / <code>println</code></li></ul></li></ol><h3 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h3><p>RequestDispatcher对象由Servlet容器来创建, 封装一个由路径所标识的服务器资源.<br>在Servlet实现类中获取dispatcher对象: <code>this.getServletContext().getRequestDispatcher(&quot;/api/v2/topic/load&quot;)</code></p><ol><li>获取RequestDispatcher对象<ol><li>ServletRequest的<code>getRequestDispatcher(String  path)</code>方法</li><li>ServletContext的<code>getNamedDispatcher(String  path)</code>和<code>getRequestDispatcher(String  path)</code>方法</li></ol></li><li>RequestDispatcher.forward(ServletRequest, ServletResponse) : 类似php里的inclde, 在返回页面中包括其他资源</li><li>RequestDispatcher.include(ServletRequest, ServletResponse) : 转发</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;/2.html&quot;).include(request, response); // 在当前页面包含2.html</span><br><span class="line">requset.getRequestDisPatcher(&quot;/servlet2&quot;).dispatcher.forward(request, response);  // 转发到servlet2</span><br></pre></td></tr></table></figure><h1 id="JSP（JavaServer-Pages）"><a href="#JSP（JavaServer-Pages）" class="headerlink" title="JSP（JavaServer Pages）"></a>JSP（JavaServer Pages）</h1><h2 id="Servlet-amp-JSP-区别与联系"><a href="#Servlet-amp-JSP-区别与联系" class="headerlink" title="Servlet &amp; JSP 区别与联系"></a>Servlet &amp; JSP 区别与联系</h2><ul><li>Servlet在Java代码中通过HttpServletResponse对象动态输出HTML内容</li><li>JSP在静态HTML内容中嵌入Java代码, Java代码被动态执行后生成HTML内容,</li><li>JSP的本质仍是Servlet, JSP编译之后生成的<code>*.java</code>文件和<code>*.class</code>里有什么?</li><li>Servlet是被Context的类加载器加载的, 所以重写Servlet需要重新部署Context, JSP有自己的加载器, JSP文件在修改之后不需要”重新加载”</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>代码段 <code>&lt;% ... %&gt;</code></li><li><p>声明: <code>&lt;%! ... &gt;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%! int i = 0; %&gt;</span><br><span class="line">&lt;%! int a, b, c; %&gt;</span><br></pre></td></tr></table></figure></li><li><p>表达式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">   今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动作元素"><a href="#动作元素" class="headerlink" title="动作元素"></a>动作元素</h2><ul><li><code>jsp:include</code> :     在页面被请求的时候引入一个文件。</li><li><code>jsp:useBean</code> : 寻找或者实例化一个JavaBean。<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"myName"</span> ... &gt;</span><br><span class="line">   &lt;jsp:setProperty name=<span class="string">"myName"</span> property=<span class="string">"someProperty"</span> .../&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-Web应用&quot;&gt;&lt;a href=&quot;#Java-Web应用&quot; class=&quot;headerlink&quot; title=&quot;Java Web应用&quot;&gt;&lt;/a&gt;Java Web应用&lt;/h1&gt;&lt;p&gt;Java Web 应用是一个 servlets, HTML 页面,类,和其他资源的集合，用于一个在 Web 服务器的完成的应用。Web 应用可以捆绑和运行来自多个供应商的在多个容器。&lt;br&gt;servlet 容器必须强制 Web 应用程序和 ServletContext 之间一对一对应的关系。ServletContext 对象提供了一个 servlet 和它的应用程序视图。&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;可以使用标准的 Java 归档工具把 Web 应用程序打包并签名到一个 Web 存档格式（WAR）文件中。例如，一个关于“issue tracking”的应用程序可以分布在一个称为 issuetrack.war 的归档文件中。&lt;/p&gt;
&lt;p&gt;当打包成这种形式时，将生成一个 META-INF 目录，其中包含了对 java归档工具有用的信息。尽管这个目录的内容可以通过 servlet 代码调用ServletContext 的 getResource 和 getResourceAsStream 方法来访问，容器也不能把这个目录当作内容来响应客户端请求。此外，任何请求访问 META-INF 目录中的资源必须返回一个 SC_NOT_FOUND（404）的响应。常见的归档格式war 和 ear格式对比：&lt;/p&gt;</summary>
    
    
    
    <category term="13.J2EE" scheme="https://beefyheisenberg.github.io/categories/13-J2EE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Servlet" scheme="https://beefyheisenberg.github.io/tags/Servlet/"/>
    
    <category term="JSP" scheme="https://beefyheisenberg.github.io/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>Java JPA &amp; ORM框架</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.ORM&amp;JPA/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.ORM&amp;JPA/</id>
    <published>2023-05-09T04:45:01.073Z</published>
    <updated>2023-05-09T04:45:01.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些概念：JDBC-amp-PJA-amp-ORM"><a href="#一些概念：JDBC-amp-PJA-amp-ORM" class="headerlink" title="一些概念：JDBC &amp; PJA &amp; ORM"></a>一些概念：JDBC &amp; PJA &amp; ORM</h1><p><strong>JDBC</strong> (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。</p><hr><p><strong>JPA</strong> 全称为Java Persistence API ，Java持久化API是Sun公司在Java EE 5规范中提出的Java持久化接口。JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。使用JPA持久化对象，并不是依赖于某一个ORM框架。<br>JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现，JBoss应用服务器底层就以Hibernate作为JPA的实现。<br>虽然 ORM 框架都实现了 JPA 规范，但是在不同 ORM 框架之间切换是需要编写的代码有一些差异，而通过使用 Spring Data Jpa 能够方便大家在不同的 ORM 框架中间进行切换而不要更改代码。并且 Spring Data Jpa 对 Repository 层封装的很好，可以省去不少的麻烦。</p><hr><p><strong>ORM</strong> :对象关系映射（Object Relational Mapping，简称 ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中。</p><h1 id="从-JDBC-到-ORM"><a href="#从-JDBC-到-ORM" class="headerlink" title="从 JDBC 到 ORM"></a>从 JDBC 到 ORM</h1><p>JDBC 规范对与数据库的交互做了如下抽象：用 Connection 代表和数据库的连接，用 Statement 执行 SQL，用 ResultSet 表示 SQL 返回的结果，提供了对数据的遍历。从 Connection 可以创建 Statement，Statement 执行查询得到 ResultSet。</p><p>Connection、Statement、ResultSet 都是接口，具体实现由各个数据库提供商提供。可以通过 JDBC统一的接口，访问多种类型的数据库，可随便切换数据库。</p><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = <span class="keyword">null</span>; </span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>; </span><br><span class="line">ResultSet rs = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//1. 加载驱动 </span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取连接</span></span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/dropnotes?serverTimezone=UTC"</span>, <span class="string">"user"</span>, <span class="string">"pwd"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 创建 PreparedStatement</span></span><br><span class="line">    ps = conn.prepareStatement(<span class="string">"select * from notes"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 执行sql</span></span><br><span class="line">    rs = ps.executeQuery(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 遍历结果集 </span></span><br><span class="line">    <span class="keyword">while</span>(rs.next()) &#123; </span><br><span class="line">        System.out.println(rs.getString(<span class="number">2</span>)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        rs.close(); </span><br><span class="line">        ps.close(); </span><br><span class="line">        conn.close(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (SQLException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDBC1 提供了 DriverManager 用于加载数据库驱动 &amp; 获取 connection ，但这种方式显然不方便，需要自己管理 connection ，频繁建立 &amp; 释放 connection 性能也不高。</p><blockquote><p>DriverManager 中使用了 SPI 模式来加载数据库 Driver Jar 包 @ref：<a href="https://pdai.tech/md/java/advanced/java-advanced-spi.html#spi%E6%9C%BA%E5%88%B6-jdbc-drivermanager" target="_blank" rel="noopener">Java常用机制 - SPI机制详解 | Java 全栈知识体系</a></p></blockquote><p>在 JDBC2 中支持了 DataSource 的方式，DataSource 包含连接池和连接池管理2个部分，习惯上称为  #数据库连接池 。在初始化的时候，建立一些 connection 对象并存储在缓存中，当需要访问数据库时，从连接池中取出一个已建立的空闲 connection 对象。</p><p>DataSource 也只是一个规范，具体的实现有 dbcp、c3p0、druid ，使用 c3p0 连接池的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource(); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test?serverTimezone=UTC"</span>);</span><br><span class="line">        dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        dataSource.setInitialPoolSize(<span class="number">3</span>);</span><br><span class="line">        dataSource.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        dataSource.setMinPoolSize(<span class="number">3</span>);</span><br><span class="line">        dataSource.setAcquireIncrement(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PropertyVetoException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    dataSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = dataSource.getConnection();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了连接池后，无需手动管理 connection 释放，方便了很多，但此时还是需要手动写 Statement 和 ResultSet 的代码。</p><p>这时候就需要使用 ORM（对象关系映射），主要解决数据库数据和 POJO 对象的相互映射，就不需要手动写 SQL 了</p><h1 id="选型对比"><a href="#选型对比" class="headerlink" title="选型对比"></a>选型对比</h1><h2 id="Spring-JPA-MyBatis"><a href="#Spring-JPA-MyBatis" class="headerlink" title="Spring JPA - MyBatis"></a>Spring JPA - MyBatis</h2><p><strong>Spring Data JPA or Mybatis</strong>?</p><p>Jpa（Java Persistence API）是 sun 官方提出的 java 持久化规范。它为 java 开发人员提供了一种对象/关联映射工具，来管理 java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 hibernate、<a href="https://www.zhihu.com/search?q=toplink&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2525463657%7D" target="_blank" rel="noopener">toplink</a>、jdo 等 ORM 框架各自为营的局面。</p><p>值得注意的是，Jpa 是在充分吸收了现有 ORM 框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，Jpa 受到了极大的支持和赞扬，其中就包括了 spring 和 EJB 的开发团队。</p><ul><li><p>Spring Data Jpa 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展</p></li><li><p>MyBatis 本是 apache 的一个开源项目 iBatis, 2010年这个项目由 apache software foundation 迁移到了 google code，并且改名为 MyBatis 。Mybatis：着力于 POJO 与 SQL 之间的映射关系</p></li></ul><p>Spring Data JPA 默认使用 hibernate 作为 ORM。我们再看看 hibernate 的官方概念，Hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 orm 框架，hibernate 可以自动生成 SQL 语句</p><p>@ref: <a href="https://www.zhihu.com/question/316458408" target="_blank" rel="noopener">SpringBoot开发使用Mybatis还是Spring Data JPA?? - 知乎</a></p><hr><p>使用 Spring Data Jpa 仅需要定义接口，并继承 JpaRepository 接口，不需要编写实现类，也不需要编写 XML 映射文件。Spring Data Jpa 默认提供简单的 CRUD 方法，并支持自动根据方法名生成 SQL，提供注解方式动态生成 SQL，也支持分页、排序。</p><p>个人更喜欢在分布式微服务项目中使用 Spring Data Jpa，特别是使用领域驱动设计架构设计的项目，而在管理后台项目使用 Mybatis。</p><p>因为管理后台需要更灵活的查询支持，经常写些复杂的 SQL，在这方面 Jpa 显得较弱势，而分布式微服务项目实现业务的核心逻辑，只需要用到简单的数据查询、删增改，因此较适合使用 Jpa。</p><p>@ref: <a href="https://juejin.cn/post/6932485961532063752" target="_blank" rel="noopener">Mybatis与Spring Data Jpa怎么选？ - 掘金</a></p><h2 id="Hibernate-MyBatis"><a href="#Hibernate-MyBatis" class="headerlink" title="Hibernate - MyBatis"></a>Hibernate - MyBatis</h2><p>Hibernate 和 Mybatis 都是 <strong>ORM 持久层框架</strong>，</p><p>Hibernate 提供的是一种全表映射的模型，对 JDBC 的封装程度比较高。但 Hibernate 也有不少缺点：</p><ul><li>全表映射带来的不便，比如更新时需要发送所有的字段；</li><li>无法根据不同的条件组装不同的SQL；</li><li>对多表关联和复杂SQL查询支持较差，需要自己写SQL，返回后，需要自己将数据组装为POJO；</li><li>不能有效支持存储过程；</li><li>虽然有HQL，但性能较差，大型互联网系统往往需要优化SQL，而Hibernate做不到。</li></ul><p>大型互联网环境中，灵活、SQL 优化，减少数据的传递是最基本的优化方法，Hibernate 无法满足要求，而 MyBatis 是一个半自动映射的框架，提供了更灵活、方便的方式。</p><p>MyBatis需要手工匹配提供POJO、SQL和映射关系，而全表映射的Hibernate只需要提供POJO和映射关系。</p><h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>在 Spring 项目中引入 MyBatis 支持 @link <a href="/13.JavaEE-Framework/JavaEE.SpringMVC/" title="JavaEE.SpringMVC">JavaEE.SpringMVC</a><br>主要是定义 SqlSessionFactory、DataSource 和 Mapper。</p><p>Mybatis 四大核心类：</p><ul><li>SqlSessionFactoryBuilder：会根据配置信息或代码来生成 SqlSessionFactory；</li><li>SqlSessionFactory：依靠工厂来生成SqlSession；</li><li>SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口；</li><li>SQL Mapper：是MyBatis新设计的组件，由一个Java接口和XML文件构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。</li></ul><ul><li><a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">MyBatis 3 | 入门</a></li><li><a href="https://gitbook.cn/books/5a37b6b66eec7c4f044a75d0/index.html" target="_blank" rel="noopener">通过源码深入理解 SQL 的执行过程</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">MyBatis的架构设计以及实例分析</a></li></ul><h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><ul><li><a href="https://www.w3cschool.cn/hibernate/" target="_blank" rel="noopener">Hibernate 教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一些概念：JDBC-amp-PJA-amp-ORM&quot;&gt;&lt;a href=&quot;#一些概念：JDBC-amp-PJA-amp-ORM&quot; class=&quot;headerlink&quot; title=&quot;一些概念：JDBC &amp;amp; PJA &amp;amp; ORM&quot;&gt;&lt;/a&gt;一些概念：JDBC &amp;amp; PJA &amp;amp; ORM&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;JDBC&lt;/strong&gt; (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;JPA&lt;/strong&gt; 全称为Java Persistence API ，Java持久化API是Sun公司在Java EE 5规范中提出的Java持久化接口。JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。使用JPA持久化对象，并不是依赖于某一个ORM框架。&lt;br&gt;JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现，JBoss应用服务器底层就以Hibernate作为JPA的实现。&lt;br&gt;虽然 ORM 框架都实现了 JPA 规范，但是在不同 ORM 框架之间切换是需要编写的代码有一些差异，而通过使用 Spring Data Jpa 能够方便大家在不同的 ORM 框架中间进行切换而不要更改代码。并且 Spring Data Jpa 对 Repository 层封装的很好，可以省去不少的麻烦。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="13.J2EE" scheme="https://beefyheisenberg.github.io/categories/13-J2EE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="ORM" scheme="https://beefyheisenberg.github.io/tags/ORM/"/>
    
    <category term="MyBatis" scheme="https://beefyheisenberg.github.io/tags/MyBatis/"/>
    
    <category term="Hibernate" scheme="https://beefyheisenberg.github.io/tags/Hibernate/"/>
    
  </entry>
  
</feed>
