<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扔掉笔记 ᐛ</title>
  
  <subtitle>dropNotes</subtitle>
  <link href="https://beefyheisenberg.github.io/atom.xml" rel="self"/>
  
  <link href="https://beefyheisenberg.github.io/"/>
  <updated>2023-08-28T12:41:28.816Z</updated>
  <id>https://beefyheisenberg.github.io/</id>
  
  <author>
    <name>beefyheisenberg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>后端架构：System Design</title>
    <link href="https://beefyheisenberg.github.io/31.Backend/SystemDesign-00-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    <id>https://beefyheisenberg.github.io/31.Backend/SystemDesign-00-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/</id>
    <published>2023-08-28T12:41:28.815Z</published>
    <updated>2023-08-28T12:41:28.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些概念和测试基准"><a href="#一些概念和测试基准" class="headerlink" title="一些概念和测试基准"></a>一些概念和测试基准</h1><p>本章内容包括: 系统可用性的概念和指标, 系统性能的概念和指标, 如何严谨地做性能测试.</p><h2 id="系统可用性的概念和指标"><a href="#系统可用性的概念和指标" class="headerlink" title="系统可用性的概念和指标"></a>系统可用性的概念和指标</h2><p><strong>高可用性</strong>（high availability，缩写为 HA），IT术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行<br>其度量方式，是根据系统损害、无法使用的时间，以及由无法运作恢复到可运作状况的时间，与系统总运作时间的比较。计算公式为:<br><img src="/images/system_design/Arch-HA-Exp.png" alt=""></p><p>A（可用性），MTBF(平均故障间隔)，MDT(平均修复时间)<br>在线系统和执行关键任务的系统通常要求其可用性要达到5个9标准(99.999%)。</p><ul><li>3个9：(1-99.9%) x 365 x 24 =8.76小时，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是8.76小时。</li><li>4个9：(1-99.99%) x 365 x 24 =0.876小时=52.6分钟，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是52.6分钟。</li><li>5个9：(1-99.999%) x 365 x 24 x 60 =5.26分钟，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是5.26分钟。</li></ul><p>那么X个9里的X只代表数字3~5，为什么没有1~2，也没有大于6的呢？我们接着往下计算：</p><ul><li>1个9：(1-90%)x365=36.5天</li><li>2个9：(1-99%)x365=3.65天</li><li>6个9：(1-99.9999%)x365x24x60x60=31秒</li></ul><p>可以看到1个9和、2个9分别表示一年时间内业务可能中断的时间是36.5天、3.65天，这种级别的可靠性或许还不配使用“可靠性”这个词；而6个9则表示一年内业务中断时间最多是31秒，那么这个级别的可靠性并非实现不了，而是要做到从5个9》6个9的可靠性提升的话，后者需要付出比前者几倍的成本，所以在企业里大家都只谈（3~5）个9。</p><h2 id="系统性能的概念和指标"><a href="#系统性能的概念和指标" class="headerlink" title="系统性能的概念和指标"></a>系统性能的概念和指标</h2><p>① 系统延迟(Latency): 系统在处理一个请求或一个任务时的延迟, 有平均值, 中位数, TP 三种衡量指标:</p><ol><li>平均值(Avg): 延迟的评测性能指标原则: <strong>不要用平均值!</strong>  例如测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况</li><li>中位数（Mean）: 可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。</li><li>TP指标(Top Percentile): <strong>这是最为正确的统计做法</strong> ，也就是英文中的 Top Percentile ，Top百分数，是一个统计学里的术语，与平均数、中位数都是一类。<ul><li>TP50：指在一个时间段内（如5分钟），统计该方法每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序，取第50%的那个值作为TP50 值；正确使用TP50做监控: 配置此监控指标对应的报警阀值后，需要保证在这个时间段内该方法所有调用的消耗时间至少有50%的值要小于此阀值，否则系统将会报警。</li><li>TP90: 通过上面的定义, 90%的请求中最长耗时; TP90也即要求 比这个耗时还长的请求次数 比例应该在总次数的10%以下</li><li>TP99: 与TP50/90值计算方式一致，它们分别代表着对方法的不同性能要求，TP50相对较低，TP90则比较高，TP99，TP999则对方法性能要求很高</li></ul></li></ol><blockquote><p>Amazon AWS 定义的 P99: <a href="https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/health-enhanced-metrics.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/health-enhanced-metrics.html</a></p></blockquote><p>② 吞吐量(Throughput): 每秒可处理的请求数/事务数, 等于<code>并发数/平均响应时间</code></p><ul><li><strong>QPS</strong>: Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。可用由PV粗略计算QPS的两种方法:<ul><li>按照每天80%的请求集中在20%的时间, <code>峰值QPS= (PV*80%) / (24*3600*20%)</code></li><li>按照峰值QPS是评价QPS的三倍计算, <code>峰值QPS= (PV*3) / (24*3600)</code></li></ul></li><li><strong>TPS</strong>: Transactions Per Second, 也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。</li></ul><blockquote><p>Java GC回收器的评估指标里也有吞吐量的概念: 系统总运行时间 = 应用程序耗时 + 总GC耗时。</p></blockquote><p>③ 除了 Latency 和 Throughtput , 其他的性能衡量指标还有:</p><ul><li>PV: page view</li><li>UV: user view;</li><li>VU: 并发用户数, 也叫虚拟用户数(VU), 同时请求系统的用户数. 一般情况下, 大型系统（业务量大、机器多）做性能测试 5000 个并发用户就够了, 中小型系统做性能测试 1000 个并发用户就足够了;</li></ul><h2 id="如何严谨地做性能测试"><a href="#如何严谨地做性能测试" class="headerlink" title="如何严谨地做性能测试"></a>如何严谨地做性能测试</h2><p>一般来说，性能测试要统一考虑这么几个因素：Thoughput吞吐量，Latency响应时间，资源利用（CPU/MEM/IO/Bandwidth…），成功率，系统稳定性。</p><ul><li>一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。</li><li>二，在这个响应时间的限制下，找到最高的吞吐量。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。</li><li>三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能</li><li>四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。</li><li>五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。</li><li>六、低吞吐量和网络小包的测试。有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。</li></ul><blockquote><p>@ref  <a href="https://coolshell.cn/articles/17381.html" target="_blank" rel="noopener">性能测试应该怎么做？ | | 酷 壳 - CoolShell</a></p></blockquote><h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><p>本章内容包括: 负载均衡, 限流, 隔离, 降级, 超时与重试, 回滚, 压测与预案.</p><h2 id="负载均衡与反向代理-Nginx"><a href="#负载均衡与反向代理-Nginx" class="headerlink" title="负载均衡与反向代理(Nginx)"></a>负载均衡与反向代理(Nginx)</h2><p>这里不再介绍Nginx的具体配置</p><h3 id="负载均衡-loadbalance"><a href="#负载均衡-loadbalance" class="headerlink" title="负载均衡(loadbalance)"></a>负载均衡(loadbalance)</h3><p>Nginx目前提供了HTTP七层负载均衡(ngx_http_upstream_module), 意思是在OSI第七层应用层的负载均衡, 1.9版本也开始提供TCP四层负载均衡(ngx_stream_upstream_module)</p><h4 id="upstream服务器配置"><a href="#upstream服务器配置" class="headerlink" title="upstream服务器配置"></a>upstream服务器配置</h4><p>略</p><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>几种负载均衡算法:</p><ul><li>轮询（Round Robin）</li><li>加权轮询（Weight Round Robin）</li><li>随机（Random）</li><li>加权随机（Weight Random）</li><li>源地址哈希（Hash）</li><li>一致性哈希（ConsistentHash）</li><li>最小连接数（Least Connections）</li><li>低并发优先（Active Weight）</li></ul><p>Nginx配置中常用的负载均衡:</p><ul><li>round robin(轮询): 默认的</li><li>ip哈希:<code>ip_hash</code>, 根据客户端ip</li><li>哈希:<ul><li><code>hash $uri</code>:根据uri进行哈希</li><li><code>hash $key consistent</code>:一致性哈希</li></ul></li></ul><p><strong>一致性哈希(consistent hashing)</strong>:<br>在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对K/n个关键字重新映射，其中K是哈希关键字的数量(也就是Key)，n是槽位数量(槽位指的是Node的槽位)。<br>然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p><p>一致性哈希vs传统哈希的优势:</p><ul><li>新增/减少节点, 传统哈希需要对全部Key做rehash, 一致性哈希只需…</li><li>新增/减少节点, rehash影响的节点少, 理论上只影响相邻的节点</li></ul><p>一致性哈希过程: </p><ol><li>首先求出服务器（节点）的哈希值，并将其配置到0～2^32的圆（continuum）上。// 为什么哈希范围是2^32?  当服务节点太少时，容易因为节点分部不均匀而造成数据倾斜。这种一般通过增加虚拟节点的方式解决</li><li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li><li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台memcached服务器上。</li></ol><p><img src="/images/system_design/consistent-hash.png" alt="consistent-hash"></p><ol start="4"><li>如果增加一个服务器节点, 如下图, 新增 node5 节点, 只有在圆（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响</li></ol><p><img src="/images/system_design/consistnet-hash-add-node.png" alt="consistnet-hash-add-node"></p><h4 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h4><p>主要针对在Nginx的<code>upstream</code>和<code>proxy_pass</code>进行配置, 作用是实现”多少时间内失败多少次, 则从upstream列表里摘除”</p><h4 id="upstream心跳检查"><a href="#upstream心跳检查" class="headerlink" title="upstream心跳检查"></a>upstream心跳检查</h4><p>失败重试是被动的去摘除upstream无效机器, 心跳检测可以认为是一种主动的检查并摘除无效机器, 主要在<code>upstream</code>的<code>check</code>里, 有http和tcp两种</p><h3 id="长连接-keepalive"><a href="#长连接-keepalive" class="headerlink" title="长连接(keepalive)"></a>长连接(keepalive)</h3><ol><li>client 与 nginx之间的长连接: <code>http</code>里的<code>keepalive_timeout 300s 300s;</code><ul><li>第一个参数: client和nginx建立的长连接, 如果在此时间内没有实际消息发送, nginx将主动关闭此连接（默认是75秒)</li><li>第二个参数: nginx向client发送response的http头, 其中的<code>Keep-Alive: timeout=xx</code></li></ul></li><li>nginx 与 upstream之间的长连接: <code>upstream</code>里的<code>keepalive 100</code>这里的100指的是”每个Worker与upstream服务器可缓存的最大连接数”</li></ol><p>参考: <a href="/31.Backend/反向代理-Nginx/" title="反向代理-Nginx">反向代理-Nginx</a></p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p><h3 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h3><p>即可以降级的功能点, 降级服务需要从服务端链路考虑, 根据用户访问的服务调用链路决定哪里可以降级. 一般情况下可以考虑降级的点有:</p><ul><li>页面降级(整个页面or页面片段):非核心业务的页面, 在紧急情况下可以降级, 可以利用nginx把该页面直接跳转一个静态页</li><li>页面异步请求:比如异步加载的信息, 在紧急情况下可以降级</li><li>非核心功能降级:比如商品详情页的推荐/热销</li><li>读降级:紧急情况下只读缓存, 适用于一致性要求不高的情况</li><li>写降级:在高并发抢购这种情景下, 可以先更新cache, 然后异步写回数据库</li><li>风控降级:识别机器人, 根据用户画像和用户风控等级降级, 需要提前做好用户风控等级的功能</li></ul><blockquote><p>降级后的处理方式一般有:返回默认值, 返回静态页面, 从缓存读数据而不是数据库</p></blockquote><h3 id="自动降级"><a href="#自动降级" class="headerlink" title="自动降级"></a>自动降级</h3><ul><li>超时降级: 访问数据库 或 非本地接口(RPC, HTTP)超时, 需要提前设置合理的超时时间/重试机制/重试次数</li><li>故障降级: 远程调用的接口RPC抛异常, HTTP服务500错误等,</li><li>流量降级: 超过限流阈值时..</li></ul><h3 id="手动开关降级"><a href="#手动开关降级" class="headerlink" title="手动开关降级"></a>手动开关降级</h3><p>开关可以放在Redis, Zookeeper上.</p><h3 id="读写服务降级"><a href="#读写服务降级" class="headerlink" title="读写服务降级"></a>读写服务降级</h3><ul><li>库存扣减案例: 正常情况下扣减Redis, 同步扣减DB, 当流量过大时, 降级为发送一条扣减消息, 然后异步写入DB实现最终一致性</li></ul><h3 id="多级降级"><a href="#多级降级" class="headerlink" title="多级降级"></a>多级降级</h3><p>从用户到系统, 降级离用户越近, 最终落到后端系统的QPS越低, 对后端系统的保护就越好</p><ul><li>页面JS降级开关</li><li>接入层降级开关, 一般是Nginx</li><li>后端应用降级开关</li></ul><h3 id="通过-Hystrix实现熔断降级"><a href="#通过-Hystrix实现熔断降级" class="headerlink" title="通过 Hystrix实现熔断降级"></a>通过 Hystrix实现熔断降级</h3><p>@todo</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>@todo</p><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>几种常用<strong>容错策略</strong>：</p><ul><li>失效转移（failover）: 当出现失败，重试其他服务器，通常用于读操作等幂等行为(保证调用 1 次与 N 次效果相同)，重试会带来更长延迟。</li><li>快速失败（failfast）: 只发起一次调用，失败立即报错，通常用于非幂等性的写操作。</li><li>失效安全（failsafe）: 出现异常时忽略，但记录这一次失败，存入日志中。// 失败安全策略的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。</li><li>失败通知（failback）: 客户端需要能够获取到服务调用失败的具体信息，通过对失败错误码等异常信息的判断，决定后续的执行策略，例如非幂等性的服务调用。// Dubbo中的Failback策略中，如果调用失败，则此次失败相当于Failsafe，将返回一个空结果。而与Failsafe不同的是，Failback策略会将这次调用加入内存中的失败列表中，对于这个列表中的失败调用，会在另一个线程中进行异步重试，重试如果再发生失败，则会忽略，即使重试调用成功，原来的调用方也感知不到了。因此它通常适合于，对于实时性要求不高，且不需要返回值的一些异步操作。</li></ul><h2 id="超时与重试"><a href="#超时与重试" class="headerlink" title="超时与重试"></a>超时与重试</h2><p>在实际开发过程中，笔者见过太多故障是因为没有设置超时或者设置得不对而造成的。而这些故障都是因为没有意识到超时设置的重要性而造成的。如果应用不设置超时，则可能会导致请求响应慢，慢请求累积导致连锁反应，甚至造成应用雪崩。<br>而有些中间件或者框架在超时后会进行重试（如设置超时重试两次），读服务天然适合重试，但写服务大多不能重试（如写订单，如果写服务是幂等的，则重试是允许的），重试次数太多会导致多倍请求流量，即模拟了DDoS攻击，后果可能是灾难，因此，务必设置合理的重试机制，并且应该和熔断、快速失败机制配合。</p><h3 id="Nginx超时设置"><a href="#Nginx超时设置" class="headerlink" title="Nginx超时设置"></a>Nginx超时设置</h3><ol><li>客户端超时设置: 对于客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。<ul><li><code>keepalive_timeout time [header_timeout]</code>：<ul><li>time默认是75s,  表示长连接的超时时间(客户端在75s期间没有任何请求,  Nginx将会主动发送FIN关闭连接);</li><li>header_timeout会通过HTTP头<code>Keep-Alive: timeout=xx</code>告知客户端长连接超时时间,</li></ul></li></ul></li><li>上游服务器(upstream)超时:<ul><li>超时设置:<code>proxy_connect_timeout time</code>：与后端/上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</li><li>重试设置:<ul><li><code>proxy_next_upstream_tries number</code>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</li><li><code>proxy_next_upstream_timeout time</code>：设置重试最大超时时间，默认0表示不限制。</li></ul></li></ul></li><li>DNS解析超时:  @todo</li></ol><h3 id="Web容器超时设置"><a href="#Web容器超时设置" class="headerlink" title="Web容器超时设置"></a>Web容器超时设置</h3><p>以Tomcat为例:</p><ul><li><code>connectionTimeout</code>: 当client与tomcat建立连接之后, 在”connectionTimeout”时间之内, 仍然没有得到client的请求数据, 此时连接将会被断开, connectionTimeout只会在链接建立之后, 得到client发送http-request信息前有效.</li><li><code>socket.soTimeout</code>: 从收到client请求后,  到返回数据, 这段超时时间  @doubt</li><li><code>keepAliveTimeout</code>: 当无实际数据交互时，连接被保持的时间，单位：毫秒。在未指定此属性时，将使用connectionTimeout作为keepAliveTimeout。</li></ul><blockquote><p>不过我们通常在tomcat前面还有nginx等代理服务器，我们通常希望链接keepAlive的机制由代理服务器控制，比如nginx来决定链接是否需要“保持活性”（注意，与keep_alive不同），当然nginx服务器只会保留极少的长连接，几乎所有的链接都会在使用结束后主动close；有nginx与client保持，而不再是tomcat与client保持。</p></blockquote><h3 id="Apache-HttpClient-客户端-超时设置"><a href="#Apache-HttpClient-客户端-超时设置" class="headerlink" title="Apache HttpClient(客户端)超时设置"></a>Apache HttpClient(客户端)超时设置</h3><ul><li>connectionTimeout: 建立连接超时时间,  指Client发出请求后,  到建立连接这段超时时间,  如果在该时间仍没有完成连接的建立会抛出connectionTimeout异常;</li><li>socketTimeout: 等待响应超时时间,  指Client对Url发起请求(连接已经建立),  到收到服务端的Response这段超时时间</li></ul><h3 id="数据库客户端连接超时设置"><a href="#数据库客户端连接超时设置" class="headerlink" title="数据库客户端连接超时设置"></a>数据库客户端连接超时设置</h3><p>@todo</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章主要介绍了如何在Web应用访问的整个链路上进行超时时间设置。通过配置合理的超时时间，防止出现某服务的依赖服务超时时间太长且响应慢，以致自己响应慢甚至崩溃。<br>客户端和服务器端都应该设置超时时间，而且客户端根据场景可以设置比服务器端更长的超时时间。如果存在多级依赖关系，如A调用B，B调用C，则超时设置应该是A&gt;B&gt;C，否则可能会一直重试，引起DDoS攻击效果。不过最终如何选择还是要看场景，有时候客户端设置的超时时间就是要比服务器端的短，可以通过在服务器端实施限流/降级等手段防止DDoS攻击。</p><p>超时之后应该有相应的策略来处理，常见的策略有重试（等一会儿再试、尝试其他分组服务、尝试其他机房服务，重试算法可考虑使用如指数退避算法）、摘掉不存活节点（负载均衡/分布式缓存场景下）、托底（返回历史数据/静态数据/缓存数据）、等待页或者错误页。对于非幂等写服务应避免重试，或者可以考虑提前生成唯一流水号来保证写服务操作通过判断流水号来实现幂等操作。<br>在进行数据库/缓存服务器操作时，记得经常检查慢查询，慢查询通常是引起服务出问题的罪魁祸首。也要考虑在超时严重时，直接将该服务降级，待该服务修复后再取消降级。</p><p>对于有负载均衡的中间件，请考虑配置心跳/存活检查，而不是惰性检查。<br>超时重试必然导致请求响应时间增加，最坏情况下的响应时间=重试次数×单次超时时间，这很可能严重影响用户体验，导致用户不断刷新页面来重复请求，最后导致服务接收的请求太多而挂掉，因此除了控制单次超时时间，也要控制好用户能忍受的最长超时时间。<br>超时时间太短会导致服务调用成功率降低，超时时间太长又会导致本应成功的调用却失败了，这也要根据实际场景来选择最适合当前业务的超时时间，甚至是程序动态自动计算超时时间。<br>比如商品详情页的库存状态服务，可以设置较短的超时时间，当超时时降级返回有货，而结算页服务就需要设置稍微长一些的超时时间保证确实有货。在实际开发中，不要轻视超时时间，很多重大事故都是因为超时时间不合理导致的，设置超时时间一定是只有好处没有坏处的，请立即Review你的代码吧。</p><blockquote><p>回顾: TCP协议里的重试机制:<br>Client发给Server端SYN包后, Server端要返给Client一个SYN-ACK, 然后Server要等待Client发过来的ACK,<br>Server发送SYN-ACK并等待ACK的过程是有重试机制的, 重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s。</p></blockquote><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><ul><li>进线程隔离</li><li>集群隔离</li><li>机房隔离</li><li>读写隔离</li><li>动静隔离: 静态资源放CDN</li><li>爬虫隔离</li><li>热点隔离: 诸如秒杀, 抢购做成独立系统</li><li>资源隔离</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><ul><li>令牌桶:</li><li>漏桶:</li></ul><h3 id="应用级限流"><a href="#应用级限流" class="headerlink" title="应用级限流"></a>应用级限流</h3><ul><li>限制总并发数/连接数: Tomcat的几个参数 acceptCount, maxConnections, maxThreads</li><li>限制单个接口的请求数:<ul><li>限制某个时间窗口的请求数:用Guava的Cache, 时间戳做Key, 访问次数AtomicLong做Value. . . 缺点是无法应对突发流量, 瞬时请求可能都被允许</li><li>平滑限流:Guava的RateLimiter提供的令牌桶算法可以对请求进行速率平均化, 比如5request/秒, 每隔200ms处理一个请求</li></ul></li></ul><h3 id="Nginx层限流"><a href="#Nginx层限流" class="headerlink" title="Nginx层限流"></a>Nginx层限流</h3><p>Nginx提供了两个限流模块:</p><ul><li>限制总并发数的<code>ngx_http_limit_conn_module</code></li><li>漏桶算法的<code>ngx_http_limit_req_module</code></li></ul><h1 id="高性能方案"><a href="#高性能方案" class="headerlink" title="高性能方案"></a>高性能方案</h1><p>本章内容: 缓存, 连接池, 异步并发, 数据库拆分, 任务系统拆分, 队列.</p><p>有关C10K、C100K单机系统，参考： <a href="https://whatsrtos.github.io/基础架构/Arch-架构-并发系统-C100K/" target="_blank" rel="noopener">架构-并发系统-C100K</a></p><h2 id="应用级缓存"><a href="#应用级缓存" class="headerlink" title="应用级缓存"></a>应用级缓存</h2><p>本章以Java应用缓存为例.</p><h3 id="缓存回收策略"><a href="#缓存回收策略" class="headerlink" title="缓存回收策略"></a>缓存回收策略</h3><ul><li>基于空间和容量: 超过xx时回收</li><li>基于存活时间(TTL): 缓存数据从创建开始计算, 过期则清除</li><li>基于Java GC:<ul><li>软引用</li><li>弱引用</li></ul></li><li>基于回收算法:<ul><li>FIFO</li><li>LRU: Least Recently Used, 最近最不常访问的被淘汰, 访问时间距离现在最久远的被淘汰(较常用)</li><li>LFU: Least Frequently Used, 在一段时间内访问次数最少的被淘汰, 访问频率最少的被淘汰(可能需要预热)</li></ul></li></ul><h3 id="Java应用级缓存的类型"><a href="#Java应用级缓存的类型" class="headerlink" title="Java应用级缓存的类型"></a>Java应用级缓存的类型</h3><ul><li>堆内缓存: 用Java软引用/弱引用对象作为缓存, 不需要序列化. Guava的Cache, Ehcache3.x</li><li>堆外缓存: 缓存在JVM内存之外, 减少GC次数, 但是需要序列化的时间开销, Ehcache3.x, MapDB</li></ul><h3 id="缓存的设计模式"><a href="#缓存的设计模式" class="headerlink" title="缓存的设计模式"></a>缓存的设计模式</h3><p>首先介绍三个名词:</p><ul><li><strong>SoR</strong>(SystemofRecord): 记录系统, 一般是DB;</li><li><strong>Cache</strong>: Cache的访问速度比SoR要快, 数据放在Cache中可以提升访问速度, 减少回源次数;</li><li><strong>回源</strong>: 缓存没有命中, 需要去SoR取数据, 这叫做回源;</li></ul><h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h4><p>即代码围绕着缓存写, 由业务层的代码读取/更新缓存.</p><ul><li>读:先读Cache, 没有读到再读SoR, 并更新Cache</li><li>写(更新):<ul><li>方案1: 先更新SoR, 再更新Cache</li><li>方案2: 先更新SoR, 再失效Cache, 读取的时候再把SoR的数据写入Cache</li></ul></li></ul><p>CacheAside存在的问题:<br>如果并发更新Cache, 会出现Cache和SoR数据不一致的情况(A更新了SoR, 还没来得及更新Cache, B线程插入进来更新SoR并更新Cache, 之后A线程更新Cache), 这种有两种解决方式:</p><ol><li>用canal订阅数据库(SoR)的 binlog, 增量更新Cache, 缓存的更新会有延迟;</li><li>通过对请求合理的hash, 让同一个读服务落到同一个实例;</li></ol><h4 id="Cache-as-SoR"><a href="#Cache-as-SoR" class="headerlink" title="Cache as SoR"></a>Cache as SoR</h4><p>即Cache和SoR是一个整体, 业务层代码只对Cache进行读写, 然后Cache再委托给SoR进行真实的读写. 有三种实现模式: Read-Throught, Write-Throught, Write-Behind:</p><ul><li>Read-Throught: 读cache, 如果没有读到, 由cache把SoR的数据更新到缓存里. GuavaCache提供了此模式, 创建Cache时需要指定一个CacheLoader, 从Cache未能读到数据时, GuavaCache委托CacheLoader从SoR读取, 用户代码只需要调用<code>cache.get()</code></li><li>Write-Throught: 用户调用<code>cache.set()</code>, 缓存更新后, 同步写到SoR, 不需要用户代码干预</li><li>Write-Behind: 与上面的区别是, Write-Behind是异步批量写SoR</li></ul><h4 id="Copy-Pattern"><a href="#Copy-Pattern" class="headerlink" title="Copy Pattern"></a>Copy Pattern</h4><ul><li>Copy-On-Read: 读时复制</li><li>Copy-On-Write: 写时复制</li></ul><h2 id="数据库拆分-分库分表"><a href="#数据库拆分-分库分表" class="headerlink" title="数据库拆分(分库分表)"></a>数据库拆分(分库分表)</h2><ul><li>垂直切分: 一般根据业务来<ul><li>垂直分表: 通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中</li><li>垂直分库: 按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。</li></ul></li><li>水平切分:<ul><li>哈希分库: 比如根据自增主键对库的总数取余操作, 可以多次哈希, 第一次哈希分库, 第二次分表:<ul><li>例子: UserId后四位mod32分到32个库中，同时再将UserId后四位Div32Mod32将每个库分为32个表，共计分为1024张表。</li></ul></li><li>范围分库: 比如根据自增主键范围切分,<ul><li>优点: 单表大小可控，天然水平扩展。</li><li>缺点: 无法解决集中写入瓶颈的问题。</li></ul></li></ul></li></ul><h3 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h3><ul><li>跨库join的问题解决方案:<ul><li>字段冗余</li><li>Redis存储索引</li></ul></li><li>夸库事务: @todo</li></ul><h2 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h2><ul><li>利用数据库自增ID:<ul><li>优点：最简单。</li><li>缺点：单点风险、单机性能瓶颈。</li></ul></li><li>TwitterSnowflake<ul><li>优点：高性能高可用、易拓展。</li><li>缺点：需要独立的集群以及ZK。</li></ul></li><li>UUID, GUID</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>这里是一些”一句话解决方案”.</p><h2 id="最佳实践list"><a href="#最佳实践list" class="headerlink" title="最佳实践list"></a>最佳实践list</h2><ul><li>LVS/F5/HAProxy负载均衡 -&gt; Nginx/Apache -&gt; Redis/Memcached</li><li>Kafka，ActiveMQ负责解耦的消息队列</li><li>RPC框架Thrift, 序列化Protobuf</li><li>分布式框架Zookeeper</li><li>Mysql分表分库的Cobar</li><li>通用搜索引擎ElasticSearch</li></ul><h2 id="如何存储密码"><a href="#如何存储密码" class="headerlink" title="如何存储密码"></a>如何存储密码</h2><ul><li>bcrypt:带盐的散列算法, 可以指定costfactor, 10表示2^10次方次运算, 返回的散列值包括盐和加密后的文本</li><li><a href="http://www.infoq.com/cn/news/2016/12/How-Dropbox-securely-passwords" target="_blank" rel="noopener">Dropbox是如何安全地存储用户密码的</a> : <code>AES256(bcrypt(SHA512(pwd), salt(10)))</code></li><li><a href="https://www.zhihu.com/question/20299384" target="_blank" rel="noopener">加盐密码保存的最通用方法是？ - 知乎</a> @todo</li></ul><p><img src="/images/how-to-store-pwds-in-db.png" alt=""></p><hr><h1 id="附录-名词解释"><a href="#附录-名词解释" class="headerlink" title="附录:名词解释"></a>附录:名词解释</h1><ul><li>高可用High-Availability、高可扩展性(高可伸缩性)High-Scalability</li><li>解耦LooselyCoupled</li><li>吞吐量Throughput（QPS/TPS)、并发量C10K</li><li>冗余Redundancy、分区Partitions、缓存Caches、代理Proxies、索引Indexes、队列Queues</li><li>集群Cluster、主从Master-Slave、水平/垂直切分Sharding</li><li>请求负载均衡LoadBalancing、请求路由Route、状态复制Replication</li><li>故障转移Failover、故障回复Failback、心跳检测Healthcheck/Heartbeat</li><li>纵向扩展Scale-up、横向扩展Scale-out</li><li>自动升降级Auto-upgrade/downgrade</li><li>scaleup:纵向扩展, 指提高单台机器的存储(RAM, HD)上限</li><li>scaleout:横向扩展, 多台主机</li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳</a></li><li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a></li></ul><p><img src="/images/system_design/亿级流量网站架构核心技术.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一些概念和测试基准&quot;&gt;&lt;a href=&quot;#一些概念和测试基准&quot; class=&quot;headerlink&quot; title=&quot;一些概念和测试基准&quot;&gt;&lt;/a&gt;一些概念和测试基准&lt;/h1&gt;&lt;p&gt;本章内容包括: 系统可用性的概念和指标, 系统性能的概念和指标, 如何严谨地做性能测试.&lt;/p&gt;
&lt;h2 id=&quot;系统可用性的概念和指标&quot;&gt;&lt;a href=&quot;#系统可用性的概念和指标&quot; class=&quot;headerlink&quot; title=&quot;系统可用性的概念和指标&quot;&gt;&lt;/a&gt;系统可用性的概念和指标&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;高可用性&lt;/strong&gt;（high availability，缩写为 HA），IT术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行&lt;br&gt;其度量方式，是根据系统损害、无法使用的时间，以及由无法运作恢复到可运作状况的时间，与系统总运作时间的比较。计算公式为:&lt;br&gt;&lt;img src=&quot;/images/system_design/Arch-HA-Exp.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;A（可用性），MTBF(平均故障间隔)，MDT(平均修复时间)&lt;br&gt;在线系统和执行关键任务的系统通常要求其可用性要达到5个9标准(99.999%)。&lt;/p&gt;</summary>
    
    
    
    <category term="31.Backend" scheme="https://beefyheisenberg.github.io/categories/31-Backend/"/>
    
    
    <category term="后端架构" scheme="https://beefyheisenberg.github.io/tags/后端架构/"/>
    
    <category term="缓存" scheme="https://beefyheisenberg.github.io/tags/缓存/"/>
    
    <category term="架构" scheme="https://beefyheisenberg.github.io/tags/架构/"/>
    
    <category term="System Design" scheme="https://beefyheisenberg.github.io/tags/System-Design/"/>
    
    <category term="高可用" scheme="https://beefyheisenberg.github.io/tags/高可用/"/>
    
    <category term="高性能" scheme="https://beefyheisenberg.github.io/tags/高性能/"/>
    
    <category term="负载均衡" scheme="https://beefyheisenberg.github.io/tags/负载均衡/"/>
    
    <category term="限流" scheme="https://beefyheisenberg.github.io/tags/限流/"/>
    
    <category term="分库分表" scheme="https://beefyheisenberg.github.io/tags/分库分表/"/>
    
    <category term="消息队列" scheme="https://beefyheisenberg.github.io/tags/消息队列/"/>
    
  </entry>
  
  <entry>
    <title>Golang Tutorials-02并发</title>
    <link href="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.02.%E5%B9%B6%E5%8F%91/"/>
    <id>https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.02.%E5%B9%B6%E5%8F%91/</id>
    <published>2023-08-28T12:41:28.195Z</published>
    <updated>2023-08-28T12:41:28.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chan-amp-select"><a href="#chan-amp-select" class="headerlink" title="chan &amp; select"></a>chan &amp; select</h1><ul><li><p>chan 是并发安全的通信对象，读写使用示例:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用make 创建一个存储int 类型的chan:</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向chan写入:</span></span><br><span class="line">ch1 &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从chan读出:</span></span><br><span class="line">i := &lt;-ch1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过ok判断ch里是否有数据</span></span><br><span class="line">i, ok := &lt;-ch1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不接受返回值的读:</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br></pre></td></tr></table></figure></li><li><p>带缓冲区的 chan: <code>ch := make(chan int, 100)</code></p><ul><li>不带缓冲区的 channel, 如果 ch 已经有数据, 再向 ch 写数据会导致写入方阻塞, 如果 ch 空, 读取方会阻塞</li><li>带缓冲区的 channel, 如果 ch 没满, 写入方不会阻塞</li></ul></li><li><p>channel 的关闭: <code>close(channel)</code>，：</p><ul><li>只能由 sender 关闭；</li><li>调用 close 后，如果 sender 继续写入数据，会 panic；</li><li>调用 close 后，receiver 接收完最后一个元素，chan 为关闭状态，尝试从 chan 读取动作不会阻塞，而是立刻返回 success；</li></ul></li><li><p>使用 <code>select</code> 监视一组 chan, 并从已经准备好的 chan 里随机选出一个, 用法类似 switch, 每个 case 后面是读取 chan 的操作:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> i := &lt;-ch1:</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  <span class="keyword">case</span> j := &lt;-ch2:</span><br><span class="line">    fmt.Println(j)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p>chan 的内部实现，@ref: <a href="https://zhuanlan.zhihu.com/p/395278270?utm_id=0" target="_blank" rel="noopener">golang 系列：channel 全面解析 - 知乎</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type hchan struct &#123;</span><br><span class="line"> qcount   uint   // channel 里的元素计数</span><br><span class="line"> dataqsiz uint   // 最大可以缓冲的数量</span><br><span class="line"> </span><br><span class="line"> buf      unsafe.Pointer // 该 buf 指向一个循环队列的数据结构</span><br><span class="line"> </span><br><span class="line"> closed   uint32 // 关闭状态</span><br><span class="line"> </span><br><span class="line"> sendx    uint  // 当 channel 设置了缓冲数量时，数据区域即循环队列此时已发送数据的索引位置</span><br><span class="line"> recvx    uint  // 当 channel 设置了缓冲数量时，数据区域即循环队列此时已接收数据的索引位置</span><br><span class="line"> </span><br><span class="line"> recvq    waitq // 想读取数据但又被阻塞住的 goroutine 队列</span><br><span class="line"> sendq    waitq // 想发送数据但又被阻塞住的 goroutine 队列</span><br><span class="line"></span><br><span class="line"> lock mutex</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>chan 使用范例：@ref : <a href="https://zhuanlan.zhihu.com/p/36907022" target="_blank" rel="noopener">深入golang之—goroutine并发控制与通信 - 知乎</a></p><p>CSP模型：Communicating Sequential Process，Go的Channel 和 Actor都算一种实现，二者的区别..</p><p>代码demo功能：主进程和协程通信，主进程等待协程退出</p><ul><li>共享变量实现：考虑这种做法的缺点是？</li><li>Channel + WaitGroup实现</li><li>Context + WaitGroup实现</li></ul><h1 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h1><p>Go 语言在 sync 包中提供了用于同步的一些基本原语，包括常见的 sync.Mutex、sync.RWMutex、sync.WaitGroup、sync.Once 和 sync.Cond</p><p>@todo</p><h1 id="os-exec"><a href="#os-exec" class="headerlink" title="os/exec"></a>os/exec</h1><p>@Ref：<a href="https://colobu.com/2020/12/27/go-with-os-exec/" target="_blank" rel="noopener">go os/exec 简明教程</a></p><p>cmd基本函数：</p><ul><li>cmd.Start() 和 cmd.Wait(), 其他函数的实现可以看做是对Start和Wait的封装</li><li>cmd.Run() = Start() + Wait()</li><li>cmd.CombinedOutput() = cmd. Stdout和cmd.Stderr关联同一个Buffer + Run()<br>cmd属性:<ul><li>标准输出/错误： cmd. Stdout 和 cmd. Stderr属性</li></ul></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</span><br><span class="line"><span class="keyword">var</span> stdout, stderr bytes.Buffer</span><br><span class="line">cmd.Stdout = &amp;stdout <span class="comment">// stdout关联Buffer</span></span><br><span class="line">cmd.Stderr = &amp;stderr</span><br><span class="line"></span><br><span class="line">err := cmd.Start() <span class="comment">// 非阻塞</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to call cmd.Start(): %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"pid: %d"</span>, cmd.Process.Pid)</span><br><span class="line">cmd.Process.Wait() <span class="comment">// 阻塞直到退出</span></span><br><span class="line">log.Printf(<span class="string">"exitcode: %d"</span>, cmd.ProcessState.ExitCode())</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;chan-amp-select&quot;&gt;&lt;a href=&quot;#chan-amp-select&quot; class=&quot;headerlink&quot; title=&quot;chan &amp;amp; select&quot;&gt;&lt;/a&gt;chan &amp;amp; select&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;chan 是并发安全的通信对象，读写使用示例:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用make 创建一个存储int 类型的chan:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ch1 := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 向chan写入:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ch1 &amp;lt;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 从chan读出:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i := &amp;lt;-ch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者通过ok判断ch里是否有数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i, ok := &amp;lt;-ch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 不接受返回值的读:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(&amp;lt;-ch)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;带缓冲区的 chan: &lt;code&gt;ch := make(chan int, 100)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带缓冲区的 channel, 如果 ch 已经有数据, 再向 ch 写数据会导致写入方阻塞, 如果 ch 空, 读取方会阻塞&lt;/li&gt;
&lt;li&gt;带缓冲区的 channel, 如果 ch 没满, 写入方不会阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;channel 的关闭: &lt;code&gt;close(channel)&lt;/code&gt;，：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能由 sender 关闭；&lt;/li&gt;
&lt;li&gt;调用 close 后，如果 sender 继续写入数据，会 panic；&lt;/li&gt;
&lt;li&gt;调用 close 后，receiver 接收完最后一个元素，chan 为关闭状态，尝试从 chan 读取动作不会阻塞，而是立刻返回 success；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;select&lt;/code&gt; 监视一组 chan, 并从已经准备好的 chan 里随机选出一个, 用法类似 switch, 每个 case 后面是读取 chan 的操作:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; i := &amp;lt;-ch1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; j := &amp;lt;-ch2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;?&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;chan 的内部实现，@ref: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/395278270?utm_id=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;golang 系列：channel 全面解析 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type hchan struct &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; qcount   uint   // channel 里的元素计数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; dataqsiz uint   // 最大可以缓冲的数量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; buf      unsafe.Pointer // 该 buf 指向一个循环队列的数据结构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; closed   uint32 // 关闭状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; sendx    uint  // 当 channel 设置了缓冲数量时，数据区域即循环队列此时已发送数据的索引位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; recvx    uint  // 当 channel 设置了缓冲数量时，数据区域即循环队列此时已接收数据的索引位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; recvq    waitq // 想读取数据但又被阻塞住的 goroutine 队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; sendq    waitq // 想发送数据但又被阻塞住的 goroutine 队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; lock mutex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="11.Programming-Language" scheme="https://beefyheisenberg.github.io/categories/11-Programming-Language/"/>
    
    
    <category term="Golang" scheme="https://beefyheisenberg.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang Tutorials-01基础</title>
    <link href="https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.%E5%9F%BA%E7%A1%80/"/>
    <id>https://beefyheisenberg.github.io/11.Programming-Language/Golang-Tutorials.01.%E5%9F%BA%E7%A1%80/</id>
    <published>2023-08-28T12:41:28.190Z</published>
    <updated>2023-08-28T12:41:28.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang中的约定大于配置"><a href="#Golang中的约定大于配置" class="headerlink" title="Golang中的约定大于配置"></a>Golang中的约定大于配置</h1><p>Golang遵循”约定大于配置”(convention over configuratio)的理念:</p><ul><li>小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public)</li><li><p>结构体中的”小写开头的成员”, 在用 <code>json.Marshal</code> 序列化时会被忽略</p></li><li><p>每个文件是一个 package，声明在源文件第一行，<code>package main</code> 是一个特殊的包</p></li><li><p>import as <code>_</code> 和 <code>.</code> 的包:</p><ul><li><code>import . &quot;packageXXX&quot;</code> : 调用包内的函数,不需要再加 <code>packageXXX.</code></li><li><code>import _ &quot;packageXXX&quot;</code> : 匿名导入，并不使用包内导出的函数，而是仅仅让包的 init 得到调用</li></ul></li><li><p>单元测试:</p><ul><li>文件名: <code>源文件名_test.go</code></li><li>函数名: <code>func Test源函数名()</code></li></ul></li></ul><h1 id="Package-amp-Import"><a href="#Package-amp-Import" class="headerlink" title="Package &amp; Import"></a>Package &amp; Import</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A package clause starts every source file.</span></span><br><span class="line"><span class="comment">// main is a special name declaring an executable rather than a library.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span>       <span class="comment">// A package in the Go standard library.</span></span><br><span class="line">    <span class="string">"io/ioutil"</span> <span class="comment">// Implements some I/O utility functions.</span></span><br><span class="line">    <span class="string">"math"</span>    <span class="comment">// Math library with local alias m.</span></span><br><span class="line">    <span class="string">"net/http"</span>  <span class="comment">// Yes, a web server!</span></span><br><span class="line">    <span class="string">"os"</span>        <span class="comment">// OS functions like working with the file system</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>init()函数特性:</p><ul><li>在 main 之前, 由 runtime 调用</li><li>同一个 go 文件下, 可以有多个 init 函数, 调用顺序同定义顺序</li><li>同一个 package 下, 可以有多个 init 函数, 调用顺序似乎是 go 文件字典顺序, 但不要依赖此顺序做初始化</li><li>对于 import 导入的包，这些导入的包的 init 的调用顺序同 import 的顺序</li><li>用户代码无法调用 <code>init()</code>, 会报错 undefined</li></ul><p>➤ init 使用场景:</p><ul><li>做初始化；</li><li>实现 sync.Once 功能；</li><li>无法用初始化表达式初始的变量；</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li><p>变量的声明 + 初始化：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更方便的写法</span></span><br><span class="line">j := <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>Go 支持全局变量，首字母大写的变量名表示可被外界访问：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypkg</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">100</span> <span class="comment">// 未导出的本地变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyConst = <span class="string">"hello"</span> <span class="comment">// 导出的全局变量</span></span><br></pre></td></tr></table></figure><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p><strong>整形</strong>：</p><ul><li><code>uint8</code>/<code>int8</code>: 平台无关, 8位</li><li><code>uint16</code>/<code>int16</code>: ..</li><li><code>uint32</code>/<code>int32</code>: ..</li><li><code>uint64</code>/<code>int64</code>: ..</li><li><code>uint</code>/<code>int</code>: 平台有关，可能是32 or 64 bits(视机器平台而定)</li></ul><p><strong>浮点数</strong>：</p><ul><li><code>float32</code>：平台无关，4位</li><li><code>float64</code>：…</li></ul><p><strong>复数</strong>：</p><ul><li><code>complex64</code>: 复数, 由float32的实部 + float32的虚部构成</li></ul><p>@ref: <a href="https://golang.google.cn/ref/spec#Numeric_types" target="_blank" rel="noopener">The Go Programming Language Specification - The Go Programming Language</a></p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><ul><li><p>双引号和反引号： </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">"string example"</span></span><br><span class="line">str2 := <span class="string">`another string</span></span><br><span class="line"><span class="string">example`</span></span><br><span class="line">str3 := <span class="string">`&#123;"type": "json"&#125;`</span></span><br></pre></td></tr></table></figure></li><li><p>字符串是”只读的”, 意味着无法直接修改字符串的内存空间</p></li><li><p>字符串的实现，运行时使用 <code>reflect.StringHeader</code> 结构体表示字符串，与切片的结构体（<code>SliceHeader</code>）相比，字符串只少了一个表示容量的 <code>Cap</code> 字段:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type StringHeader struct &#123;</span><br><span class="line">  Data uintptr</span><br><span class="line"> Len  int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断字符串 empty: <code>len(str) == 0</code></p></li></ul><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li><p>Golang的类型转换: <code>T(var)</code></p></li><li><p>字符串 → any 都可以用<code>strconv</code>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i, err := strconv.ParseInt(<span class="string">"1287089"</span>, <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">result := <span class="keyword">int</span>(i)</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Golang 函数声明的不同之处：形参列表后面才是返回值，返回值可以有多个，变量名在前类型在后</p><ul><li><p>多个返回值:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum, prod <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+y, x*y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变参数:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">(params ...<span class="keyword">type</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, param := <span class="keyword">range</span> params &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Golang 是值传递还是引用传递?</p><ul><li>Golang 是值传递, 函数内得到一份形参的拷贝</li><li>对于 slice, map, chan,  因为其结构内包含指针, 所以仍可以在函数内改变其存储的值</li><li>数组也是值传递，因为数组的类型是 <code>[N]Type</code>，所以数组作为形参是有局限性的，大小 N 被固定，推荐用 slice</li></ul></li></ul><h1 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h1><p>例1:<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p><p>例2:<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      x = x + <span class="number">1</span></span><br><span class="line">      fmt.Printf(<span class="string">"foo1 val = %d\n"</span>, x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = foo2(<span class="number">133</span>)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p><ul><li>什么是闭包(closure)? a <strong>closure</strong> is a record storing <strong>a function</strong> together with <strong>an environment</strong>., 那么闭包的简化定义是: 函数+依赖的外部变量（不以参数传入的变量）</li><li>实际上, Golang 实现闭包, 实际是把 <em>函数</em> 和<em>它依赖的外部变量</em> 都放在了一个 struct 里, 用这个 struct 保存了函数地址，和它依赖的外部变量（的引用）</li><li>闭包的实现依赖 Golang 的逃逸分析, 在逃逸分析时，闭包依赖的外部环境变量，被判定为逃逸，则在堆上分配；</li><li>闭包另一个特性是延迟绑定, 意思是, 上面的闭包(也即 struct)里保存的环境变量的值, 不是在编译期确定的, 而是在<strong>闭包的运行时才确定</strong>, 在闭包的外部寻找依赖变量的最新值, 并赋值进去 // 闭包的运行时即 <code>闭包()</code> 时；</li></ul><blockquote><p><a href="https://zh.wikipedia.org/zh-cn/%E9%97%AD%E5%8C%85_ (%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">闭包 - 维基百科，自由的百科全书</a>)<br>在支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" title="头等函数" target="_blank" rel="noopener">头等函数</a>的语言中，如果函数f内定义了函数g，那么如果g存在<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F" title="自由变量" target="_blank" rel="noopener">自由变量</a>，且这些自由变量没有在编译过程中被优化掉，那么将产生闭包。</p></blockquote><p>再使用一个例子说明闭包的<strong>延迟绑定</strong>，下面输出什么?</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(x <span class="keyword">int</span>)</span> []<span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">values</span> := []<span class="title">int</span></span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">fs = <span class="built_in">append</span>(fs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"in closure, x + val = %d\n"</span>, x+val)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs := foo(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> fs &#123;</span><br><span class="line">    f() <span class="comment">// 闭包运行时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类问题的通解是：</p><ul><li>找出闭包，找出闭包依赖的外部变量</li><li>在闭包运行时（调用 <code>func()</code> 时），找到外部变量当前值</li></ul><p>分析:</p><ul><li>foo 返回了一个数组, 数组内是4个闭包函数, 闭包函数依赖2个外部变量: x 和 val</li><li>foo 返回 fs 的时候, 仅仅是返回了一个闭包的定义, struct 定义中包含有“外部变量” x 和 val，但是 struct 中的 x 和 val 只是引用，并没有绑定值</li><li>第一次执行 <code>f()</code> 时, 寻找 x 和 val 的最新值并绑定到闭包, 也即10 和 3</li><li>所以输出的%d 是 13,13,13,13</li></ul><p><strong>Goroutine 的闭包</strong>：</p><ul><li><p>没有自由变量，没有形成真正的闭包：</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"foo4 val = %v\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> show(val) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">foo4() <span class="comment">// 打印 1,2,3,5 （不一定按顺序）</span></span><br></pre></td></tr></table></figure></li><li><p>go 后面的匿名函数内，使用了自由变量，形成了闭包，所以外部变量会在“运行时”绑定：</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    values := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"foo5 val = %v\n"</span>, val)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">foo5() <span class="comment">// 打印 5,5,5,5</span></span><br></pre></td></tr></table></figure></li></ul><p>解析：</p><ul><li><code>go func() {... } ()</code> 的写法，虽然最后带 <code>()</code>，但匿名函数并没有立刻执行，只是将它加入任务队列等待调度；</li><li>匿名函数使用了外部变量，也即形成了闭包，Go 对闭包的实现是定义一个 struct，该 struct 的成员包括函数返回地址和引用的环境中的变量地址；</li><li>匿名函数被 Goroution scheduler 调度到，以闭包的方式执行</li></ul><p>@ref:</p><ul><li>闭包的实现 · 深入解析Go：<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html" target="_blank" rel="noopener">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.6.html</a></li><li>Golang：“闭包（closure）”到底包了什么？ - 知乎：<a href="https://zhuanlan.zhihu.com/p/92634505" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92634505</a></li></ul><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><ul><li><p>if可以先赋值再判断</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x:=computerValue(); x&gt;y &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按次数循环</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环1</span></span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;<span class="number">10</span>; x++ &#123;</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历map/slice, 使用关键字<code>range</code>:  <code>index, elem : = range slice</code> or <code>k, v := range map</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环遍历 map</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;<span class="string">"one"</span>:<span class="number">1</span>, <span class="string">"two"</span>:<span class="number">2</span>&#125; &#123;</span><br><span class="line">  fmt.Println(<span class="string">"%s %d\n"</span>, k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历 slice</span></span><br><span class="line"><span class="keyword">for</span> i,s := <span class="keyword">range</span> []<span class="keyword">string</span> &#123;<span class="string">"one"</span>,<span class="string">"two"</span>&#125; &#123;</span><br><span class="line">  fmt.Println(<span class="string">"%d %s\n"</span>, i,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="comment">// 隐式break, 匹配到一个即停止</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><blockquote><p>@ref: <a href="https://colobu.com/2017/06/26/learn-go-type-aliases/" target="_blank" rel="noopener">https://colobu.com/2017/06/26/learn-go-type-aliases/</a></p></blockquote><p>golang中type的用法:</p><ul><li>定义新类型: <code>type newType oldType</code> // C++中的typedef用法是<code>typedef oldType newType</code> …</li><li>定义结构体: <code>type STypeName struct{}</code></li><li><p>类型别名:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> FloatType <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名2:</span></span><br><span class="line"><span class="keyword">type</span> S = <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> str S = <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数别名:</span></span><br><span class="line"><span class="keyword">type</span> F = <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">foo</span> <span class="title">F</span> = <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><ul><li><p>定义：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourFirstStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  member1 <span class="keyword">string</span></span><br><span class="line">  member2 <span class="keyword">string</span></span><br><span class="line">  <span class="comment">// 每个成员没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := YourFirstStruct &#123;</span><br><span class="line">  member1: <span class="string">"member1"</span>,</span><br><span class="line">  member2: <span class="string">"member2"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>golang 只有值传递, struct 在函数内/外传递 or 直接 <code>=</code> 赋值给另一 struct 变量, 都会有一次拷贝；</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := YourFirstStruct &#123;</span><br><span class="line">  member1: <span class="string">""</span></span><br><span class="line">  member2: <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">s2 := s1 <span class="comment">// 赋值导致一次拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免拷贝的做法:</span></span><br><span class="line">ptr1 := &amp;YourFirstStruct &#123;</span><br><span class="line">&#125;</span><br><span class="line">ptr2 := ptr1 <span class="comment">// 指针传递</span></span><br></pre></td></tr></table></figure></li><li><p>因为函数传参是值传递，所以在函数内对 struct 类型的参数进行更改，所修改的只是副本，如果需要实现在函数内对 struct 的修改，应该使用 <code>*T</code> 类型作为形参；</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;</span><br><span class="line">Value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">myT := T&#123;Value:<span class="number">666</span>&#125;</span><br><span class="line"></span><br><span class="line">change(&amp;myT)</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(myT.Value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(t *T)</span></span>&#123;</span><br><span class="line">t.Value = <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>给Struct添加方法, 无需C++那样的头文件声明, 直接定义方法:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s被叫做“接收器”，第一种是“指针接收器”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *YourFirstStruct)</span> <span class="title">foo</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “值接收器”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s YourFirstStruct)</span> <span class="title">foo2</span><span class="params">(param <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>比较 struct 的“指针接收器” &amp; “值接收器”</p><ul><li>如果 func 内改变结构体的内容，需要“指针接收器”；</li><li>从性能比较，“值接收器” 需要更多次拷贝；</li><li>如果使用“值接收器”，因为函数内使用的是拷贝，所以func线程安全</li></ul></li></ul><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ul><li><p>interface是一种类型, 包括0个或多个方法</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">  Get() <span class="keyword">int</span></span><br><span class="line">  Set(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>空interface: <code>interface{}</code> 没有方法的interface, 可以认为任何类型都实现了该interface,</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(any <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// foo可以接受任何类型的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Golang里没有extends这样的关键字来表名 某struct 实现了 某Interface, 只是在 <em>赋值</em>, <em>入参</em>, <em>返回值</em> 时被动检查</p></li></ul><h1 id="array"><a href="#array" class="headerlink" title="array"></a>array</h1><ul><li><p>数组在编译期即指定大小</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组在用var声明时即分配了空间并给初始值</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明, 同时赋值</span></span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">arr2 := [...]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>golang在创建<strong>字面量数组</strong>时, 会根据数组长度进行不同的处理</p><ul><li>数组len&lt;=4, 直接在栈上分配数组</li><li>数组len&gt;4, 会在静态区分配数组(编译期), 并在运行时取出来</li><li>上述没有考虑逃逸</li></ul></li><li><p>数组的类型是: <code>[N]ElemType</code>, 长度也算类型的一部分, 例如 <code>[10]int</code> 和 <code>[3]int</code> 是不同的类型</p></li><li><p>在 golang 中，数组也是值传递，所以：</p><ul><li>对于大型数组，应该使用 <em>数组指针 or slice</em> 的方式传递参数，避免拷贝；</li><li>如果要在函数内，修改函数外声明的数组，需要使用<em>数组指针</em>作为参数；</li></ul></li></ul><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><ul><li>slice: Golang 内置类型, 即”动态数组” // 区别：数组的长度固定，不可改变</li><li><p>比较 slice 和 array 的声明方式</p><ul><li><code>s2 := []int{1,2,3}</code> 字面量声明方式创建 slice</li><li>如果上面使用 <code>[N]</code> or <code>[...]</code> ，创建出来的就不是 slice 而是 array 了</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组: 声明即分配空间</span></span><br><span class="line"><span class="keyword">var</span> arr0 [<span class="number">4</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片: 声明时没有分配空间</span></span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="keyword">string</span></span><br><span class="line">slice0[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// panic: runtime error: index out of range</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片1, 通过数组</span></span><br><span class="line">s1 := arr0[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片2, 创建时给初值</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建切片3, len=cap=0</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>切片的扩容: 向切片add元素, 如果 len 大于 cap, 将创建新数组, 大小为原切面cap的两倍, 然后所有元素复制到新数组中</p></li><li><p>切片底层实现，由两部分组成: Header + 数组实际存储空间, 其中 Header 的结构表述如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">array unsafe.Pointer // 指针, 指向连续的内存</span><br><span class="line">len   int</span><br><span class="line">cap   int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/golang-slice.png" alt="../_images/golang-slice.png"></p></li><li><p>从数组创建切片: <code>slice := array[startIndex:endIndex]</code> , 切片将包含 <code>array[startIndex] ...array[endIdex-1]</code>, 这种方式创建的新数组, 只是新建了一个 slice 结构, data 指针指向的即是数组, 故修改 slice 的数据也会影响数组中的值:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := array3[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// 此时slice包括 [2,3], len=2, 但slice指向的数组是[2,3,4,5], 故cap=4</span></span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">7</span> <span class="comment">// 对切片的修改也会影响数组, 但当切片发生一次扩容之后, 切片会指向一个新申请的数组空间</span></span><br></pre></td></tr></table></figure></li><li><p>复制切片：<code>slice3 :=  slice2[:]</code> 可以快速复制切片，但缺陷是 <code>slice3</code> 和 <code>slice2</code> 是同一个切片，无论改动哪个，另一个都会产生变化。内建函数 <code>copy</code> 可以用于复制 slice，并且两个 slice 各自使用独立的数组，见「内置函数」</p></li></ul><p>➤ 比较数组和切片:</p><ul><li>数组声明即分配空间, 且不可改变长度</li><li>切片声明不分配空间, 需要通过<code>make()</code> or <code>arr[start:end]</code></li><li>切片的类型是 <code>[]type</code>, 数组的类型是<code>[N]type</code></li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul><li><p>声明和初始化, 赋值, 访问：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> mmap1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">mmap1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">mmap1[<span class="string">"One"</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="keyword">if</span> v, exist := mmap1[<span class="string">"One"</span>]; exist &#123;</span><br><span class="line">  <span class="built_in">delete</span>(mmap1, <span class="string">"One"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明+定义</span></span><br><span class="line">mmap2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;<span class="string">"One"</span>:<span class="number">1</span>, <span class="string">"Two"</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>How to range map:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v = <span class="keyword">range</span> myMap &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s %s"</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h1><p>见第二部分</p><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><p>@ref: <a href="https://pkg.go.dev/builtin#pkg-functions" target="_blank" rel="noopener">https://pkg.go.dev/builtin#pkg-functions</a></p><h2 id="len-cap"><a href="#len-cap" class="headerlink" title="len/cap"></a>len/cap</h2><ul><li>len/cap: 返回数组, slice, map, string, chan ..的长度&amp;容量</li></ul><h2 id="append-copy"><a href="#append-copy" class="headerlink" title="append/copy"></a>append/copy</h2><ul><li>append: 切片拼接，原型: <code>func append(slice []Type, elems ...Type) []Type</code></li><li>copy：切片复制，原型: <code>func copy(dst, src []Type) int</code></li></ul><h2 id="print-println"><a href="#print-println" class="headerlink" title="print/println"></a>print/println</h2><ul><li>print：输出到 std err，原型: <code>func print(args ...Type)</code></li><li><p>println：输出到 std err，arg 之间有空格，且有换行，原型: <code>func println(args ...Type)</code></p><p>区分 <code>fmt.Print()</code>，输出到 <strong>standard output</strong></p></li></ul><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><ul><li>slice:<ul><li>make([]T)</li><li>make([]T, len)</li><li>make([]T, len, cap)</li></ul></li><li>map:<ul><li>make(map[K]V)</li><li>make(map[K]V, cap)</li></ul></li><li>chan:<ul><li>make(chan T, cap)</li></ul></li></ul><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ul><li>原型: <code>func new(Type) *Type</code></li><li>作用: 返回为指定类型分配的内存地址，分配的内存置零</li><li><p>example:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  member1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建struct方式1</span></span><br><span class="line">p1 := <span class="built_in">new</span>(YourStruct)</span><br><span class="line">p1.member1 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建struct方式2</span></span><br><span class="line">p2 := &amp;YourStruct&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>Golang 中 new 和 var ，一个返回指针一个返回变量，二者的实现没有本质区别，都是要通过逃逸分析判断是在栈上/堆上分配变量（如果没有逃逸，new 创建的变量也可能在栈上创建）</p></li></ul><h2 id="make-vs-new"><a href="#make-vs-new" class="headerlink" title="make vs new"></a>make vs new</h2><ul><li>new(T)：<ul><li>分配一块内存，内存置零，返回其指针（并未初始化）</li><li>根据new(T)的T创建内存，返回<code>*T</code>类型，<code>p := new(Type)</code> 等同于<code>p := &amp; Type{}</code></li></ul></li><li>make(T)：<ul><li>分配一块内存，并初始化，返回地址</li><li>make只能用于初始化slice/map/chan</li></ul></li></ul><p><img src="/images/golang-make-vs-new.png" alt="../_images/golang-make-vs-new.png"></p><p>比较： </p><ul><li><code>new([]int)</code> 只分配了一片内存（指向 <code>[]int</code> 类型，也就是 slice 的头）但是这块内存的 ptr 并未初始化；</li><li><code>make([]int)</code> 为 slice 的 prt 做了初始化；</li></ul><p>@ref:</p><ul><li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/#551-make" target="_blank" rel="noopener">Go 语言中的 make 和 new | Go 语言设计与实现</a></li></ul><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><ul><li>delete: 用于删除 map 里的 key, 原型: <code>func delete(m map[Type]Type1, key Type)</code></li></ul><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><ul><li>关闭 chan，原型 <code>func close(c chan&lt;- Type)</code></li></ul><p>close() 只能由 sender 调用，不可以由 receiver 调用，一旦对 chan 使用了 close，在接收完最后一个值后，该 chan 将被关闭，任何从该 chan 的 receive 都会返回 <strong>success</strong> 而不会阻塞；</p><h2 id="panic-amp-recovery"><a href="#panic-amp-recovery" class="headerlink" title="panic &amp; recovery"></a>panic &amp; recovery</h2><p><strong>panic</strong>： panic 会停止当前 Goroutine 的正常执行，相当于其他编程语言的抛异常</p><ul><li>原型：<code>func panic(v any)</code></li><li>行为：<ul><li>当函数 F 调用了 panic，F 的执行会被停止，在 F 中 panic 前面定义的 defer 操作都会被执行，然后 F 函数返回给调用者 G。</li><li>对于 G，调用 F 的行为类似于调用 panic，G 将调用 defer 函数，并返回给上一层调用者，直到程序非零值退出（除非调用了recover）</li></ul></li></ul><p><strong>recovery</strong>：让程序从 panic 中恢复，阻止 panic 继续向上层调用者传播。返回类型是 any，返回的值是传入 <code>panic(v)</code> 的参数，recovery 必须在 defer 块中调用</p><ul><li>原型：<code>func recover() any</code></li></ul><p>➤ <strong>panic</strong> &amp; <strong>recovery</strong> 使用示例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Recovered in main"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"Returned normally from main."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Calling f."</span>)</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Panicking in f!"</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%v"</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Returned normally from f."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ref: <a href="https://pkg.go.dev/builtin#panic" target="_blank" rel="noopener">https://pkg.go.dev/builtin#panic</a></p><p>➤ <strong>defer</strong> 关键字 → [[#defer]]</p><h1 id="error"><a href="#error" class="headerlink" title="error"></a>error</h1><ul><li><p><code>error</code>是一个Interface:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 接口只有一个函数,返回字符串</span></span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>errors</code>创建一个错误: <code>err := errors.New(&quot;Error occured!&quot;)</code>, 返回的是一个<code>type errorString struct</code>类型的错误</p></li><li>定义自己的 error 类型: 定义错误的 Struct 类型, 然后实现 <code>Error() string</code> 方法即可</li></ul><h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><ul><li>函数内定义的 defer 后的表达式，在函数退出前执行；</li><li>一个 func 可以有多个 defer 语句, defer 语句被压入栈中，所以函数退出时执行顺序与 defer 定义顺序相反；</li><li>如果 defer 之后是一个带参函数，例如 <code>defer f(i)</code>，运行至 defer 时会立刻保存 i 的值（类似于一次值拷贝）；</li><li>如果 defer 之后形成了<strong>闭包</strong>（匿名函数内使用了外部变量），那么对外部变量的处理与闭包类似，在闭包实际运行时读取外部变量的最新值</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeferEtudes3</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span> <span class="comment">// 以形参传入，不是闭包的自由变量</span></span><br><span class="line">j := <span class="number">9</span> <span class="comment">// 形成闭包的自由变量</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"in defer: i=%d, j=%d\n"</span>, i, j) <span class="comment">// 1， 10</span></span><br><span class="line">&#125;(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">j = j + <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">"in func: i=%d, j=%d\n"</span>, i, j) <span class="comment">// 2， 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// j是闭包的自由变量，符合“运行时”绑定值，</span></span><br><span class="line">    <span class="comment">// i以参数传入，不是闭包的自由变量，会在运行到defer时就保存当时的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ref：</p><ul><li><a href="https://go.dev/blog/defer-panic-and-recover" target="_blank" rel="noopener">Defer, Panic, and Recover - The Go Programming Language</a></li></ul><p>➤ <strong>defer</strong> 的实现：</p><ul><li>编译器将 defer 关键字转换为调用 <code>runtime.deferproc()</code> 函数，这个函数接收了参数的大小和闭包所在的地址两个参数。</li><li>在 <code>runtime.deferproc()</code> 中，创建一个 <code>runtime._defer</code> 结构体，并为它的成员赋值：函数指针 <code>fn</code>、程序计数器 <code>pc</code> 和栈指针 <code>sp</code> ，并将相关的参数拷贝到相邻的内存空间中，并将结构体加入 <code>_defer</code> 链表的开头；</li><li>在调用 defer 的函数末尾，插入 <code>runtime.deferreturn()</code> 函数的调用，该函数会从 Goroutine 的 <code>_defer</code> 链表中取出最前面的 <code>runtime._defer</code> 结构体 … </li><li>以上 @ref: <a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer" target="_blank" rel="noopener">理解 Go 语言 defer 关键字的原理 | Go 语言设计与实现</a></li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul><li>小写开头的成员默认不被序列化</li><li>struct tag: <code>json:&quot;var_name&quot;</code> 指定序列化后的变量名</li><li>struct tag: <code>json:&quot;var_name,omitempty&quot;</code> 如果成员值为”zero-value”, 序列化将不包括此字段</li><li><p>struct tag: <code>json:&quot;-&quot;</code> 序列化时跳过此字段</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> YourFirstStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  Mem1 <span class="keyword">string</span>  <span class="string">`json:"variable1"`</span></span><br><span class="line">  Mem2 <span class="keyword">string</span>  <span class="string">`json:"variable2,omitempty"`</span></span><br><span class="line">  Mem3 <span class="keyword">string</span>  <span class="string">`json:"-"`</span></span><br><span class="line">  <span class="comment">// 每个成员没有分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Type(struct/map 等) → byte[]</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice_of_byte, err := json.Marshal(obj)</span><br></pre></td></tr></table></figure></li><li><p>byte[] → Type</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">obj := <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">json_str := <span class="string">`&#123;"Name":"X", "Age": 101&#125;`</span></span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(json_str), &amp;obj)</span><br></pre></td></tr></table></figure></li></ul><h1 id="时间-API"><a href="#时间-API" class="headerlink" title="时间 API"></a>时间 API</h1><ul><li>获取 int64时间戳: <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timestampSec <span class="keyword">int32</span> = time.Now().Unix()</span><br></pre></td></tr></table></figure></li></ul><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p><a href="https://geektutu.com/post/quick-go-test.html" target="_blank" rel="noopener">https://geektutu.com/post/quick-go-test.html</a></p><h1 id="命令行-amp-环境"><a href="#命令行-amp-环境" class="headerlink" title="命令行 &amp; 环境"></a>命令行 &amp; 环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">go &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation for package or symbol</span><br><span class="line">env         print Go environment information</span><br><span class="line">fix         update packages to use new APIs</span><br><span class="line">fmt         gofmt (reformat) package sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         add dependencies to current module and install them</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified go tool</span><br><span class="line">version     print Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure><p>➤ 常用：</p><ul><li>获取包并安装：<code>go get golang.org/x/tools/gopls@latest</code> （源码默认下载到 $GOPATH/src）</li><li>开启 Go module：<code>go env -w GO111MODULE=on</code>，从 v1.13 版本开始这个选项默认开启</li></ul><blockquote><p>Go 1.11 引入了 Go Modules，不再使用 GOPATH 存储每个依赖包的 git checkout，而是通过项目目录下的 go.mod 记录依赖包</p></blockquote><p>➤ Golang 的环境变量可以使用 <code>go env</code> 查看：</p><ul><li><code>$GOROOT</code> 表示 Go SDK 的安装位置，它的值一般都是 $HOME/go</li><li><code>$GOPATH</code> 表示工作空间的路径，用来保存 Go 项目代码和第三方依赖包</li><li><code>$GOARCH</code> 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。</li><li><code>$GOOS</code> 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。</li><li><code>$GOARM</code> 专门针对基于 arm 架构的处理器，它的值可以是 5~7，默认为 6。</li></ul><blockquote><ul><li>GOARM=5: 使用软件浮点（software floating point）；当 CPU 没有 VFP 协同处理器时</li><li>GOARM=6: 仅使用 VFPv1; 使用交叉编译时的默认使用此选项，通常在 ARM11 或更高版本的内核中使用（也支持 VFPv2 或更高版本）</li><li>GOARM=7: 使用 VFPv3；通常在 Cortex-A 内核中使用</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Golang中的约定大于配置&quot;&gt;&lt;a href=&quot;#Golang中的约定大于配置&quot; class=&quot;headerlink&quot; title=&quot;Golang中的约定大于配置&quot;&gt;&lt;/a&gt;Golang中的约定大于配置&lt;/h1&gt;&lt;p&gt;Golang遵循”约定大于配置”(convention over configuratio)的理念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小写开头的标识(变量/函数/结构体类型等等)是 package 内可见, 大写开头的标识包外可见(类似 public)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构体中的”小写开头的成员”, 在用 &lt;code&gt;json.Marshal&lt;/code&gt; 序列化时会被忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个文件是一个 package，声明在源文件第一行，&lt;code&gt;package main&lt;/code&gt; 是一个特殊的包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;import as &lt;code&gt;_&lt;/code&gt; 和 &lt;code&gt;.&lt;/code&gt; 的包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import . &amp;quot;packageXXX&amp;quot;&lt;/code&gt; : 调用包内的函数,不需要再加 &lt;code&gt;packageXXX.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import _ &amp;quot;packageXXX&amp;quot;&lt;/code&gt; : 匿名导入，并不使用包内导出的函数，而是仅仅让包的 init 得到调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单元测试:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件名: &lt;code&gt;源文件名_test.go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数名: &lt;code&gt;func Test源函数名()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Package-amp-Import&quot;&gt;&lt;a href=&quot;#Package-amp-Import&quot; class=&quot;headerlink&quot; title=&quot;Package &amp;amp; Import&quot;&gt;&lt;/a&gt;Package &amp;amp; Import&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// A package clause starts every source file.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// main is a special name declaring an executable rather than a library.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;// A package in the Go standard library.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;io/ioutil&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// Implements some I/O utility functions.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;math&quot;&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;// Math library with local alias m.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;net/http&quot;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// Yes, a web server!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;os&quot;&lt;/span&gt;        &lt;span class=&quot;comment&quot;&gt;// OS functions like working with the file system&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="11.Programming-Language" scheme="https://beefyheisenberg.github.io/categories/11-Programming-Language/"/>
    
    
    <category term="Golang" scheme="https://beefyheisenberg.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>About-Scriptorium</title>
    <link href="https://beefyheisenberg.github.io/About/About-Scriptorium/"/>
    <id>https://beefyheisenberg.github.io/About/About-Scriptorium/</id>
    <published>2023-08-28T12:08:57.921Z</published>
    <updated>2023-08-28T12:08:57.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缮写室"><a href="#缮写室" class="headerlink" title="缮写室"></a>缮写室</h2><p><img src="/images/About-Scriptorium.png" alt=""></p><h2 id="黄金诗篇"><a href="#黄金诗篇" class="headerlink" title="黄金诗篇"></a>黄金诗篇</h2><p><img src="/images/About-Golden-Verses.png" alt=""></p><h2 id="卡尔达诺书"><a href="#卡尔达诺书" class="headerlink" title="卡尔达诺书"></a>卡尔达诺书</h2><p><img src="/images/About-Ars-Magna.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;缮写室&quot;&gt;&lt;a href=&quot;#缮写室&quot; class=&quot;headerlink&quot; title=&quot;缮写室&quot;&gt;&lt;/a&gt;缮写室&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/About-Scriptorium.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;黄金诗篇&quot;&gt;&lt;a href=&quot;#黄金诗篇&quot; class=&quot;headerlink&quot; title=&quot;黄金诗篇&quot;&gt;&lt;/a&gt;黄金诗篇&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/About-Golden-Verses.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;卡尔达诺书&quot;&gt;&lt;a href=&quot;#卡尔达诺书&quot; class=&quot;headerlink&quot; title=&quot;卡尔达诺书&quot;&gt;&lt;/a&gt;卡尔达诺书&lt;/h2&gt;</summary>
    
    
    
    <category term="About" scheme="https://beefyheisenberg.github.io/categories/About/"/>
    
    
  </entry>
  
  <entry>
    <title>游戏《Rise-of-Kingdoms》中的历史人物</title>
    <link href="https://beefyheisenberg.github.io/76.Games/%E6%B8%B8%E6%88%8F%E3%80%8ARise-of-Kingdoms%E3%80%8B%E4%B8%AD%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BA%BA%E7%89%A9/"/>
    <id>https://beefyheisenberg.github.io/76.Games/%E6%B8%B8%E6%88%8F%E3%80%8ARise-of-Kingdoms%E3%80%8B%E4%B8%AD%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BA%BA%E7%89%A9/</id>
    <published>2023-08-28T12:08:57.900Z</published>
    <updated>2023-08-28T12:08:57.900Z</updated>
    
    <content type="html"><![CDATA[<p>Rise of Kingdoms （万国觉醒） 是一款 P2W（pay to win）游戏。</p><h2 id="大西庇阿"><a href="#大西庇阿" class="headerlink" title="大西庇阿"></a>大西庇阿</h2><p><img src="/images/2022/IMG20220922-1.png" alt=""><br>大西庇阿（前235年—前183年），全名为普布利乌斯·科尔内利乌斯·西庇阿。古罗马统帅和政治家。他是第二次布匿战争中罗马方面的主要将领之一，以在扎马战役中打败迦太基统帅汉尼拔而著称于世。由于西庇阿的胜利，罗马人以绝对有利的条件结束了第二次布匿战争。西庇阿因此得到他那著名的绰号：“阿非利加征服者”。</p><h2 id="贝利萨留（Belisarius）"><a href="#贝利萨留（Belisarius）" class="headerlink" title="贝利萨留（Belisarius）"></a>贝利萨留（Belisarius）</h2><p><img src="/images/2022/IMG20220922.png" alt=""><br>贝利萨留（约505年～565年），又名贝利萨留斯，拜占庭帝国统帅、军事家。他一生当中的大多数战役是以少胜多。<br>贝利萨留出生于色雷斯。早年任皇帝查士丁尼一世的侍卫。527年率军参加对波斯的战争。529年，升任禁卫军长官。530年，任德拉总督，击败4万波斯-阿拉伯联军，名声大振。532年，镇压君士坦丁堡的尼卡起义，解救被围困的皇帝。533～534年，仅率1万步兵和6000骑兵入侵北非，灭汪达尔-阿兰王国并俘其国王。回国后被授予执政官称号。535年，出征意大利的东哥特王国，登陆西西里岛。536年攻入意大利南部，随后北上占领罗马。540年，攻陷东哥特都城拉韦纳，俘东哥特王。曾经用“自己将政变”为计谋欺骗敌方获胜，结果因此受到查士丁尼一世的怀疑。562年，被指控参与谋反，被捕入狱。563年，获释。565年，去世，享年61岁。</p><h2 id="海尔曼"><a href="#海尔曼" class="headerlink" title="海尔曼"></a>海尔曼</h2><p>英文名：Arminius阿米尼乌斯<br>德语作Hermann赫尔曼</p><p>阿米尼乌斯，或称阿尔米尼乌斯，于公元前18年生于日耳曼尼亚，日耳曼部族切鲁西人(Cherusci)的首领。小被送往罗马当人质。长大后，他成为罗马辅助部队一队骑兵的首领。9年他大败罗马人，在条顿堡森林(Teutoburg Forest)歼灭普布利乌斯·昆克提尼乌斯·瓦卢斯(Publius Quinctilius Varus)的3个军团。15年他巧妙地抵挡了罗马发动的全面进攻，但在16年，他在安格里瓦尔瓦战役败给了罗马将领日尔曼尼库斯，17年与马科曼尼人(Marcomanni)国王马罗波都(Maroboduus)进行战斗。在取得胜利以後，他被日耳曼尼亚部落的对手首领下令暗杀。</p><p>条顿堡森林战役：<br>公元9年9月，瓦卢斯带领十七、十八、十九三个军团从夏营返回东营过冬，连同辎重、家属共计逾两万两千人，阿米尼乌斯召集日耳曼各部落共同伏击罗马人，他施计引诱罗马人进入条顿堡森林，通过三场战斗，他歼灭了罗马人的3个军团，瓦卢斯自杀身亡。<br>当奥古斯都得知瓦鲁斯及三个罗马军团全军覆没，便痛叫”Quintili Vare, legiones redde!” (‘Quintilius Varus, give me back my legions!’)“瓦鲁斯，把军团还给我！”</p><h2 id="佩拉约"><a href="#佩拉约" class="headerlink" title="佩拉约"></a>佩拉约</h2><p>佩拉约（西班牙语：Pelayo，拉丁语：Pelagius，约685年－737年）685年出生于西班牙，他建立了阿斯图里亚斯王国，从718年开始统治直到去世。他在科法敦加战役的胜利，被视为“收复失地运动”的起点，基督徒从摩尔人手中收复伊比利亚半岛，从他建立独立的基督教西班牙国家对抗摩尔人政权开始，但是并没有强力的证据证明他的目的是复兴过去的西班牙王国或者只是因为任何宗教渴望的刺激。</p><h2 id="源义经"><a href="#源义经" class="headerlink" title="源义经"></a>源义经</h2><p><img src="/images/2022/IMG20220922-2.png" alt=""></p><p>源义经（1159年—1189年6月15日），幼名牛若（うしわかまる）。日本传奇英雄，平安时代末期的名将。出身于河内源氏的武士，家系乃清和源氏其中一支，河内源氏的栋梁源赖信的后代。为源义朝的第九子，源赖朝之弟。<br>源义经之父源义朝在平治之乱中为平清盛所败后，源义经在七岁时被送到京都鞍马寺学习，改名遮那王。之后投奔奥州，受到奥州藤原氏当主藤原秀衡的庇护。承治四年（1180年），源义经与同父异母的兄长源赖朝一齐举兵讨伐平家，在著名的战役源平合战中战功彪炳，威名显赫。但也因功高震主为源赖朝所猜忌，最终兄弟反目成仇。源赖朝得到后白河天皇的院宣后，在全国发布通缉命令追捕源义经。源义经在走投无路之下再度投靠藤原秀衡，藤原秀衡死后，其子藤原泰衡开始排挤源义经。文治五年（1189年），源赖朝亲自率兵讨伐平泉。迫于源赖朝之压力，藤原泰衡把枪口转向了源义经。源义经最后在衣川馆自尽。<br>源义经为日本人所爱戴的传统英雄之一，而且由于其生涯富有传奇与悲剧的色彩，在许多故事、戏剧中都有关于他的描述，在许多神社中也奉祀著源义经。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rise of Kingdoms （万国觉醒） 是一款 P2W（pay to win）游戏。&lt;/p&gt;
&lt;h2 id=&quot;大西庇阿&quot;&gt;&lt;a href=&quot;#大西庇阿&quot; class=&quot;headerlink&quot; title=&quot;大西庇阿&quot;&gt;&lt;/a&gt;大西庇阿&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/2022/IMG20220922-1.png&quot; alt&gt;&lt;br&gt;大西庇阿（前235年—前183年），全名为普布利乌斯·科尔内利乌斯·西庇阿。古罗马统帅和政治家。他是第二次布匿战争中罗马方面的主要将领之一，以在扎马战役中打败迦太基统帅汉尼拔而著称于世。由于西庇阿的胜利，罗马人以绝对有利的条件结束了第二次布匿战争。西庇阿因此得到他那著名的绰号：“阿非利加征服者”。&lt;/p&gt;
&lt;h2 id=&quot;贝利萨留（Belisarius）&quot;&gt;&lt;a href=&quot;#贝利萨留（Belisarius）&quot; class=&quot;headerlink&quot; title=&quot;贝利萨留（Belisarius）&quot;&gt;&lt;/a&gt;贝利萨留（Belisarius）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/2022/IMG20220922.png&quot; alt&gt;&lt;br&gt;贝利萨留（约505年～565年），又名贝利萨留斯，拜占庭帝国统帅、军事家。他一生当中的大多数战役是以少胜多。&lt;br&gt;贝利萨留出生于色雷斯。早年任皇帝查士丁尼一世的侍卫。527年率军参加对波斯的战争。529年，升任禁卫军长官。530年，任德拉总督，击败4万波斯-阿拉伯联军，名声大振。532年，镇压君士坦丁堡的尼卡起义，解救被围困的皇帝。533～534年，仅率1万步兵和6000骑兵入侵北非，灭汪达尔-阿兰王国并俘其国王。回国后被授予执政官称号。535年，出征意大利的东哥特王国，登陆西西里岛。536年攻入意大利南部，随后北上占领罗马。540年，攻陷东哥特都城拉韦纳，俘东哥特王。曾经用“自己将政变”为计谋欺骗敌方获胜，结果因此受到查士丁尼一世的怀疑。562年，被指控参与谋反，被捕入狱。563年，获释。565年，去世，享年61岁。&lt;/p&gt;</summary>
    
    
    
    <category term="76.Games" scheme="https://beefyheisenberg.github.io/categories/76-Games/"/>
    
    
  </entry>
  
  <entry>
    <title>Ingress Prime</title>
    <link href="https://beefyheisenberg.github.io/76.Games/Ingress/"/>
    <id>https://beefyheisenberg.github.io/76.Games/Ingress/</id>
    <published>2023-08-28T12:08:57.893Z</published>
    <updated>2023-08-28T12:08:57.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Ingress 是一款基于地理位置的大型多人侵入式虚拟现实游戏。</p><p>游戏的故事背景是一群欧洲科学家偶然发现某种神秘的能量 XM（Exotic Matter），这一能量的来源和用途无人知晓，研究人员认为可以开发并善用这能量，但另一方面却担心这样的能量会影响人们的思考甚至被能量本身奴役。</p><p>游戏中有两大主要阵营，这两大互相争夺主控权的全球性组织分别是“反抗军”和“启蒙军”。“启蒙军”（Enlightened，以绿色标示）阵营希望能接纳这股“神秘的能量XM”，并相信这股能量能赐予人类进步与改革，其追随者相信神秘的能量会催生影响重大的“启蒙运动”，使全人类进化。另一派“反抗军”（Resistance，以蓝色标示）阵营则奋力捍卫并守护仅存的人性，有些人认为他们对于变化或进步感到畏惧，但反抗军坚信这一切都是为了保护人类。游戏的玩家被称为特工（Agent），两个阵营互相角力，争夺控制真实世界中的地标性建筑或雕塑等Portal（译作“传送门”）。</p><p>游戏内容和真实世界的地理状况结合，游戏会透过手持装置的GPS、AGPS以及Wi-Fi资讯确认玩家的位置，而玩家可以透过游戏的扫描器（Scanner）界面看到自身周围的传送门、XM或物品。游戏地图上各处散落着白色亮点，代表XM所在的位置，玩家在接近XM时会自动收集，而对传送门进行任何操作均需耗用XM。传送门主要是各种建筑、雕塑、艺术品等，玩家需亲自持手机接近这些传送门，进行部署（Deploy）、入侵（Hack）、补充能量（Recharge）、发射XMP等动作。玩家在游戏中的目标是透过连接多个本阵营控制的传送门，建立控制场（Control Field），覆盖最多的“Mind Units（MUs）”。</p><ul><li><a href="https://zh.wikipedia.org/zh-sg/Ingress" target="_blank" rel="noopener">Ingress - 维基百科，自由的百科全书</a></li><li><a href="https://ingress.huijiwiki.com/wiki/%E5%85%B3%E4%BA%8EIngress" target="_blank" rel="noopener">Ingress维基 - 灰机wiki</a></li><li><a href="https://hz-ingress.gitbooks.io/ingress-tutorial/content/guide/basic_training/glossary.html" target="_blank" rel="noopener">术语表 · Ingress 中文游戏指南</a></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ul><li><a href="https://www.bilibili.com/video/BV1W4411g74c/?vd_source=5e050a2245c701c285e8cb8e667e09b6" target="_blank" rel="noopener">【Ingress Prime】真实游戏实况，给新人玩家的基础教程_哔哩哔哩_bilibili</a></li><li><a href="https://bjres.net/2016/07/13/%e6%96%b0%e6%89%8b%e6%94%bb%e7%95%a5%e7%b4%a2%e5%bc%95/" target="_blank" rel="noopener">新手攻略索引 – Ingress Resistance BeiJing</a></li></ul><h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><ul><li><a href="https://bjres.net/home/" target="_blank" rel="noopener">Ingress Resistance BeiJing</a></li></ul><h2 id="世界地图"><a href="#世界地图" class="headerlink" title="世界地图"></a>世界地图</h2><ul><li>Intel 地图： <a href="https://intel.ingress.com/intel" target="_blank" rel="noopener">https://intel.ingress.com/intel</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Ingress 是一款基于地理位置的大型多人侵入式虚拟现实游戏。&lt;/p&gt;
&lt;p&gt;游戏的故事背景是一群欧洲科学家偶然发现某种神秘的能量 XM（Exotic Matter），这一能量的来源和用途无人知晓，研究人员认为可以开发并善用这能量，但另一方面却担心这样的能量会影响人们的思考甚至被能量本身奴役。&lt;/p&gt;
&lt;p&gt;游戏中有两大主要阵营，这两大互相争夺主控权的全球性组织分别是“反抗军”和“启蒙军”。“启蒙军”（Enlightened，以绿色标示）阵营希望能接纳这股“神秘的能量XM”，并相信这股能量能赐予人类进步与改革，其追随者相信神秘的能量会催生影响重大的“启蒙运动”，使全人类进化。另一派“反抗军”（Resistance，以蓝色标示）阵营则奋力捍卫并守护仅存的人性，有些人认为他们对于变化或进步感到畏惧，但反抗军坚信这一切都是为了保护人类。游戏的玩家被称为特工（Agent），两个阵营互相角力，争夺控制真实世界中的地标性建筑或雕塑等Portal（译作“传送门”）。&lt;/p&gt;
&lt;p&gt;游戏内容和真实世界的地理状况结合，游戏会透过手持装置的GPS、AGPS以及Wi-Fi资讯确认玩家的位置，而玩家可以透过游戏的扫描器（Scanner）界面看到自身周围的传送门、XM或物品。游戏地图上各处散落着白色亮点，代表XM所在的位置，玩家在接近XM时会自动收集，而对传送门进行任何操作均需耗用XM。传送门主要是各种建筑、雕塑、艺术品等，玩家需亲自持手机接近这些传送门，进行部署（Deploy）、入侵（Hack）、补充能量（Recharge）、发射XMP等动作。玩家在游戏中的目标是透过连接多个本阵营控制的传送门，建立控制场（Control Field），覆盖最多的“Mind Units（MUs）”。&lt;/p&gt;</summary>
    
    
    
    <category term="76.Games" scheme="https://beefyheisenberg.github.io/categories/76-Games/"/>
    
    
  </entry>
  
  <entry>
    <title>自制榨果汁</title>
    <link href="https://beefyheisenberg.github.io/74.Foods/%E8%87%AA%E5%88%B6%E6%A6%A8%E6%9E%9C%E6%B1%81/"/>
    <id>https://beefyheisenberg.github.io/74.Foods/%E8%87%AA%E5%88%B6%E6%A6%A8%E6%9E%9C%E6%B1%81/</id>
    <published>2023-08-28T12:08:57.873Z</published>
    <updated>2023-08-28T12:08:57.873Z</updated>
    
    <content type="html"><![CDATA[<p>@ref：知乎 《你曾榨出过最好喝的果蔬汁搭配是什么？ - 毛羽立的回答 - 知乎》</p><p>我在台湾交换时，学校门口的夜市有一个现打蔬果汁摊儿，永远排长队。<br>有凤梨草莓猕猴桃汁，地瓜山药牛奶，木瓜鲜橙胡萝卜汁，红豆薏米牛奶……<br>还有几种以颜色命名的蔬果汁，内容物我记不太清了，大致描述一下。</p><ul><li>红色：草莓，蕃茄，西瓜，木瓜，莲雾，桃子</li><li>橙色：柠檬，甜橙，胡萝卜，芒果，南瓜，凤梨，柚子</li><li>绿色：小麦草，芭乐，芹菜，猕猴桃，芦荟，苦瓜</li><li>白色：香蕉，苹果，梨，薏仁，黄瓜，牛油果</li><li>黑色：葡萄，桑葚，黑布林，蓝莓</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@ref：知乎 《你曾榨出过最好喝的果蔬汁搭配是什么？ - 毛羽立的回答 - 知乎》&lt;/p&gt;
&lt;p&gt;我在台湾交换时，学校门口的夜市有一个现打蔬果汁摊儿，永远排长队。&lt;br&gt;有凤梨草莓猕猴桃汁，地瓜山药牛奶，木瓜鲜橙胡萝卜汁，红豆薏米牛奶……&lt;br&gt;还有几种以颜色命名的蔬果汁</summary>
      
    
    
    
    <category term="74.Foods" scheme="https://beefyheisenberg.github.io/categories/74-Foods/"/>
    
    
    <category term="吃喝的修养" scheme="https://beefyheisenberg.github.io/tags/吃喝的修养/"/>
    
  </entry>
  
  <entry>
    <title>午餐肉</title>
    <link href="https://beefyheisenberg.github.io/74.Foods/%E5%8D%88%E9%A4%90%E8%82%89/"/>
    <id>https://beefyheisenberg.github.io/74.Foods/%E5%8D%88%E9%A4%90%E8%82%89/</id>
    <published>2023-08-28T12:08:57.847Z</published>
    <updated>2023-08-28T12:08:57.848Z</updated>
    
    <content type="html"><![CDATA[<p>@ref 豆瓣 《午餐肉爱好者的自我修养——顶级午餐肉指南》</p><p>新手入门： 梅林<br><img src="/images/2022/IMG20220922-5.png" alt=""></p><p>中阶识货：长城白猪午餐肉<br><img src="/images/2022/IMG20220922-6.png" alt=""></p><p>高阶吃货：德和云腿午餐肉<br><img src="/images/2022/IMG20220922-7.png" alt=""></p><p>寻根觅祖：世棒午餐肉（SPAM）<br><img src="/images/2022/IMG20220922-8.png" alt=""></p><p>欧洲货才装B：丹麦三花午餐肉（Tuilp）<br><img src="/images/2022/IMG20220922-9.png" alt=""></p><hr><p>@ref: <a href="https://zhuanlan.zhihu.com/p/21744705" target="_blank" rel="noopener">我们一不小心吃掉了15公斤午餐肉 - 知乎</a></p><p><img src="/images/2022/IMG20220922-10.png" alt=""></p><hr><p>上面提到的：梅林、长城</p><p>梅林：<br>1949年上海解放后，梅林罐头食品厂股份有限公司先于1954年公私合营，由上海轻工业管理局主管，后于1956年成为地方工业部掌管的重点企业。1958年1月8日，《人民日报》发表社论《从梅林看全国》，掀起增产节约、反对浪费的高潮，在全国产生了很大的影响，同时也极大的促进和激发了梅林罐头食品厂的创造热情。于是，梅林厂“双革”创奇迹，竞赛掀热潮，罐头品种增加到200余种。1960年10月1日，地处虹桥路808号的梅林罐头食品厂移至军工路224号，并将拥有较好制罐生产基础和技术实力的上海益民食品二厂的职工、设备全部并入。</p><p>长城：<br>1953年，苏联首次从我国进口水果罐头。当时，总公司尚无主管罐头业务的机构，而由主管水果业务的吴成章同志承办。1954年，我国对苏联出口罐头数量大增，有猪、牛、羊、家禽、水果、蔬菜等十多个品种。</p><p>1954年，我国首次对苏联出口猪肉罐头,是按我国传统口味生产的红烧猪肉，年底，李瑞征副经理去苏联谈判，苏联方面提出红烧肉不适合苏联人民的口味，不久苏联方面派罐头专家来试制清蒸猪肉；捷克派罐头专家试制原汁猪肉、午餐肉；民主德国派罐头专家试制浓汁猪肉（又称古拉许），这些品种基本上都是生猪肉装罐，不加酱油、白糖等调味品，原汁原味。当时，生产对苏联出口的罐头厂，都有苏联罐头专家驻厂或巡回检查验收才能发货。</p><p>对苏联、东欧出口罐头，统一使用长城牌商标，由总公司统一对外签订供货合同下达各地执行。对资出口罐头由上海、天津、广州、汕头、南宁、福州、厦门、青岛、大连等口岸公司对外经营。每个口岸都有一个或两个专用商标。上海梅林牌、绿叶牌，天津长城牌，广州、汕头天坛牌、珠江牌，南宁象山牌，福州、厦门水仙花牌，青岛飞轮牌、牡丹牌，大连红梅牌。有些品种如红烧猪肉、红烧扣肉、红烧牛肉、红烧鸡、红烧鸭、菠萝、桔子等，几个口岸交叉经营。</p><p>@ref： <a href="https://zhuanlan.zhihu.com/p/60363901" target="_blank" rel="noopener">忆五十年代我国的罐头生产和出口 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;@ref 豆瓣 《午餐肉爱好者的自我修养——顶级午餐肉指南》&lt;/p&gt;
&lt;p&gt;新手入门： 梅林&lt;br&gt;&lt;img src=&quot;/images/2022/IMG20220922-5.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;中阶识货：长城白猪午餐肉&lt;br&gt;&lt;img src=&quot;/images/2022/IMG20220922-6.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;高阶吃货：德和云腿午餐肉&lt;br&gt;&lt;img src=&quot;/images/2022/IMG20220922-7.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;寻根觅祖：世棒午餐肉（SPAM）&lt;br&gt;&lt;img src=&quot;/images/2022/IMG20220922-8.png&quot; alt&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="74.Foods" scheme="https://beefyheisenberg.github.io/categories/74-Foods/"/>
    
    
    <category term="吃喝的修养" scheme="https://beefyheisenberg.github.io/tags/吃喝的修养/"/>
    
  </entry>
  
  <entry>
    <title>啤酒</title>
    <link href="https://beefyheisenberg.github.io/74.Foods/%E5%95%A4%E9%85%92/"/>
    <id>https://beefyheisenberg.github.io/74.Foods/%E5%95%A4%E9%85%92/</id>
    <published>2023-08-28T12:08:57.840Z</published>
    <updated>2023-08-28T12:08:57.841Z</updated>
    
    <content type="html"><![CDATA[<p>Cheers🍻！</p><h2 id="啤酒分类"><a href="#啤酒分类" class="headerlink" title="啤酒分类"></a>啤酒分类</h2><p>艾尔啤酒：或是人类最早的啤酒</p><ul><li>艾尔（Ale），又称为顶部发酵（Top Fermentating）。使用该种方式发酵的啤酒，酵母位于啤酒液体顶部，通过表面大量聚集泡沫发酵。这种发酵方式适合温度高的环境，约16℃~24℃最佳，这样发酵的代谢产物能更多样。比如会产生酰类和酯类，这些物质极大地影响了啤酒风味，也是艾尔啤酒当中复杂香气的重要来源。<br>最初的艾尔啤酒并不加入啤酒花，后来渐渐地人们发现，在发酵过程中加入啤酒花后，不但可以延长保存期，还可以增加啤酒的苦味和香味。如今，艾尔啤酒呈现琥珀色，外观透亮，泡沫丰富细腻，挂杯持久，香气丰富，麦芽香气、酯香、酒花香气平衡宜人。<br> 在艾尔啤酒中，还有一些具体的细分，如淡色艾尔、IPA、APA、棕色艾尔、琥珀艾尔、烈性艾尔、小麦啤酒、波特、世涛等。</li><li>IPA（India Pale Ale）印度淡色艾尔： 最早是出现在印度的英国淡色艾尔啤酒。IPA啤酒为干型，呈深琥珀色，含大量酒花，口感偏苦，回味温醇，常带有热带水果味。</li><li>APA（ American Pale Ale）美式淡色艾尔：1980年11月美国的Sierra Nevada酒厂酿出了第一款实验性的美式淡色艾尔啤酒。APA啤酒的麦芽味相对较淡，苦味更明显，风味更浓郁，还常常带有一些柑橘水果的香气</li><li>波特啤酒（Porter）：是一种深色、麦芽味很浓、带点烘烤味道的艾尔啤酒。波特啤酒与棕色艾尔型啤酒不同，它更烈、酒体更丰富、颜色更深并带有更多的烘烤麦芽的味道。和艾尔啤酒的另一分支——世涛非常相似，都是黑色，都有咖啡、太妃糖、焦糖、大麦、燕麦、果仁等香气。</li></ul><p>拉格啤酒：全世界占比90%的啤酒</p><ul><li>拉格（Lager），又称为底部发酵（Bottom fermenting）。拉格啤酒发酵时，酵母在液体底部，发酵温度要求较低，酒精含量较低。由于酵母沉在发酵醪底部，酵母主要以单一的酒精代谢为主，所以拉格啤酒的口感更加简单，主要是大麦和小麦的原味。<br>拉格啤酒也包括一些细分种类，如淡色拉格、深色拉格、皮尔森、博克等。</li><li>皮尔森：诞生于捷克，如今遍布全世界，属于淡色系的拉格啤酒，爽口清冽，有淡淡的啤酒花苦味。皮尔森采用下层发酵法，是用浅色麦芽苦味较重的啤酒花酿造的lager（拉格）啤酒，麦汁浓度最高不超过12.5度。</li><li>深色拉格：颜色范围覆盖至琥珀色到非常深的红棕色，酒精度一般在 4.5%-6% 之间，通常带有烘烤、可可豆和焦糖等风味，口感比较柔和饱满。德国黑啤就是大家比较熟知的深色拉格。</li></ul><p>生啤熟啤：根据杀菌情况区分</p><ul><li>生啤是指不经过传统高温杀菌的啤酒，这类啤酒中还含有活性酵母菌，一般保存时间不宜太长，通常为桶装，口感鲜美，营养丰富。</li><li>熟啤是经过灭菌处理的啤酒，保存时间较长。起初是通过巴氏（高温瞬时）灭菌，但会使啤酒伴随老熟的味道；随着啤酒酿造技术成熟，美国、日本及欧洲一些国家采用低温膜过滤以及冷杀菌，具有较长的保质期，一般选择瓶装或罐装。</li></ul><h2 id="精酿入门"><a href="#精酿入门" class="headerlink" title="精酿入门"></a>精酿入门</h2><p><a href="https://www.zhihu.com/question/319531361/answer/1945585776" target="_blank" rel="noopener">有什么可以当口粮的精酿啤酒？ - 知乎</a></p><p><a href="https://www.zhihu.com/question/288080401" target="_blank" rel="noopener">精酿啤酒和国内普通啤酒有什么本质的区别？ - 知乎</a></p><ul><li>精酿啤酒比流水线生产的工业啤酒更追求品质，原料、工艺的选择都以突出品质为前提，始终把啤酒的风味放在首位。</li><li>用料上，精酿啤酒不计成本采用精良的原料，大部分使用纯麦芽糖化，工业啤酒更多采用低成本原料，例如大米，糖浆，玉米、淀粉等代替麦芽。</li><li>原料使用上，传统的工艺要求啤酒只能使用四种原材料，麦芽、酒花、酵母、水，但随着社会发展，现在的精酿更加多样，也有添加果汁等原料。whatever，区别于工业啤酒的使用低成本的原料发酵，使用添加剂、浸膏等代替酒花。</li><li>精酿啤酒讲究创新，在基础的四种原料外，大胆地尝试新原料，加入了很多匪夷所思的东西，有的精酿啤酒也会采用玉米、淀粉这类原料，不过始终坚持不使用人工添加剂。所以两者的区别不在原料种类，而在于精酿更重视原料的天然，选择原料的目的是为了突出啤酒的风味，而工业啤酒是为了降低成本。</li><li>发酵方式上，精酿啤酒大多采用艾尔酵母，进行上层发酵。一些精酿啤酒也会采用拉格工艺（下发酵工艺）。所以不能把工艺当作区分二者的绝对标准。</li><li>酒精度和麦芽汁浓度区分不可靠，<br>同保质期一样，精酿啤酒也有低酒精度和低麦芽汁浓度的，所以不能说所有的精酿啤酒酒精度和麦芽汁浓度都比普通啤酒高。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cheers🍻！&lt;/p&gt;
&lt;h2 id=&quot;啤酒分类&quot;&gt;&lt;a href=&quot;#啤酒分类&quot; class=&quot;headerlink&quot; title=&quot;啤酒分类&quot;&gt;&lt;/a&gt;啤酒分类&lt;/h2&gt;&lt;p&gt;艾尔啤酒：或是人类最早的啤酒&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;艾尔（Ale），又称为顶部发酵（Top Fermentating）。使用该种方式发酵的啤酒，酵母位于啤酒液体顶部，通过表面大量聚集泡沫发酵。这种发酵方式适合温度高的环境，约16℃~24℃最佳，这样发酵的代谢产物能更多样。比如会产生酰类和酯类，这些物质极大地影响了啤酒风味，也是艾尔啤酒当中复杂香气的重要来源。&lt;br&gt;最初的艾尔啤酒并不加入啤酒花，后来渐渐地人们发现，在发酵过程中加入啤酒花后，不但可以延长保存期，还可以增加啤酒的苦味和香味。如今，艾尔啤酒呈现琥珀色，外观透亮，泡沫丰富细腻，挂杯持久，香气丰富，麦芽香气、酯香、酒花香气平衡宜人。&lt;br&gt; 在艾尔啤酒中，还有一些具体的细分，如淡色艾尔、IPA、APA、棕色艾尔、琥珀艾尔、烈性艾尔、小麦啤酒、波特、世涛等。&lt;/li&gt;
&lt;li&gt;IPA（India Pale Ale）印度淡色艾尔： 最早是出现在印度的英国淡色艾尔啤酒。IPA啤酒为干型，呈深琥珀色，含大量酒花，口感偏苦，回味温醇，常带有热带水果味。&lt;/li&gt;
&lt;li&gt;APA（ American Pale Ale）美式淡色艾尔：1980年11月美国的Sierra Nevada酒厂酿出了第一款实验性的美式淡色艾尔啤酒。APA啤酒的麦芽味相对较淡，苦味更明显，风味更浓郁，还常常带有一些柑橘水果的香气&lt;/li&gt;
&lt;li&gt;波特啤酒（Porter）：是一种深色、麦芽味很浓、带点烘烤味道的艾尔啤酒。波特啤酒与棕色艾尔型啤酒不同，它更烈、酒体更丰富、颜色更深并带有更多的烘烤麦芽的味道。和艾尔啤酒的另一分支——世涛非常相似，都是黑色，都有咖啡、太妃糖、焦糖、大麦、燕麦、果仁等香气。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拉格啤酒：全世界占比90%的啤酒&lt;/p&gt;</summary>
    
    
    
    <category term="74.Foods" scheme="https://beefyheisenberg.github.io/categories/74-Foods/"/>
    
    
    <category term="吃喝的修养" scheme="https://beefyheisenberg.github.io/tags/吃喝的修养/"/>
    
  </entry>
  
  <entry>
    <title>家庭常备药品</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/%E5%AE%B6%E5%BA%AD%E5%B8%B8%E5%A4%87%E8%8D%AF%E5%93%81/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/%E5%AE%B6%E5%BA%AD%E5%B8%B8%E5%A4%87%E8%8D%AF%E5%93%81/</id>
    <published>2023-08-28T12:08:57.832Z</published>
    <updated>2023-08-28T12:08:57.833Z</updated>
    
    <content type="html"><![CDATA[<p>家庭药箱中应有哪些常用药才能覆盖日常应急所需？根据家庭成员的构成，应主要覆盖内服药、外用药、特殊人群和辅助用品四大类别。</p><p>内服药常见的有感冒药、 解热镇痛药、止咳化痰药、止泻药、通便药、抗过敏药、助消化药七大类，一般不推荐储备抗菌类药物。<br>外用药主要有外用消毒药，如75%乙醇（酒精）、碘伏等；其他外用药如云南白药、风油精等；创可贴、灭菌医用棉签、纱布、绷带等卫生材料也要备齐。<br>家中如有特殊病患，还应按专科医师建议准备常用应急药物。如心血管疾病使用的硝酸甘油、阿司匹林，哮喘患者使用的硫酸沙丁胺醇气雾剂等。</p><h2 id="感冒药："><a href="#感冒药：" class="headerlink" title="感冒药："></a>感冒药：</h2><p>　　可备酚麻美敏片、维C银翘片。感冒是自限性疾病，一般不用药物治疗，多休息、多喝热水也可以自愈，但服药可缓解症状，所以口服感冒药通常是家庭药箱的常见成员。需要留意的是，很多感冒药都含有相同成分，一定要仔细看好说明书，避免重复用药，严格按推荐的剂量和用法。使用中成药时最好能分清风热感冒和风寒感冒或流行性感冒，不同类型的感冒使用的药物也不同。</p><h2 id="解热镇痛药："><a href="#解热镇痛药：" class="headerlink" title="解热镇痛药："></a>解热镇痛药：</h2><p>　　常见的有布洛芬混悬液、对乙酰氨基芬片。该类药物主要用于缓解感冒后发热、头痛、关节痛等症状。有胃病、消化道溃疡病史的人要慎用，疼痛症状明显加重或出现新的疼痛症状，以及连续用药三天不能缓解的，要咨询医生或药师。这两种药物均有儿童剂型可供选择。</p><h2 id="止咳化痰药："><a href="#止咳化痰药：" class="headerlink" title="止咳化痰药："></a>止咳化痰药：</h2><p>　　可备氢溴酸右美沙芬片、蛇胆川贝枇杷膏；化痰药物可以选择盐酸氨溴索片、乙酰半胱氨酸颗粒等。针对干咳，一般会使用中枢性镇咳药，目前，唯一一种非处方中枢性镇咳药是氢溴酸右美沙芬，市售有糖浆剂和片剂。</p><h2 id="止泻药："><a href="#止泻药：" class="headerlink" title="止泻药："></a>止泻药：</h2><p>　　可备口服补液盐散、蒙脱石散。前者能预防和纠正腹泻导致的脱水；后者是高效消化道黏膜保护剂，具有改善肠道的吸收和分泌功能，能有效阻止病原微生物的攻击。不过腹泻最好在发病初期到医院筛查病因，这样才能有的放矢。</p><h2 id="通便药："><a href="#通便药：" class="headerlink" title="通便药："></a>通便药：</h2><p>　　可选乳果糖。它不被人体吸收，通过刺激结肠蠕动，缓解便秘，尤其适宜老年人、孕产妇、儿童及术后便秘者。应注意，便秘不应单纯依赖药物治疗，还要从改变生活方式改良饮食习惯入手。</p><h2 id="抗过敏药："><a href="#抗过敏药：" class="headerlink" title="抗过敏药："></a>抗过敏药：</h2><p>　　如氯雷他定，属于抗组胺类抗过敏药，适用于皮肤过敏、食物及药物过敏等。氯雷他定除了有片剂外，还有儿童使用的糖浆剂和滴剂。</p><h2 id="助消化药："><a href="#助消化药：" class="headerlink" title="助消化药："></a>助消化药：</h2><p>　　如多酶片、健胃消食片等。</p><h2 id="家庭备药注意四大原则："><a href="#家庭备药注意四大原则：" class="headerlink" title="家庭备药注意四大原则："></a>家庭备药注意四大原则：</h2><p>　　第一，根据家庭人员的组成和健康状况备药，注意老人、小孩与孕妇的用药；严禁混入家庭成员过敏的药物；</p><p>　　第二，选择不良反应较少的非处方药（OTC药）；</p><p>　　第三，选择疗效稳定、用法简单的药物，如口服药、外用药等。</p><p>　　第四，选择常见病、多发病用药。家庭备药一般只是作为应急或方便，无需面面俱到。</p><hr><p>  @ref: <a href="http://baby.sina.com.cn/health/mmjk/hzbhy/2018-05-08/doc-ifyuwqfa7628610.shtml" target="_blank" rel="noopener">http://baby.sina.com.cn/health/mmjk/hzbhy/2018-05-08/doc-ifyuwqfa7628610.shtml</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;家庭药箱中应有哪些常用药才能覆盖日常应急所需？根据家庭成员的构成，应主要覆盖内服药、外用药、特殊人群和辅助用品四大类别。&lt;/p&gt;
&lt;p&gt;内服药常见的有感冒药、 解热镇痛药、止咳化痰药、止泻药、通便药、抗过敏药、助消化药七大类，一般不推荐储备抗菌类药物。&lt;br&gt;外用药主要有外用消毒药，如75%乙醇（酒精）、碘伏等；其他外用药如云南白药、风油精等；创可贴、灭菌医用棉签、纱布、绷带等卫生材料也要备齐。&lt;br&gt;家中如有特殊病患，还应按专科医师建议准备常用应急药物。如心血管疾病使用的硝酸甘油、阿司匹林，哮喘患者使用的硫酸沙丁胺醇气雾剂等。&lt;/p&gt;
&lt;h2 id=&quot;感冒药：&quot;&gt;&lt;a href=&quot;#感冒药：&quot; class=&quot;headerlink&quot; title=&quot;感冒药：&quot;&gt;&lt;/a&gt;感冒药：&lt;/h2&gt;&lt;p&gt;　　可备酚麻美敏片、维C银翘片。感冒是自限性疾病，一般不用药物治疗，多休息、多喝热水也可以自愈，但服药可缓解症状，所以口服感冒药通常是家庭药箱的常见成员。需要留意的是，很多感冒药都含有相同成分，一定要仔细看好说明书，避免重复用药，严格按推荐的剂量和用法。使用中成药时最好能分清风热感冒和风寒感冒或流行性感冒，不同类型的感冒使用的药物也不同。&lt;/p&gt;
&lt;h2 id=&quot;解热镇痛药：&quot;&gt;&lt;a href=&quot;#解热镇痛药：&quot; class=&quot;headerlink&quot; title=&quot;解热镇痛药：&quot;&gt;&lt;/a&gt;解热镇痛药：&lt;/h2&gt;</summary>
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
    <category term="药物指南" scheme="https://beefyheisenberg.github.io/tags/药物指南/"/>
    
  </entry>
  
  <entry>
    <title>中医药黑名单</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/%E4%B8%AD%E5%8C%BB%E8%8D%AF%E9%BB%91%E5%90%8D%E5%8D%95/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/%E4%B8%AD%E5%8C%BB%E8%8D%AF%E9%BB%91%E5%90%8D%E5%8D%95/</id>
    <published>2023-08-28T12:08:57.826Z</published>
    <updated>2023-08-28T12:08:57.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="马兜铃酸-细辛-amp-关木通-amp-鱼腥草"><a href="#马兜铃酸-细辛-amp-关木通-amp-鱼腥草" class="headerlink" title="马兜铃酸/细辛&amp;关木通&amp;鱼腥草"></a>马兜铃酸/细辛&amp;关木通&amp;鱼腥草</h2><ul><li>致病：马兜铃酸及其进入人体后代谢出来的马兜铃内酰胺1型会导致马兜铃酸肾病</li><li>药材：<ul><li>细辛(马兜铃科)</li><li>关木通(马兜铃科)</li><li>青木香</li><li>广防己</li><li>鱼腥草(折耳根)：目前被认为有强致癌性的是马兜铃酸I，而折耳根（鱼腥草）中含的则是马兜铃内酰胺-BII、马兜铃内酰胺-AII和马兜铃内酰胺-FII（总0.016g/kg）。鱼腥草不是马兜铃科的植物，但是其含有马兜铃酸在人体代谢后的产物内酰胺</li></ul></li><li>成品：<ul><li>当归四逆加吴茱萸生姜汤</li><li>龙胆泻肝丸</li><li>各类凉茶</li></ul></li><li>参考：<ul><li><a href="https://www.zhihu.com/question/47548920" target="_blank" rel="noopener">鱼腥草（折耳根）会导致马兜铃肾病，甚至肾衰吗？ - 知乎</a></li></ul></li></ul><h2 id="砷化物-雄黄"><a href="#砷化物-雄黄" class="headerlink" title="砷化物/雄黄"></a>砷化物/雄黄</h2><ul><li>药材：<ul><li>雄黄：四硫化四砷</li></ul></li><li>成品：<ul><li>牛黄解毒片：牛黄解毒片的成分有牛黄、雄黄、石膏、大黄、黄芩、桔梗、冰片和甘草</li></ul></li><li>参考：<ul><li><a href="https://www.zhihu.com/question/40735357" target="_blank" rel="noopener">牛黄解毒片中的雄黄会导致中毒么？ - 知乎</a></li></ul></li></ul><h2 id="重金属-朱砂"><a href="#重金属-朱砂" class="headerlink" title="重金属/朱砂"></a>重金属/朱砂</h2><ul><li>成分：硫化汞</li><li>成品：兰州牛黄清心丸</li></ul><h2 id="生物碱-乌头碱"><a href="#生物碱-乌头碱" class="headerlink" title="生物碱/乌头碱"></a>生物碱/乌头碱</h2><ul><li>致病：乌头类中药主要毒性成分是乌头碱等生物碱，人口服乌头碱3-5mg可使人致死。乌头碱主要损害循环系统及中枢神经系统，其对循环系统的损害主要是导致各种心律失常。</li><li>药材：<ul><li>附子：为毛茛科植物，母根叫乌头，为镇痉剂，冶风庳，风湿神经痛。侧根（子根）入药，叫附子。</li><li>草乌</li><li>川乌</li></ul></li><li>成品：<ul><li>云南白药</li></ul></li><li>参考：<ul><li><a href="http://yao.dxy.cn/article/72948" target="_blank" rel="noopener">云南白药中的毒药 - 丁香园</a></li><li><a href="http://news.163.com/special/reviews/aconite0910.html" target="_blank" rel="noopener">乌头类草药：处处带毒，防不胜防</a></li><li><a href="https://www.cmro.gov.hk/html/gb/health_info/pamphlet/The_safe_use_of_Chinese_medicines_containing_aconitum_alkaloids.html" target="_blank" rel="noopener">卫生署中医药规管办公室</a></li></ul></li></ul><h2 id="生物碱-番木鳖碱"><a href="#生物碱-番木鳖碱" class="headerlink" title="生物碱/番木鳖碱"></a>生物碱/番木鳖碱</h2><ul><li>致病：番木鳖碱（士的宁，strychnine）其口服中毒剂量成人一般为5～10 mg，口服致死量为30 mg。士的宁对整个中枢神经系统有兴奋作用。马钱子中毒的早期症状为头痛，头晕、恶心、呕吐、焦虑、烦躁不安及轻度抽搐，继之出现全身抽搐、感觉器官敏感性增高、牙关紧闭、痉笑、角弓反张、吞咽和呼吸困难。患者通常死于呼吸骤停。</li><li>药材：<ul><li>马钱子：马钱子是马钱科植物马钱的干燥成熟种子。马钱子含有多种生物碱，主要为番木鳖碱（士的宁，strychnine）和马钱子碱。别名有番木鳖、乌鸦眼、苦实、马前、牛银等</li></ul></li></ul><h2 id="黄连素"><a href="#黄连素" class="headerlink" title="黄连素"></a>黄连素</h2><p><a href="https://www.dxy.cn/bbs/newweb/pc/post/45745019" target="_blank" rel="noopener">长教训了！一颗黄连素片害我差点断送职业生涯</a></p><ul><li>蚕豆病是一种遗传性溶血性疾病，本质是红细胞葡萄糖-6-磷酸脱氢酶（G6PD）缺乏症的一种表现类型，这类病人可能因为食用蚕豆或服用特定药物诱发溶血反应，严重时可出现黄疸，甚至危及生命。</li><li>黄连素片（盐酸小檗碱片）就是蚕豆病的禁用药之一，这个药可能会导致蚕豆病病人溶血</li></ul><blockquote><p>黄连是一种常用的中药，不仅“治病”，还能“防病”。例如我国某些地区有给新生儿喂黄连的习俗，认为可以“去胎毒”。由于国内药物不良反应的监测与上报均不完善，我们很难得到黄连中毒及不良反应的全面信息，但新生儿因喂黄连导致中毒，产生溶血、胃肠道反应乃至致死的事件，却时有耳闻。<br>黄连并不会对所有新生儿或成人都产生毒性，而是针对某些特定人群。遗传的原因使这些人体内缺少一种酶，即葡萄糖-6-磷酸脱氢酶，简称G6PD。缺少这种酶的人，体内无法产生足够的NADPH，而NADPH又是抗氧化剂GSH循环使用的必须物质。简言之，缺少G6PD，人体就不能产生足够的抗氧化剂，容易受到氧自由基的损伤。人体中氧含量最丰富的细胞是专门携带氧的红细胞，而红细胞只能靠GSH来抗氧化。当体内氧化剂突然增多时，红细胞就会产生大量的氧自由基。正常人可以自体清除氧自由基，但缺少G6PD的人则不能，红细胞会受自由基损伤而大量破坏，也就是溶血反应。人会头痛、全身不适、高热、肾功能衰竭，严重者可致死。历史上记载这种病多见于蚕豆产地，大多因吃新鲜蚕豆而诱发，所以又叫蚕豆病。<br>中国人缺乏G6PD的很多，尤其是南方人群，据报道发病率最高的广东省可达8.7%。而给新生儿喂黄连的也以南方居多。因为历史的原因，这类习俗也传到了东南亚。因为“疗效”没有任何依据，却会有溶血的风险，在上世纪70年代，新加坡就禁用了黄连。2016年新加坡解除了黄连禁令，但仍然禁止给婴儿、G6PD酶素缺乏症患者、孕妇和哺乳期妇女使用。美国则在上世纪90年代禁用了含黄连的膳食补充剂。</p></blockquote><blockquote><p>参考： <a href="https://zhuanlan.zhihu.com/p/38325689" target="_blank" rel="noopener">黄连翻案为哪般？ - 知乎</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;马兜铃酸-细辛-amp-关木通-amp-鱼腥草&quot;&gt;&lt;a href=&quot;#马兜铃酸-细辛-amp-关木通-amp-鱼腥草&quot; class=&quot;headerlink&quot; title=&quot;马兜铃酸/细辛&amp;amp;关木通&amp;amp;鱼腥草&quot;&gt;&lt;/a&gt;马兜铃酸/细辛&amp;amp;关木通&amp;amp;鱼腥草&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;致病：马兜铃酸及其进入人体后代谢出来的马兜铃内酰胺1型会导致马兜铃酸肾病&lt;/li&gt;
&lt;li&gt;药材：&lt;ul&gt;
&lt;li&gt;细辛(马兜铃科)&lt;/li&gt;
&lt;li&gt;关木通(马兜铃科)&lt;/li&gt;
&lt;li&gt;青木香&lt;/li&gt;
&lt;li&gt;广防己&lt;/li&gt;
&lt;li&gt;鱼腥草(折耳根)：目前被认为有强致癌性的是马兜铃酸I，而折耳根（鱼腥草）中含的则是马兜铃内酰胺-BII、马兜铃内酰胺-AII和马兜铃内酰胺-FII（总0.016g/kg）。鱼腥草不是马兜铃科的植物，但是其含有马兜铃酸在人体代谢后的产物内酰胺&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成品：&lt;ul&gt;
&lt;li&gt;当归四逆加吴茱萸生姜汤&lt;/li&gt;
&lt;li&gt;龙胆泻肝丸&lt;/li&gt;
&lt;li&gt;各类凉茶&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参考：&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/47548920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鱼腥草（折耳根）会导致马兜铃肾病，甚至肾衰吗？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;砷化物-雄黄&quot;&gt;&lt;a href=&quot;#砷化物-雄黄&quot; class=&quot;headerlink&quot; title=&quot;砷化物/雄黄&quot;&gt;&lt;/a&gt;砷化物/雄黄&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;药材：&lt;ul&gt;
&lt;li&gt;雄黄：四硫化四砷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成品：&lt;ul&gt;
&lt;li&gt;牛黄解毒片：牛黄解毒片的成分有牛黄、雄黄、石膏、大黄、黄芩、桔梗、冰片和甘草&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参考：&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/40735357&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛黄解毒片中的雄黄会导致中毒么？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;重金属-朱砂&quot;&gt;&lt;a href=&quot;#重金属-朱砂&quot; class=&quot;headerlink&quot; title=&quot;重金属/朱砂&quot;&gt;&lt;/a&gt;重金属/朱砂&lt;/h2&gt;</summary>
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
    <category term="药物指南" scheme="https://beefyheisenberg.github.io/tags/药物指南/"/>
    
  </entry>
  
  <entry>
    <title>饮食健康.升糖指数（GI）</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E5%8D%87%E7%B3%96%E6%8C%87%E6%95%B0%EF%BC%88GI%EF%BC%89/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E5%8D%87%E7%B3%96%E6%8C%87%E6%95%B0%EF%BC%88GI%EF%BC%89/</id>
    <published>2023-08-28T12:08:57.817Z</published>
    <updated>2023-08-28T12:08:57.817Z</updated>
    
    <content type="html"><![CDATA[<ul><li>GI (Glycemic index / 升糖指数)：GI越高意味着食物转化成血糖的时间越短。</li><li>为何高碳水食物导致犯困：碳水化合物含量较高且升糖指数较高的，会迅速导致血糖升高从而导致大量胰岛素的分泌。胰岛素让一种特别的氨基酸—色氨酸进入大脑，而色氨酸在大脑中会转变成血清素导致人们犯困。</li><li>食物升糖指数： <ul><li>高GI食物： 白面包，白米，红薯，白薯</li><li>低GI食物： 黑豆，lentil，鹰嘴豆，芝麻，花生，瓜子，核桃，腰果，糙粮，蘑菇等</li></ul></li></ul><p><img src="/images/食物升糖指数（GI）/15948892509400.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;GI (Glycemic index / 升糖指数)：GI越高意味着食物转化成血糖的时间越短。&lt;/li&gt;
&lt;li&gt;为何高碳水食物导致犯困：碳水化合物含量较高且升糖指数较高的，会迅速导致血糖升高从而导致大量胰岛素的分泌。胰岛素让一种特别的氨基酸—色氨酸进入大脑，而</summary>
      
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
    <category term="饮食健康" scheme="https://beefyheisenberg.github.io/tags/饮食健康/"/>
    
  </entry>
  
  <entry>
    <title>饮食健康.高嘌呤食物</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E9%AB%98%E5%98%8C%E5%91%A4%E9%A3%9F%E7%89%A9/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E9%AB%98%E5%98%8C%E5%91%A4%E9%A3%9F%E7%89%A9/</id>
    <published>2023-08-28T12:08:57.812Z</published>
    <updated>2023-08-28T12:08:57.812Z</updated>
    
    <content type="html"><![CDATA[<p>▶ 嘌呤： 有机化合物，分子式C5H4N4,无色结晶，在人体内嘌呤氧化而变成尿酸。人体尿酸过高就会引起痛风。</p><p>▶ 食物含量(单位 100g食物/mg嘌呤)：</p><ul><li>低嘌呤（小于50毫克）：<ul><li>五谷类（米、麦、高梁、玉米、马铃薯）</li><li>蛋类（鸡蛋、鸭蛋）</li><li>奶制品（牛奶、奶酪）</li><li>水果</li></ul></li><li>中等嘌呤（50~150毫克）：<ul><li>肉类：鸡肉、猪肉、牛肉、羊肉、鱼100~150mg、虾80~130mg</li><li>豆类：黑豆、绿豆、红豆、花豆、碗豆</li></ul></li><li>高嘌呤：<ul><li>海产：紫菜270mg、</li><li>动物内脏： 鸭肝300mg、牛肝233mg、牛肾200mg、胰脏825mg</li><li>肉汤：160-400mg</li></ul></li></ul><blockquote><p>@ref: <a href="https://baike.baidu.com/item/%E5%98%8C%E5%91%A4%E9%A3%9F%E7%89%A9/8536185" target="_blank" rel="noopener">嘌呤食物_百度百科</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;▶ 嘌呤： 有机化合物，分子式C5H4N4,无色结晶，在人体内嘌呤氧化而变成尿酸。人体尿酸过高就会引起痛风。&lt;/p&gt;
&lt;p&gt;▶ 食物含量(单位 100g食物/mg嘌呤)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;低嘌呤（小于50毫克）：&lt;ul&gt;
&lt;li&gt;五谷类（米、麦、高梁、玉米、马铃薯</summary>
      
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
    <category term="饮食健康" scheme="https://beefyheisenberg.github.io/tags/饮食健康/"/>
    
  </entry>
  
  <entry>
    <title>饮食健康.生酮饮食</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E7%94%9F%E9%85%AE%E9%A5%AE%E9%A3%9F/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.%E7%94%9F%E9%85%AE%E9%A5%AE%E9%A3%9F/</id>
    <published>2023-08-28T12:08:57.807Z</published>
    <updated>2023-08-28T12:08:57.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生酮饮食"><a href="#生酮饮食" class="headerlink" title="生酮饮食"></a>生酮饮食</h2><p>▶ 生酮饮食：大幅降低碳水化合物比例，蛋白质比例不变，空缺出来的部分就靠脂肪类填补。</p><p>生酮饮食（ketogenic diet，或简称keto diet）指的是脂肪含量多、蛋白质含量中低、碳水化合物含量极低的食物。这类食物给人体带来酮症（ketosis），从而导致了酮类（ketones）分子的形成。当人体因缺少碳水化合物而被迫燃烧脂肪以补充能量时，上述过程就会发生。</p><p>「生酮」是指一个令身体产「生」「酮」体的过程。由于摄取极低量的碳水化合物，促使肝糖用尽，身体便会开始燃烧脂肪，继而产生称为「酮体」的代谢物。</p><blockquote><p>医学上曾经主用于治疗儿童的困难控制型癫痫；<br>正常情况下，碳水化合物经人体吸收后会转化为葡萄糖运往身体各处及供给能量，尤其是用于维持大脑运作。然而由于生酮饮食中只摄取少量的低碳水化合物，肝脏便会将脂肪转换为脂肪酸和酮体。酮体运到脑部取代葡萄糖成为能量来源。当血液中酮体含量达到一定程度时，即为酮症，能缓和癫痫的频繁发作。</p></blockquote><p><img src="/images/2022/20220226012906.png" alt=""></p><h2 id="如何安排三餐"><a href="#如何安排三餐" class="headerlink" title="如何安排三餐"></a>如何安排三餐</h2><p>一份生酮食谱需要人们严格执行膳食计划，其中包括：像培根、多脂奶油和黄油等高脂肪食物，与此同时，还要严格限制如淀粉类蔬菜的摄入，包括：番薯、全谷物以及某些特定的水果。这种饮食习惯上的巨大改变会导致呕吐、消化不良、无意识的体重减轻以及风险增高的营养不良的现象。</p><p>每日热量 = 5%碳水 + 25%蛋白质 + 70%脂肪</p><ul><li>在进行生酮饮食时，碳水化合物应只占总热量的5%！生酮饮食餐单的比例限定每天碳水化合物的摄取量少于50克，从而降低胰岛素的分泌量，减少胰岛素阻抗的程度，更能稳定体重。</li><li>蛋白质提供20%到25%的热量</li><li>依靠脂肪提供约70%到75%剩下最大部分的热量。</li></ul><p>三餐示例:</p><ul><li>早餐:<ul><li>煎鸡蛋</li><li>咖啡或热茶中加入一大已融化的奶油、椰子油或中链脂肪酸油来作为生酮饮品<ul><li>午餐:</li><li>鸡肉沙拉, 搭配 初榨橄榄油、牛油果油或以这些油品来制作的沙律酱</li><li>晚餐:</li><li>煎三文鱼</li></ul></li></ul></li></ul><h2 id="阿特金斯饮食法"><a href="#阿特金斯饮食法" class="headerlink" title="阿特金斯饮食法"></a>阿特金斯饮食法</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E7%89%B9%E9%87%91%E6%96%AF%E9%A5%AE%E9%A3%9F%E6%B3%95" target="_blank" rel="noopener">阿特金斯饮食法 - 维基百科，自由的百科全书</a></p><blockquote><p>阿特金斯饮食法（英语：Atkins diet）是美国医生罗伯特·阿特金斯（Robert Atkins）创造的一种颇具争议的减肥饮食方法，其要求完全不吃碳水化合物，而可以吃高蛋白的食品，即不吃任何淀粉类、高糖分的食品，而多吃肉类、鱼。其核心是控制碳水化合物的摄入量，类似生酮饮食，从而将人体从消耗碳水化合物的代谢转化成以消耗脂肪为主的代谢模式。[1][2]阿特金斯饮食法被认为属于“食物盲从”，只有薄弱的证据支撑其在减肥方面的有效性。<br>多吃高蛋白质食物会增加肾的负担，所以该方法并不适合有肾脏病的人使用（多数国家的肾脏疾病患病率超过10%，而且许多轻微的肾脏疾病患者并不自知）。</p></blockquote><p><a href="https://www.zhihu.com/question/280966542" target="_blank" rel="noopener">阿特金斯和生酮哪个好，有什么区别？阿特金斯减肥法会不会也让身体进入生酮期？ - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;生酮饮食&quot;&gt;&lt;a href=&quot;#生酮饮食&quot; class=&quot;headerlink&quot; title=&quot;生酮饮食&quot;&gt;&lt;/a&gt;生酮饮食&lt;/h2&gt;&lt;p&gt;▶ 生酮饮食：大幅降低碳水化合物比例，蛋白质比例不变，空缺出来的部分就靠脂肪类填补。&lt;/p&gt;
&lt;p&gt;生酮饮食（ketogenic diet，或简称keto diet）指的是脂肪含量多、蛋白质含量中低、碳水化合物含量极低的食物。这类食物给人体带来酮症（ketosis），从而导致了酮类（ketones）分子的形成。当人体因缺少碳水化合物而被迫燃烧脂肪以补充能量时，上述过程就会发生。&lt;/p&gt;
&lt;p&gt;「生酮」是指一个令身体产「生」「酮」体的过程。由于摄取极低量的碳水化合物，促使肝糖用尽，身体便会开始燃烧脂肪，继而产生称为「酮体」的代谢物。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;医学上曾经主用于治疗儿童的困难控制型癫痫；&lt;br&gt;正常情况下，碳水化合物经人体吸收后会转化为葡萄糖运往身体各处及供给能量，尤其是用于维持大脑运作。然而由于生酮饮食中只摄取少量的低碳水化合物，肝脏便会将脂肪转换为脂肪酸和酮体。酮体运到脑部取代葡萄糖成为能量来源。当血液中酮体含量达到一定程度时，即为酮症，能缓和癫痫的频繁发作。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
    <category term="饮食健康" scheme="https://beefyheisenberg.github.io/tags/饮食健康/"/>
    
  </entry>
  
  <entry>
    <title>饮食健康.IBS（肠易激综合征）</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.IBS%EF%BC%88%E8%82%A0%E6%98%93%E6%BF%80%E7%BB%BC%E5%90%88%E5%BE%81%EF%BC%89/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/%E9%A5%AE%E9%A3%9F%E5%81%A5%E5%BA%B7.IBS%EF%BC%88%E8%82%A0%E6%98%93%E6%BF%80%E7%BB%BC%E5%90%88%E5%BE%81%EF%BC%89/</id>
    <published>2023-08-28T12:08:57.799Z</published>
    <updated>2023-08-28T12:08:57.799Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>肠易激综合征（irritable bowel syndrome，IBS）</p><ul><li>“喝了冰冻饮料就会拉肚子”</li><li>“紧张一点会有腹痛感”</li><li>“吃了某些‘寒气’食物就会拉肚子”</li><li>“肚子痛然后马上就像上厕所”</li><li>压力、紧张也会导致： <a href="https://mp.weixin.qq.com/s/xYoaQaW1N-oM9gmISHGtKw" target="_blank" rel="noopener">一有压力就胃痛，肠易激综合征如何解决？</a></li></ul></li><li><p>什么引起：腹泻由FODMAP（Fermentable Oligo-, Di-, Mono-saccharides And Polyols，可发酵的寡糖，二糖，单糖和多元醇）引起，FODMAP包括：</p><ul><li>Fructose：果糖</li><li>Lactose：乳糖</li><li>Mannitol：甘露糖醇</li><li>Sorbitol：山梨糖醇</li><li>GOS：低聚半乳糖</li><li>Fructan：果聚糖</li></ul></li></ul><ul><li><p>为什么FODMAP等糖类引起腹泻：</p><ul><li>无法被小肠吸收的短链碳水化合物（被称为FODMAP）会将进入大肠，大肠内细菌会迅速发酵FODMAP并产生过量气体。</li><li>大量水分和过量气体导致肠道过分扩展，肠壁因扩张而过分延伸，肠壁上高度连接的神经会马上向大脑传输疼痛信号。于是人就会出现腹痛、腹泻。</li></ul></li><li><p>IBS患者不能吃什么：高FODMAP的食物</p><ul><li>Furctose 果糖： 蜂蜜</li><li>Lactos 乳糖： 牛奶</li><li>Mannitol 甘露糖醇/Sorbitol 山梨糖醇： 雪梨、桃子、苹果</li><li>GOS 低聚半乳糖/Fructan 果聚糖：小麦、黑麦、洋葱、大蒜、豆类</li></ul></li></ul><ul><li>IBS患者吃什么：低FODMAP的食物可以降低IBS症状，燕麦、香蕉、少量芒果、少量北杏仁是符合低FODMAP的食物<ul><li>麦片：避免添加奶粉和糖的麦片</li></ul></li></ul><p>图1: FODMAP糖类 和 引起腹泻的原因<br><img src="/images/IBS/15949232146885.jpg" alt="-w679"></p><p>识别生活中常见的高/低FODMAP食物：<br>注意! 面粉(面包,馒头,面)是高FODMAP, 米饭是低FODMAP食物<br><img src="/images/IBS/15949232497059.jpg" alt="-w679"></p><p>@ref： <a href="https://zhuanlan.zhihu.com/p/141590924" target="_blank" rel="noopener">经常肚子痛拉肚子？你很可能患有IBS - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;肠易激综合征（irritable bowel syndrome，IBS）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“喝了冰冻饮料就会拉肚子”&lt;/li&gt;
&lt;li&gt;“紧张一点会有腹痛感”&lt;/li&gt;
&lt;li&gt;“吃了某些‘寒气’食物就会拉肚子”&lt;/li&gt;
&lt;li&gt;“肚子痛然后马上就像上厕所”&lt;/li&gt;
&lt;li&gt;压力、紧张也会导致： &lt;a href=&quot;https://mp.weixin.qq.com/s/xYoaQaW1N-oM9gmISHGtKw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一有压力就胃痛，肠易激综合征如何解决？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么引起：腹泻由FODMAP（Fermentable Oligo-, Di-, Mono-saccharides And Polyols，可发酵的寡糖，二糖，单糖和多元醇）引起，FODMAP包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fructose：果糖&lt;/li&gt;
&lt;li&gt;Lactose：乳糖&lt;/li&gt;
&lt;li&gt;Mannitol：甘露糖醇&lt;/li&gt;
&lt;li&gt;Sorbitol：山梨糖醇&lt;/li&gt;
&lt;li&gt;GOS：低聚半乳糖&lt;/li&gt;
&lt;li&gt;Fructan：果聚糖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么FODMAP等糖类引起腹泻：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法被小肠吸收的短链碳水化合物（被称为FODMAP）会将进入大肠，大肠内细菌会迅速发酵FODMAP并产生过量气体。&lt;/li&gt;
&lt;li&gt;大量水分和过量气体导致肠道过分扩展，肠壁因扩张而过分延伸，肠壁上高度连接的神经会马上向大脑传输疼痛信号。于是人就会出现腹痛、腹泻。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IBS患者不能吃什么：高FODMAP的食物&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Furctose 果糖： 蜂蜜&lt;/li&gt;
&lt;li&gt;Lactos 乳糖： 牛奶&lt;/li&gt;
&lt;li&gt;Mannitol 甘露糖醇/Sorbitol 山梨糖醇： 雪梨、桃子、苹果&lt;/li&gt;
&lt;li&gt;GOS 低聚半乳糖/Fructan 果聚糖：小麦、黑麦、洋葱、大蒜、豆类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;IBS患者吃什么：低FODMAP的食物可以降低IBS症状，燕麦、香蕉、少量芒果、少量北杏仁是符合低FODMAP的食物&lt;ul&gt;
&lt;li&gt;麦片：避免添加奶粉和糖的麦片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图1: FODMAP糖类 和 引起腹泻的原因&lt;br&gt;&lt;img src=&quot;/images/IBS/15949232146885.jpg&quot; alt=&quot;-w679&quot;&gt;&lt;/p&gt;
&lt;p&gt;识别生活中常见的高/低FODMAP食物：&lt;br&gt;注意! 面粉(面包,馒头,面)是高FODMAP, 米饭是低FODMAP食物&lt;br&gt;&lt;img src=&quot;/images/IBS/15949232497059.jpg&quot; alt=&quot;-w679&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
    <category term="饮食健康" scheme="https://beefyheisenberg.github.io/tags/饮食健康/"/>
    
  </entry>
  
  <entry>
    <title>如何在 2 分钟内入睡</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/%E5%A6%82%E4%BD%95%E5%9C%A8%202%20%E5%88%86%E9%92%9F%E5%86%85%E5%85%A5%E7%9D%A1/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/%E5%A6%82%E4%BD%95%E5%9C%A8%202%20%E5%88%86%E9%92%9F%E5%86%85%E5%85%A5%E7%9D%A1/</id>
    <published>2023-08-28T12:08:57.794Z</published>
    <updated>2023-08-28T12:08:57.794Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/fall-asleep-in-2-min.png" alt="../_images/fall-asleep-in-2-min.png"></p><p>在二战那几年，美军意识到了一个问题：由于空中作战的巨大压力，许多飞行员都存在着应激反应，这让他们身体虚弱，不堪负重。从而犯下一系列致命的错误，无意击中友军飞机或者自己的误操作而受伤。</p><p>为了阻止飞行员和飞机的损失，海军少尉 Bud Winter 开始研究测试一种可以训练的放松方法，以便飞行员能够减压，提高反应速度，增加注意力减少恐惧。</p><p>战前 Winter 是一个成功的大学橄榄球和田径教练，他与心理学教授一起合作，帮助运动员在高压下放松并取得更好的表现。</p><p>他将睡眠定义为「身心放松的状态」。第一步是身体放松，第二步是心理放松。</p><h2 id="如何身体放松？"><a href="#如何身体放松？" class="headerlink" title="如何身体放松？"></a>如何身体放松？</h2><p>在「Relax and Win」一书中，Winter 写到了为战斗飞行员开发的这套入睡技术，战后用于运动员身上也特别奏效，他列出明确的步骤，教运动员如何放松：</p><ul><li>坐在你的椅子上，两脚放在地板上。膝盖分开，手在膝盖内侧无力耷拉着。现在，闭上眼睛，放下下巴，直到它落在你的胸前。</li><li>有规律地、缓慢地深呼吸。让额头的皱纹都出现再舒展开，放松你的头皮。放松脸部其余肌肉，放松你的舌头和嘴唇，就像你在河边看到的鳟鱼那样嘴一开一合，缓慢呼吸。</li><li>现在来处理一下眼部八块肌肉。闭眼的同时，眼睛在眼窝中随意翻动，没有什么重点，就是上下左右翻动就行，缓慢呼吸。</li><li>现在，把肩膀放的尽可能低，就算你认为很低了，但是让它们更低。感受脖子后面的肌肉，当你觉得已经很放松了，尝试着让它们再进一步。</li><li>现在放松你的胸部。深吸一口气，屏住，呼气并吹出你所有的紧张情绪。让你的胸部瘪下去，想象在椅子上，自己是一直笨重的水母。缓慢呼吸，呼气时，释放越来越多的紧张情绪。</li><li>现在关注手臂。放松右二头肌，右前臂也一样，然后右手，手指。然后在左臂重复，且保持缓慢呼吸。</li><li>你的上半身已经放松了，感觉温暖而愉快，感觉良好，幸福感侵入身体。</li><li>现在该下半身了，先右大腿肌肉，想象着肉挂在机构上，放松。然后是小腿肌肉，在之后是右脚踝和脚部肌肉。告诉自己，右腿没骨头。在左腿重复。感觉自己就是椅子上的一堆肉。</li><li>目前，我们身心放松，或者你觉得如此。为了保险，我们深呼吸三次，呼出最后的紧张，一次，呼，两次，呼，三次，呼~~~</li></ul><p>如果你无法感觉自己身体的松弛，以及水母般的感受，请尝试拉紧肌肉，然后使之放松。</p><p>如果遵从上述步骤，你可以达到一个很好地放松水平。Winter 建议，在任何压力大的时候尝试这个练习，可以很好的放松，减压，提高专注力，促成更好的决策。</p><p>这只是第一步，身体的放松，下一步精神的放松可以「跨越门槛进入深度、轻松的睡眠」。</p><h2 id="如何精神放松"><a href="#如何精神放松" class="headerlink" title="如何精神放松"></a>如何精神放松</h2><p>Winter 认为，一旦你身体放松了，只要头脑十秒钟内没有任何活跃的想法，你就会睡着。快速入睡的关键就在于「<strong>停止你脑中奔腾的想法</strong>」，你必须停止反思当天的遗憾、忧虑、问题。</p><p>Winter 特别警告，<strong>不要有任何运动的想法</strong>：现代研究证实了，只要我们在脑海中想象身体运动，相关肌肉会处于激活状态。所以，当你试图入睡的时候，积极活跃的想法可能导致肌肉紧张并抑制睡眠。</p><p>所以，如果你想用最沉默的思考来填满你的脑袋，Winter 有三个建议，这里有任何一条都可以帮助你，只需要选一个就行，如果不行就选另一个：</p><ul><li>幻想这是一个温暖的春日，而且你正躺在一个非常宁静的湖上独木舟的里。你正在仰望蓝天与云朵，浮动的云彩。不要有任何其他想法。只要专注于个画面十秒钟。</li><li>想象你正躺在一个黑色天鹅绒大床上，而且房子的其他地方全都是黑色的，专注这个画面十秒钟。</li><li>第三个窍门，在脑海中说「不要想、不要想、不要想。。。」，持续十秒钟，消除其他想法。</li></ul><hr><p>@ref: <a href="https://www.artofmanliness.com/health-fitness/health/fall-asleep-fast/" target="_blank" rel="noopener">Fall Asleep Fast — In 2 Minutes or Less | Art of Manliness</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/fall-asleep-in-2-min.png&quot; alt=&quot;../_images/fall-asleep-in-2-min.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在二战那几年，美军意识到了一个问题：由于空中作战的巨大压力，许多飞行员都存在着应激反应，这让他们身体虚弱，不堪负重。从而犯下一系列致命的错误，无意击中友军飞机或者自己的误操作而受伤。&lt;/p&gt;
&lt;p&gt;为了阻止飞行员和飞机的损失，海军少尉 Bud Winter 开始研究测试一种可以训练的放松方法，以便飞行员能够减压，提高反应速度，增加注意力减少恐惧。&lt;/p&gt;
&lt;p&gt;战前 Winter 是一个成功的大学橄榄球和田径教练，他与心理学教授一起合作，帮助运动员在高压下放松并取得更好的表现。&lt;/p&gt;
&lt;p&gt;他将睡眠定义为「身心放松的状态」。第一步是身体放松，第二步是心理放松。&lt;/p&gt;</summary>
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
  </entry>
  
  <entry>
    <title>Fitness-and-Gym指南</title>
    <link href="https://beefyheisenberg.github.io/73.Health-and-Medicine/Fitness-and-Gym%E6%8C%87%E5%8D%97/"/>
    <id>https://beefyheisenberg.github.io/73.Health-and-Medicine/Fitness-and-Gym%E6%8C%87%E5%8D%97/</id>
    <published>2023-08-28T12:08:57.787Z</published>
    <updated>2023-08-28T12:08:57.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="健身房-器械"><a href="#健身房-器械" class="headerlink" title="健身房-器械"></a>健身房-器械</h1><h2 id="力竭和组间休息"><a href="#力竭和组间休息" class="headerlink" title="力竭和组间休息"></a>力竭和组间休息</h2><blockquote><p><a href="https://www.zhihu.com/question/25022205" target="_blank" rel="noopener">每组力竭的话和组间休息时间怎么安排？ - 知乎</a><br>什么是组间间歇？假设我们锻炼一个部位采用abcd四个动作，我们首先使用a动作，一般采用递增的重量连续做四组，a动作四组之间的休息时间即为组间间歇时间。还有一种情况是a动作四组结束之后与b动作之间的休息时间，同样b动作结束后连接c动作的时间。<br>正确的组间间歇：你可以通过带一个秒表或者一款心率表去健身房，通过这两块表来控制组间间歇时间，组间间歇一般在0s—90s之间（除硬拉，深蹲等大重量动作），并且时间越短越好。</p></blockquote><h2 id="Gym-颈前正握下拉"><a href="#Gym-颈前正握下拉" class="headerlink" title="[Gym]颈前正握下拉"></a>[Gym]颈前正握下拉</h2><p><img src="/images/Fitness-Gym/16038802165474.jpg" alt=""></p><h2 id="Gym-宽握引体向上"><a href="#Gym-宽握引体向上" class="headerlink" title="[Gym]宽握引体向上"></a>[Gym]宽握引体向上</h2><p><img src="/images/Fitness-Gym/16038803955092.jpg" alt=""></p><h1 id="使用哑铃进行练习"><a href="#使用哑铃进行练习" class="headerlink" title="使用哑铃进行练习"></a>使用哑铃进行练习</h1><h2 id="哑铃7天训练-飞特那斯"><a href="#哑铃7天训练-飞特那斯" class="headerlink" title="哑铃7天训练-飞特那斯"></a>哑铃7天训练-飞特那斯</h2><p><a href="https://www.zhihu.com/zvideo/1521844652630454272" target="_blank" rel="noopener">全身哑铃7天训练方案，适合所有人，家庭训练必备 - 知乎</a></p><p>哑铃7天训练时间表<br>第1天，背+肩：00：00-03：11<br>第2天，胸+肩：03：12-06：28<br>第3天，休息：06：28-06：30<br>第4天，二头+三头：06：30-11：18<br>第5天，三角肌：11：18-13：40<br>第6天，臀腿+小腿：13:40-16：33<br>第7天，休息:16：33-16：35</p><p><img src="/images/2022/IMG20220919.png" alt="../_images/2022/IMG20220919.png"></p><h3 id="Day-1（背-肩）"><a href="#Day-1（背-肩）" class="headerlink" title="Day 1（背+肩）"></a>Day 1（背+肩）</h3><p><img src="/images/2022/IMG20220919-1.png" alt="../_images/2022/IMG20220919-1.png"></p><p><img src="/images/2022/IMG20220919-2.png" alt="../_images/2022/IMG20220919-2.png"></p><p><img src="/images/2022/IMG20220919-3.png" alt="../_images/2022/IMG20220919-3.png"></p><p><img src="/images/2022/IMG20220919-4.png" alt="../_images/2022/IMG20220919-4.png"></p><p><img src="/images/2022/IMG20220919-5.png" alt="../_images/2022/IMG20220919-5.png"></p><p><img src="/images/2022/IMG20220919-6.png" alt="../_images/2022/IMG20220919-6.png"></p><p><img src="/images/2022/IMG20220919-7.png" alt="../_images/2022/IMG20220919-7.png"></p><h2 id="哑铃训练动作参考"><a href="#哑铃训练动作参考" class="headerlink" title="哑铃训练动作参考"></a>哑铃训练动作参考</h2><h3 id="单臂哑铃划船"><a href="#单臂哑铃划船" class="headerlink" title="单臂哑铃划船"></a>单臂哑铃划船</h3><p><img src="/images/Fitness-Gym/16038804712616.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038805257133.jpg" alt=""></p><h3 id="坐姿臂弯举"><a href="#坐姿臂弯举" class="headerlink" title="坐姿臂弯举"></a>坐姿臂弯举</h3><p><img src="/images/Fitness-Gym/16038810777986.jpg" alt=""></p><h3 id="哑铃颈后臂屈伸"><a href="#哑铃颈后臂屈伸" class="headerlink" title="哑铃颈后臂屈伸"></a>哑铃颈后臂屈伸</h3><p><img src="/images/Fitness-Gym/16038812423162.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038813322401.jpg" alt=""></p><h3 id="哑铃推举-侧平举"><a href="#哑铃推举-侧平举" class="headerlink" title="哑铃推举/侧平举"></a>哑铃推举/侧平举</h3><p><img src="/images/Fitness-Gym/16038813899796.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038821099928.jpg" alt=""></p><p><img src="/images/Fitness-Gym/16038821238073.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;健身房-器械&quot;&gt;&lt;a href=&quot;#健身房-器械&quot; class=&quot;headerlink&quot; title=&quot;健身房-器械&quot;&gt;&lt;/a&gt;健身房-器械&lt;/h1&gt;&lt;h2 id=&quot;力竭和组间休息&quot;&gt;&lt;a href=&quot;#力竭和组间休息&quot; class=&quot;headerlink&quot; title=&quot;力竭和组间休息&quot;&gt;&lt;/a&gt;力竭和组间休息&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/25022205&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每组力竭的话和组间休息时间怎么安排？ - 知乎&lt;/a&gt;&lt;br&gt;什么是组间间歇？假设我们锻炼一个部位采用abcd四个动作，我们首先使用a动作，一般采用递增的重量连续做四组，a动作四组之间的休息时间即为组间间歇时间。还有一种情况是a动作四组结束之后与b动作之间的休息时间，同样b动作结束后连接c动作的时间。&lt;br&gt;正确的组间间歇：你可以通过带一个秒表或者一款心率表去健身房，通过这两块表来控制组间间歇时间，组间间歇一般在0s—90s之间（除硬拉，深蹲等大重量动作），并且时间越短越好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Gym-颈前正握下拉&quot;&gt;&lt;a href=&quot;#Gym-颈前正握下拉&quot; class=&quot;headerlink&quot; title=&quot;[Gym]颈前正握下拉&quot;&gt;&lt;/a&gt;[Gym]颈前正握下拉&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/Fitness-Gym/16038802165474.jpg&quot; alt&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="73.Health-and-Medicine" scheme="https://beefyheisenberg.github.io/categories/73-Health-and-Medicine/"/>
    
    
    <category term="Gym" scheme="https://beefyheisenberg.github.io/tags/Gym/"/>
    
    <category term="健身房" scheme="https://beefyheisenberg.github.io/tags/健身房/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯公式</title>
    <link href="https://beefyheisenberg.github.io/72.Math-and-Logic/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/"/>
    <id>https://beefyheisenberg.github.io/72.Math-and-Logic/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/</id>
    <published>2023-08-28T12:08:57.782Z</published>
    <updated>2023-08-28T12:08:57.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="➤-贝叶斯公式"><a href="#➤-贝叶斯公式" class="headerlink" title="➤ 贝叶斯公式"></a>➤ 贝叶斯公式</h2><ul><li>P(A|B)是B发生的情况下, A发生的可能性, 贝叶斯公式:<br>$$ P(A|B) = P(B|A)*P(A)/P(B) $$</li></ul><p>@ref: <a href="https://zhuanlan.zhihu.com/p/22467549" target="_blank" rel="noopener">Think Bayes - 我所理解的贝叶斯定理 - 知乎</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;➤-贝叶斯公式&quot;&gt;&lt;a href=&quot;#➤-贝叶斯公式&quot; class=&quot;headerlink&quot; title=&quot;➤ 贝叶斯公式&quot;&gt;&lt;/a&gt;➤ 贝叶斯公式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;P(A|B)是B发生的情况下, A发生的可能性, 贝叶斯公式:&lt;br&gt;$$ P(A|B)</summary>
      
    
    
    
    <category term="72.Math-and-Logic" scheme="https://beefyheisenberg.github.io/categories/72-Math-and-Logic/"/>
    
    
  </entry>
  
  <entry>
    <title>傅里叶变换</title>
    <link href="https://beefyheisenberg.github.io/72.Math-and-Logic/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>https://beefyheisenberg.github.io/72.Math-and-Logic/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</id>
    <published>2023-08-28T12:08:57.777Z</published>
    <updated>2023-08-28T12:08:57.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="➤-傅里叶变换"><a href="#➤-傅里叶变换" class="headerlink" title="➤ 傅里叶变换"></a>➤ 傅里叶变换</h2><ul><li>傅里叶级数: 任何周期函数, 都可以看做不同振幅,不同相位的正弦波的叠加</li><li>图: 周期函数 → N个正弦波叠加</li><li>上图从频域看… 频域的x/y轴物理意义是? 即傅里叶级数的频谱</li><li>上图频域里的离散信号, 如果无限接近连续..</li><li>频域的相位谱</li><li>傅里叶级数: (时域)周期连续 → (频域)非周期离散</li><li>傅里叶变换: (时域)非周期连续→ (频域)非周期连续</li><li>虚数: 虚数i也即-1的平方根, 乘以虚数可以理解为: 旋转</li><li>欧拉公式: $$ e^(ix) = cos(x) + isin(x) $$</li></ul><p><img src="/images/2022/20220217153337.png" alt="../_images/Pasted image 20220217153337.png"></p><hr><p>@ref: <a href="https://zhuanlan.zhihu.com/p/19763358" target="_blank" rel="noopener">傅里叶分析之掐死教程（完整版）更新于2014.06.06 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;➤-傅里叶变换&quot;&gt;&lt;a href=&quot;#➤-傅里叶变换&quot; class=&quot;headerlink&quot; title=&quot;➤ 傅里叶变换&quot;&gt;&lt;/a&gt;➤ 傅里叶变换&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;傅里叶级数: 任何周期函数, 都可以看做不同振幅,不同相位的正弦波的叠加&lt;/li&gt;
&lt;li&gt;图: 周期函数 → N个正弦波叠加&lt;/li&gt;
&lt;li&gt;上图从频域看… 频域的x/y轴物理意义是? 即傅里叶级数的频谱&lt;/li&gt;
&lt;li&gt;上图频域里的离散信号, 如果无限接近连续..&lt;/li&gt;
&lt;li&gt;频域的相位谱&lt;/li&gt;
&lt;li&gt;傅里叶级数: (时域)周期连续 → (频域)非周期离散&lt;/li&gt;
&lt;li&gt;傅里叶变换: (时域)非周期连续→ (频域)非周期连续&lt;/li&gt;
&lt;li&gt;虚数: 虚数i也即-1的平方根, 乘以虚数可以理解为: 旋转&lt;/li&gt;
&lt;li&gt;欧拉公式: $$ e^(ix) = cos(x) + isin(x) $$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/2022/20220217153337.png&quot; alt=&quot;../_images/Pasted image 20220217153337.png&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;@ref: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/19763358&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;傅里叶分析之掐死教程（完整版）更新于2014.06.06 - 知乎&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="72.Math-and-Logic" scheme="https://beefyheisenberg.github.io/categories/72-Math-and-Logic/"/>
    
    
  </entry>
  
  <entry>
    <title>博弈论</title>
    <link href="https://beefyheisenberg.github.io/72.Math-and-Logic/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <id>https://beefyheisenberg.github.io/72.Math-and-Logic/%E5%8D%9A%E5%BC%88%E8%AE%BA/</id>
    <published>2023-08-28T12:08:57.770Z</published>
    <updated>2023-08-28T12:08:57.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博弈论相关概念"><a href="#博弈论相关概念" class="headerlink" title="博弈论相关概念"></a>博弈论相关概念</h1><ul><li>纳什均衡</li><li>囚徒困境</li><li>重复博弈</li><li>大众定理</li><li>信息</li><li>帕累托最优</li><li>零和博弈</li><li>非零和博弈</li><li>微分包含式</li><li>拍卖博弈</li></ul><h1 id="帕累托最优"><a href="#帕累托最优" class="headerlink" title="帕累托最优"></a>帕累托最优</h1><p><strong>帕累托最优</strong> 也称为帕累托效率（Pareto Efficiency）、帕雷托最佳配置，是博弈论中的重要概念，并且在经济学， 工程学和社会科学中有着广泛的应用。<br>　　帕累托最优是指资源分配的一种理想状态，假定固有的一群人和可分配的资源，从一种分配状态到另一种状态的变化中，在没有使任何人境况变坏的前提下，使得至少一个人变得更好，这就是帕累托改进或帕累托最优化。帕累托最优的状态就是不可能再有更多的帕累托改进的余地；换句话说，帕累托改进是达到帕累托最优的路径和方法。帕累托最优是公平与效率的“理想王国”。<br>　　帕累托最优回答的是效率问题。从社会福利角度出发，用效率来评价总体经济运行有其合理性，因为如果资源配置未达到帕累托最优，那么，总有一些人能改善境况而没有人会受损，也就是说，社会福利总量肯定能上升，那么通过一种恰当的分配或补偿措施，能使所有人的境况都有所改善。[1]</p><p><strong>举例1：</strong><br>假设现在有两个人，甲和乙，分10块蛋糕，并且两个人都喜欢吃蛋糕。10块蛋糕无论在两个人之间如何分配，都是帕累托最优，因为你想让某一个人拥有更大利益的唯一办法是从另一个人手里拿走蛋糕，导致的结果是那个被拿走蛋糕的人利益受损</p><h1 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h1><p><strong>纳什均衡</strong> 是指博弈中这样的局面，又称为非合作博弈均衡，对于每个参与者来说，只要其他人不改变策略，这个参与者就无法改善自己的状况。纳什证明了在每个参与者都只有有限种策略选择并允许混合策略的前提下，纳什均衡定存在。以两家公司的价格大战为例，价格大战存在着两败俱伤的可能，在对方不改变价格的条件下既不能提价，否则会进一步丧失市场;也不能降价,因为会出现赔本甩卖。于是两家公司可以改变原先的利益格局，通过谈判寻求新的利益评估分摊方案。相互作用的经济主体假定其他主体所选择的战略为既定时，选择自己的最优战略的状态，也就是纳什均衡。</p><p><strong>举例1：</strong><br>1950年，由就职于兰德公司的梅里尔·弗勒德和梅尔文·德雷希尔拟定出相关困境的理论，后来由顾问艾伯特·塔克以囚徒方式阐述，并命名为“囚徒困境”。经典的囚徒困境如下：</p><p>警方逮捕甲、乙两名嫌疑犯，但没有足够证据指控二人有罪。于是警方分开囚禁嫌疑犯，分别和二人见面，并向双方提供以下相同的选择：</p><ul><li>若一人认罪并作证检控对方（相关术语称“背叛”对方），而对方保持沉默，此人将即时获释，沉默者将判监10年。</li><li>若二人都保持沉默（相关术语称互相“合作”），则二人同样判监半年。</li><li>若二人都互相检举（互相“背叛”），则二人同样判监5年。</li></ul><p><img src="/images/博弈论-囚徒困境.png" alt=""></p><p><strong>解说：</strong></p><p>如同博弈论的其他例证，囚徒困境假定每个参与者（即“囚徒”）都是利己的，即都寻求最大自身利益，而不关心另一参与者的利益。参与者某一策略所得利益，如果在任何情况下都比其他策略要低的话，此策略称为“严格劣势”，理性的参与者绝不会选择。另外，没有任何其他力量干预个人决策，参与者可完全按照自己意愿选择策略。</p><p>囚徒到底应该选择哪一项策略，才能将自己个人的刑期缩至最短？两名囚徒由于隔绝监禁，并不知道对方选择；而即使他们能交谈，还是未必能够尽信对方不会反口。就个人的理性选择而言，检举背叛对方所得刑期，总比沉默要来得低。试设想困境中两名理性囚徒会如何作出选择：</p><ul><li>若对方沉默、我背叛会让我获释，所以会选择背叛。</li><li>若对方背叛指控我，我也要指控对方才能得到较低的刑期，所以也是会选择背叛。</li></ul><p>二人面对的情况一样，所以二人的理性思考都会得出相同的结论——选择背叛。背叛是两种策略之中的支配性策略。因此，这场博弈中唯一可能达到的纳什均衡，就是双方参与者都背叛对方，结果二人同样服刑5年。</p><p>这场博弈的纳什均衡，显然不是顾及团体利益的帕累托最优解决方案。以全体利益而言，如果两个参与者都合作保持沉默，两人都只会被判刑半年，总体利益更高，结果也比两人背叛对方、判刑5年的情况较佳。但根据以上假设，二人均为理性的个人，且只追求自己个人利益。均衡状况会是两个囚徒都选择背叛，结果二人判监均比合作为高，总体利益较合作为低。这就是“困境”所在。例子有效地证明了：非零和博弈中，帕累托最优和纳什均衡是互相冲突的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;博弈论相关概念&quot;&gt;&lt;a href=&quot;#博弈论相关概念&quot; class=&quot;headerlink&quot; title=&quot;博弈论相关概念&quot;&gt;&lt;/a&gt;博弈论相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;纳什均衡&lt;/li&gt;
&lt;li&gt;囚徒困境&lt;/li&gt;
&lt;li&gt;重复博弈&lt;/li&gt;
&lt;li&gt;大众定理&lt;/li&gt;
&lt;li&gt;信息&lt;/li&gt;
&lt;li&gt;帕累托最优&lt;/li&gt;
&lt;li&gt;零和博弈&lt;/li&gt;
&lt;li&gt;非零和博弈&lt;/li&gt;
&lt;li&gt;微分包含式&lt;/li&gt;
&lt;li&gt;拍卖博弈&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;帕累托最优&quot;&gt;&lt;a href=&quot;#帕累托最优&quot; class=&quot;headerlink&quot; title=&quot;帕累托最优&quot;&gt;&lt;/a&gt;帕累托最优&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;帕累托最优&lt;/strong&gt; 也称为帕累托效率（Pareto Efficiency）、帕雷托最佳配置，是博弈论中的重要概念，并且在经济学， 工程学和社会科学中有着广泛的应用。&lt;br&gt;　　帕累托最优是指资源分配的一种理想状态，假定固有的一群人和可分配的资源，从一种分配状态到另一种状态的变化中，在没有使任何人境况变坏的前提下，使得至少一个人变得更好，这就是帕累托改进或帕累托最优化。帕累托最优的状态就是不可能再有更多的帕累托改进的余地；换句话说，帕累托改进是达到帕累托最优的路径和方法。帕累托最优是公平与效率的“理想王国”。&lt;br&gt;　　帕累托最优回答的是效率问题。从社会福利角度出发，用效率来评价总体经济运行有其合理性，因为如果资源配置未达到帕累托最优，那么，总有一些人能改善境况而没有人会受损，也就是说，社会福利总量肯定能上升，那么通过一种恰当的分配或补偿措施，能使所有人的境况都有所改善。[1]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例1：&lt;/strong&gt;&lt;br&gt;假设现在有两个人，甲和乙，分10块蛋糕，并且两个人都喜欢吃蛋糕。10块蛋糕无论在两个人之间如何分配，都是帕累托最优，因为你想让某一个人拥有更大利益的唯一办法是从另一个人手里拿走蛋糕，导致的结果是那个被拿走蛋糕的人利益受损&lt;/p&gt;</summary>
    
    
    
    <category term="72.Math-and-Logic" scheme="https://beefyheisenberg.github.io/categories/72-Math-and-Logic/"/>
    
    
  </entry>
  
</feed>
