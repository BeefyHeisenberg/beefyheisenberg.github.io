<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扔掉笔记 ᐛ</title>
  
  <subtitle>dropNotes</subtitle>
  <link href="https://beefyheisenberg.github.io/atom.xml" rel="self"/>
  
  <link href="https://beefyheisenberg.github.io/"/>
  <updated>2023-04-28T00:14:18.762Z</updated>
  <id>https://beefyheisenberg.github.io/</id>
  
  <author>
    <name>beefyheisenberg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>迦太基文明</title>
    <link href="https://beefyheisenberg.github.io/66.History-and-Politics/%E8%BF%A6%E5%A4%AA%E5%9F%BA%E6%96%87%E6%98%8E/"/>
    <id>https://beefyheisenberg.github.io/66.History-and-Politics/%E8%BF%A6%E5%A4%AA%E5%9F%BA%E6%96%87%E6%98%8E/</id>
    <published>2023-04-28T00:14:18.762Z</published>
    <updated>2023-04-28T00:14:18.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迦太基（腓尼基人建立的古国）"><a href="#迦太基（腓尼基人建立的古国）" class="headerlink" title="迦太基（腓尼基人建立的古国）"></a>迦太基（腓尼基人建立的古国）</h2><p>迦太基一词在腓尼基语中读作“Qart-ḥadašt” ，意思是「新的城市」，其早期居民为迦南城市泰尔（Tyre或譯為推羅）的移民。在古羅馬文獻中，迦太基也被稱為「布匿」（拉丁語：Punici）。</p><p>前8世紀，<strong>腓尼基人</strong>在北非建立迦太基城，當時迦太基城還只是腓尼基城邦泰爾（Tyer）的海外殖民地。前650年，脫離泰爾獨立，建立城市國家古迦太基。</p><blockquote><p>據考證，前814年，腓尼基人蘇爾王國（位於現今黎巴嫩南部西南海岸）的狄多公主（Dido）因其兄庇格瑪里翁（Pygmalion）在國王死後，排斥公主而獨攬大權。為免遭迫害，狄多帶著財寶與僕人飄洋過海，在突尼斯灣登陸。她向柏柏人部落首領馬西塔尼求借一張牛皮之地棲身，得到應允；於是她便把一張牛皮切成一根根細條，然後把細牛皮連在一起，在緊靠海邊的山丘上圍起一塊地皮，建起了迦太基城。故而迦太基的卫城又叫柏萨，意为“一张牛皮”。</p></blockquote><p>古迦太基强势时疆土遼闊，勢力最大曾囊括今天北非沿岸、今西班牙中部、科西嘉島、薩丁尼亞島、西西里島和馬爾他島，首都迦太基富極一時，其基礎是農業与商業，在外貿易居民善航海与貿易，在國內居民又是出色的農民，很早就出現了奴隸佔有制莊園，因此在當時地中海地區成為最有活力的經濟強國。</p><blockquote><p>迦太基主要是貴族寡頭式掌權，其中商業奴隸主與農業奴隸主這兩個統治階級間則往往有利害衝突，這造成了日後與羅馬作戰時出現和戰不定的問題。[2]而最高行政官員有兩名，稱為蘇菲特，每年選舉產生，但選民限於富有的迦太基人，不過這兩位蘇菲特沒有兵權。迦太基與羅馬一樣，設有元老院，由300人組成。元老院擁有立法權和決策權，成員任期終身。並設有公民大會，但權力有限。此外，亦設有百人會議，共有成員104人，負責監察和作出審判。</p></blockquote><p>大約在前8世紀 - 前6世紀，迦太基開始向非洲內陸擴展，並控制了北非的大部份腓尼基人殖民地。與此同時，迦太基亦向西地中海進發，佔領了伊比利亚半岛南部海岸及其附近島嶼，前654年征服了西西里島西部及撒丁島，前535年奪取科西嘉島等，開始稱霸西地中海，與希臘分別控制著地中海的西東兩邊。<br>古迦太基曾與古希臘爭奪地中海霸權，後又與古羅馬爭奪霸權。最後因為在三次布匿戰爭中均被羅馬共和國打敗，並於前146年滅亡。</p><p>从前6世紀開始，迦太基開始與欲染指地中海西部的希臘人發生衝突。大約在前535年，迦太基人聯合伊特拉斯坎人，在科西嘉島近岸打敗了其中一支希臘人的艦隊。但是在前480年，敘拉古的領主格隆和阿克拉加斯的領主特隆所統率的希臘軍隊卻在西西里島大敗迦太基的軍隊。此後百年間，迦太基與希臘為了爭霸地中海而紛爭不斷。</p><p>直到前4世紀初，希臘在經歷<a href="伯罗奔尼撒战争.md">伯羅奔尼撒戰爭</a>後元氣大傷，開始停止在西西里殖民。而在希臘的皮洛士於西西里為希臘城邦作出最後一次對抗迦太基的戰事後，迦太基與希臘的紛爭大致告一段落。但取而代之的，卻是與更可怕的對手――羅馬所發生的戰爭。</p><p>前264～前146年，迦太基與羅馬發生了3次戰爭，史稱布匿战争。</p><ul><li>第一次布匿战争（前264年-前241年），主要是在地中海上的海战。开始在西西里岛交战，接着罗马进攻迦太基本土，迦太基被打败。</li><li>第二次布匿战争（前218年-前201年），三个中最著名的战争。迦太基主帅汉尼拔率6万大军穿过阿尔卑斯山，入侵罗马。罗马则出兵马赛切断汉尼拔的补给，此时迦太基国内矛盾激发，汉尼拔回军驰援，罗马乘机进攻迦太基本土。迦太基战败，丧失全部海外领地，交出舰船，并向罗马赔款。</li><li>第三次布匿战争（前149年-前146年），这是一场罗马以强凌弱的侵略战争。罗马主动进攻，长期围困迦太基城，迦太基不甘被进攻，于是奋起作战。可惜最后迦太基战败惨遭屠城，领土成为罗马的一个省份——阿非利加行省。<br>布匿战争的结果是迦太基被灭，迦太基城也被夷为平地，罗马争得了地中海西部的霸权。</li></ul><p>古迦太基滅亡之後，羅馬軍隊摧毀了迦太基城。後來在迦太基城原址附近建立新城，並成為羅馬的阿非利加行省。439年汪達爾人佔領迦太基，成為汪达尔-阿兰王国的首都。533年成為东罗马帝國的屬地，並成為東羅馬帝國重要文化中心。7世紀因阿拉伯帝國的崛起引發的戰亂而被徹底廢棄。</p><h2 id="闪米特人"><a href="#闪米特人" class="headerlink" title="闪米特人"></a>闪米特人</h2><p>闪米特人（阿拉伯文：ساميون，拉丁文：samium；德文：Semiten）词汇由德国人，冯施洛泽（August Ludwig von Schlözer），在1781年提出，用来指代民族语属亚非语系—闪米特语族人群，灵感来自《圣经》诺亚的长子Shem（闪）。<br>闪米特人不是单一民族，而是包含了母语属性有关联的群体民族，并且这些民族的亲疏关系尚不明确。</p><blockquote><p>苏美尔文明是闪米特人终结的吗？<a href="https://zhuanlan.zhihu.com/p/102021587" target="_blank" rel="noopener">苏美尔人与闪米特人的恩怨纠葛 - 知乎</a></p></blockquote><p>闪米特人的历史十分久远，至公元前30世纪初，按语言明显地分为东、西两大支。</p><ul><li>东闪米特，按现代分类法，此支称“闪米特北支”。东闪米特人生活在两河流域的北部，操阿卡德语，在与苏美尔人接触中吸收、融化了对方的语言。自公元前三千二百年至公元初，其代表为阿卡德人、巴比伦人、亚述人。</li><li>西支闪米特人又分三个分支：西北支（现称闪米特北中支）、中支（现称闪米特南中支）、南支（现称闪米特南支）。<ul><li>西北支（现称闪米特北中支），系指分布在巴勒斯坦、叙利亚、美索不达米亚北部的各民族，最早的代表为阿摩里特人、<strong>迦南人</strong>、乌加里特人，约在公元前二千年后，有<strong>腓尼基人</strong>、犹太人、阿拉米人、莫阿比特人、亚奥迪人等。</li><li>中支（现称闪米特南中支）约在公元前二千年至前一千年，其代表为利希亚尼特人、萨姆德人等，随后统一共称阿拉伯人，阿拉伯人是闪米特人最年轻的一支，起源于阿拉伯半岛。七世纪随着伊斯兰教的兴起，开始了闪米特人的一次大迁移。</li><li>南支（现称闪米特南支）分布在阿拉伯半岛的南部，阿拉伯半岛，可能是闪米特人的摇篮，闪米特人在这个地方成长之后，迁移到肥沃的新月地区（即伊拉克、叙利亚、黎巴嫩、巴勒斯坦和约旦），后来就成为历史上的巴比伦人、亚述人、腓尼基人和希伯来人。</li></ul></li></ul><p><strong>布匿人</strong>（英语：Punics），指北非历史上的一个源于迦太基的讲西闪米特语的民族，他们是腓尼基移民和北非的柏柏尔人原住民融合产生。不像其他的腓尼基人，除了沿海据点，布匿人控制了北非内陆和跨撒哈拉贸易，并在当地建立了地主贵族政治统治。</p><p>在考古学和语言学方面，“布匿”用来指代源于迦太基的希腊化及后期文化和腓尼基语中一种不同于腓尼基人起源城市泰尔的迦太基方言。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;迦太基（腓尼基人建立的古国）&quot;&gt;&lt;a href=&quot;#迦太基（腓尼基人建立的古国）&quot; class=&quot;headerlink&quot; title=&quot;迦太基（腓尼基人建立的古国）&quot;&gt;&lt;/a&gt;迦太基（腓尼基人建立的古国）&lt;/h2&gt;&lt;p&gt;迦太基一词在腓尼基语中读作“Qart-ḥadašt” ，意思是「新的城市」，其早期居民为迦南城市泰尔（Tyre或譯為推羅）的移民。在古羅馬文獻中，迦太基也被稱為「布匿」（拉丁語：Punici）。&lt;/p&gt;
&lt;p&gt;前8世紀，&lt;strong&gt;腓尼基人&lt;/strong&gt;在北非建立迦太基城，當時迦太基城還只是腓尼基城邦泰爾（Tyer）的海外殖民地。前650年，脫離泰爾獨立，建立城市國家古迦太基。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;據考證，前814年，腓尼基人蘇爾王國（位於現今黎巴嫩南部西南海岸）的狄多公主（Dido）因其兄庇格瑪里翁（Pygmalion）在國王死後，排斥公主而獨攬大權。為免遭迫害，狄多帶著財寶與僕人飄洋過海，在突尼斯灣登陸。她向柏柏人部落首領馬西塔尼求借一張牛皮之地棲身，得到應允；於是她便把一張牛皮切成一根根細條，然後把細牛皮連在一起，在緊靠海邊的山丘上圍起一塊地皮，建起了迦太基城。故而迦太基的卫城又叫柏萨，意为“一张牛皮”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;古迦太基强势时疆土遼闊，勢力最大曾囊括今天北非沿岸、今西班牙中部、科西嘉島、薩丁尼亞島、西西里島和馬爾他島，首都迦太基富極一時，其基礎是農業与商業，在外貿易居民善航海与貿易，在國內居民又是出色的農民，很早就出現了奴隸佔有制莊園，因此在當時地中海地區成為最有活力的經濟強國。&lt;/p&gt;</summary>
    
    
    
    <category term="66.History-and-Politics" scheme="https://beefyheisenberg.github.io/categories/66-History-and-Politics/"/>
    
    
    <category term="世界历史" scheme="https://beefyheisenberg.github.io/tags/世界历史/"/>
    
  </entry>
  
  <entry>
    <title>大舰巨炮-近代海战史</title>
    <link href="https://beefyheisenberg.github.io/66.History-and-Politics/%E5%A4%A7%E8%88%B0%E5%B7%A8%E7%82%AE-%E8%BF%91%E4%BB%A3%E6%B5%B7%E6%88%98%E5%8F%B2/"/>
    <id>https://beefyheisenberg.github.io/66.History-and-Politics/%E5%A4%A7%E8%88%B0%E5%B7%A8%E7%82%AE-%E8%BF%91%E4%BB%A3%E6%B5%B7%E6%88%98%E5%8F%B2/</id>
    <published>2023-04-28T00:14:18.757Z</published>
    <updated>2023-04-28T00:14:18.758Z</updated>
    
    <content type="html"><![CDATA[<p>多铆蒸钢，大舰巨炮。亿万炮塔，亿万荣光！</p><h1 id="海战史"><a href="#海战史" class="headerlink" title="海战史"></a>海战史</h1><ul><li>1805-<a href="https://zh.m.wikipedia.org/wiki/%E7%89%B9%E6%8B%89%E6%B3%95%E5%8A%A0%E6%B5%B7%E6%88%B0" target="_blank" rel="noopener">特拉法尔加海战 - 维基百科，自由的百科全书</a></li><li>1894-<a href="https://zh.m.wikipedia.org/wiki/%E9%BB%84%E6%B5%B7%E6%B5%B7%E6%88%98_(1894%E5%B9%B4" target="_blank" rel="noopener">黄海海战 (1894年) - 维基百科，自由的百科全书</a>)</li><li>1905-<a href="https://zh.m.wikipedia.org/wiki/%E5%AF%B9%E9%A9%AC%E6%B5%B7%E5%B3%A1%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">对马海峡海战 - 维基百科，自由的百科全书</a></li><li>1916-<a href="https://zh.m.wikipedia.org/wiki/%E6%97%A5%E5%BE%B7%E5%85%B0%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">日德兰海战 - 维基百科，自由的百科全书</a></li><li>1941-<a href="https://zh.wikipedia.org/wiki/%E7%8F%8D%E7%8F%A0%E6%B8%AF%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">珍珠港事件 - 维基百科，自由的百科全书</a></li><li>1942-<a href="https://zh.m.wikipedia.org/wiki/%E7%8F%8A%E7%91%9A%E6%B5%B7%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">珊瑚海海战 - 维基百科，自由的百科全书</a></li><li>1942-<a href="https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E5%B2%9B%E6%B5%B7%E6%88%98" target="_blank" rel="noopener">中途岛海战 - 维基百科，自由的百科全书</a></li><li>1944-<a href="https://zh.m.wikipedia.org/wiki/%E9%9B%B7%E4%BC%8A%E6%B3%B0%E7%81%A3%E6%B5%B7%E6%88%B0" target="_blank" rel="noopener">莱特湾海战 - 维基百科，自由的百科全书</a></li></ul><h1 id="陈列馆"><a href="#陈列馆" class="headerlink" title="陈列馆"></a>陈列馆</h1><ul><li><p><a href="https://page.om.qq.com/page/OpAfxwpDZC-zeS9jT2Ochq9Q0" target="_blank" rel="noopener">铁甲舰、前无畏舰、无畏舰、超无畏舰有啥区别？又是如何演化的？</a> @link: </p></li><li><p><a href="https://zh.m.wikipedia.org/zh/%E9%98%BF%E9%87%91%E7%A7%91%E7%89%B9%E5%8F%B7%E6%88%98%E5%88%97%E8%88%B0" target="_blank" rel="noopener">阿金科特号战列舰- 维基百科，自由的百科全书</a></p></li><li><a href="https://zhuanlan.zhihu.com/p/27545575" target="_blank" rel="noopener">多铆蒸刚的图腾——阿金库尔号战舰传奇 - 知乎</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%83%A1%E5%BE%B7%E5%8F%B7%E6%88%98%E5%88%97%E5%B7%A1%E6%B4%8B%E8%88%B0" target="_blank" rel="noopener">胡德号战列巡洋舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E6%81%A9%E9%9C%8D%E6%96%AF%E7%89%B9%E8%99%9F%E6%88%B0%E8%89%A6" target="_blank" rel="noopener">沙恩霍斯特号战列舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E7%B4%8D%E7%88%BE%E9%81%9C%E8%99%9F%E6%88%B0%E8%89%A6" target="_blank" rel="noopener">纳尔逊号战舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E7%BE%85%E5%BE%B7%E5%B0%BC%E8%99%9F%E6%88%B0%E8%89%A6" target="_blank" rel="noopener">罗德尼号战舰 - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%A8%81%E5%B0%94%E5%A3%AB%E4%BA%B2%E7%8E%8B%E5%8F%B7%E6%88%98%E5%88%97%E8%88%B0" target="_blank" rel="noopener">威尔士亲王号战列舰 - 维基百科，自由的百科全书</a></li><li><a href="https://www.sohu.com/a/391584137_99978337" target="_blank" rel="noopener">二战美军经典驱逐舰拉菲号</a></li><li><a href="https://zhuanlan.zhihu.com/p/20735323" target="_blank" rel="noopener">战巡金刚杂谈（一） - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/20807863" target="_blank" rel="noopener">战巡/战舰金刚杂谈（二） - 知乎</a></li><li><a href="https://zh.m.wikipedia.org/zh/%E9%9B%AA%E9%A2%A8%E8%99%9F%E9%A9%85%E9%80%90%E8%89%A6" target="_blank" rel="noopener">雪風號驅逐艦 - 维基百科，自由的百科全书</a></li><li><a href="https://zhuanlan.zhihu.com/p/266144718" target="_blank" rel="noopener">二战日本沉没的大中型水面舰艇 - 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;多铆蒸钢，大舰巨炮。亿万炮塔，亿万荣光！&lt;/p&gt;
&lt;h1 id=&quot;海战史&quot;&gt;&lt;a href=&quot;#海战史&quot; class=&quot;headerlink&quot; title=&quot;海战史&quot;&gt;&lt;/a&gt;海战史&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1805-&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E7%89%B9%E6%8B%89%E6%B3%95%E5%8A%A0%E6%B5%B7%E6%88%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;特拉法尔加海战 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1894-&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E9%BB%84%E6%B5%B7%E6%B5%B7%E6%88%98_(1894%E5%B9%B4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黄海海战 (1894年) - 维基百科，自由的百科全书&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;1905-&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E5%AF%B9%E9%A9%AC%E6%B5%B7%E5%B3%A1%E6%B5%B7%E6%88%98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对马海峡海战 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1916-&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E6%97%A5%E5%BE%B7%E5%85%B0%E6%B5%B7%E6%88%98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;日德兰海战 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1941-&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%8F%8D%E7%8F%A0%E6%B8%AF%E4%BA%8B%E4%BB%B6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;珍珠港事件 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1942-&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E7%8F%8A%E7%91%9A%E6%B5%B7%E6%B5%B7%E6%88%98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;珊瑚海海战 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1942-&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E5%B2%9B%E6%B5%B7%E6%88%98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中途岛海战 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1944-&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E9%9B%B7%E4%BC%8A%E6%B3%B0%E7%81%A3%E6%B5%B7%E6%88%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;莱特湾海战 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;陈列馆&quot;&gt;&lt;a href=&quot;#陈列馆&quot; class=&quot;headerlink&quot; title=&quot;陈列馆&quot;&gt;&lt;/a&gt;陈列馆&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://page.om.qq.com/page/OpAfxwpDZC-zeS9jT2Ochq9Q0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;铁甲舰、前无畏舰、无畏舰、超无畏舰有啥区别？又是如何演化的？&lt;/a&gt; @link: &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zh.m.wikipedia.org/zh/%E9%98%BF%E9%87%91%E7%A7%91%E7%89%B9%E5%8F%B7%E6%88%98%E5%88%97%E8%88%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿金科特号战列舰- 维基百科，自由的百科全书&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27545575&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多铆蒸刚的图腾——阿金库尔号战舰传奇 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%83%A1%E5%BE%B7%E5%8F%B7%E6%88%98%E5%88%97%E5%B7%A1%E6%B4%8B%E8%88%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;胡德号战列巡洋舰 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B2%99%E6%81%A9%E9%9C%8D%E6%96%AF%E7%89%B9%E8%99%9F%E6%88%B0%E8%89%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;沙恩霍斯特号战列舰 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.m.wikipedia.org/zh-hans/%E7%B4%8D%E7%88%BE%E9%81%9C%E8%99%9F%E6%88%B0%E8%89%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纳尔逊号战舰 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.m.wikipedia.org/zh-hans/%E7%BE%85%E5%BE%B7%E5%B0%BC%E8%99%9F%E6%88%B0%E8%89%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;罗德尼号战舰 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A8%81%E5%B0%94%E5%A3%AB%E4%BA%B2%E7%8E%8B%E5%8F%B7%E6%88%98%E5%88%97%E8%88%B0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;威尔士亲王号战列舰 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sohu.com/a/391584137_99978337&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二战美军经典驱逐舰拉菲号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20735323&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;战巡金刚杂谈（一） - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20807863&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;战巡/战舰金刚杂谈（二） - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.m.wikipedia.org/zh/%E9%9B%AA%E9%A2%A8%E8%99%9F%E9%A9%85%E9%80%90%E8%89%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雪風號驅逐艦 - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/266144718&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二战日本沉没的大中型水面舰艇 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="66.History-and-Politics" scheme="https://beefyheisenberg.github.io/categories/66-History-and-Politics/"/>
    
    
    <category term="大舰巨炮" scheme="https://beefyheisenberg.github.io/tags/大舰巨炮/"/>
    
  </entry>
  
  <entry>
    <title>01.中国历史与世界历史对照表</title>
    <link href="https://beefyheisenberg.github.io/66.History-and-Politics/01.%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E4%B8%8E%E4%B8%96%E7%95%8C%E5%8E%86%E5%8F%B2%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>https://beefyheisenberg.github.io/66.History-and-Politics/01.%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E4%B8%8E%E4%B8%96%E7%95%8C%E5%8E%86%E5%8F%B2%E5%AF%B9%E7%85%A7%E8%A1%A8/</id>
    <published>2023-04-28T00:14:18.734Z</published>
    <updated>2023-04-28T00:14:18.739Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"><strong>中国历史</strong></th><th style="text-align:left"><strong>世界历史</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>世界古代史</strong>(公元前4500年–公元1500年)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">前3000-2000年传说中的黄帝、炎帝、颛琐、帝喾、尧、舜时代</td><td style="text-align:left">约前4300-前3500年苏美尔地区出现原始的城市；<br>约前3100年上埃及王美尼斯统一上下埃及；<br>约前3000-前2600年爱琴海地区先后进入早期青铜时代；<br>约前2500-前1750年印度河古文明时期，称为哈拉巴文化。</td></tr><tr><td style="text-align:left">前2070年-1600年禹建立夏王朝</td><td style="text-align:left">前1754年巴比伦国王统一两河流域，颁布《汉谟拉比法典》</td></tr><tr><td style="text-align:left">前1600年-1046年成汤建立商朝，共传17代31王；<br>前1300年盘庚迁都于殷，史称“盘庚中兴”；<br>前1250年-1192年武丁在位59年，史称“武丁盛世”。</td><td style="text-align:left">前1504-1450年埃及法老图特摩斯三世，跨西亚北非；<br>前1250年希腊各邦以迈锡尼为首远征特洛伊城；<br>约前1200年希腊语的多利亚人结束迈锡尼文明。</td></tr><tr><td style="text-align:left">前1046年牧野之战武王<strong>建立周朝</strong>。前1043年周公摄政；<br>前841年共和元年“国人暴动”（彘之乱）；<br>前828年周宣王即位，在位46年，史称“宣王中兴”。</td><td style="text-align:left">前1000-960年<strong>大卫王</strong>定都耶路撒冷，统一以色列和犹太国家；<br>约前800年印度进入后吠陀时期，开始种姓制度。</td></tr><tr><td style="text-align:left">前770年周平王迁都洛邑，史称东周</td><td style="text-align:left">前776年第一届<strong>奥林匹克</strong>，希腊历史元年。</td></tr><tr><td style="text-align:left">前651年葵丘会诸侯，齐桓公(前685)霸业达到顶峰；<br>前634年晋文公在城濮之战大败楚军，称霸中原；<br>前551孔子(前551-479年)出生</td><td style="text-align:left">前594年梭伦任雅典首席执政官，实行改革；<br>前586年新巴比伦攻下耶路撒冷，犹太国灭亡；<br>前570-前495年<strong>毕达哥拉斯</strong>；<br>前563年相传<strong>释迦牟尼</strong>(乔达摩·悉达多)出生</td></tr><tr><td style="text-align:left">前537年楚晋联姻，晋楚百年争霸正式结束；<br>前510年吴王阖闾攻占楚国郢都；<br>前497年<strong>孔子开始周游列国</strong>；<br>前482年吴王夫差北上黄池称霸；<br>前481年齐国卿大夫田氏杀齐简公，“专齐之政”</td><td style="text-align:left">前550年波斯王居鲁士灭米底，建立波斯帝国；<br>前509年雅典执政官克里斯梯尼改革，民主政治建立；<br>前509年<strong>罗马共和国</strong>建立，王政时代结束；<br>前490年波希马拉松战役雅典将军以少胜多</td></tr><tr><td style="text-align:left">前475-221年东周王朝开始进入战国时代；<br>前473年吴国被卧薪尝胆的越王勾践灭亡；<br>前403年三家分晋得到周天子的正式承认</td><td style="text-align:left">前470-前399年<strong>苏格拉底</strong>；<br>前462年伯利克里(前495-429年)改革，雅典民主鼎盛；<br>前449年希波订立卡里阿斯和约，希波战争正式结束；<br>前431-404年<a href="/66.History-and-Politics/伯罗奔尼撒战争/" title="伯罗奔尼撒战争">伯罗奔尼撒战争</a>；<br>前429-前347年<strong>柏拉图</strong>；</td></tr><tr><td style="text-align:left">前356年秦孝公任用商鞅(前390-338年)变法；<br>前341年在马陵之战，魏国由强转弱；<br>前318年秦灭巴蜀；<br>前307年赵武灵王实行军事改革“胡服骑射”</td><td style="text-align:left">前384-前322年<strong>亚里士多德</strong>；<br>前337年马其顿腓力二世召开全希腊会议，希腊城邦时代结束；<br>前330年波斯被马其顿灭亡；<br>前324年印度之旃陀罗笈多自立为王，孔雀王朝</td></tr><tr><td style="text-align:left">前278年屈原(前340-278年)投汨罗江而死；<br>前260年长平之战，四十余万赵军被歼，赵国元气大伤；<br>前256年西周亡，周赧王去世，名义的周天子不复存在                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ；</td><td style="text-align:left">前273年阿育王即位，在位37年孔雀帝国极盛时期。佛教广泛传播，还派传教使者到邻国传教；<br>前264年罗马与<a href="/66.History-and-Politics/迦太基文明/" title="迦太基文明">迦太基文明</a>进行第一次布匿战争</td></tr><tr><td style="text-align:left">前221年<strong>秦统一六国</strong>；<br>前209年<strong>陈胜吴广</strong>起义；<br>前209-174年匈奴冒顿单于杀父自立；<br>前207年巨鹿之战，秦亡；翌年长达四年“楚汉争霸”开始</td><td style="text-align:left">前219年罗马对迦太基宣战。第二次布匿战争开始；<br>前209年罗马将军小西庇阿率海陆军攻陷迦太基城</td></tr><tr><td style="text-align:left">前202年刘邦即皇帝位，<strong>汉朝建立</strong>，史称西汉；<br>前180-157年-157年-141年文帝景帝在位，“文景之治”</td><td style="text-align:left">前146年罗马开始确立在希腊的统治；<br>前146年罗马克迦太基城，夷为平地</td></tr><tr><td style="text-align:left">前141-87年刘彻即位，是为汉武帝；<br>前138、前115年张骞出使西域，“丝绸之路”自此开通；<br>前134年董仲舒提出“罢黜百家独尊儒术”主张；<br>前119年汉将霍去病、卫青率军痛击匈奴，；<br>前60年汉置西域都护，汉朝号令行于西域各国</td><td style="text-align:left">前73年罗马爆发角斗士<strong>斯巴达克斯</strong>领导的奴隶大起义；<br>前49年<strong>恺撒</strong>成为罗马独裁者。</td></tr><tr><td style="text-align:left">8年12月王莽称帝，国号“新”(8-23年)，<strong>西汉灭亡</strong></td><td style="text-align:left">前27年屋大维被尊为“奥古斯都”，开始罗马帝国时代；<br>公元元年<strong>耶稣</strong>(基督)诞生。</td></tr><tr><td style="text-align:left"><strong>公元纪年分隔线</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">25年刘秀称帝，<strong>东汉王朝建立</strong>，定都洛阳；<br>73年窦固败匈奴，班超出使西域；89年窦宪大破北匈奴</td><td style="text-align:left">52年大月氏建立贵霜帝国；<br>64年罗马城大火，皇帝尼禄乘机迫害基督教徒；<br>77年罗马势力扩大到英格兰</td></tr><tr><td style="text-align:left">97年西域都护班超派甘英出使大秦等国，到达波斯湾；<br>105年蔡伦将改进造纸术奏报朝廷，闻名于后世。</td><td style="text-align:left">132年犹太人起义反抗罗马被镇压，离开巴勒斯坦，流落各地</td></tr><tr><td style="text-align:left">167年东汉“党锢之祸”；<br>184年太平道教主张角发起“黄巾起义”</td><td style="text-align:left">167年日尔曼部落突破多瑙河防线，侵入罗马边境。</td></tr><tr><td style="text-align:left">200年官渡之战，曹操开始统一北方；<br>208年孙刘联军“赤壁之战”大败魏军，三足鼎立之势成</td><td style="text-align:left">212年皇帝卡拉卡拉颁布敕令，授予境内自由人罗马公民权</td></tr><tr><td style="text-align:left">220年十月曹丕废汉献帝，称帝，国号魏。<strong>东汉亡</strong>；<br>221年刘备在成都称帝；<br>229年四月孙权称帝，后定都建业；<br>263年魏大举攻蜀，后主刘禅投降，蜀汉亡国；<br>265年十二月司马炎皇帝，<strong>建立晋朝</strong>；<br>280年晋灭吴，统一全国。291-306年西晋八王之乱</td><td style="text-align:left">227年萨珊王朝(227-651年)灭帕提亚；<br>284年戴克里先被拥立为罗马皇帝，罗马帝国出现复兴；<br>286年戴克里先建立“<strong>四帝共治制</strong>”，罗马的东西分治开始；</td></tr><tr><td style="text-align:left">316年，匈奴刘曜围攻长安，晋愍帝出降，西晋灭亡；<br>317年三月司马睿在建康称晋王，次年称帝，<strong>东晋自此始</strong>。</td><td style="text-align:left">313年君士坦丁与莱西尼阿联合发表<strong>米兰敕令</strong>，基督教合法化；<br>330年君士坦丁迁都拜占庭，改名君士坦丁堡（新罗马）</td></tr><tr><td style="text-align:left">376年苻坚再灭前凉、代国，前秦统一了北方；<br>383年苻坚亲率大军南下攻晋，败于淝水之战</td><td style="text-align:left">380年旃陀罗·笈多二世(超日王)即位，笈多王朝进全盛期</td></tr><tr><td style="text-align:left">386年拓跋珪建魏，史称北魏；<br>399年法显出发西行，往天竺求经。</td><td style="text-align:left">392年基督教被定为罗马国教；<br>395年罗马皇帝狄奥多西把国土分给两个儿子，<strong>罗马帝国从此彻底分裂</strong></td></tr><tr><td style="text-align:left">420年六月刘裕称帝，史称刘宋，<strong>南朝自此始</strong>；<br>439年北魏军灭北凉灭，十六国时期至此结束；<br>446年北魏武帝禁佛教，诛沙门，毁经像</td><td style="text-align:left">439年汪达尔人在北非建立汪达尔王国；<br>449年日耳曼族盎格鲁·萨克森人、朱特人侵入不列颠；<br>476年西罗马帝国灭亡。</td></tr><tr><td style="text-align:left">479年萧道成废杀宋顺帝，称帝，史称南齐；<br>493年北魏孝文帝从平城(大同)迁都洛阳</td><td style="text-align:left">486年克洛维在高卢北部建法兰克王国，创墨洛温王；<br>493-553年东哥特王国，东哥特人统一意大利半岛</td></tr><tr><td style="text-align:left">502年萧衍在健康称帝，国号梁，是为梁武帝；<br>503年新罗始定国号为“新罗”，国主正式称王</td><td style="text-align:left">507年克洛维击败西哥特军，次年迁都巴黎；<br>518年查士丁尼一世即位，529年拜占廷颁布《查士丁尼法典》</td></tr><tr><td style="text-align:left">534年高欢进兵洛阳，立元善见为帝，迁都邺城，称东魏；<br>535年魏文帝元宝炬在长安即位，史称西魏</td><td style="text-align:left">531-579科斯洛埃斯一世在位，萨珊王朝进入全盛时期；<br>532年耶稣诞生之年此时被倡议做为纪元之始</td></tr><tr><td style="text-align:left">550年东魏高洋自立，史称北齐(550—577)；<br>552年阿史那土门大败柔然，自称伊利可汗建突厥汗国；<br>553年新罗进攻百济，获得汉江流域，疆域到达黄海；<br>557年正月西魏宇文觉受禅称天王，史称北周(557—581)；<br>557年梁大将陈霸先受禅称帝，国号陈(557—589)；<br>577年北周灭北齐，统一北方；周武帝再次宣布灭佛</td><td style="text-align:left">554年拜占廷占有全部意大利；<br>563年波斯与突厥联合入侵嚈哒，历时五年，嚈哒灭亡；<br>577年斯拉夫人渡多瑙河侵入色雷斯，成为巴尔干主要居民；<br>579年意大利语渐代拉丁语。西班牙则拉丁语渐代替哥特语</td></tr><tr><td style="text-align:left">581年北周外戚杨坚废帝自立，北周亡，<strong>隋朝建立</strong>；<br>589年隋灭陈，统一全国</td><td style="text-align:left">590年格里哥利一世即教皇位，从此确立教皇权威</td></tr><tr><td style="text-align:left">606年始建进士科，典定科举制度；<br>607年隋炀帝派遣朱宽等入海，到达流求(台湾)；<br>610年开凿自京口至余杭的江南河，隋大运河全部告竣</td><td style="text-align:left">603-628年波斯与拜占廷又开始长达20年的战争；<br>606年印度戒日王即位，在位40年，统一北印度大部；<br>610年穆罕默德约于此时开始传布伊斯兰教</td></tr><tr><td style="text-align:left">618年炀帝死江都兵变，隋朝灭亡。李渊长安称帝，<strong>唐朝建立</strong>；</td><td style="text-align:left">622年穆罕默德(570-632)从麦加出走迁往麦地那，伊斯兰历元年开始</td></tr><tr><td style="text-align:left">626年“玄武门之变”李世民继位，<strong>贞观之治</strong>(627-649年)；<br>629-645年玄奘(600～664)西行；<br>630年日本派出第一个遣唐使；<br>630败东突厥李世民被尊“天可汗”。640置安西都护府；<br>641年文成公主嫁给吐蕃的松赞干布；<br>646年日本大化改新</td><td style="text-align:left">630年穆罕默德征服麦加；<br>637年阿拉伯攻入波斯首都泰西封(巴格达)，占领伊拉克；<br>638年占领耶鲁撒冷，640年征服整个叙利亚；<br>642年波斯与阿拉伯决战败北。同年阿拉伯占领亚历山大城</td></tr><tr><td style="text-align:left">657年唐朝平西突厥；<br>663年百济-日本与唐-新罗联军“白江口之战”；<br>668年唐朝灭亡高句丽。676年新罗统一朝鲜</td><td style="text-align:left">651年波斯亡，阿拉伯正式与唐朝交往；<br>655年船桅之役，拜占廷的海军优势受严重打击；<br>661-750年阿拉伯倭马亚王朝，定都大马士革。</td></tr><tr><td style="text-align:left">690年武则天称帝，改国号为“周”，史称武周；<br>698年大祚荣在高句丽故地建立起震国，后封渤海国；<br>705年敬珲和宰相张柬之等人发动政变，中宗李显复位；<br>712年睿宗让位予唐玄宗，713-741年开元盛世。</td><td style="text-align:left">711年阿拉伯征服西班牙的西哥特王国；<br>732年受挫于法兰克查理·马特，阿拉伯在西欧的扩张止步；<br>710—712年征服撒马尔罕、花拉子模；<br>711—713年征服印度河流域的信德和南旁遮普</td></tr><tr><td style="text-align:left">738年蒙舍诏首领皮罗阁建立南诏(738-937年)；<br>744年李白(701-762)和杜甫(712-770)在洛阳结识</td><td style="text-align:left">750-1258阿拔斯王朝(黑衣大食)，定都巴格达；<br>750-850掀起百年翻译运动。阿拉伯文化顶盛。</td></tr><tr><td style="text-align:left">751年怛罗斯之战，造纸术随被俘工匠传入西方；<br>753年鉴真(687-763)东渡抵达日本，传律宗；<br>755-763年唐朝发生安史之乱；<br>780年德宗采纳杨炎建议，颁行两税法</td><td style="text-align:left">751年丕平称王，<strong>建立加洛林王朝</strong>；<br>754-756丕平征意大利，“丕平献土”教皇国成立；<br>774年查理曼征服伦巴第王国；<br>800年查理大帝(768-814)圣诞节在罗马加冕称帝</td></tr><tr><td style="text-align:left">821年唐蕃会盟，在拉萨立《长庆会盟碑》；<br>835年太和九年唐文宗“甘露之变”失败；<br>874-884年王仙芝、黄巢领导唐末农民战争；<br>881年黄巢在长安建立政权，国号“大齐”；<br>902年郑买嗣灭南诏自立，改国号大长和</td><td style="text-align:left">843年凡尔登条约，加洛林帝国一分为三；<br>9世纪中叶诺曼人深入攻击西欧，西法兰克王室权威式微；<br>870年墨尔森条约，东西法兰克瓜分中法兰克大部分领地；<br>882年基辅罗斯公国建立；<br>891年东法兰克对诺曼人取得决定性胜利。</td></tr><tr><td style="text-align:left">907年后梁建立，唐朝灭亡，五代开始</td><td style="text-align:left">902年阿拉伯人彻底征服西西里岛；<br>909-1171北非法蒂玛王朝(黑衣大食)什叶派的大王朝；<br>911年诺曼公国建立，并接受基督教；<br>920年东法兰克改名德意志，930-980第一次向东方殖民。</td></tr><tr><td style="text-align:left">916年阿保机建立契丹国；<br>935年高丽灭亡新罗，重新统一朝鲜半岛；<br>937段思平建立大理国；<br>947年耶律德光南下灭后晋，改国号大辽；<br>951郭威即帝位，建后周，灭后汉</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">960年陈桥兵变，赵匡胤黄袍加身，<strong>建立宋朝</strong>；</td><td style="text-align:left">960年波兰国家建立</td></tr><tr><td style="text-align:left">968丁部领称“大胜明皇帝”，国号“大瞿越”，越南创国；<br>982年李继迁反宋自立；<br>986年太宗“雍熙北伐”败北</td><td style="text-align:left">962奥托大帝称意大利王，加冕称帝建神圣罗马帝国；<br>988罗斯弗拉基米尔(978-1015)定国教东正教</td></tr><tr><td style="text-align:left">1004年宋、辽澶渊之盟；<br>1023年宋真宗时成都16家富户共同发行最早的纸币“交子”<br>1038年元昊建立西夏</td><td style="text-align:left">1017年克努特成为首个统一的英格兰国王，并继承丹、挪王位；<br>1039-1056年亨利三世在位，神圣罗马帝国达到鼎盛；<br>1054年基督教会分裂；<br>1055年塞尔柱突厥人在巴格达建立素丹政权，哈里发成为附庸。</td></tr><tr><td style="text-align:left">1069年王安石(1021-1086)开始变法；<br>1085年哲宗赵煦继位</td><td style="text-align:left">1066年法国诺曼底公爵威廉一世征服英格兰；<br>1071年塞尔柱人在马拉兹古尔特之役重创拜占庭；<br>1096-1099年<strong>第一次十字军东征</strong></td></tr><tr><td style="text-align:left">1115年阿骨打建立大金(1115-1234)；<br>1125年金灭辽；<br>1127年靖康之变，金灭北宋，赵构即位，史称南宋；<br>1131耶律大石建立西辽；<br>1141年宋金达成《绍兴和议》</td><td style="text-align:left">1108-1137法王路易六世在位，统一进程开始起步，城市兴起；<br>1130年诺曼人建立两西西里王国；<br>1147年收复里斯本；<br>1147年莫斯科建城；<br>1147-1149年<strong>第二次十字军</strong>(德法联军)东征，遭突厥人重创</td></tr><tr><td style="text-align:left">1164年宋孝宗改交趾郡为安南国；<br>1192年源赖氏被任命为征夷大将军，开创镰仓幕府，史称镰仓时代(1192-1333)</td><td style="text-align:left">1158-1189德皇腓特烈一世在位，帝国的最光辉(回光返照)；<br>1168年牛津大学建立；<br>1187年萨拉丁收复耶路撒冷；<br>1189-1192<strong>第三次十字军东征</strong>(萨拉丁 vs 狮心王、红胡子、腓力二世)</td></tr><tr><td style="text-align:left">1206年成吉思汗铁木真(1206-1227)建蒙古国；<br>1218年蒙古灭掉西辽政权；<br>1219-1223成吉思汗首次西征；<br>1227年蒙古灭西夏；1231年蒙古入侵高丽；<br>1234年蒙宋联军攻破蔡州城，金国灭亡；<br>1236-1241年拔都西征1240年攻占基辅直至多瑙河</td><td style="text-align:left">1202-1204年第四次东征洗劫君士坦丁堡，建立拉丁帝国；<br>1206年法王菲利普二世(1180-1223)剥夺英王在大陆领地；<br>1215年“失地王”约翰(1199-1216)签订《英国大宪章》；<br>1228-1229年腓特烈二世擅自第六次十字军东征；<br>1230条顿骑士团侵占普鲁士</td></tr><tr><td style="text-align:left">1252年旭烈兀西征；1258年攻占巴格达，灭阿拔斯王朝；<br>1253年灭大理；1259年蒙哥卒于钓鱼城；<br>1271年<strong>忽必烈定国号元</strong>(1271-1368年)；<br>1275-1292威尼斯商人马可波罗到元朝和印度；<br>1276年<strong>南宋投降</strong>；1279年南宋流亡朝亡于廷崖山海战；<br>1281年(1274)忽必烈第两次入侵日本失败</td><td style="text-align:left">1254-1273年神圣罗马帝国大空位时期；<br>1261拉丁帝国终结，恢复了拜占廷帝国；<br>1270路易九世第八次十字军东征突尼斯时死去；<br>1284爱德华一世(1272-1307)彻底征服威尔士；<br>1291年埃及夺取十字军在东方的最后据点；<br>1295年英国“模范国会”召开</td></tr><tr><td style="text-align:left">1333年后醍醐天皇推翻镰仓幕府，1336-1392南北朝时代；<br>1337年伊儿汗国亡；<br>1351年元末爆发红巾军大起义，刘福通、徐寿辉起兵。</td><td style="text-align:left">14-15世纪欧洲资本主义萌芽；<br>14-16世纪欧洲<strong>文艺复兴</strong>运动；<br>1307但丁《神曲》；<br>1337<strong>英法百年战争</strong>开始；<br>1348欧洲开始爆发“黑死病”，人口锐减三分一</td></tr><tr><td style="text-align:left">1368年朱元璋在应天府登基即位，<strong>建立明朝</strong>(1368-1644)，元顺帝北逃。同年大将徐达攻克大都，元朝覆亡</td><td style="text-align:left">1378-1447罗马教会分裂，两教皇并存；<br>1380年罗斯大败钦察汗国；<br>1415亨利王子占领摩洛哥休达，开启大探险时代(1415-1580)；<br>1429年贞德解奥尔良之围1436年法国收复巴黎；<br>1436年德国约翰·古登堡发明活字印刷；<br>1438哈布斯堡的阿尔伯特选为皇帝(1438-1806)</td></tr><tr><td style="text-align:left">1392年李成桂篡位，国号朝鲜，史称李氏朝鲜；<br>1392年足利义满迫南朝天皇让位，室町时代1392-1573；<br>1399-1402年“靖难之役”朱棣即位；<br>1405-1433年<strong>郑和七次下西洋</strong>；<br>1421年明朝迁都北京，南京改为留都；<br>1429年尚巴志统一琉球，开创第一尚氏王朝，都首里。</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1449年“土木堡之变”；<br>1457年夺门之变，英宗复位；<br>1467年应仁之乱，日本战国时代(1467年—1573年)；<br>1471年安南黎圣宗灭占城；<br>1487-1505年明孝宗朱祐樘继位，史称为“弘治中兴”。</td><td style="text-align:left">达·芬奇(1452-1519)米开朗基罗(1472-1564)拉斐尔(1483—1520)；<br>1453年<strong>奥斯曼灭拜占庭</strong>。<strong>英法百年战争</strong>结束；<br>1479阿拉贡斐迪南一世继卡斯提王，合并为西班牙；<br>1480罗斯摆脱蒙古控制，1485统一东北罗斯；<br>1487年迪亚士到达好望角</td></tr><tr><td style="text-align:left"><strong>世界近现代史</strong>(公元1500年–至今)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1517果阿总督到广州请求通商未果，炮轰广州；<br>1553年中葡停息干戈，1553-1557年葡人开始在澳居留；<br>1555-1558年胡宗宪、戚继光(1528-1588)、俞大猷等接连重创倭寇；<br>1565年西班牙征服菲律宾群岛；<br>1566年为害已解放后东南倭患终于最后平息；<br>1567年有限度的开放海禁，史称“隆庆开海”；<br>1571年鞑靼部俺答汗受封顺义王；<br>1572年神宗继位，张居正十年辅政，史称“万历中兴”；<br>1578年李时珍经27年著成《本草纲目》；<br>1590年织田信长的继承者<strong>丰臣秀吉完成统一</strong>；<br>1592、1597年丰臣秀吉入侵朝鲜，中朝赢得最后胜利；<br>1598年西班牙闯入广东；<br>1601年荷兰炮舰首次开到广州。</td><td style="text-align:left">1492年<strong>哥伦布初次航行到美洲</strong>；<br>1497-1498年达加马开辟西欧到印度的新航路；<br>1500年葡萄牙到达巴西；1510年攻占果阿，建立东方殖民地总部；1511年夺取马六甲；<br>1517马丁-路德《九十五条论纲》发动宗教改革；<br>1519-1522年<strong>麦哲伦</strong>第一次环球航行；<br>1521西班牙征服阿兹特克；1532征服印加帝国；<br>1528年苏里曼一世攻陷布达佩斯；<br>1534《至尊法案》，英王成英教会最高领袖，正式与教廷决裂；<br>1543<strong>哥白尼</strong>(1469-1492)《天体运行论》出版；<br>1562-1594法国胡诺(加尔文派)战争，破坏性超百年战争；<br>1566年“破坏圣像运动”，尼德兰革命爆发；<br>1580年西班牙吞并葡萄牙；<br>1581年(荷兰)联省共和国成立；<br>1588年英国海军击败西班牙“无敌舰队”；<br>1600年英国东印度公司建立</td></tr><tr><td style="text-align:left">1603年德川家康在江户开创<strong>德川幕府</strong>(1603-1867)；<br>1609年琉球受入侵萨摩藩的支配，形成中日两属的状态；<br>1616年努尔哈赤建立后金；<br>1619荷兰占领爪哇，1622据澎湖1624被逐转筑赤嵌城；<br>1628全国性大灾荒，陕西爆发大规模农民起义；<br>1636年<strong>皇太极称帝</strong>，改国号为大清；<br>1639-1641年松锦之战，关外辽东地区至此基本沦陷。</td><td style="text-align:left">1603年詹姆斯一世继位，斯图亚特王朝开始；<br>1607年伦敦公司在北美建立詹姆斯城；<br>1608年法国在魏北克建立殖民据点；<br>1618-1648欧洲三十年战争；<br>1620年“五月花”号到达新英格兰；<br>1632<strong>伽利略</strong>《两大宇宙体系的对话》</td></tr><tr><td style="text-align:left">1644年李自成建立大顺政权，农民军攻占北京，明亡；<br>1652年达赖五世入京，顺治帝赐予“达赖喇嘛”称号；<br>1661-1662年郑成功收复台湾；<br>1662年永历帝被吴三桂绞杀于昆明，南明灭亡。同年郑成功病逝于台湾，李定国病故于猛腊。</td><td style="text-align:left">1640年英国资产阶级革命开始；<br>1648年《威斯特伐利亚条约》，三十年战争结束，哈布斯堡霸权终结；<br>1649年英国王查理一世被处死；<br>1651年英国颁布《航海条例》，1652-1654第一次英荷战争；1660年英国斯图亚特王朝复辟</td></tr><tr><td style="text-align:left">1669年康熙帝开始真正亲政；<br>1673-1681年康熙平定以吴三桂为首的三藩叛乱；<br>1683年施琅攻克澎湖，台湾归降。1684年清朝设台湾府；<br>1688年-1697年平定准噶尔汗噶尔丹叛乱；<br>1689年中俄签订《尼布楚条约》；<br>1690年噶尔丹攻入内蒙，兵锋遥指北京，遭清军痛击；<br>1691年对喀尔喀蒙古实行盟旗制度，正式从属中央政府</td><td style="text-align:left">1661年路易十四(1643-1715)亲政；<br>1683年奥斯曼被奥波联军击溃，扩张宣告终结；<br>1686年俄波《永久和约》，确认乌克兰归俄；<br>1687年《自然哲学的数学原理》发表，<strong>牛顿力学体系确立</strong>；<br>1688年英国光荣革命，威廉三世入主，1689年通过《权利法案》；<br>1689俄国彼得一世(彼得大帝，1672-1725)开始改革；<br>1700-1721年俄瑞“北方战争”</td></tr><tr><td style="text-align:left">1713年清朝廷封班禅“额尔德尼”；<br>1718、1720年康熙两次派兵入藏击败准噶尔，并分兵驻藏；<br>1722年清世宗雍正帝胤禛盛年登基；<br>1726年清朝将“摊丁入亩”办法推行全国；<br>1726年清朝对西南少数民族地区“改土归流”；<br>1727年清廷正式设立驻藏大臣；<br>1727年中俄签订《中俄布连斯奇条约》。</td><td style="text-align:left">1701年普鲁士王国成立；<br>1703年彼得一世建新都圣彼得堡；<br>1707年英格兰苏格兰合并为“联合王国”</td></tr><tr><td style="text-align:left">1735年清高宗乾隆帝弘历即位；<br>1755、1757年两次出兵平定西北的准噶尔部；<br>1759年第三次西北用兵平定新疆回部的“大小和卓叛乱”；<br>1762年设伊犁将军，新疆完全置于清朝中央政府控制之下；<br>1771年土尔扈特部重返祖国</td><td style="text-align:left">1740-1786年腓特烈二世开明专制推重商主义，开普奥争霸；<br>1756-1763年英法七年战争；<br>1762<strong>叶卡捷琳娜二世</strong>通过政变登基<br>1765-1790奥地利特雷西亚女皇和约瑟夫二世改革；<br>1768年英国瓦特改良蒸汽机，<strong>第一次工业革命</strong>开始；<br>1772年俄普奥第一次瓜分波兰；<br>1774年北美第一届大陆会议在费城召开，1775年独立战争在莱克星顿打响，1776年7月4日《独立宣言》美国独立日；<br>1776年亚当斯密《国富论》；<br>1778伏尔泰和卢梭(1712-1778)去世；<br>1787年美国《联邦宪法》次年生效；1789年<strong>华盛顿任第一任美国总统</strong>；<br>1789年法国大革命爆发，同年《人权宣言》。</td></tr><tr><td style="text-align:left">1791-1792年两次出征尼泊尔廓尔喀，制定《钦定西藏章程》；<br>1796年乾隆帝禅位于清仁宗嘉庆帝颙琰，三年后逝世；<br>1796年，川楚陕边境地区爆发的白莲教起义历时九载，波及川楚陕豫甘等省，使满清元气大伤；<br>1813年北方天理教起义甚至在太监接应下冲进皇宫</td><td style="text-align:left">1799年拿破仑发动<strong>雾月政变</strong>；<br>1801年英国兼并爱尔兰；<br>1803年美国购得路易斯安娜；<br>1804年《拿破仑法典》，拿破仑加冕；<br>1804年海地独立；<br>1806年莱茵联邦成立，神圣罗马帝国解散。拿破仑封锁大陆；<br>1812委、巴拉圭独立。1816阿根廷、1818智利、1821墨秘独立；<br>1815<strong>滑铁卢战役</strong>。维也纳会议，维也纳体系确立。</td></tr><tr><td style="text-align:left">1820年清宣宗道光皇帝旻宁继位。</td><td style="text-align:left">1821-1829希腊独立战争；<br>1822年巴西宣布独立；1823年“门罗宣言”；<br>1834年德意志关税同盟成立；<br>1836-1848英国宪章运动</td></tr><tr><td style="text-align:left">1839年林则徐(1785-1850)虎门销烟；<br>1840-1842年<strong>第一次鸦片战争</strong>，1841年英国占领香港；<br>1842年中英《南京条约》；<br>1851年金田起义1853年定都南京，建立太平天国；<br>1853、1854年“黑船事件”马修·佩里准将两度叩关日本；<br>1856年-1860年<strong>第二次鸦片战争</strong>；<br>1858年《爱珲条约》《天津条约》的签订；<br>1860年攻进北京，并洗劫圆明园；<br>1860年《北京条约》的签订</td><td style="text-align:left">1846-1848美墨战争。1847年加利福尼亚淘金热开始；<br>1848欧洲革命（民族之春）。马克思发表《共产党宣言》；<br>1849英国完全吞并旁遮普；<br>1851年古巴宣布独立；<br>1852年波拿巴建立第二帝国；<br>1852年英国通过自由贸易原则；<br>1853-1856年英法与俄克里米亚战争；<br>1857-1859年印度民族起义1858年英国东印度公司解散；<br>1859年达尔文《物种起源》发表；<br>1859年意大利反奥独立战争开始</td></tr><tr><td style="text-align:left">1861咸丰帝病死于承德避暑山庄，同年辛酉政变；<br>1862法越《西贡条约》；<br>1864年天京陷落、太平天国运动失败；<br>1865年中亚浩罕汗国阿古柏侵入喀什，占据南疆；<br>19世纪60到90年代<strong>洋务运动</strong>；<br>1868年推翻德川幕府，<strong>明治维新</strong>，揭开日本近代历史。</td><td style="text-align:left">1861年意大利王国成立；<br>1861年俄罗斯农奴制改革；<br>1861-1865年美国南北战争，1862林肯签署《黑奴解放宣言》；<br>1864年普奥联军战胜丹麦。1866年普奥战争；<br>1867年美国购得俄国阿拉斯加。1867年加拿大自治领成立；<br>1868年美国首条横跨大陆的铁路正式通车</td></tr><tr><td style="text-align:left">1871年沙俄派兵侵占伊犁地区；<br>1872年洋务派企业轮船招商局。私办继昌隆缫丝厂创立；<br>1881年曾纪泽与沙俄签订《中俄改订条约》；<br>1883年-1885年中法战争；<br>1884年新疆建省；1885年台湾建省；<br>1885年朝鲜甲申政变；<br>1888年英国入侵西藏；<br>1894年美国檀香山成立兴中会；<br>1894-1895年<strong>甲午中日战争</strong>；<br>1895年中日《马关条约》签订；<br>1897年德国租借胶州湾；俄国租借旅顺；<br>1898年戊戌变法</td><td style="text-align:left">19世纪70年代<strong>第二次工业革命</strong>开始；<br>1870年普法战争；<br>1870年意大利完成统一；<br>1871年德意志帝国成立，威廉一世登基；<br>1871年3－5月巴黎公社；<br>1882年德意奥三国同盟形成；<br>1885年柏林会议；<br>1889年第二国际建立；<br>1891年俄罗斯开始修建西伯利亚大铁路；<br>1896年第一届现代奥运於希腊雅典举行；<br>1898年美西战争，美占领古巴波多黎各菲律宾，正式侵并夏威夷；<br>1899年英布战争(布尔战争)爆发</td></tr><tr><td style="text-align:left">1900年义和团运动高潮,八国联军侵略中国；1901年《辛丑条约》签订；<br>1905年中国同盟会成立；<br>1908年光绪与慈禧太后先后去世；<br>1910日本正式吞并朝鲜；<br>1911年黄花岗起义、保路运动、武昌起义；<br>1912年（民国元年）<strong>中华民国成立</strong>；<br>1912年宣统帝退位清朝灭亡，中国二千多年的帝制结束；<br>1913年二次革命；<br>1915年新文化运动开始；<br>1915年护国运动开始；1916年袁世凯恢复帝制失败；<br>1917年张勋复辟失败；1917年护法运动开始；<br>1919年5月4日五四爱国运动爆发；<br>1921年7月中国共产党成立；<br>1923年京汉铁路工人大罢工；<br>1924中国国民党第一次全国代表大会；创立黄埔军校；<br>1925年孙中山逝世；<br>1925年上海五卅惨案、五卅反帝爱国运动爆发；<br>1926年国民革命军出师北伐；<br>1927年3月上海工人第三次武装起义胜利；<br>1927年“四一二”、“七一五”反革命政变；<br>1927年4月蒋介石在南京建立国民政府；<br>1927年8月1日南昌起义；8月7日八七会议；<br>1927年8月秋收起义部队到达井冈山；年底广州起义；<br>1928年张学良宣布东北易帜；<br>1931年<strong>九一八事变</strong>；<br>1932年一.二八事变、十九陆军抗战1932年伪满洲国成立；<br>1934年10月中央红军开始长征；<br>1935年1月遵义会议；<br>1935年中共中央发表八一宣言；<br>1935年10月红军第一方面军长征到达陕北；<br>1935年一二.九运动；<br>1936年10月第二、四方面军达甘肃会宁等地，长征结束；<br>1936年12月12日西安事变；<br>1937年7月7日卢沟桥事变；<br>1937年八一三事变凇沪会战；<br>1937年平型关大捷；<br>1937年12月南京沦陷；<br>1938年台儿庄战役；<br>1938年毛泽东发表《论持久战》；<br>1940年3月汪精卫伪国民政府在南京成立；<br>1940年百团大战；<br>1941年皖南事变；<br>1945年中国共产党第七次全国代表大会召开；<br>1945年8月15日日本宣布投降；<br>1945年重庆谈判；双十协定签字；<br>1946年政治协商会议；<br>1946年6月国共全面内战；<br>1948年9月-1949年1月三大战役；<br>1949年春中国共产党七届二中全会召开；<br>1949年4月23日人民解放军解放南京；<br>1949年9月中国人民政治协商会议第一次全体会议召开</td><td style="text-align:left">20世纪初世界殖民体系最终形成；<br>1900<strong>普朗克</strong>引入量子理论；<br>1903年<strong>爱因斯坦</strong>提出相对论；<br>1903怀特兄弟制成世界上第一架飞机；<br>1903俄国社会民主工党第二次代表大会1907英法俄协约的最后形成；<br>1914－1918第一次世界大战，1918西班牙流感；<br>1917.11.7(俄历10月25日)俄国十月社会主义革命；<br>1918.11德国十一月革命爆发；<br>1918－1922印度民族解放运动高涨；<br>1919－1922土耳其凯末尔革命；<br>1919.3匈牙利苏维埃共和国建立；<br>1919共产国际建立；<br>1919.1－6巴黎和会；<br>1921.11－1922.2华盛顿会议；<br>1922.10墨索里尼在意大利上台；<br>1922.12苏联成立；<br>1923.10土耳其共和国成立；<br>1924年苏联领导人列宁逝世；<br>1925.10洛迦诺会议；<br>1929－1933资本主义世界经济危机；<br>1931年英国《威斯敏斯特法》，澳大利亚独立；<br>1933.1希特勒在德国上台；<br>1933.3罗斯福就任美国总统，实行新政；<br>1935－1936埃塞俄比亚抗击意大利侵略的民族解放运动；<br>1936－1939西班牙反对法西斯的民族革命战争；<br>1938.9慕尼黑会议1939.8苏德互不侵犯条约；<br>1939.9第二次世界大战全面爆发；<br>1940.6法国投降；<br>1940秋不列颠之战；<br>1940.9<strong>德意日三国同盟条约签订</strong>；<br>1941.6苏德战争爆发；<br>1941.12太平洋战争爆发；<br>1941秋大西洋宪章；<br>1942初《联合国家宣言》形成反法西斯同盟；<br>1942莫斯科保卫战；<br>1942.6中途岛战役；<br>1942.7－1943.2斯大林格勒战役；<br>1943.12.1中美英发表《开罗宣言》；<br>1943.11－12苏美英举行德黑兰会议；<br>1944.6.6美英军队在诺曼底登陆，欧洲第二战场开辟；<br>1945.2苏美英举行雅尔塔会议；<br>1945.5.8德国签订无条件投降书；<br>1945.9.2苏美英举行波茨坦会议日本签订无条件投降书；<br>20世纪四五十年代第三次科技革命开始；<br>1945.10联合国建立；<br>1947美国提出杜鲁门主义；<br>1947印巴分治：印度、巴基斯坦独立；<br>1948以色列建国，第一次中东战争爆发；<br>1948美国开始实施马歇尔计划</td></tr><tr><td style="text-align:left">1949年10月1日<strong>中华人民共和国成立</strong>；<br>1950年－1952年土地改革；<br>1950年10月－1953年7月抗美援朝战争；<br>1951年西藏的和平解放；<br>1953-1956年三大改造；<br>1953-1957年一五计划；<br>1954年第一届人大，第一部宪法颁布；<br>1956年中共八大召开；<br>1958年大跃进、全民炼钢和人民公社化运动；<br>1959年－1961年三年自然灾害；<br>1962年中印边境自卫反击战；<br>1964年中国第一颗原子弹爆炸成功；<br>1966年-1976年文化大革命；<br>1968年各地开始大规模知识青年上山下乡运动；<br>1969年中苏爆发珍宝岛武装冲突；<br>1970年中国第一颗人造卫星“东方红1号”成功发射；<br>1971年中国恢复在联合国席位；<br>1977年文革结束后第一年，恢复高考；<br>1978年十一届三中全会召开，改革开放开始；<br>1979年对越自卫还击战；<br>1980年四个经济特区的建立，平反文革的冤假错案；<br>1985年城市改革，国有企业改革；<br>1986年义务教育法颁布；<br>1992年小平南方视察；<br>1997年邓小平逝世，香港回归，十五大；<br>1999年澳门回归</td><td style="text-align:left">1949北大西洋公约组织建立；<br>1950－1953美国侵略朝鲜战争；<br>1954《关于恢复印度支那和平的日内瓦协议》签字；<br>1955亚非国家召开的万隆会议；<br>1955华沙条约组织成立；<br>1956波兰波兹南事件，匈牙利事件；<br>1956第二次中东战争（苏伊士运河战争）；<br>1957前苏联发射世界上第一颗人造地球卫星；<br>1959古巴革命取得胜利；<br>1960非洲有17个国家独立，这一年被成为“非洲独立年”；<br>1961加加林成为第一个太空人；<br>20世纪60年代初不结盟运动形成；<br>20世纪60年代中期七十七国集团产生；<br>1965-1973年美国发动越南战争；<br>1967欧洲共同体成立；<br>1972.2美国总统尼克松访华，上海公报发表；<br>1973美国在《关于在越南结束战争，恢复和平的协议》签字；<br>1979中美建交；<br>1979年苏联入侵阿富汗；<br>20世纪80年代末90年代初东欧剧变；<br>1991海湾战争，苏联解体；<br>1992北美自由贸易区形成；<br>1993欧洲联盟建立；<br>1999科索沃战争，北约空袭南联盟；<br>2008年：四川大地震；北京奥运会；美国次级贷款引发金融危机</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;中国历史&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;世界历史&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/t</summary>
      
    
    
    
    <category term="66.History-and-Politics" scheme="https://beefyheisenberg.github.io/categories/66-History-and-Politics/"/>
    
    
    <category term="中国历史" scheme="https://beefyheisenberg.github.io/tags/中国历史/"/>
    
    <category term="世界历史" scheme="https://beefyheisenberg.github.io/tags/世界历史/"/>
    
  </entry>
  
  <entry>
    <title>户外露营装备</title>
    <link href="https://beefyheisenberg.github.io/54.Trips-and-Exploration/%E6%88%B7%E5%A4%96%E9%9C%B2%E8%90%A5%E8%A3%85%E5%A4%87/"/>
    <id>https://beefyheisenberg.github.io/54.Trips-and-Exploration/%E6%88%B7%E5%A4%96%E9%9C%B2%E8%90%A5%E8%A3%85%E5%A4%87/</id>
    <published>2023-04-28T00:14:18.296Z</published>
    <updated>2023-04-28T00:14:18.296Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://www.zhihu.com/question/43389258/answer/1881196041" target="_blank" rel="noopener">户外野营的神级装备有哪些？ - 知乎</a></li><li><a href="https://sspai.com/post/75980" target="_blank" rel="noopener">户外不完全吃饱指南 - 少数派</a></li></ul><h2 id="雪拉杯"><a href="#雪拉杯" class="headerlink" title="雪拉杯"></a>雪拉杯</h2><p>我们常说的雪拉杯或者塞拉杯，全称是 Sierra cup，是美国十分著名的户外环境组织雪拉俱乐部(Sierra Club)的周边产品，其使用最早可以追述到1905年</p><p><img src="/images/Sierra-cup.png" alt="../_images/Sierra-cup.png"></p><p>1、起源</p><p>它的起源与加利福尼亚的锡耶拉有关，最早可以追溯到20世纪初，是美国最大、历史最久、最有影响力的草根环境保护组织“塞拉俱乐部”的周边产品。在物资匮乏的年代，“塞拉杯”凭借其低廉的价格、实用性&amp;便携性，在户外界迅速火了起来。如果你是历史迷，那么同样会喜欢这款杯子！</p><p>2、荒野的象征</p><p>在鼓励人们去户外的时代，塞拉杯被认为是背包客&amp;攀岩爱好者的“理想之杯”，也得到了普及。随着时代的进步，越来越多的人越来越多的人意识到“保护荒野”的重要性以及其内在价值。</p><p>推荐品牌：Cook’n’Escape</p><h2 id="克米特椅"><a href="#克米特椅" class="headerlink" title="克米特椅"></a>克米特椅</h2><p>Kermit Chair</p><p><img src="/images/Kermit-Chair.png" alt="../_images/Kermit-Chair.png"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/43389258/answer/1881196041&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;户外野营的神级装备有哪些？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sspai.com/post/75980&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;户外不完全吃饱指南 - 少数派&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;雪拉杯&quot;&gt;&lt;a href=&quot;#雪拉杯&quot; class=&quot;headerlink&quot; title=&quot;雪拉杯&quot;&gt;&lt;/a&gt;雪拉杯&lt;/h2&gt;&lt;p&gt;我们常说的雪拉杯或者塞拉杯，全称是 Sierra cup，是美国十分著名的户外环境组织雪拉俱乐部(Sierra Club)的周边产品，其使用最早可以追述到1905年&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Sierra-cup.png&quot; alt=&quot;../_images/Sierra-cup.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、起源&lt;/p&gt;</summary>
    
    
    
    <category term="54.Trips-and-Exploration" scheme="https://beefyheisenberg.github.io/categories/54-Trips-and-Exploration/"/>
    
    
  </entry>
  
  <entry>
    <title>F41a.K线和技术分析</title>
    <link href="https://beefyheisenberg.github.io/52.Financing/F41a.K%E7%BA%BF%E5%92%8C%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <id>https://beefyheisenberg.github.io/52.Financing/F41a.K%E7%BA%BF%E5%92%8C%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</id>
    <published>2023-04-28T00:14:18.063Z</published>
    <updated>2023-04-28T00:14:18.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="所谓「技术分析」"><a href="#所谓「技术分析」" class="headerlink" title="所谓「技术分析」"></a>所谓「技术分析」</h2><ul><li>技术分析包含的内容：<ul><li>技术分析理论的主要的代表有道氏理论、波浪理论、江恩法则等；  　　</li><li>主要分析方法有K线理论、切线理论（趋势线、轨道线、黄金分割线、角度线）、形态理论（背离、发散、M头、W底、头肩顶、头肩底、圆弧底）、量价关系理论；  　　</li><li>主要的分析指标包括：趋势型指标、超买超卖型指标、人气型指标、大势型指标等内容；</li></ul></li><li>技术分析的特性: 技术分析区别于其他分析方法的关键在于，它更像一门艺术。<ul><li>其一、<strong>在它的各种理论体系中，从定义到规则，都带有明显的经验总结色彩，不具备严格的数学推理过程；</strong>  // 哈哈哈 　　</li><li>其二、它包含的理论很多，每位技术分析家都有不同的见地  // 像不像星座？</li></ul></li></ul><p>➤ 技术分析效果如何？</p><ul><li><a href="https://www.zhihu.com/question/25625592" target="_blank" rel="noopener">专业量化交易从业人士如何看待传统的技术分析？ - 知乎</a> ：这里的传统技术分析包括像均线、布林带，或者MACD等技术指标，他们在量化从业人士的工具箱中处于什么地位？</li><li><a href="https://www.zhihu.com/question/36411902" target="_blank" rel="noopener">MACD指标在量化策略实战中如何应用？ - 知乎</a> =&gt; <a href="/52.Financing/F51.Quant.量化交易101/" title="F51.Quant.量化交易101">F51.Quant.量化交易101</a></li></ul><p>➤ 技术分析的三大假设：</p><ul><li><a href="https://www.tfzq.com/edu/view/id/229.html" target="_blank" rel="noopener">天风证券 - 技术分析的三大假设</a><ul><li>技术分析的理论技术是基于三项市场假设：一、市场行为包含一切；二、价格以趋势方式演变；三、历史会重演。</li></ul></li><li><a href="https://www.zhihu.com/question/41840547" target="_blank" rel="noopener">技术分析三大假设的漏洞是什么？ - 知乎</a></li></ul><h2 id="技术分析常用指标"><a href="#技术分析常用指标" class="headerlink" title="技术分析常用指标"></a>技术分析常用指标</h2><p>@ref: <a href="https://www.futunn.com/learn/detail-introduction-of-k-line-1172-1901400024" target="_blank" rel="noopener">https://www.futunn.com/learn/detail-introduction-of-k-line-1172-1901400024</a></p><p>MACD、KDJ、RSI、BIAS在量化中的实际效果：<a href="/52.Financing/F41b.技术分析指标-量化回测/" title="F41b.技术分析指标-量化回测">F41b.技术分析指标-量化回测</a></p><h3 id="▷-成交量"><a href="#▷-成交量" class="headerlink" title="▷ 成交量"></a>▷ 成交量</h3><ul><li>放量（成交量增加）所表明的是买卖双方对目前的价格分歧特别大。</li><li>缩量（成交量减少）所表明的是买卖双方对市场非常的一致，无论是一致的看涨也好还是看跌也罢，核心点就是一致。<ul><li>缩量上涨：有些股票进入拉升状态后呈现缩量上涨的格局,很多投资者并不认可这种走势,认 为是上升乏力的表现,因为缺乏持续资金进场.事实上这种看法比较片面,缩量上 涨虽然表明增量进场比较少,但也反过来说明卖盘不多.成交量缩小还能保持上升 态势,说明主力不用多少资金就能拉升股价,实质就是浮筹比较少,即该股已经高 度控盘,后市很可能有超强的表现</li><li>缩量下跌：如果在很低的价格位置，有可能形成底部；如果在价格高位出现，突然放量下跌后，继续缩量下跌，这样的股票比较危险，因为很有可能主力已经出货完毕，缩量下跌只是散户的行为</li></ul></li></ul><h3 id="▷-换手率"><a href="#▷-换手率" class="headerlink" title="▷ 换手率"></a>▷ 换手率</h3><p>$$ 换手率 = 单位时间成交量/总股数 $$</p><ul><li>按时间参数的不同，在使用上又划分为日换手率、周换手率</li><li>除新股外，大多数股票日换手在1%-25%</li><li>70%的股票日换手率低于3%（分界线），过高的换手率也意味着风险（买卖方分歧大）</li><li>A股散户多，所以A股平均换手率稳居世界前列，为券商贡献巨量手续费</li></ul><h3 id="▷-量比-amp-委比"><a href="#▷-量比-amp-委比" class="headerlink" title="▷ 量比 &amp; 委比"></a>▷ 量比 &amp; 委比</h3><ul><li>量比：<code>1分钟成交量/过去5日分钟平均交易量</code>，大于1表示交易活跃</li><li>委比：<code>委托买入量/委托卖出量</code>，委比反应的是买:卖的意愿，但是委托是可以撤单的，所以可能不那么准确</li></ul><h3 id="▷-总结：均线系统"><a href="#▷-总结：均线系统" class="headerlink" title="▷ 总结：均线系统"></a>▷ 总结：均线系统</h3><p>常见的均线系统（MACD/MA/EMA/KDJ/DKX等..）的使用方法：</p><ul><li>均线排列：多头/空头排列、收敛/发散趋势</li><li>均线交叉：金叉、死叉</li><li>不同均线系统的背离情况</li></ul><p><strong>基于价格</strong>的均线系统（MACD/MA/EMA/KDJ/DKX等..）都有滞后性的问题，如果增加短期的权重可以使其变灵敏，但灵敏度的上限=K线的变化，过于频繁发出信号，比较几种均线系统：</p><ul><li>MACD(12, 26)：约等于“K线上站5MA”</li><li>DK点：<br>D点 ≈ “K线上站5MA”，<br>K点 ≈ “K线跌破5MA”</li><li>DKX： 约等于双均线 MA（5，20），但加上了成交量</li><li>EMA(5, 20)：MA的平滑版本</li><li>20MA+60MA（ETF之家提供的双均线策略）：明显滞后，能躲过一部分大跌，但由于滞后性也没机会吃到涨幅</li><li>KDJ： MACD的神经质版本，频繁的买入信号，对于中长期没法用</li></ul><p>复盘上个牛熊周期（2019-2022），均线系统是否有效：</p><ul><li>DK线（5MA+20MA）：在牛市启动期，可以保证上车，但在牛市顶部阶段随时可能崩盘时，会发出错误的买入信号（参考2022.03），所以DK点（包括短均线）在不同时期的信号需区别对待，在估值过高的阶段应该选择空仓 or 极小仓位</li><li>观察（MACD/MA/EMA/DK线等..）周线背离情况，2021.4之后的周MACD/DKX/DDX出现了背离，意味着随时可能变盘：牛市跌破120MA，等于结束了，均线再次发出买入信号可以不理会</li></ul><h3 id="▷-MA（移动均线）"><a href="#▷-MA（移动均线）" class="headerlink" title="▷ MA（移动均线）"></a>▷ MA（移动均线）</h3><p>移动平均线－MA (Moving Average):  <code>当日MA = 过去N天的收盘价求算数平均</code>, 类似一个N天的滑动窗口</p><p>➤ 均线的用法：</p><ul><li>股价上站/回踩均线：例如“K线上站5日均线”作为短期趋势</li><li>均线排列：<ul><li>多头排列：短期均线依次在长期均线之上，例如从上向下依次为 5—10—20—40—120</li><li>空头排列：相反</li></ul></li><li>均线交叉：<ul><li>金叉：短期均线上穿长期均线</li><li>死叉：短期均线下穿长期均线</li></ul></li><li>均线收敛/发散：<ul><li>均线间的距离呈收敛 + 向上突破：当多条均线出现收敛（均线值接近）迹象时，表明市场成本趋于一致，此时是买入信号 =&gt; [[#顾比均线]]</li></ul></li></ul><p>➤ 均线的周期：</p><table><thead><tr><th style="text-align:left">均线</th><th style="text-align:left">又称</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">5日均线</td><td style="text-align:left">周线</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">20日均线</td><td style="text-align:left">月线</td><td style="text-align:left">短期趋势</td></tr><tr><td style="text-align:left">60日均线</td><td style="text-align:left">季线</td><td style="text-align:left">中期趋势</td></tr><tr><td style="text-align:left">120日均线</td><td style="text-align:left">半年线</td><td style="text-align:left">中长趋势</td></tr><tr><td style="text-align:left">250日均线</td><td style="text-align:left">年线</td><td style="text-align:left">长期趋势</td></tr><tr><td style="text-align:left">120月均线</td><td style="text-align:left">十年线</td><td style="text-align:left">大经济周期中的超长趋势</td></tr></tbody></table><ul><li>一般以日线 <code>MA5 + MA10</code>解析短期走势，以 <code>MA30 + MA60</code>解析中期走势，以 <code>MA120 + MA250</code>解析中长期走势</li><li>年线、5年线（月K，MA60）和10年线（月K，MA120）的支撑性逐步增强 </li></ul><hr><p>➤ 不同周期K线的 MA 设置：</p><ul><li>月K：MA(4, 8)，对应 半年、年；MA(60, 120)，对应 五年、十年；</li><li>周K：MA(17, 35)，对应 半年、年；</li><li>日K：MA(20, 60, 120)，对应 月、季、半年；</li><li>15分钟K线 / 30分钟K线，这个级别的K线在东财上可以看到资金的（大户/小户）分时博弈：<ul><li>15分钟K线均线参数：MA(80, 320)，对应5日、20日；</li><li>30分钟K线均线参数：MA(40, 160)，对应5日、20日；</li></ul></li></ul><hr><ul><li>简单量化交易之均线策略：<a href="/52.Financing/F52a.双均线策略/" title="F52a.双均线策略">F52a.双均线策略</a></li><li>MA策略量化实测：<a href="/52.Financing/F41b.技术分析指标-量化回测/" title="F41b.技术分析指标-量化回测">F41b.技术分析指标-量化回测</a></li></ul><h3 id="▷-MACD（平滑移动均线）"><a href="#▷-MACD（平滑移动均线）" class="headerlink" title="▷ MACD（平滑移动均线）"></a>▷ MACD（平滑移动均线）</h3><p>指数平滑移动平均线（Moving Average Convergence / Divergence，缩写：MACD，港澳台称为指数平滑异同移动平均线）。<br>是利用快速移动平均线和慢速移动平均线，在一段上涨或下跌行情中两线之间的差距拉大，而在涨势或跌势趋缓时两线又相互接近或交叉的特征，通过双重平滑运算后研判买卖时机的方法。运用两条移动平均线相互背离，相互应证的交易法则：当MACD从负数转向正数，是买的信号。当MACD从正数转向负数，是卖的信号。当MACD以大角度变化，表示快的移动平均线和慢的移动平均线的差距非常迅速的拉开，代表了一个市场大趋势的转变。</p><p><img src="/images/2022/20220403162738.png" alt="MACD"></p><ul><li>白色线(DIF): <code>DIF = EMA(close, 12) - EMA(close, 26)</code>，EMA(close, n)表示过去n日收盘价的指数移动平均<ul><li>EMA12: 最近12日移动平均值= <code>前一日EMA12 × 11/13 + 今日收盘价×2/13</code></li><li>EMA26: 最近26日移动平均值= <code>前一日EMA26 × 25/27 + 今日收盘价×2/27</code></li></ul></li><li>黄色线(DEA): 即再计算上面 DIF的 9日EMA = <code>前一日DEA × 8/10 + 今日DIF × 2/10</code></li><li>红蓝色柱: 即为MACD柱状图 = <code>(DIF-DEA)×2</code>，正数为红，负数为绿</li><li>零轴：在零轴以上，意味着每天的DIF大于零（每天的12EMA一直大于26EMA）</li></ul><p>MACD使用的 <strong>EMA（指数移动平均值）</strong> 的计算方法，和另一种均线指标 <strong>EXPMA（指数平均线）</strong> 还是有区别的，<del>前者“前一日”权重更大，后者“今日”权重更大</del>；</p><p>相比较移动均线（MA）和 MACD，二者都属于“针对过去股价”计算的均线，所有均线都有同样的问题——滞后性，但MACD为了弥补这一点，使用了DIF差值，DIF可以认为是长/短周期均值的差，反应变化程度，（对于平滑的曲线，计算变化程度用切线角度，但是K线不是“平滑”曲线，故这里也就不用切线斜率，而是用差值，来反应变化的程度）。</p><p>所以MACD指标的核心就是快慢线的变化趋势，也即DIF 相较 DIF的均值（DEA）的变化趋势，<br>如果仅靠观察两条线的敞口大小（收敛趋势 or 发散趋势）不是很直观，为了方便观察快慢线差值变化，MACD还引入了<strong>红绿柱</strong>，用红蓝柱体能更明显反应两条线之间的差值。</p><p>➤ MACD基本用法:</p><ul><li>DIF 向上穿过 DEA 时，被称为“金叉”，这是一个买入信号</li><li>DIF 向下穿过 DEA 时，被称为“死叉”，这是一个卖出信号</li><li>处于高位且 快慢线和K线的趋势出现背离… 卖出</li></ul><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/29954111/answer/2444898925" target="_blank" rel="noopener">MACD指标的内在逻辑是什么？ - 知乎</a></li></ul><p>MACD择时效果量化实测：</p><ul><li><a href="https://www.zhihu.com/question/36411902/answer/2384383208" target="_blank" rel="noopener">MACD指标在量化策略实战中如何应用？- 知乎</a> // 结论很有意思</li><li><a href="/52.Financing/F41b.技术分析指标-量化回测/" title="F41b.技术分析指标-量化回测">F41b.技术分析指标-量化回测</a></li></ul><hr><p>为什么MACD的默认参数是12、26、9（DIFF参数设置是12日和26日收盘价的EMA，DEA是9日DIFF的EMA）？</p><p>○ 为什么是12、26？</p><p>坊间对“12”和“26”的来历说法都较为一致。相传在Gerald发明MACD的上世纪70年代，漂亮国交易市场仍在“996”，一周有6个交易日，于是“12”对应的是两周。每个月有4周，一周休息一天，那么30-4=26，“26”对应的是一个月。<br>但是查了道琼斯工业指数和麦当劳的历史日K图，发现一周并没有6根Bar，说明至少在漂亮国股票交易市场并没有“996”，觉得更可能是Gerald关注的交易品种一周是交易6天，类似于期货从周一上午交易到周六凌晨。</p><p>○ 为什么是9？</p><p>“9”是每周交易日数目乘以概率密度系数后的结果，其中1/sqrt(2π)是标准正态分布的<strong>概率密度函数</strong>的系数：</p><p>$$ (1+ 1/sqrt(2π)) * 6 ≈ 9$$</p><p>@ref: <a href="https://www.zhihu.com/question/29523961" target="_blank" rel="noopener">MACD参数设置的逻辑是什么 ？ - 知乎</a></p><h3 id="▷-KDJ（随机指标）"><a href="#▷-KDJ（随机指标）" class="headerlink" title="▷ KDJ（随机指标）"></a>▷ KDJ（随机指标）</h3><p>KDJ指标的中文名称又叫<strong>随机指标</strong>，最早起源于期货市场，由乔治·莱恩（George Lane）首创。随机指标KDJ最早是以KD指标的形式出现，而KD指标是在威廉指标的基础上发展起来的。不过KD指标只判断股票的超买超卖的现象，在KDJ指标中则融合了移动平均线速度上的观念，形成比较准确的买卖信号依据。<br>在实践中，K线与D线配合J线组成KDJ指标来使用。KDJ指标在设计过程中主要是研究最高价、最低价和收盘价之间的关系，同时也融合了动量观念、强弱指标和移动平均线的一些优点。因此，能够比较迅速、快捷、直观地研判行情，被广泛用于股市的中短期趋势分析，是期货和股票市场上最常用的技术分析工具。</p><ul><li>RSV（未成熟随机值）的计算较复杂，忽略</li><li>K值 = <code>2/3 × 前一日K值 + 1/3 × 当日RSV</code>，变化率介于D、J之间</li><li>D值 = <code>2/3 × 前一日D值 + 1/3 × 当日K值</code>，D值可以看作是比K更“平均化”的RSV，变化率最低</li><li>J值 = <code>3 × 当日K值 - 2 × 当日D值</code>，反应了K和D之间的差值，变化率最高</li></ul><p>KDJ主要是利用价格波动的真实波幅来反映价格走势的强弱和超买超卖现象，在价格尚未上升或下降之前发出买卖信号的一种技术工具。它在设计过程中主要是研究最高价、最低价和收盘价之间的关系，同时也融合了动量观念、强弱指标和移动平均线的一些优点，因此，能够比较迅速、快捷、直观地研判行情。由于KDJ线本质上是一个随机波动的观念，故其对于掌握中短期行情走势比较准确。</p><p>➤ KDJ基本用法：</p><ul><li>K/D指标的交叉类似快慢MA，K线向上突破D线时金叉，K线从上方下穿D线时死叉；</li><li>K/D/J三个值都大于80，进入超买（大部分人只愿意买，股价被推高）区域，后续下跌的可能性变大；</li><li>K/D/J三个值都小于20，进入超卖（大部分人只愿意卖，股价被拉低）区域，后续反弹的可能性变大；</li><li>KDJ在进入超买/超卖区域后，容易出现钝化（3条线变得纠缠）；</li><li>KDJ适用于短期买卖点，一般和长期MACD配合使用；</li></ul><h3 id="▷-RSI（强弱指标）"><a href="#▷-RSI（强弱指标）" class="headerlink" title="▷ RSI（强弱指标）"></a>▷ RSI（强弱指标）</h3><p>相对强弱指标（Relative Strength Index），RSI强弱指标是根据一定时期内上涨和下跌幅度之和的比率制作出的一种技术曲线。能够反映出市场在一定时期内的景气程度。是由威尔斯.威尔德（Welles Wilder)最早应用于期货买卖，后来人们发现在众多的图表技术分析中，强弱指标的理论和实践极其适合于股票市场的短线投资，于是被用于股票升跌的测量和分析中。</p><p>技术方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N日RSI = A /（A+B）× 100，其中：</span><br><span class="line"></span><br><span class="line">A：N日内收盘涨幅之和</span><br><span class="line">B：N日内收盘跌幅之和（取正值）</span><br><span class="line"></span><br><span class="line">N常用的周期有：6日 / 12日 / 24日</span><br></pre></td></tr></table></figure><p>由上面算式可知RSI指标的技术含义，即以向上的力量与向下的力量进行比较，若向上的力量较大，则计算出来的指标上升；若向下的力量较大，则指标下降，由此测算出市场走势的强弱。</p><p>➤ RSI基本用法：RSI值范围在0-100，”强”和”弱”以50作为分界线：</p><ul><li>RSI&gt;50，表明市场进入强市，可以考虑买入;</li><li><p>RSI&gt;80，表明买入力量极强，进入<strong>超买区</strong>，后市回调的机会增加；</p></li><li><p>RSI&lt;50，表明市场进入弱市，可以考虑卖出;</p></li><li>RSI&lt;20，表明卖出力量极强，进入<strong>超卖区</strong>，后市反弹的机会增加。</li></ul><p>具体使用时，三条不同周期的RSI类似多周期均线，“金叉”/“死叉”，多头排列/空头排列，敞口收敛/发散…也适用于多周期RSI；</p><h3 id="▷-BIAS（乖离率指标）"><a href="#▷-BIAS（乖离率指标）" class="headerlink" title="▷ BIAS（乖离率指标）"></a>▷ BIAS（乖离率指标）</h3><p>BIAS乖离率指标是测量股价偏离均线大小程度的指标。当股价偏离市场平均成本太大时，都有一个回归的过程，即所谓的“物极必反”。乖离率是指股价与平均移动线之间的偏离程度，通过百分比的形式来表示股价与平均移动线之间的差距。如果股价在均线之上，则为正值；如果股价在均线之下，则为负值。乖离率最早来源于葛兰维的平均线定律，它的理论基础主要从投资者心理角度来分析，当股价偏离市场平均成本太大时，都有一个回归的过程，即所谓的“物极必反”，因为均线可以代表平均持仓成本，利好利空的刺激，造成股价出现暴涨暴跌。</p><p>$$ BIAS=(收盘价-收盘价的N日简单平均)/收盘价的N日简单平均*100 $$</p><p>BIAS指标有三条指标线，N的参数一般设置为6日、12日、24日，</p><p>从BIAS的计算过程可以看出，其值 = 最近一天价格，相较过去N日均价的波动程度，由于只是简单的算术平均，没有归一化，导致绝对值上下限波动大，且回复性并不怎么好；</p><p>因为BIAS三条线也属于快慢线，所以<strong>均线的用法</strong>（多空排列、上穿下穿）也适用于BIAS，绝对值越大=波动越大；</p><p>➤ 实际对BIAS的应用，是均值回归。大盘指数的<strong>均值回复性</strong>比个股更好；<br>如果是振荡期，BIAS三条线纠缠，绝对值也不大（=波动不大）；<br>但如果出现过大的波动（上涨/下跌），则反向做，即出现正值的大波动开始做空，出现负值的大波动开始做多；</p><h3 id="▷-EMA（指数平均数）"><a href="#▷-EMA（指数平均数）" class="headerlink" title="▷ EMA（指数平均数）"></a>▷ EMA（指数平均数）</h3><p><strong>EXPMA</strong>指标简称<strong>EMA</strong>，中文名字指数平均数指标，一种趋向类指标，从统计学的观点来看，只有把移动平均线（MA)绘制在价格时间跨度的中点，才能够正确地反映价格的运动趋势，但这会使信号在时间上滞后，而EXPMA指标是对移动平均线的弥补，EXPMA指标由于其计算公式中着重考虑了价格当天（当期）行情的权重。<code>EXPMA=（当日收盘价－上一日EXPMA）/N + 上一日EXPMA</code></p><h3 id="▷-GMMA（顾比均线）"><a href="#▷-GMMA（顾比均线）" class="headerlink" title="▷ GMMA（顾比均线）"></a>▷ GMMA（顾比均线）</h3><p>顾比均线： GMMA（Guppy Multiple Moving Average）——顾比复合移动平均线，简称顾比均线</p><ul><li>顾比均线由两组均线构成，分别是长期组（黄线部分）和短期组（蓝线部分）。</li><li>短期组6根均线，分别是3、5、8、10、12和15日（周、月）平均线；</li><li>长期组也是6根均线，分别是30、35、40、45、50和60日（周、月）平均线。</li></ul><p>➤ 顾比均线使用：短期均线组和长期均线组，分别反映了短线交易者和中长期投资者的行为，当这两组指标相互靠近的时候，说明投资者和投机者对于证券的价值有了共识，而当两组相互远离的时候，就说明对价值产生了分歧</p><p>从偏股混合基金指数2005年以来的月线图来看，在顾比均线<strong>短期组完全上穿长期组</strong>时买入，胜率达到了100%：<br><img src="/images/gmma.png" alt="GMMA"></p><p>@ref:</p><ul><li><a href="https://xueqiu.com/2356382715/204101803" target="_blank" rel="noopener">一个简单易行的基金买入策略 - 雪球</a></li><li><a href="https://xueqiu.com/2356382715/207958894" target="_blank" rel="noopener">顾比均线在基金投资中的运用 - 雪球</a></li></ul><h3 id="▷-布林-BOLL-线"><a href="#▷-布林-BOLL-线" class="headerlink" title="▷ 布林(BOLL)线"></a>▷ 布林(BOLL)线</h3><p>在所有的指标计算中，BOLL指标的计算方法是最复杂的之一，其中引进了统计学中的标准差概念，涉及到中轨线（MB）、上轨线（UP）和下轨线（DN）的计算。<br>另外，和其他指标的计算一样，由于选用的计算周期的不同，BOLL指标也包括日BOLL指标、周BOLL指标、月BOLL指标年BOLL指标以及分钟BOLL指标等各种类型。<br>经常被用于股市研判的是日BOLL指标和周BOLL指标。虽然它们的计算时的取值有所不同，但基本的计算方法一样。  　　</p><p>以日BOLL指标计算为例，其计算方法如下：</p><ul><li>中轨线=N日的移动平均线 // 一般用20日MA</li><li>上轨线=中轨线＋两倍的标准差</li><li>下轨线=中轨线－两倍的标准差</li></ul><p>布林线的理论使用原则：1是<strong>均值回复</strong>，主要是K线穿过上/下轨时，可能出现反向走势；2是排列，3线敞口收敛/发散、3线方向；</p><p>➤ BOLL指标使用规则：</p><p>（1）买卖信号：</p><ul><li>当股价K线带量向上突破布林线的上轨，并且TRIX指标也已经发出底位“金叉”时，说明股价即将进入一个中长期上升通道之中，这是BOLL指标发出的买入信号。</li><li>当布林线轨道很长一段时间的<strong>底位窄幅水平运动后</strong>，一旦股价K线<strong>带量向上突破布林线的上轨</strong>，同时原本狭窄的布林线通道突然开口向上时，说明股价即将脱离原来的水平运行通道、进入新的上升通道之中，这也是BOLL指标发出的买入信号。</li><li>当股价K线向下突破布林线的中轨，并且TRIX指标也在已经发出高位“死叉”时，说明股价即将进入一个中长期下降通道之中，这是BOLL指标发出的卖出信号。</li><li>当布林线轨道很长一段时间的<strong>高位窄幅水平运动</strong>后，一旦股价K线<strong>向下突破布林线的下轨</strong>，同时原本狭窄的布林线通道突然开口向下时，说明股价即将脱离原来的水平运行通道、进入新的下降通道之中，这也是BOLL指标发出的卖出信号。</li></ul><p>（2）持股持币信号：</p><ul><li>当布林线开口向上后，只要股价K线始终运行在布林线的中轨上方的时候，说明股价一直处在一个中长期上升轨道之中，这是BOLL指标发出的持股待涨信号，如果TRIX指标也是发出持股信号时，这种信号更加准确。</li><li>当布林线开口向下后，只要股价K线始终运行在布林线的中轨下方的时候，说明股价一直处在一个中长期下降轨道之中，这是BOLL指标发出的持币观望信号，如果TRIX指标也是发出持币信号时，这种信号更加准确。</li></ul><p>其他：</p><ul><li>简单量化交易之布林带策略：<a href="/52.Financing/F52b.布林线策略/" title="F52b.布林线策略">F52b.布林线策略</a></li><li><a href="/52.Financing/F41b.技术分析指标-量化回测/" title="F41b.技术分析指标-量化回测">F41b.技术分析指标-量化回测</a></li></ul><h3 id="软件特色指标（DKX、DDX）"><a href="#软件特色指标（DKX、DDX）" class="headerlink" title="软件特色指标（DKX、DDX）"></a>软件特色指标（DKX、DDX）</h3><p>@link: [[F41a1.东方财富PC版功能说明]]</p><ul><li><p>DKX（DK线/多空线）根据收盘价和成交量计算出是 D点（多） or K点（空），算法未知</p></li><li><p>DDX（主力强度，分时DDX=<code>大单净买入量/流通盘</code>），由快/中/慢三条DDX均线：</p><ul><li>DDX也是快/中/慢 3条线，用法同均线的快慢线</li><li>DDX的红/绿柱：红-大单流入较多，绿-大单流出较多</li><li>DDX走强（持续红柱 &amp; 金叉），表示主力持续进入，但有大单持续流入不代表股价一定上涨</li><li>DDX可以在大盘/个股/板块的日K下显示，但是ETF和行业指数无（在DDE显示的ETF的DDX似乎有问题，值&gt;1）</li><li>DDX与大盘股价的背离（20个交易日为窗口观察趋势），是一个逃顶信号</li><li>同花顺也有类似功能：<a href="https://baike.baidu.com/item/%E5%90%8C%E8%8A%B1%E9%A1%BABBD%E6%8C%87%E6%A0%87/1666444" target="_blank" rel="noopener">BBD指标_百度百科</a></li></ul></li><li>DDY (散户动向）衡量当日成交中散户参与度大小的指标<ul><li>正值越大，表示当日散户离场现象明显；</li><li>负值越小，表示当日散户进场意愿强烈；</li></ul></li><li>DDZ (主力博弈）衡量买卖双方大单力度的指标，对于成交量大或者多空分歧较大的股票比较有效。<ul><li>红色彩带表示大资金买入强度，色带越宽、越高表示买入强度越大。</li><li>当彩带突然升高放宽时往往预示短线将快速上涨。</li></ul></li></ul><blockquote><p>如果要计算某天的大单净量 占交易量的比例 = 今天累计DDX/日换手率</p></blockquote><ul><li><p>资金博弈：每日买入单按金额分为超大/大户/中户/小户，累积计算买入量</p><ul><li>只需关注4条线的分歧（距离走阔 or 收窄）</li><li>大盘的资金博弈，在日级别K线走阔/收窄的趋势并不明显，15分钟/30分钟下看短期的资金分歧</li><li>和DDX一样，有大单持续流入不代表股价一定上涨</li></ul></li><li><p>资金趋势：柱状线代表每日资金流向占比情况，红色柱状线表示主力资金流入，绿色柱状线表示主力资金流出</p></li></ul><h2 id="K线形态"><a href="#K线形态" class="headerlink" title="K线形态"></a>K线形态</h2><p><img src="/images/2022/20220331145900.png" alt=""></p><ul><li>① 全秃阳线：也称光头光脚阳线，该线是一条既无上影线，也无下影线的图线。因开盘价是最低价，收盘价是最高价，故当天一直处于上升走势，表示上升走势强劲，后市可持续看好。</li><li>② 开盘秃阳线：也称光脚阳线，即只有上影线而无下影线的阳线。因收盘价并不是最高价，而开盘价是最低价，当天依然处于上升行情，但上挡压力开始显现。</li><li>③ 收盘秃阳线：也称光头阳线，即只有下影线而无上影线的阳线。因收盘价是最高价，当天虽有下跌，但开盘价依然较低，表示上升力度较大，行情持续看好。</li><li>④ 大阳线：实体较长，又带有上下影线，因实体较长，当天涨幅较大，显示较强上升走势，行情持续看好。</li><li>⑤ 小阳线：也称小棋子，实体较小，带有不太长的上下影线，涨跌走势不明朗，行情难料。</li><li>⑥ 星形阳线：也称极阳线，实体很小，上下影线更短，相对上方小阳线，走势更加不确定，涨跌难判断。</li><li>⑦ 长下影阳线：实体较小，下影线较长，无上影线，或只有很短的上影线。<br>若处在高价位（<strong>上吊线</strong>），是行情见顶的信号，应卖出股票；<br>若处在低价位（<strong>锤子线</strong>），则是行情见底的信号，可考虑买入股票。</li><li>⑧ 长上影阳线（<strong>倒锤头线</strong>）：也叫流星线，实体较短，上影线较长，无下影线或只有很短的下影线。<br>若处在高价位，是行情见顶的信号，应卖出股票；<br>若处在低价位，则是行情见底的信号，可考虑买入股票。</li></ul><hr><p>K线技术分析不是国内老法师特产，其实都是进口来的概念，比如上面的：<br>  上吊线 = Hanging Man；<br>  锤子线 = Bullish Hammer；</p><p>英为上还有根据K线形态看涨跌的专区：<a href="https://cn.investing.com/technical/candlestick-patterns" target="_blank" rel="noopener">https://cn.investing.com/technical/candlestick-patterns</a> …</p><p>Doji Star Bearish（十字星看跌）：<br><img src="/images/2022/IMG20221211-1.png" alt=""></p><p>Bullish doji Star（十字星看涨）：<br><img src="/images/2022/IMG20221211-2.png" alt=""></p><p>Falling Three Methods（中文翻译成什么？）：<br><img src="/images/2022/IMG20221211-3.png" alt=""></p><hr><p><img src="/images/2022/20220331145923.png" alt=""></p><ul><li>① 全秃阴线：也称光头光脚阴线，该线是一条既无上影线，也无下影线的图线。开盘价是最低价，收盘价是最高价，上升走势很弱，行情看淡。</li><li>② 收盘秃阴线：也称光脚阴线，即只有上影线而无下影线的阴线。遇到上涨阻力较大，行情看淡。</li><li>③ 开盘秃阴线：也称光头阴线，即只有下影线而无上影线的阴线。虽然下挡出现了一定程度的支撑，但行情一时可能还难以变好。</li><li>④ 大阴线：即实体大，而又带有上下影线的图线，当天下跌幅度较大，显示弱势走势，后市看淡。</li><li>⑤ 小阴线：趋势看法同上⑤</li><li>⑥ 星形阴线：趋势看法同上⑥</li><li>⑦ 长下影阴线：趋势看法同上⑦</li><li>⑧ 长上影阴线：趋势看法同上⑧</li></ul><hr><p>K线补缺口理论：</p><ul><li>A、向上的缺口。由于缺口下端以上全部是获利盘，所以赚到钱的人就有了结的动力，这股力会一直持续到价格接近缺口下端为止。从“筹码分布”的理论解释..</li><li>B、向下的缺口。由于缺口下端以下部分全都是套牢盘，卖出的人就会减少，直到价格接近缺口上端时实现平衡</li></ul><h2 id="趋势形态"><a href="#趋势形态" class="headerlink" title="趋势形态"></a>趋势形态</h2><p>本章内容参考自：<a href="https://www.futunn.com/learn/detail-trend-line-1172-1902400003" target="_blank" rel="noopener">速学21个技术分析利器_富途</a></p><h3 id="▶-阻力位-amp-支撑位"><a href="#▶-阻力位-amp-支撑位" class="headerlink" title="▶ 阻力位 &amp; 支撑位"></a>▶ 阻力位 &amp; 支撑位</h3><blockquote><p>判断是否是“有效的支撑位”：<strong>还要看交易量</strong>，有大量交易/换手的区域，才能算为有效支撑</p></blockquote><p><strong>支撑位</strong>的形成：下跌过程中，如果在某个位置（在众多散户心理上是一个低价）出现大量的买盘，那么价格在此处不再下跌，但是当支撑位跌破后，后续可能会有较大幅度的下跌；</p><p>同时<strong>支撑位和阻力位是可以相互转化的</strong>：当股价跌破支撑位后触底，再次反弹到上次的支撑位，这个位置可能变成阻力位，因为股价运行到这里后有太多“保本出”的卖盘（这种压力位往往出现在股价底部反弹的过程中）；</p><p><img src="/images/%E9%98%BB%E5%8A%9B%E4%BD%8D-%E6%94%AF%E6%92%91%E4%BD%8D.png" alt="阻力位-支撑位"></p><p><strong>压力位</strong>另一种解释（这种往往是高价位出现的阻力）：当股价足够高，因为很多人已经获利，形成众多散户的“止盈心理价位”，卖出盘会变多，此时这个位置便成为阻力位。</p><p>@ref:</p><ul><li><a href="https://bbs.pinggu.org/thread-3837876-1-1.html" target="_blank" rel="noopener">【陈珺盈】：支撑位和阻力位背后的秘密 - 经管之家(原人大经济论坛)</a></li><li><a href="https://www.jsgroup-chn.com/cn/education/education-themes/technical-analysis/support-and-resistance/" target="_blank" rel="noopener">支撑位与阻力位</a></li></ul><hr><p>因为有很多看技术指标的交易者，所以某些技术指标也可以成为阻力位 &amp; 支撑位：</p><ul><li>均线阻力(压力)位：主要指5、10、20、30、60、120、250日等均线对股价的压力</li><li>高点(波峰)压力位：前期两个以上高点(波峰)的连线构成高点阻力位。股价突破此连线也需成交量放大配合。</li><li>低点(波谷)压力位;股价跌破前期两个以上低点(波谷)连线后，如果反弹，这条连线对股价将产生压力，这条连线就叫低点压力位。</li><li>颈线压力位：双底(W底)、头肩底、N形底、双顶(M顶)、头肩顶等形态的颈线对股价上涨或反弹都有压力。</li><li>轨道压力位：上升或下跌轨道的中轨、上轨；BOLL线的中轨、上轨对股价也有压力。这里主要讲一下BOLL中轨，上轨对股价的压力，因为在轨道中常用的就是BOLL轨道</li></ul><h3 id="▶-筹码理论"><a href="#▶-筹码理论" class="headerlink" title="▶ 筹码理论"></a>▶ 筹码理论</h3><p>什么是筹码分布？<br>确切地说是“流通股票持仓成本分布”，展示的是不同价位上投资者的持股数量。</p><p><strong>所有的“技术形态”都是对筹码分布的动态修改，交易量越大的点位，对筹码分布的修改力度越大</strong>。</p><p>上面提到了“有效的” 阻力位 &amp; 支撑位，应该是“成交密集区”，<br>无论是周K线或日K线，如果在某价位区内停留一段时间（n个交易日）。这个K线集中且成交量较大的价位区称之为“成交密集区”。通常多头与空头实力变化决定成交密集区面积的大小。</p><p>但是“成交密集区”并不是静态的，因为市场过高的换手率无时无刻不在化解“成交密集区”。例如许多资金套牢之后并非死守，有些会选择卖出止损，“阻力位”也会动态下移。而且距离上个“成交密集区”的时间越长，期间换手率越高，上个“成交密集区”的效力越小。</p><p>无论是大盘还是个股，都是这样，尤其是个股，有些股票换手率极高，成交密集区作用十分微小。也就不可能形成什么压力。</p><ul><li>K线的走出来的形态，可以认为是对筹码分布的不断修改，而筹码分布决定了阻力和支撑在哪里，阻力和支撑又在引导K线走势。   </li><li>当然技术分析派称，还有所谓的“势能”…   这同样可以用筹码理论去解释：<strong>筹码分布决定了阻力的位置，股价更倾向于往阻力最小的方向移动</strong>，例如上下都有筹码集中，但上方的筹码分布更密集，这时候下行的概率更大；再例如筹码稀薄区，只需很少的成交量就可以穿过，无论向上还是向下，这种区域也是K线容易出现缺口的地方。</li></ul><p>@ref:</p><ul><li><a href="https://www.zhihu.com/question/59689990" target="_blank" rel="noopener">同花顺等股票软件中筹码分布图有多大可信度，数据来源是什么？ - 知乎</a></li><li><a href="https://xueqiu.com/8773730078/237348601" target="_blank" rel="noopener">技术分析，有用撒？——筹码分布笔记（1） - 雪球</a></li></ul><h3 id="▷-趋势线"><a href="#▷-趋势线" class="headerlink" title="▷ 趋势线"></a>▷ 趋势线</h3><ul><li>上升趋势线：连接K线低点，当跌破<strong>上升趋势线</strong>时意味着可能反转下跌</li><li>下降趋势线：连接K线高点，当突破<strong>下跌趋势线</strong>意味着可能反转反弹</li></ul><p>注意：</p><ul><li>收盘价K线上穿or下跌趋势线波动超过3%时才视为有效；</li><li>趋势线穿过的点越多，它所反映的趋势走向越准确；</li></ul><p><img src="/images/2022/IMG20221113.png" alt=""></p><h3 id="▷-轨道线"><a href="#▷-轨道线" class="headerlink" title="▷ 轨道线"></a>▷ 轨道线</h3><p>在趋势线的基础上，添加上升轨道线(上升过程中连接高点) 和 下降轨道线（下降过程中连接低点），<br>当股价突破上升轨道线 &amp; 跌破下降轨道线后，行情可能有大的变动。<br><img src="/images/2022/IMG20221113-1.png" alt=""></p><h3 id="▷-楔形形态"><a href="#▷-楔形形态" class="headerlink" title="▷ 楔形形态"></a>▷ 楔形形态</h3><p>如果轨道线的上下轨道相交，则被称为<strong>楔形</strong></p><p>例①-上涨趋势中，出现的向下运行楔形，其调整的是相对应的此前一轮上涨，最后还将向上突破顺应原有趋势来发展：<br><img src="/images/2022/IMG20221209-30.png" alt="../_images/2022/IMG20221209-30.png"></p><p>例②-下跌趋势中，出现的向上运行楔形，这则是对原有下跌趋势进行的一轮修正，此后的运行方向也延续向下：<br><img src="/images/2022/IMG20221209-31.png" alt="../_images/2022/IMG20221209-31.png"></p><p>例③-两个典型的反转楔形：<br><img src="/images/2022/IMG20221209-32.png" alt="../_images/2022/IMG20221209-32.png"></p><hr><p>楔形形态，可以认为是对上一段走势（筹码分布）的整理：</p><p>@ref: <a href="https://xueqiu.com/8773730078/237417419" target="_blank" rel="noopener">https://xueqiu.com/8773730078/237417419</a></p><blockquote><p>好多老法师喜欢画线，画线中的玄学之一就是下跌过程中的上楔形走势，所有技术分析的预测都能用筹码理论解释，因为所有技术形态都是对筹码的整理。<br>如何用筹码理论解释“下跌过程中的上楔形走势”呢，<br>先简化一下模型，假如每天成交量都完全相等的情况，那么楔形走势，可以认为对筹码的整理如下：</p><ol><li>筹码中枢一定是上移的</li><li>K线的震荡逐步减弱，k线下方的筹码分布变得更集中<br>综上，这种楔形走势，实际增加了获利盘的风险，更有可能出货。但是，每天的成交量是不同的，那筹码未必走出上面的期望分布，楔形也就失效了，所以任何画线技术分析都是概率的</li></ol></blockquote><h3 id="▷-头肩形态"><a href="#▷-头肩形态" class="headerlink" title="▷ 头肩形态"></a>▷ 头肩形态</h3><p><img src="/images/2022/IMG20221113-4.png" alt=""></p><ul><li>构成：头肩顶图形以左肩、头部、右肩，以及<strong>颈线</strong>构成</li><li>成交量：左肩的到右肩，成交量呈递减现象</li><li>在头肩形态中，<strong>颈线成为支撑位</strong>，当颈线被击破时，是一个沽出信号</li><li>注意事项：<ul><li>如果成交量在跌破颈线时明显增加，表示抛售力量庞大，加速下跌。</li><li>跌破颈线后偶尔会出现暂时性的回调，但大概率不会超越颈线位（颈线变为回调的压力位），这情形通常会在低成交量的跌破时出现。</li><li>若跌破颈线后，回调时超越颈线位置，头肩顶形态很大可能会失败，不适合追空/卖出。</li></ul></li></ul><h3 id="▷-圆顶-amp-圆底"><a href="#▷-圆顶-amp-圆底" class="headerlink" title="▷ 圆顶 &amp; 圆底"></a>▷ 圆顶 &amp; 圆底</h3><p>圆顶的理论：股价运行到在圆顶左边时，切线斜率较大（也意味着买盘强），接近圆顶的顶部附近，斜率为0，意味着买盘力量减弱，无法再支撑股价向上运行</p><h3 id="▷-背离形态"><a href="#▷-背离形态" class="headerlink" title="▷ 背离形态"></a>▷ 背离形态</h3><p>背离形态往往意味着后续趋势可能发生变化。由于日线存在着较多的骗线，一些技术指标会反复发出背离信号，使得其实用性不强，建议重点关注周线上的技术指标背离现象。</p><p>（1）K线与交易量背离（量价背离）：</p><ul><li>底背离：出现于价格的阶段性底部区域，K线价格持续阶段下跌，成交量出现上扬趋势，有可能筑底 &amp;向上反转；从筹码理论解释，放量意味着这个区域迅速集中起来一堆筹码，放量的价位也就变成了“阻力位”，至于反弹能走多远，要看上面套牢筹码的抛压，如果抛压过重，下面获利筹码也会撤离…</li><li>顶背离：出现于价格的阶段性顶部区域，K线价格持续阶段上涨。成交量出现下降趋势，有可能价格见顶 &amp;下跌。从筹码理论解释，出现顶背离的时候，因为上涨的时候缩量，所以出现了“价涨，但筹码中枢没跟着涨”的现象，也就是说，让下方大量的获利筹码（绿色最长的线）有了结账退出的动力：</li></ul><p><img src="/images/2022/IMG20221208.png" alt="../_images/2022/IMG20221208.png"></p><blockquote><p>在App的设置中，K线和成交量都设置同样周期的移动平均线，更容易观察到背离。</p></blockquote><p>（2）K线与 MACD 背离：</p><ul><li>顶背离:  K线上涨, 但是MACD（DIF和DEA）趋势向下，“一般是股价在高位即将反转转势的信号，表明股价短期内即将下跌”。这种背离也不神秘，只要K线趋势的斜率变小，就一定有“MACD背离形态”，至于上升中趋势线斜率变小意味着什么不言而喻，但最终还是看筹码分布和趋势</li><li>底背离:  K线下跌, 但是MACD（DIF和DEA）向上，“预示着下跌行情将结束”。底部MACD背离的形成同上</li></ul><p><img src="/images/2022/20220403165211.png" alt="背离"></p><h2 id="交易理论"><a href="#交易理论" class="headerlink" title="交易理论"></a>交易理论</h2><p>江恩理论、道氏理论、波浪理论、箱体理论</p><p>@ref: <a href="https://www.futunn.com/learn/detail-ganns-theory-1172-1902400011" target="_blank" rel="noopener">https://www.futunn.com/learn/detail-ganns-theory-1172-1902400011</a></p><h3 id="▷-波浪理论"><a href="#▷-波浪理论" class="headerlink" title="▷ 波浪理论"></a>▷ 波浪理论</h3><p><a href="https://baike.baidu.com/item/%E4%BA%94%E6%B5%AA%E7%90%86%E8%AE%BA/2390299" target="_blank" rel="noopener">五浪理论_百度百科</a></p><ul><li>推动浪：<ul><li>第一浪：建仓浪</li><li>第二浪：洗盘浪</li><li>第三浪：主升浪</li><li>第四浪：调整，通常在低一级的对上一个第四浪之范围内完结，浪底不会低于第一浪的顶。</li><li>第五浪：股市中第五浪升幅，一般较第三浪为小。</li></ul></li><li>调整浪<ul><li>A浪：调整浪的第一波</li><li>B浪：升势较为情绪化，出现传统图表的牛势陷阱</li><li>C浪：调整浪的终点，破坏力较强，C浪应该可以再划分为低一级的五个波浪 …</li></ul></li></ul><p><img src="/images/%E8%89%BE%E7%95%A5%E7%89%B9%E6%B3%A2%E6%B5%AA.png" alt="../_images/艾略特波浪.png"></p><h3 id="▷-箱体理论"><a href="#▷-箱体理论" class="headerlink" title="▷ 箱体理论"></a>▷ 箱体理论</h3><ul><li>K线在箱体内波动，是调整阶段；</li><li>在箱体内运行是调整阶段，一旦K线突破压力位，会进入下一个箱体周期，此时是较好的买入时期；</li></ul><p><img src="/images/2022/IMG20221113-3.png" alt=""></p><h3 id="▷-江恩理论"><a href="#▷-江恩理论" class="headerlink" title="▷ 江恩理论"></a>▷ 江恩理论</h3><p>参考：<a href="https://www.baike.com/wikiid/885314551976213528" target="_blank" rel="noopener">江恩理论 - 快懂百科</a></p><h3 id="▷-道氏理论"><a href="#▷-道氏理论" class="headerlink" title="▷ 道氏理论"></a>▷ 道氏理论</h3><p>参考：<a href="https://www.baike.com/wikiid/6783954996668532065" target="_blank" rel="noopener">道氏理论 - 快懂百科</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;所谓「技术分析」&quot;&gt;&lt;a href=&quot;#所谓「技术分析」&quot; class=&quot;headerlink&quot; title=&quot;所谓「技术分析」&quot;&gt;&lt;/a&gt;所谓「技术分析」&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;技术分析包含的内容：&lt;ul&gt;
&lt;li&gt;技术分析理论的主要的代表有道氏理论、波浪理论、江恩法则等；  　　&lt;/li&gt;
&lt;li&gt;主要分析方法有K线理论、切线理论（趋势线、轨道线、黄金分割线、角度线）、形态理论（背离、发散、M头、W底、头肩顶、头肩底、圆弧底）、量价关系理论；  　　&lt;/li&gt;
&lt;li&gt;主要的分析指标包括：趋势型指标、超买超卖型指标、人气型指标、大势型指标等内容；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术分析的特性: 技术分析区别于其他分析方法的关键在于，它更像一门艺术。&lt;ul&gt;
&lt;li&gt;其一、&lt;strong&gt;在它的各种理论体系中，从定义到规则，都带有明显的经验总结色彩，不具备严格的数学推理过程；&lt;/strong&gt;  // 哈哈哈 　　&lt;/li&gt;
&lt;li&gt;其二、它包含的理论很多，每位技术分析家都有不同的见地  // 像不像星座？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;➤ 技术分析效果如何？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/25625592&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;专业量化交易从业人士如何看待传统的技术分析？ - 知乎&lt;/a&gt; ：这里的传统技术分析包括像均线、布林带，或者MACD等技术指标，他们在量化从业人士的工具箱中处于什么地位？&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/36411902&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MACD指标在量化策略实战中如何应用？ - 知乎&lt;/a&gt; =&amp;gt; &lt;a href=&quot;/52.Financing/F51.Quant.量化交易101/&quot; title=&quot;F51.Quant.量化交易101&quot;&gt;F51.Quant.量化交易101&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;➤ 技术分析的三大假设：&lt;/p&gt;</summary>
    
    
    
    <category term="52.Financing" scheme="https://beefyheisenberg.github.io/categories/52-Financing/"/>
    
    
    <category term="股市" scheme="https://beefyheisenberg.github.io/tags/股市/"/>
    
    <category term="K线" scheme="https://beefyheisenberg.github.io/tags/K线/"/>
    
    <category term="技术分析" scheme="https://beefyheisenberg.github.io/tags/技术分析/"/>
    
  </entry>
  
  <entry>
    <title>F13.股市101</title>
    <link href="https://beefyheisenberg.github.io/52.Financing/F13.%E8%82%A1%E5%B8%82101/"/>
    <id>https://beefyheisenberg.github.io/52.Financing/F13.%E8%82%A1%E5%B8%82101/</id>
    <published>2023-04-28T00:14:17.775Z</published>
    <updated>2023-04-28T00:14:17.776Z</updated>
    
    <content type="html"><![CDATA[<p>@tag: #入门101</p><h2 id="一级市场、二级市场"><a href="#一级市场、二级市场" class="headerlink" title="一级市场、二级市场"></a>一级市场、二级市场</h2><ul><li>一级市场(发行市场): 公司上市需要证监会批准, 根据公司净值定发行价, 股民投资者可以从证券公司申购, 申购成功则以发行价买入 (券商=&gt;投资者)</li><li>二级市场(交易市场): 在上述过程之后，公司到二级市场(也即证券交易市场, 故二级市场是’场内’)上市流通, 股民之间的转手/交易</li></ul><h2 id="买方、卖方"><a href="#买方、卖方" class="headerlink" title="买方、卖方"></a>买方、卖方</h2><ul><li>买方（buyside）：买（股票）的一方，主要包括公募基金，私募基金，保险公司投资部等以资产管理模式为代表的公司；</li><li>卖方（sellside）：卖（股票）的一方，券商和一些独立研究机构，他们主要从事分析和研究股票的工作，并且对于公司的基本面给予建议。从历史上看，卖方这个行业真正出现比较强的定价权是发生在美国上世纪的70年代。当时《对冲基金风云录》作者，摩根斯坦利著名的策略分析师巴顿.比格斯第一次在公司内部组建了一只超级豪华的分析师阵容，在那个时代就给出了6位数美元的工资。之后就是进入80年代美国股市最长的一轮牛市。这一次牛市同时推动了卖方研究所和买方投资机构的市场地位</li></ul><p>@ref: <a href="https://m.gelonghui.com/p/164848" target="_blank" rel="noopener">https://m.gelonghui.com/p/164848</a></p><h2 id="公募-私募"><a href="#公募-私募" class="headerlink" title="公募/私募"></a>公募/私募</h2><p>公募又称公开发行，是指发行人通过中介机构向不特定的社会公众广泛地发售证券，通过公开营销等方式向没有特定限制的对象募集资金的业务模式。为适应更广大投入者的需求，公募没有合同份数和起点金额的限制。因为涉及众多中小投入人的利益，监管当局对公募资金的使用方向、信息披露内容、危机防范要求都非常高。而私募是面向少量的、特定的投入者募集资金的方式。参加人一般应具备一定的经济实力、危机识别和危机承担能力。</p><h2 id="融资-融券"><a href="#融资-融券" class="headerlink" title="融资/融券"></a>融资/融券</h2><ul><li><a href="https://www.zhihu.com/question/20763639/answer/2367194502" target="_blank" rel="noopener">融资融券账户与普通账户相比有哪些区别和限制？（除了融资融券的特性以外） - 双牛做的木子星 的回答 - 知乎</a></li><li><a href="https://xueqiu.com/7410397739/115067709" target="_blank" rel="noopener">图文说明：融资（做多）与融券（做空）- 雪球</a></li></ul><h2 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h2><p>开盘前，不需要按照时间优先和价格优先的原则交易，而是按最大成交量的原则来定出股票的开盘价，</p><p>使它同时能满足以下3个条件：</p><ul><li>成交量最大。</li><li>高于基准价格的买入申报和低于基准价格的卖出申报全部满足（成交）。</li><li>与基准价格相同的买卖双方中有一方申报全部满足（成交）。</li></ul><h2 id="对冲"><a href="#对冲" class="headerlink" title="对冲"></a>对冲</h2><ul><li>对冲: 一般对冲是同时进行两笔行情相关、方向相反、数量相当、盈亏相抵的交易</li><li>对冲基金 <a href="https://wiki.mbalib.com/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91" target="_blank" rel="noopener">https://wiki.mbalib.com/wiki/%E5%AF%B9%E5%86%B2%E5%9F%BA%E9%87%91</a></li></ul><h2 id="做空"><a href="#做空" class="headerlink" title="做空"></a>做空</h2><p>可以做空的品种包括股票、股指期货、某国货币</p><blockquote><p>股票市场是通过融资融券“做空”的，融券卖出，即借来股票现值卖掉，等待价格下跌，再以低价买回股票归还，实现差价收益。<br>实际操作中，做空是先借入标的资产（有专门出借方如证券公司），然后卖出获得现金，这段时间内如果标的资产价格下跌，再以低价买入标的等量资产归还(证券公司), 获取差价利润<br>为什么出借方愿意出借标的的资产呢？通常出借方出借资产的利率是远高于贷款利率的，而且会不断浮动（根据市场情绪及下跌的可能性浮动，下跌可能性大，利率高；下跌可能性小，利率低），因此如果资产价格没有下跌，出借方就可以获得远超市场利率的收益，这也是出借方愿意出借的原因。</p></blockquote><ul><li><a href="https://www.zhihu.com/question/303151833/answer/1239497921" target="_blank" rel="noopener">什么是“做空”？“做空”是如何赚钱的？ - 飞翔的勇士的回答 - 知乎</a></li><li><a href="https://www.zhitongcaijing.com/content/detail/56980.html" target="_blank" rel="noopener">详解港股做空机制之一：做空到底怎么玩?</a></li><li>索罗斯做空英镑：<a href="/52.Financing/F29.金融大事记/" title="F29.金融大事记">F29.金融大事记</a></li><li>索罗斯做空港元：<a href="/52.Financing/F29.金融大事记/" title="F29.金融大事记">F29.金融大事记</a></li></ul><p>做空失败的案例:</p><ul><li><a href="https://xw.qq.com/cmsid/20210128A0F0SW00?f=newdc" target="_blank" rel="noopener">游戏驿站GameStop是做什么的？机构为何做空它？为何遭到散户毒打？|游戏|gamestop</a></li><li><a href="https://www.youtube.com/watch?v=KIe1MyD1m_o" target="_blank" rel="noopener">李永乐：游戏驿站GME股票为何暴涨？美国散户如何血洗华尔街？ - YouTube</a></li><li><a href="https://zhuanlan.zhihu.com/p/374931559" target="_blank" rel="noopener">Gamestop 美国散户逼空机构的“华尔街暴徒”事件是怎么一回事儿？ - 知乎</a></li></ul><h2 id="爆仓、平仓"><a href="#爆仓、平仓" class="headerlink" title="爆仓、平仓"></a>爆仓、平仓</h2><ul><li>爆仓：期货市场 or 有融资情况下的股市，当市场行情发生较大变化时，如果投资者保证金账户中资金的绝大部分都被交易保证金占用，而且交易方向又与市场走势相反时，由于保证金交易的杠杆效应，就很容易出现爆仓。//@ref : <a href="https://www.sohu.com/a/311450813_104543" target="_blank" rel="noopener">股市里的“爆仓”是什么意思？_股票</a></li><li>平仓: 可分为对冲平仓和强制平仓。<ul><li>对冲平仓是期货投入企业在同一期货交易所内通过买入卖出相同交割月份的期货合约，用以了结先前卖出或买入的期货合约。</li><li>强制平仓是指仓位持有者以外的第三人(期货交易所或期货经纪企业)强行了结仓位持有者的仓位，又称被斩仓或被砍仓。</li></ul></li></ul><p>在期货交易中发生强行平仓的原因较多，譬如客户未及时追加交易保证金、违反交易头寸限制等违规行为、政策或交易规则临时发生变化等。而在规范的期货市场上，最为常见的当属因客户交易保证金不足而发生的强行平仓。具体而言，是指在客户持仓合约所需的交易保证金不足，而其又未能按照期货企业的通知及时追加相应保证金或者主动减仓，且市场行情仍朝持仓不利的方向进展时，期货企业为避免损失扩大而强行平掉客户部分或者全部仓位，将所得资金填补保证金缺口的行为。</p><h2 id="PB、PE、ROE"><a href="#PB、PE、ROE" class="headerlink" title="PB、PE、ROE"></a>PB、PE、ROE</h2><p>=&gt; <a href="/52.Financing/F42.公司和行业的基本面指标/" title="F42.公司和行业的基本面指标">F42.公司和行业的基本面指标</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;@tag: #入门101&lt;/p&gt;
&lt;h2 id=&quot;一级市场、二级市场&quot;&gt;&lt;a href=&quot;#一级市场、二级市场&quot; class=&quot;headerlink&quot; title=&quot;一级市场、二级市场&quot;&gt;&lt;/a&gt;一级市场、二级市场&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一级市场(发行市场): 公司上市需要证监会批准, 根据公司净值定发行价, 股民投资者可以从证券公司申购, 申购成功则以发行价买入 (券商=&amp;gt;投资者)&lt;/li&gt;
&lt;li&gt;二级市场(交易市场): 在上述过程之后，公司到二级市场(也即证券交易市场, 故二级市场是’场内’)上市流通, 股民之间的转手/交易&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;买方、卖方&quot;&gt;&lt;a href=&quot;#买方、卖方&quot; class=&quot;headerlink&quot; title=&quot;买方、卖方&quot;&gt;&lt;/a&gt;买方、卖方&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;买方（buyside）：买（股票）的一方，主要包括公募基金，私募基金，保险公司投资部等以资产管理模式为代表的公司；&lt;/li&gt;
&lt;li&gt;卖方（sellside）：卖（股票）的一方，券商和一些独立研究机构，他们主要从事分析和研究股票的工作，并且对于公司的基本面给予建议。从历史上看，卖方这个行业真正出现比较强的定价权是发生在美国上世纪的70年代。当时《对冲基金风云录》作者，摩根斯坦利著名的策略分析师巴顿.比格斯第一次在公司内部组建了一只超级豪华的分析师阵容，在那个时代就给出了6位数美元的工资。之后就是进入80年代美国股市最长的一轮牛市。这一次牛市同时推动了卖方研究所和买方投资机构的市场地位&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="52.Financing" scheme="https://beefyheisenberg.github.io/categories/52-Financing/"/>
    
    
    <category term="入门101" scheme="https://beefyheisenberg.github.io/tags/入门101/"/>
    
    <category term="股市" scheme="https://beefyheisenberg.github.io/tags/股市/"/>
    
  </entry>
  
  <entry>
    <title>习惯的力量：富兰克林的自我修养</title>
    <link href="https://beefyheisenberg.github.io/51.Productivity/%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%EF%BC%9A%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    <id>https://beefyheisenberg.github.io/51.Productivity/%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%EF%BC%9A%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</id>
    <published>2023-04-28T00:14:17.752Z</published>
    <updated>2023-04-28T00:14:17.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://sspai.com/post/65630" target="_blank" rel="noopener">从富兰克林到 2021，他们都在工程化自己的习惯 - 少数派</a></li><li><a href="http://www.tywiki.com/index.php/%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">富兰克林的自我修炼方法 - 通约智库</a></li></ul><h2 id="富兰克林的行为准则和习惯培养"><a href="#富兰克林的行为准则和习惯培养" class="headerlink" title="富兰克林的行为准则和习惯培养"></a>富兰克林的行为准则和习惯培养</h2><p>《本杰明·富兰克林自传》中写到，人的习惯的惰性总是于人不备时乘虚而入，而人们的习性往往强于理智。这是习惯的 2 个特性，既能击败自己又能帮助自己。坏的习惯必须打破，好的习惯必须加以培养。富兰克林的树立目标就是不断增多好的习惯，减少坏的习惯，在更大范围内寻求最佳结果。</p><p>为了实现这一目标，他拟定了方法，给自己设定了 13 个戒律，带着道德层面完善自己的心态出发，制定养成习惯的关键性的行为。他认为培养习惯的时候应该循序渐进，看哪一个习惯是哪一个习惯的基石，一个周期培养一次。</p><ul><li>一、节制。食不过饱；饮酒不醉。</li><li>二、沉默寡言。言必于人于己有益；避免无益的聊天。</li><li>三、生活秩序。每一样东西应有一定的安放的地方；每件日常事务当有一定的时间。</li><li>四、决心。当做必做；决心要做的事应坚持不懈。</li><li>五、俭朴。用钱必须于人或于己有益，换言之，切戒浪费。</li><li>六、勤勉。不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动。</li><li>七、诚恳。不欺骗人；思想要纯洁公正；说话也要如此。</li><li>八、公正。不做不利于人的事，不要忘记履行对人有益而又是你应尽的义务。</li><li>九、中庸适度。避免极端；人若给你应得处罚，你当容忍之。</li><li>十、清洁。身体、衣服和住所力求清洁。</li><li>十一、镇静。勿因小事或普通的不可避免的事故而惊慌失措。</li><li>十二、贞节。除了为了健康或生育后代起见，不常举行房事，切戒房事过度，伤害身体或损害你自己或他人的安宁或名誉。</li><li>十三、谦虚。仿效耶稣和苏格拉底。</li></ul><p>在循序渐进列出习惯的具体方法之后，他又想到毕达哥拉斯《黄金诗篇》里提出的忠告，有必要逐日对自己的行为进行反省，这样才能优化整个系统，就像生物新陈代谢一样能适应环境变化更好的生存下去。于是他想到设计了一个用表格的形式来检查习惯的方法。</p><p><img src="/images/2022/20220228214928.png" alt=""></p><p>每一列是一种塑造美德的习惯，每一行是这个星期的一天。每天检查自己的所作所为，如果违反了哪几项习惯，就在相应的格子中打上小黑点。<br>他决心照此顺序对每一种习惯进行一星期的严密监控。这样，第一周特别注意避免发生任何违反「节制」 的行为，而对另外的只能是一般的关注，只是每天晚上就这一天的错误做上标记。<br>假如第一个星期，能够使标有节制的一行里没有黑点，就认为对这一习惯已经加强，与它相反的陋习已经大为削弱。如果达到这种程度，就将注意力扩展到下面的一项，争取在下一周内两行都没有黑点，直到完成最后一项习惯。<br>顺利的话，每过 13 个星期（一个季度）就可以走完一周期，一年可以循环 4 个周期。</p><h2 id="富兰克林的作息表"><a href="#富兰克林的作息表" class="headerlink" title="富兰克林的作息表"></a>富兰克林的作息表</h2><p><img src="/images/2022/20220228213633.png" alt=""></p><h2 id="毕达哥拉斯-金诗"><a href="#毕达哥拉斯-金诗" class="headerlink" title="毕达哥拉斯-金诗"></a>毕达哥拉斯-金诗</h2><p>被归到毕达哥拉斯名下的著名的《金诗》（或译《黄金韵文》）可能并不是毕达哥拉斯所创作的，正如多数批评家所说的那样，但是，这些诗句包含了毕达哥拉斯哲学的摘要，它以和谐、优美和简洁的形式清楚地阐述了他的主要训诫。如果这些训诫得到实践，那么结果会在人生中导致一种道德和理智上的革新，这会带给人类不可估量的益处。《金诗》已经被广泛编辑和翻译成多种语言。</p><ul><li><a href="https://en.wikipedia.org/wiki/Golden_Verses" target="_blank" rel="noopener">Golden Verses - Wikipedia</a></li><li>《金诗》中文翻译： <a href="https://www.douban.com/group/topic/31694245/?_i=0245217kQHWhAK" target="_blank" rel="noopener">https://www.douban.com/group/topic/31694245/?_i=0245217kQHWhAK</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sspai.com/post/65630&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从富兰克林到 2021，他们都在工程化自己的习惯 - 少数派&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.tywiki.com/index.php/%E5%AF%8C%E5%85%B0%E5%85%8B%E6%9E%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E7%82%BC%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;富兰克林的自我修炼方法 - 通约智库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;富兰克林的行为准则和习惯培养&quot;&gt;&lt;a href=&quot;#富兰克林的行为准则和习惯培养&quot; class=&quot;headerlink&quot; title=&quot;富兰克林的行为准则和习惯培养&quot;&gt;&lt;/a&gt;富兰克林的行为准则和习惯培养&lt;/h2&gt;&lt;p&gt;《本杰明·富兰克林自传》中写到，人的习惯的惰性总是于人不备时乘虚而入，而人们的习性往往强于理智。这是习惯的 2 个特性，既能击败自己又能帮助自己。坏的习惯必须打破，好的习惯必须加以培养。富兰克林的树立目标就是不断增多好的习惯，减少坏的习惯，在更大范围内寻求最佳结果。&lt;/p&gt;
&lt;p&gt;为了实现这一目标，他拟定了方法，给自己设定了 13 个戒律，带着道德层面完善自己的心态出发，制定养成习惯的关键性的行为。他认为培养习惯的时候应该循序渐进，看哪一个习惯是哪一个习惯的基石，一个周期培养一次。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一、节制。食不过饱；饮酒不醉。&lt;/li&gt;
&lt;li&gt;二、沉默寡言。言必于人于己有益；避免无益的聊天。&lt;/li&gt;
&lt;li&gt;三、生活秩序。每一样东西应有一定的安放的地方；每件日常事务当有一定的时间。&lt;/li&gt;
&lt;li&gt;四、决心。当做必做；决心要做的事应坚持不懈。&lt;/li&gt;
&lt;li&gt;五、俭朴。用钱必须于人或于己有益，换言之，切戒浪费。&lt;/li&gt;
&lt;li&gt;六、勤勉。不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动。&lt;/li&gt;
&lt;li&gt;七、诚恳。不欺骗人；思想要纯洁公正；说话也要如此。&lt;/li&gt;
&lt;li&gt;八、公正。不做不利于人的事，不要忘记履行对人有益而又是你应尽的义务。&lt;/li&gt;
&lt;li&gt;九、中庸适度。避免极端；人若给你应得处罚，你当容忍之。&lt;/li&gt;
&lt;li&gt;十、清洁。身体、衣服和住所力求清洁。&lt;/li&gt;
&lt;li&gt;十一、镇静。勿因小事或普通的不可避免的事故而惊慌失措。&lt;/li&gt;
&lt;li&gt;十二、贞节。除了为了健康或生育后代起见，不常举行房事，切戒房事过度，伤害身体或损害你自己或他人的安宁或名誉。&lt;/li&gt;
&lt;li&gt;十三、谦虚。仿效耶稣和苏格拉底。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="51.Productivity" scheme="https://beefyheisenberg.github.io/categories/51-Productivity/"/>
    
    
    <category term="习惯" scheme="https://beefyheisenberg.github.io/tags/习惯/"/>
    
    <category term="富兰克林" scheme="https://beefyheisenberg.github.io/tags/富兰克林/"/>
    
    <category term="毕达哥拉斯" scheme="https://beefyheisenberg.github.io/tags/毕达哥拉斯/"/>
    
  </entry>
  
  <entry>
    <title>开始使用Obsidian</title>
    <link href="https://beefyheisenberg.github.io/51.Productivity/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Obsidian/"/>
    <id>https://beefyheisenberg.github.io/51.Productivity/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Obsidian/</id>
    <published>2023-04-28T00:14:17.719Z</published>
    <updated>2023-04-28T00:14:17.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h2><ul><li>特性介绍: <a href="https://obsidian.md/features" target="_blank" rel="noopener">Features - Obsidian</a></li><li>版本发布: <a href="https://forum.obsidian.md/c/announcements/13" target="_blank" rel="noopener">Latest Announcements topics - Obsidian Forum</a></li><li>Feature requests: <a href="https://forum.obsidian.md/c/feature-requests/8" target="_blank" rel="noopener">Latest Feature requests topics - Obsidian Forum</a></li></ul><h2 id="Vault（库）"><a href="#Vault（库）" class="headerlink" title="Vault（库）"></a>Vault（库）</h2><p>每个vault下有单独的.obsidian文件夹:</p><ul><li><code>.obsidian/thems/</code>:   CSS主题目录</li><li><code>.obsidian/snippets/</code>: CSS代码片段目录</li><li><code>.obsidian/config</code>:</li><li><code>.obsidian/workspace</code>:</li></ul><blockquote><p>For example YourOwnVault/.obsidian/.trash is the trash folder<br>YourOwnVault/.obsidian/config stores things like your own custom hotkeys<br>YourOwnVault/.obsidian/workspace saves things like the most recent files, and the window layout (I think).</p></blockquote><p>App系统文件夹:</p><ul><li>macOS: <code>~/Library/Application\ Support/obsidian</code>, 文件缓存在<code>ObsidianCache/</code> 和 <code>IndexedDB/</code></li><li>Win: <code>%APPDATA%\Obsidian\</code></li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li><a href="https://github.com/zsviczian/obsidian-excalidraw-plugin" target="_blank" rel="noopener">zsviczian/obsidian-excalidraw-plugin: A plugin to edit and view Excalidraw drawings in Obsidian</a>: The Obsidian-Excalidraw plugin integrates Excalidraw, a feature rich sketching tool. You can store and edit Excalidraw files in your vault, you can embed drawings into your documents, and you can link to documents and other drawings to/and from Excalidraw</li><li><a href="https://github.com/shichongrui/obsidian-reveal-active-file" target="_blank" rel="noopener">obsidian-reveal-active-file</a>: 打开一个mkd时, 自动在文件树导航到这个文件</li><li><a href="https://github.com/darlal/obsidian-switcher-plus" target="_blank" rel="noopener">obsidian-switcher-plus</a>: 类似Sublime的Symbol搜索, 自定义快捷键<code>Cmd</code>+<code>R</code>, 呼出搜索框，直接是文件名模糊搜索， 输入<code>@</code>触发当前文件内搜索Heading, 输入<code>#</code>触发全库内搜索Heading</li><li><a href="https://github.com/lynchjames/obsidian-mind-map" target="_blank" rel="noopener">obsidian-mind-map</a>: 为当前笔记生成 mind map</li><li><a href="https://github.com/tgrosinger/advanced-tables-obsidian" target="_blank" rel="noopener">advanced-tables-obsidian</a>: 表格编辑, 输入<code>|</code>就可以进入表格编辑, 按<code>Tab</code>编辑下一个表格的内容</li><li><a href="https://github.com/platers/obsidian-linter" target="_blank" rel="noopener">obsidian-linter</a>: 格式化md文件, 更新yaml头</li><li><a href="https://github.com/OliverBalfour/obsidian-pandoc" target="_blank" rel="noopener">OliverBalfour/obsidian-pandoc: Pandoc document export plugin for Obsidian (https://obsidian.md)</a>: 导出为pdf、doc、html等格式</li><li><a href="https://github.com/obsidian-html/obsidian-html" target="_blank" rel="noopener">Obsidian-Html</a>: 将Obsidian笔记导出为网站html, 网站样例: <a href="https://obsidian-html.github.io/?path=%2FInstructions%2FUsage.html/" target="_blank" rel="noopener">https://obsidian-html.github.io/?path=%2FInstructions%2FUsage.html/</a></li><li><a href="https://github.com/liamcain/obsidian-calendar-plugin" target="_blank" rel="noopener">obsidian-calendar-plugin</a>: 给Obs增加一个日历widget用以显示每天的笔记, 依赖于Obs的Core插件<code>Daily Note</code>, 是按照mkd的文件名区分日期的, 对于我来说大部分mkd文件都不是日期命名所以也没多大用处, 希望能改成通过yaml头或者文件modify属性识别日期</li><li><a href="https://silentvoid13.github.io/Templater/introduction.html" target="_blank" rel="noopener">Templater</a>： 更好的模板管理</li><li><a href="https://github.com/Yaozhuwa/easy-typing-obsidian" target="_blank" rel="noopener">easy-typing-obsidian</a>：自动格式化 md</li><li><a href="https://github.com/agathauy/wikilinks-to-mdlinks-obsidian" target="_blank" rel="noopener">wikilinks-to-mdlinks-obsidian</a>：Obsidian 默认的附件（PDF or 贴图）都是 <code>[[ ]]</code>，这种图片格式在其他支持 mkd 的笔记、以及 Hexo 博客里并不支持，这个插件可以一键切换 <code>[[ ]]</code> 和 <code>![]()</code> 两种 link 格式</li><li><a href="https://github.com/reorx/obsidian-paste-image-rename" target="_blank" rel="noopener">obsidian-paste-image-rename:</a>：Obsidian 的贴图自动命名为“pasted image 日期” 这种带空格的格式，对 URL 显示并不友好，这个插件可以自动按规则重命名图片文件，支持 <code>dirName</code> 、<code>fileName</code>、<code>date</code> 等变量；</li><li><a href="https://github.com/guopenghui/obsidian-quiet-outline" target="_blank" rel="noopener">Quiet Outline</a>：更好的显示文件大纲（outline）</li></ul><h2 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h2><ul><li><a href="https://github.com/whyt-byte/Blue-Topaz_Obsidian-css" target="_blank" rel="noopener">whyt-byte/Blue-Topaz_Obsidian-css: A blue theme for Obsidian.</a></li><li><a href="https://github.com/mediapathic/obsidian-arsmagna-theme" target="_blank" rel="noopener">mediapathic/obsidian-arsmagna-theme: A theme for Obsidian, inspired by the works of Athanasius Kircher</a></li><li><a href="https://github.com/kepano/obsidian-minimal" target="_blank" rel="noopener">kepano/obsidian-minimal: Minimal theme for Obsidian</a></li></ul><h2 id="CSS-Snippets"><a href="#CSS-Snippets" class="headerlink" title="CSS Snippets"></a>CSS Snippets</h2><p>CSS Snippets 可以载入自定义CSS， 自定义 Obsidian 的外观，例如自定 Heading 的显示样式..</p><p>在 <code>设置 =&gt; 外观 =&gt; CSS 代码片段</code> 管理，</p><p>更多可用的 Snippet可以在这里找到： <a href="https://github.com/deathau/obsidian-snippets" target="_blank" rel="noopener">https://github.com/deathau/obsidian-snippets</a></p><h2 id="YAML-front-matter"><a href="#YAML-front-matter" class="headerlink" title="YAML front matter"></a>YAML front matter</h2><p>由于 Markdown 官方标准不支持存储 metadata（例如笔记更新日期、分类等），所以 Obsidian 通过支持 YAML front matter 来解决，目前受 Obsidian 支持的有：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aliases:</span> <span class="string">[别名1,</span> <span class="string">别名2]</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">publish:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>title</code>不是官方支持的属性…</li><li><code>aliases</code> 必须在第一行，</li></ul><p>@ref: <a href="https://help.obsidian.md/Advanced+topics/YAML+front+matter" target="_blank" rel="noopener">https://help.obsidian.md/Advanced+topics/YAML+front+matter</a></p><h2 id="标注（callout）"><a href="#标注（callout）" class="headerlink" title="标注（callout）"></a>标注（callout）</h2><p>在标准 Markdown GFM 规范中，对于“标注框”都没有明确的定义。因此关于标注框这件事，各家都是采用各自的语法来实现，不同语法之间互不通用。<br>标注框有点类似 Markdown 中的 <code>&gt;</code> 引言块，但更加醒目。往往用于诸如提示、警告之类的用途，也经常被称为“谏言块”（admonition）。</p><p>Obsidian 在引用块上加了一些特殊的语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; [!标注类型]</span><br><span class="line">&gt; 这里是标注内容...</span><br></pre></td></tr></table></figure><p>支持的“标注类型”有：info 、tip、warning、note、todo、question、danger、bug 等，不同的标注类型，渲染出的 icon 和背景色不同：</p><blockquote><p>[!warning]<br>这是一个警告标注</p></blockquote><h2 id="快捷键（含自定义）"><a href="#快捷键（含自定义）" class="headerlink" title="快捷键（含自定义）"></a>快捷键（含自定义）</h2><ul><li>快速打开：<code>cmd + O</code></li><li>命令面板：<code>cmd + P</code></li><li>编辑/预览: <code>cmd + E</code></li><li>插件-Advanced Tables插入表格： 按<code>|</code>，再按<code>Tab</code></li><li>插件-Linter 格式化当前文件： <code>cmd + alt + L</code></li><li>插件-Quick Switcher： <code>cmd + R</code>，再按<code>#</code>进入 Heading 搜索</li><li>插件-Templater 插入YAML（自定义）：<code>cmd + shift + Y</code></li><li>返回：<code>cmd + alt + ←</code></li><li>访问光标处的链接： <code>alt + Enter</code></li><li>播放关系图谱生长动画： <code>cmd + shift + P</code></li><li>查看关系图谱： <code>cmd + G</code></li><li>查看局部关系图谱： <code>cmd + shift + G</code></li></ul><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><p>进入调试模式快捷键： <code>option-cmd-i</code>（或 <code>Ctrl+shift+I</code> for Win）</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li><a href="https://help.obsidian.md/Advanced+topics/Using+obsidian+URI" target="_blank" rel="noopener">Using obsidian URI</a></li><li><a href="https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter" target="_blank" rel="noopener">YAML front matter</a></li><li><a href="https://help.obsidian.md/How+to/Add+aliases+to+note" target="_blank" rel="noopener">Add aliases to note</a></li><li><a href="https://help.obsidian.md/How+to/Link+to+blocks" target="_blank" rel="noopener">Link to blocks</a></li><li><a href="https://help.obsidian.md/How+to/Internal+link" target="_blank" rel="noopener">Link to headings</a></li><li><a href="https://help.obsidian.md/Plugins/Workspaces" target="_blank" rel="noopener">Workspace</a></li><li><a href="https://help.obsidian.md/How+to/Add+custom+styles" target="_blank" rel="noopener">添加自定义CSS</a></li></ul><h2 id="问题-amp-feature-requests"><a href="#问题-amp-feature-requests" class="headerlink" title="问题 &amp; feature requests"></a>问题 &amp; feature requests</h2><ul><li>在 Graph View使用H1标题替代 filename<ul><li><a href="https://forum.obsidian.md/t/show-title-of-zettelkasten-notes-in-graph-view/683" target="_blank" rel="noopener">https://forum.obsidian.md/t/show-title-of-zettelkasten-notes-in-graph-view/683</a></li><li><a href="https://forum.obsidian.md/t/use-h1-or-front-matter-title-instead-of-or-in-addition-to-filename-as-display-name/687" target="_blank" rel="noopener">https://forum.obsidian.md/t/use-h1-or-front-matter-title-instead-of-or-in-addition-to-filename-as-display-name/687</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;有用的链接&quot;&gt;&lt;a href=&quot;#有用的链接&quot; class=&quot;headerlink&quot; title=&quot;有用的链接&quot;&gt;&lt;/a&gt;有用的链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;特性介绍: &lt;a href=&quot;https://obsidian.md/features&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Features - Obsidian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;版本发布: &lt;a href=&quot;https://forum.obsidian.md/c/announcements/13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Latest Announcements topics - Obsidian Forum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Feature requests: &lt;a href=&quot;https://forum.obsidian.md/c/feature-requests/8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Latest Feature requests topics - Obsidian Forum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Vault（库）&quot;&gt;&lt;a href=&quot;#Vault（库）&quot; class=&quot;headerlink&quot; title=&quot;Vault（库）&quot;&gt;&lt;/a&gt;Vault（库）&lt;/h2&gt;&lt;p&gt;每个vault下有单独的.obsidian文件夹:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.obsidian/thems/&lt;/code&gt;:   CSS主题目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.obsidian/snippets/&lt;/code&gt;: CSS代码片段目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.obsidian/config&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.obsidian/workspace&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="51.Productivity" scheme="https://beefyheisenberg.github.io/categories/51-Productivity/"/>
    
    
    <category term="生产力" scheme="https://beefyheisenberg.github.io/tags/生产力/"/>
    
    <category term="知识管理" scheme="https://beefyheisenberg.github.io/tags/知识管理/"/>
    
    <category term="PKM" scheme="https://beefyheisenberg.github.io/tags/PKM/"/>
    
    <category term="笔记" scheme="https://beefyheisenberg.github.io/tags/笔记/"/>
    
  </entry>
  
  <entry>
    <title>TaskPaper</title>
    <link href="https://beefyheisenberg.github.io/51.Productivity/TaskPaper/"/>
    <id>https://beefyheisenberg.github.io/51.Productivity/TaskPaper/</id>
    <published>2023-04-28T00:14:17.701Z</published>
    <updated>2023-04-28T00:14:17.701Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>TaskPaper is a plain-text to-do list that’s surprisingly adept. Thoroughly modernized. TaskPaper 3 is all new, while still retaining the same plain-text design that’s been getting things done since 2006. What’s New in 3 All new app More powerful searches Flexible and unique folding interface More powerful text editor and outliner Saved searches; one click away in sidebar Relative date and time based searches LESS/CSS powered themes Extensive Javascript API Key Features Plain text files; edit anywhere Type and your lists are auto formatted Projects- tasks, notes, and @tags Text editor speed with outliner power Lists within lists within lists Fold, focus, and filter to make big list small Drag and drop to organize your list Fully scriptable and themable Getting things done since 2006</p></blockquote><p>TaskPaper 是一款基于纯文本的 Todo 应用，它有一个 “看起来像个文本编辑器”的 GUI，实际上它的存储格式也是纯文本。官网 <a href="https://www.taskpaper.com/" target="_blank" rel="noopener">TaskPaper – Plain text to-do lists for Mac</a></p><p><img src="/images/TaskPaper-GUI.png" alt="../_images/TaskPaper-GUI.png"></p><p>也正是因为纯文本，Taskpaper 的存储文件可以用 dropbox &amp; iCloud 同步，用你喜欢的任意的文本编辑器来编辑。</p><p>iOS 上的 Mkd 编辑器 Editorial 支持高亮 <code>.taskpaper</code> 格式的文件；<br>Atom 上也有一些第三方制作的主题，可以高亮 taskpaper 的语法 <a href="https://github.com/jasonshanks/TaskPaper-Atom-One-Dark" target="_blank" rel="noopener">GitHub - jasonshanks/TaskPaper-Atom-One-Dark: v2 of a theme for TaskPaper 3 by pslobo and inspired by Atom One Dark Syntax</a>；</p><p>下面是 taskpaper 文本格式的例子：</p><hr><p>TaskPaper Mode:<br>Editorial supports the .taskpaper plain text todo list format, invented by Jesse Grosjean of Hog Bay Software (see <a href="http://hogbaysoftware.com/products/taskpaper" target="_blank" rel="noopener">http://hogbaysoftware.com/products/taskpaper</a> ).</p><p><strong>（一）添加一个 task，就像 markdown 里的一行列表一样</strong><br>The TaskPaper “markup” is very simple: To create a task, just start a line with a dash and a following space. </p><ul><li>This is a task<br>Editorial automatically shows a checkbox instead of the dash, but the file is still saved as plain text, and you can open it in any other editor. </li></ul><p><strong>（二）用 “@tag” 这样的语法给一个任务加标签，这有点像 Java 里的注解语法，例如“@done”表示完成的任务，此外 Taskpaper 支持@due、@flagged 和@today 等标签</strong><br>Tasks can be tagged, using the <code>@</code> symbol. </p><ul><li>Another task @home<br>The special <code>@done</code> tag is used to mark finished tasks.</li><li>A finished task @done(2015-02-21)<br>(Tags can contain additional information, like the completion date in parentheses.)<br>You can quickly add or remove the <code>@done</code> tag by tapping the checkbox.</li></ul><p><strong>（三）如果一行用 “项目名:”开头，表示下面的 task 都是属于该项目的，缩进 2 空格表示子项目</strong><br>To insert a project header, simply type a line that ends with a colon (‘:’). Everything that isn’t a task or project header is considered a note. </p><p>Color Labels:<br>In Editorial’s settings, you can associate tags with color labels. Some tags, like @due, @flagged, and @today have default colors, but you can easily change this.</p><ul><li>This task should be blue  @today</li><li>This one is red @flagged @done(2018-12-17)</li></ul><p>Tips:</p><ul><li>You can rearrange tasks by dragging the right margin (tap and hold the gray box).</li><li>Tap the triangle next to a project header to hide (“fold”) its content. The label next to a folded project shows the number of tasks that are hidden.</li></ul><p>Project:<br>  Project2:</p><hr><p><a href="https://sspai.com/post/42136" target="_blank" rel="noopener">序章 | TaskPaper 原理 - 少数派</a></p><blockquote><p>和你一样，有个外国的小伙子也想要一款称心的任务管理工具。<br>他曾打算做一款「完美的信息管理应用（Mori）」，但他自己尚不能满意这个工具；最后他卖掉了 Mori，用纯文本来记录任务。为了让自己的任务列表保持有序、便于管理，他开始为之添加最简单基本的结构——不破坏这一点的前提下，不断丰富这一系统，最后我们看到了 TaskPaper。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;TaskPaper is a plain-text to-do list that’s surprisingly adept. Thoroughly modernized. TaskPaper 3 is all new, while still retaining the same plain-text design that’s been getting things done since 2006. What’s New in 3 All new app More powerful searches Flexible and unique folding interface More powerful text editor and outliner Saved searches; one click away in sidebar Relative date and time based searches LESS/CSS powered themes Extensive Javascript API Key Features Plain text files; edit anywhere Type and your lists are auto formatted Projects- tasks, notes, and @tags Text editor speed with outliner power Lists within lists within lists Fold, focus, and filter to make big list small Drag and drop to organize your list Fully scriptable and themable Getting things done since 2006&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TaskPaper 是一款基于纯文本的 Todo 应用，它有一个 “看起来像个文本编辑器”的 GUI，实际上它的存储格式也是纯文本。官网 &lt;a href=&quot;https://www.taskpaper.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TaskPaper – Plain text to-do lists for Mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/TaskPaper-GUI.png&quot; alt=&quot;../_images/TaskPaper-GUI.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;也正是因为纯文本，Taskpaper 的存储文件可以用 dropbox &amp;amp; iCloud 同步，用你喜欢的任意的文本编辑器来编辑。&lt;/p&gt;
&lt;p&gt;iOS 上的 Mkd 编辑器 Editorial 支持高亮 &lt;code&gt;.taskpaper&lt;/code&gt; 格式的文件；&lt;br&gt;Atom 上也有一些第三方制作的主题，可以高亮 taskpaper 的语法 &lt;a href=&quot;https://github.com/jasonshanks/TaskPaper-Atom-One-Dark&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub - jasonshanks/TaskPaper-Atom-One-Dark: v2 of a theme for TaskPaper 3 by pslobo and inspired by Atom One Dark Syntax&lt;/a&gt;；&lt;/p&gt;</summary>
    
    
    
    <category term="51.Productivity" scheme="https://beefyheisenberg.github.io/categories/51-Productivity/"/>
    
    
    <category term="GTD" scheme="https://beefyheisenberg.github.io/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>PKM.笔记分类法.PARA-and-IARP</title>
    <link href="https://beefyheisenberg.github.io/51.Productivity/PKM.%E7%AC%94%E8%AE%B0%E5%88%86%E7%B1%BB%E6%B3%95.PARA-and-IARP/"/>
    <id>https://beefyheisenberg.github.io/51.Productivity/PKM.%E7%AC%94%E8%AE%B0%E5%88%86%E7%B1%BB%E6%B3%95.PARA-and-IARP/</id>
    <published>2023-04-28T00:14:17.690Z</published>
    <updated>2023-04-28T00:14:17.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P-A-R-A"><a href="#P-A-R-A" class="headerlink" title="P.A.R.A"></a>P.A.R.A</h2><p>P.A.R.A 是一个通用且简单的数字资料分类方法</p><p><img src="/images/2022/20220311142045.png" alt=""></p><p>一个好的个人知识管理体系，应该可以支持并帮助你的工作，它应该让你在放置信息时准确知道放置的位置，以及在需要信息时能准确查找到信息的位置。</p><p>这个系统应该有如下特点：</p><ul><li>通用，能涵盖任何来源的任何信息</li><li>灵活，能够处理各种现在在做的和将来要做的项目和活动。</li><li>简单，无需超出最低要求的任何耗时维护、编目、标记或重新整理</li><li>可操作，与任务管理和项目管理方法无缝集成</li><li>跨平台，可与任何应用程序一起使用，包括已存应用在或未来的应用</li><li>以结果为导向，以支持交付有价值的工作为目的来构建信息</li><li>模块化，允许根据当前任务的需求隐藏或揭示不同级别的细节</li><li>机会主义，最好能够在已经完成的工作的基础上进行，而不是占用额外时间。</li></ul><p>P.A.R.A. 代表<strong>项目（Projects）— 领域(Areas) — 资源(Resources) — 档案(Archives)</strong>，四个顶级类别， 包括您在工作和生活中可能遇到的每种类型的信息。</p><ul><li>P：Project，有目标、有交付日期、会结束</li><li>A：Area of responsibility，是”需要一直负责和维护的活动领域”, 例如工作中需要持续关注的领域, 或者打算持续发展兴趣（健康/写作/营销等）</li><li>R：Resource，是”持续感兴趣的话题或主题”</li><li>A：Archive，存档，示例包括：已完成或非活动的项目;不再承诺维护的Areas;不再感兴趣的resources</li></ul><p><em>Area与Project</em>：<br>二者的区别是，项目有DDL或明确的结束的日期而Area没有，Project的里更多属于”可操作的”, Area里更多的是”不可操作的信息”。二者的联系：项目总是属于一个领域，例如:</p><ul><li>参加马拉松是一个项目，而健康是一个领域</li><li>出版一本书是一个项目，而写作是一个领域</li></ul><p><em>Area与Resource</em>:<br>Area（注意是 Are of responsibility）, 是您在生活中扮演的角色和您所负责的职位（配偶、母亲/父亲、团队负责人、足球教练）、您承担责任的现行标准（产品开发、公司通讯、法律），以及需要持续关注的事情（锻炼、财务、公寓、宠物）。Area 强调的是需要”负责的领域”，而Resource仅仅是”感兴趣的主题”, 这是二者的主要区分点。Resource 里可以是任何感兴趣的主题的文章、资料甚至代码片段。<br>另外作者还提到自己私人信息也会放入Area，这样可以随时放心的分享Resource，例如体检报告、就诊记录放在名为“健康”的Area中，而Resource中存放的是运动、健康的有趣文章或者推荐的训练方案。</p><p>@ref:</p><ul><li><a href="https://fortelabs.com/blog/para/" target="_blank" rel="noopener">The PARA Method: A Universal System for Organizing Digital Information - Forte Labs</a></li><li><a href="https://fortelabs.com/blog/p-a-r-a-ii-operations-manual/" target="_blank" rel="noopener">PARA Part 2: Operations Manual - Forte Labs</a></li><li><a href="https://sspai.com/post/61459" target="_blank" rel="noopener">P.A.R.A. 是什么及在 Notion 中的应用 - 少数派</a></li></ul><h2 id="I-A-R-P"><a href="#I-A-R-P" class="headerlink" title="I.A.R.P"></a>I.A.R.P</h2><p>I.A.R.P 是一组缩写，即：</p><ul><li>Inbox（收件箱）：我会将所有临时性的，还未消化的内容放置于此，定期来进行归档、整理或者删除。可以当做大脑的缓存，避免记录的时候纠结放在哪里。</li><li>Area（领域）：这是最重要的概念，即日常你需要精进的「领域」，比如健康就是一个领域，而跑步则是项目；写作是一个领域，而写一篇公众号文章则是一个项目；</li><li>Resource（资源）：对应到卢曼的 Zettelkasten 方法中，更像是永久笔记。一般来说是兴趣、主题、资产等内容。注意是自己消化过的内容，而非机械的收藏。</li><li>Project（项目）：是指一个将要发生的独立事件，并且这个事件不是一次性就能完成的，至少需要多个动作才能完成。比如要写一本书，需要整理资料，罗列提纲，撰写内容，联系出版社。类似生活中还有组织一次旅游，录制一期播客等。</li></ul><p>这里面最难的其实是 Area（领域） ，即你最关注的领域是什么。我们的一生中由许多事件构成。只是对于大多数人来说，他们其实并没有一个关于自己生活和工作的完整的项目清单。但是他们却会告诉你，有太多的事情要做。当这样忙忙碌碌多年以后，其实发现自己可能做了许多事，但是却「样样稀松」。这就是只有项目，而缺乏 Area（领域）聚焦带来的问题。</p><p>@ref:</p><ul><li>I.A.R.P: <a href="https://help.flomoapp.com/thinking/iarp.html" target="_blank" rel="noopener">https://help.flomoapp.com/thinking/iarp.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;P-A-R-A&quot;&gt;&lt;a href=&quot;#P-A-R-A&quot; class=&quot;headerlink&quot; title=&quot;P.A.R.A&quot;&gt;&lt;/a&gt;P.A.R.A&lt;/h2&gt;&lt;p&gt;P.A.R.A 是一个通用且简单的数字资料分类方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2022/20220311142045.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;一个好的个人知识管理体系，应该可以支持并帮助你的工作，它应该让你在放置信息时准确知道放置的位置，以及在需要信息时能准确查找到信息的位置。&lt;/p&gt;
&lt;p&gt;这个系统应该有如下特点：&lt;/p&gt;</summary>
    
    
    
    <category term="51.Productivity" scheme="https://beefyheisenberg.github.io/categories/51-Productivity/"/>
    
    
    <category term="生产力" scheme="https://beefyheisenberg.github.io/tags/生产力/"/>
    
    <category term="知识管理" scheme="https://beefyheisenberg.github.io/tags/知识管理/"/>
    
    <category term="PKM" scheme="https://beefyheisenberg.github.io/tags/PKM/"/>
    
    <category term="笔记" scheme="https://beefyheisenberg.github.io/tags/笔记/"/>
    
    <category term="分类法" scheme="https://beefyheisenberg.github.io/tags/分类法/"/>
    
  </entry>
  
  <entry>
    <title>PKM.笔记分类法.ACCESS</title>
    <link href="https://beefyheisenberg.github.io/51.Productivity/PKM.%E7%AC%94%E8%AE%B0%E5%88%86%E7%B1%BB%E6%B3%95.ACCESS/"/>
    <id>https://beefyheisenberg.github.io/51.Productivity/PKM.%E7%AC%94%E8%AE%B0%E5%88%86%E7%B1%BB%E6%B3%95.ACCESS/</id>
    <published>2023-04-28T00:14:17.685Z</published>
    <updated>2023-04-28T00:14:17.686Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=p0zWJ-TLghw&amp;t=459s&amp;ab_channel=LinkingYourThinking" target="_blank" rel="noopener">Folders or Links? The key to both is A.C.C.E.S.S. - YouTube</a></p><blockquote><p>Folders &amp; links can work together—not as an afterthought—but as a fundamental part of the design. A.C.C.E.S.S. helps you achieve a system to manage knowledge—and action—in the digital age.</p></blockquote><p>视频中 Nick Milo 提出的 <strong>A.C.C.E.S.S. 笔记组织法</strong>：</p><p>（1） Atlas，通常是笔记的 MOC（map of contents）/Dashboard/Overview 等… 作用：为笔记提供一个鸟瞰图，Maps to your world of knowledge</p><p>（2） Calender，时间轴的视角（time-based），通常是每日笔记/会议纪要/计划(plan)/Review(回顾)/Journals 等… 作用：作为一种日志（Log）追踪 &amp; 回顾曾经感兴趣的（笔记）</p><p>（3） Card，通常是 Ideas/Things/People/概念/状态等…  </p><p>（4） Extras，支持材料，通常是笔记附件/图片/手册/模板…</p><p>（5） Source，资源，文章/书籍/论文/在线课程/Talks…</p><p>（6） Space，空间，通常是一个“领域”，例如 Life/Work… 每个空间下又按“M.A.P.S”分类（maps、areas、project、support note）</p><p>Nick Milo 还发布了一个 Obsidian 库来阐述 A.C.C.E.S.S. 的使用：</p><p><a href="https://forum.obsidian.md/t/lyt-kit-7-new-version-sep-13th/390" target="_blank" rel="noopener">LYT Kit 7 - NEW Version Sep 13th! - Share &amp; showcase - Obsidian Forum</a></p><blockquote><p>About LYT<br>If you want to take notes that compound in value over your lifetime, it’s not enough to rely solely on direct links, tags, and folders. In the Age of the [[Linked]] Note, we have access to powerful thinking tools. The LYT System explores how to use Fluid Frameworks like MOCs (Maps of Content) and a Home note to elevate your thinking today—and years from now.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=p0zWJ-TLghw&amp;amp;t=459s&amp;amp;ab_channel=LinkingYourThinking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Folders or Links? The key to both is A.C.C.E.S.S. - YouTube&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Folders &amp;amp; links can work together—not as an afterthought—but as a fundamental part of the design. A.C.C.E.S.S. helps you achieve a system to manage knowledge—and action—in the digital age.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;视频中 Nick Milo 提出的 &lt;strong&gt;A.C.C.E.S.S. 笔记组织法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;（1） Atlas，通常是笔记的 MOC（map of contents）/Dashboard/Overview 等… 作用：为笔记提供一个鸟瞰图，Maps to your world of knowledge&lt;/p&gt;
&lt;p&gt;（2） Calender，时间轴的视角（time-based），通常是每日笔记/会议纪要/计划(plan)/Review(回顾)/Journals 等… 作用：作为一种日志（Log）追踪 &amp;amp; 回顾曾经感兴趣的（笔记）&lt;/p&gt;</summary>
    
    
    
    <category term="51.Productivity" scheme="https://beefyheisenberg.github.io/categories/51-Productivity/"/>
    
    
    <category term="生产力" scheme="https://beefyheisenberg.github.io/tags/生产力/"/>
    
    <category term="知识管理" scheme="https://beefyheisenberg.github.io/tags/知识管理/"/>
    
    <category term="PKM" scheme="https://beefyheisenberg.github.io/tags/PKM/"/>
    
    <category term="笔记" scheme="https://beefyheisenberg.github.io/tags/笔记/"/>
    
    <category term="分类法" scheme="https://beefyheisenberg.github.io/tags/分类法/"/>
    
  </entry>
  
  <entry>
    <title>容器化-Docker-02容器隔离实现原理</title>
    <link href="https://beefyheisenberg.github.io/31.Backend/%E5%AE%B9%E5%99%A8%E5%8C%96-Docker-02%E5%AE%B9%E5%99%A8%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://beefyheisenberg.github.io/31.Backend/%E5%AE%B9%E5%99%A8%E5%8C%96-Docker-02%E5%AE%B9%E5%99%A8%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-04-28T00:14:17.192Z</published>
    <updated>2023-04-28T00:14:17.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker容器隔离的实现原理"><a href="#Docker容器隔离的实现原理" class="headerlink" title="Docker容器隔离的实现原理"></a>Docker容器隔离的实现原理</h1><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>先认识Linux 提供的Namespace机制: Linux的 Namespace 提供了7种不同的命名空间:</p><ul><li>PID namespace: 隔离进程ID,每个容器有自己的pid命名空间</li><li>UTS namespace: 隔离主机名 &amp; 域名, ….有自己的主机名和NIS域名</li><li>IPC namespace: 隔离进程间通信, 相同IPC Ns的进程之间才可以使用(共享内存/信号量/消息队列)通讯</li><li>MNT namespace: 隔离文件系统挂载点</li><li>…</li></ul><p>Docker 如何实现进程隔离 (宿主机进程 &amp; 容器内进程的隔离) ?</p><ul><li>调用<code>clone</code>创建进程时传入 <code>CLONE_NEWPID</code>, 这样创建出的进程PID和宿主机是隔离的</li><li>下图中, docker containterd 进程就是在clone时指定<code>CLONE_NEWPID</code>创建的, 所以其子进程和宿主机是隔离的: </li></ul><p><img src="/images/docker-container-process.png" alt="docker-container-process"></p><blockquote><p>Linux 两个重要进程: pid=1的init(使用命令<code>ps -p 1</code>可以看到) &amp; pid=2的 kthreadd进程, 前者用于执行一部分内核的初始化和系统配置, 后者负责管理和调度其他内核进程;</p></blockquote><ul><li>Docker 的挂载点隔离的实现:<ul><li>一个容器需要一个rootfs才可以正常启动 (rootfs, 包括/proc, /dev等等..)</li><li>调用<code>clone</code>创建进程时传入 <code>CLONE_NEWNS</code>, 这样子进程就能得到父进程挂载点的拷贝, 如果不传入<code>CLONE_NEWNS</code>这个参数, 子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统</li></ul></li></ul><ul><li>Docker 的网络隔离的实现:<ul><li>Docker 提供了四种网络模式(Host、Container、None 和 Bridge)</li><li>如果是网桥模式, 除了分配网络的Namespace, 还会给容器分配虚拟网卡, 在宿主机安装虚拟网桥, 虚拟网卡和网桥通过iptables连接;</li><li>例如<code>docker run -d -p 6379:6379 redis</code>启动一个容器, 查看 iptables 的 NAT 配置就会看到在 DOCKER 的链中出现了一条新的规则</li></ul></li></ul><p>以上, Docker通过Linux 提供的 Namespace为新创建的进程隔离了 进程ID/网络/文件系统…</p><p>@ref: </p><ul><li>Clone()函数: [[../21.Operating-System/APUE.03a.进程#clone]]</li><li>Namespace: [[../21.Operating-System/APUE.03a.进程#Namespace]]</li></ul><h2 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h2><ul><li><p>Docker 对容器的资源使用限额(CPU/RAM..)是通过 Controll Group (简称 CGroup)实现的:</p><ul><li>创建一个CGroup 并指定其(CPU/RAM等)限额, 实现不同CGroup 之间资源隔离</li><li>进程可以随时加入一个CGroup or 退出</li><li><p>查看当前系统中的CGroup: <code>lssubsys -m</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lssubsys -m</span><br><span class="line">cpuset /sys/fs/cgroup/cpuset</span><br><span class="line">cpu /sys/fs/cgroup/cpu</span><br><span class="line">cpuacct /sys/fs/cgroup/cpuacct</span><br><span class="line">memory /sys/fs/cgroup/memory</span><br></pre></td></tr></table></figure></li><li><p>继续查看 /sys/fs/cgroup/cpu/目录, 下面有个名为docker的文件夹, 再向下层是docker container id命名的目录 </p></li><li>创建一个Docker容器并指定配额: <code>docker run -it -d --cpu-quota=50000 image_tag</code></li></ul></li></ul><p><img src="/images/docker-cgroup.png" alt="docker-cgroup"></p><h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>综上所述, Namespace解决了…, CGroup解决了… , 还有一个文件系统的隔离问题, 是通过UnionFS实现的 (是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务)</p><ul><li>Dockerfile里每一个命令都会创建一个只读层, 当使用<code>docker run</code>命令启动一个容器时, 会在镜像最上层添加一个可写的层(也就是容器层), 容器运行时对容器的修改都是对这个层的修改; </li><li>docker镜像的每一个层, 都对应宿主机/var/lib/docker/ 下面的一个目录</li><li>通过AUFS(Advanced UnionFS) , 把多个文件目录”联合”到同一个挂载点;</li><li>除了AUFS之外, Docker 还支持aufs、devicemapper、overlay2、zfs 和 vfs 等等不同驱动</li><li>通过这种层(layer)    的设计, 不同tag的docker镜像, 可以公用同一个层, 减少了镜像的磁盘占用</li></ul><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Docker 的隔离技术实现的基础: Namespace/CGroup/UnionFS</p><p><img src="/images/docker-fs-layer.png" alt="../_images/docker-fs-layer"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>@ref: </p><ul><li><a href="https://draveness.me/docker/" target="_blank" rel="noopener">Docker 核心技术与实现原理 - 面向信仰编程</a></li></ul><h1 id="Docker运行性能分析"><a href="#Docker运行性能分析" class="headerlink" title="Docker运行性能分析"></a>Docker运行性能分析</h1><ul><li>与虚拟机技术不同, Docker使用Ns和CGroup实现隔离和资源配额控制, 不需要用额外的性能消耗运行vm</li><li>Docker启动的进程和宿主机共享一个内核.</li><li>对Docker容器内进程的优化(内核参数优化), 也可以在容器内执行<code>sysctl</code>命令更改, 或者在Docker启动时: <code>docker run --sysctl key=value IMAGE:TAG CMD</code></li><li>Docker有一个白名单, 定义哪些sysctl参数可以在<code>docker run</code>时更改, 不在白名单内的参数, 在docker容器内<code>sysctl -a</code>也看不到</li><li>有些参数可以在容器内使用 sysctl 更改(如 kernel.pid_max), 但是容器内更改后会影响到主机, 原因是这类参数没有 Namespace 隔离(大部分 kernel 开头的), docker 和宿主机共享内核. 这类参数也不建议通过容器更改, sysctl 命令参考：[[../21.Operating-System/Linux.04a.Sysctl]]</li><li>所以针对docker的内核类优化:<ul><li>最好是在宿主机内修改, 然后作用于docker进程;</li><li>如果需要针对docker修改, 可以通过<code>docker run</code>传入参数, 并注意这些参数会不会影响到宿主机</li></ul></li></ul><p>@ref: </p><ul><li><a href="https://zhuanlan.zhihu.com/p/82488569" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82488569</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker容器隔离的实现原理&quot;&gt;&lt;a href=&quot;#Docker容器隔离的实现原理&quot; class=&quot;headerlink&quot; title=&quot;Docker容器隔离的实现原理&quot;&gt;&lt;/a&gt;Docker容器隔离的实现原理&lt;/h1&gt;&lt;h2 id=&quot;Namespace&quot;&gt;&lt;a href=&quot;#Namespace&quot; class=&quot;headerlink&quot; title=&quot;Namespace&quot;&gt;&lt;/a&gt;Namespace&lt;/h2&gt;&lt;p&gt;先认识Linux 提供的Namespace机制: Linux的 Namespace 提供了7种不同的命名空间:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID namespace: 隔离进程ID,每个容器有自己的pid命名空间&lt;/li&gt;
&lt;li&gt;UTS namespace: 隔离主机名 &amp;amp; 域名, ….有自己的主机名和NIS域名&lt;/li&gt;
&lt;li&gt;IPC namespace: 隔离进程间通信, 相同IPC Ns的进程之间才可以使用(共享内存/信号量/消息队列)通讯&lt;/li&gt;
&lt;li&gt;MNT namespace: 隔离文件系统挂载点&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker 如何实现进程隔离 (宿主机进程 &amp;amp; 容器内进程的隔离) ?&lt;/p&gt;</summary>
    
    
    
    <category term="31.Backend" scheme="https://beefyheisenberg.github.io/categories/31-Backend/"/>
    
    
  </entry>
  
  <entry>
    <title>C100K系统设计</title>
    <link href="https://beefyheisenberg.github.io/31.Backend/SystemDesign-01-C100K/"/>
    <id>https://beefyheisenberg.github.io/31.Backend/SystemDesign-01-C100K/</id>
    <published>2023-04-28T00:14:17.061Z</published>
    <updated>2023-04-28T00:14:17.062Z</updated>
    
    <content type="html"><![CDATA[<p>本篇只讨论<strong>OS 级别的并发优化</strong>，不包括<strong>语言层面对并发的支持特性</strong>，C10 K / C100 K / C1000 K（百万） 都是指单服务器下，能够支持的空闲长连接的数量。</p><h1 id="有关-Linux-系统的限制"><a href="#有关-Linux-系统的限制" class="headerlink" title="有关 Linux 系统的限制"></a>有关 Linux 系统的限制</h1><p>服务器能支持建立连接数由几个决定：</p><ul><li>建立 TCP 连接最大并发数：TCP 连接四元组是由源 IP 地址、源端口、目的 IP 地址和目的端口构成，理论上是无上限的；</li></ul><ul><li>端口数限制：参考 [[#系统端口限制]]</li></ul><ul><li>Linux 文件描述符数量限制：打开一个 socket 要创建多个结构体（参考《深入理解 Linux 内核》），占用内存，所以 linux 系统出于安全角度的考虑，在多个位置都限制了可打开的文件描述符的数量，包括系统级、进程级、用户进程级，参考 [[#系统最大文件数]]</li><li>TCP 连接的内存开销：Linux 为内核对象申请空间使用 Slab 机制，在 Linux 3.10.0 版本中，创建一个 socket 需要消耗 densty、flip、sock_inode_cache、TCP 四个内核对象。这些对象加起来总共需要消耗大约 3 KB 多一点的内存。</li><li>服务器端应用层设置：Nginx、Apache、Tomcat 都有各自的最大并发数限制选项</li></ul><h2 id="系统最大文件数"><a href="#系统最大文件数" class="headerlink" title="系统最大文件数"></a>系统最大文件数</h2><p>使用 <code>ulimit</code> 设置最多能打开文件数:</p><blockquote><ul><li>查看所有的限制: <code>ulimit -a</code></li><li>设置最大打开文件句柄数: <code>ulimit -n 65535</code>, 65535 = 2^16 = 0 xFFFF</li><li>设置 <strong>每个用户的</strong> 最大进程数: <code>ulimit -u 32768</code></li><li>设置线程栈的大小: <code>ulimit -s 10240</code></li><li>设置最大线程数数: <code>ulimit -T</code> (在 Unix 上可能不同)</li><li>设置产生 core 文件大小: <code>ulimit -c xxx</code></li><li>不限制 core 的大小: <code>ulimit -c unlimited</code></li></ul></blockquote><p>ulimit 起作用的范围是”当前 Shell”, 并不是作用于”当前用户”, 如要对”用户”级别做限制, 则需要修改系统文件 <code>/etc/security/limits.conf</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># * 表示所有用户, nofile表示限制文件打开数, 限制在100</span><br><span class="line"># 注意 [hard nofile]一定要比 fs.nr_open 要小，否则可能导致用户无法登陆</span><br><span class="line">* soft  nofile  55000  </span><br><span class="line">* hard  nofile 100</span><br></pre></td></tr></table></figure><p>如果是针对整个系统, 则需要使用 <code>sysctl</code> 修改, 命令格式为: <code>sysctl -w fs.nr_open=10000000</code>, 每个系统参数对应一个/proc 下的文件, <code>fs.nr_open</code> 对应的文件路径是 <code>/proc/sys/fs/nr_open</code><br>系统最大打开文件数相关的参数有两个:</p><ul><li>fs.nr_open，进程级别</li><li>fs.file-max，系统级别</li></ul><p>至此总结一下, “Linux 系统最多能打开文件数” 有当前 shell, 进程, 用户, 系统三个级别,<br>shell 级别的更改限制命令是 ulimit, 更改系统级别限制的命令是 sysctl, 用户级别<br>限制优先级最大的是 fs.file-max, 假如 fs.file-max 设置为 100 万, ulimit 是不能超过 100万的.</p><blockquote><p>cat /proc/sys/fs/file-nr, 输出 9344 0 592026，分别为：1.已经分配的文件句柄数，2.已经分配但没有使用的文件句柄数，3.最大文件句柄数<br>file-nr 不是单个进程的限制, 是系统级的, 最后一个数字与 <code>file-max</code> 相同</p></blockquote><p>➤ 系统打开文件数有上限吗？<br>还没查到靠谱的资料，参考 RH6 手册，对于文件的限制，只有最大文件大小、最多子目录的数量等待，没有提到打开文件数 <a href="https://access.redhat.com/zh_CN/articles/3482381" target="_blank" rel="noopener">Red Hat Enterprise Linux 的技术能力和限制 - Red Hat Customer Portal</a></p><p>➤ 如何查看已创建文件描述符数?</p><ul><li>某进程打开文件数 <code>ll /proc/1599/fd | wc -l</code></li><li>某进程打开 socket 的数量: <code>ll /proc/1599/fd | grep socket | wc -l</code>  # nginx 一个 worker 打开了 200-300 个 socket</li><li>系统全部打开的文件数 <code>lsof | wc -l</code></li><li>系统全部打开的 TCP 连接数 <code>lsof | grep TCP | wc -l</code></li><li>查看 tcp 不同状态连接数: <code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code><ul><li>注意处于 TIME_WAIT 的链接, 如果这个数过高会占用大量连接, 应该调整参数尽快的释放 time_wait 连接</li></ul></li></ul><p>在 Nginx 机器上测试:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@zw_85_63 ~]# netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br><span class="line">TIME_WAIT 37968</span><br><span class="line">SYN_SENT 1</span><br><span class="line">FIN_WAIT1 5</span><br><span class="line">FIN_WAIT2 4</span><br><span class="line">ESTABLISHED 2725</span><br><span class="line">SYN_RECV 18</span><br><span class="line">LAST_ACK 4</span><br></pre></td></tr></table></figure><h2 id="系统端口限制"><a href="#系统端口限制" class="headerlink" title="系统端口限制"></a>系统端口限制</h2><p>TCP 协议规定的端口数量有 65535 个，但是一般的系统里 1024 以下的端口都是保留的，可用的大约就是 64 k 个. 默认情况下，Linux 只开启了 3 万多个可用端口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#vi /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_local_port_range = 5000 65000</span><br></pre></td></tr></table></figure><p>但对于服务端，端口数不是问题，因为一个监听的端口可以复用，<br>对于客户端，端口其实也是可以复用的，但还是有<strong>四元组</strong>的限制（举例，如果 Client 用一个端口，那么 dst_ip dst_port 的组合不能相同）</p><blockquote><p>四元组相关的代码, 参考 net/ipv4/inet_hashtables.c 下的 INET_MATCH 宏</p></blockquote><p>如果 Client 只连接一个 Server（这种情况下 dst_ip 和 dst_port 被固定了），那么作为 Client 只能一个 port 建立一个连接了，也就受到 TCP 协议端口数上限的限制。如果 Client 启动大量并发线程去连接 Server，这时候可能遇到一个问题：TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。 </p><p>但有个优化选项：打开 <code>net.ipv4.tcp_tw_reuse</code> 这个内核参数，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。</p><h2 id="系统最大进线程数"><a href="#系统最大进线程数" class="headerlink" title="系统最大进线程数"></a>系统最大进线程数</h2><p>某些服务程序(Apache, Tomcat) 采用 “Thread Per Request”, 系统的进线程最大数也会影响并发性能.</p><p>Linux 没有 <strong>直接限制</strong> 每个进程能够创建线程数, 仅限制了系统最大进线程数, 相关的配置有 :</p><ul><li>仅对当前 shell 有效: <code>ulimit -u 102400</code>, <code>-u</code> 表示 “max user processes”;</li><li>系统级别有效:<ol><li>临时生效: <code>echo 102400 &gt; /proc/sys/kernel/threads-max</code> 或 <code>sysctl -w sys.kernel.threads-max=10240</code> ;</li><li>永久生效: 修改 /etc/sysctl.conf 文件;</li></ol></li></ul><blockquote><p>这里的 threads-max 不是指进程, 是 “maximum number of threads that can be created using fork()”,<br>@ref <a href="https://www.kernel.org/doc/Documentation/sysctl/kernel.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/sysctl/kernel.txt</a></p></blockquote><p>每个进程能创建的最大线程数, 是由 total virtual memory 和 stack size 共同决定的, <code>number of threads = total virtual memory / stack size</code><br>这两个参数分别用 <code>ulimit -v xxx</code> 和 <code>ulimit -s xxx</code> 设置</p><p>此外系统能创建最大进程数还受 <code>kernel.pid_max</code> 影响:</p><ul><li>方式1 运行时限制,临时生效 <code>echo 999999 &gt; /proc/sys/kernel/pid_max</code></li><li>方式2 修改/etc/sysctl.conf，永久生效 <code>sys.kernel.pid_max = 999999</code></li></ul><p>但是线程数没限制不代表”Thread Per Request”可以行得通，如果创建了百万级的线程，上下文切换对 CPU 的调度也是考验</p><h1 id="应用程序的设置"><a href="#应用程序的设置" class="headerlink" title="应用程序的设置"></a>应用程序的设置</h1><p>根据不同程序不同 IO 模型, 设置的思路也不一样</p><blockquote><p>BIO：Apache/Tomcat, 主要是并发量要求不高的场景<br>NIO：Nginx/Redis, 主要是高并发量要求的场景<br>Redis 使用单线程的 I/O 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll、kqueue 和 select。对于单纯只有 I/O 操作来说，单线程可以将速度优势发挥到最大。<br>但是 Redis 也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU 计算过程中，整个 I/O 调度都是被阻塞住的，</p></blockquote><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><ul><li>worker_rlimit_nofile 65535; // 一个 nginx 进程打开的最多文件描述符数目</li><li><p>listen 8080 backlog=168888; // accept 成功队列长度，用于 listen(int sockfd, int backlog)，默认值 511</p></li><li><p>worker_connections= //每个 worker 线程能创建的连接数</p></li><li>upstream 可以使用 http 1.1的 keepalive //与后端服务器创建的连接池大小</li><li>worker_processes 8; // nginx 进程数，一般等于 cpu core 数量</li><li>worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000; // 每个进程分配到 cpu 的 core 上</li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>@todo</p><h2 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h2><p>默认是多进程同步处理 request, 所以思路和 Nginx 每个 Core 一个进程 epoll 轮询的方式不同, apache 应该增加”系统创建进程数上限”, 并且减小进程栈内存</p><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><ul><li>maxThreads=500 最大线程数，此值限制了 bio 的最大连接数<ul><li>一般的当一个进程有 500 个线程在跑的话，那性能已经是很低很低了。Tomcat 默认配置的最大请求数是 150。当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。</li></ul></li><li>maxConnection=8192: 使用 nio 或者 apr 时，最大连接数受此值影响。</li></ul><p>参考 <a href="http://www.cnblogs.com/zhanjindong/p/concurrent-and-tomcat-threads.html" target="_blank" rel="noopener">聊下并发和Tomcat线程数（Updated） - zhanjindong - 博客园</a> @ref</p><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h2><ul><li>fastcgi_connect_timeout 300;</li></ul><h1 id="高并发配置-无废话总结"><a href="#高并发配置-无废话总结" class="headerlink" title="高并发配置-无废话总结"></a>高并发配置-无废话总结</h1><ol><li>应用程序的并发设置: 主要是 timeout, 进/线程数这几类参数</li><li>操作系统打开文件数量限制:  <code>ulimit -n</code> 单个 Shell 环境的限制, <code>sysctl -w fs.file-max</code> 修改系统打开文件限制</li><li>操作系统打开端口数量限制: 最大端口数 65535(2^16), 但 1024 以后的端口是给系统用的</li><li></li><li>sysctl 修改的 TCP 协议栈参数</li></ol><h1 id="并发性能测试工具"><a href="#并发性能测试工具" class="headerlink" title="并发性能测试工具"></a>并发性能测试工具</h1><h2 id="ab-Apache-Bench"><a href="#ab-Apache-Bench" class="headerlink" title="ab(Apache Bench)"></a>ab(Apache Bench)</h2><p>1000并发, 总共20000次请求: <code>ab -n 20000 -c 1000 &lt;url&gt;</code></p><h2 id="http-load"><a href="#http-load" class="headerlink" title="http_load"></a>http_load</h2><p>30个并发线程, 共60秒测试: <code>http_load -p 30 -s 60 Url.txt</code></p><h2 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>@todo</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>@todo</p><h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p>在聚合报告中，会显示一行数据，共有 10 个字段，含义分别如下。</p><ul><li>Label：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值</li><li>Samples：表示你这次测试中一共发出了多少个请求，如果模拟 10 个用户，每个用户迭代 10 次，那么这里显示 100</li><li>Average：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以 Transaction 为单位显示平均* 响应时间</li><li>Median：中位数，也就是 50％ 用户的响应时间</li><li>90% Line：90％ 用户的响应时间</li><li>Min：最小响应时间</li><li>Max：最大响应时间</li><li>Error%：本次测试中出现错误的请求的数量/请求的总数</li><li>Throughput：吞吐量——默认情况下表示每秒完成的请求数（Request per Second）</li><li>KB/Sec：每秒从服务器端接收到的数据量，相当于 LoadRunner 中的 Throughput/Sec</li></ul><p>参考: <a href="http://www.importnew.com/13876.html" target="_blank" rel="noopener">使用JMeter进行负载测试——终极指南 - ImportNew</a> @ref</p><h2 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h2><p><a href="https://github.com/wg/wrk" target="_blank" rel="noopener">wg/wrk: Modern HTTP benchmarking tool</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.rowkey.me/blog/2015/09/09/load-analysis/" target="_blank" rel="noopener">系统负载能力浅析</a></li><li><a href="https://www.zhihu.com/question/361111920" target="_blank" rel="noopener">一台主机上只能保持最多 65535 个 TCP 连接吗？ - 知乎</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/" target="_blank" rel="noopener">通过 ulimit 改善系统性能</a> @Archived</li><li><a href="http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/" target="_blank" rel="noopener">怎样增大 Linux 系统的 open file(s) 上限</a></li><li><a href="http://www.cnblogs.com/sxlfybb/archive/2011/09/15/2178160.html" target="_blank" rel="noopener">nginx优化 突破十万并发</a></li><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-libev/" target="_blank" rel="noopener">使用 libevent 和 libev 提高网络应用性能</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇只讨论&lt;strong&gt;OS 级别的并发优化&lt;/strong&gt;，不包括&lt;strong&gt;语言层面对并发的支持特性&lt;/strong&gt;，C10 K / C100 K / C1000 K（百万） 都是指单服务器下，能够支持的空闲长连接的数量。&lt;/p&gt;
&lt;h1 id=&quot;有关-Linux-系统的限制&quot;&gt;&lt;a href=&quot;#有关-Linux-系统的限制&quot; class=&quot;headerlink&quot; title=&quot;有关 Linux 系统的限制&quot;&gt;&lt;/a&gt;有关 Linux 系统的限制&lt;/h1&gt;&lt;p&gt;服务器能支持建立连接数由几个决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立 TCP 连接最大并发数：TCP 连接四元组是由源 IP 地址、源端口、目的 IP 地址和目的端口构成，理论上是无上限的；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;端口数限制：参考 [[#系统端口限制]]&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="31.Backend" scheme="https://beefyheisenberg.github.io/categories/31-Backend/"/>
    
    
    <category term="后端架构" scheme="https://beefyheisenberg.github.io/tags/后端架构/"/>
    
    <category term="并发" scheme="https://beefyheisenberg.github.io/tags/并发/"/>
    
    <category term="性能测试" scheme="https://beefyheisenberg.github.io/tags/性能测试/"/>
    
    <category term="C10K" scheme="https://beefyheisenberg.github.io/tags/C10K/"/>
    
    <category term="C100K" scheme="https://beefyheisenberg.github.io/tags/C100K/"/>
    
    <category term="ulimit" scheme="https://beefyheisenberg.github.io/tags/ulimit/"/>
    
  </entry>
  
  <entry>
    <title>后端架构：System Design</title>
    <link href="https://beefyheisenberg.github.io/31.Backend/SystemDesign-00-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"/>
    <id>https://beefyheisenberg.github.io/31.Backend/SystemDesign-00-%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/</id>
    <published>2023-04-28T00:14:17.055Z</published>
    <updated>2023-04-28T00:14:17.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些概念和测试基准"><a href="#一些概念和测试基准" class="headerlink" title="一些概念和测试基准"></a>一些概念和测试基准</h1><p>本章内容包括: 系统可用性的概念和指标, 系统性能的概念和指标, 如何严谨地做性能测试.</p><h2 id="系统可用性的概念和指标"><a href="#系统可用性的概念和指标" class="headerlink" title="系统可用性的概念和指标"></a>系统可用性的概念和指标</h2><p><strong>高可用性</strong>（high availability，缩写为 HA），IT术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行<br>其度量方式，是根据系统损害、无法使用的时间，以及由无法运作恢复到可运作状况的时间，与系统总运作时间的比较。计算公式为:<br><img src="/images/system_design/Arch-HA-Exp.png" alt=""></p><p>A（可用性），MTBF(平均故障间隔)，MDT(平均修复时间)<br>在线系统和执行关键任务的系统通常要求其可用性要达到5个9标准(99.999%)。</p><ul><li>3个9：(1-99.9%) x 365 x 24 =8.76小时，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是8.76小时。</li><li>4个9：(1-99.99%) x 365 x 24 =0.876小时=52.6分钟，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是52.6分钟。</li><li>5个9：(1-99.999%) x 365 x 24 x 60 =5.26分钟，表示该软件系统在连续运行1年时间里最多可能的业务中断时间是5.26分钟。</li></ul><p>那么X个9里的X只代表数字3~5，为什么没有1~2，也没有大于6的呢？我们接着往下计算：</p><ul><li>1个9：(1-90%)x365=36.5天</li><li>2个9：(1-99%)x365=3.65天</li><li>6个9：(1-99.9999%)x365x24x60x60=31秒</li></ul><p>可以看到1个9和、2个9分别表示一年时间内业务可能中断的时间是36.5天、3.65天，这种级别的可靠性或许还不配使用“可靠性”这个词；而6个9则表示一年内业务中断时间最多是31秒，那么这个级别的可靠性并非实现不了，而是要做到从5个9》6个9的可靠性提升的话，后者需要付出比前者几倍的成本，所以在企业里大家都只谈（3~5）个9。</p><h2 id="系统性能的概念和指标"><a href="#系统性能的概念和指标" class="headerlink" title="系统性能的概念和指标"></a>系统性能的概念和指标</h2><p>① 系统延迟(Latency): 系统在处理一个请求或一个任务时的延迟, 有平均值, 中位数, TP 三种衡量指标:</p><ol><li>平均值(Avg): 延迟的评测性能指标原则: <strong>不要用平均值!</strong>  例如测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况</li><li>中位数（Mean）: 可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。</li><li>TP指标(Top Percentile): <strong>这是最为正确的统计做法</strong> ，也就是英文中的 Top Percentile ，Top百分数，是一个统计学里的术语，与平均数、中位数都是一类。<ul><li>TP50：指在一个时间段内（如5分钟），统计该方法每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序，取第50%的那个值作为TP50 值；正确使用TP50做监控: 配置此监控指标对应的报警阀值后，需要保证在这个时间段内该方法所有调用的消耗时间至少有50%的值要小于此阀值，否则系统将会报警。</li><li>TP90: 通过上面的定义, 90%的请求中最长耗时; TP90也即要求 比这个耗时还长的请求次数 比例应该在总次数的10%以下</li><li>TP99: 与TP50/90值计算方式一致，它们分别代表着对方法的不同性能要求，TP50相对较低，TP90则比较高，TP99，TP999则对方法性能要求很高</li></ul></li></ol><blockquote><p>Amazon AWS 定义的 P99: <a href="https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/health-enhanced-metrics.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/health-enhanced-metrics.html</a></p></blockquote><p>② 吞吐量(Throughput): 每秒可处理的请求数/事务数, 等于<code>并发数/平均响应时间</code></p><ul><li><strong>QPS</strong>: Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。可用由PV粗略计算QPS的两种方法:<ul><li>按照每天80%的请求集中在20%的时间, <code>峰值QPS= (PV*80%) / (24*3600*20%)</code></li><li>按照峰值QPS是评价QPS的三倍计算, <code>峰值QPS= (PV*3) / (24*3600)</code></li></ul></li><li><strong>TPS</strong>: Transactions Per Second, 也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。</li></ul><blockquote><p>Java GC回收器的评估指标里也有吞吐量的概念: 系统总运行时间 = 应用程序耗时 + 总GC耗时。</p></blockquote><p>③ 除了 Latency 和 Throughtput , 其他的性能衡量指标还有:</p><ul><li>PV: page view</li><li>UV: user view;</li><li>VU: 并发用户数, 也叫虚拟用户数(VU), 同时请求系统的用户数. 一般情况下, 大型系统（业务量大、机器多）做性能测试 5000 个并发用户就够了, 中小型系统做性能测试 1000 个并发用户就足够了;</li></ul><h2 id="如何严谨地做性能测试"><a href="#如何严谨地做性能测试" class="headerlink" title="如何严谨地做性能测试"></a>如何严谨地做性能测试</h2><p>一般来说，性能测试要统一考虑这么几个因素：Thoughput吞吐量，Latency响应时间，资源利用（CPU/MEM/IO/Bandwidth…），成功率，系统稳定性。</p><ul><li>一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。</li><li>二，在这个响应时间的限制下，找到最高的吞吐量。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。</li><li>三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能</li><li>四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。</li><li>五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。</li><li>六、低吞吐量和网络小包的测试。有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。</li></ul><blockquote><p>@ref  <a href="https://coolshell.cn/articles/17381.html" target="_blank" rel="noopener">性能测试应该怎么做？ | | 酷 壳 - CoolShell</a></p></blockquote><h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><p>本章内容包括: 负载均衡, 限流, 隔离, 降级, 超时与重试, 回滚, 压测与预案.</p><h2 id="负载均衡与反向代理-Nginx"><a href="#负载均衡与反向代理-Nginx" class="headerlink" title="负载均衡与反向代理(Nginx)"></a>负载均衡与反向代理(Nginx)</h2><p>这里不再介绍Nginx的具体配置</p><h3 id="负载均衡-loadbalance"><a href="#负载均衡-loadbalance" class="headerlink" title="负载均衡(loadbalance)"></a>负载均衡(loadbalance)</h3><p>Nginx目前提供了HTTP七层负载均衡(ngx_http_upstream_module), 意思是在OSI第七层应用层的负载均衡, 1.9版本也开始提供TCP四层负载均衡(ngx_stream_upstream_module)</p><h4 id="upstream服务器配置"><a href="#upstream服务器配置" class="headerlink" title="upstream服务器配置"></a>upstream服务器配置</h4><p>略</p><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>几种负载均衡算法:</p><ul><li>轮询（Round Robin）</li><li>加权轮询（Weight Round Robin）</li><li>随机（Random）</li><li>加权随机（Weight Random）</li><li>源地址哈希（Hash）</li><li>一致性哈希（ConsistentHash）</li><li>最小连接数（Least Connections）</li><li>低并发优先（Active Weight）</li></ul><p>Nginx配置中常用的负载均衡:</p><ul><li>round robin(轮询): 默认的</li><li>ip哈希:<code>ip_hash</code>, 根据客户端ip</li><li>哈希:<ul><li><code>hash $uri</code>:根据uri进行哈希</li><li><code>hash $key consistent</code>:一致性哈希</li></ul></li></ul><p><strong>一致性哈希(consistent hashing)</strong>:<br>在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对K/n个关键字重新映射，其中K是哈希关键字的数量(也就是Key)，n是槽位数量(槽位指的是Node的槽位)。<br>然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p><p>一致性哈希vs传统哈希的优势:</p><ul><li>新增/减少节点, 传统哈希需要对全部Key做rehash, 一致性哈希只需…</li><li>新增/减少节点, rehash影响的节点少, 理论上只影响相邻的节点</li></ul><p>一致性哈希过程: </p><ol><li>首先求出服务器（节点）的哈希值，并将其配置到0～2^32的圆（continuum）上。// 为什么哈希范围是2^32?  当服务节点太少时，容易因为节点分部不均匀而造成数据倾斜。这种一般通过增加虚拟节点的方式解决</li><li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li><li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台memcached服务器上。</li></ol><p><img src="/images/system_design/consistent-hash.png" alt="consistent-hash"></p><ol start="4"><li>如果增加一个服务器节点, 如下图, 新增 node5 节点, 只有在圆（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响</li></ol><p><img src="/images/system_design/consistnet-hash-add-node.png" alt="consistnet-hash-add-node"></p><h4 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h4><p>主要针对在Nginx的<code>upstream</code>和<code>proxy_pass</code>进行配置, 作用是实现”多少时间内失败多少次, 则从upstream列表里摘除”</p><h4 id="upstream心跳检查"><a href="#upstream心跳检查" class="headerlink" title="upstream心跳检查"></a>upstream心跳检查</h4><p>失败重试是被动的去摘除upstream无效机器, 心跳检测可以认为是一种主动的检查并摘除无效机器, 主要在<code>upstream</code>的<code>check</code>里, 有http和tcp两种</p><h3 id="长连接-keepalive"><a href="#长连接-keepalive" class="headerlink" title="长连接(keepalive)"></a>长连接(keepalive)</h3><ol><li>client 与 nginx之间的长连接: <code>http</code>里的<code>keepalive_timeout 300s 300s;</code><ul><li>第一个参数: client和nginx建立的长连接, 如果在此时间内没有实际消息发送, nginx将主动关闭此连接（默认是75秒)</li><li>第二个参数: nginx向client发送response的http头, 其中的<code>Keep-Alive: timeout=xx</code></li></ul></li><li>nginx 与 upstream之间的长连接: <code>upstream</code>里的<code>keepalive 100</code>这里的100指的是”每个Worker与upstream服务器可缓存的最大连接数”</li></ol><p>参考: <a href="/31.Backend/反向代理-Nginx/" title="反向代理-Nginx">反向代理-Nginx</a></p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>服务降级，当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</p><h3 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h3><p>即可以降级的功能点, 降级服务需要从服务端链路考虑, 根据用户访问的服务调用链路决定哪里可以降级. 一般情况下可以考虑降级的点有:</p><ul><li>页面降级(整个页面or页面片段):非核心业务的页面, 在紧急情况下可以降级, 可以利用nginx把该页面直接跳转一个静态页</li><li>页面异步请求:比如异步加载的信息, 在紧急情况下可以降级</li><li>非核心功能降级:比如商品详情页的推荐/热销</li><li>读降级:紧急情况下只读缓存, 适用于一致性要求不高的情况</li><li>写降级:在高并发抢购这种情景下, 可以先更新cache, 然后异步写回数据库</li><li>风控降级:识别机器人, 根据用户画像和用户风控等级降级, 需要提前做好用户风控等级的功能</li></ul><blockquote><p>降级后的处理方式一般有:返回默认值, 返回静态页面, 从缓存读数据而不是数据库</p></blockquote><h3 id="自动降级"><a href="#自动降级" class="headerlink" title="自动降级"></a>自动降级</h3><ul><li>超时降级: 访问数据库 或 非本地接口(RPC, HTTP)超时, 需要提前设置合理的超时时间/重试机制/重试次数</li><li>故障降级: 远程调用的接口RPC抛异常, HTTP服务500错误等,</li><li>流量降级: 超过限流阈值时..</li></ul><h3 id="手动开关降级"><a href="#手动开关降级" class="headerlink" title="手动开关降级"></a>手动开关降级</h3><p>开关可以放在Redis, Zookeeper上.</p><h3 id="读写服务降级"><a href="#读写服务降级" class="headerlink" title="读写服务降级"></a>读写服务降级</h3><ul><li>库存扣减案例: 正常情况下扣减Redis, 同步扣减DB, 当流量过大时, 降级为发送一条扣减消息, 然后异步写入DB实现最终一致性</li></ul><h3 id="多级降级"><a href="#多级降级" class="headerlink" title="多级降级"></a>多级降级</h3><p>从用户到系统, 降级离用户越近, 最终落到后端系统的QPS越低, 对后端系统的保护就越好</p><ul><li>页面JS降级开关</li><li>接入层降级开关, 一般是Nginx</li><li>后端应用降级开关</li></ul><h3 id="通过-Hystrix实现熔断降级"><a href="#通过-Hystrix实现熔断降级" class="headerlink" title="通过 Hystrix实现熔断降级"></a>通过 Hystrix实现熔断降级</h3><p>@todo</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>@todo</p><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>几种常用<strong>容错策略</strong>：</p><ul><li>失效转移（failover）: 当出现失败，重试其他服务器，通常用于读操作等幂等行为(保证调用 1 次与 N 次效果相同)，重试会带来更长延迟。</li><li>快速失败（failfast）: 只发起一次调用，失败立即报错，通常用于非幂等性的写操作。</li><li>失效安全（failsafe）: 出现异常时忽略，但记录这一次失败，存入日志中。// 失败安全策略的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。</li><li>失败通知（failback）: 客户端需要能够获取到服务调用失败的具体信息，通过对失败错误码等异常信息的判断，决定后续的执行策略，例如非幂等性的服务调用。// Dubbo中的Failback策略中，如果调用失败，则此次失败相当于Failsafe，将返回一个空结果。而与Failsafe不同的是，Failback策略会将这次调用加入内存中的失败列表中，对于这个列表中的失败调用，会在另一个线程中进行异步重试，重试如果再发生失败，则会忽略，即使重试调用成功，原来的调用方也感知不到了。因此它通常适合于，对于实时性要求不高，且不需要返回值的一些异步操作。</li></ul><h2 id="超时与重试"><a href="#超时与重试" class="headerlink" title="超时与重试"></a>超时与重试</h2><p>在实际开发过程中，笔者见过太多故障是因为没有设置超时或者设置得不对而造成的。而这些故障都是因为没有意识到超时设置的重要性而造成的。如果应用不设置超时，则可能会导致请求响应慢，慢请求累积导致连锁反应，甚至造成应用雪崩。<br>而有些中间件或者框架在超时后会进行重试（如设置超时重试两次），读服务天然适合重试，但写服务大多不能重试（如写订单，如果写服务是幂等的，则重试是允许的），重试次数太多会导致多倍请求流量，即模拟了DDoS攻击，后果可能是灾难，因此，务必设置合理的重试机制，并且应该和熔断、快速失败机制配合。</p><h3 id="Nginx超时设置"><a href="#Nginx超时设置" class="headerlink" title="Nginx超时设置"></a>Nginx超时设置</h3><ol><li>客户端超时设置: 对于客户端超时主要设置有读取请求头超时时间、读取请求体超时时间、发送响应超时时间、长连接超时时间。<ul><li><code>keepalive_timeout time [header_timeout]</code>：<ul><li>time默认是75s,  表示长连接的超时时间(客户端在75s期间没有任何请求,  Nginx将会主动发送FIN关闭连接);</li><li>header_timeout会通过HTTP头<code>Keep-Alive: timeout=xx</code>告知客户端长连接超时时间,</li></ul></li></ul></li><li>上游服务器(upstream)超时:<ul><li>超时设置:<code>proxy_connect_timeout time</code>：与后端/上游服务器建立连接的超时时间，默认为60s，此时间不超过75s。</li><li>重试设置:<ul><li><code>proxy_next_upstream_tries number</code>：设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数（包括第一次和之后的重试次数之和）。</li><li><code>proxy_next_upstream_timeout time</code>：设置重试最大超时时间，默认0表示不限制。</li></ul></li></ul></li><li>DNS解析超时:  @todo</li></ol><h3 id="Web容器超时设置"><a href="#Web容器超时设置" class="headerlink" title="Web容器超时设置"></a>Web容器超时设置</h3><p>以Tomcat为例:</p><ul><li><code>connectionTimeout</code>: 当client与tomcat建立连接之后, 在”connectionTimeout”时间之内, 仍然没有得到client的请求数据, 此时连接将会被断开, connectionTimeout只会在链接建立之后, 得到client发送http-request信息前有效.</li><li><code>socket.soTimeout</code>: 从收到client请求后,  到返回数据, 这段超时时间  @doubt</li><li><code>keepAliveTimeout</code>: 当无实际数据交互时，连接被保持的时间，单位：毫秒。在未指定此属性时，将使用connectionTimeout作为keepAliveTimeout。</li></ul><blockquote><p>不过我们通常在tomcat前面还有nginx等代理服务器，我们通常希望链接keepAlive的机制由代理服务器控制，比如nginx来决定链接是否需要“保持活性”（注意，与keep_alive不同），当然nginx服务器只会保留极少的长连接，几乎所有的链接都会在使用结束后主动close；有nginx与client保持，而不再是tomcat与client保持。</p></blockquote><h3 id="Apache-HttpClient-客户端-超时设置"><a href="#Apache-HttpClient-客户端-超时设置" class="headerlink" title="Apache HttpClient(客户端)超时设置"></a>Apache HttpClient(客户端)超时设置</h3><ul><li>connectionTimeout: 建立连接超时时间,  指Client发出请求后,  到建立连接这段超时时间,  如果在该时间仍没有完成连接的建立会抛出connectionTimeout异常;</li><li>socketTimeout: 等待响应超时时间,  指Client对Url发起请求(连接已经建立),  到收到服务端的Response这段超时时间</li></ul><h3 id="数据库客户端连接超时设置"><a href="#数据库客户端连接超时设置" class="headerlink" title="数据库客户端连接超时设置"></a>数据库客户端连接超时设置</h3><p>@todo</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章主要介绍了如何在Web应用访问的整个链路上进行超时时间设置。通过配置合理的超时时间，防止出现某服务的依赖服务超时时间太长且响应慢，以致自己响应慢甚至崩溃。<br>客户端和服务器端都应该设置超时时间，而且客户端根据场景可以设置比服务器端更长的超时时间。如果存在多级依赖关系，如A调用B，B调用C，则超时设置应该是A&gt;B&gt;C，否则可能会一直重试，引起DDoS攻击效果。不过最终如何选择还是要看场景，有时候客户端设置的超时时间就是要比服务器端的短，可以通过在服务器端实施限流/降级等手段防止DDoS攻击。</p><p>超时之后应该有相应的策略来处理，常见的策略有重试（等一会儿再试、尝试其他分组服务、尝试其他机房服务，重试算法可考虑使用如指数退避算法）、摘掉不存活节点（负载均衡/分布式缓存场景下）、托底（返回历史数据/静态数据/缓存数据）、等待页或者错误页。对于非幂等写服务应避免重试，或者可以考虑提前生成唯一流水号来保证写服务操作通过判断流水号来实现幂等操作。<br>在进行数据库/缓存服务器操作时，记得经常检查慢查询，慢查询通常是引起服务出问题的罪魁祸首。也要考虑在超时严重时，直接将该服务降级，待该服务修复后再取消降级。</p><p>对于有负载均衡的中间件，请考虑配置心跳/存活检查，而不是惰性检查。<br>超时重试必然导致请求响应时间增加，最坏情况下的响应时间=重试次数×单次超时时间，这很可能严重影响用户体验，导致用户不断刷新页面来重复请求，最后导致服务接收的请求太多而挂掉，因此除了控制单次超时时间，也要控制好用户能忍受的最长超时时间。<br>超时时间太短会导致服务调用成功率降低，超时时间太长又会导致本应成功的调用却失败了，这也要根据实际场景来选择最适合当前业务的超时时间，甚至是程序动态自动计算超时时间。<br>比如商品详情页的库存状态服务，可以设置较短的超时时间，当超时时降级返回有货，而结算页服务就需要设置稍微长一些的超时时间保证确实有货。在实际开发中，不要轻视超时时间，很多重大事故都是因为超时时间不合理导致的，设置超时时间一定是只有好处没有坏处的，请立即Review你的代码吧。</p><blockquote><p>回顾: TCP协议里的重试机制:<br>Client发给Server端SYN包后, Server端要返给Client一个SYN-ACK, 然后Server要等待Client发过来的ACK,<br>Server发送SYN-ACK并等待ACK的过程是有重试机制的, 重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s。</p></blockquote><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><ul><li>进线程隔离</li><li>集群隔离</li><li>机房隔离</li><li>读写隔离</li><li>动静隔离: 静态资源放CDN</li><li>爬虫隔离</li><li>热点隔离: 诸如秒杀, 抢购做成独立系统</li><li>资源隔离</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><ul><li>令牌桶:</li><li>漏桶:</li></ul><h3 id="应用级限流"><a href="#应用级限流" class="headerlink" title="应用级限流"></a>应用级限流</h3><ul><li>限制总并发数/连接数: Tomcat的几个参数 acceptCount, maxConnections, maxThreads</li><li>限制单个接口的请求数:<ul><li>限制某个时间窗口的请求数:用Guava的Cache, 时间戳做Key, 访问次数AtomicLong做Value. . . 缺点是无法应对突发流量, 瞬时请求可能都被允许</li><li>平滑限流:Guava的RateLimiter提供的令牌桶算法可以对请求进行速率平均化, 比如5request/秒, 每隔200ms处理一个请求</li></ul></li></ul><h3 id="Nginx层限流"><a href="#Nginx层限流" class="headerlink" title="Nginx层限流"></a>Nginx层限流</h3><p>Nginx提供了两个限流模块:</p><ul><li>限制总并发数的<code>ngx_http_limit_conn_module</code></li><li>漏桶算法的<code>ngx_http_limit_req_module</code></li></ul><h1 id="高性能方案"><a href="#高性能方案" class="headerlink" title="高性能方案"></a>高性能方案</h1><p>本章内容: 缓存, 连接池, 异步并发, 数据库拆分, 任务系统拆分, 队列.</p><p>有关C10K、C100K单机系统，参考： <a href="https://whatsrtos.github.io/基础架构/Arch-架构-并发系统-C100K/" target="_blank" rel="noopener">架构-并发系统-C100K</a></p><h2 id="应用级缓存"><a href="#应用级缓存" class="headerlink" title="应用级缓存"></a>应用级缓存</h2><p>本章以Java应用缓存为例.</p><h3 id="缓存回收策略"><a href="#缓存回收策略" class="headerlink" title="缓存回收策略"></a>缓存回收策略</h3><ul><li>基于空间和容量: 超过xx时回收</li><li>基于存活时间(TTL): 缓存数据从创建开始计算, 过期则清除</li><li>基于Java GC:<ul><li>软引用</li><li>弱引用</li></ul></li><li>基于回收算法:<ul><li>FIFO</li><li>LRU: Least Recently Used, 最近最不常访问的被淘汰, 访问时间距离现在最久远的被淘汰(较常用)</li><li>LFU: Least Frequently Used, 在一段时间内访问次数最少的被淘汰, 访问频率最少的被淘汰(可能需要预热)</li></ul></li></ul><h3 id="Java应用级缓存的类型"><a href="#Java应用级缓存的类型" class="headerlink" title="Java应用级缓存的类型"></a>Java应用级缓存的类型</h3><ul><li>堆内缓存: 用Java软引用/弱引用对象作为缓存, 不需要序列化. Guava的Cache, Ehcache3.x</li><li>堆外缓存: 缓存在JVM内存之外, 减少GC次数, 但是需要序列化的时间开销, Ehcache3.x, MapDB</li></ul><h3 id="缓存的设计模式"><a href="#缓存的设计模式" class="headerlink" title="缓存的设计模式"></a>缓存的设计模式</h3><p>首先介绍三个名词:</p><ul><li><strong>SoR</strong>(SystemofRecord): 记录系统, 一般是DB;</li><li><strong>Cache</strong>: Cache的访问速度比SoR要快, 数据放在Cache中可以提升访问速度, 减少回源次数;</li><li><strong>回源</strong>: 缓存没有命中, 需要去SoR取数据, 这叫做回源;</li></ul><h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h4><p>即代码围绕着缓存写, 由业务层的代码读取/更新缓存.</p><ul><li>读:先读Cache, 没有读到再读SoR, 并更新Cache</li><li>写(更新):<ul><li>方案1: 先更新SoR, 再更新Cache</li><li>方案2: 先更新SoR, 再失效Cache, 读取的时候再把SoR的数据写入Cache</li></ul></li></ul><p>CacheAside存在的问题:<br>如果并发更新Cache, 会出现Cache和SoR数据不一致的情况(A更新了SoR, 还没来得及更新Cache, B线程插入进来更新SoR并更新Cache, 之后A线程更新Cache), 这种有两种解决方式:</p><ol><li>用canal订阅数据库(SoR)的 binlog, 增量更新Cache, 缓存的更新会有延迟;</li><li>通过对请求合理的hash, 让同一个读服务落到同一个实例;</li></ol><h4 id="Cache-as-SoR"><a href="#Cache-as-SoR" class="headerlink" title="Cache as SoR"></a>Cache as SoR</h4><p>即Cache和SoR是一个整体, 业务层代码只对Cache进行读写, 然后Cache再委托给SoR进行真实的读写. 有三种实现模式: Read-Throught, Write-Throught, Write-Behind:</p><ul><li>Read-Throught: 读cache, 如果没有读到, 由cache把SoR的数据更新到缓存里. GuavaCache提供了此模式, 创建Cache时需要指定一个CacheLoader, 从Cache未能读到数据时, GuavaCache委托CacheLoader从SoR读取, 用户代码只需要调用<code>cache.get()</code></li><li>Write-Throught: 用户调用<code>cache.set()</code>, 缓存更新后, 同步写到SoR, 不需要用户代码干预</li><li>Write-Behind: 与上面的区别是, Write-Behind是异步批量写SoR</li></ul><h4 id="Copy-Pattern"><a href="#Copy-Pattern" class="headerlink" title="Copy Pattern"></a>Copy Pattern</h4><ul><li>Copy-On-Read: 读时复制</li><li>Copy-On-Write: 写时复制</li></ul><h2 id="数据库拆分-分库分表"><a href="#数据库拆分-分库分表" class="headerlink" title="数据库拆分(分库分表)"></a>数据库拆分(分库分表)</h2><ul><li>垂直切分: 一般根据业务来<ul><li>垂直分表: 通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中</li><li>垂直分库: 按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。</li></ul></li><li>水平切分:<ul><li>哈希分库: 比如根据自增主键对库的总数取余操作, 可以多次哈希, 第一次哈希分库, 第二次分表:<ul><li>例子: UserId后四位mod32分到32个库中，同时再将UserId后四位Div32Mod32将每个库分为32个表，共计分为1024张表。</li></ul></li><li>范围分库: 比如根据自增主键范围切分,<ul><li>优点: 单表大小可控，天然水平扩展。</li><li>缺点: 无法解决集中写入瓶颈的问题。</li></ul></li></ul></li></ul><h3 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h3><ul><li>跨库join的问题解决方案:<ul><li>字段冗余</li><li>Redis存储索引</li></ul></li><li>夸库事务: @todo</li></ul><h2 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h2><ul><li>利用数据库自增ID:<ul><li>优点：最简单。</li><li>缺点：单点风险、单机性能瓶颈。</li></ul></li><li>TwitterSnowflake<ul><li>优点：高性能高可用、易拓展。</li><li>缺点：需要独立的集群以及ZK。</li></ul></li><li>UUID, GUID</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>这里是一些”一句话解决方案”.</p><h2 id="最佳实践list"><a href="#最佳实践list" class="headerlink" title="最佳实践list"></a>最佳实践list</h2><ul><li>LVS/F5/HAProxy负载均衡 -&gt; Nginx/Apache -&gt; Redis/Memcached</li><li>Kafka，ActiveMQ负责解耦的消息队列</li><li>RPC框架Thrift, 序列化Protobuf</li><li>分布式框架Zookeeper</li><li>Mysql分表分库的Cobar</li><li>通用搜索引擎ElasticSearch</li></ul><h2 id="如何存储密码"><a href="#如何存储密码" class="headerlink" title="如何存储密码"></a>如何存储密码</h2><ul><li>bcrypt:带盐的散列算法, 可以指定costfactor, 10表示2^10次方次运算, 返回的散列值包括盐和加密后的文本</li><li><a href="http://www.infoq.com/cn/news/2016/12/How-Dropbox-securely-passwords" target="_blank" rel="noopener">Dropbox是如何安全地存储用户密码的</a> : <code>AES256(bcrypt(SHA512(pwd), salt(10)))</code></li><li><a href="https://www.zhihu.com/question/20299384" target="_blank" rel="noopener">加盐密码保存的最通用方法是？ - 知乎</a> @todo</li></ul><hr><h1 id="附录-名词解释"><a href="#附录-名词解释" class="headerlink" title="附录:名词解释"></a>附录:名词解释</h1><ul><li>高可用High-Availability、高可扩展性(高可伸缩性)High-Scalability</li><li>解耦LooselyCoupled</li><li>吞吐量Throughput（QPS/TPS)、并发量C10K</li><li>冗余Redundancy、分区Partitions、缓存Caches、代理Proxies、索引Indexes、队列Queues</li><li>集群Cluster、主从Master-Slave、水平/垂直切分Sharding</li><li>请求负载均衡LoadBalancing、请求路由Route、状态复制Replication</li><li>故障转移Failover、故障回复Failback、心跳检测Healthcheck/Heartbeat</li><li>纵向扩展Scale-up、横向扩展Scale-out</li><li>自动升降级Auto-upgrade/downgrade</li><li>scaleup:纵向扩展, 指提高单台机器的存储(RAM, HD)上限</li><li>scaleout:横向扩展, 多台主机</li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳</a></li><li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a></li></ul><p><img src="/images/system_design/亿级流量网站架构核心技术.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一些概念和测试基准&quot;&gt;&lt;a href=&quot;#一些概念和测试基准&quot; class=&quot;headerlink&quot; title=&quot;一些概念和测试基准&quot;&gt;&lt;/a&gt;一些概念和测试基准&lt;/h1&gt;&lt;p&gt;本章内容包括: 系统可用性的概念和指标, 系统性能的概念和指标, 如何严谨地做性能测试.&lt;/p&gt;
&lt;h2 id=&quot;系统可用性的概念和指标&quot;&gt;&lt;a href=&quot;#系统可用性的概念和指标&quot; class=&quot;headerlink&quot; title=&quot;系统可用性的概念和指标&quot;&gt;&lt;/a&gt;系统可用性的概念和指标&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;高可用性&lt;/strong&gt;（high availability，缩写为 HA），IT术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行&lt;br&gt;其度量方式，是根据系统损害、无法使用的时间，以及由无法运作恢复到可运作状况的时间，与系统总运作时间的比较。计算公式为:&lt;br&gt;&lt;img src=&quot;/images/system_design/Arch-HA-Exp.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;A（可用性），MTBF(平均故障间隔)，MDT(平均修复时间)&lt;br&gt;在线系统和执行关键任务的系统通常要求其可用性要达到5个9标准(99.999%)。&lt;/p&gt;</summary>
    
    
    
    <category term="31.Backend" scheme="https://beefyheisenberg.github.io/categories/31-Backend/"/>
    
    
    <category term="后端架构" scheme="https://beefyheisenberg.github.io/tags/后端架构/"/>
    
    <category term="缓存" scheme="https://beefyheisenberg.github.io/tags/缓存/"/>
    
    <category term="架构" scheme="https://beefyheisenberg.github.io/tags/架构/"/>
    
    <category term="System Design" scheme="https://beefyheisenberg.github.io/tags/System-Design/"/>
    
    <category term="高可用" scheme="https://beefyheisenberg.github.io/tags/高可用/"/>
    
    <category term="高性能" scheme="https://beefyheisenberg.github.io/tags/高性能/"/>
    
    <category term="负载均衡" scheme="https://beefyheisenberg.github.io/tags/负载均衡/"/>
    
    <category term="限流" scheme="https://beefyheisenberg.github.io/tags/限流/"/>
    
    <category term="分库分表" scheme="https://beefyheisenberg.github.io/tags/分库分表/"/>
    
    <category term="消息队列" scheme="https://beefyheisenberg.github.io/tags/消息队列/"/>
    
  </entry>
  
  <entry>
    <title>网络协议-OSI七层模型</title>
    <link href="https://beefyheisenberg.github.io/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://beefyheisenberg.github.io/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-04-28T00:14:16.953Z</published>
    <updated>2023-04-28T00:14:16.953Z</updated>
    
    <content type="html"><![CDATA[<p>@toc:</p><ul><li>OSI七层模型;</li><li>七层、五层、四层对比;</li></ul><p>➤ 七层模型: 国际标准组织（ISO）定义的网络互联7层框架, 包括:</p><ul><li>7应用层: 该层协议包括 Socket, HTTP, HTTPS, FTP, SSH, POP3,  // WebSocket属于哪一层?</li><li>6表示层: 格式转换, 把数据转换为应用层能兼容的格式 或 适合传输的格式, 比如: 加密/解密, 压缩/解压</li><li>5会话层: 维护和管理数据传输过程中两台计算机之间的连接, 该层协议有: SSL/TLS</li><li>4传输层: 传输控制, 例如<strong>TCP协议</strong>(传输控制协议, 主要实现了传输的可靠性, 例如超时重传), 该层把「传输表头」TH加入数据形成「报文」<strong>Segment</strong>, 传输表头包括了传输协议等</li><li>3网络层: 决定数据的路由, 例如<strong>IP/ICMP协议</strong>, 该层把「网络表头」NH加入数据形成「包」<strong>Packet</strong>, 网络表头包括: @todo</li><li>2链路层: 负责网络寻找和错误侦测, 该层把「数据链表头」DLH加入数据开头, 以及「数据链表尾」DLT加入数据结尾, 形成「信息框」Data Frame, 数据链表头包括, 该层协议包括WiFi, GPRS(通用分组无线服务)</li><li>1物理层: 在局部局域网上传送「数据帧」Data Frame, 该层定义了网络硬件和网络数据之间的互通, 包括: 针脚/电压/集线器/网卡等</li></ul><p>➤ 7,5,4层网络模型的区别与联系:</p><p><img src="/images/network_protocol/OSI-7-Layer-Model.png" alt=""></p><p>网络设备供应商一般用 5 层网络描述：</p><ul><li><strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;@toc:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSI七层模型;&lt;/li&gt;
&lt;li&gt;七层、五层、四层对比;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;➤ 七层模型: 国际标准组织（ISO）定义的网络互联7层框架, 包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;7应用层: 该层协议包括 Socket, HTTP, HTTPS, FTP, SSH, POP3,  // WebSocket属于哪一层?&lt;/li&gt;
&lt;li&gt;6表示层: 格式转换, 把数据转换为应用层能兼容的格式 或 适合传输的格式, 比如: 加密/解密, 压缩/解压&lt;/li&gt;
&lt;li&gt;5会话层: 维护和管理数据传输过程中两台计算机之间的连接, 该层协议有: SSL/TLS&lt;/li&gt;
&lt;li&gt;4传输层: 传输控制, 例如&lt;strong&gt;TCP协议&lt;/strong&gt;(传输控制协议, 主要实现了传输的可靠性, 例如超时重传), 该层把「传输表头」TH加入数据形成「报文」&lt;strong&gt;Segment&lt;/strong&gt;, 传输表头包括了传输协议等&lt;/li&gt;
&lt;li&gt;3网络层: 决定数据的路由, 例如&lt;strong&gt;IP/ICMP协议&lt;/strong&gt;, 该层把「网络表头」NH加入数据形成「包」&lt;strong&gt;Packet&lt;/strong&gt;, 网络表头包括: @todo&lt;/li&gt;
&lt;li&gt;2链路层: 负责网络寻找和错误侦测, 该层把「数据链表头」DLH加入数据开头, 以及「数据链表尾」DLT加入数据结尾, 形成「信息框」Data Frame, 数据链表头包括, 该层协议包括WiFi, GPRS(通用分组无线服务)&lt;/li&gt;
&lt;li&gt;1物理层: 在局部局域网上传送「数据帧」Data Frame, 该层定义了网络硬件和网络数据之间的互通, 包括: 针脚/电压/集线器/网卡等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;➤ 7,5,4层网络模型的区别与联系:&lt;/p&gt;</summary>
    
    
    
    <category term="22.Network-Protocol" scheme="https://beefyheisenberg.github.io/categories/22-Network-Protocol/"/>
    
    
    <category term="网络协议" scheme="https://beefyheisenberg.github.io/tags/网络协议/"/>
    
  </entry>
  
  <entry>
    <title>网络协议-IP</title>
    <link href="https://beefyheisenberg.github.io/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP/"/>
    <id>https://beefyheisenberg.github.io/22.Network-Protocol/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP/</id>
    <published>2023-04-28T00:14:16.948Z</published>
    <updated>2023-04-28T00:14:16.948Z</updated>
    
    <content type="html"><![CDATA[<p>@todo： DNS、ARP、DHCP、NAT、ICMP、IGMP</p><h2 id="IP-地址的划分"><a href="#IP-地址的划分" class="headerlink" title="IP 地址的划分"></a>IP 地址的划分</h2><p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了<strong>分类地址</strong>。IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类：</p><ul><li>A类地址： 网络地址1字节，主机地址3字节，其中网络地址最高1位必须是0<ul><li>网络地址占1位，范围是1 — 126（开区间 0000 0000 — 0111 1111）不包括0000 0000 和 0111 111，前者用于表示未知地址，后者表示回环地址</li><li>主机地址占3位，表示一个网络地址中最大主机数是<code>2^24 - 2</code>（主机地址全0表示网络地址，全1表示广播地址，所以减2）</li><li>A类地址范围： <code>1.0.0.1</code> — <code>126.255.255.254</code></li><li>默认子网掩码255.0.0.0</li><li>在A类地址中，10.0.0.0到10.255.255.255是私有地址（所谓的私有地址=只能在局域网络中使用）</li></ul></li><li>B类地址： 网络地址2字节，主机地址2字节，其中网络地址最高2位必须是10<ul><li>B类地址范围：<code>128.0.0.1</code> — <code>191.255.255.254</code>，每个网络中最大主机数65534</li><li>默认子网掩码255.255.0.0</li><li>在B类地址中，172.16.0.0 — 172.31.255.255是私有地址</li></ul></li><li>C类地址： 网络地址3字节，主机地址1字节，其中网络地址最高3位必须是110<ul><li>C类地址范围：<code>192.0.0.1</code> — <code>223.255.255.254</code>，每个网络中最大主机数254</li><li>默认子网掩码255.255.255.0</li><li>在C类地址中，192.168.0.0 — 192.168.255.255是私有地址</li></ul></li><li>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。<br><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP-2023-04-26-1.png" alt="../_images/网络协议-IP-2023-04-26-1.png"></li></ul><p>因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和全为 0 地址：</p><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络（子网）</li></ul><p>➤  子网掩码：subnet mask，掩码的意思就是掩盖掉主机号，剩余的就是网络号。将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</p><p>子网掩码可以把（一个网络号表示的）网络更加细化：假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 （192 = 1100 0000）对其进行子网划分。C 类地址中前 24 位是网络号，最后 8 位是主机号，根据子网掩码可知<strong>从 8 位主机号中借用 2 位作为子网号</strong>：所以192.168.1.0这个网络被分为 4 个子网：分别是 00、01、10、11。</p><p>➤  A、B、C 类有个尴尬处境，就是<strong>不能很好的与现实网络匹配</strong>。</p><ul><li>C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。</li><li>而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</li></ul><p>这两个缺点，都可以在 <code>CIDR</code> 无分类地址解决</p><p>➤  <em>CIDR(Classless Inter-Domain Routing)</em>: 这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p><p>比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;@todo： DNS、ARP、DHCP、NAT、ICMP、IGMP&lt;/p&gt;
&lt;h2 id=&quot;IP-地址的划分&quot;&gt;&lt;a href=&quot;#IP-地址的划分&quot; class=&quot;headerlink&quot; title=&quot;IP 地址的划分&quot;&gt;&lt;/a&gt;IP 地址的划分&lt;/h2&gt;&lt;p&gt;互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了&lt;strong&gt;分类地址&lt;/strong&gt;。IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A类地址： 网络地址1字节，主机地址3字节，其中网络地址最高1位必须是0&lt;ul&gt;
&lt;li&gt;网络地址占1位，范围是1 — 126（开区间 0000 0000 — 0111 1111）不包括0000 0000 和 0111 111，前者用于表示未知地址，后者表示回环地址&lt;/li&gt;
&lt;li&gt;主机地址占3位，表示一个网络地址中最大主机数是&lt;code&gt;2^24 - 2&lt;/code&gt;（主机地址全0表示网络地址，全1表示广播地址，所以减2）&lt;/li&gt;
&lt;li&gt;A类地址范围： &lt;code&gt;1.0.0.1&lt;/code&gt; — &lt;code&gt;126.255.255.254&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认子网掩码255.0.0.0&lt;/li&gt;
&lt;li&gt;在A类地址中，10.0.0.0到10.255.255.255是私有地址（所谓的私有地址=只能在局域网络中使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B类地址： 网络地址2字节，主机地址2字节，其中网络地址最高2位必须是10&lt;ul&gt;
&lt;li&gt;B类地址范围：&lt;code&gt;128.0.0.1&lt;/code&gt; — &lt;code&gt;191.255.255.254&lt;/code&gt;，每个网络中最大主机数65534&lt;/li&gt;
&lt;li&gt;默认子网掩码255.255.0.0&lt;/li&gt;
&lt;li&gt;在B类地址中，172.16.0.0 — 172.31.255.255是私有地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C类地址： 网络地址3字节，主机地址1字节，其中网络地址最高3位必须是110&lt;ul&gt;
&lt;li&gt;C类地址范围：&lt;code&gt;192.0.0.1&lt;/code&gt; — &lt;code&gt;223.255.255.254&lt;/code&gt;，每个网络中最大主机数254&lt;/li&gt;
&lt;li&gt;默认子网掩码255.255.255.0&lt;/li&gt;
&lt;li&gt;在C类地址中，192.168.0.0 — 192.168.255.255是私有地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于&lt;strong&gt;多播&lt;/strong&gt;，E 类是预留的分类，暂时未使用。&lt;br&gt;&lt;img src=&quot;/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-IP-2023-04-26-1.png&quot; alt=&quot;../_images/网络协议-IP-2023-04-26-1.png&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和全为 0 地址：&lt;/p&gt;</summary>
    
    
    
    <category term="22.Network-Protocol" scheme="https://beefyheisenberg.github.io/categories/22-Network-Protocol/"/>
    
    
    <category term="网络协议" scheme="https://beefyheisenberg.github.io/tags/网络协议/"/>
    
    <category term="IP" scheme="https://beefyheisenberg.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>Linux.05.系统配置</title>
    <link href="https://beefyheisenberg.github.io/21.Operating-System/Linux.04.%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    <id>https://beefyheisenberg.github.io/21.Operating-System/Linux.04.%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</id>
    <published>2023-04-28T00:14:16.923Z</published>
    <updated>2023-04-28T00:14:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="profile相关"><a href="#profile相关" class="headerlink" title="profile相关"></a>profile相关</h2><blockquote><ol><li>bashrc是在系统启动后就会自动运行。</li><li>profile是在用户登录后才会运行。</li><li>进行设置后，可运用source bashrc命令更新bashrc，也可运用source profile命令更新profile。</li></ol></blockquote><ul><li>/etc/profile: 中设定的变量(全局)的可以作用于任何用户</li><li>~/.bashrc: 等中设定的变量(局部)只能继承/etc/profile中的变量</li><li>~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</li></ul><h2 id="init系统"><a href="#init系统" class="headerlink" title="init系统"></a>init系统</h2><p>init进程是 Linux系统内核初始化最后一步启动的进程，也是系统的第一个进程，pid=1。</p><p>运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统下不同的运行模式。运行级别通常分为7等，分别是从0到6，但如果必要的话也可以更多。<br>例如在大多数Linux操作系统下一共有如下7个典型的运行级别：</p><blockquote></blockquote><p>0 停机，关机<br>1 单用户，无网络连接，不运行守护进程，不允许非超级用户登录<br>2 多用户，无网络连接，不运行守护进程<br>3 多用户，正常启动系统<br>4 用户自定义<br>5 多用户，带图形界面<br>6 重启</p><p>除了模式 0,1,6外, 每种 Unix 和 Unix-like 系统对运行模式的定义不太一样。通常在 /etc/inittab 文件中定义了各种运行模式的工作范围。<br>当前绝大多数Linux发行版已经基于新的systemd，systemd一般不再使用/etc/inittab文件。</p><h3 id="init-sysvinit-和-systemd"><a href="#init-sysvinit-和-systemd" class="headerlink" title="init,sysvinit 和 systemd"></a>init,sysvinit 和 systemd</h3><p>大多数 Linux 发行版的 init 系统是和 System V 相兼容的，被称为 sysvinit。这是人们最熟悉的 init 系统。<br>Ubuntu 采用 upstart 替代了传统的 sysvinit，<br>RHEL 采用 systemd替代 sysvinit。</p><p>关于 System V，参考 <a href="/21.Operating-System/APUE.00.从Unix到Linux（Gnu、Posix是什么）/" title="APUE.00.从Unix到Linux（Gnu、Posix是什么）">APUE.00.从Unix到Linux（Gnu、Posix是什么）</a> </p><h3 id="sysvinit"><a href="#sysvinit" class="headerlink" title="sysvinit"></a>sysvinit</h3><blockquote><p>本节参考:</p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/" target="_blank" rel="noopener">浅析Linux初始化init系统, 第1部分: sysvinit</a> @ref</li></ul></blockquote><h4 id="sysvinit-运行顺序"><a href="#sysvinit-运行顺序" class="headerlink" title="sysvinit 运行顺序"></a>sysvinit 运行顺序</h4><ol><li>读取 /etc/inittab, 获取配置(系统的 runlevel 等)</li><li>/etc/rc.d/rc.sysinit</li><li>/etc/rc.d/rc 和 /etc/rc.d/rcX.d/ (X 代表运行级别 0-6)</li><li>/etc/rc.d/rc.local</li></ol><h4 id="sysvinit-管理功能"><a href="#sysvinit-管理功能" class="headerlink" title="sysvinit 管理功能"></a>sysvinit 管理功能</h4><p>sysvinit 软件包包含了一系列的控制启动、运行和关闭所有其他程序的工具：</p><ul><li>init: 这个就是 sysvinit 本身的 init 进程实体，以 pid1 身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用/etc/inittab 文件创建进程。</li><li>halt: 停止系统</li><li>poweroff: 等于 shutdown -h –p</li><li>reboot: 等于 shutdown –r</li><li>killall: 向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的 shell。</li><li>last: 回溯/var/log/wtmp 文件(或者-f 选项指定的文件)，显示自从这个文件建立以来，所有用户的登录情况。</li><li>chkconfig:  RHEL 在 sysvinit 的基础上开发的命令行工具</li><li>service: 同上</li></ul><p>使用 sysvinit 启动一个服务:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /etc/init.d/apache2 start</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> service apache2 start</span><br></pre></td></tr></table></figure><p>这种方法有两个缺点。</p><ul><li>一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ul><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是为系统的启动和管理提供一套完整的解决方案。</p><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><ul><li>systemctl是 Systemd 的主命令，用于管理系统。</li><li>systemd-analyze命令用于查看启动耗时。</li><li>…</li></ul><p>@ref:</p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程：命令篇 - 阮一峰的网络日志</a> </li><li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/" target="_blank" rel="noopener">浅析Linux初始化init系统, 第3部分: Systemd</a> </li></ul><h4 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a>systemctl 命令</h4><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。//区别 <code>sysctl</code> 命令，用于修改 Kernel参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 重启系统</span><br><span class="line"><span class="meta">$</span> sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 关闭系统，切断电源</span><br><span class="line"><span class="meta">$</span> sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> CPU停止工作</span><br><span class="line"><span class="meta">$</span> sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 暂停系统</span><br><span class="line"><span class="meta">$</span> sudo systemctl suspend</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 让系统进入冬眠状态</span><br><span class="line"><span class="meta">$</span> sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 让系统进入交互式休眠状态</span><br><span class="line"><span class="meta">$</span> sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动进入救援状态（单用户状态）</span><br><span class="line"><span class="meta">$</span> sudo systemctl rescue</span><br></pre></td></tr></table></figure><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。相关命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 列出正在运行的 Unit</span><br><span class="line"><span class="meta">$</span> systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br><span class="line"><span class="meta">$</span> systemctl list-units --all</span><br></pre></td></tr></table></figure><p>启动、重启、停止Unit：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 立即启动一个服务</span><br><span class="line"><span class="meta">$</span> sudo systemctl start example.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 立即停止一个服务</span><br><span class="line"><span class="meta">$</span> sudo systemctl stop example.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启一个服务</span><br><span class="line"><span class="meta">$</span> sudo systemctl restart example.service</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 杀死一个服务的所有子进程</span><br><span class="line"><span class="meta">$</span> sudo systemctl kill example.service</span><br></pre></td></tr></table></figure><p>Example: How to 新加一个 Service（Systemd Unit）:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/ngx-example.service</span><br></pre></td></tr></table></figure><blockquote><p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。<br><code>systemctl enable</code> 命令用于在上面两个目录之间，建立符号链接关系。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description=proxy-nginx</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/data0/www/logs/nginx.pid</span><br><span class="line"></span><br><span class="line"># 启动进程时执行的命令</span><br><span class="line">ExecStart=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf</span><br><span class="line"></span><br><span class="line"># 重启服务时执行的命令</span><br><span class="line">ExecReload=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf -s reload</span><br><span class="line"></span><br><span class="line"># 停止服务时执行的命令</span><br><span class="line">ExecStop=/usr/local/sbin/proxy-nginx -c /usr/local/etc/proxy-nginx.conf -s stop</span><br><span class="line">PrivateTmp=True</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h4 id="journald-日志系统"><a href="#journald-日志系统" class="headerlink" title="journald 日志系统"></a>journald 日志系统</h4><blockquote><p>本节参考:</p><ul><li><a href="https://ieevee.com/tech/2017/08/24/journald.html" target="_blank" rel="noopener">centos7的日志系统：journald, rsyslog, logrotate</a></li><li><a href="https://www.cnblogs.com/itxdm/p/Systemd_log_system_journalctl.html" target="_blank" rel="noopener">systemd 之 journalctl</a></li></ul></blockquote><p>Systemd 使用 journald 做日志服务，使用 rsyslog 来持久化日志，使用 logrotate 来轮转日志文件。<br>Systemd日志收集流程: <code>systemd --&gt; systemd-journald --&gt; ram DB(/run/log/journal) --&gt; rsyslog -&gt; /var/log/messages</code>;<br>对比 init日志收集: <code>service daemon ---&gt; rsyslog ---&gt; /var/log</code></p><h5 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h5><p>journald用二进制格式保存所有日志信息，用户使用 <code>journalctl</code> 命令来查看日志信息。<br>配置文件位置: <code>cat /etc/systemd/journald.conf</code></p><p>使用<code>journalctl</code>命令查看日志:</p><ul><li>journalctl: 显示所有的日志信息，notice或warning以粗体显示，红色显示error级别以上的信息</li><li>journalctl –dmesg: 查看 dmesg 信息。</li><li>journalctl -k: 查看 kernel 日志。</li><li>journalctl -f: 很像tailf命令</li><li>journalctl –since=yesterday: 指定时间段</li><li>journalctl -u docker.service:  指定服务，查看docker服务的 journal 日志。查看所有service列表使用命令 <code>systemctl list-units</code></li><li>journalctl _PID=8088: 查看指定pid的</li><li>journalctl _UID=33: 查看指定用户的</li><li>journalctl /usr/bin/bash: 查看某个路径的脚本的日志</li><li>journalctl –verify: 检查日志文件的一致性</li></ul><p>例如，docker daemon会配置为将所有容器的日志为存储到 journald。<br><code>/usr/bin/docker-current daemon --exec-opt native.cgroupdriver=systemd --selinux-enabled --log-driver=journald</code><br>所以，运行中 docker的日志，例如 k8s的 apiserver都会打到 journald日志里去（最终输出到 /var/log/messages）</p><h5 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h5><p>rsyslog用来固化journald日志。rsyslog读取 ram DB(/run/log/journal)的数据，并根据优先级排列日志信息，将它们写入到 /var/log目录中永久保存。</p><blockquote><p>默认 journald配置<code>#ForwardToSyslog=no</code>，所以并未将日志转发给syslog。syslog自己去读取的 journald的日志文件(类似journalctl)。</p></blockquote><h5 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h5><p>rsyslog的日志存储于/var/log下，显然日志文件不能无限变大，否则磁盘空间会被耗尽。RHEL7使用logrotate来做日志文件轮转。<br>配置文件位置: <code>cat /etc/cron.daily/logrotate</code></p><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>几个常见的用户组: <a href="https://www.debian.org/doc/manuals/securing-debian-howto/ch12.en.html" target="_blank" rel="noopener">adm/daemon/bin</a> :</p><ul><li>root:超级用户, 就是管理员, 拥有所有权限</li><li>bin:历史遗留用户</li><li>daemon:守护进程, 非特权的, 需要对一些以磁盘文件有写权限的daemon以daemon.daemon(portmap,atd,etc)运行；不需要占有任何文件的daemon 以nobody.nogroup运行；比较复杂的, 涉及安全问题的daemon以特定的用户运行. daemon用户也方便本地安装的daemon运行.</li><li>adm:adm组执行系统监控任务, 组成员可以读取/var/log下的多数文件, 可以使用xconsole. 历史上/var/log来自于/usr/adm, 后来叫/var/adm, 这也是组名称的由来.</li><li>apache/_www: 用root启动httpd服务, apache的子进程还是用apache(或者_www用户)运行的, 可以通过修改<code>/etc/httpd/conf/httpd.conf</code>指定apache运行的用户组.</li></ul><h3 id="用户组常用命令"><a href="#用户组常用命令" class="headerlink" title="用户组常用命令"></a>用户组常用命令</h3><ul><li><code>usermod -a -G daemon XYZ</code> 将用户XYZ加入一个组</li><li><code>id</code> , <code>whoami</code> :</li><li><code>who</code> :</li><li><code>useradd</code>, <code>userdel</code></li></ul><h2 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h2><ul><li>/etc/sudoers</li><li>/etc/hosts.allow: 限制SSH的客户端IP, /etc/hosts.allow 的设定优先于 /etc/hosts.deny</li><li>/etc/hosts.deny: 限制SSH的客户端IP</li></ul><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><ul><li><code>chmod 400 ~/.ssh/authorized_keys</code></li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul><li><p>/etc/resolv.conf: 这个文件是用于配置DNS服务器的, 扩展阅读: <a href="http://mydf.github.io/blog/ubuntu-dnsmasq/" target="_blank" rel="noopener">Ubuntu使用dnsmasq作本地DNS缓存</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure></li><li><p>/etc/hosts: 设置主机名和IP地址绑定</p></li><li>/etc/hostname: 主机名配置</li><li>/etc/sysconfig/network: 主机名和网关<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NETWORK=yes    #网络是否被配置</span><br><span class="line">RORWARD_IPV4=yes    #是否开启IP转发功能</span><br><span class="line">HOSTNAME= localhost.localdomain   #表示服务器的主机名</span><br><span class="line">GAREWAY=192.168.0.1    #表示网络网关的IP地址</span><br><span class="line">GATEWAYDEV=eth0    #网关的设备名，即选择使用哪个网卡</span><br></pre></td></tr></table></figure></li></ul><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p><code>* * * * * * cmd</code>, 分别表示每<code>分/时/每月第几日/月/周几(0~6)</code></p><ul><li>每5分钟: <code>*/5 * * * *</code></li><li>每小时: <code>0 * * * *</code></li><li>每天早上6点10分 <code>10 6 * * *</code></li><li>晚上11点到早上8点之间每两个小时, 和早上8点: <code>0 23-7/2, 8 * * *</code></li></ul><blockquote><p>每个用户的crontab文件在 /var/spool/cron/</p></blockquote><h1 id="终端Terminal"><a href="#终端Terminal" class="headerlink" title="终端Terminal"></a>终端Terminal</h1><ul><li>Ctrl+r搜索, 输入, 按Ctrl+r继续搜索</li><li>Ctrl+a / Ctrl+e : 移动光标开头/末尾m</li></ul><h2 id="tty-pst-pty"><a href="#tty-pst-pty" class="headerlink" title="tty/pst/pty"></a>tty/pst/pty</h2><ul><li>参考 <a href="https://unix.stackexchange.com/questions/21280/difference-between-pts-and-tty" target="_blank" rel="noopener">linux - Difference between pts and tty - Unix &amp; Linux Stack Exchange</a></li></ul><h1 id="性能-amp-并发相关"><a href="#性能-amp-并发相关" class="headerlink" title="性能 &amp; 并发相关"></a>性能 &amp; 并发相关</h1><p>@link: [[../31.Backend/SystemDesign-01-C100K]]</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;profile相关&quot;&gt;&lt;a href=&quot;#profile相关&quot; class=&quot;headerlink&quot; title=&quot;profile相关&quot;&gt;&lt;/a&gt;profile相关&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;bashrc是在系统启动后就会自动运行。&lt;/li&gt;
&lt;li&gt;profile是在用户登录后才会运行。&lt;/li&gt;
&lt;li&gt;进行设置后，可运用source bashrc命令更新bashrc，也可运用source profile命令更新profile。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;/etc/profile: 中设定的变量(全局)的可以作用于任何用户&lt;/li&gt;
&lt;li&gt;~/.bashrc: 等中设定的变量(局部)只能继承/etc/profile中的变量&lt;/li&gt;
&lt;li&gt;~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;init系统&quot;&gt;&lt;a href=&quot;#init系统&quot; class=&quot;headerlink&quot; title=&quot;init系统&quot;&gt;&lt;/a&gt;init系统&lt;/h2&gt;&lt;p&gt;init进程是 Linux系统内核初始化最后一步启动的进程，也是系统的第一个进程，pid=1。&lt;/p&gt;</summary>
    
    
    
    <category term="21.Operating-System" scheme="https://beefyheisenberg.github.io/categories/21-Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux.03.性能分析命令行 | Performance</title>
    <link href="https://beefyheisenberg.github.io/21.Operating-System/Linux.03.%E5%91%BD%E4%BB%A4%E8%A1%8C-Performance/"/>
    <id>https://beefyheisenberg.github.io/21.Operating-System/Linux.03.%E5%91%BD%E4%BB%A4%E8%A1%8C-Performance/</id>
    <published>2023-04-28T00:14:16.916Z</published>
    <updated>2023-04-28T00:14:16.917Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/operating_system/Linux-Series-Title.png" alt=""></p><h1 id="tldr"><a href="#tldr" class="headerlink" title="@tldr"></a>@tldr</h1><ul><li><strong>cpu</strong>:<ul><li>uptime 查看load值, 不高于core数, <code>sar -q</code>也可以查看load值</li><li>vmstat: 关注r(同load), 和b(等待资源的进程数), 以及cpu占用(用户进程和内核进程)时间百分比: us%不超过50%, us% + sy%不超过80%</li><li>sar也可以查看us% sy%占用CPU时间百分比</li></ul></li><li><strong>内存</strong>:<ul><li>free: 可用内存小于20%需要关注, <code>sar -r</code>类似</li><li>vmstat的si和so: 一般不应该大于0, <code>sar -W</code>也可以查看交换区</li></ul></li><li><strong>I/O</strong>:<ul><li>vmstat: 需关注wa(IO等待占用CPU百分比): 大于30%时需关注, bi/bo也需要关注(阈值?)</li><li>iowait: sar也可以查看iowait%</li></ul></li><li><strong>网络</strong>:<ul><li>netstat -antp : 查看所有tcp连接</li><li>iperf: 吞吐量(Throughput) , 大约为网卡最大速率的一半</li></ul></li></ul><h1 id="基础性能参数"><a href="#基础性能参数" class="headerlink" title="基础性能参数"></a>基础性能参数</h1><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p>如果CPU每分钟最多处理100个进程：</p><ul><li>那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；</li><li>系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；</li><li>系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。</li></ul><p>为了电脑顺畅运行，系统负荷最好不要超过1.0，这样就没有进程需要等待了，所有进程都能第一时间得到处理。很显然，1.0是一个关键值，超过这个值，系统就不在最佳状态了，你要动手干预了。</p><p>@ref: <a href="http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html</a></p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><ul><li>uptime返回1/5/15分钟内的load值(进程队列的长度), 对于单核cpu, load值在1.0以下可以接受, 对于多核CPU, load值要除以”核心数”</li><li>多核CPU的话, 满负荷状态的数字为 “1.00 * CPU核数”, 这里的CPU核数是<code>processor</code>的数量,</li><li>某台服务器举例: 2个物理CPU, 每个物理CPU包括8个Core, 每个Core包括4个Processor(HT超线程),</li><li>以上参考<a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages" target="_blank" rel="noopener">Understanding Linux CPU Load - when should you be worried?</a> @ref</li><li>1/5/15分钟的load值, 应该参考哪一个? 如下:</li></ul><p><img src="/images/operating_system/linux-load-uptime.png" alt="Linux_Load_Uptime"></p><blockquote><p>load值走高也不一定就是cpu资源紧张导致的, 还需要结合<code>vmstat</code>, <code>iostat</code>工具进行确认和判断是cpu不足还是磁盘IO问题又或者是内存不足导致.</p></blockquote><h3 id="cat-proc-cpuinfo"><a href="#cat-proc-cpuinfo" class="headerlink" title="cat /proc/cpuinfo"></a>cat /proc/cpuinfo</h3><p>一个物理封装的CPU（通过<code>physical id</code>区分判断）, 可以有多个”核心”（通过<code>core id</code>区分判断）, 每个核可以有多个”逻辑cpu”（通过<code>processor</code>区分判断）</p><ul><li>物理Cpu数: <code>cat /proc/cpuinfo | grep &quot;physical id&quot; | sort -u |wc -l</code> 输出2</li><li>核心数: <code>cat /proc/cpuinfo | grep &quot;core id&quot; | sort -u |wc -l</code> 输出8</li><li>逻辑Cpu数: <code>cat /proc/cpuinfo | grep &quot;processor&quot; | sort -u | wc -l</code>  输出32</li></ul><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><ul><li><code>ps -ef</code> : e参数列出所有(用户)的进程, f列出PPID;</li><li><code>ps aux</code> : 能显示出更多的线程信息, 比如”VSZ”,”RSS”,”TTY”,”STAT”.</li><li><code>ps -l</code> : 列出进程优先级(PRI), Nice值(NI),内存占用(SZ)</li><li><code>ps -T -p &lt;pid&gt;</code> : 查看进程的所有线程</li></ul><h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND</span><br><span class="line">root                47   0.0  0.0  2502056   1700   ??  Ss   一09上午   0:11.65 /usr/libexec/kextd</span><br><span class="line">root                45   0.0  0.2  2503976   6576   ??  Ss   一09上午   0:29.45 /usr/libexec/UserEventAgent (System)</span><br><span class="line">root                44   0.0  0.0  2472460   1204   ??  Ss   一09上午   0:32.91 /usr/sbin/syslogd</span><br><span class="line">beefymiracle       424  98.7  0.1  2507128   4764   ??  R    一09上午 1762:56.80 /System/Library/PrivateFrameworks/ParsecUI.framework/Versions/A/Support/SpotlightNetHelper.app/Contents/MacOS/SpotlightNetHelper</span><br></pre></td></tr></table></figure><ul><li><p>VSZ：KB, virtual memory size, Device mappings are currently excluded;</p></li><li><p>RSS：KB, resident set size, 一般作为实际占用内存大小,<br>包括程序二进制映像(binary image), Heap/Stack实际使用(系统为进程分配的堆和栈, 不一定完全用掉), 共享区(shared Library, 也即Memory Mapping)实际使用的空间;</p></li><li><p>区分VSZ,RSS,SZ <a href="http://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management" target="_blank" rel="noopener">http://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management</a></p></li><li><p>STAT：R/S/D/T/Z/X  @ref: <a href="http://askubuntu.com/questions/360252/what-do-the-stat-column-values-in-ps-mean" target="_blank" rel="noopener">http://askubuntu.com/questions/360252/what-do-the-stat-column-values-in-ps-mean</a></p></li></ul><blockquote><p>进程状态 R S D T X Z:<br>R: Running<br>S: Interruptible Sleep, 可中断的睡眠<br>D: Uninterruptible Sleep. 不可中断的睡眠, 比如等待磁盘IO, 这种进程不接受kill,kill -9的信号<br>T: Stoped, 按下Ctrl+Z的状态</p></blockquote><h3 id="ps-el"><a href="#ps-el" class="headerlink" title="ps -el"></a>ps -el</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD</span><br><span class="line">  0     1     0     4004   0  37  0  2478772   7372 -      Ss                  0 ??         3:01.68 /sbin/launchd</span><br><span class="line">  0    44     1     4004   0   4  0  2474032   1228 -      Ss                  0 ??         0:32.87 /usr/sbin/syslogd</span><br><span class="line">501   424     1     4004   0   4  0  2506604   4952 -      R                   0 ??       1757:31.24 /System/Library/PrivateFrameworks/ParsecUI.framework/Versions/A/Support/SpotlightNetHelper.app/Contents/MacOS/SpotlightNetHelper</span><br></pre></td></tr></table></figure><ul><li><p>SZ：size in physical pages of the core image of the process. This includes text, data, and stack space. Device mappings are currently excluded</p></li><li><p>PRI：PRI表示线程优先级(数值越小越先执行), 优先级的范围是[0, MAX_PRIO-1], <code>MAX_PRIO</code> 的值一般为140.</p></li><li><p>NI 修正优先级：</p><ul><li>NI=Nice, 值表示对优先级PRI的修正, 范围从-20~19, Nice越小表示优先级越高.</li><li>以指定Nice启动任务: <code>nice -n -5 /usr/bin/mysqld &amp;</code>, 注意这里<code>-5</code>并不是表示负数, 而是正数5, 如果要以高优先级启动某进程(负的Nice值), 则应该为<code>nice -n --5 top</code>.</li><li>使用nohup: <code>nohup -n 10 COMMANDS</code></li><li>改变已存在进程的优先级: <code>renice -5 -p 1203</code>注意这里的”-5”表示负数.</li></ul></li></ul><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><ul><li>pstree -apu 显示进程树</li><li>-a 显示进程的命令行</li><li>-p 显示PID</li><li>-u 显示UID, 如果子进程和父进程的UID不同, 比如Nginx启动worker线程用nobody</li></ul><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><ul><li>查看指定进程: <code>top -d 1 -p 1021</code>, 解释: -d 刷新间隔, -p 进程号, <a href="http://javawind.net/p131" target="_blank" rel="noopener">每列”VIRT”, “RES”, “SHR”的表示含义</a><ul><li>VIRT: 进程“需要的”虚拟内存大小, 包括库/代码/数据, <code>VIRT = SWP + RES</code></li><li>RES:  常驻内存(Resident memory), 包括共享内存, <code>进程实际占用内存 = RES - SHR</code></li><li>SHR:  共享内存(Shared memory), 比如动态库</li></ul></li><li>某个进程占用的CPU和内存也可以用<code>ps -aux</code>查看, 其中<code>RSS</code>(Resident Set Size)表示实际RAM使用, <code>VSZ</code>(Virtual Memory Size)包括程序占用的SWAP空间, 和使用的shared libraries所占用的空间.</li><li>或者, 直接查看<code>/proc/PID/status</code>文件也可以得知进程占用RAM的情况.</li><li>查看线程: <code>top -H</code>, 查看指定进程的线程: <code>top -H -p &lt;pid&gt;</code></li></ul><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><ul><li><a href="https://www.quora.com/What-is-the-difference-between-Buffers-and-Cached-columns-in-proc-meminfo-output" target="_blank" rel="noopener">What is the difference between Buffers and Cached columns in /proc/meminfo output?</a><ul><li>Buffer 是准备写入块设备的数据, 存储了文件的目录/权限等metadata;</li><li>Cache  频繁访问的文件都会被cache, 里面只有文件内容数据;</li></ul></li></ul><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@tc_157_46 ~]# vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 3 23   2840 3118492 110100 21213972    0    0    19   201    0    0  1  1 97  1  0</span><br></pre></td></tr></table></figure><p>vmstat每列解释:</p><ul><li>procs列<ul><li>r 等待cpu时间片的进程数, 如果长期大于1, 说明cpu不足, 需要增加cpu.</li><li>b (在等待资源的进程数, 比如正在等待I/O, 或者内存交换等).</li></ul></li><li>memory列<ul><li>swpd 虚拟内存大小(交换区). 如果swpd的值不为0, 比如超过了100m, 只要si, so的值长期为0, 系统性能还是正常</li><li>free 空闲内存大小</li><li>buff 做为buffer的内存大小, 一般对块设备的读写才需要缓冲.</li><li>cache: 做为page cache的内存大小, 一般做为文件系统的cache, 如果cache较大, 说明用到cache的文件较多, 如果此时IO中bi比较小, 说明文件系统效率比较好.</li></ul></li><li>swap列<ul><li>si 每秒由内存进入内存交换区数量.</li><li>so 每秒由内存交换区进入内存数量.</li></ul></li><li>io列<ul><li>bi 每秒从块设备读取数据的Blocks, 一个Block =1024byte</li><li>bo 每秒块设备写入数据的总量 // 这里我们设置的bi+bo参考值为1000, 如果超过1000(1MB), 而且wa值较大应该考虑均衡磁盘负载, 可以结合<code>iostat</code>输出来分析.</li></ul></li><li>system列<ul><li>in 每秒设备中断数.</li><li>cs 每秒产生的上下文切换次数, 如当cs比磁盘I/O和网络信息包速率高得多, 都应进行进一步调查.</li></ul></li><li>cpu列<ul><li>us 用户进程所占时间的百分比. 如果长期大于50%, 需要考虑优化用户的程序, 比如加密解密等运算.</li><li>sy 系统进程所占时间的百分比. 这里<code>us+sy</code>的参考值为80%, 如果<code>us+sy</code>大于80%说明可能存在CPU不足.</li><li>wa IO等待所占用的CPU时间百分比. 这里wa的参考值为30%, 如果wa超过30%, 说明IO等待严重, 这可能是磁盘大量随机访问造成的, 也可能磁盘或者磁盘访问控制器的带宽瓶颈造成的(主要是块操作).</li><li>id 空闲状态的CPU时间百分比</li></ul></li></ul><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>命令格式: <code>iostat [option] [间隔秒数] [统计次数]</code> , 比如<code>iostat -x 1 10</code>表示1秒打印一次, 共10次</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@tc_157_46 ~]# iostat -x 1 1</span><br><span class="line">Linux 2.6.18-274.el5 (tc_157_46)        07/26/2016</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.18    0.00    1.01    1.06    0.00   96.75</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util</span><br><span class="line">sda               1.34   747.37  4.12 55.96   600.54  6426.98   116.95     0.03    0.49   0.38   2.25</span><br><span class="line">sda1              0.00     1.56  0.01  0.66     0.25    17.76    26.94     0.03   38.49  11.73   0.78</span><br><span class="line">sda2              0.00     0.01  0.00  0.00     0.02     0.04   106.87     0.00   88.03   7.93   0.00</span><br><span class="line">sda3              0.01     1.31  0.04  1.94     1.34    26.02    13.83     0.02   11.81   8.91   1.76</span><br><span class="line">sda4              0.00     0.00  0.00  0.00     0.00     0.00     7.40     0.00  110.47 110.47   0.00</span><br><span class="line">sda5              0.01     0.36  0.02  0.25     0.59     4.84    20.14     0.01   41.69  17.49   0.47</span><br><span class="line">sda6              1.32   744.13  4.05 53.12   598.33  6378.33   122.03     0.03    0.52   0.18   1.00</span><br></pre></td></tr></table></figure><ul><li>%util: IO操作占用CPU时间的百分比: 如果%util长期接近100%, 说明产生的I/O请求太多, I/O系统已经满负荷, 该磁盘可能存在瓶颈.</li><li>Idle如果长期大于70% IO压力就比较大了,这时一般读取速度有较多的wait.</li></ul><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>查看系统的不同时间段的状况, CPU, load, 页面交换</p><ul><li>CPU<ul><li>sar 或sar -u:  查看CPU占用状况</li><li>sar -q 查看任务队列, 同load</li></ul></li><li>内存<ul><li>sar -r 查看内存使用, 同free</li><li>sar -W 查看Swap区的数据交换状况, 怀疑Swap频繁导致系统变慢可以使用</li></ul></li><li>IO<ul><li>sar -b</li><li>sar -d 1 5: 一秒每次, 共5次, 显示实时的信息</li></ul></li><li>网卡<ul><li>sar -n DEV 1 5:  一秒每次, 共5次, 显示实时的信息</li></ul></li></ul><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>查看TCP的并发数/TCP连接的状态, 以一个Nginx服务器为例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[@zw_85_63 ~]# netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br><span class="line">TIME_WAIT 37968</span><br><span class="line">SYN_SENT 1</span><br><span class="line">FIN_WAIT1 5</span><br><span class="line">FIN_WAIT2 4</span><br><span class="line">ESTABLISHED 2725</span><br><span class="line">SYN_RECV 18</span><br><span class="line">LAST_ACK 4</span><br></pre></td></tr></table></figure><p>→ <a href="/21.Operating-System/Linux.02.网络命令/" title="Linux.02.网络命令">Linux.02.网络命令</a></p><h1 id="sysctl优化内核参数"><a href="#sysctl优化内核参数" class="headerlink" title="sysctl优化内核参数"></a>sysctl优化内核参数</h1><p>获取当前内核参数的设定值:</p><ul><li>sysctl -a | grep vm</li><li>sysctl -a | grep net.ipv4</li></ul><p>使用 sysctl 调整内核参数, 例:  <code>sysctl -w net.ipv4.tcp_syncookies=0</code>, 更多参考→ <a href="/21.Operating-System/Linux.04a.Sysctl/" title="Linux.04a.Sysctl">Linux.04a.Sysctl</a></p><p>@ref</p><ul><li>并发相关的内核参数调整参考 : <a href="https://whatsdjgpp.github.io/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Arch-%E6%9E%B6%E6%9E%84-%E5%B9%B6%E5%8F%91/" target="_blank" rel="noopener">后端架构-并发(C10K/C100K) | 扔掉笔记</a></li></ul><hr><h1 id="附：Linux-Performance-Tools（图）"><a href="#附：Linux-Performance-Tools（图）" class="headerlink" title="附：Linux Performance Tools（图）"></a>附：Linux Performance Tools（图）</h1><p><img src="/images/operating_system/linux-performance-benchmark-tools.png" alt="Linux-Performance-Benchmark-Tools"></p><p><img src="/images/operating_system/linux-performance-tuning-tools.png" alt="Linux-Performance-Tuning-Tools"></p><p><img src="/images/operating_system/linux-performance-observability-sar.png" alt="Linux-Performance-Observability-Sar"></p><blockquote><p>来源: <a href="https://colobu.com/2014/09/18/Linux-Performance-Analysis-and-Tools/" target="_blank" rel="noopener">https://colobu.com/2014/09/18/Linux-Performance-Analysis-and-Tools/</a></p></blockquote><h1 id="附：线上服务器的数据"><a href="#附：线上服务器的数据" class="headerlink" title="附：线上服务器的数据"></a>附：线上服务器的数据</h1><p>平均值~峰值:</p><ul><li><strong>Nginx &amp; Memcache</strong>:<ul><li>load少于0.1, iowait少于0.1%,</li><li>User:System时间大约10%:5%(峰值), 每秒上下文切换(用vmstat查看cs)20-50K,</li><li>打开TCP连接4000, 带宽200Mbps （千兆网卡）</li></ul></li><li><strong>Redis</strong>:<ul><li>load少于0.1, iowait少于0.1%,</li><li>User:System时间不到0.1%(峰值), 每秒上下文切换2-4K+,</li><li>打开TCP连接数600, 带宽2.0Mbps</li></ul></li><li><strong>Resin</strong>:<ul><li>load少于0.2, iowait少于0.2%,</li><li>User:System时间大约15%:2%(峰值), 每秒上下文切换30~60K,</li><li>打开TCP连接数1500, 带宽40~80Mbps,</li></ul></li><li><strong>Hadoop</strong>:<ul><li>load大约0.5~1.5, iowait时间2%-20%, 峰值iowait能到35% ( 一般大于30%需要排查 )</li><li>User:System时间大约15%:1%, 每秒上下文切换2-7K,</li><li>打开TCP连接数, 带宽20-70Mbps</li></ul></li><li><strong>Flume</strong>:<ul><li>load少于0.1, iowait少于0.1%,</li><li>User:System时间大约5%:1%, 每秒上下文切换30-60K,</li><li>打开TCP连接数, 带宽5-25Mbps</li></ul></li></ul><blockquote><p>注: 上面Hadoop机器的iowait有问题, 数据选自一台硬盘有问题的机器</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/operating_system/Linux-Series-Title.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;tldr&quot;&gt;&lt;a href=&quot;#tldr&quot; class=&quot;headerlink&quot; title=&quot;@tldr&quot;&gt;&lt;/a&gt;@tldr&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cpu&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;uptime 查看load值, 不高于core数, &lt;code&gt;sar -q&lt;/code&gt;也可以查看load值&lt;/li&gt;
&lt;li&gt;vmstat: 关注r(同load), 和b(等待资源的进程数), 以及cpu占用(用户进程和内核进程)时间百分比: us%不超过50%, us% + sy%不超过80%&lt;/li&gt;
&lt;li&gt;sar也可以查看us% sy%占用CPU时间百分比&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;free: 可用内存小于20%需要关注, &lt;code&gt;sar -r&lt;/code&gt;类似&lt;/li&gt;
&lt;li&gt;vmstat的si和so: 一般不应该大于0, &lt;code&gt;sar -W&lt;/code&gt;也可以查看交换区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;vmstat: 需关注wa(IO等待占用CPU百分比): 大于30%时需关注, bi/bo也需要关注(阈值?)&lt;/li&gt;
&lt;li&gt;iowait: sar也可以查看iowait%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络&lt;/strong&gt;:&lt;ul&gt;
&lt;li&gt;netstat -antp : 查看所有tcp连接&lt;/li&gt;
&lt;li&gt;iperf: 吞吐量(Throughput) , 大约为网卡最大速率的一半&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基础性能参数&quot;&gt;&lt;a href=&quot;#基础性能参数&quot; class=&quot;headerlink&quot; title=&quot;基础性能参数&quot;&gt;&lt;/a&gt;基础性能参数&lt;/h1&gt;&lt;h2 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;load&quot;&gt;&lt;/a&gt;load&lt;/h2&gt;</summary>
    
    
    
    <category term="21.Operating-System" scheme="https://beefyheisenberg.github.io/categories/21-Operating-System/"/>
    
    
    <category term="Linux" scheme="https://beefyheisenberg.github.io/tags/Linux/"/>
    
    <category term="Linux命令行" scheme="https://beefyheisenberg.github.io/tags/Linux命令行/"/>
    
    <category term="后端技术" scheme="https://beefyheisenberg.github.io/tags/后端技术/"/>
    
    <category term="系统性能分析" scheme="https://beefyheisenberg.github.io/tags/系统性能分析/"/>
    
  </entry>
  
  <entry>
    <title>Linux.02.网络命令行</title>
    <link href="https://beefyheisenberg.github.io/21.Operating-System/Linux.02.%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/"/>
    <id>https://beefyheisenberg.github.io/21.Operating-System/Linux.02.%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2023-04-28T00:14:16.912Z</published>
    <updated>2023-04-28T00:14:16.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>ping是通过发送ICMP报文(回显请求), 并等待回显请求的应答, 目标主机的防火墙可能对ICMP报文做了限制, 所以ping不通不代表无法ssh.</p><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><ul><li><p>启动关闭指定网卡</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure></li><li><p>配置IP地址 <code>ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</code></p></li></ul><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>显示建立的网络连接, 分为三种: tcp/udp/unix(进程通讯)</p><ul><li><code>netstat -au</code> : 显示所有udp连接</li><li><code>netstat -at</code> : 显示所有tcp连接</li><li><code>netstat -nlt</code> :<ul><li>-n 显示ip而非域名</li><li>-l 显示所有listen状态的连接</li><li>-p 显示出连接对应的进程, 需要root权限才能看到</li></ul></li><li><code>netstat -r</code> : 显示路由表/网关, 同 route返回的</li></ul><h2 id="nslookup-dig"><a href="#nslookup-dig" class="headerlink" title="nslookup, dig"></a>nslookup, dig</h2><p>nslookup, dig 都是DNS查询命令:</p><ul><li><strong>nslookup</strong>: 用于对DNS正向解析 &amp; 返向解析;<ul><li><code>nslookup a.xxx.com</code> 使用默认dns查询网址的dns记录</li><li><code>nslookup a.xxx.com 8.8.8.8</code> 使用指定dns服务器查询dns记录</li></ul></li><li><strong>dig</strong>: 是一个用于询问DNS 域名服务器的灵活的工具。它执行DNS 查询，显示从已查询名称服务器返回的应答。<ul><li><code>dig</code>: 显示13个根域服务器</li><li><code>dig www.baidu.com</code>: 使用默认dns查询网址的dns记录</li><li><code>dig @8.8.8.8 www.yahoo.com</code>: 使用指定dns服务器查询dns记录</li></ul></li></ul><h2 id="route"><a href="#route" class="headerlink" title="route"></a>route</h2><ul><li>命令格式 <code>route add 目标网段 gw 网关地址 dev 设备</code></li><li>增加默认网关 <code>route add default gw 192.168.0.254</code></li><li>增加网关: <code>route add -net 192.168.1.0 netmask 255.255.255.128 gw 192.168.1.129 dev eth0</code></li><li>删除网关: <code>route del -net 192.168.1.0 netmask 255.255.255.128 dev eth0</code></li><li><p>查看内核路由表: <code>route</code>, 返回如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.6.0     *               255.255.255.0   U     0      0        0 eth0</span><br><span class="line">link-local      *               255.255.0.0     U     1002   0        0 eth0</span><br><span class="line">default         192.168.6.253   0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><ul><li>Destination : 目标网段或者主机，Destination 为 default（<code>0.0.0.0</code>）时，表示这个是默认网关，所有数据都发到这个网关</li><li>Gateway : 网关地址。如果是<code>*</code>表示目标是本主机所属的网络不需要路由</li><li>Genmask : 网络掩码</li><li>Flags : 标记。一些可能的标记如下：<ul><li>U — 路由是活动的</li><li>H — 目标是一个主机</li><li>G — 路由指向网关</li></ul></li></ul></li></ul><pre><code>例如，在下面的示例中，本地主机将发送到网络192.19.12的数据包转发到IP地址为192.168.1.1的路由器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Destination    Gateway       Genmask Flags    Metric    Ref     Use    Iface</span><br><span class="line">-----------    -------     -------         -----    -----   ---    ---    -----</span><br><span class="line">192.19.12     192.168.1.1    255.255.255.0      UN      0       0     0    eth0</span><br></pre></td></tr></table></figure>例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Destination    Gateway       Genmask Flags     Metric    Ref    Use    Iface</span><br><span class="line">-----------    -------     ------- -----      ------    ---    ---    -----</span><br><span class="line">default       192.168.1.1     0.0.0.0    UG       0        0     0    eth0</span><br></pre></td></tr></table></figure></code></pre><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><blockquote><p>当ping不到或者丢包严重时, 使用traceroute可以看到从当前计算机到目标主机每一跳的耗时情况, 在哪一个节点丢包等细节</p></blockquote><p>例子:</p><ul><li><code>traceroute -I a.com</code> : 使用ICMP ECHO</li><li><code>traceroute -T a.com</code> : 使用TCP SYN</li><li><code>traceroute -p 8080 a.com</code> : 查询到主机指定端口的路由</li></ul><p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。</p><p>linux系统中，我们称之为 <code>traceroute</code>,在MS Windows中为 <code>tracert</code>。</p><p>traceroute的工作机制主要是利用使用ICMP报文和和IP首部中的TTL（Time to Live?）字段来实现的。在网络数据包的传输过程中，每个处理处理数据包的路由器都要讲数据包的TTL值减1或者减去数据报在路由器中停留的秒数，由于大多数的路由器转发数据报的延时都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1。TTL字段的目的是防止数据报在网络中无休止的流动。当路由器收到一份IP数据报，如果TTL字段是0或者1，则路由器不转发该数据报（接收到这种数据报的目的主机可以将它交给应用程序，这是因为不需要转发该数据报。但是，在通常情况下系统不应该接收TTL字段为0的数据报）。通常情况下是，路由器将该数据报丢弃，并给信源主机发送一份ICMP超时信息。tracerouter程序的关键在于，这份ICMP超时信息包含了该路由器的地址。<br>tracerouter利用网络协议的这种机制，TTL值从1开始每次发送一个TTL等于上次值加一的数据包，直到收到目的主机的响应才停止。这样就能拿到数据包经过路径上的每个路由器的地址信息，从而打印路由信息。<br>有些情况下traceroute无法到达最终节点(traceroute一台主机时，会看到有一些行是以星号表示的) 有可能因为主机屏蔽了ICMP回显, 对于有HTTP服务的服务器, 可以使用-p 指定端口使用TCP协议进行探测<code>traceroute -T -p 80 a.xxx.com</code> (在 macOS上好像不支持-T)</p><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>探测远端机器端口 <code>nmap 192.168.1.1 -p 80</code></p><h2 id="nc-netcat"><a href="#nc-netcat" class="headerlink" title="nc(netcat)"></a>nc(netcat)</h2><ul><li>接受文件: <code>nc -4 -l -p local_port &gt; file</code> 说明:  <code>-4</code>是指IPv4, 如果默认<code>-6</code>有问题就试试这个, <code>-l</code>=listen, <code>-p</code>=port</li><li>发送文件: <code>nc dest_ip dest_port &lt; file</code></li></ul><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>=&gt; [[../22.Network-Protocol/Tcpdump]]</p><h2 id="网卡吞吐量-Throughput"><a href="#网卡吞吐量-Throughput" class="headerlink" title="网卡吞吐量(Throughput)"></a>网卡吞吐量(Throughput)</h2><p><img src="/images/operating_system/Linux-Net-Throughput-A-Day.png" alt=""></p><h3 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h3><p><img src="/images/operating_system/Linux-Net-Throughput-Iftop.png" alt=""></p><p>iftop底部会显示一些全局的统计数据，peek 是指峰值情况，cumm 是从运行至今的累计情况，而 rates 表示最近 2 秒、10 秒、40 秒内总共接收或者发送的平均网络流量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TX:  cumm:   143MB   peak:   10.5Mb    rates:   1.03Mb  1.54Mb  2.10Mb</span><br><span class="line">RX:          12.7GB          228Mb              189Mb   191Mb   183Mb</span><br><span class="line">TOTAL:       12.9GB          229Mb              190Mb   193Mb   185MbW</span><br></pre></td></tr></table></figure><h3 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h3><ul><li>server: <code>iperf -s</code></li><li>client: <code>iperf -c 192.168.0.138 -t 60 -l 8k -i 10</code> // 进行60秒测试, 缓冲区大小8k, 每10秒打印一次结果</li></ul><blockquote><p>测试阿里云服务器大约67.5 Mbits/sec, 似乎是Mac无线网卡的限制…内网的两台服务器测试(非同一机房) 450 Mbits/sec</p></blockquote><h3 id="netperf"><a href="#netperf" class="headerlink" title="netperf"></a>netperf</h3><ul><li>server端: <code>netserver</code></li><li>client端测试tcp: <code>./netperf -t TCP_STREAM -H 192.168.0.138 -l 60 -- -m 2048</code> # 测试时长60秒, 发送分组大小2048 Bytes</li><li>client端测试udp: <code>./netperf -t UDP_STREAM -H 192.168.0.138 -l 60 -- -m 2048</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ping&quot;&gt;&lt;a href=&quot;#ping&quot; class=&quot;headerlink&quot; title=&quot;ping&quot;&gt;&lt;/a&gt;ping&lt;/h2&gt;&lt;p&gt;ping是通过发送ICMP报文(回显请求), 并等待回显请求的应答, 目标主机的防火墙可能对ICMP报文做了限制, 所以ping不通不代表无法ssh.&lt;/p&gt;
&lt;h2 id=&quot;ifconfig&quot;&gt;&lt;a href=&quot;#ifconfig&quot; class=&quot;headerlink&quot; title=&quot;ifconfig&quot;&gt;&lt;/a&gt;ifconfig&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动关闭指定网卡&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ifconfig eth0 up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ifconfig eth0 down&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置IP地址 &lt;code&gt;ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;netstat&quot;&gt;&lt;a href=&quot;#netstat&quot; class=&quot;headerlink&quot; title=&quot;netstat&quot;&gt;&lt;/a&gt;netstat&lt;/h2&gt;</summary>
    
    
    
    <category term="21.Operating-System" scheme="https://beefyheisenberg.github.io/categories/21-Operating-System/"/>
    
    
    <category term="Linux" scheme="https://beefyheisenberg.github.io/tags/Linux/"/>
    
    <category term="Linux命令行" scheme="https://beefyheisenberg.github.io/tags/Linux命令行/"/>
    
    <category term="网络" scheme="https://beefyheisenberg.github.io/tags/网络/"/>
    
  </entry>
  
  <entry>
    <title>Linux.01.常用命令行</title>
    <link href="https://beefyheisenberg.github.io/21.Operating-System/Linux.01.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>https://beefyheisenberg.github.io/21.Operating-System/Linux.01.%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2023-04-28T00:14:16.901Z</published>
    <updated>2023-04-28T00:14:16.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令全称"><a href="#命令全称" class="headerlink" title="命令全称"></a>命令全称</h2><p>=&gt; <a href="/21.Operating-System/Linux.01a.常用命令行全称速记/" title="Linux.01a.常用命令行全称速记">Linux.01a.常用命令行全称速记</a></p><h2 id="使用-man"><a href="#使用-man" class="headerlink" title="使用 man"></a>使用 man</h2><p>man 可以查看”系统命令/系统调用函数/glibc库函数” 等等共9类内容, 例如 <code>man lsof</code> 第一行是 “LSOF(8)”, 表示是第8类, <code>man man</code> 第一行是”man(8)” 表示man 是第8类, 也可以看到所有9类 “manual”, 如下:</p><blockquote><ol><li>系统命令</li><li>系统调用，一般是对应的C封装函数；所有系统调用的函数在调用发生时都会进入内核空间执行</li><li>各种库函数手册，例如glibc，pthread库API等，如果是非C库，则会标注出对于的链接选项</li><li>特殊设备文件，例如zero, mem等</li><li>文件格式手册，描述Linux支持的各种文件系统以及对于的C接口结构，如vfat/iso</li><li>游戏程序文档</li><li>其它的各种各样不在前边分类的文档（8/9除外）</li><li>系统管理员命令，一般仅供root用户使用，如cron/useradd等</li><li>Linux内核相关部分的手册，一般情况很少用到，这一节就没有intro介绍页</li></ol></blockquote><ul><li><code>man ascii</code>: 该命令用来查看 ASC II表</li><li><code>man malloc</code>: 查看malloc用法, 如果显示 “No manual entry for malloc”, 则需要安装 “man-pages”: <code>yum -y install man-pages</code></li></ul><h2 id="ps-top-free-vmstat"><a href="#ps-top-free-vmstat" class="headerlink" title="ps, top, free, vmstat"></a>ps, top, free, vmstat</h2><p><code>vmstat</code>, <code>sar</code>, <code>iostat</code>, <code>iotop</code> @link: <a href="/21.Operating-System/Linux.03.命令行-Performance/" title="Linux.03.命令行-Performance">Linux.03.命令行-Performance</a></p><h2 id="sort-uniq-wc-cut"><a href="#sort-uniq-wc-cut" class="headerlink" title="sort, uniq, wc, cut"></a>sort, uniq, wc, cut</h2><ul><li><p><code>sort</code>参数:</p><ul><li>-t 指定分隔符</li><li>-n 按数字大小排序, 如果不加-n默认是ASCII码排序</li><li>-r 倒序</li><li>-k 1,5 指定按哪一列排序, 默认是从第N列到行尾, <code>-k4</code>指定按第四列排序</li></ul><blockquote><p>例:<br>按进程VSS内存排序: <code>ps aux | tr -s &quot; &quot; | sort -nrk 5 | cut -d &quot; &quot; -f 1,2,5,6,11- | more</code><br>分隔符为”:”的文件按照第5列数值排序: <code>cat file | sort -t : -nrk 1,5</code></p></blockquote></li><li><p><code>uniq</code>只能去除相邻行的重复, 所以一般跟<code>sort</code>联用.</p><ul><li>-c: 去重+统计次数</li><li>sort联用: <code>cat /proc/cpuinfo | grep &#39;physical id&#39; | sort | uniq | wc -l</code></li></ul></li><li><code>wc</code>:<ul><li>-l: 统计行数</li><li>-w: 统计单词数</li></ul></li><li><p><code>cut</code>用来显示行中的指定部分, 分隔符用-d 参数(如果不加-d参数则分隔符是制表符), 取出第几列用-f 参数(从1开始),<br>例: <code>who | cut -d &#39; &#39; -f 2</code></p><blockquote><p>注: cut通常和其他命令一起使用, 用来处理其他命令的输出, 但实际情况下很多命令的分隔符并不统一, 所以用 awk比 cut更方便: <code>ls -l | awk &#39;{print $9}&#39;</code></p></blockquote></li></ul><h2 id="chmod-chown-chgrp"><a href="#chmod-chown-chgrp" class="headerlink" title="chmod, chown, chgrp"></a>chmod, chown, chgrp</h2><p>通过<code>ls -l</code>查看文件属性:<br><img src="/images/linux-file-rwx.png" alt="linux-file-rwx"></p><ul><li><code>chmod [-R] xyz 文件或目录名</code>: xyz三个数字即 owner/group/other的 rwx属性之和 (r=4, w=2, x=1)<ul><li><code>chmod 640 file1</code>         // 给user读写权限, group读权限, other无权限</li><li><code>chmod u=rw,g=r,o= file1</code> // 同<code>chmod 640</code></li><li><code>chmod -R o-r /home/*</code>    // 把other的读权限都去掉. chmod支持<code>+</code>,<code>-</code>,<code>=</code>符号.</li></ul></li><li><code>chown [–R] 属主名 文件名</code> or <code>chown [-R] 属主名：属组名 文件名</code></li><li><code>chgrp [-R] 属组名 文件名</code></li></ul><blockquote><p>注: 目录的x权限指可以cd到这个目录, 目录的r权限指可以遍历目录下的文件,<br>父级目录和子文件的权限互不影响, 例如用户有父级目录的x权限, 但目录下的文件不会继承x权限, 但是如果要执行目录下文件, 前提是能切到父级目录, 意味着父级目录要有x权限</p></blockquote><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><ul><li>创建软链接: <code>ln -s src target</code>  // 记住 <code>ln ... as ...</code></li><li>创建硬链接: <code>ln src target</code></li><li>软链接vs硬链接:<ul><li>允许对目录创建软链接,硬链接不可以</li><li>可以跨文件系统创建软链接, 硬链接不可以</li><li>删除源文件, 软链接将失效, 硬链接仍保留删除前源文件内容</li></ul></li></ul><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">理解 Linux 的硬链接与软链接</a></p></blockquote><h2 id="gzip-bzip2-tar"><a href="#gzip-bzip2-tar" class="headerlink" title="gzip, bzip2, tar"></a>gzip, bzip2, tar</h2><p><img src="/images/operating_system/linux-compress-cmd.png" alt="linux_compress_cmd"></p><p>压缩与读压缩命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -v file1    # 压缩为gz格式</span><br><span class="line">bzip2 -z file1   # 压缩为bz2格式</span><br><span class="line"></span><br><span class="line">zcat file1.gz    # 不解压读取gz</span><br><span class="line">bzcat file1.bz2  # 不解压读取bz2</span><br><span class="line"></span><br><span class="line">gzip -d file1.gz   # 解压gz</span><br><span class="line">bzip2 -d file1.bz2 # 解压bz2</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: gzip压缩后不保留源文件, bzip2必须加<code>-k</code>参数才保留源文件</p></blockquote><p>打包与解包:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar cvzf file1 file1.tar.gz   # 打包为 tar.gz</span><br><span class="line">tar cvjf file1 file1.tar.bz2  # 打包为 tar.bz2</span><br><span class="line"></span><br><span class="line">tar xvzf file1.tar.gz</span><br><span class="line">tar xvjf file1.tar.bz2</span><br></pre></td></tr></table></figure></p><h2 id="where-which-locate"><a href="#where-which-locate" class="headerlink" title="where, which, locate"></a>where, which, locate</h2><p>功能和which类似, 也是一种查找, 区别在于locate搜索的是数据库/var/lib/locatedb所以速度更快, 例如<code>locate _vimrc</code></p><h2 id="sed-awk"><a href="#sed-awk" class="headerlink" title="sed, awk"></a>sed, awk</h2><p>@ref: <a href="https://whatsrtos.github.io/Linux/Linux-Sed_Awk_Grep/" target="_blank" rel="noopener">sed &amp; awk &amp; grep</a></p><h2 id="find-grep-ack"><a href="#find-grep-ack" class="headerlink" title="find, grep, ack"></a>find, grep, ack</h2><ul><li><strong>find</strong>:<ul><li>按时间查找, 可用参数有: <code>-mmin</code> 以分钟为单位, <code>-mtime</code> 以天为单位, 后面的数字<code>+</code>表示比该时间更早, <code>-</code>表示该时间之后-当前,<ul><li>查找N天之前更早的: <code>find . -mtime +3 -name &#39;*.log&#39;</code></li><li>查找N天前~当前时刻的: <code>find . -mtime -3 -name &#39;*.log&#39;</code></li></ul></li><li>在当前目录及其子目录下查找符号链接文件: <code>find -type l</code></li><li>在当前目录及其子目录下查文件夹: <code>find -type d</code></li><li>在当前目录查找普通文件: <code>find -type f</code></li><li>在root目录下及其最大3层深度的子目录中查找: <code>find / -max-depth 3 -name log</code></li><li>查找特定文件并ls列出: <code>find -name *.java -exec ls -l {} \;</code> 注意exec的参数必须以”分号”结束,分号还要加转义符.解释:<ul><li><code>{}</code>是前面find找到的文件,</li><li><code>-exec</code>后面的参数后面跟的是command命令, 它的终止是以<code>;</code>为结束标志的, 所以这句命令后面的”分号”是不可缺少的, 考虑到各个系统中分号会有不同的意义, 所以前面加反斜杠.  参考 <a href="https://stackoverflow.com/questions/6085156/using-semicolon-vs-plus-with-exec-in-find" target="_blank" rel="noopener">Using semicolon (;) vs plus (+) with exec in find - Stack Overflow</a></li><li>shell的内建命令<code>-exec</code>将并不启动新的shell, 而是用要被执行命令替换当前的shell进程, 并且将老进程的环境清理掉, 而且exec命令后的其它命令将不再执行. 以新的进程去代替原来的进程, 但进程的PID保持不变.</li></ul></li><li>与xargs配合使用: <code>find find -name *.java | xargs rm -f</code></li></ul></li></ul><blockquote><p>文件的 atime, mtime,ctime<br>atime: 文件访问时间, 用<code>touch</code>,<code>vi</code>等命令都会修改这个时间<br>ctime: 文件元数据(所属人,读写权限..) <code>chown</code>,<code>chmod</code>都会…<br>mtime: 文件内容修改时间, ps修改了文件内容, 文件元数据也会变化<br><code>ls -l</code> 列出来的是ctime<br>命令<code>stat fileName</code>返回如下</p></blockquote><p><img src="/images/2021/20211227145907.png" alt=""></p><ul><li><p><strong>grep</strong>:</p><ul><li>查找某个文件: <code>grep &quot;Invalid user&quot; /var/log/auth.log</code></li><li>查找多个Word: <code>grep -E &quot;word1|word2&quot;</code></li><li>在某个目录下递归查找: <code>grep -irn &quot;xxx&quot; /dir</code></li><li>与<code>find</code>一起使用: <code>find . -name &quot;*.css&quot; | xargs grep &quot;monospac&quot;</code></li></ul><blockquote><p>grep = globally search for regular expression and print out // @ref: <a href="https://www.geeksforgeeks.org/grep-command-in-unixlinux/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/grep-command-in-unixlinux/</a></p></blockquote></li><li><p><strong>ack</strong>:</p><ul><li><code>ack xxxx dir/log1</code>: 在指定文件里搜索xxx</li><li><code>ack --java xxxx</code>: 在java文件里搜索xxx</li><li><code>ack -i xxx</code>: 不区分大小写</li><li><code>ack -w xxx</code>: 全词匹配</li></ul></li></ul><h2 id="who-w-whoami-last"><a href="#who-w-whoami-last" class="headerlink" title="who, w, whoami, last"></a>who, w, whoami, last</h2><ul><li><code>w</code> - Show who is logged on and what they are doing.</li><li><code>who</code> - show who is logged on</li><li><code>whoami</code> - print effective userid</li><li><code>who am i</code> - When a user logs in as a root across the network, both the command</li><li><code>whoami</code> and <code>who am i</code> will show you root. However, when a user abc logs in remotely<br>and runs <code>su – root</code>, <code>whoami</code> will show root whereas <code>who am i</code> will show abc</li><li><code>last</code>: 获取每个用户登录的持续时间. 该记录保存在: <code>/var/log/wtmp</code></li></ul><h2 id="lsof-fuser"><a href="#lsof-fuser" class="headerlink" title="lsof, fuser"></a>lsof, fuser</h2><p><strong>fuser:</strong><br>列出哪个进程在使用文件: <code>fuser /etc/filenames</code></p><p><strong>lsof:</strong></p><ul><li>常用参数:<ul><li><code>-p 进程id</code></li><li><code>-i :端口号</code></li><li><code>-P</code> :  默认情况lsof会显示 “端口名字” 而不是 “数字类型的端口号” （如果此端口号有名字的话）, <code>-P</code>可以指定显示数字端口号, 而不是名字</li></ul></li><li>用法示例:<ul><li>查找已被删除但硬盘空间不释放的文件: <code>lsof |grep delete</code>, 这个文件的innode链接被移除了, 但还没有被删掉</li><li>某个端口: <code>lsof -i TCP:8080</code> or <code>lsof -i :80</code>， -i是列出listening的sock，If -i4 or -i6 is specified with no following address, only files of the indicated IP version</li><li>某个进程: <code>lsof -p PID</code></li><li>查看所有活动状态的网络服务: lsof -i</li><li>查看某个用户打开的文件: <code>lsof -u ^root</code>, 或者<code>lsof | grep ^root</code><br>*</li></ul></li></ul><blockquote><p>文件实际上是一个指向inode的链接, inode链接包含了文件的所有属性, 比如权限和所有者, 数据块地址(文件存储在磁盘的这些数据块中). 当你删除(rm)一个文件, 实际删除了指向inode的链接, 并没有删除inode的内容. 进程可能还在使用. 只有当inode的所有链接完全移去, 然后这些数据块将可以写入新的数据.</p></blockquote><p>Example: lsof返回数据如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND     PID    USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class="line">init          1    root  cwd       DIR                8,1        4096          2 /</span><br><span class="line">crond      4621    root  txt       REG                8,5       64096     151941 /usr/sbin/crond</span><br><span class="line">crond      4621    root  DEL       REG                8,1                    115 /lib64/libnss_files-2.12.so</span><br><span class="line">nginx     42544    root  194u     unix 0xffff880012b9a080         0t0  510761950 socket</span><br><span class="line">nginx     42544    root  195u     unix 0xffff8800cbb99cc0         0t0  510761952 socket</span><br><span class="line">java      27672    root   66u     IPv4           41351930         0t0        TCP *:56494 (LISTEN)</span><br></pre></td></tr></table></figure><ul><li><code>lsof | awk &#39;{process[$1]++;} END{for(key in process) printf(&quot;%s:%d\n&quot;, key, process[key])}&#39;</code>  // 每个进程打开的文件数</li><li><code>lsof | awk &#39;{if($8 == &quot;TCP&quot;) opened_tcp++} END{print opened_tcp }&#39;</code> //打开TCP连接数量</li><li><code>lsof | awk &#39;{opened_type[$5]++} END{ for(key in opened_type) printf(&quot;%s : %d\n&quot;, key, opened_type[key])}&#39;</code> // 打开文件按TYPE统计</li></ul><h2 id="du-df-fdisk"><a href="#du-df-fdisk" class="headerlink" title="du, df, fdisk"></a>du, df, fdisk</h2><ul><li>du:<ul><li>查看当前子目录大小: <code>du -h --max-depth=1</code></li><li>当前目录文件按大小排序: <code>du -s * | sort -n | tail</code></li></ul></li><li>df: （英文全拼：disk free） 显示文件系统的使用情况 &amp; 挂载点<ul><li>-h：<code>--human-readable</code></li></ul></li><li>fdisk: 创建和维护分区表<ul><li>-l：列出所有分区表</li></ul></li></ul><h2 id="exec-xargs"><a href="#exec-xargs" class="headerlink" title="-exec, xargs"></a>-exec, xargs</h2><p>xargs的作用一般等同于大多数Unix shell中的反引号, 但更加灵活易用, 并可以正确处理输入中有空格等特殊字符的情况. 对于经常产生大量输出的命令如find、locate和grep来说非常有用: <code>file * |grep ASCII | cut -d&quot;:&quot; -f1 |xargs ls -l</code></p><ul><li>-exec查找并grep: <code>find . -name &quot;*.php&quot; -exec grep -in &quot;string&quot; {} \;</code> 最后的<code>\;</code>是-exec的结束标识</li><li>xargs: <code>find . -name &quot;*.php&quot; | xargs grep -in &quot;string&quot;</code></li></ul><h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h2><ul><li>查看所有的限制: <code>ulimit -a</code><ul><li>set 最大打开文件句柄数: <code>ulimit -n 65535</code>, 查看当前值<code>ulimit -n</code></li><li>set 最大进程数: <code>ulimit -u 32768</code>, 查看当前值<code>ulimit -u</code></li><li>set 线程栈的大小: <code>ulimit -s 10240</code></li><li>set core文件大小: <code>ulimit -c xxx</code>, 不限制core的大小: <code>ulimit -c unlimited</code></li></ul></li></ul><blockquote><p>ulimit起作用的范围是当前Shell, 并不是作用于”当前用户”, 如要对”用户”做限制, 则需要修改系统文件<code>/etc/security/limits.conf</code></p></blockquote><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>umask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。</p><ul><li><code>umask 022</code>: 用户权限为755</li><li><code>umask 077</code>: 用户权限为700</li></ul><h2 id="su-sudo"><a href="#su-sudo" class="headerlink" title="su, sudo"></a>su, sudo</h2><p>su:</p><ul><li><code>su</code>: 切换到root用户, 切换之前的环境变量一并被带到了新shell里;</li><li><code>su - user_name</code>:  切换用户, 切换之后的环境变量会改变为新用户的,  <code>su -</code> 同<code>su - root</code><ul><li>例: <code>su - root -c commands</code>, 执行完commands之后自动切换会原来的用户.</li></ul></li></ul><p>sudo:</p><ul><li><code>sudo</code>是受限制的su, 两个命令的最大区别是：<code>sudo</code> 命令需要输入当前用户的密码，<code>su</code> 命令需要输入 root 用户的密码。</li><li><code>sudo -s cmd</code>: 执行cmd命令, 如果是<code>sudo -s</code>则会启动一个可交互shell, 有点类似<code>su</code>,</li><li>通过修改<code>/etc/sudoer</code>配置哪些用户具有执行sudo的权限, sudo命令能继承哪些环境变量也是在<code>/etc/sudoer</code>中配置的.</li></ul><h2 id="export-amp-环境变量"><a href="#export-amp-环境变量" class="headerlink" title="export &amp; 环境变量"></a>export &amp; 环境变量</h2><ul><li><code>VAR=hello</code> $VAR scope is restricted to the shell;</li><li><code>export VAR=hello</code> makes the $VAR available to child processes;</li></ul><p>每个进程的环境变量可以在<code>/proc/$PID/evnrion</code>查看.</p><h2 id="sh-exec-source的区别"><a href="#sh-exec-source的区别" class="headerlink" title="sh, exec, source的区别"></a>sh, exec, source的区别</h2><ul><li><code>source</code> 和 点命令<code>.</code>是一样的, 不会启动子shell, 不需要script有可执行权限, script里定义的变量也会被导入当前的shell环境.</li><li><code>./script</code> 启动子shell, script里的变量不会被带进当前环境, 相当于<code>fork</code>, 需要脚本有x权限</li><li><code>sh ./script</code> 先启动了一个子shell, 子shell继承父shell的环境变量, 但子shell里新建变量、改变变量 不会被带回父shell, 除非用<code>export VAR=&quot;xxx&quot;</code></li><li><code>exec cmd</code> 产生了新的进程, 新进程会关闭当前shell的进程, 新的进程继承了原shell的PID号, 原shell剩下的内容不会执行,</li></ul><h2 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h2><p>多命令顺序执行:</p><ul><li>分号（<code>;</code>）： 顺序执行，命令之间不存在关系，互不影响<ul><li>例 <code>ls; date; cd /user; pwd</code></li></ul></li><li>逻辑与（<code>&amp;&amp;</code>）： 只有第一条命令成功执行，才会执行第二条命令<ul><li>例 <code>cd ~/dir &amp;&amp; git commit -am &quot;u&quot; &amp;&amp; git pull &amp;&amp; git push</code></li></ul></li><li>逻辑或（<code>||</code>）： 第一条成功执行，第二条不执行; 第一条非正确执行，第二条才会执行</li></ul><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><a href="/21.Operating-System/APUE.03a.进程/" title="APUE.03a.进程">APUE.03a.进程</a><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>并不是所有的程序都像 Nginx, Redis, httpd一样提供守护进程, 保证在关闭终端会话后正常运行.<br>如果终端会话关闭，那么程序也会被关闭。为了能够后台运行，那么我们就可以使用nohup:</p><ul><li><code>nohup cmd &amp;</code> : 后台运行cmd, 程序运行的输出信息放到当前目录的 nohup.out 文件中去</li><li><code>nohup command &gt; myout.log 2&gt;&amp;1 &amp;</code> : 后台运行cmd, 并指定输出的文件</li></ul><blockquote><p>nohup的原理也很简单，终端关闭后会给此终端下的每一个进程发送<code>SIGHUP</code>信号，而使用nohup运行的进程则会忽略这个信号，因此终端关闭后进程也不会退出。</p></blockquote><h2 id="命令重定向"><a href="#命令重定向" class="headerlink" title="命令重定向"></a>命令重定向</h2><blockquote><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件: 文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p></blockquote><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 将输出重定向到 file</span><br><span class="line">command &gt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将输出追加重定向到 file</span><br><span class="line">command &gt;&gt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将文件描述符为n的文件重定向到 file</span><br><span class="line"><span class="meta">n&gt;</span>file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将文件描述符为 n 的文件以追加的方式重定向到 file</span><br><span class="line"><span class="meta">n&gt;</span>&gt;file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将文件描述符为 m 和 n 的内容合并,注意</span><br><span class="line"><span class="meta">n&gt;</span>&amp;m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将文件描述符为 m 和 n 的内容合并, 一并输出到 file</span><br><span class="line">command &gt; file m&gt;&amp;n</span><br></pre></td></tr></table></figure><blockquote><p>有关 <code>command &gt;out.file  2&gt;&amp;1 &amp;</code> 的解释(注意文件描述符和重定向符号之间不能有空格):<br>最后的<code>&amp;</code> 表示后台运行;<br>为什么是 <code>2&gt;&amp;1</code> 而不是 <code>2&gt;1</code> ? 这样做会直接输出文件名为1的文件;<br><code>&gt;outfile</code> 和 <code>2&gt;&amp;1</code> 的顺序可以交换吗? 不可以, <code>command 2&gt;&amp;1 &gt;out.file</code> ,  先<code>2&gt;&amp;1</code> 的意思是 stderr输出到 stdout, 此时的 stdout是输出到终端的, stderr也就被输出到终端, 然后 <code>&gt;out.file</code>是把 stdout输出到文件, 但是此时 stderr还是输出到终端的;</p></blockquote><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 将 file的内容作为标准输入</span><br><span class="line">command &lt; file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将 infile的内容作为标准输入, 标准输出写入 outfile</span><br><span class="line">command &lt; infile &gt; outfile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Here Document 式重定向输入, 将定界符（下面例子中的EOF没有特殊含义, 可以自定义界定符）之间的作为stdin</span><br><span class="line">command &lt;&lt; EOF</span><br><span class="line">    hello</span><br><span class="line">    world</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p></blockquote><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><ul><li>创建一个空文件, 除了touch还可 : <code>&gt; file</code></li><li>用ssh远程执行本地脚本, 不用scp拷贝 : <code>ssh root@host bash &lt; /local/xxx.sh</code></li><li><code>&lt;(COMMAND)</code> 可以作为一个文件 : <code>diff /etc/host &lt;(ssh remote cat /etc/hosts)</code></li></ul><h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><ul><li>脚本内执行<code>java -jar ...</code>命令, 通过<code>$!</code>获得子进程ID</li><li>脚本执行<code>wait 子进程ID</code></li><li>如下</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">_term() &#123;</span><br><span class="line">    kill -TERM "$child_pid"</span><br><span class="line">    wait "$child_pid"</span><br><span class="line">&#125;</span><br><span class="line">trap _term SIGTERM</span><br><span class="line"></span><br><span class="line">java -Dspring.profiles.active=test \</span><br><span class="line">     -Dserver.port=9013 \</span><br><span class="line">     -jar wallet-console-2.0.0.jar &amp;</span><br><span class="line"></span><br><span class="line">child_pid=$!</span><br><span class="line">wait "$child_pid"</span><br></pre></td></tr></table></figure><h2 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h2><a href="/21.Operating-System/Linux.02.网络命令/" title="Linux.02.网络命令">Linux.02.网络命令</a><h2 id="常用配置文件"><a href="#常用配置文件" class="headerlink" title="常用配置文件"></a>常用配置文件</h2><a href="/21.Operating-System/Linux.04.系统配置/" title="Linux.04.系统配置">Linux.04.系统配置</a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;命令全称&quot;&gt;&lt;a href=&quot;#命令全称&quot; class=&quot;headerlink&quot; title=&quot;命令全称&quot;&gt;&lt;/a&gt;命令全称&lt;/h2&gt;&lt;p&gt;=&amp;gt; &lt;a href=&quot;/21.Operating-System/Linux.01a.常用命令行全称速记/&quot; title=&quot;Linux.01a.常用命令行全称速记&quot;&gt;Linux.01a.常用命令行全称速记&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-man&quot;&gt;&lt;a href=&quot;#使用-man&quot; class=&quot;headerlink&quot; title=&quot;使用 man&quot;&gt;&lt;/a&gt;使用 man&lt;/h2&gt;&lt;p&gt;man 可以查看”系统命令/系统调用函数/glibc库函数” 等等共9类内容, 例如 &lt;code&gt;man lsof&lt;/code&gt; 第一行是 “LSOF(8)”, 表示是第8类, &lt;code&gt;man man&lt;/code&gt; 第一行是”man(8)” 表示man 是第8类, 也可以看到所有9类 “manual”, 如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;系统命令&lt;/li&gt;
&lt;li&gt;系统调用，一般是对应的C封装函数；所有系统调用的函数在调用发生时都会进入内核空间执行&lt;/li&gt;
&lt;li&gt;各种库函数手册，例如glibc，pthread库API等，如果是非C库，则会标注出对于的链接选项&lt;/li&gt;
&lt;li&gt;特殊设备文件，例如zero, mem等&lt;/li&gt;
&lt;li&gt;文件格式手册，描述Linux支持的各种文件系统以及对于的C接口结构，如vfat/iso&lt;/li&gt;
&lt;li&gt;游戏程序文档&lt;/li&gt;
&lt;li&gt;其它的各种各样不在前边分类的文档（8/9除外）&lt;/li&gt;
&lt;li&gt;系统管理员命令，一般仅供root用户使用，如cron/useradd等&lt;/li&gt;
&lt;li&gt;Linux内核相关部分的手册，一般情况很少用到，这一节就没有intro介绍页&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="21.Operating-System" scheme="https://beefyheisenberg.github.io/categories/21-Operating-System/"/>
    
    
    <category term="Linux" scheme="https://beefyheisenberg.github.io/tags/Linux/"/>
    
    <category term="Linux命令行" scheme="https://beefyheisenberg.github.io/tags/Linux命令行/"/>
    
  </entry>
  
</feed>
