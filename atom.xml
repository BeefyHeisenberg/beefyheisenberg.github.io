<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扔掉笔记 ᐛ</title>
  
  <subtitle>dropNotes</subtitle>
  <link href="https://beefyheisenberg.github.io/atom.xml" rel="self"/>
  
  <link href="https://beefyheisenberg.github.io/"/>
  <updated>2023-05-24T10:36:02.694Z</updated>
  <id>https://beefyheisenberg.github.io/</id>
  
  <author>
    <name>beefyheisenberg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>05a.此在的本真-海德格的存在主义</title>
    <link href="https://beefyheisenberg.github.io/61.Philosophy/05a.%E6%AD%A4%E5%9C%A8%E7%9A%84%E6%9C%AC%E7%9C%9F-%E6%B5%B7%E5%BE%B7%E6%A0%BC%E7%9A%84%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/"/>
    <id>https://beefyheisenberg.github.io/61.Philosophy/05a.%E6%AD%A4%E5%9C%A8%E7%9A%84%E6%9C%AC%E7%9C%9F-%E6%B5%B7%E5%BE%B7%E6%A0%BC%E7%9A%84%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/</id>
    <published>2023-05-24T10:36:02.693Z</published>
    <updated>2023-05-24T10:36:02.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="此在的本真-海德格的存在主义"><a href="#此在的本真-海德格的存在主义" class="headerlink" title="此在的本真-海德格的存在主义"></a>此在的本真-海德格的存在主义</h1><blockquote><p>海德格尔的『此在』在德语里翻译成“Dasein”，在黑格尔体系里，“Dasein”意指“定在”或“有限存在”，物质世界或具体历史的有限性对应真理总体的无限性。“Da”表示“在此之中”，“此”表示“这里”。</p></blockquote><p>海德格把『此在』关切自身的存在 称为牵挂（care），牵挂也是『此在』与世界的基本关联，也是『此在』在“这个世界”获得意义的基础。</p><p>牵挂由：生存（唯物的“存在”），实际性(存在于在……之中)，沉沦(存在于……状态里)，以及言谈组成。</p><p>沉沦（非指消极状态，也非道德上的堕落）的日常体现：闲谈，好奇，两可。</p><blockquote><p>闲谈：本质是诉说的快感，不为真实性和合理性负责，不必经过自我验证<br>好奇：这里不是指求知欲，而是放纵自己于世界，寻求不安和激动。不操持于所及的世界，而是涣散在新的可能性中<br>两可：在“共在”的状况下，处在一种随从、不做决断的状态</p></blockquote><p>这三种日常方式被称为“此在的沉沦”，但它们不是消极的，而是『此在』从“本真”状态脱离，而消失于常人的公共意见中（常人：自身之外的大众）</p><p>那么此在的“本真”又是一种什么状态呢？<br><strong>本真(Authentic)</strong>是此在的一种生活状态：『此在』在面对一个孤独的局面时采取决断的态度，并且敢于承担自己的唯一性和个体性，那么可以说，此在进取了本真(Authentic)的状态。并且此在意识到这个状态的存在。</p><p>海德格尔指出，「常人」表明为公众意见的“平均状态”。作为常人被从他的本真的可能性的筹划中拉离出来，陷入到 <strong>非本真存在</strong>的无根基状态之中。决心面对死亡之畏把此在从消散于世界的沉沦中唤回到他的最本真的能在。常人和本真性是海德格尔的两个核心概念，</p><blockquote><p>海德格尔认为，当人与自己的死亡遭遇时，真实的属己的自我才会显露出来。死亡是对现实世界的否定，当人面对死亡时，才会停止对外界的忧虑和担心，从牵挂中脱离开来，从外界中孤立出自己，成为“真正的存在”。</p></blockquote><blockquote><p>[[../62.Psychology/《存在主义心理治疗》读书笔记]] /第三部《孤独》： 海德格用“不自在”来指代人失去了在世界中的熟悉感的状态，当人完全专注于表象世界，对自己的存在处境失去接触时，海德格称这个人处于“日常”或者“陷入”的模式里。</p></blockquote><h1 id="海德格的“畏”"><a href="#海德格的“畏”" class="headerlink" title="海德格的“畏”"></a>海德格的“畏”</h1><p>在存在主义哲学中，”畏”有特殊的概念性意义。最初使用这个词的是丹麦哲学家索伦·克尔凯郭尔。在作品《焦虑的概念》中，克尔凯郭尔使用”畏”来指代一种深层的情绪。他认为，除了人类以外的动物，它们的行为只被本能所引导，只有人类得以享受基于自由的选择，但也因此而感到恐惧。当考虑到前方未知的可能性，以及因选择而将要背负的无形义务，人们就会感到焦虑。</p><p>后世哲学家，例如弗里德里希·尼采、让-保罗·萨特、马丁·海德格尔等人继承了克尔凯郭尔的”畏”的概念。他们对这个概念进行了自主的延伸。克尔凯郭尔对于”畏”的理解更多是出于一种关于宗教的个人情感，而其他哲学家则寻求在个人原则、文化传统以及存在的绝望等方面进行自己的探索。</p><p>海德格尔的存在主义哲学认为，”此在的生存论意义就是畏”，”此在就是畏”，”此在的存在结构就是畏” 。畏的是”存在自身”，畏的是随时都可能来临，而又无法回避的”死”，”为死而存在就是畏” 。他认为存在是死亡的开始，而死亡是存在的终结，当人真正认清了此在的这个实质时，他就不会终日惶惶于死亡，就能视死如归，从畏转向大无畏。</p><hr><p>=&gt; <a href="/61.Philosophy/05.存在主义/" title="05.存在主义">05.存在主义</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;此在的本真-海德格的存在主义&quot;&gt;&lt;a href=&quot;#此在的本真-海德格的存在主义&quot; class=&quot;headerlink&quot; title=&quot;此在的本真-海德格的存在主义&quot;&gt;&lt;/a&gt;此在的本真-海德格的存在主义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;海德格尔的『此在』在德语里翻译成“Dasein”，在黑格尔体系里，“Dasein”意指“定在”或“有限存在”，物质世界或具体历史的有限性对应真理总体的无限性。“Da”表示“在此之中”，“此”表示“这里”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;海德格把『此在』关切自身的存在 称为牵挂（care），牵挂也是『此在』与世界的基本关联，也是『此在』在“这个世界”获得意义的基础。&lt;/p&gt;
&lt;p&gt;牵挂由：生存（唯物的“存在”），实际性(存在于在……之中)，沉沦(存在于……状态里)，以及言谈组成。&lt;/p&gt;
&lt;p&gt;沉沦（非指消极状态，也非道德上的堕落）的日常体现：闲谈，好奇，两可。&lt;/p&gt;</summary>
    
    
    
    <category term="61.Philosophy" scheme="https://beefyheisenberg.github.io/categories/61-Philosophy/"/>
    
    
    <category term="哲学" scheme="https://beefyheisenberg.github.io/tags/哲学/"/>
    
    <category term="存在主义" scheme="https://beefyheisenberg.github.io/tags/存在主义/"/>
    
    <category term="海德格" scheme="https://beefyheisenberg.github.io/tags/海德格/"/>
    
  </entry>
  
  <entry>
    <title>开始使用Obsidian</title>
    <link href="https://beefyheisenberg.github.io/51.Productivity/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Obsidian/"/>
    <id>https://beefyheisenberg.github.io/51.Productivity/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Obsidian/</id>
    <published>2023-05-24T10:10:51.164Z</published>
    <updated>2023-05-24T10:10:51.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h2><ul><li>特性介绍: <a href="https://obsidian.md/features" target="_blank" rel="noopener">Features - Obsidian</a></li><li>版本发布: <a href="https://forum.obsidian.md/c/announcements/13" target="_blank" rel="noopener">Latest Announcements topics - Obsidian Forum</a></li><li>Feature requests: <a href="https://forum.obsidian.md/c/feature-requests/8" target="_blank" rel="noopener">Latest Feature requests topics - Obsidian Forum</a></li></ul><h2 id="Vault（库）"><a href="#Vault（库）" class="headerlink" title="Vault（库）"></a>Vault（库）</h2><p>每个vault下有单独的.obsidian文件夹:</p><ul><li><code>.obsidian/thems/</code>:   CSS主题目录</li><li><code>.obsidian/snippets/</code>: CSS代码片段目录</li><li><code>.obsidian/config</code>:</li><li><code>.obsidian/workspace</code>:</li></ul><blockquote><p>For example YourOwnVault/.obsidian/.trash is the trash folder<br>YourOwnVault/.obsidian/config stores things like your own custom hotkeys<br>YourOwnVault/.obsidian/workspace saves things like the most recent files, and the window layout (I think).</p></blockquote><p>App系统文件夹:</p><ul><li>macOS: <code>~/Library/Application\ Support/obsidian</code>, 文件缓存在<code>ObsidianCache/</code> 和 <code>IndexedDB/</code></li><li>Win: <code>%APPDATA%\Obsidian\</code></li></ul><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li><a href="https://github.com/zsviczian/obsidian-excalidraw-plugin" target="_blank" rel="noopener">obsidian-excalidraw-plugin</a>: The Obsidian-Excalidraw plugin integrates Excalidraw, a feature rich sketching tool. You can store and edit Excalidraw files in your vault, you can embed drawings into your documents, and you can link to documents and other drawings to/and from Excalidraw</li><li><a href="https://github.com/shichongrui/obsidian-reveal-active-file" target="_blank" rel="noopener">obsidian-reveal-active-file</a>: 打开一个mkd时, 自动在文件树导航到这个文件</li><li><a href="https://github.com/darlal/obsidian-switcher-plus" target="_blank" rel="noopener">obsidian-switcher-plus</a>: 类似Sublime的Symbol搜索, 自定义快捷键<code>Cmd</code>+<code>R</code>, 呼出搜索框，直接是文件名模糊搜索， 输入<code>@</code>触发当前文件内搜索Heading, 输入<code>#</code>触发全库内搜索Heading</li><li><a href="https://github.com/lynchjames/obsidian-mind-map" target="_blank" rel="noopener">obsidian-mind-map</a>: 为当前笔记生成 mind map</li><li><a href="https://github.com/tgrosinger/advanced-tables-obsidian" target="_blank" rel="noopener">advanced-tables-obsidian</a>: 表格编辑, 输入<code>|</code>就可以进入表格编辑, 按<code>Tab</code>编辑下一个表格的内容</li><li><a href="https://github.com/platers/obsidian-linter" target="_blank" rel="noopener">obsidian-linter</a>: 格式化md文件, 更新yaml头</li><li><a href="https://github.com/OliverBalfour/obsidian-pandoc" target="_blank" rel="noopener">OliverBalfour/obsidian-pandoc</a>: 导出为pdf、doc、html等格式</li><li><a href="https://github.com/obsidian-html/obsidian-html" target="_blank" rel="noopener">Obsidian-Html</a>: 将Obsidian笔记导出为网站html, 网站样例: <a href="https://obsidian-html.github.io/?path=%2FInstructions%2FUsage.html/" target="_blank" rel="noopener">https://obsidian-html.github.io/?path=%2FInstructions%2FUsage.html/</a></li><li><a href="https://github.com/liamcain/obsidian-calendar-plugin" target="_blank" rel="noopener">obsidian-calendar-plugin</a>: 给Obs增加一个日历widget用以显示每天的笔记, 依赖于Obs的Core插件<code>Daily Note</code>, 是按照mkd的文件名区分日期的, 对于我来说大部分mkd文件都不是日期命名所以也没多大用处, 希望能改成通过yaml头或者文件modify属性识别日期</li><li><a href="https://silentvoid13.github.io/Templater/introduction.html" target="_blank" rel="noopener">Templater</a>： 更好的模板管理</li><li><a href="https://github.com/Yaozhuwa/easy-typing-obsidian" target="_blank" rel="noopener">easy-typing-obsidian</a>：自动格式化 md</li><li><a href="https://github.com/agathauy/wikilinks-to-mdlinks-obsidian" target="_blank" rel="noopener">wikilinks-to-mdlinks-obsidian</a>：Obsidian 默认的附件（PDF or 贴图）都是 <code>[[ ]]</code>，这种图片格式在其他支持 mkd 的笔记、以及 Hexo 博客里并不支持，这个插件可以一键切换 <code>[[ ]]</code> 和 <code>![]()</code> 两种 link 格式</li><li><a href="https://github.com/reorx/obsidian-paste-image-rename" target="_blank" rel="noopener">obsidian-paste-image-rename:</a>：Obsidian 的贴图自动命名为“pasted image 日期” 这种带空格的格式，对 URL 显示并不友好，这个插件可以自动按规则重命名图片文件，支持 <code>dirName</code> 、<code>fileName</code>、<code>date</code> 等变量；</li><li><a href="https://github.com/guopenghui/obsidian-quiet-outline" target="_blank" rel="noopener">Quiet Outline</a>：更好的显示文件大纲（outline）</li></ul><p>如果在Ob 中已经打开了 fileA，再通过 “快速打开” or “点击双链” 进入 fileA，Ob会重复再开一个标签页：</p><ul><li>Quicker Switcher++：替换默认的快速打开功能；</li><li><a href="https://github.com/scambier/obsidian-no-dupe-leaves" target="_blank" rel="noopener">obsidian-no-dupe-leaves</a>：解决从双链进入的重复打开；</li><li><a href="https://github.com/patleeman/obsidian-open-in-new-tab" target="_blank" rel="noopener">obsidian-open-in-new-tab</a>：解决从文件管理器的重复打开；</li></ul><h2 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h2><ul><li><a href="https://github.com/whyt-byte/Blue-Topaz_Obsidian-css" target="_blank" rel="noopener">whyt-byte/Blue-Topaz_Obsidian-css: A blue theme for Obsidian.</a></li><li><a href="https://github.com/mediapathic/obsidian-arsmagna-theme" target="_blank" rel="noopener">mediapathic/obsidian-arsmagna-theme: A theme for Obsidian, inspired by the works of Athanasius Kircher</a></li><li><a href="https://github.com/kepano/obsidian-minimal" target="_blank" rel="noopener">kepano/obsidian-minimal: Minimal theme for Obsidian</a></li></ul><h2 id="CSS-Snippets"><a href="#CSS-Snippets" class="headerlink" title="CSS Snippets"></a>CSS Snippets</h2><p>CSS Snippets 可以载入自定义CSS， 自定义 Obsidian 的外观，例如自定 Heading 的显示样式..</p><p>在 <code>设置 =&gt; 外观 =&gt; CSS 代码片段</code> 管理，</p><p>更多可用的 Snippet可以在这里找到： <a href="https://github.com/deathau/obsidian-snippets" target="_blank" rel="noopener">https://github.com/deathau/obsidian-snippets</a></p><h2 id="YAML-front-matter"><a href="#YAML-front-matter" class="headerlink" title="YAML front matter"></a>YAML front matter</h2><p>由于 Markdown 官方标准不支持存储 metadata（例如笔记更新日期、分类等），所以 Obsidian 通过支持 YAML front matter 来解决，目前受 Obsidian 支持的有：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aliases:</span> <span class="string">[别名1,</span> <span class="string">别名2]</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">publish:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>title</code>不是官方支持的属性…</li><li><code>aliases</code> 必须在第一行，</li></ul><p>@ref: <a href="https://help.obsidian.md/Advanced+topics/YAML+front+matter" target="_blank" rel="noopener">https://help.obsidian.md/Advanced+topics/YAML+front+matter</a></p><h2 id="标注（callout）"><a href="#标注（callout）" class="headerlink" title="标注（callout）"></a>标注（callout）</h2><p>在标准 Markdown GFM 规范中，对于“标注框”都没有明确的定义。因此关于标注框这件事，各家都是采用各自的语法来实现，不同语法之间互不通用。<br>标注框有点类似 Markdown 中的 <code>&gt;</code> 引言块，但更加醒目。往往用于诸如提示、警告之类的用途，也经常被称为“谏言块”（admonition）。</p><p>Obsidian 在引用块上加了一些特殊的语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; [!标注类型]</span><br><span class="line">&gt; 这里是标注内容...</span><br></pre></td></tr></table></figure><p>支持的“标注类型”有：info 、tip、warning、note、todo、question、danger、bug 等，不同的标注类型，渲染出的 icon 和背景色不同：</p><blockquote><p>[!warning]<br>这是一个警告标注</p></blockquote><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Obsidian内建功能快捷键：</p><ul><li>快速打开：<code>cmd + O</code></li><li>命令面板：<code>cmd + P</code></li><li>编辑/预览: <code>cmd + E</code></li><li>返回：<code>cmd + alt + ←</code></li><li>访问光标处的链接： <code>alt + Enter</code></li><li>播放关系图谱生长动画： <code>cmd + shift + P</code></li><li>查看关系图谱： <code>cmd + G</code></li><li>查看局部关系图谱： <code>cmd + shift + G</code></li></ul><p>插件快捷键：</p><ul><li>插件-Advanced Tables插入表格： 按<code>|</code>，再按<code>Tab</code></li><li>插件-Linter 格式化当前文件： <code>cmd + alt + L</code></li><li>插件-Quick Switcher： <code>cmd + R</code>，再按<code>#</code>进入 Heading 搜索</li><li>插件-Templater 插入YAML（自定义）：<code>cmd + shift + Y</code></li></ul><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><p>进入调试模式快捷键： <code>option-cmd-i</code>（或 <code>Ctrl+shift+I</code> for Win）</p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li><a href="https://help.obsidian.md/Advanced+topics/Using+obsidian+URI" target="_blank" rel="noopener">Using obsidian URI</a></li><li><a href="https://publish.obsidian.md/help/Advanced+topics/YAML+front+matter" target="_blank" rel="noopener">YAML front matter</a></li><li><a href="https://help.obsidian.md/How+to/Add+aliases+to+note" target="_blank" rel="noopener">Add aliases to note</a></li><li><a href="https://help.obsidian.md/How+to/Link+to+blocks" target="_blank" rel="noopener">Link to blocks</a></li><li><a href="https://help.obsidian.md/How+to/Internal+link" target="_blank" rel="noopener">Link to headings</a></li><li><a href="https://help.obsidian.md/Plugins/Workspaces" target="_blank" rel="noopener">Workspace</a></li><li><a href="https://help.obsidian.md/How+to/Add+custom+styles" target="_blank" rel="noopener">添加自定义CSS</a></li></ul><h2 id="问题-amp-feature-requests"><a href="#问题-amp-feature-requests" class="headerlink" title="问题 &amp; feature requests"></a>问题 &amp; feature requests</h2><ul><li>在 Graph View使用H1标题替代 filename<ul><li><a href="https://forum.obsidian.md/t/show-title-of-zettelkasten-notes-in-graph-view/683" target="_blank" rel="noopener">https://forum.obsidian.md/t/show-title-of-zettelkasten-notes-in-graph-view/683</a></li><li><a href="https://forum.obsidian.md/t/use-h1-or-front-matter-title-instead-of-or-in-addition-to-filename-as-display-name/687" target="_blank" rel="noopener">https://forum.obsidian.md/t/use-h1-or-front-matter-title-instead-of-or-in-addition-to-filename-as-display-name/687</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;有用的链接&quot;&gt;&lt;a href=&quot;#有用的链接&quot; class=&quot;headerlink&quot; title=&quot;有用的链接&quot;&gt;&lt;/a&gt;有用的链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;特性介绍: &lt;a href=&quot;https://obsidian.md/features&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Features - Obsidian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;版本发布: &lt;a href=&quot;https://forum.obsidian.md/c/announcements/13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Latest Announcements topics - Obsidian Forum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Feature requests: &lt;a href=&quot;https://forum.obsidian.md/c/feature-requests/8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Latest Feature requests topics - Obsidian Forum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Vault（库）&quot;&gt;&lt;a href=&quot;#Vault（库）&quot; class=&quot;headerlink&quot; title=&quot;Vault（库）&quot;&gt;&lt;/a&gt;Vault（库）&lt;/h2&gt;&lt;p&gt;每个vault下有单独的.obsidian文件夹:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.obsidian/thems/&lt;/code&gt;:   CSS主题目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.obsidian/snippets/&lt;/code&gt;: CSS代码片段目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.obsidian/config&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.obsidian/workspace&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="51.Productivity" scheme="https://beefyheisenberg.github.io/categories/51-Productivity/"/>
    
    
    <category term="生产力" scheme="https://beefyheisenberg.github.io/tags/生产力/"/>
    
    <category term="知识管理" scheme="https://beefyheisenberg.github.io/tags/知识管理/"/>
    
    <category term="PKM" scheme="https://beefyheisenberg.github.io/tags/PKM/"/>
    
    <category term="笔记" scheme="https://beefyheisenberg.github.io/tags/笔记/"/>
    
  </entry>
  
  <entry>
    <title>RPC.03-框架设计概要</title>
    <link href="https://beefyheisenberg.github.io/31.Backend/RPC.03-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/"/>
    <id>https://beefyheisenberg.github.io/31.Backend/RPC.03-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/</id>
    <published>2023-05-24T10:10:50.482Z</published>
    <updated>2023-05-24T10:10:50.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><p>早期JDK1.2引入的RMI框架图: （👉🏻[[../@project/Java-RMI]]）</p><h2 id="RPC通用框架"><a href="#RPC通用框架" class="headerlink" title="RPC通用框架"></a>RPC通用框架</h2><p>通用RPC框架图:</p><p><img src="/images/2022/20220315092643.png" alt="../_images/2022/20220315092643.png"></p><ul><li><p>serviceClient：这个模块主要是封装服务端对外提供的API，让客户端像使用本地API接口一样调用远程服务。一般使用动态代理机制，当客户端调用api的方法时，serviceClient会走代理逻辑，去远程服务器请求真正的执行方法。类似RMI的stub模块。</p></li><li><p>processor：在服务端存在很多方法，当客户端请求过来，服务端需要定位到具体对象的具体方法，然后执行该方法，这个功能就由processor模块来完成。一般这个操作需要使用反射机制来获取用来执行真实处理逻辑的方法。类似RMI的skeleton模块。</p></li><li><p>protocol：协议层，一般协议层包括编码/解码，或者说序列化和反序列化工作；有的时候编解码不仅仅是对象序列化的工作，还有一些通信相关的字节流的额外解析部分。序列化工具有：hessian，Apache avro，G的 protobuf，FB的 Thrift，json系，xml系等等。在RMI中直接使用JDK自身的序列化组件。</p><blockquote><p>Thrift和Protobuf的最大不同，在于Thrift提供了完整的RPC支持，包含了Server/Client，而Protobuf只包括了stub的生成器和格式定义。@ref <a href="https://developer.aliyun.com/article/229886" target="_blank" rel="noopener">Protobuf 和 Thrift对比-阿里云开发者社区</a></p></blockquote></li><li><p>transport：传输层，主要是服务端和客户端网络通信相关的功能。这里和下面的IO层区分开，主要是因为传输层处理server/client的网络通信交互，而不涉及具体底层处理连接请求和响应相关的逻辑。</p></li><li><p>I/O：这个模块主要是为了提高性能可能采用不同的IO模型和线程模型，当然，一般我们可能和上面的transport层联系的比较紧密，统一称为remote模块。</p></li></ul><p>Dubbo框架图参考:  <a href="/31.Backend/RPC.01-浅谈服务治理-and-微服务(zz)/" title="RPC.01-浅谈服务治理-and-微服务(zz)">RPC.01-浅谈服务治理-and-微服务(zz)</a></p><h2 id="RPC技术要点"><a href="#RPC技术要点" class="headerlink" title="RPC技术要点"></a>RPC技术要点</h2><ul><li>序列化:<ul><li>JDK内置序列化 👉🏻 [[../12.Java/Java-Tutorials.06.序列化(Serialize)]]</li><li>Hessian: 在字节流里为每个field存储了类型信息, 可以不依赖serialVersionUID 进行版本匹配(Java类的UID被更改, 反序列化也没有问题)</li><li>Kryo: “Kryo是一个快速高效的Java对象序列化框架，其在java的序列化上的性能指标甚至优于google著名的序列化框架protobuf，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用”</li><li>Json:</li></ul></li><li><p>编解码: 注意区分序列化的不同, RPC框架基本上都是基于Socket来实现通信层功能，但是在网络传输的数据由于网络链路和协议的问题，会出现半包、分包和粘包情况。这样就需要设计编解码协议头来解码网络流。比如dubbo给出的处理流程，可以清晰的看出序列化和编码之间的区别,  参考[[#Dubbo协议头]]<br>  <img src="/images/2022/20220316000934.png" alt="../_images/2022/20220316000934.png"></p></li><li><p>负载均衡:</p><ul><li>一般通过client维护可用服务列表, client通过同server建立心跳 测试server是否存活, 如果server暂时不可用, client会把server暂时放入不可用列表, 一段时间后再次尝试建立心跳(类似熔断)</li><li>心跳服务可选的有 netty提供的 HashedWheelTimer, 在不要求高精度定时心跳的情况下提供了很高的性能</li><li>Client侧负载均衡算法: 👉🏻 <a href="/31.Backend/SystemDesign-负载均衡-算法/" title="SystemDesign-负载均衡-算法">SystemDesign-负载均衡-算法</a></li></ul></li><li>超时管理:<ul><li>client端的超时处理, 例如 future.get()</li><li>server端的超时处理, 处理完后, 设定的超时参数比较, 如果发现已经超时则可以直接给client返回 err_code, 省去了序列化的时间</li></ul></li><li>服务发现:<ul><li>服务注册: server启动后注册服务信息 , 可选的存储服务有 zk/redis</li><li>服务感知/维护:<ul><li>服务端和客户端与注册中心通过心跳上报运行情况</li><li>服务提供列表发生变化, 可以通过 client pull 或者 register push的方式</li></ul></li></ul></li><li>IO模型: 参考 [[../12.Java/Java-Tutorials.09.NIO&amp;Netty##Reactor三种常见线程模型]]</li></ul><h2 id="Dubbo协议头"><a href="#Dubbo协议头" class="headerlink" title="Dubbo协议头"></a>Dubbo协议头</h2><p><img src="/images/2022/20220316001058.png" alt="../_images/2022/20220316001058.png"></p><ul><li>协议头固定长度16个字节</li><li>Magic:  共2字节 <code>static final short MAGIC = (short) 0xdabb</code></li><li>Serialization id: 表示序列化类型ID，Dubbo支持多种序列化工具，比如hessian，jdk，fastjson等</li><li>event表示事件，比如这个请求是heartbeat</li><li>two way表示请求是否是需要交互返回数据的请求</li><li>req/res表示该数据是请求还是响应</li><li>status表示状态位，当响应数据的时候，根据该字段判断是否成功。</li><li>id表示请求id</li><li>data length则表示正文内容的长度</li></ul><hr><p>@ref <a href="https://ketao1989.github.io/2016/12/10/2016-12-10-rpc-theory-in-action/" target="_blank" rel="noopener">深入浅出RPC原理 | 没有期望的分布</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;RMI&quot;&gt;&lt;a href=&quot;#RMI&quot; class=&quot;headerlink&quot; title=&quot;RMI&quot;&gt;&lt;/a&gt;RMI&lt;/h2&gt;&lt;p&gt;早期JDK1.2引入的RMI框架图: （👉🏻[[../@project/Java-RMI]]）&lt;/p&gt;
&lt;h2 id=&quot;RPC通用框架&quot;&gt;&lt;a href=&quot;#RPC通用框架&quot; class=&quot;headerlink&quot; title=&quot;RPC通用框架&quot;&gt;&lt;/a&gt;RPC通用框架&lt;/h2&gt;&lt;p&gt;通用RPC框架图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2022/20220315092643.png&quot; alt=&quot;../_images/2022/20220315092643.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="31.Backend" scheme="https://beefyheisenberg.github.io/categories/31-Backend/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://beefyheisenberg.github.io/14.Coding-Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://beefyheisenberg.github.io/14.Coding-Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-24T10:10:50.258Z</published>
    <updated>2023-05-24T10:10:50.259Z</updated>
    
    <content type="html"><![CDATA[<p>索引: <a href="https://zh.wikipedia.org/wiki/设计模式：可复用面向对象软件的基础" target="_blank" rel="noopener">设计模式：可复用面向对象软件的基础</a></p><blockquote><p>《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）是软件工程领域有关设计模式的一本书，提出和总结了对于一些常见软件设计问题的标准解决方案，称为软件设计模式。该书作者是埃里希·伽玛（Erich Gamma）、Richard Helm、Ralph Johnson和John Vlissides，后以“四人帮”（Gang of Four，GoF）[1]著称，书中的设计模式也被成为“四人帮设计模式”（Gang of Four design patterns）</p></blockquote><p><img src="/images/wikipedia-design-patterns.png" alt="wikipedia-design-patterns"></p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><ul><li>工厂类实现工厂方法, 根据传入参数的不同, 返回不同的产品实例(可以返回产品的抽象类)</li><li>简单工厂类的工厂方法是静态方法, 又称为静态工厂模式</li><li>问题:<ul><li>增加一种产品需要修改工厂方法, 增加工厂方法的复杂性</li><li>由于使用了静态方法, 简单工厂无法形成基于继承的层级结构</li></ul></li></ul><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><ul><li>抽象工厂类提供抽象工厂方法(可以有多种方法), 此类方法返回产品的抽象类；</li><li>实现抽象工厂类, 实现类需要实现不同的工厂方法, 此外还需要实现 FactoryProducer 来获取不同的工厂实例；</li><li>相比简单工厂:<ul><li>简单工厂在一个工厂方法里生产所有产品, 如果需要新增产品…需要更改具体的工厂方法；</li><li>抽象工厂包含多个“工厂实现”, 每个工厂实现类只生产一类产品, 如果需要新增产品, 只需要增加新工厂类和方法；</li><li>问题是, 用户代码又引入了”FactoryProducer”, 如果要新增产品和工厂, 需要修改抽象工厂类</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractFactory factory1 = FactoryProducer.getFactory(type1)</span><br><span class="line">AbstractFactory factory2 = FactoryProducer.getFactory(type2)</span><br><span class="line"></span><br><span class="line">AbstractProduct product1 = factory1.get()</span><br></pre></td></tr></table></figure><p>【图】抽象工厂示例，用户代码从main()函数开始，通过 FactoryProducer 获取抽象工厂（AbstractFactory）<br><img src="/images/design-patterns-abstract-factory.png" alt="../_images/design-patterns-abstract-factory.png"></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul><li>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</li><li>抽象Builder, 提供为产品设定各个属性的的抽象方法, 以及创建产品的抽象方法</li><li>具体Builder, 实现…</li><li>调用者创建具体的Builder实例, 调用抽象Builder类的设定属性的方法, 最后创建产品..</li></ul><p>【图】建造者模式，从 main()函数开始，用户代码使用 MealBuilder 创建一个复杂的 Meal 对象<br><img src="/images/design-patterns-builder.png" alt="../_images/design-patterns-builder.png"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>单例模式的类, 会保证该类仅有一个实例, 并提供一个创建&amp;获取唯一实例的方法</li><li>为了保证只有一个实例, 单例类的构造函数是私有的, 不允许其他类调用其构造函数</li><li><p>基本样式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">  private static Singleton INSTANCE;</span><br><span class="line">  private Singleton();</span><br><span class="line">  public Singleton getInstance(); // 获取单例的具体实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现singleton的几种方式:</p><ol><li>Lazy式, <code>getInstance()</code>使用synchronized 加锁</li><li>Lazy式, <code>getInstance()</code>使用DLC(double lock check)</li><li>非Lazy式, 在static区进行实例化 // 不需要lazy loading时的首选</li><li>Lazy式, 嵌套类(Singleton类里加一个static类) // 需要lazy loading时的首选</li><li>枚举 //</li></ol></li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype）是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。原型模式主要用于对象的复制，例如 clone()</p><ul><li>如果业务对象需要“可 clone”，一般需继承一个表示是 “cloneable” 的 interface ；</li><li>业务对象实现 clone()</li></ul><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>适配器模式（Adapter Pattern）</li><li>用户代码里调用 methodA(), 但是<strong>实现类</strong>没有提供 methodA() 却提供了 methodB(), 这时候需要 adaptor 类对实现类进行包装, 并提供 methodA()</li><li>实现: adaptor类中, 持有一个实现类的引用 // 注意adaptor和实现类<strong>非继承关系, 而是关联关系</strong></li></ul><p>【图】用户代码（Client 类）通过 Adaptor 的实例，最终调用 methodB()<br><img src="/images/design-patterns-adapter.png" alt="design-patterns-adapter"></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p><strong>桥接模式</strong>是<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F" title="软件设计模式" target="_blank" rel="noopener">软件设计模式</a>中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。</p><ul><li>桥接（Bridge）模式把抽象事物/抽象行为分离开, 抽象事物调用抽象行为(的方法)</li><li>桥接是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</li><li>抽象事物(Abstraction)的继承类仍是抽象类(RedefinedAbstraction)</li><li>抽象行为(Implementor)</li><li>抽象事物(Abstraction)像桥一样把 RedefinedAbstraction 类和 Implementor 类连接在一起</li><li>实现:<ul><li>抽象事物(Abstraction) 持有抽象行为(Implementor)的引用</li><li>RedefinedAbstraction extends Abstraction //实现具体事物</li><li>ConcreteImplementor extends Implementor  //实现具体行为</li></ul></li></ul><p>【图】<br><img src="/images/design-patterns-bridge.png" alt="design-patterns-bridge"></p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ul><li>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</li><li>增加一个修饰类, 包裹原来的类, 包裹的方式一般是通过修饰类的构造函数传入, 修饰类实现新的功能</li><li>装饰模式可以避免向一个实现类添加新方法导致代码膨胀</li><li>下图中的 Decorator类即装饰类, 装饰类可以改写operation()方法也可以增加自己的方法</li><li>实现:<ul><li>需要被装饰的类(ConcreteComponent), 和它的基类(Component)</li><li>装饰类(Decorator) 持有基类的一个引用. 事实上装饰类也继承上面的基类</li></ul></li></ul><p><img src="/images/design-patterns-decorator.png" alt="design-patterns-decorator"></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul><li>用户代码不调用具体的功能类, 而是通过调用代理类间接调用这些功能类 (用户代码往往调用的是代理类的抽象接口, 代理也不直接调用功能类, 而是调用功能类的接口)</li><li>代理类可以调用多种功能类, 并且可以在代理类中, 增加一些功能 @link [[../12.Java/Java-Tutorials.14.代理(Proxy)]]</li><li>实现:<ul><li>被代理的类(RealSubject), 需要有一个接口(Subject)</li><li>创建Proxy类, Proxy类也实现该接口(Subject)</li><li>用户(client) 不直接调用 <code>realSubject.DoAction()</code>, 调用的是接口（Subject）的方法，然后是 Proxy的<code>DoAction()</code>, 最终调用 <code>realSubject.DoAction()</code></li><li>可以在代理类 <code>Proxy::DoAction()</code>中做一些额外的操作: e.g. 实现引用计数 &amp; Java的AOP(面向切面编程)</li></ul></li></ul><p><img src="/images/design-patterns-proxy.png" alt="design-patterns-proxy"></p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><ul><li>享元模式（Flyweight Pattern），创建大量对象时, 把这些对象共有的部分抽象出来单独存储, 这些对象共享共有部分, 而不是重复创建</li><li>享元模式通过共享数据减少内存使用量</li><li>例子: Java String Pool、Java Intger</li></ul><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ul><li>实现责任链模式的抽象类, 通常具有一个next属性</li><li>实现类判断是否在自己这一层进行处理, 然后传递给next指向的对象</li><li>例如一条日志具有 debug/info/warning/error几个级别, 每个实现类判断自己是否需要处理(自己的优先级同这条日志的优先级比较), 然后传给下一个实现类</li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul><li>观察者 attach到被观察者, 被观察者发生改变时, 通知观察者</li><li>下图中, Observer是观察者, Subject作为被观察者的抽象类, 提供了attach和detach观察者的方法(add和delete)</li><li>实现:<ul><li>被观察者( Subject) 持有观察者(Observer)的对象</li><li>注意二者关系是聚合关系(一种松散的关联关系, 二者不必有共同生命周期, Observer可以随时attach/detach到Subject)</li></ul></li></ul><p><img src="/images/design-patterns-observer.png" alt="../_images/design-patterns-observer.png"></p><h1 id="JDK里的设计模式-zz"><a href="#JDK里的设计模式-zz" class="headerlink" title="JDK里的设计模式(zz)"></a>JDK里的设计模式(zz)</h1><ul><li>创建模式:<pre><code>- 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 `java.util.Calendar#getInstance()`。- 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：`java.lang.StringBuilder#append()`。- 工厂方法：一个返回具体对象的方法，而不是多个，如 `java.lang.Object#toString()`、`java.lang.Class#newInstance()`。- 原型模式：使得类的实例能够生成自身的拷贝、如：`java.lang.Object#clone()`。- 单例模式：全局只有一个实例，如 `java.lang.Runtime#getRuntime()`。</code></pre></li><li>结构型模式：<pre><code>- 适配器：用来把一个接口转化成另一个接口，如 `java.util.Arrays#asList()`。- 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；- 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 `Map.putAll`，`List.addAll`、`Set.addAll`。- 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 `java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap`。- 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。- 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 `java.lang.reflect.Proxy`</code></pre></li><li>行为模式：<pre><code>- 命令模式：将操作封装到对象内，以便存储，传递和返回，如：`java.lang.Runnable`。- 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，`java.text.Format`，`java.text.Normalizer`。- 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 `java.util.Iterator`。- 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，`java.lang.reflect.Method#invoke()`。- 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 `java.util.EventListener`。- 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 `javax.servlet.Filter#doFilter()`。- 空对象模式：如 `java.util.Collections#emptyList()`。- 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 `java.util.Collections#sort()`。</code></pre></li></ul><p>@ref:</p><ul><li><a href="https://www.javacodegeeks.com/2011/03/design-patterns-in-jdk.html" target="_blank" rel="noopener">Design Patterns in the JDK | Java Code Geeks - 2021</a></li><li><a href="https://coolshell.cn/articles/3320.html" target="_blank" rel="noopener">JDK里的设计模式 | 酷 壳 - CoolShell</a></li></ul><h1 id="关于UML"><a href="#关于UML" class="headerlink" title="关于UML"></a>关于UML</h1><p>UML参考: <a href="/14.Coding-Pattern/设计模式-UML类图/" title="设计模式-UML类图">设计模式-UML类图</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;索引: &lt;a href=&quot;https://zh.wikipedia.org/wiki/设计模式：可复用面向对象软件的基础&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式：可复用面向对象软件的基础&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）是软件工程领域有关设计模式的一本书，提出和总结了对于一些常见软件设计问题的标准解决方案，称为软件设计模式。该书作者是埃里希·伽玛（Erich Gamma）、Richard Helm、Ralph Johnson和John Vlissides，后以“四人帮”（Gang of Four，GoF）[1]著称，书中的设计模式也被成为“四人帮设计模式”（Gang of Four design patterns）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/wikipedia-design-patterns.png&quot; alt=&quot;wikipedia-design-patterns&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建型模式&quot;&gt;&lt;a href=&quot;#创建型模式&quot; class=&quot;headerlink&quot; title=&quot;创建型模式&quot;&gt;&lt;/a&gt;创建型模式&lt;/h1&gt;&lt;h2 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工厂&lt;/h2&gt;</summary>
    
    
    
    <category term="14.Coding-Pattern" scheme="https://beefyheisenberg.github.io/categories/14-Coding-Pattern/"/>
    
    
    <category term="设计模式" scheme="https://beefyheisenberg.github.io/tags/设计模式/"/>
    
    <category term="Design Pattern" scheme="https://beefyheisenberg.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Tomcat/</id>
    <published>2023-05-24T10:10:50.223Z</published>
    <updated>2023-05-24T10:10:50.226Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png" alt="Tomcat"></p><h1 id="为什么-Java-Web-开发需要-Tomcat"><a href="#为什么-Java-Web-开发需要-Tomcat" class="headerlink" title="为什么 Java Web 开发需要 Tomcat"></a>为什么 Java Web 开发需要 Tomcat</h1><p>JavaEE、Servlet、Java Web 的概念：</p><ul><li><strong>Java EE</strong>（Java Platform Enterprise Edition，2018 年 3 月更名为<strong>Jakarta EE</strong>）是一些列（Java 企业级开发）标准集合；</li><li>Servlet 是 Java EE 众多标准下的一个 （link <a href="/13.JavaEE-Framework/JavaEE.Servlet/" title="JavaEE.Servlet">JavaEE.Servlet</a>），主要定义了进行 Java Web 开发的规范（Request、Response 对象、servlet 生命周期）</li></ul><p>一个典型的 Servlet 工作模式：</p><ul><li>创建并填充 Request 对象，包括：URI、参数、method、请求头信息、请求体信息等</li><li>创建 Response 对象</li><li>执行业务逻辑，将结果通过 Response 的输出流输出到客户端</li></ul><p>所以 Servlet 定义了众多规范：Request &amp; Response 对象、Servlet 生命周期（init &amp; service &amp; destory 方法）…<br>但 Servlet 没有 main 方法，需要在一个 Servlet 容器里面才能执行，Servlet 容器按照上述规范调用 Servlet 的方法，Tomcat 即是一个 Servlet 容器，在下面 Tomcat 源码分析可以看到 Tomcat 是如何使用 Servlet 规范处理一个 Http 请求的：</p><blockquote><ul><li>Tomcat 接到 Http 请求后，使用 Poller 线程来处理这个请求的 socket，在 Poller 线程没有太多的处理，只是确认收包完整，然后把请求丢给 executor（工作线程池）；</li><li>在工作线程，把 Socket 读取到的数据，按照 Http 协议进行解析，并生成 Request 对象（这里也是按照 Servlet Request 的标准），并最终调用了 <code>Servlet.service()</code></li><li>Tomcat 的一个 Context 对应一个 <strong>ServletContext</strong>，一个 Context 下有 1 个 or 多个 <strong>Servlet 实现</strong></li></ul></blockquote><p>回答最开是问题，为什么 Java Web 开发需要 Tomcat？<br>Java Web 一般要遵循 Servlet 规范，Tomcat 是一个 Servlet 容器的实现，所以~ Java Web 开发需要 Tomcat。<br>那么开发 Java Web 可以摆脱 Servlet 吗？也可以不用，比如 Spring 5 支持的 WebFlux framework</p><blockquote><p><a href="https://www.quora.com/Is-it-possible-to-create-a-Java-web-application-without-servlets" target="_blank" rel="noopener">Is it possible to create a Java web application without servlets? - Quora</a></p></blockquote><h1 id="Tomcat-整体架构"><a href="#Tomcat-整体架构" class="headerlink" title="Tomcat 整体架构"></a>Tomcat 整体架构</h1><p><img src="/images/JavaEE.Tomcat-2023-05-04-1.png" alt="../_images/JavaEE.Tomcat-2023-05-04-1.png"></p><p>Tomcat 的架构如上图，主要的组件如下：</p><ul><li><p><strong>Server</strong>: 表示服务器，它提供了一种优雅的方式来启动和停止整个系统，不必单独启停连接器和容器；它是 Tomcat 构成的顶级构成元素，所有一切均包含在 Server 中；</p></li><li><p><strong>Service</strong>: 表示服务，Server 可以运行多个服务。比如一个 Tomcat 里面可运行订单服务、支付服务、用户服务等等；Server 的实现类 StandardServer 可以包含一个到多个 Services, Service 的实现类为 StandardService 调用了容器(Container)接口，其实是调用了 Servlet Engine(引擎)，而且 StandardService 类中也指明了该 Service 归属的 Server;</p></li><li><p><strong>Container</strong>: 表示容器，可以看做 Servlet 容器；引擎(Engine)、主机(Host)、上下文(Context)和 Wraper 均继承自 Container 接口，所以它们都是容器。</p><ul><li>Engine – 引擎</li><li>Host – 主机</li><li>Context – 上下文</li><li>Wrapper – 包装器</li></ul></li><li><p><strong>Connector</strong>: 表示连接器, <strong>它将 Service 和 Container 连接起来</strong>，首先它需要注册到一个 Service，它的作用就是把来自客户端的请求转发到 Container(容器)，这就是它为什么称作连接器, 它支持的协议如下：</p><ul><li>支持 AJP 协议</li><li>支持 Http 协议</li><li>支持 Https 协议</li></ul></li><li><p><strong>Service 内部</strong>还有各种支撑组件，下面简单罗列一下这些组件</p><ul><li>Manager – 管理器，用于管理会话 Session</li><li>Logger – 日志器，用于管理日志</li><li>Loader – 加载器，和类加载有关，只会开放给 Context 所使用</li><li>Pipeline – 管道组件，配合 Valve 实现过滤器功能</li><li>Valve – 阀门组件，配合 Pipeline 实现过滤器功能</li><li>Realm – 认证授权组件</li></ul></li></ul><p>在下面讲解配置文件的时候可以看到，server.xml 里的元素，与上面的组件一一对应。</p><p>本节参考 @ref： <a href="https://pdai.tech/md/framework/tomcat/tomcat-x-arch.html" target="_blank" rel="noopener">https://pdai.tech/md/framework/tomcat/tomcat-x-arch.html</a></p><h1 id="配置文件-server-xml"><a href="#配置文件-server-xml" class="headerlink" title="配置文件 server.xml"></a>配置文件 server.xml</h1><p>一个配置文件实例:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JasperListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="server-xml-配置元素分类"><a href="#server-xml-配置元素分类" class="headerlink" title="server.xml 配置元素分类"></a>server.xml 配置元素分类</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>server.xml 的整体结构如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 现在常常使用自动部署，不推荐配Context --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Context表示一个War应用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>该结构中只给出了 Tomcat 的核心组件，除了核心组件外，Tomcat 还有一些其他组件，下面介绍一下组件的分类。</p><h3 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h3><p>server.xml 文件中的元素可以分为以下 4 类：</p><ul><li>（1）顶层元素：<code>&lt;Server&gt;</code> 和 <code>&lt;Service&gt;</code></li></ul><p><code>&lt;Server&gt;</code> 元素是整个配置文件的根元素，<code>&lt;Service&gt;</code> 元素则代表一个 Engine 元素以及一组与之相连的 Connector 元素。</p><ul><li>（2）连接器：<code>&lt;Connector&gt;</code></li></ul><p><code>&lt;Connector&gt;</code> 代表了外部客户端发送请求到特定 Service 的接口；同时也是外部客户端从特定 Service 接收响应的接口。</p><ul><li>（3）容器：<code>&lt;Engine&gt;</code> <code>&lt;Host&gt;</code> <code>&lt;Context&gt;</code></li></ul><p>容器的功能是处理 Connector 接收进来的请求，并产生相应的响应。Engine、Host 和 Context 都是容器，都实现了 Container 接口，但它们不是平行的关系，而是父子关系：Engine 包含 Host，Host 包含 Context。</p><ul><li>Engine 表示一个 Servlet 引擎，它可以包含一个或多个子容器，比如 Host 或者 Context 容器；</li><li>Host 表示一台虚拟的主机，它可以包含一系列 Context 容器；</li><li>Context 表示一个唯一的 ServletContext，一个 Context 对应一个 Web 工程，它可以包含一个或多个 Wrapper 容器；</li><li>Wrapper 表示一个独立的 Servlet 定义，即 Wrapper 本质就是对 Servlet 进行了一层包装。</li></ul><p>一个 Engine 组件可以处理 Service 中的所有请求，一个 Host 组件可以处理发向一个特定虚拟主机的所有请求，一个 Context 组件可以处理一个特定 Web 应用的所有请求。</p><ul><li>（4）内嵌组件：</li></ul><p>可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host 和 Context 是最重要的最核心的 Tomcat 组件，其他组件都可以归为内嵌组件。</p><p>下面将详细介绍 Tomcat 中各个核心组件的作用，以及相互之间的关系。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>本部分将分别介绍各个核心组件的作用、特点以及配置方式等。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server 元素在最顶层，代表整个 Tomcat 容器，因此它必须是 server.xml 中唯一一个最外层的元素。一个 Server 元素中可以有一个或多个 Service 元素。</p><p>在第一部分的例子中，在最外层有一个 <code>&lt;Server&gt;</code> 元素，shutdown 属性表示关闭 Server 的指令；port 属性表示 Server 接收 shutdown 指令的端口号，设为-1可以禁掉该端口。</p><p>Server 的主要任务，就是提供一个接口让客户端能够访问到这个 Service 集合，同时维护它所包含的所有的 Service 的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的 Service。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 的作用，是在 Connector 和 Engine 外面包了一层，把它们组装在一起，对外提供服务。一个 Service 可以包含多个 Connector，但是只能包含一个 Engine；其中 Connector 的作用是从客户端接收请求，Engine 的作用是处理接收进来的请求。</p><p>在第一部分的例子中，Server 中包含一个名称为“Catalina”的 Service。实际上，Tomcat 可以提供多个 Service，不同的 Service 监听不同的端口，后文会有介绍。</p><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector 的主要功能，是接收连接请求，创建 Request 和 Response 对象用于和请求端交换数据；然后分配线程让 Engine 来处理这个请求，并把产生的 Request 和 Response 对象传给 Engine。</p><p>通过配置 Connector，可以控制请求 Service 的协议及端口号。在第一部分的例子中，Service 包含两个 Connector：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>（1）通过配置第 1 个 Connector，客户端可以通过 8080 端口号使用 http 协议访问 Tomcat。其中，protocol 属性规定了请求的协议，port 规定了请求的端口号，redirectPort 表示当强制要求 https 而请求是 http 时，重定向至端口号为 8443 的 Connector，connectionTimeout 表示连接的超时时间。</li><li>（2）通过配置第 2 个 Connector，客户端可以通过 8009 端口号使用 AJP 协议访问 Tomcat。AJP 协议负责和其他的 HTTP 服务器(如 Apache)建立连接；在把 Tomcat 与其他 HTTP 服务器集成时，就需要用到这个连接器。之所以使用 Tomcat 和其他服务器集成，是因为 Tomcat 可以用作 Servlet/JSP 容器，但是对静态资源的处理速度较慢，不如 Apache 和 IIS 等 HTTP 服务器；因此常常将 Tomcat 与 Apache 等集成，前者作 Servlet 容器，后者处理静态资源，而 AJP 协议便负责 Tomcat 和 Apache 的连接。Tomcat 与 Apache 等集成的原理如下图(图片来源)：</li></ul><p><img src="/images/javaee/tomcat_ajp_apache.png" alt="tomcat_ajp_apache"></p><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine 组件在 Service 组件中有且只有一个；Engine 是 Service 组件中的请求处理组件。Engine 组件从一个或多个 Connector 中接收请求并处理，并将完成的响应返回给 Connector，最终传递给客户端。</p><p>在第一部分的例子中，Engine 的配置语句如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，name 属性用于日志和错误信息，在整个 Server 中应该唯一。defaultHost 属性指定了默认的 host 名称，当发往本机的请求指定的 host 名称不存在时，一律使用 defaultHost 指定的 host 进行处理；因此，defaultHost 的值，必须与 Engine 中的一个 Host 组件的 name 属性值匹配。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><h4 id="Engine-与-Host"><a href="#Engine-与-Host" class="headerlink" title="Engine 与 Host"></a>Engine 与 Host</h4><p>Host 是 Engine 的子容器。Engine 组件中可以内嵌 1 个或多个 Host 组件，每个 Host 组件代表 Engine 中的一个虚拟主机。Host 组件至少有一个，且其中一个的 name 必须与 Engine 组件的 defaultHost 属性相匹配。</p><h4 id="Host-的作用"><a href="#Host-的作用" class="headerlink" title="Host 的作用"></a>Host 的作用</h4><p>Host 虚拟主机的作用，是运行多个 Web 应用（一个 Context 代表一个 Web 应用），并负责安装、展开、启动和结束每个 Web 应用。</p><p>Host 组件代表的虚拟主机，对应了服务器中一个网络名实体(如” <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> ”，或 IP 地址”116.25.25.25”)；为了使用户可以通过网络名连接 Tomcat 服务器，这个名字应该在 DNS 服务器上注册。</p><h4 id="Host-的配置"><a href="#Host-的配置" class="headerlink" title="Host 的配置"></a>Host 的配置</h4><p>在第一部分的例子中，Host 的配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面对其中配置的属性进行说明：</p><p>name 属性指定虚拟主机的主机名，一个 Engine 中有且仅有一个 Host 组件的 name 属性与 Engine 组件的 defaultHost 属性相匹配；一般情况下，主机名需要是在 DNS 服务器中注册的网络名，但是 Engine 指定的 defaultHost 不需要，原因在前面已经说明。</p><p>unpackWARs 指定了是否将代表 Web 应用的 WAR 文件解压；如果为 true，通过解压后的文件结构运行该 Web 应用，如果为 false，直接使用 WAR 文件运行 Web 应用。</p><p>Host 的 autoDeploy 和 appBase 属性，与 Host 内 Web 应用的自动部署有关；此外，本例中没有出现的 xmlBase 和 deployOnStartup 属性，也与 Web 应用的自动部署有关；将在下一节(Context)中介绍。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="Context-的作用"><a href="#Context-的作用" class="headerlink" title="Context 的作用"></a>Context 的作用</h4><p>Context 元素代表在特定虚拟主机上运行的一个 Web 应用。每个 Web 应用基于 WAR 文件，或 WAR 文件解压后对应的目录（这里称为应用目录）。</p><p>Context 是 Host 的子容器，每个 Host 中可以定义任意多的 Context 元素。</p><p>在第一部分的例子中，可以看到 server.xml 配置文件中并没有出现 Context 元素的配置。这是因为，Tomcat 开启了自动部署，Web 应用没有在 server.xml 中配置静态部署，而是由 Tomcat 通过特定的规则自动部署。下面介绍一下 Tomcat 自动部署 Web 应用的机制。</p><h4 id="Web-应用自动部署"><a href="#Web-应用自动部署" class="headerlink" title="Web 应用自动部署"></a>Web 应用自动部署</h4><p>如何开启自动部署 War:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外 Context 组件还有一个 reloadable 属性, <code>&lt;Context docBase=&quot;xxx&quot; path=&quot;/xxx&quot; reloadable=&quot;true&quot;/&gt;</code><br>替换 WEB-INF/lib 目录中的 jar 文件或 WEB-INF/classes 目录中的 class 文件时，reloadable=”true”会让修改生效（但代价不小），该选项适合调试。</p><p>autoDeploy 和 reloadable 的区别是, 前者是 Host 的属性后者是 Context 的属性,<br>前者监控的是 webapps 目录下 War 包的改动, 后者监控的是 webapps 下面文件夹内 jar 或者 class 文件的变化;</p><p>一般线上环境会关闭这两个参数, 开发阶段可以通过这两个参数无需重启 tomcat 预览改变;</p><h5 id="自动部署的实现"><a href="#自动部署的实现" class="headerlink" title="自动部署的实现"></a>自动部署的实现</h5><blockquote><p>Tomcat 的 Engine 会启动一个线程，该线程每 10s 会发送一个发送一个事件，监听到该事件的部署配置类, 会自动去扫描 webapp 文件夹下的 war 包，将其加载成一个 Context，即启动一个 web 服务。</p></blockquote><p>Tomcat 的 <code>StandardEngine</code> 会在 <code>starInternal()</code> 启动一个线程，该线程运行的是 <code>ContainerBackgroundProcessor.run()</code> 方法,<br>这个 run 每隔10s 唤醒调用一次 <code>processChildren()</code>, 继续跟踪该方法，会看到调用其子容器 Engine、Host、Context、Wrapper 各容器组件及与它们相关的其它组件的 backgroundProcess 方法。<br><code>backgroundProcess()</code> 发送一个事件 <code>Lifecycle.PERIODIC_EVENT</code>,<br>StandardHost 通 server.xml 配置了 HostConfig 监听器，对该事件的响应方法是 <code>HostConfig.lifecycleEvent()</code>,<br><code>lifecycleEvent()</code> 会检查 <code>autoDeploy=&quot;true&quot;</code> 的配置, 如果开启了, 则调用 <code>deployApps()</code> 扫描 webapp 文件夹下的 war 包，将其加载成一个 Context，即启动一个 web 服务。</p><h2 id="核心组件的关联"><a href="#核心组件的关联" class="headerlink" title="核心组件的关联"></a>核心组件的关联</h2><h3 id="整体关系"><a href="#整体关系" class="headerlink" title="整体关系"></a>整体关系</h3><p>核心组件之间的整体关系，在上一部分有所介绍，这里总结一下：</p><p>Server 元素在最顶层，代表整个 Tomcat 容器；一个 Server 元素中可以有一个或多个 Service 元素。<br>Service 在 Connector 和 Engine 外面包了一层，把它们组装在一起，对外提供服务。<strong>一个 Service 可以包含多个 Connector，但是只能包含一个 Engine；</strong>  Connector 接收请求，Engine 处理请求。<br>Engine、Host 和 Context 都是容器，且 Engine 包含 Host，Host 包含 Context。每个 Host 组件代表 Engine 中的一个虚拟主机；每个 Context 组件代表在特定 Host 上运行的一个 Web 应用。</p><p><img src="/images/javaee/tomcat_architecture.png" alt=""></p><h3 id="如何确定请求由谁处理？"><a href="#如何确定请求由谁处理？" class="headerlink" title="如何确定请求由谁处理？"></a>如何确定请求由谁处理？</h3><p>当请求被发送到 Tomcat 所在的主机时，如何确定最终哪个 Web 应用来处理该请求呢？</p><ul><li>（1）根据协议和端口号选定 Service 和 Engine</li></ul><p>Service 中的 Connector 组件可以接收特定端口的请求，当请求进来时，Tomcat 便可以根据协议和端口号选定处理请求的 Service；Service 一旦选定，Engine 也就确定。</p><ul><li>（2）根据域名或 IP 地址选定 Host</li></ul><p>Service 确定后，Tomcat 在 Service 中寻找名称与域名/IP 地址匹配的 Host 处理该请求。如果没有找到，则使用 Engine 中指定的 defaultHost 来处理该请求。</p><ul><li>（3）根据 URI 选定 Context/Web 应用</li></ul><p>这一点在 Context 一节有详细的说明：Tomcat 根据应用的 path 属性与 URI 的匹配程度来选择 Web 应用处理相应请求，这里不再赘述。</p><ul><li>（4）举例</li></ul><p>以请求 <a href="http://localhost:8080/app1/index.html为例" target="_blank" rel="noopener">http://localhost:8080/app1/index.html为例</a> ，首先通过协议和端口号（http 和 8080）选定 Service；然后通过主机名（localhost）选定 Host；然后通过 uri（/app1/index.html）选定 Web 应用。</p><h3 id="如何部署多个-war-包项目"><a href="#如何部署多个-war-包项目" class="headerlink" title="如何部署多个 war 包项目"></a>如何部署多个 war 包项目</h3><p>@todo</p><h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener(即监听器)定义的组件，可以在特定事件发生时执行特定的操作；被监听的事件通常是 Tomcat 的启动和停止。<br>监听器可以在 Server、Engine、Host 或 Context 中，本例中的监听器都是在 Server 中。实际上，本例中定义的 6 个监听器，都只能存在于 Server 组件中。监听器不允许内嵌其他组件。<br>监听器需要配置的最重要的属性是 className，该属性规定了监听器的具体实现类，该类必须实现了 <code>org.apache.catalina.LifecycleListener</code> 接口。</p><h3 id="GlobalNamingResources-与-Realm"><a href="#GlobalNamingResources-与-Realm" class="headerlink" title="GlobalNamingResources 与 Realm"></a>GlobalNamingResources 与 Realm</h3><p>@todo</p><h3 id="Valve"><a href="#Valve" class="headerlink" title="Valve"></a>Valve</h3><p>在第一部分的例子中，Host 元素内定义了 Valve 组件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>单词 Valve 的意思是“阀门”，在 Tomcat 中代表了请求处理流水线上的一个组件；Valve 可以与 Tomcat 的容器(Engine、Host 或 Context)关联。<br>不同的 Valve 有不同的特性，下面介绍一下本例中出现的 AccessLogValve。<br>AccessLogValve 的作用是通过日志记录其所在的容器中处理的所有请求，在本例中，Valve 放在 Host 下，便可以记录该 Host 处理的所有请求。AccessLogValve 记录的日志就是访问日志，每天的请求会写到一个日志文件里。AccessLogValve 可以与 Engine、Host 或 Context 关联；在本例中，只有一个 Engine，Engine 下只有一个 Host，Host 下只有一个 Context，因此 AccessLogValve 放在三个容器下的作用其实是类似的。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="bin-catalina-sh"><a href="#bin-catalina-sh" class="headerlink" title="bin/catalina.sh"></a>bin/catalina.sh</h2><p>这里主要是对 JVM 参数的设置，主要修改 Xms, Xmx, PermSize 几个参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS="-Xms8g -Xmx8g -Xmn2g -server -DServer=mblog -XX:PermSize=128m -XX:MaxPermSize=128m -XX:MaxTenuringThreshold=4 -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=8 -XX:CMSInitiatingOccupancyFraction=70 -XX:+ExplicitGCInvokesConcurrent -XX:+PrintFlagsFinal -XX:+PrintCommandLineFlags -XX:+PrintGCDateStamps -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -Xloggc:../gclogs/gc.log.$nowday"</span><br></pre></td></tr></table></figure><h2 id="conf-server-xml"><a href="#conf-server-xml" class="headerlink" title="conf/server.xml"></a>conf/server.xml</h2><p>这里主要是对 Connector 和线程池的设置</p><p>主要优化点 @tldr：</p><ul><li><strong>maxThreads</strong> = 业务线程池大小，一般几百~几 K，如果并发到来的<strong>请求数</strong>超过 maxThreads，再新来的请求不能被及时处理；</li><li><strong>maxConnections</strong>：意思是 Tomcat 维护的<strong>已建立连接数</strong>上限。当连接数达到 maxConnections，Tomcat 不会再 accept，而是直接 block 掉（这时候系统仍然能 accept，但 Tomcat 不会把新连接扔给 Poller 线程了，而是 block 掉新的连接），maxConnections 在 NIO 模式默认是 1W；</li><li><strong>acceptCount</strong>：如果所有的业务线程都在忙（ all possible request processing threads are in use），即并发处理中的<strong>请求数</strong>超过了 maxThreads。这时候新请会放入 accept 队列（区别 socket 的 accept），acceptCount 即是这个队列的长度，默认 100；</li></ul><blockquote><p>区分连接数 &amp; 请求数：</p><ul><li>连接数：建立并监听读写事件的 Connection 数量，大部分 Connection 都是空闲的，少数有读写</li><li>请求数：指客户端发 Http Request 过来，Tomcat 会把 Request 放入<strong>业务线程池</strong>处理</li></ul></blockquote><p>maxConnections 决定<strong>连接数</strong>上限；<br>acceptCount + maxThread 决定<strong>并发请求</strong>的上限；</p><p>用 <a href="https://asciiflow.com/#/" target="_blank" rel="noopener">ASCIIFlow</a> 画图解释：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">新连接到来：</span><br><span class="line"></span><br><span class="line">[Acceptor] ────────────► [Poller] ──线程池是否满？────NO─────► [业务线程池]&lt;maxThreads limits&gt;</span><br><span class="line">      &lt;maxConnections limits&gt;            │                    ▲</span><br><span class="line">                                        Yes                   │</span><br><span class="line">                                         │                    │</span><br><span class="line">                                         ┴───►[accept queue]──┴</span><br><span class="line">                                          &lt;acceptCount limits&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图示：</span><br><span class="line">[ ] 表示对象实体</span><br><span class="line">&lt; &gt; 表示限制</span><br></pre></td></tr></table></figure><blockquote><p>这几个参数容易混淆，如果搞清楚 Tomcat 的 NIO 线程模型，就不难理解了</p></blockquote><hr><p>Tomcat 采用 Request Per Thread 策略, 每个用户请求由一个线程处理, <code>&lt;Executor&gt;</code> 部分定义了该线程池, 该线程池被多个 <code>&lt;Connector&gt;</code> 共享, server.xml 里的优化主要在 <code>&lt;Connector&gt;</code>:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.StandardThreadExecutor"</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxThreads</span>=<span class="string">"300"</span> <span class="attr">minSpareThreads</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定使用上面的线程池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">port</span>=<span class="string">"8080"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">"8000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableLookups</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptCount</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxThreads</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">acceptorThreadCount</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">"utf-8"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">"443"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">compression</span>=<span class="string">"on"</span> <span class="attr">compressionMinSize</span>=<span class="string">"1024"</span> <span class="attr">compressableMimeType</span>=<span class="string">"text/html,text/xml,text/javascript,text/css,text/plain,application/json,application/xml"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>Executor 参数</p><ul><li><strong>maxThreads</strong>:  线程池最大线程数</li><li><strong>minSpareThreads</strong>: 线程池最小线程数(线程池初始化时), 默认 25</li></ul></li><li><p>Connector 参数:</p><ul><li><strong>executor</strong>: 指明使用哪一个 Executor, 如果指定了,那么 Connector 中所有关于线程的设定会被忽略, 如果没有指定一个线程池, Connector 将会创建一个私有的线程池.</li><li><strong>maxThreads</strong>: 用于处理客户端请求的最大线程数, 设置为多少视 CPU 处理能力而定, 一般单个应用不应该超过 300, 如果超过 300 应考虑多个 Tomcat 组成集群方式</li><li>enableLookups: 是否开启域名反查，一般设置为 false 来提高处理能力，它的取值还有 true，一般很少使用。若设为 true, 则支持域名解析，可把 ip 地址解析为主机名</li><li>connectionTimeout: 网络连接超时，单位：毫秒。设置为 0 表示永不超时</li><li><strong>acceptorThreadCount</strong>: 默认为 1，表示用于 accept 新 socket 连接的线程个数。一般跟监听端口数匹配。</li><li><strong>acceptCount</strong>: 当全部线程都在忙(意味着客户端并发数超过 maxThreads 个线程), 新的请求会放入 accept 队列, 该值是队列的 size, 默认 100</li><li><strong>maxConnections</strong>: Tomcat 的最大连接数, 如果连接数超过 maxConnections, tomcat 将不再 accept 新的连接而是拒绝, For NIO and NIO2 the default is 10000. For APR/native, the default is 8192.</li><li>compressionMinSize: 大于这个数值讲开启压缩, 默认为 2K</li><li>compressableMimeType: 压缩哪些类型</li><li><p><strong>protocol</strong>：协议类型，可选类型有四种，分别为 BIO（阻塞型 IO），NIO，NIO2 和 APR。</p><ul><li>BIO：BIO(Blocking I/O)，顾名思义，即阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作(即 java.io 包及其子包)。Tomcat 在默认情况下，是以 bio 模式运行的。遗憾的是，就一般而言，bio 模式是三种运行模式中性能最低的一种。BIO 配置采用默认即可。</li><li>NIO：NIO(New I/O)，是 Java SE 1.4及后续版本提供的一种新的 I/O 操作方式(即 java.nio 包及其子包)。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API，因此 nio 也被看成是 non-blocking I/O 的缩写。它拥有比传统 I/O 操作(bio)更好的并发运行性能。要让 Tomcat 以 nio 模式来运行也比较简单，我们只需要 protocol 类型修改为：<code>protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</code><br>对于互联网应用，我们应该在 NIO、NIO2 之间做选择，因为它能够有效的提升性能（主要是并发能力），其中 NIO2 即为 AIO，需要 JDK 1.7+、Linux 2.6+才能支持。<ul><li>NIO：JDK 1.6+，tomcat 6.x+</li><li>NIO2：JDK 1.7+，tomcat 7.x+</li></ul></li><li><p>APR: 通过 Native 实现的 I/O 库, Tomcat 通过 JNI 调用;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Tomcat 支持的几种protocol:</span><br><span class="line">//NIO</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">//NIO2</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;</span><br><span class="line">//ARP</span><br><span class="line">protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>@ref:</p><ul><li><a href="https://www.cnblogs.com/zhanjindong/p/concurrent-and-tomcat-threads.html" target="_blank" rel="noopener">聊下并发和Tomcat线程数（Updated） - zhanjindong - 博客园</a></li><li><a href="https://www.zhihu.com/question/53498767" target="_blank" rel="noopener">tomcat 源码为啥不采用netty 处理并发？ - 知乎</a></li></ul><h3 id="附-Connector-和线程池参数解析"><a href="#附-Connector-和线程池参数解析" class="headerlink" title="附: Connector 和线程池参数解析"></a>附: Connector 和线程池参数解析</h3><ol><li><code>&lt;Executor&gt;</code> 部分, 参数说明: <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/executor.html</a><ul><li><strong>namePrefix</strong>: The name prefix for each thread created by the executor</li><li><strong>maxThreads</strong>: The max number of active threads in this pool, default is 200</li><li><strong>minSpareThreads</strong>: The minimum number of threads (idle and active) always kept alive, default is 25</li><li><strong>maxIdleTime</strong>: The number of milliseconds before an idle thread shutsdown, unless the number of active threads are less or equal to minSpareThreads. Default value is 60000(1 minute)</li><li><strong>maxQueueSize</strong>: The maximum number of runnable tasks that can queue up awaiting execution before we reject them. Default value is Integer.MAX_VALUE</li></ul></li><li><code>&lt;Connector&gt;</code> 部分, <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</a><ul><li><strong>executor</strong>: A reference to the name in an Executor element. If this attribute is set, and the named executor exists, the connector will use the executor, and all the other thread attributes will be ignored. Note that if a shared executor is not specified for a connector then the connector will use a private, internal executor to provide the thread pool.</li><li><strong>acceptCount</strong>: The maximum queue length for incoming connection requests when all possible request processing threads are in use. Any requests received when the queue is full will be refused. The default value is 100.</li><li><strong>connectionTimeout</strong>: The number of milliseconds this Connector will wait, after accepting a connection, for the request URI line to be presented. Use a value of -1 to indicate no (i.e. infinite) timeout. The default value is 60000 (i.e. 60 seconds) but note that the standard server.xml that ships with Tomcat sets this to 20000 (i.e. 20 seconds). Unless disableUploadTimeout is set to false, this timeout will also be used when reading the request body (if any).</li><li><strong>maxThreads</strong>: The maximum number of request processing threads to be created by this Connector, which therefore determines the maximum number of simultaneous requests that can be handled. If not specified, this attribute is set to 200. If an executor is associated with this connector, this attribute is ignored as the connector will execute tasks using the executor rather than an internal thread pool. Note that if an executor is configured any value set for this attribute will be recorded correctly but it will be reported (e.g. via JMX) as -1 to make clear that it is not used.</li><li><strong>acceptorThreadCount</strong>: The number of threads to be used to accept connections. Increase this value on a multi CPU machine, although you would never really need more than 2. Also, with a lot of non keep alive connections, you might want to increase this value as well. Default value is 1.</li><li><strong>maxConnections</strong>: The maximum number of connections that the server will accept and process at any given time. When this number has been reached, the server will accept, but not process, one further connection. This additional connection be blocked until the number of connections being processed falls below maxConnections at which point the server will start accepting and processing new connections again. Note that once the limit has been reached, the operating system may still accept connections based on the acceptCount setting. The default value varies by connector type. For NIO and NIO2 the default is 10000. For APR/native, the default is 8192.<br>Note that for APR/native on Windows, the configured value will be reduced to the highest multiple of 1024 that is less than or equal to maxConnections. This is done for performance reasons.</li></ul></li></ol><h3 id="Tomcat-在-NIO-模式下的线程模型"><a href="#Tomcat-在-NIO-模式下的线程模型" class="headerlink" title="Tomcat 在 NIO 模式下的线程模型"></a>Tomcat 在 NIO 模式下的线程模型</h3><p>Tomcat 使用 Connector 完成整个 HTTP Request 的处理流程, 包括 accept socket → NIO Selector 处理 socket 读事件 → 把可读 Socket 分发给 Work 线程 → 从 socket 读取数据并解析为 Http 请求 → Http 请求交给 CoyoteAdaper 处理, CoyoteAdaper 通过 Mapper 找到对应的 Servlet.</p><p><img src="/images/javaee/tomcat-nio-connector-process.png" alt="Tomcat-NIO-Connector-Process"></p><p>在 NIO 实现的 Connector 中，处理请求的主要实体是 NIoEndpoint 对象。NIoEndpoint 中除了包含 Acceptor 和 Worker 外，还是用了 Poller，处理流程如下图所示:</p><p><img src="/images/javaee/tomcat-nioendpoint-poler-worker.png" alt="Tomcat-NioEndpoint-Poler-Worker"></p><ul><li>Acceptor accept 客户端请求, 这里虽然是基于 NIO 的 connector，但是在接收 socket 方面还是传统的 <code>serverSocket.accept()</code> 方式, Acceptor 获取到客户端请求的 socket, 封装进 tomcat 的实现类 org.apache.tomcat.util.net.NioChannel 对象中, 然后将 NioChannel 对象封装在一个 PollerEvent 对象中，并将 PollerEvent 对象压入 events queue</li><li>Poller 读取 events queue 取出 PollerEvent,  Poller 线程中维护了一个 Selector 对象, Poller 从 Event 中取出客户端请求的 socketChannel, 把这个 channel 的 READ 事件注册到 Selector 上.</li><li>Poller 通过 <code>Selector.select()</code> 遍历可读的 socketChannel, 从 Worker 线程池中拿到可用的 Worker 线程,将 socket 传递给 Worker 处理</li><li>Worker 线程将 socket 封装在 SocketProcessor 对象中。然后从 Http11ConnectionHandler 中取出 Http11NioProcessor 对象，从 Http11NioProcessor 中调用 CoyoteAdapter 的逻辑</li></ul><p>本节参考:<br><a href="https://my.oschina.net/weiweiblog/blog/1830173" target="_blank" rel="noopener">https://my.oschina.net/weiweiblog/blog/1830173</a><br><a href="https://www.jianshu.com/p/f91f99610b9e" target="_blank" rel="noopener">https://www.jianshu.com/p/f91f99610b9e</a></p><h2 id="APR-支持"><a href="#APR-支持" class="headerlink" title="APR 支持"></a>APR 支持</h2><p>APR(Apache Portable Runtime)可移植运行库，它是 Apache HTTP Server 2.x 的核心。APR 有很多用途，包括访问高级 IO 功能(例如 sendfile,<br>epoll 和 OpenSSL)，OS 级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT 管道和 UNIX sockets)。<br>这些功能可以使 Tomcat 作为一个通常的前台 WEB 服务器（类似 Nginx，只转发请求，不做业务），能更好地和其它本地 web 技术集成，总体上让 Java 更有效率作为一个高性能 web 服务器平台而不是简单作为<strong>后台业务容器</strong>。</p><p>可以简单地理解为: Tomcat 将以 JNI 的形式调用 APR 库中的 Native Method 处理文件读取或网络传输操作，提升 Tomcat 对静态文件等等的处理性能，APR 模式下的 Tomcat 更像是 Nginx 的角色。</p><p>安装步骤:</p><ul><li>下载 APR, 编译 <code>make &amp;&amp; make install</code></li><li>安装 Tomcat Native 到 Tomcat 的安装目录下</li><li>修改 conf/server.xml, 修改 <code>&lt;Connector&gt;</code> 的 protocol</li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>参考: <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html" target="_blank" rel="noopener">日志机制 - Tomcat 8 权威指南 - 极客学院Wiki</a></p><p>在 Apache Tomcat 上运行的 Web 应用可以使用以下日志：</p><ul><li>任何自选的日志框架，如 <code>log4j</code>；</li><li>使用 JDK 提供的日志 <code>java.util.logging</code>；</li><li>Java Servlets 规范所提供的日志 API，如 <code>javax.servlet.ServletContext.log(...)</code>；</li></ul><blockquote><p>当 tomcat 启动时会为每个 app 分配了一个 WebappClassLoader ，这样来避免多个 app 会加载相同 jar 包的问题，<br>不同 Web 应用程序下使用的 Servlet 日志（或者日志框架提供的日志，如 log4j 等）是相互独立的（这与 Tomcat 的 class loader 有关，参考 <a href="http://tomcat.apache.org/tomcat-6.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Class Loader HOW-TO</a> ）。<br>如果 Web 应用程序使用的是 java.util.logging 日志，那么它们并不相互独立，这是因为 java.util.logging 是由 JAVA 系统中的 Bootstrap ClassLoader 来加载的，因此它在各 Web 应用程序之间是共享的。</p></blockquote><h2 id="JULI-vs-JUL"><a href="#JULI-vs-JUL" class="headerlink" title="JULI vs JUL"></a>JULI vs JUL</h2><p>JUL API（<code>java.util.logging</code>，日志实现，非日志门面）的默认实现功能有限，因此 tomcat 的默认配置中，新增了另一种日志实现 JULI API（<code>org.apache.juli</code>），</p><blockquote><p>可以在 Tomcat 的 logging.properties 里看到定义了两种日志:<br>java.util.logging 的 <code>java.util.logging.ConsoleHandler</code> ;<br>JULI 的 <code>org.apache.juli.FileHandler</code> ;</p></blockquote><p><strong>JULI</strong> 同样支持标准 JDK java.util.logging 的配置机制（都默认使用 logging.properties 作为配置文件），不同的是 JULI 的每一个类加载属性文件都可以被设置，并可以在其中定义处理器，这样就给了开发者更大的自由度。<br>JULI 的日志配置分为全局配置和 WebApp 项目配置。<br>全局配置位于 tomcat 的配置目录 <code>${catalina.base}/conf/logging.properties</code> 文件,<br>如果该文件未配置或不可读，那么 tomcat 将会使用 JRE 中的默认日志配置，可以在 <code>${java.home}/lib/logging.properties</code> 查看配置文件的内容；<br>项目配置则是针对不同的项目，配置文件位于 <code>WEB-INFO/classes/logging.properties</code>.</p><p>JUL 和 JULI 使用相同的日志级别：SEVERE (最高级别) &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST (所有内容,最低级别)</p><p>JULI 所使用的配置与 java.util.logging 所支持的配置基本相同，只不过使用了一些扩展，以便更灵活地配置 logger 和 handler。主要的差别在于：</p><ul><li>JULI 的 handler 名称前可以加上前缀，所以同一类可以实例化出多个 handler。前缀是一个以数字开头的字符串，并以 . 结尾。比如 22foobar. 就是个有效的前缀。</li><li>JULI 的 handler 支持额外的属性, 比如 <code>bufferSize</code></li></ul><h2 id="Tomcat-日志配置解析"><a href="#Tomcat-日志配置解析" class="headerlink" title="Tomcat 日志配置解析"></a>Tomcat 日志配置解析</h2><p>以下是一个 <code>$CATALINA_BASE/conf</code> 中的默认 logging.properties 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span># 声明所有的handlers</span><br><span class="line">handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># RootLogger使用的handlers</span><br><span class="line">.handlers = 1catalina.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 定义了4个 org.apache.juli.FileHandler : 1catalina, 2localhost, 3manager, 4host-manager</span><br><span class="line">1catalina.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">1catalina.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">1catalina.org.apache.juli.FileHandler.prefix = catalina.</span><br><span class="line">1catalina.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">2localhost.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">2localhost.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">2localhost.org.apache.juli.FileHandler.prefix = localhost.</span><br><span class="line">2localhost.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">3manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">3manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">3manager.org.apache.juli.FileHandler.prefix = manager.</span><br><span class="line">3manager.org.apache.juli.FileHandler.bufferSize = 16384</span><br><span class="line">3manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line">4host-manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.prefix = host-manager.</span><br><span class="line">4host-manager.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 定义 ava.util.logging.ConsoleHandler :</span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br><span class="line">java.util.logging.ConsoleHandler.encoding = UTF-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 定义handlers, 使用上面定义的 FileHandler</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers = 2localhost.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers = 3manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers = 4host-manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> For example, set the org.apache.catalina.util.LifecycleBase logger to log</span><br><span class="line"><span class="meta">#</span> each component that extends LifecycleBase changing state:</span><br><span class="line"><span class="meta">#</span>org.apache.catalina.util.LifecycleBase.level = FINE</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> To see debug messages in TldLocationsCache, uncomment the following line:</span><br><span class="line"><span class="meta">#</span>org.apache.jasper.compiler.TldLocationsCache.level = FINE</span><br></pre></td></tr></table></figure><ul><li><code>java.util.logging.ConsoleHandler</code>:<br>When running Tomcat on unixes, the console output is usually redirected to the file named catalina.out.<br>The name is configurable using an environment variable. (See the startup scripts).<br>Whatever is written to System.err/out will be caught into that file. That may include:<ul><li>Uncaught exceptions printed by java.lang.ThreadGroup.uncaughtException(..)</li><li>Thread dumps, if you requested them via a system signal</li></ul></li></ul><blockquote><p>java.util.logging.ConsoleHandler 是 java 自带的日志处理系统（JUL）的控制台日志 Handler,<br>Tomcat 通过 <code>System.err.println()</code> / <code>System.out.println()</code> 打出的日志会通过 java.util.logging.ConsoleHandler 写入 Tomcat 进程的 stdout/stderr,<br>并最终输出到文件”catalina.out”中, 这个文件名是在 Tomcat 启动脚本里定义的:</p></blockquote><ul><li><code>org.apache.juli.FileHandler</code>:<br>org.apache.juli.FileHandler supports buffering of the logs.<br>The buffering is not enabled by default. To configure it, use the bufferSize property of a handler.<br>The value of 0 uses system default buffering (typically an 8K buffer will be used).<br>A value of &lt; 0 forces a writer flush upon each log write.<br>A value &gt; 0 uses a BufferedOutputStream with the defined value but note that the system default buffering will also be applied.</li></ul><blockquote><p>org.apache.支持日志缓存。日志缓存默认是没有启用的。使用 handler 的 bufferSize 属性可以配置它：<br>属性值为 0 时，代表使用系统默认的缓存（通常使用 8k 缓存）；<br>属性值小于 0 时，将在每个日志写入上强制使用 writer flush（将缓存区中的数据强制写出到系统输出）功能；<br>属性值大于 0 时，则使用带有定义值的 BufferedOutputStream 类——但要注意的是，这也将应用于系统默认的缓存。</p></blockquote><h2 id="WebApp-的日志配置解析"><a href="#WebApp-的日志配置解析" class="headerlink" title="WebApp 的日志配置解析"></a>WebApp 的日志配置解析</h2><p>下例是一个用于 servlet-examples 应用的 WEB-INF/classes 中的 logging.properties 文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>###########################################################</span><br><span class="line"><span class="meta">#</span> Handler specific properties.</span><br><span class="line"><span class="meta">#</span> Describes specific configuration info for Handlers.</span><br><span class="line"><span class="meta">#</span>###########################################################</span><br><span class="line"></span><br><span class="line">org.apache.juli.FileHandler.level = FINE</span><br><span class="line">org.apache.juli.FileHandler.directory =  $&#123;catalina.base&#125;/logs</span><br><span class="line">org.apache.juli.FileHandler.prefix = $&#123;classloader.webappName&#125;.</span><br></pre></td></tr></table></figure><blockquote><p>Tomcat 启动时报错 “SEVERE: Error listenerStart” 或者 “SEVERE: Error filterStart” 等, 但没有具体的错误日志:<br>这种一般是因为 Tomcat WebAppClassLoader 加载的<code>org.springframework</code>类的日志没有关联一个 Handler,<br>可以修改 webapps/xxx/WEB-INF/classes/logging.properties, Tomcat 就会在打印 org.springframework 类的详细的报错信息了.<br>注意, 老的应用可能还在使用 System.out 或 System.err，这种情况下还需要在 web 应用的 classes/logging.properties 里增加 java.util.logging.ConsoleHandler:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlers = org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line">## JULI.FileHandler 的设置</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">## JUL.ConsoleHandler 的设置</span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br></pre></td></tr></table></figure><blockquote><p>对于还在使用 System.out 或 System.err 的应用:<br>可以通过在 Context 元素上设置 swallowOutput 属性来调整。如该属性设为 true，那么在请求阶段对 System.out/err 的调用就会被拦截，它们的输出也会通过 <code>javax.servlet.ServletContext.log(...)</code> 调用反馈给日志系统。</p></blockquote><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><ul><li>catalina.2017-08-29.log         //Cataline 引擎的日志文件</li><li>localhost.2017-08-29.log        //Tomcat 下内部代码抛出的日志 jsp 页面内部错误的异常</li><li>manager.2017-08-29.log          //Tomcat 下默认 manager 应用日志</li><li>host-manager.2017-08-29.log     //Tomcat 下默认 manager 应用日志</li><li>localhost_access_log.2017-08-29.txt  //访问日志记录</li><li>catalina.out                         //控制台输出的日志,Linux 下默认重定向到 catalina.out</li></ul><p>查看 catalina.sh, 最终启动 tomcat 执行的命令行是 <code>java ${JAVA_OPTS} org.apache.catalina.startup.Bootstrap start</code></p><h2 id="生产环境中的日志"><a href="#生产环境中的日志" class="headerlink" title="生产环境中的日志"></a>生产环境中的日志</h2><p>可能需要注意以下方面：</p><ul><li>将 ConsoleHandler 从配置中移除。默认（ .handlers 设置）日志会使用 FileHandler 和 ConsoleHandler。<br>后者的输出经常会被捕获到一个文件中，比如 catalina.out。从而导致同一消息可能生成了两个副本。</li><li>对于不使用的应用(比如 host-manager)，可以考虑将 FileHandlers 移除。</li><li>handler 默认使用系统缺省编码来写入日志文件，通过 encoding 属性可以修改设置，详情查看相关的 javadoc 文档。</li><li>增加 Access 访问日志。</li></ul><h2 id="使用-log4j"><a href="#使用-log4j" class="headerlink" title="使用 log4j"></a>使用 log4j</h2><p>参考 <a href="http://wiki.jikexueyuan.com/project/tomcat/logging.html#usingLog4j" target="_blank" rel="noopener">使用 Log4j</a> @ref</p><ul><li>如果只是想在自己的 Web 应用上使用 log4j 时<ul><li>只需将 log4j.jar 和 log4j.properties 放到 Web 应用的 WEB-INF/lib 和 WEB-INF/classes 中即可</li></ul></li><li>如果想配置 Tomcat 以便利用 log4j 来进行自身日志记录时，下面的步骤都是必需的:<ul><li>创建一个包含下列配置的 log4j.properties 文件，将其保存到 $CATALINA_BASE/lib。<strong>Important!</strong></li><li>下载 log4j</li><li>下载或构建 tomcat-juli.jar 和 tomcat-juli-adapters.jar，以便作为 Tomcat 的额外组件使用。</li><li>将 log4j.jar 和 tomcat-juli-adapters.jar 从 extras 中放入 $CATALINA_HOME/lib 中。</li><li>用 extras 中的 tomcat-juli.jar 替换 $CATALINA_HOME/bin/tomcat-juli.jar。</li><li>删除 $CATALINA_BASE/conf/logging.properties，以防止 java.util.logging 生成零长度的日志文件。</li></ul></li></ul><h1 id="高级-IO"><a href="#高级-IO" class="headerlink" title="高级 IO"></a>高级 IO</h1><h2 id="推送-Comet-支持"><a href="#推送-Comet-支持" class="headerlink" title="推送: Comet 支持"></a>推送: Comet 支持</h2><p>施工中</p><h2 id="发送大型静态文件-sendfile"><a href="#发送大型静态文件-sendfile" class="headerlink" title="发送大型静态文件: sendfile"></a>发送大型静态文件: sendfile</h2><p>施工中</p><h1 id="How-to-deploy-war"><a href="#How-to-deploy-war" class="headerlink" title="How to deploy war"></a>How to deploy war</h1><p>有 3 中方式部署 war 包:</p><ol><li>在 server.xml 的<code>&lt;Host&gt;</code>标签中声明<code>&lt;Context&gt;</code>标签</li><li>在 server.xml 的<code>&lt;Host&gt;</code>标签中开启 autoDeploy, 将 war 包放入 webapps 中会自动部署</li><li>context.xml 配置方式</li></ol><h2 id="Using-the-UI-manager"><a href="#Using-the-UI-manager" class="headerlink" title="Using the UI manager"></a>Using the UI manager</h2><p>Tomcat 提供了一个网页版的 Manager App, 默认位置在 webapps/manager, 也是一个 web 项目, 使用方式参考: <a href="http://tomcat.apache.org/tomcat-6.0-doc/manager-howto.html#Configuring_Manager_Application_Access" target="_blank" rel="noopener">Apache Tomcat 6.0 (6.0.53) - Manager App HOW-TO</a> @ref</p><p>Go to <code>[&lt;protocol&gt;://]localhost:&lt;port&gt;/manager/html/</code> (usually <code>localhost:8080/manager/html/</code>),<br>If you get:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">403 Access Denied</span><br></pre></td></tr></table></figure></p><p>go to <code>%CATALINA_HOME%\conf\tomcat-users.xml</code> and check that you have enabled a line like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;tomcat,role1,manager-gui&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="Using-maven"><a href="#Using-maven" class="headerlink" title="Using maven"></a>Using maven</h2><p>待补充…</p><h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p>为什么 Tomcat 的 Web App ClassLoader 没有遵循 「双亲委派」？[[../12.Java/Advanced-Java.04.ClassLoader#Tomcat]]</p><hr><p>翻译自: <a href="https://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Apache Tomcat 7 (7.0.93) - Class Loader HOW-TO</a></p><p>与很多服务器应用一样，Tomcat 也安装了各种类加载器。借助类加载器，容器的不同部分以及运行在容器里的 Web Apps 就可以访问不同的仓库（保存着可使用的类和资源）。<br>// 这里英文原文是”different repositories of available classes and resources.” 不知道该怎么翻译这里的”repositories” ?</p><blockquote><p>在 Java 环境中，类加载器的布局结构是一种父子树的形式。通常，类加载器被请求加载一个特定的类或资源时，它会先把这一请求委托给它的父类加载器，只有（一个或多个）父类加载器无法找到请求的类或资源时，它才开始查看自身的仓库。</p></blockquote><p>注意，Web 应用的类加载器模式跟这个稍有不同，下文将详细介绍，但基本原理是一样。</p><p>当 Tomcat 启动后，它就会创建一组类加载器，这些类加载器被布局成如下图所示这种父子关系，父类加载器在子类加载器之上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Bootstrap</span><br><span class="line">        |</span><br><span class="line">     System</span><br><span class="line">        |</span><br><span class="line">     Common</span><br><span class="line">     /     \</span><br><span class="line">WebApp1   WebApp2 ..</span><br></pre></td></tr></table></figure><p>如上图所示，Tomcat 在初始化时会创建如下这些类加载器：</p><ul><li><p><strong>Bootstrap</strong> 这种类加载器包含 JVM 所提供的基本的运行时类，以及来自系统扩展目录（<code>$JAVA_HOME/jre/lib/ext</code>）里 JAR 文件中的类。<br>注意：在有些 JVM 的实现中，它的作用不仅仅是类加载器，或者它可能根本不可见（作为类加载器）。</p></li><li><p><strong>System</strong> 这种类加载器通常是根据 CLASSPATH 环境变量内容进行初始化的（也称为 App ClassLoader）。所有的这些类对于 Tomcat 内部类以及 Web 应用来说都是可见的。不过，标准的 Tomcat 启动脚本（<code>$CATALINA_HOME/bin/catalina.sh</code> 或 <code>%CATALINA_HOME%\bin\catalina.bat</code>）完全忽略了 CLASSPATH 环境变量自身的内容，相反从下列仓库来构建系统类加载器：</p><ul><li><code>$CATALINA_HOME/bin/bootstrap.jar</code> 包含用来初始化 Tomcat 服务器的 <code>main()</code> 方法，以及它所依赖的类加载器实现类。</li><li><code>$CATALINA_BASE/bin/tomcat-juli.jar</code> 或 <code>$CATALINA_HOME/bin/tomcat-juli.jar</code> 日志实现类。其中包括了对 <code>java.util.logging</code> API 的功能增强类（Tomcat JULI），以及对 Tomcat 内部使用的 Apache Commons 日志库的包重命名副本。详情参看 Tomcat 日志文档。<br>如果 <code>*$CATALINA_BASE/bin*</code> 中存在 <code>tomcat-juli.jar</code>，就不会使用 <em>$CATALINA_HOME/bin</em> 中的那一个。它有助于日志的特定配置。</li><li><code>$CATALINA_HOME/bin/commons-daemon.jar</code> Apache Commons Daemon 项目的类。该 JAR 文件并不存在于由 catalina.bat 或 catalina.sh 脚本所创建的 CLASSPATH 中，而是引用自 bootstrap.jar 的清单文件。</li></ul></li><li><p><strong>Common</strong> 这种类加载器包含更多的额外类，它们对于 Tomcat 内部类以及所有 Web 应用都是可见的。<br>通常，应用类不会放在这里。该类加载器所搜索的位置定义在 <code>$CATALINA_BASE/conf/catalina.properties</code> 的 common.loader 属性中。默认的设置会搜索下列位置（按照列表中的上下顺序）。</p><ul><li><code>$CATALINA_BASE/lib</code> 中的解包的类和资源。</li><li><code>$CATALINA_BASE/lib</code> 中的 JAR 文件。</li><li><code>$CATALINA_HOME/lib</code> 中的解包类和资源。</li><li><code>$CATALINA_HOME/lib</code> 中的 JAR 文件。</li></ul></li></ul><p>默认，它包含以下这些内容：</p><ul><li><em>annotations-api.jar</em> JavaEE 注释类。</li><li><em>catalina.jar</em> Tomcat 的 Catalina servlet 容器部分的实现。</li><li><em>jsp-api.jar</em> JSP 2.3 API</li><li><em>servlet-api.jar</em> Servlet 3.1 API</li><li><em>tomcat-api.jar</em> Tomcat 定义的一些接口</li><li><em>tomcat-dbcp.jar</em> 数据库连接池实现，基于 Apache Commons Pool 的包重命名副本和 Apache Commons DBCP。</li><li><em>tomcat-jdbc.jar</em> 一个数据库连接池替代实现，又被称作 Tomcat JDBC 池。详情参看 JDBC 连接池文档。</li><li>…</li></ul><ul><li><strong>WebappX</strong> 为每个部署在单个 Tomcat 实例中的 Web 应用创建的类加载器。你的 Web 应用的 /WEB-INF/classes 目录中所有的解包类及资源，以及 /WEB-INF/lib 目录下 JAR 文件中的所有类及资源，对于该应用而言都是可见的，但对于其他应用来说则不可见。</li></ul><p>如上所述，Web 应用类加载器背离了默认的 Java 委托模式（根据 Servlet 规范 2.4 版的 9.7.2 Web Application Classloader 一节中提供的建议）。<br>当某个请求想从 Web 应用的 WebappX 类加载器中加载类时，该类加载器会先查看自己的仓库，而不是预先进行委托处理。<br>JRE 基类的部分类不能被重写。对于一些类（比如 J2SE 1.4+ 的 XML 解析器组件），可以使用 J2SE 1.4 支持的特性。<br>最后，类加载器会显式地忽略所有包含 Servlet API 类的 JAR 文件，所以不要在 Web 应用包含任何这样的 JAR 文件。Tomcat 其他的类加载器则遵循常用的委托模式。</p><p>因此，从 Web 应用的角度来看，加载类或资源时，要查看的仓库及其顺序如下：</p><ol><li>JVM 的 Bootstrap 类</li><li>Web 应用的 <code>/WEB-INF/classes</code> 类</li><li>Web 应用的 <code>/WEB-INF/lib/*.jar</code> 类，其中2和3 都是 <strong>WebApp Classloader</strong>加载的</li><li>System 类加载器的类（加载 <code>CLASSPATH</code> 下的类）</li><li>Common 类加载器的类（加载 <code>CATALINA_BASE</code> 和 <code>CATALINA_HOME</code> 的lib下的类)</li></ol><p>如果 Web 应用类加载器配置有 <code>&lt;Loader delegate=&quot;true&quot;/&gt;</code> ，则顺序变为：</p><ol><li>JVM 的 Bootstrap 类</li><li>System 类加载器的类（如上所述）</li><li>Common 类加载器的类（如上所述）</li><li>Web 应用的 /WEB-INF/classes 类</li><li>Web 应用的 /WEB-INF/lib/*.jar 类</li></ol><h1 id="源码导读-Tomcat-8-5"><a href="#源码导读-Tomcat-8-5" class="headerlink" title="源码导读 (Tomcat 8.5)"></a>源码导读 (Tomcat 8.5)</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ant clean</span><br><span class="line">ant</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp ./output/classes -Dcatalina.home=./output/build org.apache.catalina.startup.Bootstrap</span><br></pre></td></tr></table></figure><h2 id="启动过程源码调用时序"><a href="#启动过程源码调用时序" class="headerlink" title="启动过程源码调用时序"></a>启动过程源码调用时序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Bootstrap.main // 入口方法</span><br><span class="line">  Bootstrap.init()</span><br><span class="line">    initClassLoaders()  // 初始化 commonLoader, catalinaLoader, sharedLoader</span><br><span class="line">      commonLoader = createClassLoader(<span class="string">"common"</span>, null);</span><br><span class="line">        ClassLoaderFactory.createClassLoader(repositories, parent); // 该方法通过 AccessController.doPrivileged 创建了 URLClassLoader, 并返回</span><br><span class="line">    catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>)` // 创建 Catalina 对象</span><br><span class="line">  Bootstrap.load(args)</span><br><span class="line">    Catalina.load()</span><br><span class="line">      Digester digester = createStartDigester() // 为 digester 添加 Rule</span><br><span class="line">      Digester.parse(inputSource) // 解析 server.xml !!</span><br><span class="line">        Digester.startElement()</span><br><span class="line">          Rule.begin()</span><br><span class="line">            ObjectCreateRule.begin() // 这里通过反射调用了 Server &amp; Connector &amp; Context 等类的构造方法</span><br><span class="line">              org.apache.catalina.core.StandardServer.StandardServer() // Server 构造</span><br><span class="line">              org.apache.catalina.core.StandardService.StandardService() // Service 构造</span><br><span class="line">            ConnectorCreateRule.begin</span><br><span class="line">              org.apache.catalina.connector.Connector.Connector()</span><br><span class="line">                // Connector 构造, 根据配置中的 <span class="string">"protocol"</span> 设置创建不同的创建 ProtocolHandler:</span><br><span class="line">                Http11NioProtocol() // 默认的 ProtocolHandler</span><br><span class="line">                  AbstractHttp11Protocol(new NioEndpoint())</span><br><span class="line">                    NioEndpoint()</span><br><span class="line">                        AbstractEndpoint()  // 创建 worker 线程池</span><br><span class="line">  Bootstrap.start()</span><br><span class="line">    Catalina.start()</span><br><span class="line">      StandardServer.start() =&gt; LifecycleBase.start()</span><br><span class="line">        StandardServer.startInternal()</span><br><span class="line">          StandardService.start() =&gt; LifecycleBase.start()</span><br><span class="line">            StandardService.startInternal()</span><br><span class="line">              Engine.start() =&gt; LifecycleBase.start()   // 启动 Engine</span><br><span class="line">                StandardEngine.startInternal()</span><br><span class="line">                  ContainerBase.startInternal()</span><br><span class="line">                    StartChild.call()  // 多线程启动, 线程数=Host 数量</span><br><span class="line">                      StandardHost.start() =&gt; LifecycleBase.start()</span><br><span class="line">                        StandardHost.startInternal()</span><br><span class="line">                          ContainerBase.startInternal() =&gt; LifecycleBase.setStateInternal()</span><br><span class="line">                            ContainerBase.setState(LifecycleState.STARTING)</span><br><span class="line">                              LifecycleBase.fireLifecycleEvent(lifecycleEvent, data)</span><br><span class="line">                                  HostConfig.start()</span><br><span class="line">                                    HostConfig.deployApps()</span><br><span class="line">                                      HostConfig.deployWARs() // 解析 web.xml !!</span><br><span class="line">              MapperListener.start() =&gt; LifecycleBase.start()  // 启动 MapperListener</span><br><span class="line">                MapperListener.startInternal()</span><br><span class="line">              Connector.start() =&gt; LifecycleBase.start()     // 启动(多个) Connector</span><br><span class="line">                Connector.startInternal()</span><br><span class="line">                  Http11NioProtocol.start() =&gt; AbstractProtocol.start()</span><br><span class="line">                    AbstractEndpoint.start() =&gt; NioEndpoint.startInternal()</span><br><span class="line">                      // 创建三个 cache: processorCache, eventCache, nioChannels</span><br><span class="line">                      startAcceptorThreads()</span><br><span class="line">                    new AsyncTimeout(); // Start <span class="keyword">async</span> timeout thread</span><br><span class="line">      StandardServer.<span class="keyword">await</span>() // 创建一个在 <span class="number">8005</span> 监听的 ServerSocket, 用于监听关闭</span><br><span class="line">        ServerSocket.accept // 阻塞在这里</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote><p>参考 <a href="https://blog.csdn.net/tjiyu/article/details/54590259" target="_blank" rel="noopener">Tomcat实现：源码分析Tomcat实现细节 </a> @Archived</p><pre><code>* Connect.start()—创建并发线程模型: Work 线程, Poller 线程, Acceptor 线程, AsyncTimeout 线程* 请求处理: Acceptor 线程, Poller 线程, Selector</code></pre></blockquote><h3 id="如何解析-server-xml"><a href="#如何解析-server-xml" class="headerlink" title="如何解析 server.xml"></a>如何解析 server.xml</h3><ul><li>在 Catalina.load() 创建 digester: <code>Digester digester = createStartDigester()</code></li><li><code>createStartDigester</code>方法创建了 digester 对象, 并给 digester 对象添加多种 Rule, 每种 Rule 都对应 server.xml 里的一个节点类型, 比如<code>&lt;Server&gt;</code>, <code>&lt;Connector&gt;</code>;</li><li>digester 对 server.xml 设置的标签动作有 5 种调用：<ul><li>addObjectCreate：遇到起始标签的元素，初始化一个实例对象入栈</li><li>addSetProperties：遇到某个属性名，使用 setter 来赋值</li><li>addSetNext：遇到结束标签的元素，调用相应的方法</li><li>addRule：调用 rule 的 begin 、body、end、finish 方法来解析 xml，入栈和出栈给对象赋值</li><li>addRuleSet：调用 addRuleInstances 来解析 xml 标签</li></ul></li><li>从这些规则和 xml 中可以看到，Calatina 的 Server 对象是 StandardServer。 StandardService 包含了多个 Connector（xml 中有 2 个 connector）和一个 StandardEngine Container。 StandardEngine 包含了一个 Host Container</li></ul><h3 id="初始化-Connector"><a href="#初始化-Connector" class="headerlink" title="初始化 Connector"></a>初始化 Connector</h3><p>根据配置文件 protocol = “HTTP/1.1”,”AJP/1.3” 创建对应 protocol, 默认是 Http11NioProtocol,<br>再由 Http11NioProtocol 创建 NioEndpoint:</p><p>代码流程</p><ul><li>调用<code>Connector(String protocol)</code>, 构造函数<code>Connector</code>中默认创建<code>org.apache.coyote.http11.Http11NioProtocol</code></li><li>以<code>Http11NioProtocol</code>为例, <code>Http11NioProtocol.init()</code>最终调用到<code>NioEndpoint.bind()</code> =&gt; <code>NioEndpoint.initServerSocket()</code>  =&gt; <code>serverSock.socket().bind(addr,getAcceptCount())</code> 完成了对端口的绑定</li><li>bind()的最后调用了<code>NioSelectorPool.open()</code>, 这是一个存放 Selector 的池子,</li></ul><h3 id="启动-Connector"><a href="#启动-Connector" class="headerlink" title="启动 Connector"></a>启动 Connector</h3><p>Connector 主要功能实现都是在 <strong>NioEndpoint</strong>, NioEndpoint 包括 x 个 Acceptor 线程, x 个 Poller 线程;<br>Acceptor 线程(默认一个)用于 accept 客户端请求, 并把客户端请求 socket 封装进 event, 放入 events queue;<br>Poller 线程池用于消费 events queue, 每个 Poller 都有自己的 Selector 对象, 不断取出 event, 并从中解析出 sockt, 并把 socket 的 READ 事件注册到自己的 Selector.</p><p>代码调用流程:</p><ul><li>Connector 的启动会调用<code>start</code>方法, =&gt; <code>Connector.startInternal</code>方法 =&gt; <code>Http11NioProtocol.start()</code> =&gt; <code>AbstractProtocol.start()</code> =&gt; <code>NioEndpoint.start()</code> =&gt; <code>NioEndpoint.startInternal()</code></li><li>在<code>NioEndpoint.startInternal()</code>中,<ul><li>如果 Worker 线程池是空, 则自己创建: 调用了父类<code>AbstractEndpoint #createExecutor ()</code>, 创建 work 线程池, 名称前缀 “-exec-“;</li><li>创建<code>NioEndpoint$Poller[]</code>数组, Poller 是 Runnable 的实现, 然后所有的 Poller 线程都 start 起来, 线程名前缀是 “-ClientPoller-“, 数组的大小也就是 Poller 的数量是<code>Math.min(2,Runtime.getRuntime().availableProcessors())</code>, 可见 Poller 数量是 min(2, cpu 的 process 数量)</li><li>调用<code>startAcceptorThreads()</code>,  创建 <code>Acceptor</code>线程, 默认一个(线程数是 server.xml 里的<code>acceptCount</code>), , 线程名前缀是”-Acceptor-“</li></ul></li></ul><h3 id="accept-请求"><a href="#accept-请求" class="headerlink" title="accept 请求"></a>accept 请求</h3><p>Acceptor 线程 accept , 并把客户端请求 socket 封装进 event, 放入 events queue, 调用流程:</p><ul><li><p><code>Acceptor.run()</code>:</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (endpoint.isRunning()) &#123;</span><br><span class="line">    socket = endpoint.serverSocketAccept();</span><br><span class="line">    endpoint.setSocketOptions(socket) // 调用了 NioEndpoint.setSocketOptions()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再看 <code>NioEndpoint.setSocketOptions()</code>里做了什么:  把客户端请求的 socket 封装进 NioChannel,<br>调用 Poller.register(NioChannel): 把 NioChannel 封装进 PollerEvent,  每个 Poller 都有一个 PollerEvent 队列(events queue), 把 PollerEvent 放入这个队列 // Poller 有多个, 这里会轮询的方式选择出其中一个, <code>AtomicInteger.incrementAndGet()) % pollers.length</code></p></li></ul><h3 id="处理一次-Req-请求"><a href="#处理一次-Req-请求" class="headerlink" title="处理一次 Req 请求"></a>处理一次 Req 请求</h3><p>Poller 线程用于消费 events queue, 代码调用流程:</p><ul><li><code>Poller.run()</code> while 循环从 event queue 取出 PollerEvent, 然后调用 <code>PollerEvent.run()</code><ul><li><code>PollerEvent.run()</code> // 主要是在 Poller 自己的 Selector 上注册 READ 事件</li><li><code>Poller.processKey(SelectionKey , NioSocketWrapper)</code> 调用-&gt; <code>Poller.processSocket</code> // 处理 OPEN_READ/OPEN_WRITE 等事件<ul><li>创建一个 SocketProcessorBase 的实例, 把 socket 和 Event 封装进去, SocketProcessorBase 继承自 Runnable</li><li>executor.execute(SocketProcessorBase) // 用 Worker 线程池运行这个 SocketProcessorBase<ul><li><code>SocketProcessorBase.run()</code> -&gt; <code>SocketProcessor.doRun()</code></li></ul></li></ul></li></ul></li></ul><p>再看 SocketProcessor 调用流程:</p><ul><li><code>SocketProcessor.doRun()</code> :  // 调用 SocketChannel.keyFor()<ul><li><code>AbstractProtocol$ConnectionHandler.process()</code><ul><li><code>NioEndpoint$SocketProcessor.doRun()</code><ul><li><code>Http11Processor.service()</code> : 处理 Socket IO 流, 解析为 Http Request<ul><li><code>ApplicationFilterChain.internalDoFilter()</code>: 调用<code>Filter.doFilter()</code> ,以及<code>Servlet.service()</code>;</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="如何-SHUTDOWN"><a href="#如何-SHUTDOWN" class="headerlink" title="如何 SHUTDOWN"></a>如何 SHUTDOWN</h3><ul><li>StandardServer.await() 创建一个在 8005 监听的 ServerSocket, 是用来监听关闭 Tomcat 命令的, 当执行 shutdown.sh 关闭 tomcat 时就是连接 8005 端口执行“SHUTDOWN”命令;</li><li>关闭请求发给 Tomcat, 由 StandardServer.await 处理, await 方法验证关闭请求是否有效, 如果有效则退出 await 方法, 进入 Catalina.stop(), 调用<br>StandardServer.stop, StandardServer.destroy,  然后关闭 Connector, Service</li></ul><p>从日志可以看到:</p><ul><li>WebappLoader.stopInternal -&gt; WebappClassLoaderBase.stop -&gt; WebappClassLoaderBase.clearReferences<ul><li>WebappClassLoaderBase.clearReferencesJdbc</li><li>WebappClassLoaderBase.clearReferencesThreads</li></ul></li><li>AbstractProtocol.pause Pausing ProtocolHandler [“http-nio-8080”]</li><li>AbstractProtocol.pause Pausing ProtocolHandler [“ajp-nio-8009”]</li><li>StandardService.stopInternal</li></ul><h2 id="Useful-Java-API-usage"><a href="#Useful-Java-API-usage" class="headerlink" title="Useful Java API usage"></a>Useful Java API usage</h2><ul><li>AsyncChannelWrapperSecure:<ul><li>Executors.newFixedThreadPool , shutdownNow</li><li>AsynchronousSocketChannel</li><li>ByteBuffer, flip, hasRemaining,</li><li>AtomicBoolean</li></ul></li><li>WsWebSocketContainer<ul><li>AsynchronousSocketChannel</li></ul></li></ul><h3 id="并发的处理代码"><a href="#并发的处理代码" class="headerlink" title="并发的处理代码"></a>并发的处理代码</h3><ul><li><p>用线程池启动容器内组件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // Start our child containers, if any</span><br><span class="line">Container children[] = findChildren();</span><br><span class="line">List&lt;Future&lt;Void&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">    results.add(startStopExecutor.submit(new StartChild(children[i])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean fail = false;</span><br><span class="line">for (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        result.get();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 Callable 封装带返回值的任务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class StartChild implements Callable&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Container child;</span><br><span class="line"></span><br><span class="line">    public StartChild(Container child) &#123;</span><br><span class="line">        this.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Void call() throws LifecycleException &#123;</span><br><span class="line">        child.start();</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://toutiao.io/u/176492?page=4" target="_blank" rel="noopener">Tomcat那些事儿的热门分享 - 开发者头条</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Tomcat-logo.svg/300px-Tomcat-logo.svg.png&quot; alt=&quot;Tomcat&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;为什么-Java-Web-开发需要-Tomcat&quot;&gt;&lt;a href=&quot;#为什么-Java-Web-开发需要-Tomcat&quot; class=&quot;headerlink&quot; title=&quot;为什么 Java Web 开发需要 Tomcat&quot;&gt;&lt;/a&gt;为什么 Java Web 开发需要 Tomcat&lt;/h1&gt;&lt;p&gt;JavaEE、Servlet、Java Web 的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java EE&lt;/strong&gt;（Java Platform Enterprise Edition，2018 年 3 月更名为&lt;strong&gt;Jakarta EE&lt;/strong&gt;）是一些列（Java 企业级开发）标准集合；&lt;/li&gt;
&lt;li&gt;Servlet 是 Java EE 众多标准下的一个 （link &lt;a href=&quot;/13.JavaEE-Framework/JavaEE.Servlet/&quot; title=&quot;JavaEE.Servlet&quot;&gt;JavaEE.Servlet&lt;/a&gt;），主要定义了进行 Java Web 开发的规范（Request、Response 对象、servlet 生命周期）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个典型的 Servlet 工作模式：&lt;/p&gt;</summary>
    
    
    
    <category term="13.JavaEE" scheme="https://beefyheisenberg.github.io/categories/13-JavaEE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Tomcat" scheme="https://beefyheisenberg.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringMVC/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringMVC/</id>
    <published>2023-05-24T10:10:50.215Z</published>
    <updated>2023-05-24T10:10:50.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Framework-框架图"><a href="#Spring-Framework-框架图" class="headerlink" title="Spring Framework 框架图"></a>Spring Framework 框架图</h1><p>下图是 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RC2/spring-framework-reference/overview.html" target="_blank" rel="noopener">Spring 官网</a>的一个架构图，介绍下其组成部分：</p><p><img src="/images/Spring-Framework-Runtime.png" alt="../_images/Spring-Framework-Runtime.png"></p><h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><p>由spring-core、spring-beans、spring-context、spring-context-support和spring-expression模块组成：</p><ul><li><p>spring-core 和 spring-beans 提供框架的基础部分，包括 IOC 功能，BeanFactory 是一个复杂的工厂模式的实现，将配置和特定的依赖从实际程序逻辑中解耦。</p></li><li><p>context 模块建立在 core 和 beans 模块的基础上，增加了对国际化的支持、事件广播、资源加载和创建上下文，ApplicationContext 是 context 模块的重点。</p></li><li><p>spring-context-support 提供对常见第三个库的支持，集成到 spring 上下文中，比如缓存(ehcache,guava)、通信(javamail)、调度(commonj,quartz)、模板引擎等(freemarker,velocity)。</p></li><li><p>spring-expression 模块提供了一个强大的表达式语言用来在运行时查询和操作对象图，这种语言支持对属性值、属性参数、方法调用、数组内容存储、集合和索引、逻辑和算数操作及命名变量，并且通过名称从 spring 的控制反转容器中取回对象。</p></li></ul><h2 id="AOP-和服务器工具"><a href="#AOP-和服务器工具" class="headerlink" title="AOP 和服务器工具"></a>AOP 和服务器工具</h2><ul><li><p>spring-aop 模块提供面向切面编程实现</p></li><li><p>单独的 spring-aspects 模块提供了 aspectj 的集成和适用。</p></li><li><p>spring-instrument 提供一些类级的工具支持和 ClassLoader 级的实现，用于服务器。spring-instrument-tomcat 针对 tomcat 的 instrument 实现。</p></li></ul><h2 id="消息组件"><a href="#消息组件" class="headerlink" title="消息组件"></a>消息组件</h2><p>包含了spring-messaging模块，从spring集成项目中抽象出来，比如Messge、MessageChannel、MessageHandler及其他用来提供基于消息的基础服务。</p><h2 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h2><p>数据访问和集成层由 JDBC、ORM、OXM、JMS 和 Transaction 模块组成。</p><ul><li><p>spring-jdbc 模块提供了不需要编写冗长的 JDBC 代码和解析数据库厂商特有的错误代码的 JDBC 抽象出。</p></li><li><p>spring-orm 模块提供了领先的对象关系映射 API 集成层，如 JPA、Hibernate 等。</p></li><li><p>spring-oxm 模块提供抽象层用于支持 Object/XML maping 的实现，如 JAXB、XStream 等。</p></li><li><p>spring-jms 模块包含生产和消费消息的功能，从 Spring4.1开始提供集成 spring-messaging 模块。</p></li><li><p>spring-tx 模块提供可编程和声明式事务管理。</p></li></ul><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>Web层包含spring-web、spirng-webmvc、spring-websocket和spring-webmvc-portlet模块组成。</p><ul><li><p>spring-web 模块提供了基本的面向 web 开发的集成功能，例如多文件上传、使用 servert listeners 和 web 开发应用程序上下文初始化 IOC 容器。也包含 HTTP 客户端以及 spring 远程访问的支持的 web 相关部分。</p></li><li><p>spring-webmvc 包含 spring 的 model-view-controller 和 REST web services 实现的 Web 应用程序。</p></li><li><p>spring-webmvc-portlet 模块提供了 MVC 模式的 portlet 实现，protlet 与 Servlet 的最大区别是请求的处理分为 action 和 render 阶段，在一个请求中，action 阶段只执行一次，但 render 阶段可能由于用户的浏览器操作而被执行多次。</p></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>spring-test模块支持通过组合Junit或TestNG来进行单元测试和集成测试，提供了连续的加载ApplicationContext并且缓存这些上下文。</p><h1 id="使用Spring-Context"><a href="#使用Spring-Context" class="headerlink" title="使用Spring Context"></a>使用Spring Context</h1><p>使用ClassPathXmlApplicationContext:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"META-INF/spring/spring-main.xml"</span>);</span><br><span class="line">A a = context.getBean(A.class);</span><br></pre></td></tr></table></figure><p>直接使用 DefaultListableBeanFactory:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"spring-core.xml"</span>);</span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">reader.loadBeanDefinitions(resource);</span><br><span class="line">MyBean myBean = (MyBean) beanFactory.getBean(<span class="string">"myBean"</span>);</span><br><span class="line">myBean.sayHello();</span><br></pre></td></tr></table></figure><p>区分<strong>ApplicationContext</strong> and  <strong>ServletContext</strong> <a href="https://stackoverflow.com/questions/31931848/applicationcontext-and-servletcontext" target="_blank" rel="noopener">java - ApplicationContext and ServletContext - Stack Overflow</a></p><h1 id="使用Bean"><a href="#使用Bean" class="headerlink" title="使用Bean"></a>使用Bean</h1><p>Spring 基于 Ioc 和 DI 的方式 创建 &amp; 装配 Bean :</p><ul><li><p>控制反转(Inversion of Control): 使用者不自己创建依赖的对象, 而交由第三方(IoC容器)创建. 从IOC容器中获取（和自动注入）.而不必由用户调用 <code>new</code> 来创建 Bean 对象, 通过 IoC 则可以减少它们之间的耦合度.</p></li><li><p>依赖注入(Dependency Injection): 将依赖对象传递给使用者. 在 Spring 中, bean 的装配是依赖注入的具体行为，依赖注入的时候需要根据 bean 的名称或类型等进行装配。</p></li></ul><h2 id="创建Bean的几种方式"><a href="#创建Bean的几种方式" class="headerlink" title="创建Bean的几种方式"></a>创建Bean的几种方式</h2><h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><h4 id="①-基于-Component"><a href="#①-基于-Component" class="headerlink" title="① 基于 @Component"></a>① 基于 @Component</h4><ol><li><p>通过注解方式创建容器:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public interface ThisIsConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Configuration 来标注该接口是用于定义配置的, Spring 会视为该java文件为一个xml配置</li><li>@ComponentScan Spring 将会扫描该类所在的包下的所有 bean注解(@Component, @Service等等), 等同于在 Spring的xml里写:<br>  <code>&lt;context:component-scan base-package=&quot;com.bigdata&quot;&gt;&lt;/context:component-scan&gt;</code><br>  如果要指定要扫描的包的路径(而不是 这个类所在的包) 可以用 <code>@ComponentScan(value=&quot;包路径&quot;)</code> 指定;</li></ul></li><li>带有 <code>@Component</code>注解的类被Ioc方式创建:</li><li>通过 <code>@Autowired</code> 用 DI 方式进行装配:</li></ol><blockquote><p>关于@Component,@Service,@Controler,@Repository注解<br>这几个注解都是同样的功能，被注解的类将会被 Spring 容器创建<strong>单例</strong>对象。<br>@Component : 侧重于通用的Bean类<br>@Service：标识该类用于业务逻辑<br>@Controler：标识该类为Spring MVC的控制器类<br>@Repository: 标识该类是一个实体类，只有属性和Setter,Getter</p></blockquote><h4 id="②-基于-Bean"><a href="#②-基于-Bean" class="headerlink" title="② 基于 @Bean"></a>② 基于 @Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SwaggerSpringMvcPlugin <span class="title">customImplementation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Bean</code> 注解在这里的意思是 : 该方法会返回一个 SwaggerSpringMvcPlugin 类型的 bean</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p>Component vs Bean 的区别，参考下面的 「 [[#注解(Annotation)]] 」一章</p><h3 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h3><p>① 基于构造器: 下面的类JedisPortsFactory 具有一个构造器(该构造器 有两个参数: config 和 autoFlush)<br>config 引用到了另一个bean, autoFlush 是个boolean型</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"jedisPortsFactory"</span> <span class="attr">class</span>=<span class="string">"com.bigdata.console.tools.online.JedisPortsFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"config"</span> <span class="attr">ref</span>=<span class="string">"jedisEvictionPoolConfig"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"autoFlush"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>② 基于 setter: CommonsMultipartResolver 要有<code>property</code>对应的 Setter方法</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"-1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>③ 基于静态工厂: 指定 工厂类的class, 适用于 静态工厂方法:</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jp_featurePv"</span> <span class="attr">class</span>=<span class="string">"com.bigdata.consoleJedisPortsFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getJedisMSServers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>④ 基于动态工厂: 指定 动态工厂的bean 和方法, 下面的例子中工厂方法 getJedisMSServers 有一个字符串型的参数, 适用于动态工厂方法:</p><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jp_featurePv"</span> <span class="attr">factory-bean</span>=<span class="string">"jedisPortsFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getJedisMSServers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="Bean的属性"><a href="#Bean的属性" class="headerlink" title="Bean的属性"></a>Bean的属性</h3><p>无论是基于@Component 还是 Xml 创建的 Bean ，属性都是通用的：</p><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><ul><li>scope=”singleton”: 单例,  Spring 在每次需要时都返回同一个bean实例</li><li>scope=”prototype”: Spring 在每次需要时都产生一个新的 bean 实例</li><li>scope=”request”</li><li>scope=”session”</li></ul><p>如果使用 @Service、@Controller … 等注解创建 Bean：</p><ul><li>@Component 注解默认实例化的对象是单例，如果想声明成多例对象可以使用@Scope(“prototype”)</li><li>@Repository 默认单例</li><li>@Service 默认单例</li><li>@Controller 默认单例</li></ul><h4 id="autowire"><a href="#autowire" class="headerlink" title="autowire"></a>autowire</h4><ul><li>autowire=”byName”: 只能用于setter注入。比如我们有方法“setHelloApi”，则“byName”方式Spring容器将查找名字为helloApi的Bean并注入</li><li>autowire=”no”: 意思是 Spring 将不自动装配这个Bean，必须明确指定依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"bean.HelloApiDecorator"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h4><p>Spring保证该Bean所依赖的其他bean已经初始化, 用<code>&lt;ref&gt;</code>元素建立对其他bean的依赖关系, Sprign 会确保创建 bean的顺序:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloApi"</span> <span class="attr">class</span>=<span class="string">"helloworld.HelloImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"decorator"</span>  <span class="attr">class</span>=<span class="string">"helloworld.HelloApiDecorator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">depends-on</span>=<span class="string">"helloApi"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helloApi"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"helloApi"</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h4><p>单例模式的beanA需要引用另外一个非单例模式的beanB，为了在我们每次引用的时候都能拿到最新的beanB</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"prototypeBean"</span> <span class="attr">class</span>=<span class="string">"bean.PrototypeBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span> <span class="attr">class</span>=<span class="string">"bean.SingletonBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SingletonBean.getBean()方法被代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getBean"</span> <span class="attr">bean</span>=<span class="string">"prototypeBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBean</span></span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法, 每次获取一个新的PrototypeBean实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PrototypeBean <span class="title">getBean</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:resource/applicationContext.xml"</span>);</span><br><span class="line">SingletonBean single= (SingletonBean)app.getBean(<span class="string">"singletonBean"</span>);</span><br><span class="line">single.getBean();  <span class="comment">// 每次返回一个新的PrototypeBean</span></span><br></pre></td></tr></table></figure><h2 id="Bean的初始化-销毁回调"><a href="#Bean的初始化-销毁回调" class="headerlink" title="Bean的初始化/销毁回调"></a>Bean的初始化/销毁回调</h2><p><img src="/images/javaee/spring-bean-lifecycle.png" alt="Spring-Bean-Lifecycle"></p><h3 id="基于代码"><a href="#基于代码" class="headerlink" title="基于代码"></a>基于代码</h3><p>InitializingBean接口为bean提供了属性初始化后的处理方法，它只包括afterPropertiesSet方法，凡是继承该接口的类，在bean的属性初始化后都会执行该方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some initialization work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisposableBean接口为bean提供销毁方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do some destruction work</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="基于XML配置"><a href="#基于XML配置" class="headerlink" title="基于XML配置"></a>基于XML配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"com.dropNotes.HelloWorld"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的init-method属性和 destroy-method属性, 指定了HelloWorld类的初始化/销毁回调方法名字, 接下来在HelloWorld类中定义无参的方法即可.</p><h3 id="何时调用"><a href="#何时调用" class="headerlink" title="何时调用"></a>何时调用</h3><p>当<code>ApplicationContext.registerShutdownHook()</code>被调用时</p><h1 id="IOC-和-DI"><a href="#IOC-和-DI" class="headerlink" title="IOC 和 DI"></a>IOC 和 DI</h1><p>上面提到了 Spring 基于 Ioc 和 DI 的方式创建 &amp; 装配 Bean，总结一下 IoC 和 DI 的常用注解 :</p><ul><li>IoC 创建 Bean：@Bean、@Component、@Service、@Controller、@Repository …</li><li>DI 注入 Bean：@Autowired、@Resource …</li></ul><p>上面注解具体的区别参考下面的 「 [[#注解(Annotation)]] 」一章</p><h2 id="Spring-如何实现-IOC-和-DI"><a href="#Spring-如何实现-IOC-和-DI" class="headerlink" title="Spring 如何实现 IOC 和 DI"></a>Spring 如何实现 IOC 和 DI</h2><p>创建 bean（IoC），以 XML 方式为例，伪码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//解析&lt;bean .../&gt;元素的 id 属性得到该字符串值为“courseDao”  </span><br><span class="line">String idStr = &quot;courseDao&quot;; </span><br><span class="line"> </span><br><span class="line">//解析&lt;bean .../&gt;元素的class属性得到该字符串“com.xx.Dao.impl.CourseDaoImpl”  </span><br><span class="line">String classStr = &quot;com.xx.Dao.impl.CourseDaoImpl&quot;;  </span><br><span class="line"></span><br><span class="line">//利用反射创建对象  </span><br><span class="line">Class&lt;?&gt; cls = Class.forName(classStr);  </span><br><span class="line">Object obj = cls.newInstance();  </span><br><span class="line"></span><br><span class="line">//放入Spring容器保存</span><br><span class="line">container.put(idStr, obj);</span><br></pre></td></tr></table></figure><p>构造器注入（DI）实现的伪码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射获取当前类所有的构造方法信息（Constructor 对象）</span><br><span class="line">Constructor&lt;?&gt;[] candidates = beanClass.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">// 设置构造方法参数实例</span><br><span class="line">Object[] argsToUse = new Object[parameterTypes.length];</span><br><span class="line">argsToUse[i] = getBean(beanNames.get(i));</span><br><span class="line"></span><br><span class="line">// 使用带有参数的 Constructor 对象实现实例化 Bean</span><br><span class="line">return constructorToUse.newInstance(argsToUse);</span><br></pre></td></tr></table></figure><p>Autowired 注入（DI）实现的伪码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射得到当前类所有的字段信息（Field 对象）</span><br><span class="line">Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line"></span><br><span class="line">// 判断字段是否有 @Autowired 注解</span><br><span class="line">Annotation ann = field.getAnnotation(Autowired.class);</span><br><span class="line"></span><br><span class="line">// 设置字段可连接，相当于将非 public（private、default、protect）更改为 public field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 通过反射设置字段的值</span><br><span class="line">field.set(bean, getBean(field.getName()));</span><br></pre></td></tr></table></figure><p>@ref: <a href="https://juejin.cn/post/6844904148316471310#heading-1" target="_blank" rel="noopener">Spring 中的反射与反射的原理 - 掘金</a></p><h1 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h1><p>AOP(Aspect Oriented Program) ，<strong>面向切面编程</strong>:<br>主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p><h2 id="AOP的一些概念"><a href="#AOP的一些概念" class="headerlink" title="AOP的一些概念"></a>AOP的一些概念</h2><p><img src="/images/javaee/javaee_spring_mvc_aop.png" alt=""></p><ul><li>连接点（Jointpoint）连接点是能够插入切面的一个点，连接点可能是类初始化，可以是调某方法时，抛出异常时，修改某字段时</li><li>切入点（Pointcut）：一组连接点集合</li><li>通知（Advice）：定义在连接点上“要做什么”，以及“何时去做”<ul><li>包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice）</li></ul></li><li>切面（Aspect）：可以认为是”通知”和”切入点”的集合</li></ul><ul><li>目标对象（Target Object）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象，在AOP中表示为“对谁做”；</li><li>AOP代理（AOP Proxy）：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</li><li>织入（Weaving）：织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</li><li>引入（inter-type declaration）：为已有的类添加额外新的字段或方法，Spring 允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）, 在 AOP 中表示为“做什么”；</li></ul><h2 id="基于XML配置aspect"><a href="#基于XML配置aspect" class="headerlink" title="基于XML配置aspect"></a>基于XML配置aspect</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"cn.javass.spring.chapter6.aop.HelloWorldAspect"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义了一个id="pointcut"的切点, 范围是com.javass包下的所有类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义切面的集合, ref="aspect"表示要引入"aspect"这个bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个切点, 包括用哪些切点, 以及在切点处要插入aspect.beforeAdvice()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span> <span class="attr">method</span>=<span class="string">"beforeAdvice"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义另一个切点, 在切点处要插入aspect.afterFinallyAdvice()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">"execution(* cn.javass..*.*(..))"</span> <span class="attr">method</span>=<span class="string">"afterFinallyAdvice"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于注解配置aspect"><a href="#基于注解配置aspect" class="headerlink" title="基于注解配置aspect"></a>基于注解配置aspect</h2><p>下面的代码定义一个切面(@Aspect): 哪里切入(@Pointcut), 切入的行为(@Advice)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerLogAspect</span> </span>&#123; <span class="comment">//定义了一个切面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点"logPointCut", 在哪些类里切入</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.xxx.*.controller..*.*(..)) &amp;&amp; "</span> +</span><br><span class="line">            <span class="string">"!execution(public * com.xxx.*.controller..CheckController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advice</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知, 在切点"logPointCut"之前</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"ret"</span>, pointcut = <span class="string">"logPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-如何实现-AOP"><a href="#Spring-如何实现-AOP" class="headerlink" title="Spring 如何实现 AOP"></a>Spring 如何实现 AOP</h2><p>Spring 通过 <strong>jdk 动态代理</strong>和 <strong>cglib 动态代理</strong>实现 AOP.</p><p>Spring 的 AOP 是通过 Java 语言提供的 <strong>代理(Proxy)模式</strong> 实现的, Java 语言的代理包括如下 2种方式: JDK 动态代理, Cglib 动态代理. 实现过程参考 @link [[../12.Java/Java-Tutorials.14.代理(Proxy)]]</p><blockquote><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib ，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：</p></blockquote><p><img src="/images/JavaEE.SpringMVC-2023-05-08-1.png" alt="../_images/JavaEE.SpringMVC-2023-05-08-1.png"></p><h2 id="Spring-AOP-vs-AspectJ"><a href="#Spring-AOP-vs-AspectJ" class="headerlink" title="Spring AOP vs AspectJ"></a>Spring AOP vs AspectJ</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><blockquote><p>Servlet 规范、Servlet 容器、Spring 实现的 DispatcherServlet 关系，参考 <a href="/13.JavaEE-Framework/JavaEE.Tomcat/" title="JavaEE.Tomcat">JavaEE.Tomcat</a> 第一节</p></blockquote><p>要使用Spring MVC只需要在web.xml(Java Servlet 规范里Java Web项目的部署描述符文件)里增加一个Servlet:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:appcontext-core-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet-工作流程"><a href="#DispatcherServlet-工作流程" class="headerlink" title="DispatcherServlet 工作流程"></a>DispatcherServlet 工作流程</h2><p>DispatcherServlet处理一次 Req 的流程，伪码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">（1）Request → DispatcherServlet</span><br><span class="line"></span><br><span class="line">（2）DispatcherServlet 从 HandleMapping[] 查找匹配, 返回 HandlerExecutionChain &#123; HandlerInterceptor1,HandleInterceptor2..&#125;</span><br><span class="line"></span><br><span class="line">（3）HandleInterceptor → HandleAdaptor → Controller</span><br><span class="line"></span><br><span class="line">（4）Controller 返回 ModelAndView → ViewResolver</span><br><span class="line"></span><br><span class="line">（5）View</span><br></pre></td></tr></table></figure></p><ul><li><p>对于 Spring MVC 程序来说, 首先调用的是 <code>DispatcherServlet.service(ServletRequest, ServletResponse)</code>, 实现是在 <code>HttpServlet.service(ServletRequest req, ServletResponse resp)</code>, 这个方法里把 ServletRequest 对象转换为 HttpServletRequest, 在这个方法里又调用进了 <code>FrameworkServlet.service(HttpServletRequest req, HttpServletResponse resp)</code>, 在这个方法里如果 <code>method!=PATCH</code> 则调用进 <code>super.service(HttpServletRequest, HttpServletResponse)</code>, 也就是 <code>HttpServletservice(HttpServletRequest, HttpServletResponse)</code>, 这里根据不同的 method 调用不同的 <code>doX()</code> 方法</p></li><li><p>以 GET 方法为例，调用 <code>this.doGet()</code>, 因为在 <code>FrameworkServlet</code> 重写了 <code>doGet()</code>, 所以这里调用的代码是 <code>FrameworkServlet.doGet()</code>,  在这个方法里调用了<code>FrameworkServlet.processRequest()</code>, 然后又调用了<code>this.doService()</code>,</p></li><li><code>DispatcherServlet</code> 重写了 <code>doService()</code>, 所以最终调用到 <code>DispatcherServlet.doService()</code>, 该方法逻辑大致如下:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void doDispatch(HttpServletRequest request, HttpServletResponse response)  &#123;</span><br><span class="line">    HandlerExecutionChain mappedHandler = getHandler(processedRequest);</span><br><span class="line">    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>getHandler()</code>主要就是通过<code>this.handlerMappings</code>中的HandlerMapping实例来对具体request映射一个handler（Spring MVC中的Controller类） ;</li><li>如果看过<code>this.handlerMappings</code>的初始化，便知道HandlerMapping的具体实现有3个：<ul><li>RequestMappingHandlerMapping : 用来映射Controller和URL</li><li>BeanNameUrlHandlerMapping</li><li>SimpleUrlHandlerMapping</li></ul></li><li>……</li><li>……</li></ol><hr><p><img src="/images/javaee/javaee_spring_mvc_dispacher.png" alt="DispatcherServlet 工作流程"><br>上图中组件处理顺序分别是:</p><ul><li>Dispatcher Servlet分发器</li><li>Handler Mapping 处理器映射</li><li>Controller 控制器</li><li>ModelAndView 模型和视图对象</li><li>ViewResolver 视图解析器</li></ul><blockquote><p>@ref <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484846&amp;idx=1&amp;sn=490014ea65669c1a1e73e25d7b9fa569" target="_blank" rel="noopener">SpringMVC 工作原理详解</a></p></blockquote><h1 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器(Interceptor)"></a>拦截器(Interceptor)</h1><p>处理器映射处理过程配置的拦截器，必须实现 org.springframework.web.servlet包下的 <code>HandlerInterceptor</code>接口。<br>这个接口定义了三个方法：<br><code>preHandle(..)</code>，它在处理器实际执行 之前 会被执行；<br><code>postHandle(..)</code>，它在处理器执行 完毕 以后被执行；<br><code>afterCompletion(..)</code>，它在 整个请求处理完成 之后被执行。</p><h2 id="通过xml定义拦截器"><a href="#通过xml定义拦截器" class="headerlink" title="通过xml定义拦截器"></a>通过xml定义拦截器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"officeHoursInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"officeHoursInterceptor"</span> <span class="attr">class</span>=<span class="string">"samples.TimeBasedAccessInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"openingTime"</span> <span class="attr">value</span>=<span class="string">"9"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"closingTime"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过注解定义拦截器"><a href="#通过注解定义拦截器" class="headerlink" title="通过注解定义拦截器"></a>通过注解定义拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LocaleInterceptor());</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> ThemeInterceptor()).addPathPatterns(<span class="string">"/**"</span>).excludePathPatterns(<span class="string">"/admin/**"</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SecurityInterceptor()).addPathPatterns(<span class="string">"/secure/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制器-Controller"><a href="#控制器-Controller" class="headerlink" title="控制器(Controller)"></a>控制器(Controller)</h1><h2 id="传入类型"><a href="#传入类型" class="headerlink" title="传入类型"></a>传入类型</h2><ul><li>@RequestParam注解: <code>@RequestParam(value = &quot;client_id&quot;) String appId</code></li><li>Model类型: 这种通常返回String类型的view路径</li><li>HttpServletResponse:</li><li>HttpServletRequest:</li></ul><h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><ul><li>返回ModelAndView: 返回视图<code>return new ModelView(&quot;/view/111&quot;, map)</code><ul><li>通过ModelAndView也可以重定向: <code>return new ModelAndView(&quot;redirect:/controller2&quot;);</code></li><li>如果modelView是以参数传入的: <code>model.setViewName(&quot;forward:index.jsp&quot;); return model;</code></li></ul></li><li>返回RedirectView: 专门用来处理转发的视图, 见后面的代码.</li><li>返回String: 返回字符串可以指定逻辑视图名, 通过视图解析器解析为物理视图地址<ul><li>通过String也可以重定向: <code>return &quot;redirect:/resource/page2.jsp&quot;;</code></li><li>如果Controller带有<code>@ResponseBody</code>注解, 可以直接返回String字面值;</li></ul></li><li>以json返回对象: 借助<code>@ResponseBody</code>注解, 项目导入Jackson.jar, 并且在Spring配置文件启用了<code>&lt;mvc:annotation-driven /&gt;</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li><li>返回Map:<ul><li>借助<code>@ResponseBody</code>注解, <code>return new HashMap&lt;&gt;();</code>会返回一个json</li><li>没有<code>@ResponseBody</code>注解, <code>map.put(&quot;key1&quot;, &quot;value-1&quot;); return map;</code>, 在jsp页面中可直通过<code>${key1}</code>获得到值</li></ul></li><li>返回void: 需要通过形参传入request和response<ul><li>使用request转向页面: <code>request.getRequestDispatcher(&quot;index.html&quot;).forward(request, response);</code></li><li>通过response页面重定向: <code>response.sendRedirect(&quot;http://www.xxx.com&quot;);</code></li><li>forward和Redirect的区别: forward是由Servlet直接转给另一个Controller处理, Redirect相当于302, 返回给浏览器, 然后浏览器再发一次新的请求到Controller2</li><li>通过response指定响应结果:<ul><li>返回json: <code>response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;this_is_json&quot;);</code></li><li>返回Html: <code>response.getWriter().println(&quot;&lt;title&gt;HelloWorld&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</code></li></ul></li></ul></li></ul><h3 id="用RedirectAttributes带参跳转"><a href="#用RedirectAttributes带参跳转" class="headerlink" title="用RedirectAttributes带参跳转:"></a>用RedirectAttributes带参跳转:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedirectView <span class="title">hello</span><span class="params">(RedirectAttributes attrs)</span> </span>&#123;</span><br><span class="line">    attrs.addAttribute(<span class="string">"message"</span>, <span class="string">"hello"</span>);</span><br><span class="line">    attrs.addFlashAttribute(<span class="string">"username"</span>, <span class="string">"sudoz"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedirectView(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">hello</span><span class="params">(@ModelAttribute(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">                              @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">    map.put(<span class="string">"username"</span>, username);</span><br><span class="line">    map.put(<span class="string">"message"</span>, message);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> mvc:annotation-driven是一种简写形式，完全可以手动配置替代这种简写形式，<code>&lt;mvc:annotation-driven /&gt;</code>会自动注册<code>DefaultAnnotationHandlerMapping</code>与<code>AnnotationMethodHandlerAdapter</code> 两个bean,是Spring MVC为<code>@Controllers</code>分发请求所必须的。<br>并提供了：数据绑定支持，<code>@NumberFormatannotation</code>支持，<code>@DateTimeFormat</code>支持，<code>@Valid支持</code>，读写XML的支持（JAXB），读写JSON的支持（Jackson）。</p><h3 id="Spring是如何处理返回类型的"><a href="#Spring是如何处理返回类型的" class="headerlink" title="Spring是如何处理返回类型的?"></a>Spring是如何处理返回类型的?</h3><p>DispatchServlet.viewResolvers的类型是<code>List&lt;ViewResolver&gt;</code>, Controller返回的类型转给DispatchServlet, 最终交给不同的ViewResolver处理的</p><h1 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h1><p>所有web应用的MVC框架都提供了视图相关的支持。Spring提供了一些视图解析器，它们让你能够在浏览器中渲染模型，并支持你自由选用适合的视图技术而不必与框架绑定到一起。<br>Spring原生支持JSP视图技术、Velocity模板技术和XSLT视图等。</p><p>有两个接口在Spring处理视图相关事宜时至关重要，分别是视图解析器接口ViewResolver和视图接口本身View。<br>视图解析器ViewResolver负责处理视图名与实际视图之间的映射关系。<br>视图接口View负责准备请求，并将请求的渲染交给某种具体的视图技术实现。</p><h2 id="使用ViewResolver接口解析视图"><a href="#使用ViewResolver接口解析视图" class="headerlink" title="使用ViewResolver接口解析视图"></a>使用ViewResolver接口解析视图</h2><p>Spring MVC中所有控制器的处理器方法都必须返回一个逻辑视图的名字，无论是显式返回（比如返回一个String、View或者ModelAndView）还是隐式返回（比如基于约定的返回）。<br>Spring中的视图由一个视图名标识，并由视图解析器来渲染。Spring有非常多内置的视图解析器。</p><h1 id="资源-Resource"><a href="#资源-Resource" class="headerlink" title="资源(Resource)"></a>资源(Resource)</h1><h2 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h2><p>Resource接口提供了足够的抽象，足够满足我们日常使用。而且提供了很多内置Resource实现：ByteArrayResource、InputStreamResource 、FileSystemResource 、UrlResource 、ClassPathResource、ServletContextResource、VfsResource等。</p><p>路径通配符</p><ul><li><code>?</code>匹配一个字符，如<code>config?.xml</code>将匹配<code>config1.xml</code></li><li><code>*</code>匹配零个或多个字符串，如<code>cn/*/config.xml</code>将匹配<code>cn/javass/config.xml</code>，但不匹配匹配<code>cn/config.xml</code></li><li><code>**</code>匹配路径中的零个或多个目录，如<code>cn/**/config.xml</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Resource例子1:</span></span><br><span class="line">ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//只加载一个绝对匹配Resource，且通过ResourceLoader.getResource进行加载</span></span><br><span class="line">Resource[] resources=resolver.getResources(<span class="string">"classpath:META-INF/INDEX.LIST"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Resource例子2:</span></span><br><span class="line">ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"><span class="comment">//将加载多个绝对匹配的所有Resource</span></span><br><span class="line"><span class="comment">//将首先通过ClassLoader.getResources("META-INF")加载非模式路径部分</span></span><br><span class="line"><span class="comment">//然后进行遍历模式匹配</span></span><br><span class="line"><span class="comment">// classpath*： 用于加载类路径（包括jar包）中的所有匹配的资源</span></span><br><span class="line">Resource[] resources=resolver.getResources(<span class="string">"classpath*:META-INF/INDEX.LIST"</span>);</span><br></pre></td></tr></table></figure><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>静态资源包括：HTML、CSS、JS、图像、视频、PDF/Office等不需要服务器端处理的文件。</p><p>静态资源文件的位置:</p><ul><li>Java Web默认的静态资源文件夹是 src/main/webapp/</li><li>Spring Boot自动将src/main/resource/下的「/static」「/public」「/resources」「/META-INF/resources」识别为资源文件夹。 下面的css可以通过访问<code>http://localhost:8080/css/a.css</code>获取<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project Root</span><br><span class="line">└─src</span><br><span class="line">    └─ main</span><br><span class="line">        └─ resources</span><br><span class="line">            ├─ static</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ a.css</span><br><span class="line">            ├─ public</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ b.css</span><br><span class="line">            ├─ resources</span><br><span class="line">            |   └─ css</span><br><span class="line">            |       └─ b.css</span><br><span class="line">            └─ META-INF</span><br><span class="line">                └─ resources</span><br><span class="line">                    └─ css</span><br><span class="line">                        └─ d.css</span><br></pre></td></tr></table></figure></li></ul><h1 id="异常处理-Exception"><a href="#异常处理-Exception" class="headerlink" title="异常处理(Exception)"></a>异常处理(Exception)</h1><ol><li>Controller的匹配. 除了<code>value</code>指定url, 还可以通过<code>product</code>指定MIME-TYPE(参考网络协议HTTP)</li><li>调试的时候需要注意, <code>cURL</code>实际是使用了<code>Accept: */*</code>, 浏览器发出的请求是<code>Accept:text/html</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/return-text-plain"</span>, produces = MimeTypeUtils.TEXT_PLAIN_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">returnPlainText</span><span class="params">()</span> <span class="keyword">throws</span> SomeException </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> SomeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How to自定义Error页面:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDefaultErrorViewConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ThymeleafViewResolver thymeleafViewResolver;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> View <span class="title">error</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thymeleafViewResolver.resolveViewName(<span class="string">"custom-error-page/error"</span>, Locale.CHINA);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h1><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><h3 id="IOC-注解-Service-Controller-Repository-Component-Bean"><a href="#IOC-注解-Service-Controller-Repository-Component-Bean" class="headerlink" title="IOC 注解: @Service, @Controller, @Repository, @Component, @Bean"></a>IOC 注解: @Service, @Controller, @Repository, @Component, @Bean</h3><ul><li>@Service: 用于注解Service层, 默认是单例的</li><li>@Controller: 定义控制器类一般这个注解在类中，通常方法需要配合注解 @RequestMapping</li><li>@RestController相当于<code>@ResponseBody</code>和<code>@Controller</code>的合集, 默认是单例的</li><li>@Repository用于注解DAO，这个注解修饰的DAO类会被ComponetScan发现并配置，同时也不需要为它们提供xml配置项</li><li>如果一个类不好归类, 则使用 <code>@Component</code> 注解</li><li><p>The default scope for the bean is <strong>a singleton</strong></p></li><li><p>@Bean: 区别与上面的注解，@Component 注解作用于类，而 @Bean 注解作用于方法, 该方法必须返回一个类型对象, 该对象被注册为 Spring 上下文中的 bean, 注意方法名字将会作为 bean 的 ID, 相当于在 xml 中定义 <code>&lt;bean&gt;</code></p><ul><li>@Bean(initMethod=”aa”,destroyMethod=”bb”): 指定 aa 和 bb 方法分别在在构造之后/销毁之前执行</li></ul></li></ul><blockquote><p>Spring 会自动扫描 <code>base-package</code> 指定的包下面用 <code>@Service</code> 注解的所有类, 并注册到 beans 容器里.<br>需要在 Spring 配置文件里增加: <code>&lt;context:component-scan base-package=&quot;com.xxx.product.core.service&quot;/&gt;</code> 来说明启用自动扫描</p></blockquote><h3 id="DI-注解-Autowired-Resource-Inject-Primary"><a href="#DI-注解-Autowired-Resource-Inject-Primary" class="headerlink" title="DI 注解: @Autowired, @Resource, @Inject, @Primary"></a>DI 注解: @Autowired, @Resource, @Inject, @Primary</h3><ul><li>@Autowired: 可以写在属性上, 和 setter 方法上, 或者构造函数上, 默认按照类型进行装配</li><li>@Autowired 和@Inject: 通过 <code>AutowiredAnnotationBeanPostProcessor</code> 来实现依赖注入, 顺序:<ol><li>按照类型匹配</li><li>使用限定符进行类型限定</li><li>按照名称匹配</li></ol></li><li>@Resource: 使用 <code>CommonAnnotationBeanPostProcessor</code> 来实现注入, 顺序:<ol><li>按照名称匹配</li><li>按照类型匹配</li><li>使用限定符进行类型限定</li></ol></li></ul><p>➤ 区别二者：</p><ul><li>@Resource 并不是 Spring 的注解，它的包是 javax.annotation.Resource， Spring 也支持该注解的注入；</li><li>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter 方法；</li></ul><h3 id="ComponentScan-amp-Component"><a href="#ComponentScan-amp-Component" class="headerlink" title="@ComponentScan &amp; @Component"></a>@ComponentScan &amp; @Component</h3><ul><li>@Component: 使用在类上, 表示可以被 <code>@ComponentScan</code> 标注的类扫描到</li><li>@ComponentScan: 使用在类上, 可以扫描到 <code>@Component</code> 注解的类</li></ul><blockquote><p>比较: <code>@Configuration</code> + <code>@Bean</code> 的方式需要在@Configuration 的类里定义”返回每种 Bean 类型的方法”, <code>@ComponentScan</code> + <code>@Component</code> 的方式省去了定义方法返回 Bean 的类型<br><code>@Configuration</code>, <code>@ComponentScan</code>, <code>@Component</code> 注解通常联合起来使用, 免去了在 xml 里定义 bean, 也不必写 <code>@Bean</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123; <span class="keyword">this</span>.cd = cd; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扫描到的Bean:</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ContextConfiguration-amp-Configuration"><a href="#ContextConfiguration-amp-Configuration" class="headerlink" title="@ContextConfiguration &amp; @Configuration"></a>@ContextConfiguration &amp; @Configuration</h3><ul><li>@Configuration: 用于类上, 说明这个类可以使用 Spring IoC 容器作为 bean 定义的来源, 相当于在 xml 中定义 <code>&lt;beans&gt;</code></li><li>@ContextConfiguration(classes=KnightConfig.class) 使用在类上, 表示使用 <code>@Configuration</code> 标注的类当作 bean 的定义来源</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditorConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TextEditor <span class="title">textEditor</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TextEditor( spellChecker() );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">spellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SpellChecker( );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的等同于在xml里定义了两个&lt;bean&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用从@Configuration标注类里注入的bean</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=KnightConfig.class,loader=AnnotationConfigContextLoader.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  TextEditor textEditor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpellChecker spellChecker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transcational-Cacheable"><a href="#Transcational-Cacheable" class="headerlink" title="@Transcational, @Cacheable"></a>@Transcational, @Cacheable</h3><ul><li>@Transcational : 事务处理</li><li>@Cacheable : 数据缓存</li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>默认是<code>@Scope(&quot;singleton&quot;)</code>单例的, 此外还有:</p><ul><li><code>singleton</code> 单例的</li><li><code>prototype</code> 表示每次获得bean都会生成一个新的对象</li><li><code>request</code> 表示在一次http请求内有效</li><li><code>session</code> 表示在一个用户会话内有效</li></ul><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"ImplementedClass"</span>)</span><br><span class="line">    <span class="keyword">private</span> AbstractClass a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当抽象类AbstractClass的实现类有多个时, 如果没有<code>Qualifier</code>注解则会报错, 因为Spring不知道应该注入哪个类型, 注意<code>@Qualifier()</code>括号里是类的名字</p><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h3><ul><li>@After @Before. @Around 定义切面,可以直接将拦截规则(切入点 PointCut)作为参数</li><li>@PointCut : 专门定义拦截规则 然后在 @After @Before. @Around 中调用</li><li>@EnableAaspectJAutoProxy : 开启Spring 对 这个切面(Aspect )的支持</li></ul><h2 id="JDK注解"><a href="#JDK注解" class="headerlink" title="JDK注解"></a>JDK注解</h2><ul><li>@Resource: 可以写在属性上, 和setter方法上, 默认按照名称进行装配</li></ul><h1 id="Spring中的线程安全性"><a href="#Spring中的线程安全性" class="headerlink" title="Spring中的线程安全性"></a>Spring中的线程安全性</h1><blockquote><p>本节参考： <a href="https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/" target="_blank" rel="noopener">聊一聊Spring中的线程安全性 | SylvanasSun’s Blog</a></p></blockquote><p>Spring 作为一个 IOC/DI 容器，帮助我们管理了许许多多的“bean”。但其实，Spring 并没有保证这些对象的线程安全，需要由开发者自己编写解决线程安全问题的代码。</p><p>Spring对每个bean提供了一个<code>scope</code>属性来表示该bean的作用域。它是bean的生命周期。例如，一个<code>scope</code>为<code>singleton</code>的bean，在第一次被注入时，会创建为一个单例对象，该对象会一直被复用到应用结束。</p><blockquote><p>singleton：默认的scope，每个scope为singleton的bean都会被定义为一个单例对象，该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。<br>prototype：bean被定义为在每次注入时都会创建一个新的对象。<br>request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。<br>session：bean被定义为在一个session的生命周期内创建一个单例对象。<br>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。<br>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。</p></blockquote><p>我们交由Spring管理的大多数对象其实都是一些<strong>无状态的对象</strong>，这种不会因为多线程而导致状态被破坏的对象很适合Spring的默认scope，每个单例的无状态对象都是线程安全的（也可以说只要是无状态的对象，不管单例多例都是线程安全的，不过单例毕竟节省了不断创建对象与GC的开销）。</p><p><strong>无状态的对象</strong>即是自身没有状态的对象，自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题。无状态对象包括我们经常使用的DO、DTO、VO这些只作为数据的实体模型的贫血对象，还有Service、DAO和Controller，这些对象并没有自己的状态，它们只是用来执行某些操作的。例如，每个DAO提供的函数都只是对数据库的CRUD，而且每个数据库Connection都作为函数的局部变量（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题），用完即关（或交还给连接池）。</p><p>有人可能会认为，我使用 <code>scope=request</code> 作用域不就可以避免每个请求之间的安全问题了吗？这是完全错误的，因为 Controller 默认是单例的，一个 HTTP 请求是会被多个线程执行的，这就又回到了线程的安全问题。当然，你也可以把 Controller 的 scope 改成 prototype，实际上 Struts2就是这么做的，但有一点要注意，Spring MVC 对请求的拦截粒度是基于每个方法的，而 Struts2是基于每个类的，所以把 Controller 设为多例将会频繁的创建与回收对象，严重影响到了性能。</p><p>通过阅读上文其实已经说的很清楚了，Spring 根本就没有对 bean 的多线程安全问题做出任何保证与措施。对于每个 bean 的线程安全问题，根本原因是每个 bean 自身的设计。不要在 bean 中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用 <code>ThreadLocal</code> 把变量变为线程私有的，如果 bean 的实例变量或类变量需要在多个线程之间共享，那么就只能使用 <code>synchronized</code>、<code>lock</code>、<code>CAS</code> 等这些实现线程同步的方法了。ThreadLocal @link [[../12.Java/Java-并发.02.ThreadLocal]] &amp; Servlet 规范的线程安全  @link <a href="/13.JavaEE-Framework/JavaEE.Servlet/" title="JavaEE.Servlet">JavaEE.Servlet</a></p><blockquote><p>本文作者为 <a href="https://github.com/SylvanasSun" target="_blank" rel="noopener">SylvanasSun(sylvanas.sun@gmail.com)</a>，首发于 <a href="https://sylvanassun.github.io/" target="_blank" rel="noopener">SylvanasSun’s Blog</a>。<br>原文链接：<a href="https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/" target="_blank" rel="noopener">https://sylvanassun.github.io/2017/11/06/2017-11-06-spring_and_thread-safe/</a><br>（转载请务必保留本段声明，并且保留超链接。）</p></blockquote><h1 id="Async注解实现异步方法"><a href="#Async注解实现异步方法" class="headerlink" title="@Async注解实现异步方法"></a>@Async注解实现异步方法</h1><p>• 定义线程池：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ExecutorConfig &#123;</span><br><span class="line">    @Bean(&quot;customExecutor-1&quot;)// 自定义线程池1</span><br><span class="line">    public Executor customExecutor1() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(3);//核心池大小</span><br><span class="line">        executor.setMaxPoolSize(6);//最大线程数</span><br><span class="line">        executor.setKeepAliveSeconds(60);//线程空闲时间</span><br><span class="line">        executor.setQueueCapacity(10);//队列程度</span><br><span class="line">        executor.setThreadNamePrefix(&quot;customExecutor-1-&quot;);//线程前缀名称</span><br><span class="line">        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());//配置拒绝策略</span><br><span class="line">        executor.setAllowCoreThreadTimeOut(true);// 允许销毁核心线程</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>• @Async定义异步的service方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AsyncService &#123;</span><br><span class="line">    // 例：无返回值的异步方法</span><br><span class="line">    // 使用上面定义的线程池</span><br><span class="line">    @Async(&quot;customExecutor-1&quot;)</span><br><span class="line">    public void noReturnMethod() &#123;</span><br><span class="line">        String tName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(&quot;current thread name : &quot; + tName);</span><br><span class="line">        System.out.println(&quot;noReturnMethod end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 例：有返回值的异步方法</span><br><span class="line">    // 使用默认 SimpleAsyncTaskExecutor</span><br><span class="line">    @Async</span><br><span class="line">    public Future&lt;String&gt; withReturnMethod() &#123;</span><br><span class="line">        String tName = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(&quot;current thread name : &quot; + tName);</span><br><span class="line">        return new AsyncResult&lt;&gt;(&quot;aaa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>• 使用异步service<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/async/test/&quot;)</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    // 无返回值</span><br><span class="line">    @GetMapping(&quot;/noReturn&quot;)</span><br><span class="line">    public String noReturn() &#123;</span><br><span class="line">        asyncService.noReturnMethod();</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 有返回值</span><br><span class="line">    @GetMapping(&quot;/withReturn&quot;)</span><br><span class="line">    public String withReturn() &#123;</span><br><span class="line">        Future&lt;String&gt; future = asyncService.withReturnMethod();</span><br><span class="line">        try &#123;</span><br><span class="line">            String res = future.get();// 阻塞获取返回值</span><br><span class="line">            System.out.println(&quot;res = &quot; + res);</span><br><span class="line">        &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="对“约定优于配置”的支持"><a href="#对“约定优于配置”的支持" class="headerlink" title="对“约定优于配置”的支持"></a>对“约定优于配置”的支持</h1><blockquote><p>约定优于配置（convention over configuration)，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。<br>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为”products_sold”，才需写有关这个名字的配置。<br>许多新的框架使用了约定优于配置的方法，包括：Spring，Ruby on Rails，Kohana PHP，Grails，Grok，Zend Framework，CakePHP，symfony，Maven，ASP.NET MVC，Web2py（MVC），Apache Wicket。<br>比如Maven对目录做了”约定优于配置”的设定:</p><blockquote><p>   src/main/resources: 资源文件目录;<br>   src/main/java: Java源码目录;<br>   src/main/webapp: web应用文件目录（当打包为war时），如WEB-INF/web.xml</p></blockquote></blockquote><h1 id="对JDBC的支持"><a href="#对JDBC的支持" class="headerlink" title="对JDBC的支持"></a>对JDBC的支持</h1><p>Spring主要提供JDBC模板方式、关系数据库对象化方式和SimpleJdbc方式三种方式来简化JDBC编程，这三种方式就是Spring JDBC的工作模式：</p><ul><li>JDBC模板方式：Spring JDBC框架提供以下几种模板类来简化JDBC编程，实现GoF模板设计模式，将可变部分和非可变部分分离，可变部分采用回调接口方式由用户来实现：如JdbcTemplate、NamedParameterJdbcTemplate、SimpleJdbcTemplate。</li><li>关系数据库操作对象化方式：Spring JDBC框架提供了将关系数据库操作对象化的表示形式，从而使用户可以采用面向对象编程来完成对数据库的访问；如MappingSqlQuery、SqlUpdate、SqlCall、SqlFunction、StoredProcedure等类。这些类的实现一旦建立即可重用并且是线程安全的。</li></ul><h2 id="JDBC模板"><a href="#JDBC模板" class="headerlink" title="JDBC模板"></a>JDBC模板</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from INFORMATION_SCHEMA.SYSTEM_TABLES"</span>;</span><br><span class="line">        jdbcTemplate.query(sql, <span class="keyword">new</span> RowCallbackHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                String value = rs.getString(<span class="string">"TABLE_NAME"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Column TABLENAME:"</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert into test(name) values('name1')"</span>);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"delete from test where name=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">"name2"</span>&#125;);</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update test set name='name3' where name=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">"name1"</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关系数据库对象化"><a href="#关系数据库对象化" class="headerlink" title="关系数据库对象化"></a>关系数据库对象化</h2><h1 id="对MyBatis的支持"><a href="#对MyBatis的支持" class="headerlink" title="对MyBatis的支持"></a>对MyBatis的支持</h1><p>参考<a href="http://www.mybatis.org/spring/zh/getting-started.html" target="_blank" rel="noopener">mybatis-spring – MyBatis-Spring | 第二章 入门</a> @ref</p><h2 id="1-引入mybatis-spring依赖"><a href="#1-引入mybatis-spring依赖" class="headerlink" title="1. 引入mybatis-spring依赖"></a>1. 引入mybatis-spring依赖</h2><p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-SqlSessionFactoryBean-amp-Mapper"><a href="#2-SqlSessionFactoryBean-amp-Mapper" class="headerlink" title="2. SqlSessionFactoryBean &amp; Mapper"></a>2. SqlSessionFactoryBean &amp; Mapper</h2><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory</code> 和至少一个数据映射器。</p><ul><li><p>增加 sqlSessionFactory 的 bean，注意  sqlSessionFactory 还需要一个数据源（DataSource），下面的例子用了 DruidDataSource</p></li><li><p>这里使用了 <code>MapperScannerConfigurer</code>, 它将会查找类路径下的映射器并自动将它们创建成 MapperFactoryBean</p></li><li><p>（可选）增加 <code>transactionManager</code> 的 bean, 开启 Spring 事务</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 要注意 SqlSessionFactory 需要一个 dataSource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/**/*.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义注解驱动事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置扫描包，加载mapper代理对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.kuaizhan.kzweixin.dao.mapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="对Transaction的支持"><a href="#对Transaction的支持" class="headerlink" title="对Transaction的支持"></a>对Transaction的支持</h1><ul><li><code>@Transactional(value=&quot;transactionManagerPrimary&quot;, isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED)</code><ul><li>value: 事务管理器</li><li>隔离级别（isolation）:<ul><li>DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。</li><li>READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li><li>READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的<strong>推荐值</strong>。</li><li>REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li><li>SERIALIZABLE：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul></li><li>传播行为（Propagation）:所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。<ul><li>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<strong>这是最常见的选择。</strong></li><li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。</li></ul></li></ul></li></ul><h1 id="Spring-MVC-Step-by-Step-Deprecated"><a href="#Spring-MVC-Step-by-Step-Deprecated" class="headerlink" title="Spring MVC Step by Step @Deprecated"></a>Spring MVC Step by Step @Deprecated</h1><ol><li>Pom.xml<ul><li>build - resources # 定义资源文件?</li></ul></li><li>webapp/WEB-INF/web.xml<ul><li>context-param: contextConfigLocation=classpath<em>:spring/appcontext-</em>.xml # 指定<code>Spring配置</code>路径</li><li>listener:  # listen优先级&gt;Servlet<ul><li>ContextLoaderListener=org.springframework.web.context.ContextLoaderListener</li><li>RequestContextListener=org.springframework.web.context.request.RequestContextListener</li></ul></li><li>servlet: org.springframework.web.servlet.DispatcherServlet<ul><li>init-param: contextConfigLocation=classpath:appcontext-core-web.xml # 指定<code>Servlet配置</code>路径</li></ul></li></ul></li><li>Spring配置xml: 默认去找classpath下的application-Context.xml,这是一种约定优于配置的概念<ul><li>context:property-placeholder: 指定<code>*.properties</code>位置</li><li>mvc:interceptors // 定义拦截器</li><li>mvc:annotation-driven // 注册DefaultAnnotationHandlerMapping/AnnotationMethodHandlerAdapter, 用于支持@Controller等注解风格</li><li>mvc:resources # css/js/htm等静态资源映射</li><li>增加View解析器:<ul><li>bean id=”velocityConfigurer” class=”org.springframework.web.servlet.view.velocity.VelocityConfigurer”</li><li>bean id=”viewResolver” class=”org.springframework.web.servlet.view.velocity.VelocityViewResolver”</li></ul></li><li>增加多数据源<ul><li>bean id=”parentDataSource” class=”org.springframework.jdbc.datasource.DriverManagerDataSource”</li><li>bean id=”adminDataSource” parent=”parentDataSource” # 数据源1</li><li>bean id=”userDataSource”  parent=”parentDataSource” # 数据源2</li><li>bean id=”dataSource” class=”com.frogking.datasource.DynamicDataSource” # 多数源映射关系, property增加上面两个bean</li><li>bean id=”sessionFactory” class=”org.springframework.orm.hibernate3.LocalSessionFactoryBean”</li></ul></li></ul></li></ol><h1 id="附-Configuration-XML说明"><a href="#附-Configuration-XML说明" class="headerlink" title="附: Configuration XML说明"></a>附: Configuration XML说明</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring/appcontext-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span> <span class="attr">id</span>=<span class="string">"ContextLoaderListener"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span> <span class="attr">id</span>=<span class="string">"RequestContextListener"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/2/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:appcontext-core-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>400<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-Framework-框架图&quot;&gt;&lt;a href=&quot;#Spring-Framework-框架图&quot; class=&quot;headerlink&quot; title=&quot;Spring Framework 框架图&quot;&gt;&lt;/a&gt;Spring Framework 框架图&lt;/h1&gt;&lt;p&gt;下图是 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.0.0.RC2/spring-framework-reference/overview.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 官网&lt;/a&gt;的一个架构图，介绍下其组成部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Spring-Framework-Runtime.png&quot; alt=&quot;../_images/Spring-Framework-Runtime.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心容器&quot;&gt;&lt;a href=&quot;#核心容器&quot; class=&quot;headerlink&quot; title=&quot;核心容器&quot;&gt;&lt;/a&gt;核心容器&lt;/h2&gt;&lt;p&gt;由spring-core、spring-beans、spring-context、spring-context-support和spring-expression模块组成：&lt;/p&gt;</summary>
    
    
    
    <category term="13.JavaEE" scheme="https://beefyheisenberg.github.io/categories/13-JavaEE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Spring MVC" scheme="https://beefyheisenberg.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringBoot/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.SpringBoot/</id>
    <published>2023-05-24T10:10:50.209Z</published>
    <updated>2023-05-24T10:10:50.209Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://sdtimes.com/wp-content/uploads/2018/03/spring-boot-490x257.png" alt="Spring Boot"></p><h1 id="Spring-Boot-vs-Spring"><a href="#Spring-Boot-vs-Spring" class="headerlink" title="Spring Boot vs Spring"></a>Spring Boot vs Spring</h1><ul><li>内置了嵌入式的Tomcat、Jetty等Servlet容器，应用可以不用打包成War格式，而是可以直接以Jar格式运行</li><li>Spring Boot提倡无XML配置文件的理念，使用Spring Boot生成的应用完全不会生成任何配置代码与XML配置文件。</li><li>提供了多个可选择的「starter」:<ul><li>spring-boot-starter-data-redis:</li><li>spring-boot-starter-activemq:</li><li>spring-boot-starter-jdbc:</li><li>spring-boot-starter-web:</li><li>spring-boot-starter-actuator:</li></ul></li></ul><h1 id="Spring-Boot-全家桶"><a href="#Spring-Boot-全家桶" class="headerlink" title="Spring Boot 全家桶"></a>Spring Boot 全家桶</h1><p><img src="/images/JavaEE.springboot-bucket.png" alt="../_images/JavaEE.springboot-bucket.png"></p><p>@ref: <a href="https://gitee.com/yidao620/springboot-bucket" target="_blank" rel="noopener">https://gitee.com/yidao620/springboot-bucket</a></p><h1 id="Spring-Boot-的新注解"><a href="#Spring-Boot-的新注解" class="headerlink" title="Spring Boot 的新注解"></a>Spring Boot 的新注解</h1><ul><li><code>@SpringBootApplication</code>: 相当于 <code>@Configuration + @EnableAutoConfiguration + @ComponentScan</code><ul><li><code>@Configuration</code> : 指明是IOC容器的配置类, 被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。</li><li><code>@EnableAutoConfiguration</code>  : SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。</li><li><code>@ComponentScan</code> : 组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。</li></ul></li><li><code>@RestController</code>: 作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON或者是XML。使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，效果等同于通过向<code>response.getOutputStream()</code>写入数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:spring/spring-main.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApiApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApiApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><p>Spring Cloud 主要组件：</p><ul><li>Spring Cloud Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Subversion。</li><li><p>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</p></li><li><p>Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</p></li><li>Ribbon：提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</li><li>Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li><li>Consul：封装了 Consul 操作，consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。</li><li><del>Eureka</del>：云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li><li>Spring Cloud Cluster：提供 Leadership 选举，如：Zookeeper, Redis, Hazelcast, Consul 等常见状态模式的抽象和实现。</li><li>Spring Cloud Zookeeper：操作 Zookeeper 的工具包，用于使用 zookeeper 方式的服务发现和配置管理。</li><li>Spring Cloud Task：提供云端计划任务管理、任务调度。</li></ul><ul><li>Spring Cloud Data Flow：大数据操作工具，作为 Spring XD 的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</li><li>Spring Cloud Stream：数据流操作开发包，封装了与 Redis,Rabbit、Kafka 等发送接收消息。</li></ul><p>@ref:  </p><ul><li><a href="https://www.zhihu.com/question/47304987" target="_blank" rel="noopener"> Spring boot与Spring cloud 是什么关系？ - 知乎</a></li><li><a href="https://www.springcloud.cc/" target="_blank" rel="noopener">https://www.springcloud.cc/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://sdtimes.com/wp-content/uploads/2018/03/spring-boot-490x257.png&quot; alt=&quot;Spring Boot&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Spring-Boot-vs-Spring&quot;&gt;&lt;a href=&quot;#Spring-Boot-vs-Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot vs Spring&quot;&gt;&lt;/a&gt;Spring Boot vs Spring&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;内置了嵌入式的Tomcat、Jetty等Servlet容器，应用可以不用打包成War格式，而是可以直接以Jar格式运行&lt;/li&gt;
&lt;li&gt;Spring Boot提倡无XML配置文件的理念，使用Spring Boot生成的应用完全不会生成任何配置代码与XML配置文件。&lt;/li&gt;
&lt;li&gt;提供了多个可选择的「starter」:&lt;ul&gt;
&lt;li&gt;spring-boot-starter-data-redis:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-activemq:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-jdbc:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-web:&lt;/li&gt;
&lt;li&gt;spring-boot-starter-actuator:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Spring-Boot-全家桶&quot;&gt;&lt;a href=&quot;#Spring-Boot-全家桶&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 全家桶&quot;&gt;&lt;/a&gt;Spring Boot 全家桶&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/JavaEE.springboot-bucket.png&quot; alt=&quot;../_images/JavaEE.springboot-bucket.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="13.JavaEE" scheme="https://beefyheisenberg.github.io/categories/13-JavaEE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Spring Boot" scheme="https://beefyheisenberg.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Servelt and JSP</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Servlet/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Servlet/</id>
    <published>2023-05-24T10:10:50.203Z</published>
    <updated>2023-05-24T10:10:50.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Web应用"><a href="#Java-Web应用" class="headerlink" title="Java Web应用"></a>Java Web应用</h1><p>Java Web 应用是一个 servlets, HTML 页面,类,和其他资源的集合，用于一个在 Web 服务器的完成的应用。Web 应用可以捆绑和运行来自多个供应商的在多个容器。<br>servlet 容器必须强制 Web 应用程序和 ServletContext 之间一对一对应的关系。ServletContext 对象提供了一个 servlet 和它的应用程序视图。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>可以使用标准的 Java 归档工具把 Web 应用程序打包并签名到一个 Web 存档格式（WAR）文件中。例如，一个关于“issue tracking”的应用程序可以分布在一个称为 issuetrack.war 的归档文件中。</p><p>当打包成这种形式时，将生成一个 META-INF 目录，其中包含了对 java归档工具有用的信息。尽管这个目录的内容可以通过 servlet 代码调用ServletContext 的 getResource 和 getResourceAsStream 方法来访问，容器也不能把这个目录当作内容来响应客户端请求。此外，任何请求访问 META-INF 目录中的资源必须返回一个 SC_NOT_FOUND（404）的响应。常见的归档格式war 和 ear格式对比：</p><ul><li><p>war: Web Archive file, 结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webapp.war</span><br><span class="line">  |-index.jsp</span><br><span class="line">  |— META-INF</span><br><span class="line">    |-Manifest.mf</span><br><span class="line">  |— WEB-INF</span><br><span class="line">       |- web.xml</span><br><span class="line">       |— classes</span><br><span class="line">       |— lib  // 依赖的jar包</span><br></pre></td></tr></table></figure></li><li><p>ear: Enterprise ARchieve, 用于在Java EE中将一个或者多个模块封装到一个文件中, 这样, 多个不同模块在应用服务器上的部署就可以同时并持续的进行. 结构如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.ear</span><br><span class="line">   |- ejb.jar    // ejb-jar包</span><br><span class="line">   |- other.jar  // 普通jar包</span><br><span class="line">   |- webapp.war  // war包</span><br><span class="line">   |—META-INF</span><br><span class="line">        application.xml  // EAR描述文件</span><br></pre></td></tr></table></figure></li></ul><h2 id="Web-xml"><a href="#Web-xml" class="headerlink" title="Web.xml"></a>Web.xml</h2><blockquote><p>servlet3.*的规范已经支持不使用 web.xml了</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>HelloWorld Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">        This is a simple web application with a source code organization</span><br><span class="line">        based on the recommendations of the Application Developer's Guide.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.web.listener.MyServletRequestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.web.listener.MyServletContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ResponseFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.web.filter.ResponseFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ResponseFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.web.Servlet.Hello<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Servlet（Server-Applet）"><a href="#Servlet（Server-Applet）" class="headerlink" title="Servlet（Server Applet）"></a>Servlet（Server Applet）</h1><p>本节参考自: <a href="https://www.gitbook.com/book/waylau/servlet-3-1-specification/details" target="_blank" rel="noopener">Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a> @ref</p><h2 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h2><p>servlet 是基于 Java 的 Web 组件，由容器进行管理，来生成动态内容。像其他基于 Java 的组件技术一样，servlet 也是基于平台无关的 Java 类格式，被编译为平台无关的字节码，可以被基于 Java 技术的 Web 服务器动态加载并运行。容器（Container），有时候也叫做 servlet 引擎，是 Web 服务器为支持 servlet 功能扩展的部分。客户端通过 servlet 容器实现的 request/response paradigm（请求/应答模式） 与 Servlet 进行交互。</p><h2 id="什么是-Servlet-容器"><a href="#什么是-Servlet-容器" class="headerlink" title="什么是 Servlet 容器"></a>什么是 Servlet 容器</h2><p>Servlet Container（Servlet 容器） 是 Web 服务器或者应用服务器的一部分，用于提供基于请求/响应发送模式的网络服务，解码基于 MIME 的请求，并且格式化基于 MIME 的响应。Servlet 容器同时也包含和管理他们的生命周期里 Servlet。<a href="/13.JavaEE-Framework/JavaEE.Tomcat/" title="JavaEE.Tomcat">JavaEE.Tomcat</a></p><p>Servlet 容器可以嵌入到宿主的 Web 服务器中，或者通过 Web 服务器的本地扩展 API 单独作为附加组件安装。Servelt 容器也可能内嵌或安装到启用 Web 功能的应用服务器中。</p><p>所有的 Servlet 容器必须支持 HTTP 协议用于请求和响应，但额外的基于请求/响应的协议，如 HTTPS (HTTP over SSL)的支持是可选的。对于 HTTP 规范需要版本，容器必须支持 HTTP/1.0 和 HTTP/1.1。因为容器或许支持 RFC2616 (HTTP/1.1)描述的缓存机制，缓存机制可能在将客户端请求交给 Servlet 处理之前修改它们，也可能在将 Servlet 生成的响应发送给客户端之前修改它们，或者可能根据 RFC2616 规范直接对请求作出响应而不交给 Servlet 进行处理。</p><p>Servlet 容器应该使 Servlet 执行在一个安全限制的环境中。在 Java 平台标准版（J2SE, v.1.3 或更高） 或者 Java 平台企业版(Java EE, v.1.3 或更高) 的环境下，这些限制应该被放置在 Java 平台定义的安全许可架构中。比如，高端的应用服务器为了保证容器的其他组件不受到负面影响可能会限制 Thread 对象的创建。</p><h2 id="Servlet-与其他技术的对比"><a href="#Servlet-与其他技术的对比" class="headerlink" title="Servlet 与其他技术的对比"></a>Servlet 与其他技术的对比</h2><p>从功能上看，servlet 位于 Common Gateway Interface（公共网关接口，简称 CGI）程序和私有的服务器扩展如 Netscape Server API（NSAPI）或 Apache Modules 这两者之间。<br>相对于其他服务器扩展机制 Servlet 有如下优势：</p><ul><li>它们通常比 CGI 脚本更快，因为采用不同的处理模型。</li><li>它们采用标准的 API 从而支持更多的Web 服务器。</li><li>它们拥有 Java 编程语言的所有优势，包括容易开发和平台无关。</li><li>它们可以访问 Java 平台提供的大量的 API。</li></ul><h2 id="与-Java-EE-的关系"><a href="#与-Java-EE-的关系" class="headerlink" title="与 Java EE 的关系"></a>与 Java EE 的关系</h2><p>Java Servlet API 3.1 版本是 Java 平台企业版 7 版本必须的 API。Servlet 容器和 servlet 被部署到平台中时，为了能在 Java EE 环境中执行，必须满足 JavaEE 规范中描述的额外的一些要求。</p><h2 id="与-Servlet-2-5-规范的兼容性"><a href="#与-Servlet-2-5-规范的兼容性" class="headerlink" title="与 Servlet 2.5 规范的兼容性"></a>与 Servlet 2.5 规范的兼容性</h2><p>在 Servlet 2.5 中, metadata-complete 只影响在部署时的注释扫描。 web-fragments 的概念在 servlet 2.5 并不存在。然而在 servlet 3.0 和之后,metadata-complete 影响扫描所有的在部署时指定部署信息和 web-fragments 注释。注释的版本的描述符必须不影响你扫描在一个web应用程序。除非 metadata-complete 指定，规范的一个特定版本的实现必须扫描所有配置的支持的注解。</p><h2 id="HttpServletRequest-–-请求"><a href="#HttpServletRequest-–-请求" class="headerlink" title="HttpServletRequest – 请求"></a>HttpServletRequest – 请求</h2><p>本节参考 <a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Request/3.%20The%20Request.html" target="_blank" rel="noopener">请求 · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a> @ref</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个请求对象只在一个 servlet 的 service 方法的作用域内，或过滤器的 doFilter 方法的作用域内有效，除非该组件启用了异步处理并且调用了请求对象的 startAsync 方法。<br>在发生异步处理的情况下，请求对象一直有效，直到调用 AsyncContext 的 complete 方法。容器通常会重复利用请求对象，以避免创建请求对象而产生的性能开销。<br>开发人员必须注意的是，不建议在上述范围之外保持 startAsync 方法还没有被调用的请求对象的引用，因为这样可能产生不确定的结果。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>ServletRequest 接口提供方法:</p><ul><li>getParameter</li><li>getParameterNames</li><li>getParameterValues</li><li>getParts</li><li>getPart</li><li>getAttribute</li><li>getHeader/getHeaders</li><li>getContextPath</li><li>…</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>当数据以multipart/form-data的格式发送时，servlet 容器支持文件上传。</p><h3 id="头"><a href="#头" class="headerlink" title="头"></a>头</h3><ul><li>getAttribute</li><li>getAttributeNames</li><li>setAttribute</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>getAttribute</li><li>getAttributeNames</li><li>setAttribute</li></ul><h3 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h3><ul><li>getContextPath</li><li>getServletPath</li><li>getPathInfo</li></ul><p>requestURI = contextPath + servletPath + pathInfo</p><h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><p><a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Request/3.7%20Non%20Blocking%20IO.html" target="_blank" rel="noopener">非阻塞 IO · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a></p><h2 id="ServletResponse-–-响应"><a href="#ServletResponse-–-响应" class="headerlink" title="ServletResponse – 响应"></a>ServletResponse – 响应</h2><p><a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/docs/The%20Response/5%20The%20Response.html" target="_blank" rel="noopener">响应 · Java Servlet 3.1 Specification《Java Servlet 3.1 规范》中文翻译及示例</a></p><h2 id="ServletContext-–-上下文"><a href="#ServletContext-–-上下文" class="headerlink" title="ServletContext – 上下文"></a>ServletContext – 上下文</h2><p>ServletContext 接口定义了 servlet 运行在的 Web 应用的视图。容器供应商负责提供 servlet 容器的 ServletContext 接口的实现。servlet 可以使用 ServletContext 对象记录事件，获取 URL 引用的资源，存取当前上下文的其他 servlet 可以访问的属性。<br>ServletContext 是 Web 服务器中已知路径的根。例如，servlet 上下文可以从 <a href="http://www.mycorp.com/catalog" target="_blank" rel="noopener">http://www.mycorp.com/catalog</a> 找出，/catalog 请求路径称为上下文路径，所有以它开头的请求都会被路由到与 ServletContext 相关联的 Web 应用。</p><h2 id="Filter-–-过滤器"><a href="#Filter-–-过滤器" class="headerlink" title="Filter – 过滤器"></a>Filter – 过滤器</h2><p>过滤器是一种代码重用的技术，它可以转换 HTTP 请求的内容，响应，及头信息。过滤器通常不产生响应或像 servlet 那样对请求作出响应，而是修改或调整到资源的请求，修改或调整来自资源的响应。</p><p>在web.xml中声明的每个<code>&lt;filter&gt;</code>在每个 JVM 的容器中仅实例化一个实例。容器提供了声明在过滤器的部署描述符的过滤器config（译者注：FilterConfig），对 Web 应用的 ServletContext 的引用，和一组初始化参数。<br>当容器接收到传入的请求时，它将获取列表中的第一个过滤器并调用<code>doFilter</code> 方法，传入 ServletRequest 和 ServletResponse，和一个它将使用的 FilterChain 对象的引用。</p><h3 id="过滤器组件示例"><a href="#过滤器组件示例" class="headerlink" title="过滤器组件示例"></a>过滤器组件示例</h3><ul><li>Authentication filters //用户身份验证过滤器</li><li>Logging and auditing filters //日志记录与审计过滤器</li><li>Image conversion filters //图片转换过滤器</li><li>Data compression filters //数据压缩过滤器</li><li>Encryption filters //加密过滤器</li><li>Tokenizing filters //分词过滤</li><li>Filters that trigger resource access events //触发资源访问事件过滤</li><li>XSL/T filters that transform XML content</li><li>MIME-type chain filters //MIME-TYPE 链过滤器</li><li>Caching filters //缓存过滤器</li></ul><h2 id="Listener-–-监听器"><a href="#Listener-–-监听器" class="headerlink" title="Listener – 监听器"></a>Listener – 监听器</h2><p>Listener 用于监听 java web程序中的事件，例如创建、修改、删除Session、request、context等，并触发响应的事件。<br>Listener 对应观察者模式，事件发生的时候会自动触发该事件对应的Listeer。 Listener 主要用于对 Session、Request、Context 进行监控。servlet2.5 规范中共有 8 种Listener 。</p><p>不同功能的Listener 需要实现不同的 Listener  接口，一个Listener也可以实现多个接口，这样就可以多种功能的监听器一起工作。监听器接口可以分为三类：</p><ul><li>1）监听 Session、Request、Context 的创建于销毁，分别为  <code>HttpSessionLister</code>、<code>ServletContextListener</code>、<code>ServletRequestListener</code></li><li>2）监听对象属性变化，分别为：<code>HttpSessionAttributeLister</code>、<code>ServletContextAttributeListener</code>、<code>ServletRequestAttributeListener</code></li><li>3）监听Session 内的对象，分别为<code>HttpSessionBindingListener</code> 和 <code>HttpSessionActivationListener</code>。与上面六类不同，这两类 Listener 监听的是Session 内的对象，而非 Session 本身，不需要在 <code>web.xml</code>中配置。</li></ul><h3 id="实现一个Listener"><a href="#实现一个Listener" class="headerlink" title="实现一个Listener"></a>实现一个Listener</h3><p>web.xml的Listener配置： <code>&lt;listener&gt;</code>标签与 <code>&lt;listener-class&gt;</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>servlet.listener.MyListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建 MyListener, 实现监听对Session, Context, Request对象的创建与销毁:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span>, <span class="title">ServletContextListener</span>, <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 session</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">log.info(<span class="string">"新创建一个session, ID为: "</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁 session</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">log.info(<span class="string">"销毁一个session, ID为: "</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 context</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">ServletContext servletContext = sce.getServletContext();</span><br><span class="line">log.info(<span class="string">"即将启动"</span> + servletContext.getContextPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载 context</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">ServletContext servletContext = sce.getServletContext();</span><br><span class="line">log.info(<span class="string">"即将关闭"</span> + servletContext.getContextPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpSession-–-会话"><a href="#HttpSession-–-会话" class="headerlink" title="HttpSession – 会话"></a>HttpSession – 会话</h2><p>会话跟踪机制:</p><ul><li>Cookie: 通过 HTTP cookie 的会话跟踪是最常用的会话跟踪机制，且所有 servlet 容器都应该支持。所有 servlet 容器必须提供能够配置容器是否标记会话跟踪 cookie 为HttpOnly的能力。</li><li>SSL会话: 安全套接字层(Secure Sockets Layer)，在 HTTPS 使用的加密技术，有一种内置机制允许多个来自客户端的请求被明确识别为同一会话。Servlet容器可以很容易地使用该数据来定义会话。</li><li>URL 重写: URL 重写是会话跟踪的最低标准。当客户端不接受 cookie 时，服务器可使用 URL 重写作为会话跟踪的基础。URL 重写涉及添加数据、会话 ID、容器解析 URL 路径从而请求与会话相关联。</li></ul><h2 id="Dispatcher-–-分发器"><a href="#Dispatcher-–-分发器" class="headerlink" title="Dispatcher – 分发器"></a>Dispatcher – 分发器</h2><p>RequestDispatcher 接口负责把请求转发给一个 servlet 处理；<br>当请求启用异步处理时，AsyncContext 允许用户将这个请求转发到servlet 容器。</p><p>可以通过<code>ServletContext.getRequestDispatcher()</code>获取 RequestDispatcher.</p><p>使用请求调度器:</p><ul><li><code>include</code> 方法: include 方法的目标 servlet 能够访问请求对象的各个方法（all aspects），但是使用响应对象的方法会受到更多限制。</li><li><code>forward</code> 方法: RequestDispatcher 接口的 <code>forward()</code> 方法，只有在没有输出提交到向客户端时，通过正在被调用的 servlet 调用。如果响应缓冲区中存在尚未提交的输出数据，这些数据内容必须在目标 servlet 的 <code>service()</code> 方法调用前清除。如果响应已经提交，必须抛出一个 <code>IllegalStateException</code> 异常。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String path = “/raisins.jsp”;</span><br><span class="line">RequestDispatcher rd = context.getRequestDispatcher(path);</span><br><span class="line">rd.include(request, response);</span><br></pre></td></tr></table></figure><h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><p>当容器启动后, 容器会判断内存中是否存在指定的 Servlet对象, 如果没有则创建它, 当容器停止或者重新启动, Servlet容器调用 Servlet对象的 destroy方法来释放资源;<br>Servlet生命周期分几个步骤: Servlet类加载 -&gt; 实例化 -&gt; 服务 -&gt; 销毁:</p><ul><li>Servlet容器 负责加载 Servlet类</li><li>Servlet容器 使用开始实例化 Servlet, 创建对象并调用 init()方法</li><li>响应客户请求阶段调用 service()方法</li><li>销毁阶段调用 destroy()方法</li></ul><h3 id="Request-生命周期"><a href="#Request-生命周期" class="headerlink" title="Request 生命周期"></a>Request 生命周期</h3><p>接收到HTTP请求后, 容器会创建 HttpServletRequest对象, 并传递给 Servlet, 在这次请求结束后, Request对象也被销毁;<br>每个请求对象只在一个 servlet 的 <code>service()</code> 方法的作用域内, 或过滤器的 <code>doFilter()</code> 方法的作用域内有效,<br>除非该组件启用了异步处理并且调用了请求对象的 <code>startAsync()</code> 方法. 在发生异步处理的情况下, 请求对象一直有效, 直到调用 AsyncContext 的 <code>complete()</code> 方法.</p><h2 id="并发-amp-多线程问题"><a href="#并发-amp-多线程问题" class="headerlink" title="并发 &amp; 多线程问题"></a>并发 &amp; 多线程问题</h2><p>因为 Servlet 规范的特点，Servlet 容器（如 Tomcat）一般采用多线程来处理多个请求同时访问，Servlet 容器维护了一个线程池来服务请求。<br>线程池实际上是等待执行代码的一组线程叫做工作者线程(WorkerThread)，Servlet容器使用一个调度线程来管理工作者线程(DispatcherThread)。<br>当容器收到一个访问Servlet的请求，调度者线程从线程池中选出一个工作者线程，将请求传递给该线程，然后由该线程来执行Servlet的<code>service()</code>方法。<br>当这个线程正在执行的时候，容器收到另外一个请求，调度者线程将从池中选出另外一个工作者线程来服务新的请求，容器并不关心这个请求是否访问的是同一个Servlet还是另外一个Servlet。当容器同时收到对同一Servlet的多个请求，那这个Servlet的<code>service()</code>方法将在多线程中并发的执行。</p><p>同步<code>service()</code>的两种方式:</p><ul><li>Servlet实现<code>SingleThreadModel</code>接口: 开发人员实现 SingleThreadModel 接口，由容器保证一个 <code>service()</code> 方法在同一个时间点仅被一个请求线程调用，但是此方案是不推荐的。servlet 容器可以通过串行化访问 servlet的请求，或者维护一个 servlet 实例池完成该需求。如果 Web 应用中的 servlet 被标注为分布式的，容器应该为每一个分布式应用程序的 JVM 维护一个 servlet 实例池。</li><li>synchronized同步<code>service()</code>方法, 不建议使用: 对于那些没有实现 <code>SingleThreadModel</code> 接口的 servlet，但是它的<code>service()</code> 方法（或者是那些 HttpServlet 中通过 service 方法分派的doGet、doPost 等分派方法）是通过 synchronized 关键词定义的，servlet 容器不能使用实例池方案，并且只能使用序列化请求进行处理。强烈推荐开发人员不要去同步 <code>service()</code> 方法（或者那些由 <code>service()</code> 分派的方法），因为这将严重影响性能。</li></ul><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>这就导致了Servlet里的实例变量是线程不安全的,多个线程（多个客户端的请求）共享这些实例变量，一个线程对这些实例变量的改变会影响其它线程的取值，Servlet规范已经声明Servlet不是线程安全的,包括jsp,Servlet,javabean等。</p><blockquote><p>ServletContext：（线程不安全）</p></blockquote><p>ServletContext是可以多线程同时读/写属性的，线程是不安全的。要对属性的读写进行同步处理或者进行深度Clon。所以在Servlet上下文中尽可能少量保存会被修改（写）的数据，可以采取其他方式在多个Servlet中共享，比方我们可以使用单例模式来处理共享数据。</p><blockquote><p>HttpSession：（线程不安全）</p></blockquote><p>HttpSession对象在用户会话期间存在，只能在处理属于同一个Session的请求的线程中被访问，因此Session对象的属性访问理论上是线程安全的。当用户打开多个同属于一个进程的浏览器窗口，在这些窗口的访问属于同一个Session，会出现多次请求，需要多个工作线程来处理请求，可能造成同时多线程读写属性。这时我们需要对属性的读写进行同步处理：使用同步块Synchronized和使用读/写器来解决。</p><blockquote><p>ServletRequest：（线程安全）</p></blockquote><p>对于每一个请求，由一个工作线程来执行，都会创建有一个新的ServletRequest对象，所以ServletRequest对象只能在一个线程中被访问。ServletRequest是线程安全的。ServletRequest对 象在service方法的范围内是有效的，不要试图在service方法结束后仍然保存请求对象的引用。</p><p><a href="http://wenboo.site/2016/11/14/Servlet-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">http://wenboo.site/2016/11/14/Servlet-%E5%B9%B6%E5%8F%91%E5%B0%8F%E7%BB%93/</a></p><h2 id="异步-amp-AsyncContext"><a href="#异步-amp-AsyncContext" class="headerlink" title="异步 &amp; AsyncContext"></a>异步 &amp; AsyncContext</h2><p>@ref <a href="https://www.cnblogs.com/davenkin/p/async-servlet.html" target="_blank" rel="noopener">Servlet 3.0/3.1 中的异步处理</a></p><blockquote><p>在Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求，即每一次Http请求都由某一个线程从头到尾负责处理。如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待IO操作完成， 而IO操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。<br>为了解决这样的问题，Servlet 3.0引入了异步处理，然后在Servlet 3.1中又引入了非阻塞IO来进一步增强异步处理的性能。</p></blockquote><p>在Servlet 3.0中，<code>@WebServlet</code> 和 <code>@WebFilter</code> 注解有一个属性——<code>asyncSupported</code>，boolean 类型默认值为 false。<br>当 <code>asyncSupported</code> 设置为 true，我们可以从HttpServletRequest对象中通过<code>startAsync()</code>获得一个AsyncContext对象，AsyncContext对象构成了异步处理的上下文，Request和Response对象都可从中获取。<br>AsyncContext 可以从当前线程传给另外的线程，并在新的线程中完成对请求的处理并返回结果给客户端，当前请求的线程便可以还回给容器线程池以处理更多的请求。</p><p>一个有较长耗时操作的Servlet可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/simpleAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        asyncContext.start(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过<code>request.startAsync()</code>获取到该请求对应的<code>AsyncContext</code>，然后调用<code>AsyncContext</code>的<code>start()</code>方法进行异步处理，处理完毕后需要调用<code>AsyncContext.complete()</code>方法告知Servlet容器。<br><code>AsyncContext.start()</code>方法会向Servlet容器另外申请一个新的线程（可以是从Servlet容器中已有的主线程池获取，也可以另外维护一个线程池，不同容器实现可能不一样），然后在这个新的线程中继续处理请求，而原先的线程将被回收到主线程池中。<br>事实上，这种方式对性能的改进不大，因为如果新的线程和初始线程共享同一个线程池的话，相当于闲置下了一个线程，但同时又占用了另一个线程。</p><p>这里有一篇文章<a href="https://dzone.com/articles/limited-usefulness" target="_blank" rel="noopener">The Limited Usefulness of AsyncContext.start() - DZone Java</a>,<br>对该方法做了性能测试, 结论如下 :</p><ul><li>Tomcat 的 <code>AsyncContext.start</code> 实现是, 把处理 Request 的线程放入 Http work threadpool 线程池执行</li><li>在 Tomcat中使用 Servlet3.0 的 <code>AsyncContext.start</code> 不会带来任何 Tomcat并发性能改进</li><li>正确的办法是另外维护一个线程池，这个线程池不同于Servlet容器的主线程池（请求线程池），如下图：</li></ul><p><img src="/images/javaee/javaee_servlet_async.png" alt=""></p><p>在上图中，用户发起的请求首先交由Servlet容器主线程池（请求线程池）中的线程处理，在该线程中，我们获取到AsyncContext，然后将其交给异步处理线程池。<br><strong>请求线程</strong>可以被归还回主线程池，这样主线程池用来处理 Http请求的线程没有被长时间占用。<br>但是需要注意的是，这种做法可以及时归还<strong>请求线程</strong>，但在仍旧占用另一个线程，所以 JVM 的线程总数没有减少，系统瓶颈仍旧在 JVM 进程的最大线程数上（单个线程的栈大小默认是 <code>-Xss1M</code>）</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/threadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Requet-和-Response的非阻塞IO"><a href="#Requet-和-Response的非阻塞IO" class="headerlink" title="Requet 和 Response的非阻塞IO"></a>Requet 和 Response的非阻塞IO</h3><p>Servlet 3.0对请求的处理虽然是异步的，但是对<code>InputStream</code>和<code>OutputStream</code>的IO操作却依然是阻塞的，对于数据量大的请求体或者返回体，阻塞IO也将导致不必要的等待。因此在Servlet 3.1中引入了非阻塞IO（参考下图红框内容），通过在<code>HttpServletRequest</code>和<code>HttpServletResponse</code>中分别添加<code>ReadListener</code>和<code>WriterListener</code>方式，只有在IO数据满足一定条件时（比如数据准备好时），才进行后续的操作。</p><p><img src="/images/javaee/javaee_servlet_non_block_io.png" alt=""></p><p>对应的代码示例子:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/nonBlockingThreadPoolAsync"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockingAsyncHelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">200</span>, <span class="number">50000L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        ServletInputStream inputStream = request.getInputStream();</span><br><span class="line">        inputStream.setReadListener(<span class="keyword">new</span> ReadListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataAvailable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAllDataRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">new</span> LongRunningProcess().run();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        asyncContext.getResponse().getWriter().write(<span class="string">"Hello World!"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    asyncContext.complete();</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，我们为<code>ServletInputStream</code>添加了一个<code>ReadListener</code>，并在<code>ReadListener</code>的<code>onAllDataRead()</code>方法中完成了长时处理过程。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>servlet 在处理一个请求时可能抛出 <code>ServletException</code> 或<code>UnavailableException</code> 异常。</p><ul><li><code>ServletException</code> 表示在处理请求时出现了一些错误，容器应该采取适当的措施清理掉这个请求。</li><li><code>UnavailableException</code> 表示 servlet 目前无法处理请求，或者临时性的或者永久性的：<ul><li>如果 <code>UnavailableException</code> 表示的是一个永久性的不可用，servlet 容器必须从服务中移除这个 servlet，调用它的 destroy 方法，并释放servlet 实例。所有被容器拒绝的请求，都会返回一个 <code>SC_NOT_FOUND</code> (404) 响应。</li><li>如果 <code>UnavailableException</code> 表示的是一个临时性的不可用，容器可以选择在临时不可用的这段时间内路由任何请求到 Servlet。所以在这段时间内被容器拒绝的请求，都会返回一个 <code>SC_SERVICE_UNAVAILABLE</code> (503) 响应状态码，且同时会返回一个 Retry-After 头指示此 servlet 什么时候可用。容器可以选择忽略永久性和临时性不可用的区别，并把<code>UnavailableException</code> 视为永久性的，从而 servlet 抛出<code>UnavailableException</code> 后需要把它从服务中移除。</li></ul></li></ul><h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><p>@ref:</p><ul><li><a href="http://docs.oracle.com/javaee/6/api" target="_blank" rel="noopener">JavaTM Platform, Enterprise Edition 6 API Specificatio</a></li><li><a href="https://waylau.gitbooks.io/servlet-3-1-specification" target="_blank" rel="noopener">https://waylau.gitbooks.io/servlet-3-1-specification</a></li></ul><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ol><li>Servlet[I]: 属于<code>javax.servlet</code>包<ul><li><code>init()</code></li><li><code>destroy()</code></li><li><code>service(ServletRequest, ServletResponse)</code></li></ul></li><li>HttpServlet: 属于<code>javax.servlet.http</code>包<ul><li><code>service()</code>: 根据method调用: <code>doHead()</code>, <code>doGet()</code>, <code>doPost()</code> …</li></ul></li><li>DispatcherServlet : 属于<code>org.springframework.web.servlet</code>包<ul><li><code>doService()</code> : 调用了<code>doDispatch()</code></li><li><code>doDispatch()</code> : 从这里调用进<code>@Controller</code>中相关的方法</li></ul></li></ol><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>对应web.xml的<code>&lt;servlet&gt;</code>, ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过<code>ServletConfig.getServletContext</code>方法获得<code>ServletContext</code>对象<br>常用方法:</p><ul><li><code>getServletName</code>：</li><li><code>getServletContext</code>：</li></ul><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>对应web.xml的<code>&lt;context-param&gt;</code>, 容器中部署的每一个web应用都有一个ServletContext接口的实例对象与之关联<br>常用方法:</p><ul><li><code>getInitParameter</code> / <code>getInitParameterNames</code></li><li><code>addFilter</code></li><li><code>addListener</code></li><li><code>addServlet</code></li></ul><p>在任何Servlet实现类中可以使用<code>this.getServletContext</code>获取Context</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ul><li><code>init</code> / <code>destroy</code></li><li><code>doFilter</code></li><li><code>FilterChain</code></li></ul><h3 id="Response"><a href="#Response" class="headerlink" title="Response:"></a>Response:</h3><ol><li>ServletResponse[I]<ul><li><code>getOutputStream()</code> / <code>getWriter()</code></li><li><code>flushBuffer()</code></li></ul></li><li>HttpServletResponse[I]<ul><li><code>addCookie</code></li><li><code>setHeader</code></li></ul></li><li>HttpServletResponseWrapper</li></ol><h3 id="Request"><a href="#Request" class="headerlink" title="Request:"></a>Request:</h3><ol><li>ServletRequest[I]<ul><li><code>getInputStream()</code> / <code>getReader()</code></li><li><code>getParameter</code> / <code>getAttribute</code></li><li><code>startAsync()</code></li></ul></li><li>HttpServletRequest[I]<ul><li><code>getContextPath()</code>, <code>getServletPath()</code>, <code>getPathInfo()</code></li><li><code>getRequestURI()</code> / <code>getRequestURL()</code></li></ul></li><li>HttpServletRequestWrapper</li></ol><h3 id="IO-Stream"><a href="#IO-Stream" class="headerlink" title="IO Stream"></a>IO Stream</h3><ol><li>ServletInputStream:<ul><li><code>readLine</code></li></ul></li><li>ServletOutputStream:<ul><li><code>print</code> / <code>println</code></li></ul></li></ol><h3 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h3><p>RequestDispatcher对象由Servlet容器来创建, 封装一个由路径所标识的服务器资源.<br>在Servlet实现类中获取dispatcher对象: <code>this.getServletContext().getRequestDispatcher(&quot;/api/v2/topic/load&quot;)</code></p><ol><li>获取RequestDispatcher对象<ol><li>ServletRequest的<code>getRequestDispatcher(String  path)</code>方法</li><li>ServletContext的<code>getNamedDispatcher(String  path)</code>和<code>getRequestDispatcher(String  path)</code>方法</li></ol></li><li>RequestDispatcher.forward(ServletRequest, ServletResponse) : 类似php里的inclde, 在返回页面中包括其他资源</li><li>RequestDispatcher.include(ServletRequest, ServletResponse) : 转发</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;/2.html&quot;).include(request, response); // 在当前页面包含2.html</span><br><span class="line">requset.getRequestDisPatcher(&quot;/servlet2&quot;).dispatcher.forward(request, response);  // 转发到servlet2</span><br></pre></td></tr></table></figure><h1 id="JSP（JavaServer-Pages）"><a href="#JSP（JavaServer-Pages）" class="headerlink" title="JSP（JavaServer Pages）"></a>JSP（JavaServer Pages）</h1><h2 id="Servlet-amp-JSP-区别与联系"><a href="#Servlet-amp-JSP-区别与联系" class="headerlink" title="Servlet &amp; JSP 区别与联系"></a>Servlet &amp; JSP 区别与联系</h2><ul><li>Servlet在Java代码中通过HttpServletResponse对象动态输出HTML内容</li><li>JSP在静态HTML内容中嵌入Java代码, Java代码被动态执行后生成HTML内容,</li><li>JSP的本质仍是Servlet, JSP编译之后生成的<code>*.java</code>文件和<code>*.class</code>里有什么?</li><li>Servlet是被Context的类加载器加载的, 所以重写Servlet需要重新部署Context, JSP有自己的加载器, JSP文件在修改之后不需要”重新加载”</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>代码段 <code>&lt;% ... %&gt;</code></li><li><p>声明: <code>&lt;%! ... &gt;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%! int i = 0; %&gt;</span><br><span class="line">&lt;%! int a, b, c; %&gt;</span><br></pre></td></tr></table></figure></li><li><p>表达式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">   今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动作元素"><a href="#动作元素" class="headerlink" title="动作元素"></a>动作元素</h2><ul><li><code>jsp:include</code> :     在页面被请求的时候引入一个文件。</li><li><code>jsp:useBean</code> : 寻找或者实例化一个JavaBean。<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"myName"</span> ... &gt;</span><br><span class="line">   &lt;jsp:setProperty name=<span class="string">"myName"</span> property=<span class="string">"someProperty"</span> .../&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-Web应用&quot;&gt;&lt;a href=&quot;#Java-Web应用&quot; class=&quot;headerlink&quot; title=&quot;Java Web应用&quot;&gt;&lt;/a&gt;Java Web应用&lt;/h1&gt;&lt;p&gt;Java Web 应用是一个 servlets, HTML 页面,类,和其他资源的集合，用于一个在 Web 服务器的完成的应用。Web 应用可以捆绑和运行来自多个供应商的在多个容器。&lt;br&gt;servlet 容器必须强制 Web 应用程序和 ServletContext 之间一对一对应的关系。ServletContext 对象提供了一个 servlet 和它的应用程序视图。&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;可以使用标准的 Java 归档工具把 Web 应用程序打包并签名到一个 Web 存档格式（WAR）文件中。例如，一个关于“issue tracking”的应用程序可以分布在一个称为 issuetrack.war 的归档文件中。&lt;/p&gt;
&lt;p&gt;当打包成这种形式时，将生成一个 META-INF 目录，其中包含了对 java归档工具有用的信息。尽管这个目录的内容可以通过 servlet 代码调用ServletContext 的 getResource 和 getResourceAsStream 方法来访问，容器也不能把这个目录当作内容来响应客户端请求。此外，任何请求访问 META-INF 目录中的资源必须返回一个 SC_NOT_FOUND（404）的响应。常见的归档格式war 和 ear格式对比：&lt;/p&gt;</summary>
    
    
    
    <category term="13.JavaEE" scheme="https://beefyheisenberg.github.io/categories/13-JavaEE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="Servlet" scheme="https://beefyheisenberg.github.io/tags/Servlet/"/>
    
    <category term="JSP" scheme="https://beefyheisenberg.github.io/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>Java JPA &amp; ORM框架</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.ORM&amp;JPA/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.ORM&amp;JPA/</id>
    <published>2023-05-24T10:10:50.199Z</published>
    <updated>2023-05-24T10:10:50.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些概念：JDBC-amp-PJA-amp-ORM"><a href="#一些概念：JDBC-amp-PJA-amp-ORM" class="headerlink" title="一些概念：JDBC &amp; PJA &amp; ORM"></a>一些概念：JDBC &amp; PJA &amp; ORM</h1><p><strong>JDBC</strong> (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。</p><hr><p><strong>JPA</strong> 全称为Java Persistence API ，Java持久化API是Sun公司在Java EE 5规范中提出的Java持久化接口。JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。使用JPA持久化对象，并不是依赖于某一个ORM框架。<br>JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现，JBoss应用服务器底层就以Hibernate作为JPA的实现。<br>虽然 ORM 框架都实现了 JPA 规范，但是在不同 ORM 框架之间切换是需要编写的代码有一些差异，而通过使用 Spring Data Jpa 能够方便大家在不同的 ORM 框架中间进行切换而不要更改代码。并且 Spring Data Jpa 对 Repository 层封装的很好，可以省去不少的麻烦。</p><hr><p><strong>ORM</strong> :对象关系映射（Object Relational Mapping，简称 ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据，将 java 程序中的对象自动持久化到关系数据库中。</p><h1 id="从-JDBC-到-ORM"><a href="#从-JDBC-到-ORM" class="headerlink" title="从 JDBC 到 ORM"></a>从 JDBC 到 ORM</h1><p>JDBC 规范对与数据库的交互做了如下抽象：用 Connection 代表和数据库的连接，用 Statement 执行 SQL，用 ResultSet 表示 SQL 返回的结果，提供了对数据的遍历。从 Connection 可以创建 Statement，Statement 执行查询得到 ResultSet。</p><p>Connection、Statement、ResultSet 都是接口，具体实现由各个数据库提供商提供。可以通过 JDBC统一的接口，访问多种类型的数据库，可随便切换数据库。</p><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//1. 加载驱动</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取连接</span></span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/dropnotes?serverTimezone=UTC"</span>, <span class="string">"user"</span>, <span class="string">"pwd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 创建 PreparedStatement</span></span><br><span class="line">    ps = conn.prepareStatement(<span class="string">"select * from notes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行sql</span></span><br><span class="line">    rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 遍历结果集</span></span><br><span class="line">    <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">        System.out.println(rs.getString(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">        ps.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDBC1 提供了 DriverManager 用于加载数据库驱动 &amp; 获取 connection ，但这种方式显然不方便，需要自己管理 connection ，频繁建立 &amp; 释放 connection 性能也不高。</p><blockquote><p>DriverManager 中使用了 SPI 模式来加载数据库 Driver Jar 包 @ref：<a href="https://pdai.tech/md/java/advanced/java-advanced-spi.html#spi%E6%9C%BA%E5%88%B6-jdbc-drivermanager" target="_blank" rel="noopener">Java常用机制 - SPI机制详解 | Java 全栈知识体系</a></p></blockquote><p>在 JDBC2 中支持了 DataSource 的方式，DataSource 包含连接池和连接池管理2个部分，习惯上称为  #数据库连接池 。在初始化的时候，建立一些 connection 对象并存储在缓存中，当需要访问数据库时，从连接池中取出一个已建立的空闲 connection 对象。</p><p>DataSource 也只是一个规范，具体的实现有 dbcp、c3p0、druid ，使用 c3p0 连接池的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test?serverTimezone=UTC"</span>);</span><br><span class="line">        dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        dataSource.setInitialPoolSize(<span class="number">3</span>);</span><br><span class="line">        dataSource.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        dataSource.setMinPoolSize(<span class="number">3</span>);</span><br><span class="line">        dataSource.setAcquireIncrement(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PropertyVetoException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    dataSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = dataSource.getConnection();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了连接池后，无需手动管理 connection 释放，方便了很多，但此时还是需要手动写 Statement 和 ResultSet 的代码。</p><p>这时候就需要使用 ORM（对象关系映射），主要解决数据库数据和 POJO 对象的相互映射，就不需要手动写 SQL 了</p><h1 id="选型对比"><a href="#选型对比" class="headerlink" title="选型对比"></a>选型对比</h1><h2 id="Spring-JPA-MyBatis"><a href="#Spring-JPA-MyBatis" class="headerlink" title="Spring JPA - MyBatis"></a>Spring JPA - MyBatis</h2><p><strong>Spring Data JPA or Mybatis</strong>?</p><p>Jpa（Java Persistence API）是 sun 官方提出的 java 持久化规范。它为 java 开发人员提供了一种对象/关联映射工具，来管理 java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 hibernate、<a href="https://www.zhihu.com/search?q=toplink&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2525463657%7D" target="_blank" rel="noopener">toplink</a>、jdo 等 ORM 框架各自为营的局面。</p><p>值得注意的是，Jpa 是在充分吸收了现有 ORM 框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，Jpa 受到了极大的支持和赞扬，其中就包括了 spring 和 EJB 的开发团队。</p><ul><li><p>Spring Data Jpa 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展</p></li><li><p>MyBatis 本是 apache 的一个开源项目 iBatis, 2010年这个项目由 apache software foundation 迁移到了 google code，并且改名为 MyBatis 。Mybatis：着力于 POJO 与 SQL 之间的映射关系</p></li></ul><p>Spring Data JPA 默认使用 hibernate 作为 ORM。我们再看看 hibernate 的官方概念，Hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 orm 框架，hibernate 可以自动生成 SQL 语句</p><p>@ref: <a href="https://www.zhihu.com/question/316458408" target="_blank" rel="noopener">SpringBoot开发使用Mybatis还是Spring Data JPA?? - 知乎</a></p><hr><p>使用 Spring Data Jpa 仅需要定义接口，并继承 JpaRepository 接口，不需要编写实现类，也不需要编写 XML 映射文件。Spring Data Jpa 默认提供简单的 CRUD 方法，并支持自动根据方法名生成 SQL，提供注解方式动态生成 SQL，也支持分页、排序。</p><p>个人更喜欢在分布式微服务项目中使用 Spring Data Jpa，特别是使用领域驱动设计架构设计的项目，而在管理后台项目使用 Mybatis。</p><p>因为管理后台需要更灵活的查询支持，经常写些复杂的 SQL，在这方面 Jpa 显得较弱势，而分布式微服务项目实现业务的核心逻辑，只需要用到简单的数据查询、删增改，因此较适合使用 Jpa。</p><p>@ref: <a href="https://juejin.cn/post/6932485961532063752" target="_blank" rel="noopener">Mybatis与Spring Data Jpa怎么选？ - 掘金</a></p><h2 id="Hibernate-MyBatis"><a href="#Hibernate-MyBatis" class="headerlink" title="Hibernate - MyBatis"></a>Hibernate - MyBatis</h2><p>Hibernate 和 Mybatis 都是 <strong>ORM 持久层框架</strong>，</p><p>Hibernate 提供的是一种全表映射的模型，对 JDBC 的封装程度比较高。但 Hibernate 也有不少缺点：</p><ul><li>全表映射带来的不便，比如更新时需要发送所有的字段；</li><li>无法根据不同的条件组装不同的SQL；</li><li>对多表关联和复杂SQL查询支持较差，需要自己写SQL，返回后，需要自己将数据组装为POJO；</li><li>不能有效支持存储过程；</li><li>虽然有HQL，但性能较差，大型互联网系统往往需要优化SQL，而Hibernate做不到。</li></ul><p>大型互联网环境中，灵活、SQL 优化，减少数据的传递是最基本的优化方法，Hibernate 无法满足要求，而 MyBatis 是一个半自动映射的框架，提供了更灵活、方便的方式。</p><p>MyBatis需要手工匹配提供POJO、SQL和映射关系，而全表映射的Hibernate只需要提供POJO和映射关系。</p><h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>在 Spring 项目中引入 MyBatis 支持 @link <a href="/13.JavaEE-Framework/JavaEE.SpringMVC/" title="JavaEE.SpringMVC">JavaEE.SpringMVC</a><br>主要是定义 SqlSessionFactory、DataSource 和 Mapper。</p><p>Mybatis 四大核心类：</p><ul><li>SqlSessionFactoryBuilder：会根据配置信息或代码来生成 SqlSessionFactory；</li><li>SqlSessionFactory：依靠工厂来生成SqlSession；</li><li>SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口；</li><li>SQL Mapper：是MyBatis新设计的组件，由一个Java接口和XML文件构成，需要给出对应的SQL和映射规则。它负责发送SQL去执行，并返回结果。</li></ul><ul><li><a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">MyBatis 3 | 入门</a></li><li><a href="https://gitbook.cn/books/5a37b6b66eec7c4f044a75d0/index.html" target="_blank" rel="noopener">通过源码深入理解 SQL 的执行过程</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">MyBatis的架构设计以及实例分析</a></li></ul><h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><ul><li><a href="https://www.w3cschool.cn/hibernate/" target="_blank" rel="noopener">Hibernate 教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一些概念：JDBC-amp-PJA-amp-ORM&quot;&gt;&lt;a href=&quot;#一些概念：JDBC-amp-PJA-amp-ORM&quot; class=&quot;headerlink&quot; title=&quot;一些概念：JDBC &amp;amp; PJA &amp;amp; ORM&quot;&gt;&lt;/a&gt;一些概念：JDBC &amp;amp; PJA &amp;amp; ORM&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;JDBC&lt;/strong&gt; (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;JPA&lt;/strong&gt; 全称为Java Persistence API ，Java持久化API是Sun公司在Java EE 5规范中提出的Java持久化接口。JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。使用JPA持久化对象，并不是依赖于某一个ORM框架。&lt;br&gt;JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现，JBoss应用服务器底层就以Hibernate作为JPA的实现。&lt;br&gt;虽然 ORM 框架都实现了 JPA 规范，但是在不同 ORM 框架之间切换是需要编写的代码有一些差异，而通过使用 Spring Data Jpa 能够方便大家在不同的 ORM 框架中间进行切换而不要更改代码。并且 Spring Data Jpa 对 Repository 层封装的很好，可以省去不少的麻烦。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="13.JavaEE" scheme="https://beefyheisenberg.github.io/categories/13-JavaEE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="ORM" scheme="https://beefyheisenberg.github.io/tags/ORM/"/>
    
    <category term="MyBatis" scheme="https://beefyheisenberg.github.io/tags/MyBatis/"/>
    
    <category term="Hibernate" scheme="https://beefyheisenberg.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Java日志框架（JCL,SLF4J,Log4J,Logback）</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Log/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.Log/</id>
    <published>2023-05-24T10:10:50.194Z</published>
    <updated>2023-05-24T10:10:50.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志框架简介"><a href="#日志框架简介" class="headerlink" title="日志框架简介"></a>日志框架简介</h1><ul><li><code>Commons Logging</code>和<code>SLF4J</code>是java中的 <strong>日志门面(Facade)</strong>，即它们提供了一套通用的接口，具体的实现可以由开发者自由选择。</li><li><code>Log4j</code>（以及最新的log4j 2）和<code>Logback</code>则是具体的 <strong>日志实现</strong> 方案。它们可以理解为接口与实现类的关系</li><li>四个框架都可以在程序中使用，但是为了考虑扩展性，一般我们在程序开发的时候，会选择使用 Commons Logging 或者 SLF4J 这些日志门面，而不是直接使用 log4j 或者 Logback 这些实现。即我们写代码的时候导入的类一般都是来自门面框架中的类，然后将某个日志的实现框架加入到项目中，提供真正的日志输出功能。<br>如果项目依赖多个库，这些库又使用了不同的日志门面，这种情况可以方便的通过 Adapter 转接到同一个日志实现上；</li><li>比较常用的搭配是:<ol><li>commons-logging + log4j，这是一种比较老但稳妥的组合, 缺点是commons-logging不支持占位符;</li><li>slf4j + logback，slf4j支持占位符, logback性能优于log4j;</li></ol></li></ul><h1 id="日志门面（SLF4J，Commons-Loggings）"><a href="#日志门面（SLF4J，Commons-Loggings）" class="headerlink" title="日志门面（SLF4J，Commons-Loggings）"></a>日志门面（SLF4J，Commons-Loggings）</h1><h2 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h2><p>SLF4J全称为<code>Simple Logging Facade for JAVA</code>，Java简单日志门面。<br>类似于Commons Logging，是对不同日志框架提供的一个门面封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。</p><h3 id="Adapter-amp-Bridge"><a href="#Adapter-amp-Bridge" class="headerlink" title="Adapter &amp; Bridge"></a>Adapter &amp; Bridge</h3><p>SLF4J在编译时静态绑定真正的Log库。下图介绍了SLF4J如何绑定具体的日志实现的:</p><p><img src="/images/javaee/javaee_log_slf4j.png" alt=""></p><p>对于application层，具体的日志框架对我们都是透明的，我们只针对slf4j-api编程。应用程序调用slf4j-api，而日志的输出最终是由底层的日志实现（Log4j、Logback）来负责的。<br>上图也说明了具体日志实现（Log4j、Logback）的不同：</p><ul><li>Logback是基于slf4j接口编写的，所以中间不需要适配：<code>SLF4J</code> -&gt; <code>Logback</code></li><li>SLF4J+Log4j的方式就需要适配层：<code>SLF4J</code> -&gt; <code>slf4j-log4j12</code> -&gt; <code>Log4j</code></li></ul><p>SLF4J是如何绑定具体日志实现，参考：<br><a href="http://skyao.github.io/2014/07/21/slfj4-binding/" target="_blank" rel="noopener">slf4j初始化绑定源码分析 | Sky’s Blog</a> @ref</p><p><strong>混乱的开始</strong>：</p><p>SLF4J的开发者提供了各种 Adapter 和 Bridge 来适配各种 Log Implementation 和 Log Facade，使用JCL作为日志门面的旧项目也可以接入SLF4J。<br>甚至可以有:  Facade1 -&gt; Implementation1 -&gt; Bridge -&gt; Facade2 -&gt; Implementation2这种复杂的桥接方式.<br>比如程序中以前使用的日志门面是commong-logging，那么你可以通过引入jcl-over-slf4j包来讲日志重定向到slf4j。<br><img src="/images/javaee/J2EE-Log-SLF4J-Adapter.png" alt=""></p><p>上图中红色的是 Log Facade， 蓝色的是 Log Implementation ，所以有了以下几种可能的复杂桥接方案:</p><ul><li><code>JCL</code>(Commons Logging) -&gt; <code>jcl-over-slf4j</code> -&gt; <code>SLF4J</code> -&gt; <code>Logback</code></li><li><code>Log4j</code> -&gt; <code>log4j-over-slf4j</code> -&gt; <code>SLF4J</code> -&gt; <code>Logback</code></li></ul><blockquote><p>从上面可以看出, <code>SLF4J</code> -&gt; <code>Logback</code>是最简单的方案,  <code>SLF4J</code>想使用 <code>Log4j</code>就需要桥接包</p></blockquote><h3 id="日志占位符"><a href="#日志占位符" class="headerlink" title="日志占位符"></a>日志占位符</h3><p>SLF4J提供了更好的日志记录方式，支持占位符的方式打印日志。比如：<br><code>logger.debug(&quot;Processing trade with id: {} and symbol : {} &quot;, id, symbol);</code></p><p>而不是使用JCL的<code>+</code>的方式：<br><code>logger.debug(&quot;start process request, url:&quot; + url);</code><br>直接使用 <code>+</code> 拼接字符串有什么问题呢？一般生产环境 log 级别都会设到 info 或者以上，那这条 log 是不会被输出的。<br>然而不管是否输出，上面的代码都会做一个字符串连接操作，然后生产一个新的字符串。<br>如果这条语句在循环或者被调用很多次的函数中，就会多做很多无用的字符串连接，影响性能。</p><p>所以 JCL 的最佳实践推荐这么写：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(&quot;start process request, url:&quot; + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而开发者常常忽略这个问题或是觉得麻烦而不愿意这么写。所以SLF4J提供的占位符<code>{}</code>方式更加方便。</p><h3 id="SLF4J-Logback（推荐）"><a href="#SLF4J-Logback（推荐）" class="headerlink" title="SLF4J + Logback（推荐）"></a>SLF4J + Logback（推荐）</h3><p>SLF4J是编译时绑定到具体的日志框架，性能优于采用运行时搜寻的方式的commons-logging<br>SLF4J提供了更好的日志记录方式，带来下这几方面的好处：</p><p>更好的可读性；</p><p>不需要使用<code>logger.isDebugEnabled()</code>来解决日志因为字符拼接产生的性能问题。比如：<br><code>logger.debug(“Processing trade with id: {} and symbol : {} “, id, symbol);</code><br>logback支持了更方便的自定义日志，便于后期的日志分析，可以将日志格式化保存到各种存储引擎中，请点击这里 可以将日志写入到HBase等。但是SLF4J不支持FATAL级别</p><p>使用slf4j + logback步骤:</p><ul><li>添加slf4j + logback的Jar包依赖;<ul><li>去掉commons-loggings和log4j的依赖, 用<code>mvn dependency:tree</code>查看依赖, 并用<code>&lt;exclusions&gt;</code>去掉Jar依赖;</li><li>去掉重复引入的logback相关Jar, 比如我们使用slf4j + logback的方案，只需要引入<code>logback-classic</code>即可，不必再显示添加<code>slf4j-api</code>和<code>logback-core</code>，因为logback-classic本身依赖它们。</li></ul></li><li>slf4j 配置文件: 无</li><li>logback 配置文件: logback.xml</li><li>Java代码:  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(A.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">            logger.debug(<span class="string">"slf4j-logback debug message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(logger.isInfoEnabled())&#123;</span><br><span class="line">            logger.info(<span class="string">"slf4j-logback info message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(logger.isTraceEnabled())&#123;</span><br><span class="line">            logger.trace(<span class="string">"slf4j-logback trace message"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>@ref: <a href="https://www.jianshu.com/p/696444e1a352" target="_blank" rel="noopener">slf4j+logback的配置及使用 - 简书</a></p></blockquote><h2 id="Commons-Logging（JCL）"><a href="#Commons-Logging（JCL）" class="headerlink" title="Commons Logging（JCL）"></a>Commons Logging（JCL）</h2><p>Commons Logging是一个通用的日志接口。在有些地方会看到简写为JCL（Jakarta Commons Logging）。</p><blockquote><p>commons-logging是Apache commons类库中的一员。Apache commons类库是一个通用的类库，提供了基础的功能，比如说commons-fileupload，commons-httpclient，commons-io，commons-codes等。</p></blockquote><p>common-logging通过动态查找的机制，在程序运行时自动找出真正使用的日志库。<br>用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的logging， Commons Logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。<br>所以使用Commons Logging，通常都是配合着log4j来使用。使用它的好处就是，代码依赖是Commons Logging而非log4j， 避免了和具体的日志方案直接耦合，在有必要时，可以更改日志实现的第三方库。</p><p>工作原理：</p><ol><li>查找名为org.apache.commons.logging.Log的factory属性配置（可以是java代码配置，也可以是commons-logging.properties配置）；</li><li>查找名为org.apache.commons.logging.Log的系统属性；</li><li>上述配置不存在则classpath下是否有Log4j日志系统，如有则使用相应的包装类；</li><li>如果系统运行在JDK 1.4系统上，则使用Jdk14Logger；</li><li>上述都没有则使用SimpleLog。</li></ol><p>所以如果使用commons-logging＋log4j的组合只需要在classpath中加入log4j.xml配置即可。commons-logging的动态查找过程是在程序运行时自动完成的。他使用ClassLoader来寻找和载入底层日志库，所以像OSGI这样的框架无法正常工作，因为OSGI的不同插件使用自己的ClassLoader。</p><h3 id="Commons-Logging-Log4j"><a href="#Commons-Logging-Log4j" class="headerlink" title="Commons-Logging + Log4j"></a>Commons-Logging + Log4j</h3><blockquote><p>日志门面为Commons-Logging（JCL），实现类为log4j。Commons-Logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。只要应用系统引入了log4j.jar包 并在classpath 配置了log4j.xml ，则Commons-Logging 就会使log4j 使用正常，而代码里不需要依赖任何log4j 的代码。</p></blockquote><p>使用commons-logging + log4j的步骤:</p><ul><li>添加Jar包依赖;</li><li><p>commons-logging 配置文件: 默认的，common-logging会自动检查是否使用log4j，也可以使用配置文件显示的启用log4j。配置文件为<code>commons-logging.properties</code>,放在classpath下;</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4J-Logger</span><br><span class="line">org.apache.commons.logging.LogFactory=org.apache.commons.logging.impl.LogFactoryImpl</span><br></pre></td></tr></table></figure></li><li><p>log4j 配置文件: <code>log4j.properties</code>:</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG,console</span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%-d&#123;yyyy-MM-dd HH:mm:ss&#125;]-[%t-%5p]-[%C-%M(%L)]： %m%n</span><br></pre></td></tr></table></figure></li><li><p>Java代码:</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"Debug info: "</span> + args.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考: <a href="https://svn.apache.org/repos/asf/commons/proper/logging/tags/STRUTS_1_1_B3/usersguide.html" target="_blank" rel="noopener">Jakarta Commons Logging Users Guide</a> @ref</p><h1 id="日志实现（Log4J，LogBack，JUL）"><a href="#日志实现（Log4J，LogBack，JUL）" class="headerlink" title="日志实现（Log4J，LogBack，JUL）"></a>日志实现（Log4J，LogBack，JUL）</h1><p>主流的日志实现有 log4j（还有升级版log4j2）和logback, 实现了将日志输出到具体的介质, 比如文件/Tcp/Scribe等.<br>此外还有<code>java.util.logging</code>（JUL）</p><ul><li>log4j的默认配置文件是 log4j.properties;</li><li>logback的默认配置文件是 logback.xml;</li></ul><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><p>Log4j是Apache的一个开放源代码项目，经典的一种日志解决方案。内部把日志系统抽象封装成Logger 、appender 、pattern等实现。<br>我们可以通过配置文件轻松的实现日志系统的管理和多样化配置。<br>通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；用户也可以控制每一条日志的输出格式；<br>通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。这些可以通过一个 配置文件来灵活地进行配置，而不需要修改程序代码。</p><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><p>配置文件加载顺序:</p><ul><li>log4j.xml</li><li>log4j.properites</li></ul><p>所以把log4j.xml或log4j.properties放在这些目录下，那么log4j会“自动去加载”到，不用程序里手工写加载代码了。这也就“约定大于配置的好处”。</p><h3 id="配置文件-log4j-properties"><a href="#配置文件-log4j-properties" class="headerlink" title="配置文件 log4j.properties"></a>配置文件 log4j.properties</h3><p>配置文件log4j.properties 结构&amp;层级如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger</span><br><span class="line">    appender</span><br><span class="line">        layout</span><br></pre></td></tr></table></figure><ul><li>Loggers(记录器)：记录日志的工具，程序中就是用它来记录我们想要的日志信息。</li><li>Appenders (输出源)：日志输出到什么地方，可以是控制台、文件、流位置、数据库，等等。</li><li>Layouts(布局模式)：日志需要记录哪些基本信息，用什么样的格式去记录展示这些信息。</li><li>一个 Logger 最少要有一个 Appender，一个 Appender 有一个 Layout。</li></ul><p>log4j.properties 示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO,A1               // 定义logger方式1: 定义根logger名=rootLogger, level=INFO, 使用名为A1的appender</span><br><span class="line">log4j.logger.loggerName1=DEBUG,A2      // 定义logger方式2: logger名=loggerName1, 使用名为A2的appender</span><br><span class="line">log4j.logger.org.apache = DEBUG, A3   // 定义logger方式3: 对org.apache下的类有效, 使用名为A3的appender</span><br><span class="line"></span><br><span class="line">// 定义A1 appender的属性</span><br><span class="line">log4j.appender.A1=org.apache.log4j.DailyRollingFileAppender // 可选ConsoleAppender, RollingFileAppender ..</span><br><span class="line">log4j.appender.A1.BufferedIO=false</span><br><span class="line">log4j.appender.A1.BufferSize=1024</span><br><span class="line">log4j.appender.A1.file=../logs/api.log // 日志文件位置</span><br><span class="line">log4j.appender.A1.DatePattern=&apos;.&apos;yyyyMMddHH</span><br><span class="line">log4j.appender.A1.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH\:mm\:ss SSS&#125; [%p] %m%n // 日志格式</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rootLogger方法:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger rootLogger = Logger.getRootLogger();</span><br><span class="line">    <span class="comment">// 从logger名字获取:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = Logger.getLogger(<span class="string">"loggerName1"</span>);</span><br><span class="line">    <span class="comment">// 从class获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log2 = Logger.getLogger(Test.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><ul><li><p>设置日志缓存，以及缓存大小</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.appender.A3.BufferedIO=true</span><br><span class="line">#Buffer单位为字节，默认是8K，IO BLOCK大小默认也是8K</span><br><span class="line">log4j.appender.A3.BufferSize=8192</span><br></pre></td></tr></table></figure></li><li><p>设置日志输出为异步方式 (异步输出必须使用xml方式配置才能支持)</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;appender name=&quot;DAILY_FILE&quot; class=&quot;org.apache.log4j.DailyRollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">    &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c %x - %m%n&quot;/&gt;</span><br><span class="line">    &lt;/layout&gt;</span><br><span class="line">    &lt;param name=&quot;File&quot; value=&quot;log/log4j.log&quot;/&gt;</span><br><span class="line">    &lt;param name=&quot;DatePattern&quot; value=&quot;&apos;.&apos;yyyy-MM-dd&quot;/&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">&lt;appender name=&quot;ASYNC_FILE&quot; class=&quot;org.apache.log4j.AsyncAppender&quot;&gt;</span><br><span class="line">    &lt;param name=&quot;BufferSize&quot; value=&quot;10000&quot;/&gt;</span><br><span class="line">    &lt;param name=&quot;Blocking&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;DAILY_FILE&quot;/&gt;</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure></li></ul><p>Log4j的AsyncAppender存在的问题:</p><blockquote><p>Log4j的异步appender也就是AsyncAppender存在性能问题（现在Log4j 2.0 RC提供了一种新的异步写log的机制(基于disruptor)来试图解决问题），<br>异步写log有一个buffer的设置，也就是当队列中多少个日志的时候就flush到文件或数据库，<br>当配置为blocking=true的时候，如果应用写日志很快，log4j的缓冲队列将很快被占满，写日志会被阻塞</p></blockquote><h2 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h2><p>Logback也是一种日志实现。Logback是由log4j创始人设计的又一个开源日记组件。<br>Logback当前分成三个模块：Logback-core,Logback- classic和Logback-access。Logback-core是其它两个模块的基础模块。Logback-classic是log4j的一个 改良版本。<br>此外Logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging。<br>Logback-access访问模块与Servlet容器集成提供通过Http来访问日记的功能。</p><p>LogBack 作为一个通用可靠、快速灵活的日志框架，将作为Log4j 的替代和SLF4J 组成新的日志系统的完整实现。官网上称具有极佳的性能，在关键路径上执行速度是log4j 的10 倍，且内存消耗更少。比如判定是否记录一条日志语句的操作，其性能得到了显著的提高。这个操作在LogBack中需要3纳秒，而在Log4J中则需要30纳秒。 LogBack创建记录器（logger）的速度也更快：13微秒，而在Log4J中需要23微秒。更重要的是，它获取已存在的记录器只需94纳秒，而 Log4J需要2234纳秒，时间减少到了1/23。”。</p><p>官方文档对logback的描述</p><blockquote><p>NATIVE IMPLEMENTATION There are also SLF4J bindings external to the SLF4J project, e.g. logback which implements SLF4J natively. Logback’s ch.qos.logback.classic.Logger class is a direct implementation of SLF4J’s org.slf4j.Logger interface. Thus, using SLF4J in conjunction with logback involves strictly zero memory and computational overhead.</p></blockquote><p>可以看到logback是直接实现了slf4j的接口，是不消耗内存和计算开销的。而log4j不是对slf4j的原生实现，所以slf4j api在调用log4j时需要一个适配层。</p><h3 id="Quick-Start-1"><a href="#Quick-Start-1" class="headerlink" title="Quick Start"></a>Quick Start</h3><p>@todo</p><h3 id="配置文件-logback-xml"><a href="#配置文件-logback-xml" class="headerlink" title="配置文件 logback.xml"></a>配置文件 logback.xml</h3><p>logback在启动时，根据以下步骤寻找配置文件：</p><ul><li>①在classpath中寻找logback-test.xml文件</li><li>②如果找不到logback-test.xml，则在 classpath中寻找logback.groovy文件</li><li>③如果找不到 logback.groovy，则在classpath中寻找logback.xml文件</li></ul><p>如果上述的文件都找不到，则logback会使用JDK的SPI机制查找 <code>META-INF/services/ch.qos.logback.classic.spi.Configurator</code>中的 logback 配置实现类，这个实现类必须实现Configuration接口，使用它的实现来进行配置。<br>如果上述操作都不成功，logback 就会使用它自带的 BasicConfigurator 来配置，并将日志输出到console。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!--scan:</span></span><br><span class="line"><span class="comment">            当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</span></span><br><span class="line"><span class="comment">scanPeriod:</span></span><br><span class="line"><span class="comment">            设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</span></span><br><span class="line"><span class="comment">de<span class="doctag">bug:</span></span></span><br><span class="line"><span class="comment">            当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">configuration 子节点为 appender、logger、root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于区分不同应用程序的记录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>edu-cloud<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志文件所在目录，如果是tomcat，如下写法日志文件会在则为$&#123;TOMCAT_HOME&#125;/bin/logs/目录下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"logs"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger输出日志的logger名 %msg：日志消息，%n是换行符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--解决乱码问题--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--滚动文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoFile"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ThresholdFilter:临界值过滤器，过滤掉 TRACE 和 DEBUG 级别的日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/log.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span><span class="comment">&lt;!--保存最近30天的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里如果是info，spring、mybatis等框架则不会输出：TRACE &lt; DEBUG &lt; INFO &lt;  WARN &lt; ERROR--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--root是所有logger的祖先，均继承root，如果某一个自定义的logger没有指定level，就会寻找</span></span><br><span class="line"><span class="comment">    父logger看有没有指定级别，直到找到root。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoFile"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"errorFile"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"logstash"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JUL"><a href="#JUL" class="headerlink" title="JUL"></a>JUL</h2><p>java.util.logging 是 java自带的日志处理系统, 配置文件一般是logging.properties,</p><p><code>java.util.logging.LogManager</code> 负责读取配置, LogManager 还可以根据两个系统属性来允许用户控制日志的配置：</p><ul><li>“-Djava.util.logging.config.class=YourClass”</li><li>“-Djava.util.logging.config.file=logging.properties”</li></ul><h3 id="logging-properties"><a href="#logging-properties" class="headerlink" title="logging.properties"></a>logging.properties</h3><p>和Tomcat的配置格式类似:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handlers=java.util.logging.FileHandler,java.util.logging.ConsoleHandler,</span><br><span class="line">java.util.logging.ConsoleHandler.level=WARNING</span><br><span class="line">java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter</span><br><span class="line"></span><br><span class="line">java.util.logging.FileHandler.level=INFO</span><br><span class="line">java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter</span><br><span class="line">java.util.logging.FileHandler.limit=1024000</span><br><span class="line">java.util.logging.FileHandler.count=10</span><br><span class="line">java.util.logging.FileHandler.pattern=/data1/logs/log.%d&#123;yyyyMMddHH&#125;</span><br><span class="line">java.util.logging.FileHandler.append=true</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>如果你的项目是一个库，需要提供给给别的项目使用，那么建议使用 Log Facade，而不使用具体的 Log Implementation。<br>如果一定要使用 Log Implementation，<br>那么建议你的项目里对 Log Implementation 的依赖设置为<code>&lt;scope&gt;runtime&lt;/scope&gt;</code> 并且<code>&lt;optional&gt;true&lt;/optional&gt;</code>, 设为optional，依赖不会传递；</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是一个独立的项目(比如Web项目)，<br>那么不要单独使用 Log Impementation，而应该跟 Log Facade一起使用。</p><p><strong>如果有必要, 排除依赖的第三方库中的 Log Impementation依赖</strong></p><p>这是很常见的一个问题，第三方库的开发者未必会把具体的 <em>Log Implementation</em> 或者桥接器的依赖设置为optional，然后你的项目会继承这些 <em>Log Implementation</em> 的库，<br>—— 但这未必是你想使用的，比如第三方库依赖了Log4j，但你自己的项目使用的是Logback。<br>另外，如果不同的第三方依赖使用了不同的桥接器和 <em>Log Implementation</em> ，也极容易形成依赖环。项目里就需要针对每个 <em>Log Implementation</em> 库都都写一个配置文件。<br>这种情况下推荐的处理方法，使用exclude来排除所有的这些 <em>Log Implementation</em> 和桥接器的依赖，只保留第三方库里面对 <em>Log Facade</em> 的依赖。</p><p>@ref:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/24272450" target="_blank" rel="noopener">Java 日志框架解析(上) - 历史演进 - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/24275518" target="_blank" rel="noopener">Java 日志框架解析(下) - 最佳实践 - 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;日志框架简介&quot;&gt;&lt;a href=&quot;#日志框架简介&quot; class=&quot;headerlink&quot; title=&quot;日志框架简介&quot;&gt;&lt;/a&gt;日志框架简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Commons Logging&lt;/code&gt;和&lt;code&gt;SLF4J&lt;/code&gt;是java中的 &lt;strong&gt;日志门面(Facade)&lt;/strong&gt;，即它们提供了一套通用的接口，具体的实现可以由开发者自由选择。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Log4j&lt;/code&gt;（以及最新的log4j 2）和&lt;code&gt;Logback&lt;/code&gt;则是具体的 &lt;strong&gt;日志实现&lt;/strong&gt; 方案。它们可以理解为接口与实现类的关系&lt;/li&gt;
&lt;li&gt;四个框架都可以在程序中使用，但是为了考虑扩展性，一般我们在程序开发的时候，会选择使用 Commons Logging 或者 SLF4J 这些日志门面，而不是直接使用 log4j 或者 Logback 这些实现。即我们写代码的时候导入的类一般都是来自门面框架中的类，然后将某个日志的实现框架加入到项目中，提供真正的日志输出功能。&lt;br&gt;如果项目依赖多个库，这些库又使用了不同的日志门面，这种情况可以方便的通过 Adapter 转接到同一个日志实现上；&lt;/li&gt;
&lt;li&gt;比较常用的搭配是:&lt;ol&gt;
&lt;li&gt;commons-logging + log4j，这是一种比较老但稳妥的组合, 缺点是commons-logging不支持占位符;&lt;/li&gt;
&lt;li&gt;slf4j + logback，slf4j支持占位符, logback性能优于log4j;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;日志门面（SLF4J，Commons-Loggings）&quot;&gt;&lt;a href=&quot;#日志门面（SLF4J，Commons-Loggings）&quot; class=&quot;headerlink&quot; title=&quot;日志门面（SLF4J，Commons-Loggings）&quot;&gt;&lt;/a&gt;日志门面（SLF4J，Commons-Loggings）&lt;/h1&gt;&lt;h2 id=&quot;SLF4J&quot;&gt;&lt;a href=&quot;#SLF4J&quot; class=&quot;headerlink&quot; title=&quot;SLF4J&quot;&gt;&lt;/a&gt;SLF4J&lt;/h2&gt;&lt;p&gt;SLF4J全称为&lt;code&gt;Simple Logging Facade for JAVA&lt;/code&gt;，Java简单日志门面。&lt;br&gt;类似于Commons Logging，是对不同日志框架提供的一个门面封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。&lt;/p&gt;</summary>
    
    
    
    <category term="13.JavaEE" scheme="https://beefyheisenberg.github.io/categories/13-JavaEE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="JCL" scheme="https://beefyheisenberg.github.io/tags/JCL/"/>
    
    <category term="SLF4J" scheme="https://beefyheisenberg.github.io/tags/SLF4J/"/>
    
    <category term="Log4J" scheme="https://beefyheisenberg.github.io/tags/Log4J/"/>
    
    <category term="Logback" scheme="https://beefyheisenberg.github.io/tags/Logback/"/>
    
    <category term="日志" scheme="https://beefyheisenberg.github.io/tags/日志/"/>
    
  </entry>
  
  <entry>
    <title>Java EE 技术标准（JTS,JMS,JMX,JTA,JPA,EJB,JNDI,JDBC）</title>
    <link href="https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.01.%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/"/>
    <id>https://beefyheisenberg.github.io/13.JavaEE-Framework/JavaEE.01.%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/</id>
    <published>2023-05-24T10:10:50.188Z</published>
    <updated>2023-05-24T10:10:50.188Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/javaee/JavaEE-Title.png" alt=""></p><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><p>Java平台共分为三个主要版本：Java SE、Java EE 和 Java ME。</p><ul><li>Java SE，Java Platform Standard Edition，Java平台标准版, 基本等同于 JDK；</li><li>Java EE，Java Platform Enterprise Edition，也即Java平台企业版，JavaEE实际上是一系列技术标准的集合，并不提供具体实现；</li><li>Java ME，Java Platform Micro Edition，用于嵌入式和移动设备的Java平台，已经式微。</li></ul><p><strong>Java EE 是一系列技术标准所组成的平台</strong>，最早由 Sun 发布，后来 Oracle 把 Java EE 交给 Eclipse 基金会管理，同时改名为 Jakarta EE。Java EE 的技术标准包括：</p><ul><li>Servlet: Java Servlet API</li><li>JNDI(Java Name and Directory Interface): Java 命名和目录接口，它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。<br>并提供了一致的模型来存取和操作企业级的资源如 DNS 和 LDAP、本地文件系统、或应用服务器中的对象。</li><li>JTA(Java Transaction API): Java 事务 API.</li><li>JTS(Java Transaction Service): Java 事务服务.</li><li>JPA(Java Persistence API): 通过注解或 XML 描述对象－关系表的映射关系, 并将对象持久化到数据库中, 实现有 Spring-data-jpa, Hibernate。</li><li>JMS(Java Message Service): Java 消息服务接口是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>Java 消息服务的规范包括两种消息模式，点对点和发布者／订阅者。</li><li>JMX(Java Management Extensions): Java 管理扩展，JMX 提供了一套接口，让开发者和管理者可以通过 MBean 获取程序运行的状态以及动态的修改程序的相关配置。<br>JMX 可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。<br>Tomcat、Kafka 等都通过 JMX 实现了监控接口，Jconsole 和 VisualVM 可以通过 JMX 协议获取程序运行状态实现监控。</li><li>Java Bean: 一般情况下指的是实体类, 所有属性为 private, 提供默认构造方法和 getter, setter, 如果一个 JavaBean 需要在不同的 JVM 的进程中进行传递，还需要实现 Serializable 接口.</li><li>MBean（Managed Bean）: 托管 Bean, 是一种通过依赖注入创建的 Java Bean。MBean 代表了运行在 Java 虚拟机上的资源，例如应用程序或 Java EE 服务（事务监控、JDBC 驱动程序等）。<br>其可以用于收集如性能、资源使用率、问题信息等关键的统计信息（通过拉取），获取或设置应用程序的配置或属性（通过推送或拉取），以及对故障或状态变化等的通知事件（通过推送）。</li><li>EJB(Enterprise JavaBean): 企业级 JavaBean, 与普通 Java Bean 的区别: JavaBean 的使用可以不需要容器，EJB 的运行一般需要 EJB 容器(即应用服务器，如 JBoss/Weblogic/Websphere…</li><li>POJO(Plain Ordinary Java Object): 简单的 Java 对象, 实际就是普通 Java Beans, 是为了避免和 EJB 混淆所创造的简称</li><li>JDBC(Java Database Connectivity): 是一个标准 SQL(Structured Query Language, 结构化查询语言)数据库访问接口</li></ul><p>附：<a href="https://www.oracle.com/technetwork/java/javaee/tech/index.html" target="_blank" rel="noopener">来自 Oracke的 Java EE 8 技术列表</a></p><p>J2EE里面的2是什么意思？</p><blockquote><p>J2SE，J2SE，J2ME中2的含义要追溯要1998年。<br>1998年Java 1.2版本发布，1999年发布Java 1.2的标准版，企业版，微型版三个版本，为了区分这三个版本，分别叫做Java2SE，Java2EE，Java2ME，简称J2SE，J2EE，J2ME。故，2的含义为1.2版本。但是，这种叫法已经在2005年Java 1.6发布后取消，J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME。<br>所以，现在的J2EE等叫法是05年以前旧的叫法。</p></blockquote><h1 id="JavaEE的发展"><a href="#JavaEE的发展" class="headerlink" title="JavaEE的发展"></a>JavaEE的发展</h1><p>@ref: <a href="https://www.51cto.com/article/670298.html" target="_blank" rel="noopener">从Java EE到Jakarta EE，企业版Java的发展历程-java ee企业级</a></p><table><thead><tr><th>版本</th><th>发布日期</th><th>焦点说明</th></tr></thead><tbody><tr><td>J2EE 1.4</td><td>2003.12</td><td><strong>对 Web 服务更好支持</strong>。启用 javax 命名空间。Servlet 2.4、JSP 2.0、EJB 2.1 等</td></tr><tr><td>Java EE 5</td><td>2006.05</td><td>以 Web 为着力点继续优化。Servlet 2.5、JSP 2.1、<strong>EJB 3.0</strong>、注解支持等</td></tr><tr><td>Java EE 6</td><td>2009.12</td><td>添加了大量新技术来简化开发，如：<strong>Servlet 3.0</strong>(异步处理)、Bean Validation、EJB 3.1、JSF 2.0、JPA 2.0、<strong>上下文和依赖注入(CDI)</strong></td></tr><tr><td>Java EE 7</td><td>2013.06</td><td>提高生产力满足企业需求和 HTML5。Servlet 3.1、<strong>WebSocket 1.0</strong>、JSON 1.0、JMX 2.0、Batch 1.0</td></tr><tr><td><strong>Java EE 8</strong></td><td>2017.08</td><td>增加了 JSON 绑定和安全相关。Servlet 4.0、Bean Validation 2.0、CDI 2.0、JPA 2.2</td></tr><tr><td><strong>Jakarta EE 入局</strong></td><td>2017.08</td><td>Oracle 将 Java EE 交给开源组织，Eclipse 基金会接手（Apache 基金会爆冷出局还是不想要？）。但 Oracle 不允许开源组织使用 Java 名号，所以 Jakarta EE 名称于 2018.02.26 应运而生</td></tr><tr><td><strong>Jakarta EE 8</strong></td><td>2019.09</td><td><strong>规范与 Java EE 8完全相同</strong>。Maven 的 GAV 变了：<code>javax.servlet:javax.servlet-api:4.0.1 -&gt; jakarta.servlet:jakarta.servlet-api:4.0.2</code>，但命名空间没变依旧还是 <code>javax.*</code>，算是个小过度吧</td></tr><tr><td>Jakarta EE 9</td><td>2020.11</td><td><strong>没有加入新功能</strong>，Eclipse 基金会的首个正式版本。命名空间从 <code>javax.*</code> 迁移到 <code>jakarta.*</code>，前者从此成为历史。<strong>所有模块</strong>大版本号+1，如 Servlet 4.0.2 → Servlet 5 以表示其断层式升级</td></tr><tr><td>Jakarta EE 9.1</td><td>2021.06</td><td>相较于 9 <strong>没有</strong> 加入新 API。主要提供对 Java SE 11 的运行支持</td></tr></tbody></table><p>2021年9月 Spring Boot 3.0 M1发布, 基线从 Java8提升至 Java17, 所有 Java EE API 被迁移到 Jakarta EE(用户需要将 <code>javax</code> 替换为 <code>jakarta</code>. 例如，<code>javax.servlet.Filter</code> 将替换为 <code>jakarta.servlet.Filter</code>)  </p><p>其他参考：</p><ul><li>2017 年 3 月: <a href="https://www.infoq.cn/article/enterprise-java-opinion" target="_blank" rel="noopener">InfoQ观点：Java EE的未来</a></li><li>2018 年 2 月: <a href="https://www.infoq.cn/article/2018/02/from-javaee-to-jakartaee" target="_blank" rel="noopener">Java EE重命名为Jakarta EE：Java EE Guardians与Oracle的分歧</a></li><li>2019 年 5 月: <a href="https://www.infoq.cn/article/7TvOThYKv-Hbzp4NIsIf" target="_blank" rel="noopener">谈判失败，Oracle亲手把Java EE送上断头台</a></li></ul><h1 id="JTA-Java-Transaction-API"><a href="#JTA-Java-Transaction-API" class="headerlink" title="JTA (Java Transaction API)"></a>JTA (Java Transaction API)</h1><p>@ref:</p><ul><li><a href="https://www.oracle.com/java/technologies/jta.html" target="_blank" rel="noopener">Java Transaction API (JTA)</a></li><li><a href="https://www.baeldung.com/jee-jta" target="_blank" rel="noopener">Guide to Jakarta EE JTA | Baeldung</a></li><li><a href="https://www.progress.com/tutorials/jdbc/understanding-jta" target="_blank" rel="noopener">Understanding JTA - The Java Transaction API</a></li><li><a href="https://spring.io/blog/2011/08/15/configuring-spring-and-jta-without-full-java-ee/" target="_blank" rel="noopener">Configuring Spring and JTA without full Java EE</a></li></ul><h1 id="JTS-Java-Transaction-Service"><a href="#JTS-Java-Transaction-Service" class="headerlink" title="JTS (Java Transaction Service):"></a>JTS (Java Transaction Service):</h1><p>@ref:</p><ul><li><a href="https://docs.oracle.com/cd/E19644-01/817-5449/djjts.html" target="_blank" rel="noopener">Chapter 3 Using the Transaction Service</a></li><li><a href="https://www.ibm.com/support/pages/learning-more-about-java-transaction-service-jts" target="_blank" rel="noopener">Learning more about Java Transaction Service (JTS)</a></li></ul><h1 id="JMS-Java-Message-Service"><a href="#JMS-Java-Message-Service" class="headerlink" title="JMS (Java Message Service)"></a>JMS (Java Message Service)</h1><p>@ref:</p><ul><li><a href="https://www.oracle.com/java/technologies/java-message-service.html" target="_blank" rel="noopener">Java Message Service (JMS)</a></li><li><a href="https://www.javatpoint.com/jms-tutorial" target="_blank" rel="noopener">JMS Tutorial - javatpoint</a></li><li><a href="https://docs.oracle.com/javaee/7/api/javax/jms/package-summary.html" target="_blank" rel="noopener">javax.jms (Java(TM) EE 7 Specification APIs)</a></li></ul><h1 id="JMX-Java-Management-Extensions"><a href="#JMX-Java-Management-Extensions" class="headerlink" title="JMX (Java Management Extensions)"></a>JMX (Java Management Extensions)</h1><p>@ref:</p><ul><li><a href="https://zh.wikipedia.org/wiki/JMX" target="_blank" rel="noopener">JMX - 维基百科，自由的百科全书</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/javaee/JavaEE-Title.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h1&gt;&lt;p&gt;Java平台共分为三个主要版本：Java SE、Java EE 和 Java ME。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java SE，Java Platform Standard Edition，Java平台标准版, 基本等同于 JDK；&lt;/li&gt;
&lt;li&gt;Java EE，Java Platform Enterprise Edition，也即Java平台企业版，JavaEE实际上是一系列技术标准的集合，并不提供具体实现；&lt;/li&gt;
&lt;li&gt;Java ME，Java Platform Micro Edition，用于嵌入式和移动设备的Java平台，已经式微。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Java EE 是一系列技术标准所组成的平台&lt;/strong&gt;，最早由 Sun 发布，后来 Oracle 把 Java EE 交给 Eclipse 基金会管理，同时改名为 Jakarta EE。Java EE 的技术标准包括：&lt;/p&gt;</summary>
    
    
    
    <category term="13.JavaEE" scheme="https://beefyheisenberg.github.io/categories/13-JavaEE/"/>
    
    
    <category term="JavaEE" scheme="https://beefyheisenberg.github.io/tags/JavaEE/"/>
    
    <category term="JTS" scheme="https://beefyheisenberg.github.io/tags/JTS/"/>
    
    <category term="JMS" scheme="https://beefyheisenberg.github.io/tags/JMS/"/>
    
    <category term="JMX" scheme="https://beefyheisenberg.github.io/tags/JMX/"/>
    
    <category term="JTA" scheme="https://beefyheisenberg.github.io/tags/JTA/"/>
    
    <category term="JPA" scheme="https://beefyheisenberg.github.io/tags/JPA/"/>
    
    <category term="JNDI" scheme="https://beefyheisenberg.github.io/tags/JNDI/"/>
    
    <category term="EJB" scheme="https://beefyheisenberg.github.io/tags/EJB/"/>
    
    <category term="JDBC" scheme="https://beefyheisenberg.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.09.《深入理解Java内存模型》笔记</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.09.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.09.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JMM/</id>
    <published>2023-05-24T10:10:50.183Z</published>
    <updated>2023-05-24T10:10:50.184Z</updated>
    
    <content type="html"><![CDATA[<p>@ref: <a href="http://www.infoq.com/cn/minibooks/java_memory_model" target="_blank" rel="noopener">《深入理解Java内存模型》</a></p><hr><p>@tldr:</p><ul><li><a href="#并发编程模型">并发编程模型</a><ul><li>并发编程模型要解决的两个问题: 通信和同步</li><li>两种并发编程模型的: 基于共享内存, 基于消息</li></ul></li><li><a href="#Java内存模型的抽象">Java内存模型的抽象</a><ul><li>Java 内存模型（JMM）的抽象: 主内存和线程的”本地内存”</li><li><a href="#JMM的happens-before规则">happens-before规则</a><ul><li>该规则是 JSR-133 内存模型(JDK 层面定义的)中提出的概念, happens-before 并不是指两个指令执行的先后顺序, 而是两个指令的 <strong>内存可见性</strong>. 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。</li><li>该规则还保证了, 哪些 java 代码能达到 happens-before 的效果:<ul><li>单线程下顺序执行;</li><li>正确使用 volatile, Synchronize 的情况下, 多线程也能提供 happens-before 效果;</li></ul></li></ul></li></ul></li><li><a href="#重排序">重排序</a><ul><li>为什么会产生重排序，有哪几种重排序?</li><li>在 JMM 上, 重排序必须遵守 as-if-serial 语义: as if serial, 「就像是顺序执行」<ul><li>在单线程环境下, 保证 a-i-s, 处理器和编译器的重排序优化,不能改变存在数据依赖关系的两个操作的执行顺序</li><li>在存在竞争的多线程下, 处理器和编译器不保证 a-i-s, 必须正确使用 lock，volatile 和 final 才可以.</li></ul></li></ul></li><li><a href="#内存屏障">内存屏障</a><ul><li>内存屏障指令是 cpu 架构层面定义的, Java 编译器会在生成字节码中插入内存屏障指令来禁止某些重排序, 保证多核环境下代码执行的”一致性”</li><li>JMM 提供了四种内存屏障, 其中最重要的是 <code>StoreLoad</code> 屏障指令, 它能保证…</li></ul></li><li>Java 如何实现多线程环境下的正确同步:<ul><li>Volatile 实现了怎样的内存语义, 是如何实现的?</li><li>Synchronize 实现了怎样的内存语义, 是如何实现的?</li><li>ReentrantLock 是如何实现的? CAS 具有跟 Volatile 读写一样的内存语义, 是如何实现的?</li><li><a href="concurrent包的实现">concurrent包的实现</a> : 四种方式(CAS 和 volatile)</li></ul></li></ul><h2 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h2><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。</p><p><strong>通信</strong> 是指: 通信是指线程之间以何种机制来交换信息。在共享内存的并发模型里，对于线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p><strong>同步</strong> 是指: 程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><blockquote><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p></blockquote><p>Java 并发模型中, 线程的同步采用的是 <strong>共享内存</strong> 的方式，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><h2 id="Java-内存模型的抽象"><a href="#Java-内存模型的抽象" class="headerlink" title="Java 内存模型的抽象"></a>Java 内存模型的抽象</h2><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的 <strong>本地内存</strong>（local memory），本地内存中存储了该线程以读/写共享变量的副本。<br><strong>本地内存</strong> 是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p><img src="/images/java/JMM.png" alt="JMM"></p><blockquote><p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p></blockquote><h3 id="JMM-的-happens-before-规则"><a href="#JMM-的-happens-before-规则" class="headerlink" title="JMM 的 happens-before 规则"></a>JMM 的 happens-before 规则</h3><p>从 JDK 5 开始，java 使用新的 JSR-133 内存模型，JSR-133 提出了 happens-before 的概念，<strong>通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。</strong><br>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。与程序员密切相关的 happens-before 规则如下：</p><ol><li>顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁（Monitor）规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>线程启动法则：在一个线程里，对 Thread.start 的调用会 happens-before 于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或 Thread.isAlive 返回 false。</li><li>中断法则：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束 happens-before 于这个对象 finalizer 的开始。</li></ol><blockquote><p>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。<br>两个操作之间存在 happens-before 关系，并不意味着一定要按照 happens-before 原则制定的顺序来执行。如果重排序之后的执行结果与按照 happens-before 关系来执行的结果一致，那么这种重排序并不非法。</p></blockquote><h3 id="JMM-顺序一致性"><a href="#JMM-顺序一致性" class="headerlink" title="JMM 顺序一致性"></a>JMM 顺序一致性</h3><p><strong>什么是“顺序一致性”内存模型：</strong></p><p>顺序一致性模型(sequential consistency)是一个被计算机科学家理想化了的理论参考模型，顺序一致性内存模型有两大特性：</p><ol><li>一个线程中的所有操作必须按照程序的顺序来执行。 （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。</li><li>在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ol><p><strong>JMM 的顺序一致性保证：</strong></p><p>JMM 提供的顺序一致性内存模型是一种”面向程序员的内存模型”（Programmer-centric model），JMM 对正确同步的多线程程序的内存一致性做了如下保证：</p><p>如果程序是正确同步的（正确使用了 lock，volatile 和 final），程序的执行将具有顺序一致性（sequentially consistent）– 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（这对于程序员来说是一个极强的保证）。</p><p>这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用。</p><p>synchronized 提供的顺序一致性效果：</p><p>在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。</p><p>虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。<br>重排序分三种类型：</p><ol><li><strong>编译器优化</strong> 的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行</strong> 的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><strong>内存系统</strong> 的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p><img src="/images/java/jmm-re-order.png" alt=""></p><blockquote><ol><li>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。</li><li>写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</li></ol></blockquote><h3 id="遵守-as-if-serial-语义"><a href="#遵守-as-if-serial-语义" class="headerlink" title="遵守 as-if-serial 语义"></a>遵守 as-if-serial 语义</h3><p>as-if-serial: 翻译就是「就像是顺序执行」.</p><p>编译器和处理器对重排序准守 <code>as-if-serial</code> 语义，<code>as-if-serial</code> 的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器/runtime/处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 <code>as-if-serial</code> 语义，编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不能改变存在数据依赖关系的两个操作的执行顺序。比如 <code>a=b; b=1;</code> 以及 <code>a=1; b=a;</code>，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><p><strong>编译器和处理器仅指在单线程环境下遵守 as-if-serial</strong>，在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。必须通过正确的同步实现.</p><p>注意：if 等控制语句没有 <strong>数据依赖性</strong>，比如代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(flag)</span><br><span class="line">  int i = r * r;</span><br></pre></td></tr></table></figure></p><p>其中 <code>if</code> 和 <code>int i= r * r</code> 是控制依赖关系，但没有数据依赖性。<br>当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响，提高执行效率。<br>下面的情形是有可能发生的：处理器可以提前读取并计算 <code>r * r</code>，然后把计算结果临时保存到一个名为 <strong>重排序缓冲（reorder buffer ROB）</strong> 的硬件缓存中。当接下来 <code>if(flag)</code> 的条件判断为真时，就把该计算结果写入变量 i 中。</p><h3 id="通过内存屏障禁止重排序"><a href="#通过内存屏障禁止重排序" class="headerlink" title="通过内存屏障禁止重排序"></a>通过内存屏障禁止重排序</h3><p>编译器和处理器必须同时遵守重排规则。由于单核处理器能确保与“顺序执行”相同的一致性，所以在单核处理器上并不需要专门做什么处理，就可以保证正确的执行顺序。但在多核处理器上通常需要使用内存屏障指令来确保这种一致性。在不同的 CPU 架构上内存屏障的实现非常不一样。相对来说 Intel CPU 的强内存模型比 DEC Alpha 的弱复杂内存模型（缓存不仅分层了，还分区了）更简单。</p><blockquote><p>内存屏障提供了两个功能。首先，它们通过确保从另一个 CPU 来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到 CPU 缓存子系统。</p></blockquote><p>Java 编译器在生成指令序列的适当位置会插入 <strong>内存屏障（Barriers）</strong> 指令来禁止特定类型的处理器重排序。以实现屏障前后指令的可见性。</p><p>JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th>example</th><th>实现效果</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load 1; LoadLoad; Load 2;</td><td>确保 Load 1 数据的装载，之前于 Load 2 及所有后续装载指令的装载。(禁止 Load 1,Load 2 重排序)</td></tr><tr><td>StoreStore</td><td>Store 1; StoreStore; Store 2;</td><td>确保 Store 1 数据对其他处理器可见（刷新到内存），之前于 Store 2 及所有后续存储指令的存储。(禁止 Store 1,Store 2 重排序)</td></tr><tr><td>LoadStore</td><td>Load 1; LoadStore; Store 2;</td><td>确保 Load 1 数据装载，之前于 Store 2 及所有后续的存储指令刷新到内存。(禁止 Load 1,Store 2 重排序)</td></tr><tr><td>StoreLoad</td><td>Store 1; StoreLoad; Load 2;</td><td>确保 Store 1 数据对其他处理器变得可见（刷新到内存），之前于 Load 2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。(禁止 Store 1,Load 2 重排序)</td></tr></tbody></table><p><strong>StoreLoad</strong> 是一个“全能型”的屏障，它可以保证“先刷新到主内存再访问”。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="volatile-变量的特性"><a href="#volatile-变量的特性" class="headerlink" title="volatile 变量的特性"></a>volatile 变量的特性</h3><ul><li>可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。可以认为对 volatile 的写是原子的；</li><li>原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 <code>volatile++</code> 这种”依赖当前值”的复合操作不具有原子性，所以仅仅使用 volatile 变量当做同步手段(比如当做锁的计数器) 是不可以的。线程安全的计数器请使用 <code>AtomicInteger</code></li></ul><blockquote><p>扩展阅读: long 和 double 读写的原子性:<br>JMM 不保证对 64 位的 long 型和 double 型变量的读/写操作具有原子性,<br>在一些 32 位的处理器上，如果要求对 64 位数据的读/写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的读/写具有原子性。<br>当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的读/写操作拆分为两个 32 位的读/写操作来执行。<strong>这两个 32 位的读/写操作可能会被分配到不同的总线事务中执行</strong>，此时对这个 64 位变量的读/写将不具有原子性。</p></blockquote><h3 id="volatile-读写建立的-happens-before-关系"><a href="#volatile-读写建立的-happens-before-关系" class="headerlink" title="volatile 读写建立的 happens before 关系"></a>volatile 读写建立的 happens before 关系</h3><p><strong>从 JSR-133 开始，volatile 变量的写-读可以实现线程之间的通信</strong>。看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A执行writer():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;               <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;         <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程B执行read():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;          <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;      <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据 happens-before①，1 happens-before 2，3 happens-before 4；</li><li>根据 volatile 语义，2 happens-before 3；</li><li>根据 happens-before④，1 happens-before 4；</li></ul><blockquote><p>上面写 1 happens-before 2，指的是 1 对于 2 可见，但不一定是执行顺序；</p></blockquote><h3 id="volatile-读写的内存语义"><a href="#volatile-读写的内存语义" class="headerlink" title="volatile 读写的内存语义"></a>volatile 读写的内存语义</h3><p>volatile 读写的内存语义如下：</p><ul><li>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li><li>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。</li></ul><blockquote><p>“内存语义”（没找到对应的英文原语）的概念： 可以理解为多核环境下, “同步”(在 Java 里指 Volatile，Synchronize 等)实现的原则, 或者是”能达到的效果”.</p></blockquote><h3 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h3><p>下面是 JMM 针对编译器制定的 volatile 重排序规则表：<br><img src="/images/java/JMM-Volatile-Re-Order.png" alt=""></p><p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM 采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略：</p><ul><li>在每个 <strong>volatile 写</strong> 操作的 <strong>前面</strong> 插入一个 <code>StoreStore</code> 屏障。</li><li><p>在每个 <strong>volatile 写</strong> 操作的 <strong>后面</strong> 插入一个 <code>StoreLoad</code> 屏障。</p></li><li><p>在每个 <strong>volatile 读</strong> 操作的 <strong>后面</strong> 插入一个 <code>LoadLoad</code> 屏障。</p></li><li>在每个 <strong>volatile 读</strong> 操作的 <strong>后面</strong> 再插入一个 <code>LoadStore</code> 屏障。</li></ul><p><strong>① volatile 写插入的内存屏障：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通读/写操作</span><br><span class="line">StoreStore屏障 //禁止上面的普通写和下面的 Volatile写 重排序</span><br><span class="line">volatile写</span><br><span class="line">StoreLoad屏障  //禁止上面的Volatile写和下面有可能的 Volatile读写 重排序</span><br></pre></td></tr></table></figure></p><p><img src="/images/java/jmm-volatile-barriers_store.png" alt="jmm-volatile-read-barriers"></p><ul><li><p>StoreStore 屏障可以保证在 volatile 写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为 StoreStore 屏障将保障上面所有的普通写在 volatile 写之前刷新到主内存。</p></li><li><p>这里比较有意思的是 volatile 写后面的 StoreLoad 屏障。为了保证能正确实现 volatile 的内存语义，在每个 volatile 写的后面或在每个 volatile 读的前面插入一个 StoreLoad 屏障。从整体执行效率的角度考虑，JMM 选择了在每个 volatile 写的后面插入一个 StoreLoad 屏障。因为 volatile 写 - 读内存语义的常见使用模式是：一个写线程写 volatile 变量，多个读线程读同一个 volatile 变量。当读线程的数量大大超过写线程时，选择在 volatile 写之后插入 StoreLoad 屏障将带来可观的执行效率的提升。</p></li></ul><p><strong>② volatile 读插入的内存屏障：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile读</span><br><span class="line">LoadLoad屏障  // 禁止下面的普通读和上面的 Volatile读 重排序</span><br><span class="line">LoadStore屏障 // 禁止下面的普通写和上面的 Volatile读 重排序</span><br><span class="line">普通读/写</span><br></pre></td></tr></table></figure></p><p><img src="/images/java/jmm-volatile-barriers_load.png" alt="jmm-volatile-write-barriers"></p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>有关 Synchronized 的实现, 请参考👉 <a href="https://whatsrtos.github.io/30MinsTutorial/Java%20Tutorials/#Synchronized" target="_blank" rel="noopener">《Java Tutorials》</a></p><h3 id="Synchronized-的释放-获取建立的-happens-before-关系"><a href="#Synchronized-的释放-获取建立的-happens-before-关系" class="headerlink" title="Synchronized 的释放-获取建立的 happens before 关系"></a>Synchronized 的释放-获取建立的 happens before 关系</h3><p>线程 A 在释放锁之前所有可见的共享变量，在线程 B 获取同一个锁之后，将立刻变得对 B 线程可见。</p><h3 id="Synchronized-释放-获取的内存语义"><a href="#Synchronized-释放-获取的内存语义" class="headerlink" title="Synchronized 释放-获取的内存语义"></a>Synchronized 释放-获取的内存语义</h3><ul><li>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</li><li>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被 monitor 保护的临界区代码必须要从主内存中去读取共享变量。</li><li>对比锁释放-获取的内存语义与 volatile 写-读的内存语义，可以看出：锁释放与 volatile 写有相同的内存语义；锁获取与 volatile 读有相同的内存语义。</li></ul><h3 id="Synchronized-内存语义的实现"><a href="#Synchronized-内存语义的实现" class="headerlink" title="Synchronized 内存语义的实现"></a>Synchronized 内存语义的实现</h3><p>Synchronized 提供的 Monitor 机制可以保证：临界区内的代码可以重排序，但不允许临界区内的代码“逸出”到临界区之外。<br>JMM 会在退出 Monitor 和进入 Monitor 这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程在临界区内可以做重排序，但其他线程根本无法“观察”到该线程在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 实现的 happens-before 关系和内存语义与 Synchronized 的一样。<br>ReentrantLock 实现的基础是 Volatile 变量和 CAS, 上面提到了 Volatile 变量的读/写可以实现”禁止重排序”的效果, CAS 操作同时具有 Volatile 读和写的禁止重排序效果.</p><p>「CAS的原理和实现的内存语义」一节介绍了 CAS 是如何同时具有 Volatile 变量的读和写的内存语义的.</p><h3 id="ReentrantLock-内存语义的实现解析"><a href="#ReentrantLock-内存语义的实现解析" class="headerlink" title="ReentrantLock 内存语义的实现解析"></a>ReentrantLock 内存语义的实现解析</h3><p>回顾 ReentrantLock 的实现，<code>lock()</code> 调用栈如下：</p><ol><li>ReentrantLock : lock()</li><li>FairSync : lock()</li><li>AbstractQueuedSynchronizer : acquire(int arg)</li><li>ReentrantLock : tryAcquire(int acquires)</li></ol><p>在第 4 步真正开始加锁，<code>tryAcquire</code>方法首先读 volatile 变量 state，<br>  如果<code>state==0</code>, 说明还未加锁, 再尝试<code>CAS(state, 0, 1)</code>, 如果 CAS 成功则成功获取到锁;<br>  如果<code>state!=0</code>, 说明已经加锁, 再判断 ExclusiveOwnerThread 是否等于当前线程, 如果等于, 重入该锁(立刻获取到锁)</p><p>解锁方法<code>unlock()</code>的方法调用栈如下(公平锁为例)：</p><ol><li>ReentrantLock : unlock()</li><li>AbstractQueuedSynchronizer : release(int arg)</li><li>Sync : tryRelease(int releases)</li></ol><p>在第 3 步真正开始释放锁，<code>tryRelease</code>方法首先读 volatile 变量 state，<br>  读取到的值-1, 然后把这个减 1 后的值写入 state(这里并没用 CAS 更新), 如果这个减 1 后的值=0, 则把锁状态置为 free</p><p>由上可知, 公平锁在释放锁的时候写 Volatile 变量, 在获取锁的时候读取 Volatile 变量, 根据 volatile 的 happens-before 规则：<br><strong>释放锁的线程在写 volatile 变量之前可见的共享变量，在获取锁的线程读取同一个 volatile 变量后将立即变的对获取锁的线程可见。</strong></p><h3 id="CAS-的原理和实现的内存语义"><a href="#CAS-的原理和实现的内存语义" class="headerlink" title="CAS 的原理和实现的内存语义"></a>CAS 的原理和实现的内存语义</h3><p>CAS 同时具有 volatile 读和 volatile 写的内存语义。下面我们来分析在常见的 intel x 86 处理器中，CAS 是如何同时具有 volatile 读和 volatile 写的内存语义的。</p><p>sun.misc.Unsafe 类的<code>compareAndSwapInt()</code>方法是个 Native 方法, 最终调用到了 JVM 的 C++代码<code>Atomic::cmpxchg()</code>（compare and change）,</p><p>C++的<code>Atomic::cmpxchg()</code>最终调用的是”compare and change”的汇编代码<code>cmpxchg</code> ,</p><p><code>Atomic::cmpxchg()</code>函数会根据当前处理器的类型来决定是否为 cmpxchg 指令添加 lock 前缀。<br>如果程序是在多处理器上运行，就为 cmpxchg 指令加上 <code>lock</code> 前缀（汇编代码是这个样子 <code>lock cmpxchg dword ptr[edx], ecx</code>）。intel 的手册对<code>lock</code>前缀的说明如下：</p><ol><li>确保对内存的读-改-写操作原子执行。</li><li>禁止该指令与之前和之后的读和写指令重排序。</li><li>把写缓冲区中的所有数据刷新到内存中。</li></ol><p>上面的第 2 点和第 3 点所具有的内存屏障效果，足以同时实现 volatile 读和 volatile 写的内存语义。所以，现在我们终于能明白为什么 JDK 文档说 <strong>CAS 同时具有 volatile 读和 volatile 写的内存语义</strong> 了。</p><p>cmpxchg 和 lock 前缀的解析，详细见 -&gt; <a href="/12.Java/Java-并发.05a.JUC-Atomic&CAS/" title="Java-并发.05a.JUC-Atomic&CAS">Java-并发.05a.JUC-Atomic&CAS</a></p><h3 id="Concurrent-包的实现总结-Volatile-和-CAS"><a href="#Concurrent-包的实现总结-Volatile-和-CAS" class="headerlink" title="Concurrent 包的实现总结: Volatile 和 CAS"></a>Concurrent 包的实现总结: Volatile 和 CAS</h3><p>由于 java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面四种方式：</p><ol><li>A 线程写 volatile 变量，随后 B 线程读这个 volatile 变量。</li><li>A 线程写 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li><li>A 线程用 CAS 更新一个 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li><li>A 线程用 CAS 更新一个 volatile 变量，随后 B 线程读这个 volatile 变量。</li></ol><p>Java 的 CAS 会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键。<br>同时，volatile 变量的读/写和 CAS 可以实现线程之间的通信。把这些特性整合在一起，就形成了整个 concurrent 包得以实现的基石。<br>如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为 volatile；</li><li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li><li>同时，配合以<code>volatile 读/写的内存语义</code> 和 <code>CAS 的内存语义</code>，来实现线程之间的通信。</li></ol><p>下图是 Java concurrent 包的实现层次结构, 以 Volatile 和 CAS 为基础, JDK 实现了 AQS / Atomic 类 / 非阻塞队列等等基本类, 然后<br>通过这些基本类实现了重入锁, 阻塞队列, 线程池等..</p><p><img src="/images/java/jmm-cas-and-volatile.png" alt=""></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p><ul><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ul><h3 id="读写-FINAL-域的重排序规则"><a href="#读写-FINAL-域的重排序规则" class="headerlink" title="读写 FINAL 域的重排序规则"></a>读写 FINAL 域的重排序规则</h3><p>① 写: 写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面：</p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><p>② 读: 在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</p><h3 id="FINAL-域是引用类型"><a href="#FINAL-域是引用类型" class="headerlink" title="FINAL 域是引用类型"></a>FINAL 域是引用类型</h3><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：<br>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><h2 id="回到错误的-DLC-单例代码"><a href="#回到错误的-DLC-单例代码" class="headerlink" title="回到错误的 DLC 单例代码"></a>回到错误的 DLC 单例代码</h2><p>常见的双重锁检查（Double Checked Locking）的单例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> </span>&#123;                 <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                    <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;               <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                          <span class="comment">//4:第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123;  <span class="comment">//5:加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)                    <span class="comment">//6:第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();           <span class="comment">//7:问题的根源出在这里</span></span><br><span class="line">            &#125;                                            <span class="comment">//8</span></span><br><span class="line">        &#125;                                                <span class="comment">//9</span></span><br><span class="line">        <span class="keyword">return</span> instance;                                 <span class="comment">//10</span></span><br><span class="line">    &#125;                                                    <span class="comment">//11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写是有问题的，在多线程并发的情况下，当有某个线程在步骤 4 进行检查的时候发现 instance 非 null，但 instance 却指向一块已经分配但是未初始化的内存。</p><p>为什么出现这种情况：<br>示例代码的第 7 行<code>instance = new Instance()</code>创建一个对象。这一行代码可以分解为如下的三行伪代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized (DoubleCheckedLocking.class) &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        memory = allocate();   //1：分配对象的内存空间</span><br><span class="line">        ctorInstance(memory);  //2：构造函数，初始化对象</span><br><span class="line">        instance = memory;     //3：设置 instance 指向刚分配的内存地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 JSR-133 的 happens-before 和<code>as-if-serial</code>语义，在单线程里 1 happens-before 3，但 2 不能保证 happens-before 3，</p><p>如果发生了 1-3-2 的重排序，调用构造方法初始化对象被重排序到了最后一步，<br>当线程 A 执行完 3，但还没执行 2 的时候(instance 指向分配好的内存, 但这块内存还未由构造函数初始化)，<br>此时线程 B 开始运行, 到第一次判断 <code>instance==null</code>，线程 B 可能看到 instance 的值，所以不用走下面的 sync, 线程 B 直接获得了这个 instance（一个还未初始化的) 引用。然后就出问题了</p><p><strong>所以, 解决方法有两种思路:</strong></p><ol><li>不允许 2 和 3 重排序；</li><li>允许 2 和 3 重排序，但不允许其他线程“看到”这个重排序，也即 1-3-2 都执行完之后其他线程才可以”看到”改变（可见性）。</li></ol><p>第一种解决方案是, 将 <code>instance</code> 变量声明成 volatile。<br>当声明对象的引用为 volatile 后，“问题的根源”的三行伪代码中的 2 和 3 之间的重排序，在多线程环境中将会被禁止。</p><p>第二种方案, 基于类初始化锁, 代码示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例放在内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance ;  <span class="comment">// 这里将导致 InstanceHolder 类被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾一下 Java 对初始化的规范:</p><pre><code>T 是一个类, 首次对 T 的 static 成员属性进行读写的时候, 会触发 T 的初始化T 是一个外部类, T 被初始化的时候, 其静态内部类 Inner 不会被初始化,</code></pre><p>作为内部类, InstanceHolder 不会在外部类初始化时被初始化(可以实现延后初始化),<br>首次调用 <code>InstanceFactory.getInstance()</code>的时候, 相当于调用了 <code>getstatic</code>指令读取 InstanceHolder 的静态属性, 会导致 InstanceHolder 被初始化,<br>初始化包括执行 static 代码块, 初始化 static 成员属性, 这些操作代码都被放在一个叫 <code>&lt; clinit &gt;</code>的方法中, 被 JVM <strong>加锁</strong>执行.<br>这个方案的实质是：允许“问题的根源”的三行伪代码中的 2 和 3 重排序，但不允许其他线程（这里指线程 B）“看到”这个重排序。</p><blockquote><p>Java 语言规范规定，对于每一个类或接口 C，都有一个唯一的初始化锁 LC 与之对应。从 C 到 LC 的映射，由 JVM 的具体实现去自由实现。JVM 在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="noopener">深入理解Java内存模型（一）——基础</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-2" target="_blank" rel="noopener">深入理解Java内存模型（二）——重排序</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-3" target="_blank" rel="noopener">深入理解Java内存模型（三）——顺序一致性</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-4" target="_blank" rel="noopener">深入理解Java内存模型（四）——volatile</a></li><li><a href="http://www.infoq.com/cn/articles/java-memory-model-5" target="_blank" rel="noopener">深入理解Java内存模型（五）——锁</a></li><li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a></li><li>PDF：[[../_attachments/深入理解Java内存模型.pdf]]</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;@ref: &lt;a href=&quot;http://www.infoq.com/cn/minibooks/java_memory_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入理解Java内存模型》&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;@tldr:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#并发编程模型&quot;&gt;并发编程模型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;并发编程模型要解决的两个问题: 通信和同步&lt;/li&gt;
&lt;li&gt;两种并发编程模型的: 基于共享内存, 基于消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Java内存模型的抽象&quot;&gt;Java内存模型的抽象&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Java 内存模型（JMM）的抽象: 主内存和线程的”本地内存”&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#JMM的happens-before规则&quot;&gt;happens-before规则&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;该规则是 JSR-133 内存模型(JDK 层面定义的)中提出的概念, happens-before 并不是指两个指令执行的先后顺序, 而是两个指令的 &lt;strong&gt;内存可见性&lt;/strong&gt;. 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。&lt;/li&gt;
&lt;li&gt;该规则还保证了, 哪些 java 代码能达到 happens-before 的效果:&lt;ul&gt;
&lt;li&gt;单线程下顺序执行;&lt;/li&gt;
&lt;li&gt;正确使用 volatile, Synchronize 的情况下, 多线程也能提供 happens-before 效果;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#重排序&quot;&gt;重排序&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;为什么会产生重排序，有哪几种重排序?&lt;/li&gt;
&lt;li&gt;在 JMM 上, 重排序必须遵守 as-if-serial 语义: as if serial, 「就像是顺序执行」&lt;ul&gt;
&lt;li&gt;在单线程环境下, 保证 a-i-s, 处理器和编译器的重排序优化,不能改变存在数据依赖关系的两个操作的执行顺序&lt;/li&gt;
&lt;li&gt;在存在竞争的多线程下, 处理器和编译器不保证 a-i-s, 必须正确使用 lock，volatile 和 final 才可以.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内存屏障&quot;&gt;内存屏障&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;内存屏障指令是 cpu 架构层面定义的, Java 编译器会在生成字节码中插入内存屏障指令来禁止某些重排序, 保证多核环境下代码执行的”一致性”&lt;/li&gt;
&lt;li&gt;JMM 提供了四种内存屏障, 其中最重要的是 &lt;code&gt;StoreLoad&lt;/code&gt; 屏障指令, 它能保证…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java 如何实现多线程环境下的正确同步:&lt;ul&gt;
&lt;li&gt;Volatile 实现了怎样的内存语义, 是如何实现的?&lt;/li&gt;
&lt;li&gt;Synchronize 实现了怎样的内存语义, 是如何实现的?&lt;/li&gt;
&lt;li&gt;ReentrantLock 是如何实现的? CAS 具有跟 Volatile 读写一样的内存语义, 是如何实现的?&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;concurrent包的实现&quot;&gt;concurrent包的实现&lt;/a&gt; : 四种方式(CAS 和 volatile)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;并发编程模型&quot;&gt;&lt;a href=&quot;#并发编程模型&quot; class=&quot;headerlink&quot; title=&quot;并发编程模型&quot;&gt;&lt;/a&gt;并发编程模型&lt;/h2&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JMM" scheme="https://beefyheisenberg.github.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.08.多线程设计模式</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.08.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.08.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-05-24T10:10:50.179Z</published>
    <updated>2023-05-24T10:10:50.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guarded-Suspension-模式"><a href="#Guarded-Suspension-模式" class="headerlink" title="Guarded Suspension 模式"></a>Guarded Suspension 模式</h2><p>Guarded Suspension 模式:  guarded 是“被保护着的”、“被防卫着的”意思，suspension 则是“暂停”的意思。当现在并不适合马上执行某个操作时，让要执行该操作的线程等待。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized Request getRequest() &#123;</span><br><span class="line">    while (queue.size() &lt;= 0) &#123; // _警戒条件（guard condition）_</span><br><span class="line">        try &#123;                                   </span><br><span class="line">            wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;      </span><br><span class="line">        &#125;                                       </span><br><span class="line">    &#125;                                           </span><br><span class="line">    return (Request)queue.removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015558585" target="_blank" rel="noopener">Java多线程基础（五）——Guarded Suspension模式 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote><h2 id="Balking-模式"><a href="#Balking-模式" class="headerlink" title="Balking 模式"></a>Balking 模式</h2><p>Balking是“退缩不前”的意思。Balking Pattern和Guarded Suspension Pattern 一样需要警戒条件。在Balking Pattern中，当警戒条件不成立时，会马上中断，而Guarded Suspension Pattern 则是等待到可以执行时再去执行。</p><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015558615" target="_blank" rel="noopener">Java多线程基础（六）——Balking模式 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote><h2 id="Two-phase-Termination-模式"><a href="#Two-phase-Termination-模式" class="headerlink" title="Two -phase Termination 模式"></a>Two -phase Termination 模式</h2><p>两段式终止: 当某个工作收到 shutdown 之类的指令后，不是立刻停止，而是进入一个“已收到终止请求”的状态，可以进行一些资源回收，这一步完成后，再进入“终止处理中”的状态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 若数据有修改，则保存，否则直接返回</span><br><span class="line">public synchronized void save() throws IOException &#123;</span><br><span class="line">    if (!changed) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; balks&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    doSave();</span><br><span class="line">    changed = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015558833" target="_blank" rel="noopener">Java多线程基础（十二）——Two-phase Termination模式 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Guarded-Suspension-模式&quot;&gt;&lt;a href=&quot;#Guarded-Suspension-模式&quot; class=&quot;headerlink&quot; title=&quot;Guarded Suspension 模式&quot;&gt;&lt;/a&gt;Guarded Suspension 模式&lt;/h2&gt;&lt;p&gt;Guarded Suspension 模式:  guarded 是“被保护着的”、“被防卫着的”意思，suspension 则是“暂停”的意思。当现在并不适合马上执行某个操作时，让要执行该操作的线程等待。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public synchronized Request getRequest() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (queue.size() &amp;lt;= 0) &amp;#123; // _警戒条件（guard condition）_&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        try &amp;#123;                                   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; catch (InterruptedException e) &amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;                                       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                                           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (Request)queue.removeFirst();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;@ref &lt;a href=&quot;https://segmentfault.com/a/1190000015558585&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java多线程基础（五）——Guarded Suspension模式 - 透彻理解Java并发编程 - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Balking-模式&quot;&gt;&lt;a href=&quot;#Balking-模式&quot; class=&quot;headerlink&quot; title=&quot;Balking 模式&quot;&gt;&lt;/a&gt;Balking 模式&lt;/h2&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JUC" scheme="https://beefyheisenberg.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.06b.JUC-执行器-Future</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.06b.JUC-Future/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.06b.JUC-Future/</id>
    <published>2023-05-24T10:10:50.169Z</published>
    <updated>2023-05-24T10:10:50.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>Callable</code> 接口类似于 Runnable，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，<code>Callable</code> 功能更强大一些，被线程执行后，可以返回结果。</p><ul><li><code>Callable</code> 有些类似 <code>Runnable</code>, 它们都是接口, 前者需要实现 <code>V call()</code>, 后者需要实现 <code>void run()</code>;</li><li><code>Callable</code> 需要用 <code>FutureTask</code> 包装一下, <code>FutureTask</code> 提供了 <code>get()</code> 方法, 可以获取执行结果;</li></ul><ul><li>FutureTask 需要通过 Thread 执行: 通过构造器 <code>Thread(FutureTask)</code> 创建 Thread 对象</li></ul><ul><li>结果通过 <code>FutureTask.get</code> 获取,  <code>FutureTask</code> 实现了 <code>Future</code> 接口, 通过 <code>FutureTask</code> 和 <code>Future</code> 类型引用都可以调用 <code>get()</code> , <code>cancel()</code> , <code>isDone()</code> , <code>isCancelled()</code> 等方法;</li><li><code>Callable</code> 也可以放入线程池,  <code>ExecutorService.submit(Callable)</code> 把 Callable 提交到线程池并返回 Future ;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureAndFutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * FutureTask 示例1:</span></span><br><span class="line"><span class="comment">     * 由FutureTask直接创建线程,并执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureTaskExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Callable实现类</span></span><br><span class="line">        Callable callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建FutureTask</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread 并开始执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞在此, 直到任务完成:</span></span><br><span class="line">        Integer result = futureTask.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * Future 示例2:</span></span><br><span class="line"><span class="comment">     * Callable 提交到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lambda创建Callable实现类</span></span><br><span class="line">        Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125; ;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(callable);</span><br><span class="line"></span><br><span class="line">        Integer result = future.get();</span><br><span class="line">        <span class="comment">// 或取消线程</span></span><br><span class="line">        future.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题: <code>FutureTask.cancel()</code> 和 <code>Thread.interrupt()</code> 有什么区别?<br>通过查看 <code>cancel()</code> 的源码发现, 实际 <code>cancel()</code> 最终还是调用了 <code>Thread.interrupt()</code>,<br>所以, 要通过 <code>FutureTask.cancel()</code> 停止异步任务, 那么还需要在 <code>Runnable</code> 或 <code>Callable</code> 的主循环里捕捉 InterruptException 异常.</p><h2 id="ListenableFuture-Guava"><a href="#ListenableFuture-Guava" class="headerlink" title="ListenableFuture(Guava)"></a>ListenableFuture(Guava)</h2><p>Guava 的 Listenable Future 对 Future 做了改进，支持注册一个任务执行结束后回调函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 ListenableFuture</span></span><br><span class="line">ListenableFuture&lt;String&gt; listenableFuture =</span><br><span class="line">listeningExecutor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过addCallback() 给 ListenableFuture增加回调</span></span><br><span class="line">Futures.addCallback(ListenableFuture, <span class="keyword">new</span> FutureCallback&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something on success</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable thrown)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something on failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture-Java8"><a href="#CompletableFuture-Java8" class="headerlink" title="CompletableFuture(Java8)"></a>CompletableFuture(Java8)</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" target="_blank" rel="noopener">Future</a> 是 Java 5添加的类，用来描述一个异步计算的结果。你可以使用 <code>isDone</code> 方法检查计算是否完成，或者使用 <code>get</code> 阻塞住调用线程，直到计算完成返回结果，你也可以使用 <code>cancel</code> 方法停止任务的执行。</p><p>虽然<code>Future</code>以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？</p><p>在Java 8中, 新增加了一个包含50个方法左右的类: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">CompletableFuture</a>，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>Java8 的 CompletableFuture 参考了 Guava 的 ListenableFuture 的思路，CompletableFuture 能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。</p><p>CompletableFuture 弥补了 Future 模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过 thenAccept、thenApply、thenCompose 等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p><p>与 Guava ListenableFuture 相比，CompletableFuture 不仅可以在任务完成时注册回调通知，而且可以指定任意线程，实现了真正的异步非阻塞。</p><p><strong>▶ 创建一个 CompletableFuture:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p>runAsync 方法不支持返回值/supplyAsync 可以支持返回值<br>没有指定 Executor 的方法会使用 ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。</p></blockquote><p><strong>▶ 使用 thenApply 串行任务:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; fn, Executor executor)</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。<br>T：上一个任务返回结果的类型<br>U：当前任务的返回值类型</p></blockquote><p><strong>▶使用 thenAccept 消费处理结果:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>▶ 使用 thenCombine 合并任务:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? extends V&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>thenCombine 会把两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。</p></blockquote><p><strong>▶ 使用 thenCompose 流水化处理任务:</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span> </span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>thenCompose 方法允许你对两个 CompletionStage 进行流水线操作，第一个操作完成时，将其结果作为参数传递给第二个操作。</p></blockquote><p><strong>▶ 代码示例 1: thenApply/whenComplete/exceptionally</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Long&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).thenApply(<span class="keyword">new</span> Function&lt;Long, Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Long t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = t*<span class="number">5</span>;</span><br><span class="line">            System.out.println(<span class="string">"result2="</span>+result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    future.whenComplete(<span class="keyword">new</span> BiConsumer&lt;Void, Throwable&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Void t, Throwable action)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行完成！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    future.exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行失败！"</span>+t.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>▶ anyOf / allOf</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>anyOf: 当任意一个 CompletableFuture 完成后，创建一个完成的 CompletableFuture<br>allOf: 当所有的阶段完成后, 创建一个完成的 CompletableFuture</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;List&gt; <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; future1 = rpcService1.invoke();</span><br><span class="line">    CompletableFuture&lt;Double&gt; future2 = rpcService2.invoke();</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture</span><br><span class="line">        .allOf(future1, future2)</span><br><span class="line">        .thenApply(v -&gt; &#123;</span><br><span class="line">            Double d1 = future1.get();</span><br><span class="line">            Double d2 = future2.get();</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(d1, d2);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节参考:</p><blockquote><ul><li><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">Java CompletableFuture 详解 | 鸟窝</a></li><li><a href="https://colobu.com/2018/03/12/20-Examples-of-Using-Java%E2%80%99s-CompletableFuture/" target="_blank" rel="noopener">[译]20个使用 Java CompletableFuture 的例子 | 鸟窝</a></li></ul></blockquote><h3 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h3><ul><li><p>@ref <a href="https://www.thinbug.com/q/23575067" target="_blank" rel="noopener">Java 8 CompletableFuture中的默认值超时 - Thinbug</a><br>似乎是翻译的 Stack Overflow …</p></li><li><p>@ref <a href="http://iteratrlearning.com/java9/2016/09/13/java9-timeouts-completablefutures.html" target="_blank" rel="noopener">Asynchronous timeouts with CompletableFutures in Java 8 and Java 9</a><br>超时 &amp; CompletableFutures<br>如果直接对 CompletableFutures 使用 Future.get(1, TimeUnit.SECONDS) 作为超时, 这样做仍旧阻塞 main 线程;<br>在 Java9 中的支持: completeOnTimeout 或者 orTimeout</p></li></ul><h3 id="vs-ParallelStream"><a href="#vs-ParallelStream" class="headerlink" title="vs ParallelStream"></a>vs ParallelStream</h3><p>@ref: <a href="https://www.jdon.com/idea/java/java-8-completablefuture-vs-parallel-stream.html" target="_blank" rel="noopener">Java8的completablefuture和parallel stream比较 -解道Jdon</a></p><ul><li>可以上面的代码,  ParallelStream 使用的 forkJoinPool, 处理过程会回到主线程调用 task（因为 forkJoinPool 使用了分治+递归，要回到主线程）</li><li>CompletableFuture 默认也是使用 forkJoinPool 的线程池, 但没有回到主线程</li><li>因为 CompletableFuture 默认使用 forkJoinPool 线程池，所以线程池大小有限制 = processor 的数量，当然 CompletableFuture 也可以自己指定线程池，如果不是 CPU 密集而是 IO 密集的任务，最好是指定自己的线程池（ CPU Processor 的 2~3 倍 ）</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Callable&lt;/code&gt; 接口类似于 Runnable，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，&lt;code&gt;Callable&lt;/code&gt; 功能更强大一些，被线程执行后，可以返回结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 有些类似 &lt;code&gt;Runnable&lt;/code&gt;, 它们都是接口, 前者需要实现 &lt;code&gt;V call()&lt;/code&gt;, 后者需要实现 &lt;code&gt;void run()&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 需要用 &lt;code&gt;FutureTask&lt;/code&gt; 包装一下, &lt;code&gt;FutureTask&lt;/code&gt; 提供了 &lt;code&gt;get()&lt;/code&gt; 方法, 可以获取执行结果;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;FutureTask 需要通过 Thread 执行: 通过构造器 &lt;code&gt;Thread(FutureTask)&lt;/code&gt; 创建 Thread 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;结果通过 &lt;code&gt;FutureTask.get&lt;/code&gt; 获取,  &lt;code&gt;FutureTask&lt;/code&gt; 实现了 &lt;code&gt;Future&lt;/code&gt; 接口, 通过 &lt;code&gt;FutureTask&lt;/code&gt; 和 &lt;code&gt;Future&lt;/code&gt; 类型引用都可以调用 &lt;code&gt;get()&lt;/code&gt; , &lt;code&gt;cancel()&lt;/code&gt; , &lt;code&gt;isDone()&lt;/code&gt; , &lt;code&gt;isCancelled()&lt;/code&gt; 等方法;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 也可以放入线程池,  &lt;code&gt;ExecutorService.submit(Callable)&lt;/code&gt; 把 Callable 提交到线程池并返回 Future ;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JUC" scheme="https://beefyheisenberg.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.06a.JUC-执行器-线程池</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.06a.JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.06a.JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-05-24T10:10:50.164Z</published>
    <updated>2023-05-24T10:10:50.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池相关类和方法"><a href="#线程池相关类和方法" class="headerlink" title="线程池相关类和方法"></a>线程池相关类和方法</h1><ul><li>ExecutorService: Java线程池的接口, 提供了如下方法:<ul><li><code>void execute(Runnable command)</code> 执行 Ruannable 类型的任务</li><li><code>Future&lt;?&gt; submit(Runnable task)</code> 可用来提交 Callable 或 Runnable 任务，并返回代表此任务的 Future 对象</li><li><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>: 同上</li><li><code>void shutdown()</code> : 关闭线程池，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。最终调用了每个线程的 <code>interrupt()</code></li><li><code>void shutdownNow()</code> : 关闭线程池, 中断正在处理任务的线程，也不处理阻塞队列中已保存的任务。最终调用了每个线程的 <code>interrupt()</code></li><li><code>boolean isShutdown()</code></li></ul></li></ul><p>几种常见的线程池实现类：</p><ul><li>ThreadPoolExecutor: 实现了ExecutorService接口, 通用线程池</li><li>ScheduledExecutorService: 也实现了 ExecutorService 接口, 它的 <code>schedule()</code> 方法用来执行定时任务</li></ul><p>Executors 是线程池的工厂类, 用于创建线程池:</p><ul><li><code>ExecutorService newCachedThreadPool()</code>: 创建一个可缓存线程池，队列容量固定是1（可以认为没有队列），线程数会一直增长（如果没有空闲线程），如果线程空闲超过60s会被回收；</li><li><code>ExecutorService newFixedThreadPool(int nThreads)</code>: 创建一个定长线程池，超出的线程会进入等待队列，队列是无限大的；</li><li><code>ExecutorService newSingleThreadExecutor()</code>: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li><li><code>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code>: 创建一个定长线程池，支持定时及周期性任务执行。</li></ul><p>示例代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tpoolTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ExecutorService cachedPool = Executors.newCachedThreadPool();</span><br><span class="line">  ExecutorService fixedPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">  ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// execute()无返回值</span></span><br><span class="line">  cachedPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/*doSomething*/</span> &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  cachedPool.shutdown();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// submit()有返回值</span></span><br><span class="line">  <span class="comment">// labmda写法</span></span><br><span class="line">  Futrue&lt;String&gt; futrue = fixedPool.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  String ret = futrue.get();</span><br><span class="line">  fixedPool.shutdownNow();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// schedule()增加定时任务</span></span><br><span class="line">  schedulePool.schedule(() -&gt; &#123;</span><br><span class="line">System.out.print(<span class="string">"scheduled task"</span>);</span><br><span class="line">&#125;, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">  );</span><br><span class="line">  schedulePool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>工厂类 <code>Executors</code> 包装了对 <code>ThreadPoolExecutor</code> 构造方法的调用, 隐藏了很多创建线程池的细节, 所以在并发严格的情况下, 最好的方式还是直接调用 <code>ThreadPoolExecutor</code> 构造方法创建线程池.</p><p>ThreadPoolExecutor的构造函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造器中各个参数的含义:</strong></p><ul><li><p><strong>corePoolSize</strong>: （线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到线程数大于 corePoolSize 时就不再创建。如果调用了线程池的 <code>prestartAllCoreThreads()</code> 方法，线程池会提前创建并启动所有基本线程。</p></li><li><p><strong>workQueue</strong>: 一个阻塞队列，用来存储等待执行的任务。当线程数已经大于 corePoolSize 时, 再向线程池添加任务，会把任务放入该队列中。阻塞队列有以下几种选择：</p><ul><li><code>ArrayBlockingQueue</code>：基于数组结构的 <strong>有界阻塞队列</strong>，此队列按 FIFO（先进先出）排序元素。因为入队/出队操作的同步都用同一个 lock 对象，所以生产者和消费者无法同时进行，所以吞吐量低；</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的 <strong>无界阻塞队列</strong>，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 <code>ArrayBlockingQueue</code>。 <strong>Executors.newFixedThreadPool()</strong> 使用了这个队列。</li><li><code>SynchronousQueue</code>：一个不存储元素的 <strong>有界阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态（可以这样来理解：生产者和消费者互相等待对方，握手然后一起离开），吞吐量通常要高于 <code>LinkedBlockingQueue</code>。<strong>Executors.newCachedThreadPool()</strong> 使用了这个队列。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级的 <strong>无限阻塞队列</strong>，此队列按优先级排序元素。</li></ul></li><li><p><strong>maximumPoolSize</strong>: 线程池最大容量（池+队列里的线程数）。</p><ul><li>如果是 <code>LinkedBlockingQueue</code> 这种 <em>近似无界的队列</em>，<code>maximumPoolSize</code> 没有效果；</li><li>如果是 <code>ArrayBlockingQueue</code> 这种 <em>有界阻塞队列</em>，如果队列满了，并且已创建的线程数小于 <code>maximumPoolSize</code>，则线程池会再创建新的线程执行任务，直到总线程数超过 <code>maximumPoolSize</code>。</li></ul></li><li><p><strong>keepAliveTime</strong>: 工作线程空闲后，保持存活的时间。线程池会一直终止空闲超过 keepAliveTime 的线程，直到线程池中的线程数不超过 <code>corePoolSize</code>。</p></li><li><p><strong>unit</strong>: keepAliveTime 的单位</p></li><li><p><strong>handler</strong>: 当队列和线程池都满了（<code>maximumPoolSize</code>），说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。</p><ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ul></li></ul><p>➤ 区分 coreSize、queueSize、maxSize，当提交一个新任务到线程池时，线程池的处理流程如下：</p><ol><li>首先线程池判断<strong>基本线程池（corePoolSize）</strong> 是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li><li>其次线程池判断<strong>工作队列（workQueue）</strong> 是否已满？这一步尝试队列能否 offer 进新任务，如果 offer 失败（队列满），则进入下个流程。</li><li>最后线程池判断<strong>整个线程池（maximumPoolSize）</strong> 是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li></ol><p>➤ 再回过来看 Executors 提供的几种工厂方法:</p><blockquote><ul><li><code>newCachedThreadPool()</code>: corePoolSize 为0, maximumPoolSize 为 INT.Max, 队列使用 SynchronousQueue 不存储线程, 所以有新任务提交时, 如果没有空闲的线程, 则继续创建新的线程, 直到线程数达到 <code>INT.Max</code>. 空闲时间超过 60s 的线程会被回收；</li><li><code>newFixedThreadPool(int nThreads)</code>: corePoolSize 和 maximumPoolSize 都是 nThreads, 意味着线程池大小从 0 会增长到 coreSize, 队列是近似无界队列 LinkedBlockingQueue, 可以一直接收新任务, keepAliveTime=0 意味着不会回收空闲线程</li><li><code>newSingleThreadExecutor()</code>: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul></blockquote><p>上面提到的几种线程池，都有不足：</p><ul><li>使用 <code>newCachedThreadPool()</code> 的问题在于, 如果没有控制好任务大小(所有线程一直在忙) 线程数会一直增长（<code>maxPoolSize</code> 是 <code>Integer.MAX_VALUE</code>). 只有线程空闲的时候才有机会减少线程数.</li><li>使用 <code>newFixedThreadPool()</code> 的问题在于, 虽然工作线程数是固定的, 但是等待队列大小是 <code>Integer.MAX_VALUE</code>,</li></ul><p>这两种线程池都有可能因为创建大量线程导致 OOM. 所以<strong>不建议使用 Executors 直接创建线程池</strong></p><h2 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h2><p>流程： <code>execute –&gt; addWorker() –&gt;runWorker()</code></p><p>向线程池提交 Runnable,  会调用到线程池的 <code>addWorker()</code>，这个方法里会将工作线程封装成 Worker 类，<br>在 ReentrantLock 锁的保证下，把 Woker 实例插入到 HashSet 后，并启动 Woker 中的线程。<br>从 Woker 类的构造方法实现可以发现: 线程工厂在创建线程 thread 时，将 Woker 实例本身 this 作为参数传入，当执行 start 方法启动线程 thread 时，本质是执行了 Worker 的 runWorker 方法。 </p><p>Worker 在执行完任务(firstTask)后，还会通过 <code>runWorker()</code> 无限循环获取工作队列里的任务来执行:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行当前task或从队列里取出新的task</span></span><br><span class="line">      <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        beforeExecute(wt, task);</span><br><span class="line">        task.run(); <span class="comment">// 执行Runnable.run()</span></span><br><span class="line">        afterExecute(task, thrown);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>线程池的 <code>shutdown</code> 或者 <code>shutdownNow</code> 方法来关闭线程池。</p><ul><li><code>shutdown</code> 方法将执行平缓的关闭过程：线程池状态设置为 SHUTDOWN，不接收新的任务，同时等待已提交的任务执行完成，包括哪些在队列中的任务；</li><li><code>shutdownNow</code> 方法将执行粗暴的关闭过程：线程池状态设置为 STOP，不接收新的任务，它将尝试取消（Interrupt）所有运行中的任务，并且清空等待队列（未开始的任务也不会再执行）；</li></ul><h1 id="优化线程池"><a href="#优化线程池" class="headerlink" title="优化线程池"></a>优化线程池</h1><p>线程池参数的解析和使用建议:</p><ul><li>线程池大小:<ul><li>如果是 <strong>计算密集</strong> 任务，一般设置为 cpu 核心数 （ForkJoin 的 common 线程池）</li><li>如果是 <strong>IO 密集</strong> 任务一般设置为核心数2~3倍（Tomcat 的 Poller 线程池 &amp; Netty 的 sub-Reactor 线程池）</li><li>业务线程池：视业务耗时和吞吐量而定（Tomcat 默认工作线程池 size = 200）</li></ul></li><li><p>预热线程池：默认情况下，核心工作线程值在初始的时候被创建，当新任务来到的时候被启动，但是我们可以通过重写 <code>prestartCoreThread</code> 或 <code>prestartCoreThreads</code> 方法来改变这种行为。通常场景我们可以在应用启动的时候来 WarmUp 核心线程，从而达到任务过来能够立马执行的结果，使得初始任务处理的时间得到一定优化。</p></li><li><p>队列的选择：</p><ul><li>无界队列：使用无界队列如<code>LinkedBlockingQueue</code>没有指定最大容量的时候，将会引起当核心线程都在忙的时候，新的任务被放在队列上。<ul><li>因此，永远不会有大于 <code>corePoolSize</code> 的线程被创建，因此 <code>maximumPoolSize</code> 参数将失效。</li><li>这种策略比较适合所有的任务都不相互依赖，独立执行。如 Web 服务器中，每个线程独立处理请求。</li><li>但是当任务处理速度小于任务进入速度的时候会引起队列的无限膨胀。</li></ul><ul><li>先级不同的任务可以使用优先级队列 <code>PriorityBlockingQueue</code> 来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</li></ul></li><li>有界队列：有界队列如 <code>ArrayBlockingQueue</code> 帮助限制资源的消耗，但是不容易控制。队列长度和 <code>maximumPoolSize</code> 这两个值会相互影响，<ul><li>使用 <em>大的队列</em> 和小 <code>maximumPoolSize</code> 会降低 CPU 占用、操作系统资源、上下文切换的消耗，但是会降低吞吐量，如果任务被频繁的阻塞如 IO 线程，系统其实可以调度更多的线程。</li><li>使用 <em>小的队列</em> 通常需要大 <code>maximumPoolSize</code>，从而使得 CPU 更忙一些，但是又会增加线程调度的消耗。</li><li>总结一下：是IO密集型可以考虑 <em>多些线程+小的队列</em> 来平衡CPU的使用，CPU密集型可以考虑 <em>少些线程+大的队列</em> 减少线程调度的消耗。</li></ul></li></ul></li><li>合理的拒绝策略: @todo</li></ul><h1 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h1><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li><li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+ getActiveCount：获取活动的线程数。</li></ul><p>通过扩展线程池进行监控。通过继承线程池并重写线程池的b<code>eforeExecute</code>，<code>afterExecute</code>和<code>terminated</code>方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</p><p>@ref:</p><ul><li><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="noopener">聊聊并发（三）——JAVA线程池的分析和使用</a></li><li><a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="noopener">如何合理地估算线程池大小？ | 并发编程网 – ifeve.com</a></li><li><a href="https://www.zhihu.com/question/38128980" target="_blank" rel="noopener">java线程池大小为何会大多被设置成CPU核心数+1？ - 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;线程池相关类和方法&quot;&gt;&lt;a href=&quot;#线程池相关类和方法&quot; class=&quot;headerlink&quot; title=&quot;线程池相关类和方法&quot;&gt;&lt;/a&gt;线程池相关类和方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ExecutorService: Java线程池的接口, 提供了如下方法:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void execute(Runnable command)&lt;/code&gt; 执行 Ruannable 类型的任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future&amp;lt;?&amp;gt; submit(Runnable task)&lt;/code&gt; 可用来提交 Callable 或 Runnable 任务，并返回代表此任务的 Future 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task)&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void shutdown()&lt;/code&gt; : 关闭线程池，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。最终调用了每个线程的 &lt;code&gt;interrupt()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void shutdownNow()&lt;/code&gt; : 关闭线程池, 中断正在处理任务的线程，也不处理阻塞队列中已保存的任务。最终调用了每个线程的 &lt;code&gt;interrupt()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isShutdown()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几种常见的线程池实现类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ThreadPoolExecutor: 实现了ExecutorService接口, 通用线程池&lt;/li&gt;
&lt;li&gt;ScheduledExecutorService: 也实现了 ExecutorService 接口, 它的 &lt;code&gt;schedule()&lt;/code&gt; 方法用来执行定时任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Executors 是线程池的工厂类, 用于创建线程池:&lt;/p&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JUC" scheme="https://beefyheisenberg.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.05c.JUC-Collections（并发集合）</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05d.JUC-Collections/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05d.JUC-Collections/</id>
    <published>2023-05-24T10:10:50.157Z</published>
    <updated>2023-05-24T10:10:50.158Z</updated>
    
    <content type="html"><![CDATA[<p>旧的线程安全的集合: 任何集合类都可以通过使用同步包装器变成线程安全的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; synchArrayList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt; synchMap = Collections.synchronizedList(<span class="keyword">new</span> HasMap&lt;K,V&gt;());</span><br></pre></td></tr></table></figure><p><code>java.util.concurrent</code>包提供了线程安全的集合, 继承关系如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阻塞队列</span><br><span class="line">  |- BlockingQueue（单向队列）</span><br><span class="line">       |- ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</span><br><span class="line">       |- LinkedBlockingQueue: 一个由链表结构组成的有界阻塞队列</span><br><span class="line">       |- PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列</span><br><span class="line">       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列</span><br><span class="line">  |- BlockingDeque（双向队列）</span><br><span class="line">       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列</span><br><span class="line"></span><br><span class="line">非阻塞队列</span><br><span class="line">  |- ConcurrentLinkedQueue</span><br><span class="line">  |- ConcurrentLinkedDeque</span><br><span class="line"></span><br><span class="line">Map</span><br><span class="line">  |- ConcurrentHashMap</span><br><span class="line">  |- ConcurrentSkipListMap</span><br><span class="line"></span><br><span class="line">Set</span><br><span class="line">  |- ConcurrentSkipListSet</span><br></pre></td></tr></table></figure><h1 id="Queue-amp-Deque"><a href="#Queue-amp-Deque" class="headerlink" title="Queue &amp; Deque"></a>Queue &amp; Deque</h1><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:center">是否阻塞</th><th style="text-align:center">是否有界</th><th style="text-align:center">队列长度</th><th style="text-align:center">内部实现</th></tr></thead><tbody><tr><td style="text-align:left">ArrayBlockingQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">构造器指定</td><td style="text-align:center">循环数组,FIFO</td></tr><tr><td style="text-align:left">LinkedBlockingQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">构造器指定, 默认Int.Max</td><td style="text-align:center">链表,FIFO</td></tr><tr><td style="text-align:left">LinkedBlockingDeque</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">构造器指定, 默认Int.Max</td><td style="text-align:center">双向链表,FIFO</td></tr><tr><td style="text-align:left">SynchronousQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">有界</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">PriorityBlockingQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">构造器指定, 默认11, 无限扩容</td><td style="text-align:center">二叉堆</td></tr><tr><td style="text-align:left">DelayQueue</td><td style="text-align:center">阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">初始empty, 无限扩容</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ConcurrentLinkedQueue</td><td style="text-align:center">非阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">初始empty, 无限扩容</td><td style="text-align:center">单向链表</td></tr><tr><td style="text-align:left">ConcurrentLinkedDeque</td><td style="text-align:center">非阻塞</td><td style="text-align:center">无界</td><td style="text-align:center">初始empty, 无限扩容</td><td style="text-align:center">双向链表</td></tr></tbody></table><p>线程安全的队列可以分为 <strong>阻塞队列</strong> , <strong>非阻塞队列</strong>, 按照是否可无限扩容分为 <strong>有界队列</strong> , <strong>无界队列</strong> :</p><p>阻塞队列: </p><ul><li>当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。</li><li>阻塞队列一般是用锁(例如 <code>BlockingQueue</code>)来实现,阻塞队列继承自接口<code>BlockingQueue</code>, 常用的有: <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>LinkedBlockingDeque</code>;</li></ul><p>非阻塞队列是指:</p><ul><li>非阻塞队列一般是用 <code>CAS</code> 实现的”Lock-Free”方法,</li><li>非阻塞队列主要有: <code>ConcurrentLinkedQueue</code>, <code>ConcurrentLinkedDeque</code>;</li></ul><p>有界/无界: 无界队列可以无限扩容，一般链表实现的队列属于无界</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列一般使用condition实现消费者和生产者的”通讯”。<br>比如当生产者往满的队列里添加元素时会阻塞住，当消费者消费了队列中的元素后，会通过condition通知生产者当前队列可用。</p><p>BlockingQueue接口方法有put/take：</p><p><strong>阻塞方法：</strong></p><ul><li>put(E o)：将元素添加到此队列尾，如果队列满将一直阻塞，可以响应中断。</li><li>take()：检索并移除此队列的头部，如果队列为空则一直阻塞，可以响应中断。</li></ul><p><strong>不阻塞且抛异常的方法：</strong></p><ul><li>add(E o)：将元素添加到此队列中，如果队列已满不会阻塞，直接抛出 IllegalStateException</li><li>remove()： 移除队列头部的元素，如果队列为空不会阻塞，直接抛出 IllegalStateException</li></ul><p><strong>不阻塞且带返回值的方法：</strong></p><ul><li>offer(E o)： 将元素添加到队列，不阻塞，成功返回true，失败返回false；</li><li>offer(E o, long timeout, TimeUnit unit)： 带等待时间的offer方法，如果队列已满，将等待指定的时间；</li><li>poll(long timeout, TimeUnit unit)： 返回队列的头部并移除，如果队列为空，则等待指定等待的时间。如果取不到返回null；</li></ul><p>其他方法：</p><ul><li><code>drainTo(Collection&lt;? super E&gt; c)</code>： 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</li><li><code>drainTo(Collection&lt;? super E&gt; c,int maxElements)</code>： 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中</li><li><code>remainingCapacity()</code>： 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的元素数量；如果没有内部限制，则返回 Integer.MAX_VALUE。</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul><li><p>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序</p></li><li><p>构造器 <code>ArrayBlockingQueue(int)</code> 都要指定数组初始大小，并且大小不再扩展。</p></li><li><p>默认情况下 ArrayBlockingQueue 不保证访问者公平的访问队列，所谓“公平访问队列”是指：当队列可用时，可以按照阻塞的先后顺序访问队列。我们可以使用以下代码创建一个“公平的”阻塞队列：<code>ArrayBlockingQueue fairQueue = new  ArrayBlockingQueue(1000,true);</code></p></li><li><p>ArrayBlockingQueue 内部实现： </p><ul><li>一个 ReentrantLock，阻塞方法，无论读写都是用这个 lock；</li><li>两个 Condition(notFull、notEmpty) 管理队列满或空时的阻塞状态；</li></ul><p>在「生产者」+「消费者」情景下，因为读写都是共用同一个锁对象，由此也意味着两者无法真正并行运行，ArrayBlockingQueue 的吞吐量不如 LinkedBlockingQueue</p></li></ul><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul><li>LinkedBlockingQueue 是链表实现的“有界”的阻塞队列。构造函数可以指定最大长度，如果不指定则最大长度默认为 <code>Integer.MAX_VALUE</code></li><li>内部基于链表实现，<ul><li>两个指针：head 和 last 指向链表头尾；</li><li>由两个锁（takeLock 与 putLock），出队和入队时加锁</li><li>两个 Condition(notFull、notEmpty) ，管理队列满或空时的阻塞状态。</li></ul></li></ul><p>由于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>入队代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队尾插入指定的元素.</span></span><br><span class="line"><span class="comment"> * 如果队列已满，则阻塞线程.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();            <span class="comment">// 获取“入队锁”</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;   <span class="comment">// 队列已满, 则线程在notFull上等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);                      <span class="comment">// 将新结点添加到到“链表尾”</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * count 表示的队列中元素个数.</span></span><br><span class="line"><span class="comment">         * getAndIncrement 返回旧值，并+1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = count.getAndIncrement();      <span class="comment">// c表示入队前，链表中元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) </span><br><span class="line">            notFull.signal();             <span class="comment">// 入队后，链表队列未满, 则唤醒一个“入队线程”</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)                    <span class="comment">// c是添加该元素前，链表中元素的数量</span></span><br><span class="line">        signalNotEmpty();          <span class="comment">// 如果之前c=0，有线程可能阻塞在get上，需要唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以入队为例，新元素入队后，</p><ul><li>如果链表还没满，需要唤醒 notFull 条件上的“入队线程”；</li><li>如果新元素入队前，链表中元素数量为 0，说明可能有读线程阻塞在 get 方法（也即 notEmpty 条件）；</li></ul><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><ul><li>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。构造函数可以指定最大长度，队列的默认和最大长度为<code>Integer.MAX_VALUE</code></li><li>相比其他的阻塞单向队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法</li></ul><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 特性，在某次添加元素后必须等待其他线程取走后才能继续添加，可以认为 SynchronousQueue 是一个缓存值为1的阻塞队列（虽然是属于无界的）；</p><p>但是 isEmpty()方法永远返回是true，remainingCapacity() 方法永远返回是0，remove()和removeAll() 方法永远返回是false，iterator()方法永远返回空，peek()方法永远返回null。</p><p>SynchronousQueue 没有使用 lock，而是使用了 CAS（一种名为“<a href="https://link.segmentfault.com/?enc=Tj6XDSrrCjTPHQgG%2FqNn1g%3D%3D.PcsHG44N43bT7Gbg1A%2FzsHpv9c1PLBoMIphV424sQob%2BH9QvvDu3Gni0Xpo5W9o0BCLXPuODRuePgFV32u7rTRtugAU2PjTgpe9R6yebEM4%3D" target="_blank" rel="noopener">Dual stack and Dual queue</a>”的无锁算法实现。）</p><p>SynchronousQueue 有两种不同的模式：公平模式 or 非公平模式（默认），</p><ul><li>如果采用公平模式：这种模式下 transferer 被初始化<strong>队列</strong>，如果队列为空，先发起 get 的线程可以先从阻塞中被通知；</li><li>如果是非公平模式：这种模式下 transferer 被初始化<strong>栈</strong>，如果队列为空，先发起 get 的线程后通知；</li></ul><p>@ref: <a href="https://segmentfault.com/a/1190000016359551" target="_blank" rel="noopener">Java多线程进阶（三五）—— J.U.C之collections框架：SynchronousQueue - 透彻理解Java并发编程 - SegmentFault 思否</a></p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一种<strong>无界阻塞队列</strong>，在构造的时候可以指定队列的初始容量。具有如下特点：</p><ul><li><p>PriorityBlockingQueue 与之前介绍的阻塞队列最大的不同之处就是：它是一种<strong>优先级队列</strong>，也就是说元素并不是以 FIFO 的方式出/入队，而是以按照权重大小的顺序出队，所以队列中的元素必须是可以比较的，元素必须实现 <code>Comparable</code> 接口；</p></li><li><p>PriorityBlockingQueue 是真正的无界队列（仅受内存大小限制），它不像 ArrayBlockingQueue 那样构造时必须指定最大容量，也不像 LinkedBlockingQueue 默认最大容量为 <code>Integer.MAX_VALUE</code>，虽然 PriorityBlockingQueue 也支持构造函数指定大小，但因为自动扩容所以元素数量不会受限制；</p></li><li><p>由于 PriorityBlockingQueue 无界队列，所以<strong>插入元素</strong>永远不会阻塞线程；但是当队列为空时，取出操作（take）会阻塞线程； </p></li></ul><p>内部实现：</p><ul><li>PriorityBlockingQueue 底层是一种<strong>基于数组实现的堆结构</strong>，排序等功能的实现与 PriorityQueue 类似；</li><li>一个 ReentrantLock 锁对象，一个 notEmpty 条件对象</li></ul><p>@ref <a href="https://segmentfault.com/a/1190000016353839" target="_blank" rel="noopener">Java多线程进阶（三四）—— J.U.C之collections框架：PriorityBlockingQueue - SegmentFault 思否</a></p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p><code>DelayQueue</code> 是 JDK1.5时，随着J.U.C 包一起引入的一种阻塞队列，它实现了 BlockingQueue 接口，底层基于已有的<strong>PriorityBlockingQueue</strong>实现：</p><ul><li>队列中的元素必须实现 <strong>Delayed</strong> 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。 Delayed 接口继承了 <strong>Comparable</strong> 接口，必须实现 compareTo 来指定元素的顺序。</li><li>由于DelayQueue内部委托了PriorityBlockingQueue对象来实现所有方法，所以能以堆的结构维护元素顺序，这样剩余时间最小的元素就在堆顶，<strong>每次出队其实就是删除剩余时间≤0的最小元素</strong>。</li></ul><p>我们可以将 DelayQueue 运用在以下应用场景：</p><ul><li>定时任务调度。使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。</li></ul><p>实现：</p><ul><li>DelayQueue 的主要成员：<ul><li>ReentrantLock lock： 保证线程安全</li><li>Thread leader：最早调用 get 并阻塞的线程</li><li>Condition available：条件对象，get 并阻塞的线程在此等待</li></ul></li><li>因为是最小堆，所以堆顶是剩余时间最小的元素，每次 take 时：<ul><li>如果堆顶时间未到，调用 get 的线程阻塞在 available；</li><li>如果堆顶元素时间到了，则取出堆顶；</li></ul></li></ul><p>实际的 put / take 更复杂，因为涉及到 Leader-Follower 机制：</p><ul><li>leader 是最早调用 take 并阻塞的线程；loader 阻塞在 available（条件对象），调用的是带超时时间的 <code>awaitNanos(delay)</code> </li><li>其他后续来 take 的线程也在 available 阻塞，用的是无限阻塞；</li><li>loader 醒来后，先检测队头的节点是否到期，如果是则取走队头，并唤醒其他在 available 上的第一个线程，线程醒来（是在 take 函数的 <code>await()</code>），</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队首出队元素.</span></span><br><span class="line"><span class="comment"> * 如果队首元素（堆顶）未到期或队列为空, 则阻塞线程.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            E first = q.peek();     <span class="comment">// 读取队首元素</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)      <span class="comment">// CASE1: 队列为空, 直接阻塞</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;                  <span class="comment">// CASE2: 队列非空</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)      <span class="comment">// CASE2.0: 队首元素已过期</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();  <span class="comment">// 取走队头元素，还要进入第2个finally</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行到此处说明队列非空, 且队首元素未过期</span></span><br><span class="line">                first = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)         <span class="comment">// CASE2.1: 已存在leader线程</span></span><br><span class="line">                    available.await();      <span class="comment">// 非 leader线程，无限期 await</span></span><br><span class="line">                <span class="keyword">else</span> &#123;                      <span class="comment">// CASE2.2: 不存在leader线程</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;    <span class="comment">// 将当前线程置为leader线程</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay); <span class="comment">// leader使用带时间的 await</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 第 1 个 finally</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 第 2 个 finally</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>) <span class="comment">// 不存在leader线程, 则唤醒一个其它出队线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><ul><li>ConcurrentLinkedQueue是一个基于链接节点的无边界的线程安全队列，它采用FIFO原则对元素进行排序。采用“wait-free”算法（即CAS）来实现的。</li><li>ConcurrentLinkedQueue的结构是单向链表和head/tail两个指针，因为入队时需要修改队尾元素的next指针，以及修改tail指向新入队的元素两个CAS动作无法原子，所以需要的特殊的算法，见：<br><a href="https：//www.ibm.com/developerworks/cn/java/j-jtp04186/">Java 理论与实践： 非阻塞算法简介</a></li></ul><h3 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h3><ul><li>ConcurrentLinkedDeque是一种基于双向链表的无界链表。</li><li>与大多数集合类型不同，其size方法不是一个常量操作。因为链表的异步性质，确定当前元素的数量需要遍历所有的元素，所以如果在遍历期间有其他线程修改了这个集合，size方法就可能会报告不准确的结果。</li><li>批量的操作：包括添加、删除或检查多个元素，比如addAll()、removeIf()或者removeIf() 或forEach()方法，这个类型并不保证以原子方式执行。由此可见如果想保证原子访问，不得使用批量操作的方法。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>ArrayList 底层使用数组，实现了 List 接口，并且提供了 get(i) set(i)这种随机访问的方法，<br>线程安全的版本是 Vector，通过 Synchronized 整个方法实现了线程安全，但是性能太差，<br>CopyOnWriteArrayList 是一种线程安全的 ArrayList，更适合读多写少的场景</p><p>实现：</p><ul><li>主要成员：Object 数组、ReentrantLock 锁</li><li>get：不加锁</li><li>add/remove：这些会更改数组的方法，都是用 ReentrantLock 加锁，使用 <code>Arrays.copyOf</code> 将旧内容拷贝入新数组，然后替换掉旧数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();     <span class="comment">// 旧数组</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);    <span class="comment">// 复制并创建新数组</span></span><br><span class="line">        newElements[len] = e;               <span class="comment">// 将元素插入到新数组末尾</span></span><br><span class="line">        setArray(newElements);              <span class="comment">// 内部array引用指向新数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写操作因为要 copy 整个旧数组，代价还是较高，适用于写非常少的场景</p><p>@ref:</p><ul><li><a href="https://juejin.im/post/5aeeb55f5188256715478c21" target="_blank" rel="noopener">并发容器之CopyOnWriteArrayList - 掘金</a></li><li><a href="https://blog.csdn.net/h525483481/article/details/80347485" target="_blank" rel="noopener">实现一个简单的阻塞队列_Java_h525483481的专栏-CSDN博客</a></li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h2><p>ConcurrentSkipListSet的实现非常简单，其内部引用了一个ConcurrentSkipListMap对象，所有API方法都是调用了ConcurrentSkipListMap。<br>ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集。但是：<br>第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的；<br>第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的；</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="ConcurrentHashMap（JDK-1-8）"><a href="#ConcurrentHashMap（JDK-1-8）" class="headerlink" title="ConcurrentHashMap（JDK 1.8）"></a>ConcurrentHashMap（JDK 1.8）</h2><p>在 JDK1.7之前，ConcurrentHashMap 是通过分段锁机制来实现的，所以其最大并发度受 Segment 的个数限制。因此，在 JDK1.8中，ConcurrentHashMap 的实现原理摒弃了这种设计，而是选择了与 HashMap 类似的数组+链表+红黑树的方式实现，而加锁则采用 CAS 和 synchronized 实现。</p><p>1.8 中 ConcurrentHashMap 使用了 CAS + Synchronized 两种方式，put 流程如下：</p><ul><li>计算 index，方式同 HashMap： index = hash &amp; (n -1 )，==思考这样做的好处是？==</li><li>如果 table[i] = null, CAS 插入这个位置</li><li>如果 table[i] 是链表 or 红黑树，则 synchronized 锁住 table[i]，也即此处的 Node 对象 </li><li>如果 table[i].hash = MOVED, 说明此为 ForwardingNode 节点，则调用 transfer 进行迁移</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际的插入操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent true:仅当key不存在时,才插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());  <span class="comment">// 再次计算hash值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用链表保存时，binCount记录table[i]这个桶中所保存的结点数；</span></span><br><span class="line"><span class="comment">     * 使用红黑树保存时，binCount==2，保证put后更改计数值时能够进行扩容检查，同时不触发红黑树化操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;  <span class="comment">// 自旋插入结点，直到成功</span></span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// CASE1: 首次初始化table —— 懒加载</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123; <span class="comment">// CASE2:table[i]无数据</span></span><br><span class="line">            <span class="comment">// 注意下上面table[i]的索引i的计算方式：key的hash值 &amp; (table.length-1)</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>))) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)  <span class="comment">// CASE3: 发现ForwardingNode结点，说明此时table正在扩容，则尝试协助数据迁移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// CASE4: 出现hash冲突,也就是table[i]桶中已经有了结点</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;              <span class="comment">// 锁住table[i]结点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;   <span class="comment">// 再判断一下table[i]是不是第一个结点, 防止其它线程的写修改</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;          <span class="comment">// CASE4.1: table[i]是链表结点</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到“相等”的结点，判断是否需要更新value值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;     <span class="comment">// “尾插法”插入新结点</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key,</span><br><span class="line">                                    value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;  <span class="comment">// CASE4.2: table[i]是红黑树结点</span></span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">// 链表长度 &gt; 8</span></span><br><span class="line">                    treeifyBin(tab, i);     <span class="comment">// 链表 -&gt; 红黑树 转换</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)         <span class="comment">// 表明本次put操作只是替换了旧值，不用更改计数值</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);             <span class="comment">// 计数值加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 扩容 tryPresize() 实现：</p><ul><li>通过 CAS 保证只能由一个线程进行桶数组的扩容；</li><li>对链表进行红黑树转换的时候（触发阈值 8 ）, 如果桶数组小于 64，则不进行红黑树转换，而是进行扩容，把数组长度扩大到原来的两倍。</li></ul><p>➤ 迁移 transfer() 的实现：</p><ul><li>transfer 可以多个线程并发执行；</li><li>因为桶数组和计算 index（参考 hashMap ）的特性，扩容前和扩容后的位置只有 2 种可能，在原位置 or 原位置+oldCap，这种处理方式非常利于扩容时多个线程同时进行的数据迁移操作，因为旧 table 的各个桶中的结点迁移不会互相影响，所以就可以用分治的方式，将整个 table 数组划分为很多部分，每一部分包含一定区间的桶，每个数据迁移线程处理各自区间中的结点；</li></ul><p>➤ 计算元素个数 sum() 的实现：</p><ul><li>类似 LongAdder，一个 long 型的 base，另外是 cell[] 数组，</li><li>如果 CAS base 成功，直接在 base 上累加，如果 CAS 失败了，也即发生冲突，线程会根据自己的 hash，找到 cell[i]，然后对该 cell 进行 CAS+1</li><li>计算 sum 时，和 LongAdder 一样，也是一个瞬时值</li></ul><p>@ref：</p><ul><li><a href="https://segmentfault.com/a/1190000016096542" target="_blank" rel="noopener">Java多线程进阶（二三）—— J.U.C之collections框架：ConcurrentHashMap(1) 原理 - 透彻理解Java并发编程 - SegmentFault 思否</a></li><li><a href="https://segmentfault.com/a/1190000016124883" target="_blank" rel="noopener">Java多线程进阶（二四）—— J.U.C之collections框架：ConcurrentHashMap(2) 扩容 - 透彻理解Java并发编程 - SegmentFault 思否</a></li></ul><h2 id="ConcurrentHashMap（JDK-1-7）"><a href="#ConcurrentHashMap（JDK-1-7）" class="headerlink" title="ConcurrentHashMap（JDK 1.7）"></a>ConcurrentHashMap（JDK 1.7）</h2><ul><li>数据分段存储，每个段有一个写锁（分段锁），当一个线程占用某个段的锁时，其他段也可以正常访问，有效分散了阻塞的概率，而且没有读锁；</li><li>没有读锁是因为put/remove动作是个原子动作(比如put是一个对数组元素/Entry 指针的赋值操作)，读操作不会看到一个更新动作的中间状态；</li><li>每次扩容为原来容量的2倍，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容；</li><li>在获取size操作的时候，不是直接把所有segment的count相加就可以可到整个ConcurrentHashMap大小，也不是在统计size的时候把所有的segment的put、remove、clean方法全部锁住，这种方法太低效。<br>在累加count操作过程中，之前累加过的count发生变化的几率非常小，所有ConcurrentHashMap的做法是先尝试2（RETRIES_BEFORE_LOCK）次通过不锁住Segment的方式统计各个Segment大小，如果统计的过程中，容器的count发生了变化，再采用加锁的方式来统计所有的Segment的大小。</li><li>putIfAbsent(k,v)：当k已经存在时返回已存在的v。</li></ul><p><img src="/images/Java-%E5%B9%B6%E5%8F%91.05d.JUC-Collections-ConcurrentHashMap1.7.png" alt="../_images/Java-并发.05d.JUC-Collections-ConcurrentHashMap1.7.png"></p><p>➤ 内部实现:</p><ul><li><code>concurrencyLevel</code>: 并行级别、也是Segment 数，默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</li></ul><ul><li>实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方, 为什么?</li><li>put操作:<br>  计算桶位置:  i = (table.size-1) &amp; hash<br>  如果 table[i] == null : 用自旋+CAS 改变 table[i] 的值<br>  如果 f = table[i] != null : Synchronized(f)锁住f节点</li><li>size的实现: 类似 LongAdder</li></ul><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><ul><li>JDK6新增的并发优化的SortedMap，以SkipList实现。SkipList是红黑树的一种简化替代方案，是个流行的有序集合算法。Concurrent包选用它是因为它支持基于CAS的无锁算法，而红黑树则没有好的无锁算法。</li><li>ConcurrentSkipListMap 的key是有序的；</li><li>与ConcurrentHashMap相比，ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log(n)，和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出优势。</li><li>它的size()比较特殊，需要遍历所有元素；</li></ul><h1 id="Deprecated-Vector-amp-HashTable"><a href="#Deprecated-Vector-amp-HashTable" class="headerlink" title="Deprecated: Vector &amp; HashTable"></a>Deprecated: Vector &amp; HashTable</h1><p>Vector和HashTable已经被弃用，取而代之的是ArrayList和HashMap，如果要使用线程安全的容器，可以用Collections转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt; syncList = Collections.synchronzedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">Map&lt;K,V&gt; syncMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K,V&gt;());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;旧的线程安全的集合: 任何集合类都可以通过使用同步包装器变成线程安全的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;E&amp;gt; synchArrayList = Collections.synchronizedList(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;E&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;K,V&amp;gt; synchMap = Collections.synchronizedList(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HasMap&amp;lt;K,V&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt;包提供了线程安全的集合, 继承关系如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;阻塞队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |- BlockingQueue（单向队列）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       |- ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       |- LinkedBlockingQueue: 一个由链表结构组成的有界阻塞队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       |- PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |- BlockingDeque（双向队列）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       |- LinkedBlockingDeque: 一个由链表结构组成的双向阻塞队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;非阻塞队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |- ConcurrentLinkedQueue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |- ConcurrentLinkedDeque&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Map&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |- ConcurrentHashMap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |- ConcurrentSkipListMap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  |- ConcurrentSkipListSet&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Queue-amp-Deque&quot;&gt;&lt;a href=&quot;#Queue-amp-Deque&quot; class=&quot;headerlink&quot; title=&quot;Queue &amp;amp; Deque&quot;&gt;&lt;/a&gt;Queue &amp;amp; Deque&lt;/h1&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JUC" scheme="https://beefyheisenberg.github.io/tags/JUC/"/>
    
    <category term="集合" scheme="https://beefyheisenberg.github.io/tags/集合/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.05d.JUC-Sync（同步器）</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05c.JUC-Sync/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05c.JUC-Sync/</id>
    <published>2023-05-24T10:10:50.151Z</published>
    <updated>2023-05-24T10:10:50.151Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch、CyclicBarrier、Semaphore 在 java1.5 被引入，它们也都是基于 AQS 实现的，</p><ul><li>ReentrantLock 是基于 Exclusive（独占），只有一个线程可以执行；</li><li>CountDownLatch、CyclicBarrier、Semaphore 基于 Share(共享)，多个线程可同时执行；</li></ul><h2 id="计数器-CountDownLatch"><a href="#计数器-CountDownLatch" class="headerlink" title="计数器 CountDownLatch"></a>计数器 CountDownLatch</h2><p>CountDownLatch.await 能够使一个线程等待, 直到计数器归于 0 后再继续执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p><p>CountDownLatch 提供了类似计数器的同步手段, 构造器和主要方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造初值=count 的计数器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;  &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">          latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 在这里阻塞直到latch执行过两次countDown()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 也是基于 AQS 实现，但是对于 AQS.state 计数器的使用有区别：</p><ul><li>在 CountDownLatch 中，同步状态 State 表示 CountDownLatch 的计数器的初始值，当 <code>State==0</code> 时，表示无锁状态，且一旦 State 变为 0，就永远处于无锁状态了，此时所有线程在 await 上等待的线程都可以继续执行。  </li><li>而在 ReentrantLock 中，<code>State==0</code> 时，虽然也表示无锁状态，但是只有一个线程可以重置 State 的值。这就是<strong>共享锁</strong>的含义。</li></ul><blockquote><p>其他参考: <a href="http://www.importnew.com/15731.html" target="_blank" rel="noopener">什么时候使用CountDownLatch - ImportNew</a> @ref</p></blockquote><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>Semaphore 翻译成字面意思为 “信号量”，Semaphore 可以控同时访问的任务个数，通过 acquire(int) 获取n个许可，如果没有就等待； release(int) 释放n个许可。</p><ul><li>如果线程 acquire 不到指定资源数（资源=0 或 acquire 的大于剩余资源），线程阻塞</li><li>release 释放许可，并唤醒队列中一个节点（线程）</li></ul><p>Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>; <span class="comment">// 可同时访问资源的最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">protected</span> Object[] items = <span class="keyword">new</span> Object[MAX_AVAILABLE];   <span class="comment">//共享资源</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        available.acquire();</span><br><span class="line">        <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">            available.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> items[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                    used[i] = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ 构造器和主要方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了一个fair表示是否是公平的，即等待时间越久的越先获取许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//释放permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>➤ acquire 代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Semaphore方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//传递参数为1,说明要获取1个信号量资源</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//(1)如果线程被中断,则抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//(2)否则调用Sync子类方法尝试获取,分为公平和非公平策略</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//(3)如果获取失败则放入阻塞队列.然后再次尝试,如果使用则调用park方法挂起当前线程</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquireShared: 由 Sync 子类实现</p><ul><li>公平策略：若队列非空，先入队</li><li>非公平策略：先尝试 CAS state</li></ul><p>tryAcquireShared （公平策略）代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查询是否当前线程节点的前驱节点也在等待获取该资源,有的话直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到 ReentrantLock 对 state 的操作是基于<strong>独占模式</strong>，Semaphore 是基于<strong>共享模式</strong>，二者区别：</p><ul><li>独占模式的 acquire：<ul><li>如果 state = 0 则尝试 CAS(state, 0, 1)</li><li>如果 state &gt; 0 则需要测试 exclusiveThread 是否等于当前线程，是则 state+=1</li></ul></li><li>共享模式的 acquire：<ul><li>CAS(state, available, available-1)，available 是当前的 state 值，表示“available”的许可数量</li></ul></li></ul><p>➤ release：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)arg=1</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(2)尝试释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">//(3)资源释放成功则调用park方法唤醒AQS队列里面最先挂起的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取当前信号量值</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">//将当前信号量值增加releases,这里为增加1</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="comment">//移除处理</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">//使用CAS保证更新信号量值的原子性</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环栅栏-CyclicBarrier"><a href="#循环栅栏-CyclicBarrier" class="headerlink" title="循环栅栏 CyclicBarrier"></a>循环栅栏 CyclicBarrier</h2><p>CyclicBarrier 是一个辅助同步器类，在 JDK1.5时随着J.U.C 一起引入。</p><ul><li>CyclicBarrier 功能类似 CountDownLatch 区别是：<ul><li>CountDownLatch 计数器变为 0 之前，所有调用 await 的线程都需等待，计数器变为 0 后这些线程可以继续执行，但一旦计数器变为 0 就不可重置了；</li><li>CyclicBarrier 构造时同样需要指定计数器 N，工作线程调用 CyclicBarrier.await 后会阻塞，直到 N 个工作线程都调用了 await，这些阻塞的线程才可以继续执行；</li></ul></li><li>两种 await 的方式： CyclicBarrier.await(),  CyclicBarrier.await(timeout,TimeUnit) ，后一种可以设置等待的超时； </li><li>CyclicBarrier.await 可以响应 <strong>InterruptedException</strong>，和 <strong>BrokenBarrierException</strong><ul><li>如果正在 await 的线程 1 被打断，那么线程 1 的 await 抛出 InterruptedException，其他正在 await 的线程抛出 BrokenBarrierException</li><li>如果线程 1 使用带超时的 await，并且超时了，线程 1 的 await 抛出 TimeoutException，其他正在 await 的线程抛出 BrokenBarrierException</li><li>如果有线程调用了 CyclicBarrier.reset，其他正在 await 的线程抛出 BrokenBarrierException</li></ul></li></ul><p>调用了 CyclicBarrier.await 的线程退出等待状态的条件有：1 产生上面几种异常，2 或者达到了 await 的数量</p><p>如图，ABCD 四个线程都到达 Barrier 后，才可以同时“穿过”栅栏<br>![[../_images/Java-并发.05c.JUC-Sync-2023-05-21-1.png]]</p><p>Example:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CyclicBarrier 可以指定一个最后执行的任务</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"全部线程都调用了await，则执行这里"</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> number = i ;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程 Num"</span> + number + <span class="string">" start"</span>);</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 线程在此wait，直到达成条件</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">                    <span class="comment">// 这里应该分别处理 InterruptedException &amp; BrokenBarrierException</span></span><br><span class="line">                    <span class="comment">// 如果使用了带超时的 await，这里还需要捕获 TimeoutException </span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>CyclicBarrier</code> 时，对异常的处理一定要小心，比如线程在到达栅栏前就抛出异常，其它已经到达栅栏的线程会一直等待（因为没有还没有满足总数），最终导致程序无法继续向下执行。</p><p>线程可以通过以下几种机制避免上述情况：</p><ul><li>1 使用带超时的 await</li><li>2 捕获到异常，尝试再次 await 流程（重试）</li><li>3 重试失败调用 reset</li></ul><p>CyclicBarrier reset 相关的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将屏障重置为其初始状态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//唤醒所有等待的线程继续执行，并设置屏障中断状态为true</span></span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        <span class="comment">//唤醒所有等待的线程继续执行，并设置屏障中断状态为false</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;<span class="comment">//表示当代因为线程被中断，已经发成损坏了</span></span><br><span class="line">    count = parties;<span class="comment">//重置count值</span></span><br><span class="line">    trip.signalAll();<span class="comment">//调用Condition的signalAll方法，唤醒所有await的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();<span class="comment">//调用Condition的signalAll方法，唤醒所有await的线程</span></span><br><span class="line">    </span><br><span class="line">    count = parties;<span class="comment">//重置count值</span></span><br><span class="line">    <span class="comment">//生成新的Generation，表示上一代的所有线程已经唤醒，进行更新换代</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>reset 方法会调用 <code>breakBarrier</code>（该方法意为栅栏损坏），该方法设置 broken 标志、重置 count、唤醒所有 await 线程；</p></li><li><p>await 方法中也会调用 <code>breakBarrier</code>：当收到 InterruptedException，或者超时，都会调用 breakBarrier;</p></li></ul><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/0c8255ede7bc" target="_blank" rel="noopener">Java多线程10 同步工具类CyclicBarrier - 简书</a></li><li><a href="https://www.jianshu.com/p/0c8255ede7bc" target="_blank" rel="noopener">Java多线程10 同步工具类CyclicBarrier - 简书</a></li></ul><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p><code>Phaser</code> 是<strong>JDK1.7</strong>开始引入的一个同步工具类，适用于一些需要分阶段的任务的处理。它的功能与 <strong>CyclicBarrier</strong>和<strong>CountDownLatch</strong>有些类似，类似于一个多阶段的栅栏，比较三者：</p><table><thead><tr><th>同步器</th><th>作用</th></tr></thead><tbody><tr><td>CountDownLatch</td><td>倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器值归 0 后，所有等待的线程继续执行</td></tr><tr><td>CyclicBarrier</td><td>循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行</td></tr><tr><td>Phaser</td><td>多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（advance）</td></tr></tbody></table><p>Phaser 中几个重要的概念：</p><p>（1）phase(阶段)</p><p>在<strong>CyclicBarrier</strong>中，只有一个栅栏，线程在到达栅栏后会等待其它线程的到达。</p><p>Phaser 也有栅栏，在 Phaser 中，栅栏的名称叫做<strong>phase(阶段)</strong>，在任意时间点，Phaser 只处于某一个<strong>phase(阶段)</strong>，初始阶段为0，最大达到 <code>Integerr.MAX_VALUE</code>，然后再次归零。当所有<strong>parties</strong>参与者都到达后，<strong>phase</strong>值会递增。</p><p>如果看过之前关于 <a href="https://segmentfault.com/a/1190000015888316" target="_blank" rel="noopener">CyclicBarrier</a> 的文章，就会知道，Phaser 中的 phase(阶段)这个概念其实和<strong>CyclicBarrier</strong>中的<strong><em>Generation</em></strong>很相似，只不过<strong><em>Generation</em></strong>没有计数。</p><p>（2）parties(参与者)</p><p><strong>parties(参与者)</strong> 其实就是 <strong>CyclicBarrier</strong>中的参与线程的概念。</p><p><strong>CyclicBarrier</strong> 中的参与者在初始构造指定后就不能变更，而 Phaser 既可以在初始构造时指定参与者的数量，也可以中途通过 <code>register</code>、<code>bulkRegister</code>、<code>arriveAndDeregister</code> 等方法注册/注销参与者。</p><p>（3）arrive(到达) / advance(进阶)</p><p>Phaser 注册完 <strong>parties（参与者）</strong> 之后，参与者的初始状态是 <strong>unarrived</strong> 的，当参与者 <strong>到达（arrive）</strong> 当前阶段（phase）后，状态就会变成 <strong>arrived</strong>。当阶段的到达参与者数满足条件后（注册的数量等于到达的数量），阶段就会发生 <strong>进阶（advance）</strong> ——也就是 phase 值+1。</p><p>（4）Termination（终止）</p><p>代表当前<strong>Phaser</strong>对象达到终止状态，有点类似于<strong>CyclicBarrier</strong>中的栅栏被破坏的概念。</p><p>（5）Tiering（分层）</p><p>Phaser 支持<strong>分层（Tiering）</strong> —— 一种树形结构，通过构造函数可以指定当前待构造的 Phaser 对象的父结点。之所以引入<strong>Tiering</strong>，是因为当一个 Phaser 有大量 <strong>参与者（parties）</strong> 的时候，内部的同步操作会使性能急剧下降，而分层可以降低竞争，从而减小因同步导致的额外开销。</p><p>在一个分层 Phasers 的树结构中，注册和撤销子 Phaser 或父 Phaser 是自动被管理的。当一个 Phaser 的<strong>参与者（parties）</strong> 数量变成0时，如果有该 Phaser 有父结点，就会将它从父结点中溢移除。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>（1）通过 Phaser 控制多个线程的执行时机：有时候我们希望所有线程到达指定点后再同时开始执行，我们可以利用<strong>CyclicBarrier</strong>或<strong>CountDownLatch</strong>来实现，这里给出使用 Phaser 的版本。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            phaser.register();                  <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(phaser), <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    Task(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase ="</span> + i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 通过 Phaser 实现开关。在以前讲<strong>CountDownLatch</strong>时，我们给出过以<strong>CountDownLatch</strong>实现开关的示例，也就是说，我们希望一些外部条件得到满足后，然后打开开关，线程才能继续执行，我们看下如何用<strong>Phaser</strong>来实现此功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);       <span class="comment">// 注册主线程,当外部条件满足时,由主线程打开开关</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            phaser.register();                      <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task2(phaser), <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外部条件:等待用户输入命令</span></span><br><span class="line">        System.out.println(<span class="string">"Press ENTER to continue"</span>);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        reader.readLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开开关</span></span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">        System.out.println(<span class="string">"主线程打开了开关"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    Task2(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务，当前phase ="</span> + i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 通过<strong>Phaser</strong>控制任务的执行轮数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> repeats = <span class="number">3</span>;    <span class="comment">// 指定任务最多执行的次数</span></span><br><span class="line"></span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---------------PHASE["</span> + phase + <span class="string">"],Parties["</span> + registeredParties + <span class="string">"] ---------------"</span>);</span><br><span class="line">                <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= repeats  || registeredParties == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            phaser.register();                      <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task3(phaser), <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    Task3(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!phaser.isTerminated()) &#123;   <span class="comment">//只要Phaser没有终止, 各个线程的任务就会一直执行</span></span><br><span class="line">            <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) Phaser 支持分层功能，我们先来考虑下如何用利用 Phaser 的分层来实现高并发时的优化，在<a href="https://segmentfault.com/a/1190000015979879#articleHeader9" target="_blank" rel="noopener">示例三</a>中，我们其实创建了10个任务，然后10个线程共用一个 Phaser 对象，如下图：</p><p><img src="/images/Java-%E5%B9%B6%E5%8F%91.05c.JUC-Sync-2023-05-21-2.png" alt="../_images/Java-并发.05c.JUC-Sync-2023-05-21-2.png"></p><p>如果任务数继续增大，那么同步产生的开销会非常大，利用 Phaser 分层的功能，我们可以限定每个 Phaser 对象的最大使用线程（任务数），如下图：</p><p><img src="/images/Java-%E5%B9%B6%E5%8F%91.05c.JUC-Sync-2023-05-21-3.png" alt="../_images/Java-并发.05c.JUC-Sync-2023-05-21-3.png"></p><p>可以看到，上述 Phasers 其实构成了一颗多叉树，如果任务数继续增多，还可以将 Phaser 的叶子结点继续分裂，然后将分裂出的子结点供工作线程使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASKS_PER_PHASER = <span class="number">4</span>;      <span class="comment">// 每个Phaser对象对应的工作线程（任务）数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> repeats = <span class="number">3</span>;    <span class="comment">// 指定任务最多执行的次数</span></span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---------------PHASE["</span> + phase + <span class="string">"],Parties["</span> + registeredParties + <span class="string">"] ---------------"</span>);</span><br><span class="line">                <span class="keyword">return</span> phase + <span class="number">1</span> &gt;= repeats || registeredParties == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Tasker[] taskers = <span class="keyword">new</span> Tasker[<span class="number">10</span>];</span><br><span class="line">        build(taskers, <span class="number">0</span>, taskers.length, phaser);       <span class="comment">// 根据任务数,为每个任务分配Phaser对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskers.length; i++) &#123;          <span class="comment">// 执行任务</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(taskers[i]);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Tasker[] taskers, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Phaser phaser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi - lo &gt; TASKS_PER_PHASER) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i += TASKS_PER_PHASER) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = Math.min(i + TASKS_PER_PHASER, hi);</span><br><span class="line">                build(taskers, i, j, <span class="keyword">new</span> Phaser(phaser));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; ++i)</span><br><span class="line">                taskers[i] = <span class="keyword">new</span> Tasker(i, phaser);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">    Task4(Phaser phaser) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        <span class="keyword">this</span>.phaser.register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!phaser.isTerminated()) &#123;   <span class="comment">//只要Phaser没有终止, 各个线程的任务就会一直执行</span></span><br><span class="line">            <span class="keyword">int</span> i = phaser.arriveAndAwaitAdvance();     <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": 执行完任务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;CountDownLatch、CyclicBarrier、Semaphore 在 java1.5 被引入，它们也都是基于 AQS 实现的，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReentrantLock 是基于 Exclusive（独占），只有一个线程可以执行；&lt;/li&gt;
&lt;li&gt;CountDownLatch、CyclicBarrier、Semaphore 基于 Share(共享)，多个线程可同时执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;计数器-CountDownLatch&quot;&gt;&lt;a href=&quot;#计数器-CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;计数器 CountDownLatch&quot;&gt;&lt;/a&gt;计数器 CountDownLatch&lt;/h2&gt;&lt;p&gt;CountDownLatch.await 能够使一个线程等待, 直到计数器归于 0 后再继续执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。&lt;/p&gt;
&lt;p&gt;CountDownLatch 提供了类似计数器的同步手段, 构造器和主要方法:&lt;/p&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JUC" scheme="https://beefyheisenberg.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.05b.JUC-Lock（锁）</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05b.JUC-Lock/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05b.JUC-Lock/</id>
    <published>2023-05-24T10:10:50.146Z</published>
    <updated>2023-05-24T10:10:50.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁: ReentrantLock"></a>可重入锁: ReentrantLock</h1><p>ReentrantLock 是”可重入锁”: 一个线程已经持有锁的情况下, 重复对该锁进行 <code>lock()</code> 操作,  能立刻获得锁且不会被阻塞.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123; ... &#125; <span class="keyword">catch</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">  reentrantLock.unlock(); <span class="comment">// 在finally里释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 的构造函数 <code>ReentrantLock(boolean fair)</code> 可以返回公平锁(true)和非公平锁(false).</p><ul><li>公平锁（Fair）：加锁时先检查是否有排队等待的线程，如果队列非空，当前线程先进入队列尾，尝试唤醒队列中第一个节点的线程，即获取锁的顺序同调用 lock 的顺序一致;</li><li>非公平锁（Nonfair）：加锁时不考虑排队等待问题，当前线程直接尝试获取锁，获取不到则将当前线程包装为节点并插入队尾;</li></ul><p>ReentrantLock()默认构造是 <strong>非公平锁</strong></p><h2 id="锁的实现"><a href="#锁的实现" class="headerlink" title="锁的实现"></a>锁的实现</h2><h3 id="AQS-概述"><a href="#AQS-概述" class="headerlink" title="AQS 概述"></a>AQS 概述</h3><p>ReentrantLock 的实现基于 AQS（AbstractQueuedSynchronizer），继承了 AQS 的计数器 state、双向同步队列，ReentrantLock 的条件对象 Condition 是 AQS 的内部类。</p><p>-&gt; <a href="/12.Java/Java-并发.05b.JUC-AQS/" title="Java-并发.05b.JUC-AQS">Java-并发.05b.JUC-AQS</a></p><h3 id="Lock-lock-实现"><a href="#Lock-lock-实现" class="headerlink" title="Lock.lock() 实现"></a>Lock.lock() 实现</h3><p>ReentrantLock.lock()调用栈如下(以 NonFairSync 为例):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReentrantLock.lock()</span><br><span class="line">  NonFairSync.acquire(1)</span><br><span class="line">    AbstractQueuedSynchronizer.acquire(1)</span><br><span class="line">      NonFairSync.tryAcquire(1)</span><br><span class="line">      AbstractQueuedSynchronizer.addWaiter(Node) // 当前线程入对尾</span><br><span class="line">      AbstractQueuedSynchronizer.acquireQueued(Node) // 如果队列中只有当前线程,尝试唤醒</span><br></pre></td></tr></table></figure><p>过程大致如下:</p><ul><li>NonFairSync.tryAcquire:<ul><li>如果 state = 0 ，尝试对 state <code>CAS(0,1)</code> 操作, （<code>CAS(0,1)</code> 意即为如果 state 等于期望值0则设置为1），CAS 成功, 成功获取到该锁, 并把 exclusiveOwnerThread 置为当前线程的引用, <code>lock()</code> 成功返回;</li><li>如果 state != 0，则检查 exclusiveOwnerThread 是否等于线程自己，如果是，则对 state+1，<code>lock()</code> 成功返回;</li></ul></li><li>AQS.addWaiter:<ul><li>CAS 不成功, 表明已经有线程持有该锁, 且 exclusiveOwnerThread 不等于当前线程, 创建当前线程的 <code>AQS.Node</code> 对象, 并插入 AQS 的队尾, 并调用 <code>LockSupport.park()</code> 使当前 Thread 进入 Blocked</li></ul></li></ul><blockquote><p><code>LockSupport.park()</code> 最终调用了 unsafe.park（Native 方法）, 作用是 block 当前线程, 具体参考 <a href="https://blog.csdn.net/weixin_39687783/article/details/85058686" target="_blank" rel="noopener">LockSupport中的park与unpark原理-CSDN博客</a></p></blockquote><p>用线程 A/B 抢锁的场景说明 ReentrantLock 工作流程:</p><ul><li>线程 A 获取到锁: A 是首个获取锁的线程,  CAS 成功, 获取到锁后, 设置 exclusiveOwnerThread 为 A 的线程 ID</li><li>线程 B 获取锁: A 已经持有锁, 所以 B 在这里 CAS 失败, 线程 B 的 Node 被放入队尾, 然后 B 线程 park;</li><li>线程 A 释放锁: CAS 状态值-1, 然后取队列的首节点( 注意队列的 head 节点不存储信息, 这里取的是 head 后面的节点), 然后 <code>LockSupport.unpark(B)</code> 唤醒线程 B, 此时 B 仍在队列;</li><li>线程 B 唤醒执行: B 唤醒后自旋调用 <code>tryAcquire()</code> 再次尝试获取锁, 若成功则把自己从队列删除（AQS.head 设置为 B 节点, 并清除 B 节点信息）</li></ul><p>@ref: <a href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">JUC锁: 锁核心类AQS详解 | Java 全栈知识体系</a></p><h3 id="Lock-unlock-实现"><a href="#Lock-unlock-实现" class="headerlink" title="Lock.unlock() 实现"></a>Lock.unlock() 实现</h3><p>ReentrantLock.unlock()调用栈如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReentrantLock.unlock()</span><br><span class="line">  NonFairSync.release(1)</span><br><span class="line">    AbstractQueuedSynchronizer.release(1) </span><br><span class="line">      Sync.tryRelease(1) // 具体实现类，释放state</span><br><span class="line">      AbstractQueuedSynchronizer.unparkSuccessor // 取出队列第一个节点线程，unpark唤醒</span><br></pre></td></tr></table></figure><ul><li>只允许已经持有锁的线程调用 <code>unlock()</code>, 否则 <code>unlock()</code> 会抛出 IllegalMonitorStateException 异常</li><li>释放锁的过程；</li><li>已经持有锁的线程, 每次调用 <code>unlock()</code> 计数器都会-1, 直到计数器等于 0, 这时候表示锁全部被解开了, 再从 AQS 的队列取出第一个节点进行唤醒；</li></ul><h2 id="测锁与超时"><a href="#测锁与超时" class="headerlink" title="测锁与超时"></a>测锁与超时</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">1000</span>, TimeUnit.MILLISECOND)) &#123; </span><br><span class="line">  <span class="comment">// 超时时间内尝试获取锁失败立刻返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123; </span><br><span class="line">  <span class="comment">// 尝试获取锁失败立刻返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul><li>如果一个数据结构只有很少线程修改其值, 但是有很多线程读取, 这种数据结构非常适合用读写锁 <code>ReentrantReadWriteLock</code></li><li>writeLock 一旦被持有, 排除其他的写锁和读锁;</li><li>readLock 一旦被持有, 排斥写锁, 但不排斥其他的读锁;</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">Lock wl = rwl.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">Lock rl = rwl.readLock();  <span class="comment">// 获取读锁</span></span><br><span class="line"></span><br><span class="line">wl.lock();</span><br><span class="line"><span class="comment">// 写操作, 这里排斥其他的读写锁</span></span><br><span class="line">wl.unlock();</span><br><span class="line"></span><br><span class="line">rl.lock();</span><br><span class="line"><span class="comment">// 读操作, 其他读锁仍可以进入, 写锁则不能</span></span><br><span class="line">rl.unlock();</span><br></pre></td></tr></table></figure><p>RW Lock 其他特点:</p><ul><li>支持 Fair 和 NoFair 两种模式</li><li>支持 Condition: 只有写锁支持 newCondition(), 读锁不支持这个方法, 为什么这样设计? // 当持有写锁时, 读锁是可以任意访问的, 即使拿到了读锁的 Condition 也没有意义, 因为读线程之前不需要协调</li><li>可以降级: 写锁可以降级为读锁, 当线程先拿到读锁, 接着拿到写锁, 此时写锁是被降级为读锁的</li></ul><p>@ref: <a href="https://pdai.tech/md/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E5%8D%87%E9%99%8D%E7%BA%A7" target="_blank" rel="noopener">JUC锁: ReentrantReadWriteLock详解 | Java 全栈知识体系</a></p><h1 id="条件对象-Condition"><a href="#条件对象-Condition" class="headerlink" title="条件对象: Condition"></a>条件对象: Condition</h1><p>一个锁可以创建多个 <code>ConditionObject</code> 对象，<code>ReentrantLock.newCondition()</code> 返回一个 <code>ConditionObject</code>, 它是 AbstractQueuedSynchronizer 的一个内部类;</p><p>使用示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(!resource_is_available) &#123;</span><br><span class="line">    condition.await(); <span class="comment">//1 失去锁 &amp; waiting状态 &amp; 进入condition的等待集</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// here acquired lock, doSomething...</span></span><br><span class="line">  </span><br><span class="line">  condition.signalAll(); <span class="comment">//2 把condition等待集里的所有线程移除</span></span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;...&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  reentrantLock.unlock(); <span class="comment">//3 永远在finally里释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件对象的实现"><a href="#条件对象的实现" class="headerlink" title="条件对象的实现"></a>条件对象的实现</h2><blockquote><p>区分 AQS 的队列和 Condition 的队列：<br>“<strong>同步队列</strong>”也即 AQS 的队列，通过 Node.prev 属性和 Node.next 属性来维护的队列；<br>“<strong>条件队列</strong>”是 ConditionObject 的队列，通过 Node.nextWaiter 属性来维护队列（也看出条件队列是单向队列）；<br>另外，有些书将 prev 属性和 next 属性维护的队列称为“同步队列”，将 nextWaiter 维护的队列称为“等待队列”；<br>根据源码的注释，其实两个队列都可以称为“等待队列”，因此特以“<strong>同步队列</strong>”和“<strong>条件队列</strong>”来区分</p></blockquote><p>➤ <strong>await</strong> 的实现解析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"><span class="comment">// 1. 将当前线程包装成Node，尾插入到「等待队列」中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. 释放当前线程所占用的lock，并唤醒「同步队列」中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"><span class="comment">// 3. 调用park，当前线程在此 wait 并让出CPU</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">/* 如果线程回复运行退出这个 while 循环：</span></span><br><span class="line"><span class="comment">         情况1是线程被interrupt，走到break；</span></span><br><span class="line"><span class="comment">         情况2是线程被放入了「同步队列」，即其他线程调用signal or signalAll</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4. 不断自旋尝试获取到lock</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line"><span class="comment">// 5. 处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ <strong>signal</strong> 的实现解析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 先检测当前线程是否已经获取lock,持有lock的线程才可以signal</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//2. 获取等待队列中第一个节点（头节点）</span></span><br><span class="line">Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//3. 将刚获取的节点，状态变更为CONDITION，并插入到「同步队列」</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ <strong>signalAll</strong> 的实现解析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清空 condition 的 lastWaiter &amp; firstWaiter</span></span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从头遍历「等待队列」所有节点</span></span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first); <span class="comment">// 节点放入「同步队列」</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ref: <a href="https://tobebetterjavaer.com/thread/condition.html#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">深入理解Java并发线程协作类Condition | Java程序员进阶之路</a></p><h1 id="比较-ReentrantLock-和-synchronized"><a href="#比较-ReentrantLock-和-synchronized" class="headerlink" title="比较 ReentrantLock 和 synchronized"></a>比较 ReentrantLock 和 synchronized</h1><ol><li>ReentrantLock 可以”可中断的”获取锁 <code>void lockInterruptibly() throws InterruptedException</code></li><li>ReentrantLock 可以尝试非阻塞地获取锁 <code>boolean tryLock()</code></li><li>ReentrantLock 可以超时获取锁，通过 <code>tryLock(timeout, unit)</code></li><li>ReentrantLock 可以实现公平锁，通过 <code>new ReentrantLock(true)</code> 实现</li><li>ReentrantLock 对象可以同时绑定多个 Condition 对象，只需要多次调用 <code>newCondition()</code> 方法即可。而在 synchronized 中只能使用一个对象的 <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></li><li>Condition 对应的方法是 <code>await()</code>, <code>signal()</code>, <code>signalAll()</code>, Object 对应的方法 <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></li><li>ReentrantLock 的实现是 AQS, synchronized 实现模型是 Monitor</li></ol><blockquote><p>注: ReentrantLock.lockInterruptibly() : 当调用 lockInterruptibly 时如果线程有中断标志, 则抛出 InterruptedException, 如果调用 InterruptedException 没有拿到锁, 线程进入 Blocked 状态, 是可以被 Interrupt 的<br>@ref <a href="https://segmentfault.com/a/1190000015562196#item-1-2" target="_blank" rel="noopener">Java多线程进阶（二）—— J.U.C之locks框架：接口 - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;可重入锁-ReentrantLock&quot;&gt;&lt;a href=&quot;#可重入锁-ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;可重入锁: ReentrantLock&quot;&gt;&lt;/a&gt;可重入锁: ReentrantLock&lt;/h1&gt;&lt;p&gt;ReentrantLock 是”可重入锁”: 一个线程已经持有锁的情况下, 重复对该锁进行 &lt;code&gt;lock()&lt;/code&gt; 操作,  能立刻获得锁且不会被阻塞.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ReentrantLock reentrantLock = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reentrantLock.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123; ... &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  reentrantLock.unlock(); &lt;span class=&quot;comment&quot;&gt;// 在finally里释放锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ReentrantLock 的构造函数 &lt;code&gt;ReentrantLock(boolean fair)&lt;/code&gt; 可以返回公平锁(true)和非公平锁(false).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公平锁（Fair）：加锁时先检查是否有排队等待的线程，如果队列非空，当前线程先进入队列尾，尝试唤醒队列中第一个节点的线程，即获取锁的顺序同调用 lock 的顺序一致;&lt;/li&gt;
&lt;li&gt;非公平锁（Nonfair）：加锁时不考虑排队等待问题，当前线程直接尝试获取锁，获取不到则将当前线程包装为节点并插入队尾;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JUC" scheme="https://beefyheisenberg.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java-并发.05b.JUC-AQS（）</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05b.JUC-AQS/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05b.JUC-AQS/</id>
    <published>2023-05-24T10:10:50.142Z</published>
    <updated>2023-05-24T10:10:50.142Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReentrantLock</code> 中有一个 Sync 类型的成员, 根据调用不同的构造方法, sync 被初始化为 <code>NonFairSync</code> (非公平锁, 默认) 或者 <code>FairSync</code> (公平锁), 这两种 Sync 都继承自 <code>AbstractQueuedSynchronizer</code>, 简称 <strong>AQS</strong>.</p><p>AQS 是 java.util.concurrent 的核心, <code>CountDownLatch</code>, <code>Semaphore</code>, <code>ReentrantLock</code> 等都有一个内部类是 AQS 类的子类. </p><p>图-ReentrantLock-AQS UML:<br><img src="/images/java/java_reentrantLock_uml.png" alt="ReentrantLock AQS"></p><p><code>AbstractQueuedSynchronizer</code> 有几个重要的成员变量:</p><ul><li>1 计数器 <code>private volatile int state</code> ;</li><li>2 等待线程的队列：双向队列，由 head 和 tail 两个 Node 类型的引用，表示头尾;</li><li>3 从 <code>AbstractOwnableSynchronizer</code> 继承来的 <code>exclusiveOwnerThread</code> (Thread 类型);</li></ul><p>计数器 <code>state</code> 是<strong>volatile</strong>修饰的, 作用是记录资源：</p><ul><li>如果是 ReentrantLock，state 作用是记录锁被重入的次数, 初值是 0, 重入一次+1, 释放一次-1, 计数器为 0 表示没有线程持有该锁, 是 free 的;</li><li>如果是 ——————</li></ul><p>尝试 CAS 修改计数器失败的线程, 会被放入队列尾部;</p><p><code>exclusiveOwnerThread</code> 用来记录当前该锁被哪个线程占用(但不是 volatile 的, 此处有疑问)</p><p>➤ AbstractQueuedSynchronizer 抽象类提供的主要的属性和方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">// 双向队列头</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail; <span class="comment">// 双向队列尾</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;  <span class="comment">// 重入计数器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock.lock() 调用了 sync.acquire(1) 方法, 最终调用到 AQS.acquire(1):</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryAcquire 由具体类实现,获取state</span></span><br><span class="line">        <span class="comment">// FairSync 和 NonFairSync 分别实现了 tryAcquire</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; </span><br><span class="line">            <span class="comment">// addWaiter: 当前线程放入等待队列</span></span><br><span class="line">            <span class="comment">// acquireQueued: 如果队列中只有刚放入的线程，则尝试唤醒</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">            <span class="comment">// selfInterrupt：中断当前线程，让出CPU</span></span><br><span class="line">            selfInterrupt(); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock.unlock() 调用了 sync.release(1) 方法, 最终调用到 AQS.acquire(1):</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryRelease 由具体类实现,释放state</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; </span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 从队列中取出第一个可释放的节点, unpark之</span></span><br><span class="line">                unparkSuccessor(h); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="comment">// CANCELLED，值为1，表示当前的线程被取消 </span></span><br><span class="line">  <span class="comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark </span></span><br><span class="line">  <span class="comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中 </span></span><br><span class="line">  <span class="comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行 </span></span><br><span class="line">  <span class="comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** waitStatus value to indicate thread has cancelled. */</span>  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;  </span><br><span class="line">  <span class="comment">/** waitStatus value to indicate successor's thread needs unparking. */</span>  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;  </span><br><span class="line">  <span class="comment">/** waitStatus value to indicate thread is waiting on condition. */</span>  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;  </span><br><span class="line">  <span class="comment">/** waitStatus value to indicate the next acquireShared should * unconditionally propagate. */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">  <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">volatile</span> Node prev;</span><br><span class="line">  <span class="keyword">volatile</span> Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>➤ <strong>AQS.acquire(int)解析</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br><span class="line">          selfInterrupt(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>tryAcquire(int)：参数是 int 类型，表示获取多少个资源，tryAcquire 由具体的类实现， ReentrantLock 的 NonfairSync 和 FairSync 都分别实现了 tryAcquire：</p><ul><li>ReentrantLock.FairSync.tryAcquire：</li><li>ReentrantLock.NonfairSync.tryAcquire：解析 -&gt;  <a href="/12.Java/Java-并发.05b.JUC-Lock/" title="Java-并发.05b.JUC-Lock">Java-并发.05b.JUC-Lock</a></li></ul></li><li><p>addWaiter: 向队列尾添加（当前线程的）Node</p></li><li>acquireQueued： 向队列添加完 Node 后，接下来是执行 acquireQueued 刚添加的 Node，acquireQueued 的作用是判断队列是否只有一个 Node（因头节点不存储信息，这里只需判断 Node 的 pre 是否是 head 引用），然后尝试唤醒 Node 对应的线程，唤醒之前还需要用 shouldParkAfterFailedAcquire 检查一下，然后调用 parkAndCheckInterrupt 唤醒：<ul><li>shouldParkAfterFailedAcquire：只有当该节点的前驱结点的状态为 SIGNAL 时，才可以对该结点所封装的线程进行 park 操作。否则，将不能进行 park 操作</li><li>parkAndCheckInterrupt：调用 <code>LockSupport.park(this)</code> 停止当前的线程，让出 CPU</li></ul></li></ul><p>➤ <strong>AQS.release()解析</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123; </span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>tryRelease(int)：参数是 int 类型，表示释放多少个资源，tryRelease 也需要具体类实现：</li><li>unparkSuccessor(h)：唤醒 head 节点后面的节点，唤醒使用的是调 <code>LockSupport.unpark()</code> </li></ul><p>➤ 除了上述两个方法，AQS 还有一个重要的内部类 <code>ConditionObject</code>，这个内部类用于实现 ReentrantLock 等的 Condition 机制，一个 Lock 可以创建多个 ConditionObject 对象。</p><p>ConditionObject 内也定义了一个队列，为了区别 AQS 的队列，这个队列一般被称作等待队列，<br>此外 ConditionObject 还定义了 await、signal、signalAll 等方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// condition 队列的头节点 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// condition队列的尾结点 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">// 保存condition队列头节点</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头节点不为空</span></span><br><span class="line">            <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">// 保存condition队列头节点</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头节点不为空</span></span><br><span class="line">            <span class="comment">// 唤醒所有等待线程</span></span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// 当前线程被中断，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 在wait队列上添加一个结点</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) <span class="comment">// 检查结点等待时的中断类型</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 中有一个 Sync 类型的成员, 根据调用不同的构造方法, sync 被初始化为 &lt;code&gt;NonFairSync&lt;/code&gt; (非公平锁, 默认) 或者 &lt;code&gt;FairSync&lt;/code&gt; (公平锁), 这两种 Sync 都继承自 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;, 简称 &lt;strong&gt;AQS&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;AQS 是 java.util.concurrent 的核心, &lt;code&gt;CountDownLatch&lt;/code&gt;, &lt;code&gt;Semaphore&lt;/code&gt;, &lt;code&gt;ReentrantLock&lt;/code&gt; 等都有一个内部类是 AQS 类的子类. &lt;/p&gt;
&lt;p&gt;图-ReentrantLock-AQS UML:&lt;br&gt;&lt;img src=&quot;/images/java/java_reentrantLock_uml.png&quot; alt=&quot;ReentrantLock AQS&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 有几个重要的成员变量:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 计数器 &lt;code&gt;private volatile int state&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;2 等待线程的队列：双向队列，由 head 和 tail 两个 Node 类型的引用，表示头尾;&lt;/li&gt;
&lt;li&gt;3 从 &lt;code&gt;AbstractOwnableSynchronizer&lt;/code&gt; 继承来的 &lt;code&gt;exclusiveOwnerThread&lt;/code&gt; (Thread 类型);&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-并发.05a.JUC-Atomic（原子操作）&amp; CAS</title>
    <link href="https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05a.JUC-Atomic&amp;CAS/"/>
    <id>https://beefyheisenberg.github.io/12.Java/Java-%E5%B9%B6%E5%8F%91.05a.JUC-Atomic&amp;CAS/</id>
    <published>2023-05-24T10:10:50.137Z</published>
    <updated>2023-05-24T10:10:50.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些概念（乐观锁、CAS）"><a href="#一些概念（乐观锁、CAS）" class="headerlink" title="一些概念（乐观锁、CAS）"></a>一些概念（乐观锁、CAS）</h2><p>▷ 原子操作:</p><blockquote><p><a href="https://www.zhihu.com/question/27026846" target="_blank" rel="noopener">对int变量赋值的操作是原子的吗？ - 知乎</a></p></blockquote><p>▷ CAS:</p><ul><li>CAS(Compare And Swap)：比较并替换。CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。</li><li>CAS 指令执行时，当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B 并返回 True，否则就什么都不做并返回 False。比较+替换是一个原子操作。</li></ul><p>▷ 乐观锁 &amp; 悲观锁:</p><ul><li>悲观锁: 假定会出现冲突, 加锁前检查所有冲突的可能性，每次在拿数据的时候都会上锁，拿到锁之后才可以修改临界区数据；</li><li>乐观锁(Optimistic Locking): 假定不会出现冲突, 先尝试去修改数据的操作, 根据操作的返回值确定是否抢锁成功;</li><li>Java 中乐观锁 &amp; 悲观锁的实现: <strong>CAS</strong> &amp; <strong>ReentrantLock</strong></li></ul><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>在 JDK 5之前 Java 语言是靠 synchronized 关键字保证同步的, synchronized 的实现是 monitor 对象, 和 ReentantLock 类似也是一种重量级的锁, 获取锁失败会导致线程的上下文切换. </p><p>Volatile 关键字能够在并发条件下，强制将修改后的值刷新到主内存中来保持内存的可见性。通过 CPU 内存屏障禁止编译器指令性重排来保证并发操作的有序性, 但 volatile 也有局限性, volatile++这种依赖当前值的操作并不能保证原子性. </p><p>在这种情况下, 不想使用重量级锁, Volatile 自增无法满足原子性, 这时候可以使用 <code>java.util.concurrent.atomic</code> ，支持了大部分 Java 包的原子操作:</p><ol><li>原子更新基本类型：AtomicBoolean, AtomicInteger, AtomicLong.</li><li>原子更新数组：AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray.</li><li>原子更新引用类型：AtomicReference, AtomicStampedReference, AtomicMarkableReference.</li><li>原子更新字段类型：AtomicReferenceFieldUpdater, AtomicIntegerFieldUpdater, AtomicLongFieldUpdater.</li><li>其他：LongAdder</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// incrementAndGet提供了几个方法实现原子操作:</span></span><br><span class="line"><span class="keyword">int</span> i = atomicInteger.get();</span><br><span class="line">atomicInteger.getAndSet(<span class="number">0</span>); <span class="comment">// 当前值设置为0, 并返回之前的值</span></span><br><span class="line">atomicInteger.compareAndSet(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// 如果当前值等于1, 则更新为3</span></span><br><span class="line">atomicInteger.decrementAndGet(<span class="number">1</span>); <span class="comment">// 自减</span></span><br><span class="line">atomicInteger.incrementAndGet(<span class="number">1</span>); <span class="comment">// 自增</span></span><br></pre></td></tr></table></figure><h3 id="AtomicInteger-的-CAS-实现"><a href="#AtomicInteger-的-CAS-实现" class="headerlink" title="AtomicInteger 的 CAS 实现"></a>AtomicInteger 的 CAS 实现</h3><p><code>java.util.concurrent.atomic</code> 包下的类, 大都是调用 <code>sun.misc.Unsafe</code> 里的方法实现的, <code>sun.misc.Unsafe</code> 主要的 CAS 方法： <code>compareAndSetObject</code>, <code>compareAndSetInt</code> 和 <code>compareAndSetLong</code>, 它们都是 native 方法, 最终实现在 Hotspot 的 unsafe.cpp, 最终调用了 C++ 的 <code>Atomic::cmpxchg</code>.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值的内存偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终调用的是unsafe.compareAndSetInt, 传参是：</span></span><br><span class="line">    <span class="comment">// this：此 AtomicInteger对象</span></span><br><span class="line">    <span class="comment">// VALUE: 值在AtomicInteger对象中的偏移量</span></span><br><span class="line">    <span class="comment">// expectedValue：期望值</span></span><br><span class="line">    <span class="comment">// newValue：新值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> U.compareAndSetInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsafe.compareAndSetInt 是 native 函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unsafe.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UNSAFE_ENTRY 和 UNSAFE_END 都是宏，在预编译期间会被替换成真正的代码</span></span><br><span class="line"><span class="comment">// 下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）</span></span><br><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger.value的Offset</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Atomic.hpp</span></span><br><span class="line"></span><br><span class="line"> atomic.cppunsigned Atomic::cmpxchg(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value,  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value) &#123;</span><br><span class="line">  assert(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="keyword">sizeof</span>(jint), <span class="string">"more work to do"</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载</span></span><br><span class="line"><span class="comment">   * 函数。相关的预编译逻辑如下：</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * atomic.inline.hpp：</span></span><br><span class="line"><span class="comment">   *    #include "runtime/atomic.hpp"</span></span><br><span class="line"><span class="comment">   *    </span></span><br><span class="line"><span class="comment">   *    // Linux</span></span><br><span class="line"><span class="comment">   *    #ifdef TARGET_OS_ARCH_linux_x86</span></span><br><span class="line"><span class="comment">   *    # include "atomic_linux_x86.inline.hpp"</span></span><br><span class="line"><span class="comment">   *    #endif</span></span><br><span class="line"><span class="comment">   *   </span></span><br><span class="line"><span class="comment">   *    // 省略部分代码</span></span><br><span class="line"><span class="comment">   *    </span></span><br><span class="line"><span class="comment">   *    // Windows</span></span><br><span class="line"><span class="comment">   *    #ifdef TARGET_OS_ARCH_windows_x86</span></span><br><span class="line"><span class="comment">   *    # include "atomic_windows_x86.inline.hpp"</span></span><br><span class="line"><span class="comment">   *    #endif</span></span><br><span class="line"><span class="comment">   *    </span></span><br><span class="line"><span class="comment">   *    // BSD</span></span><br><span class="line"><span class="comment">   *    #ifdef TARGET_OS_ARCH_bsd_x86</span></span><br><span class="line"><span class="comment">   *    # include "atomic_bsd_x86.inline.hpp"</span></span><br><span class="line"><span class="comment">   *    #endif</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::cmpxchg((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,  (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 的 <code>Atomic::cmpxchg</code> 在不同的平台有不同的实现, 以 Windows 为例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// atomic_windows_x86.inline.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit <span class="number">0xF0</span> \</span><br><span class="line">                       __asm L0:</span><br><span class="line">              <span class="keyword">inline</span> jint Atomic::cmpxchg (jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value) &#123;  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, <span class="function">compare_value    <span class="title">LOCK_IF_MP</span><span class="params">(mp)</span></span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码由 LOCK_IF_MP 预编译标识符和 cmpxchg 函数组成。为了看到更清楚一些，我们将 cmpxchg 函数中的 LOCK_IF_MP 替换为实际内容。如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint Atomic::cmpxchg (jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value) &#123;  </span><br><span class="line">  <span class="comment">// 判断是否是多核 CPU</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;    <span class="comment">// 将参数值放入寄存器中</span></span><br><span class="line">    mov edx, dest    <span class="comment">// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中</span></span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value    </span><br><span class="line">    <span class="comment">// LOCK_IF_MP</span></span><br><span class="line">    cmp mp, <span class="number">0</span>    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，</span></span><br><span class="line"><span class="comment">     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令</span></span><br><span class="line"><span class="comment">     * 前加 lock 前缀。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    je L0    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。至于这样做的</span></span><br><span class="line"><span class="comment">     * 原因可以参考知乎的一个回答：</span></span><br><span class="line"><span class="comment">     *     https://www.zhihu.com/question/50878124/answer/123099923</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    _emit <span class="number">0xF0</span>L0:    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:</span></span><br><span class="line"><span class="comment">     *   cmpxchg: 即“比较并交换”指令</span></span><br><span class="line"><span class="comment">     *   dword: 全称是 double word，在 x86/x64 体系中，一个 </span></span><br><span class="line"><span class="comment">     *          word = 2 byte，dword = 4 byte = 32 bit</span></span><br><span class="line"><span class="comment">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元</span></span><br><span class="line"><span class="comment">     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。</span></span><br><span class="line"><span class="comment">     *          那么 [edx] 表示内存地址为 dest 的内存单元</span></span><br><span class="line"><span class="comment">     *          </span></span><br><span class="line"><span class="comment">     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值</span></span><br><span class="line"><span class="comment">     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS 的实现离不开处理器的支持。如上面源代码所示，程序会根据当前处理器的类型来决定是否为 cmpxchg 指令添加 lock 前缀。如果程序是在多处理器上运行，就为 cmpxchg 指令加上 lock 前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略 lock 前缀（单处理器自身会维护单处理器内的顺序一致性，不需要 lock 前缀提供的内存屏障效果）。</p><p>intel 的手册对 lock 前缀的说明如下：</p><ul><li><p>确保对内存的读/改/写操作原子执行。在 Pentium 及 Pentium 之前的处理器中，带有 lock 前缀的指令在执行期间会<strong>锁住总线</strong>，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从 Pentium 4，Intel Xeon 及 P6 处理器开始，intel 在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在 lock 前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读 / 写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做<strong>缓存锁定</strong>（cache locking），缓存锁定将大大降低 lock 前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</p></li><li><p>禁止该指令与之前和之后的读和写指令重排序。</p></li><li><p>把写缓冲区中的所有数据刷新到内存中。</p></li></ul><blockquote><p>缓存行（cache line）和 MESI 协议参考： [[../21.Operating-System/01.CPU_Cache]]</p></blockquote><p>上面的第 2 点和第 3 点所具有的内存屏障效果，JUC 的 Atomic.CAS 操作 足以同时实现 volatile 读和 volatile 写的内存语义。</p><p>@ref: <a href="https://www.cnblogs.com/huansky/p/15746624.html" target="_blank" rel="noopener">https://www.cnblogs.com/huansky/p/15746624.html</a></p><h3 id="AtomicStampedReference-解决-ABA-问题"><a href="#AtomicStampedReference-解决-ABA-问题" class="headerlink" title="AtomicStampedReference 解决 ABA 问题"></a>AtomicStampedReference 解决 ABA 问题</h3><p>AtomicReference 的通用模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicReference&lt;Object&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> Object());</span><br><span class="line">Object oldCache = ref.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对缓存oldCache做一些操作</span></span><br><span class="line">Object newCache  =  someFunctionOfOld(oldCache); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果期间没有其它线程改变了缓存值，则更新</span></span><br><span class="line"><span class="keyword">boolean</span> success = ref.compareAndSet(oldCache , newCache);</span><br></pre></td></tr></table></figure><p>但是上面的模式会有 ABA 问题：</p><ul><li>线程 1 获取 Atomic 的 oldVal = A，但是因为某些原因让出了 CPU</li><li>线程 2 获取到 oldVal= A，并成功 CAS（A，B）</li><li>线程 2 继续 CAS（B，A）并且成功，Atomic 的最终值是A</li><li>线程 1 恢复，CAS（A，B）也成功了</li></ul><p>Java 中的 <code>AtomicStampedReference&lt;E&gt;</code> 通过版本号避免了 ABA 问题，它通过包装 <code>[E,Integer]</code> 的 Pair 来对对象标记版本戳 stamp，从而避免 ABA 问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference&lt;Object&gt;  ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="keyword">new</span> Object(),<span class="number">0</span>);  <span class="comment">// 创建AtomicStampedReference对象，持有Obj引用，版本为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] stamp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">Object oldVal = ref.get(stamp); <span class="comment">// get 方法获取 ref 和 stamp</span></span><br><span class="line"><span class="keyword">int</span> oldStamp=stamp[<span class="number">0</span>];          <span class="comment">// stamp[0]保存的是上次的版本号</span></span><br><span class="line"></span><br><span class="line">ref.compareAndSet(oldVal, <span class="keyword">new</span> Object(), oldStamp, oldStamp + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>@ref： <a href="https://segmentfault.com/a/1190000015831791" target="_blank" rel="noopener">Java多线程进阶（十四）—— J.U.C之atomic框架：AtomicReference - 透彻理解Java并发编程 - SegmentFault 思否</a></p><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>已经有 <code>AtomicLong.addAndGet(l)</code> 的情况下, 为什么还要设计 <code>LongAdder</code>?  </p><p>AtomicLong 是使用 “自旋+CAS”实现, 面对大量并发的情况下有性能瓶颈：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@doubt： AtomicLong 为什么使用自旋？</p><p>LongAdder 的使用：</p><ul><li><strong>compareAndSet</strong>：</li><li><strong>addAndGet</strong>：</li><li><strong>decrementAndGet</strong>：</li></ul><p>除了 CAS，LongAdder 提供了大量 add 操作，这也是为什么叫 Adder，LongAdder 更适用于 add 并发多的场景。</p><p>LongAdder 的实现：</p><ul><li>内部是 base + cell 数组，LongAdder 初始化时 cell = null</li><li>如果是<strong>写操作</strong>，尝试 CAS base，<ul><li>如果 CAS base 成功，则只更新base</li><li>如果 CAS 失败说明有竞争，这时候开始初始化 cell 数组，并通过线程 hashCode 确认 cell 数组的位置（这里是用了 <code>THREAD_PROBE.get(Thread.currentThread())</code>, 是不是线程 hashCode 需要再确认，通过这个 hashCode 去确认数组位置，和 HashMap 的方法类似：<code>index = (cell.length - 1) &amp; hash</code> ）</li><li>以后线程进行写入操作时，如果 cell 非空，会尝试 CAS 属于自己的 cell</li><li>cell 也会扩容（double cell 数组）需要注意 cell 数组大小超过 CPU 核数后则不再扩容</li></ul></li><li><strong>读操作</strong>（sum 方法）：<ul><li>base + ∑cell[] ，简单的累加操作，如果当前有线程正在改写 cell，这里得到的仍是一个近似值</li></ul></li></ul><blockquote><p>@ref <a href="https://segmentfault.com/a/1190000015865714" target="_blank" rel="noopener">Java多线程进阶（十七）—— J.U.C之atomic框架：LongAdder - 透彻理解Java并发编程 - SegmentFault 思否</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一些概念（乐观锁、CAS）&quot;&gt;&lt;a href=&quot;#一些概念（乐观锁、CAS）&quot; class=&quot;headerlink&quot; title=&quot;一些概念（乐观锁、CAS）&quot;&gt;&lt;/a&gt;一些概念（乐观锁、CAS）&lt;/h2&gt;&lt;p&gt;▷ 原子操作:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/27026846&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对int变量赋值的操作是原子的吗？ - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;▷ CAS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAS(Compare And Swap)：比较并替换。CAS 需要有 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。&lt;/li&gt;
&lt;li&gt;CAS 指令执行时，当且仅当内存地址 V 的值与预期值 A 相等时，将内存地址 V 的值修改为 B 并返回 True，否则就什么都不做并返回 False。比较+替换是一个原子操作。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="12.Java" scheme="https://beefyheisenberg.github.io/categories/12-Java/"/>
    
    
    <category term="Java" scheme="https://beefyheisenberg.github.io/tags/Java/"/>
    
    <category term="Java并发" scheme="https://beefyheisenberg.github.io/tags/Java并发/"/>
    
    <category term="JUC" scheme="https://beefyheisenberg.github.io/tags/JUC/"/>
    
    <category term="CAS" scheme="https://beefyheisenberg.github.io/tags/CAS/"/>
    
  </entry>
  
</feed>
