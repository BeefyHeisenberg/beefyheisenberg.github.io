<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="排序算法,快速排序,希尔排序,归并排序,堆排序," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="索引 交换排序: 冒泡, 快排 插入排序: 简单插入排序, 希尔排序 选择排序: 简单选择排序, 堆排序 归并排序: 归并排序 基数排序:  选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，泡排序、插入排序、归并排序和基数排序是稳定的排序算法。 交换排序冒泡排序(Bubble Sort)">
<meta name="keywords" content="排序算法,快速排序,希尔排序,归并排序,堆排序">
<meta property="og:type" content="article">
<meta property="og:title" content="Alg.21.常用排序算法">
<meta property="og:url" content="https://beefyheisenberg.github.io/19.Algorithm/Alg.21.排序算法/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="索引 交换排序: 冒泡, 快排 插入排序: 简单插入排序, 希尔排序 选择排序: 简单选择排序, 堆排序 归并排序: 归并排序 基数排序:  选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，泡排序、插入排序、归并排序和基数排序是稳定的排序算法。 交换排序冒泡排序(Bubble Sort)">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Bubble_sort_animation.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Bubble-sort-example-300px.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Sorting_quicksort_anim.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/insertion-sort.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Sorting_shellsort_anim.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Sorting_heapsort_1.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Sorting_heapsort_2.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Merge_sort_animation.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/alg/Merge-sort-example-300px.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2023-05-11-1.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2023-05-10-1.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-Bucket2.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Two-Way-Merge.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Five-Way-Merge.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2023-05-10-2.png">
<meta property="og:updated_time" content="2024-01-12T21:45:11.988Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alg.21.常用排序算法">
<meta name="twitter:description" content="索引 交换排序: 冒泡, 快排 插入排序: 简单插入排序, 希尔排序 选择排序: 简单选择排序, 堆排序 归并排序: 归并排序 基数排序:  选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，泡排序、插入排序、归并排序和基数排序是稳定的排序算法。 交换排序冒泡排序(Bubble Sort)">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/alg/Bubble_sort_animation.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/19.Algorithm/Alg.21.排序算法/"/>





  <title>Alg.21.常用排序算法 | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/19.Algorithm/Alg.21.排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Alg.21.常用排序算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Drafts/" itemprop="url" rel="index">
                    <span itemprop="name">Drafts</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,162
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li>交换排序: 冒泡, 快排</li>
<li>插入排序: 简单插入排序, 希尔排序</li>
<li>选择排序: 简单选择排序, 堆排序</li>
<li>归并排序: 归并排序</li>
<li>基数排序:</li>
</ul>
<p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，泡排序、插入排序、归并排序和基数排序是稳定的排序算法。</p>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><p><img src="/images/alg/Bubble_sort_animation.gif" alt="使用冒泡排序为一列数字进行排序的过程"></p>
<p>最原始的交换类排序方式。遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就交换位置。时间复杂度平均情况<code>O(n^2)</code>，最坏也是<code>O(n^2)</code>，最好时间复杂度是<code>O(n)</code>，解释一下最好时间复杂度：改进的冒泡算法增加一个标志位（是否发生了swap）,如果这次循环完毕检查标志仍是false，说明这次已经是排好序的，直接return。<br>当数组是已经排好序的，这种冒泡的时间复杂度是<code>O(n)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i∈[0,N-1)       //循环N-1遍</span><br><span class="line">  j∈[0,N-1-i)   //每遍循环要处理的无序部分</span><br><span class="line">    swap(j,j+1) //两两排序（升序/降序）</span><br></pre></td></tr></table></figure>
<p><img src="/images/alg/Bubble-sort-example-300px.gif" alt="冒泡示意图"></p>
<ul>
<li>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了，结束。</li>
<li>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</li>
</ul>
<h2 id="快排-Quick-Sort"><a href="#快排-Quick-Sort" class="headerlink" title="快排(Quick Sort)"></a>快排(Quick Sort)</h2><p><img src="/images/alg/Sorting_quicksort_anim.gif" alt="快速排序"></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray (<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums,low,high);</span><br><span class="line">            quickSort(nums,low,index-<span class="number">1</span>);</span><br><span class="line">            quickSort(nums,index+<span class="number">1</span>,high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">            <span class="keyword">int</span> start = low;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot) high--;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= pivot) low++;</span><br><span class="line">                <span class="keyword">if</span> (low &gt;= high) <span class="keyword">break</span>;</span><br><span class="line">                swap(nums, low, high);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//基准值归位</span></span><br><span class="line">            swap(nums,start,low);</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快速排序的时间复杂度分析</strong></p>
<p>快排也是用递归来实现的。所以快速排序的时间性能取决于快速排序的递归树的深度。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那么此时的递归树是平衡的，性能也较好，递归树的深度也就和之前归并排序求解方法一致，然后我们每一次分区需要对数组扫描一遍，做 n 次比较，所以最优情况下，快排的时间复杂度是 O(nlogn)。</p>
<p>但是大多数情况下我们不能划分的很均匀，比如数组为正序或者逆序时，即 [1,2,3,4] 或 [4,3,2,1] 时，此时为最坏情况，那么此时我们则需要递归调用 n-1 次，此时的时间复杂度则退化到了 O(n^2)。</p>
<p><strong>快速排序的空间复杂度分析</strong></p>
<p>快速排序主要时递归造成的栈空间的使用，最好情况时其空间复杂度为 O (logn),对应递归树的深度。最坏情况时则需要 n-1 次递归调用，此时空间复杂度为 O(n).</p>
<p><strong>快速排序的稳定性分析</strong></p>
<p>快速排序是一种不稳定的排序算法</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h2><p><img src="/images/alg/insertion-sort.png" alt="insertion_sort"></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123; <span class="comment">//假设第一个数位置时正确的；要往后移，必须要假设第一个。</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> target = arr[i]; <span class="comment">//待插入的</span></span><br><span class="line">        <span class="comment">//后移</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; target &lt; arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        arr[j] = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度最坏和平均坏都是<code>O(n^2)</code>, 如果基本是已经排序的数列, 最好是<code>O(n)</code></p>
<h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。与插入排序一样，最好的复杂度可以达到<code>O(n)</code>。<br>原始的插入算法实现在最坏的情况下需要进行<code>O(n^2)</code>的比较和交换。<br>步长的选择直接决定了希尔排序的复杂度，如果用<code>n/2^i</code>作为步长，希尔排序可以使得最坏情况提升至<code>O(n*log2n)</code>。这比最好的比较算法的<code>O(n*logn)</code>要差一些。希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到<code>O(n^1.3)</code>。</p>
<p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>然后我们对每列进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>排序之后变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure>
<p>最后以1步长进行排序（此时就是简单的插入排序了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d; i&lt;arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i - d;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];    <span class="comment">//记录要插入的数据</span></span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp) &#123;  <span class="comment">//从后向前，找到比其小的数的位置</span></span><br><span class="line">            arr[j+d] = arr[j];    <span class="comment">//向后挪动</span></span><br><span class="line">            j -= d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j != i - d)    <span class="comment">//存在比其小的数</span></span><br><span class="line">            arr[j+d] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> d = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        shellInsert(arr, d);</span><br><span class="line">        d /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面源码的步长的选择是从<code>n/2</code>开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在<a href="[希尔排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">维基百科</a>)上有对于步长串行的详细介绍。</p>
<p>从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。<br>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到<code>O(n^1.3)</code>。</p>
<p><img src="/images/alg/Sorting_shellsort_anim.gif" alt="希尔排序"></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h2><p>选择排序的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。<br>如果移动元素的代价非常大，使用选择排序可以保证最少次数的数据移动。<br>选择排序的时间复杂度为<code>O(n^2)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length<span class="number">-1</span>; i++) &#123; <span class="comment">//只需要比较n-1次</span></span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++) &#123; <span class="comment">//从i+1开始比较，因为minIndex默认为i了，i就没必要比了。</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minIndex != i) &#123; <span class="comment">//如果minIndex不为i，说明找到了更小的值，交换之。</span></span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h2><p>堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。<br>首先，实现堆排序需要解决两个问题：</p>
<ol>
<li>如何由一个无序序列键成一个堆？</li>
<li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</li>
</ol>
<p>第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。<br>第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。</p>
<p>从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举例：<br>49,38,65,97,76,13,27,49 序列的堆排序建初始堆和调整的过程如下：</p>
<p>输出堆顶元素并调整建新堆的过程：<br><img src="/images/alg/Sorting_heapsort_1.png" alt="输出堆顶"></p>
<p>建初始堆过程：<br><img src="/images/alg/Sorting_heapsort_2.png" alt="建初始堆"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆筛选，除了start之外，start~end均满足大顶堆的定义。</span></span><br><span class="line"><span class="comment">     * 调整之后start~end称为一个大顶堆。</span></span><br><span class="line"><span class="comment">     * @param arr 待调整数组</span></span><br><span class="line"><span class="comment">     * @param start 起始指针</span></span><br><span class="line"><span class="comment">     * @param end 结束指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*start+<span class="number">1</span>; i&lt;=end; i*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//左右孩子的节点分别为2*i+1,2*i+2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择出左右孩子较小的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; end &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= arr[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//已经为大顶堆，=保持稳定性。</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[start] = arr[i]; <span class="comment">//将子节点上移</span></span><br><span class="line">            start = i; <span class="comment">//下一轮筛选</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[start] = temp; <span class="comment">//插入正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            heapAdjust(arr, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h1><p><img src="/images/alg/Merge_sort_animation.gif" alt="一个归并排序的例子：对一个随机点的链表进行排序"></p>
<p>如何合并两个有序数组？</p>
<ul>
<li>首先申请一个空间, 大小等于两个数组大小的和；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针移动到下一个元素；</li>
<li>重复步骤直到某一指针达到序列尾；</li>
</ul>
<p>归并排序就是用递归的方式，把待排序数组递归分解为left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<p><img src="/images/alg/Merge-sort-example-300px.gif" alt="归并示意图"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    mSort(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归分治</span></span><br><span class="line"><span class="comment"> * @param arr 待排数组</span></span><br><span class="line"><span class="comment"> * @param left 左指针</span></span><br><span class="line"><span class="comment"> * @param right 右指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    mSort(arr, left, mid); <span class="comment">//递归排序左边</span></span><br><span class="line">    mSort(arr, mid+<span class="number">1</span>, right); <span class="comment">//递归排序右边</span></span><br><span class="line">    merge(arr, left, mid, right); <span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序数组</span></span><br><span class="line"><span class="comment"> * @param arr 待合并数组</span></span><br><span class="line"><span class="comment"> * @param left 左指针</span></span><br><span class="line"><span class="comment"> * @param mid 中间指针</span></span><br><span class="line"><span class="comment"> * @param right 右指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">//临时数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双指针归并</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将左或右数组中剩余元素 存入临时数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时数组 =》 原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;temp.length; p++) &#123;</span><br><span class="line">        arr[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>归并排序时间复杂度分析</strong></p>
<p>我们一趟归并，需要将两个小集合的长度放到大集合中，则需要将待排序序列中的所有记录扫描一遍所以时间复杂度为 O(n)。<br>归并排序把集合一层一层的折半分组，则由完全二叉树的深度可知，整个排序过程需要进行 logn（向上取整）次,则总的时间复杂度为 O(nlogn)。</p>
<p>另外归并排序的执行效率与要排序的原始数组的有序程度无关，所以在最好、最坏、平均情况下时间复杂度均为 O(nlogn) 。虽然归并排序时间复杂度很稳定，但是他的应用范围却不如快速排序广泛，这是因为归并排序不是原地排序算法，那么他的空间复杂度为多少呢？</p>
<p><strong>归并排序的空间复杂度分析</strong></p>
<p>归并排序所创建的临时结合都会在方法结束时释放，单次归并排序的最大空间是 n ,所以归并排序的空间复杂度为 O(n).</p>
<p><strong>归并排序的稳定性分析</strong></p>
<p>归并排序的稳定性，要看我们的 merge 函数，我们代码中设置了 <code>arr[temp1] &lt;= arr[temp2]</code> ，当两个元素相同时，先放入 <code>arr[temp1]</code> 的值到大集合中，所以两个相同元素的相对位置没有发生改变，所以归并排序是稳定的排序算法。</p>
<h2 id="快排-vs-归并排序"><a href="#快排-vs-归并排序" class="headerlink" title="快排 vs 归并排序"></a>快排 vs 归并排序</h2><p>左：归并，右：快排<br><img src="/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2023-05-11-1.png" alt="../_images/Alg.21.排序算法-2023-05-11-1.png"></p>
<p>虽然归并排序和快速排序都用到了分治思想，但是归并排序是自下而上的，先处理子问题，然后再合并，将小集合合成大集合，最后实现排序。</p>
<p>而<strong>快速排序</strong>是由上到下的，先分区，然后再处理子问题。</p>
<p><strong>归并排序</strong>虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题</p>
<h1 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h1><p>用待排序的数作为计数数组的下标，统计每个数字的次数（数组值）。然后依次输出此数组即可得到有序序列。复杂度 <code>Ο(n+k)</code> ，k 则代表整数的范围（首先 n 个元素映射入数组 On，然后对 k 大小的数组进行遍历输出结果）</p>
<p>空间复杂度 <code>O(k)</code>，需要一个 size = k 的数组，k = 待排序元素的最大值</p>
<h1 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序(Bucket Sort)"></a>桶排序(Bucket Sort)</h1><p>假如待排序列 K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数 f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个 B[i]中的数据就可以得到有序序列了。</p>
<p><img src="/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2023-05-10-1.png" alt="../_images/Alg.21.排序算法-2023-05-10-1.png"></p>
<p>桶排序分析：</p>
<p>　　桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。　</p>
<p>对N个关键字进行桶排序的时间复杂度分为两个部分：</p>
<p>　　(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p>
<p>　　(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为  ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。</p>
<p>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到<code>O(N*logN)</code> 了)。因此，我们需要尽量做到下面两点：</p>
<p>　　(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。</p>
<p>　　(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p>
<p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             O(N) + O(M*(N/M)*log(N/M)) = O(N+N*(logN-logM)) = O(N+N*logN-N*logM)</span><br></pre></td></tr></table></figure>
<p>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。</p>
<p><strong>总结：</strong> 桶排序的平均时间复杂度为线性的 <code>O(N+C)</code>，其中 <code>C=N*(logN-logM)</code>。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p>
<hr>
<p>除了用函数 f(k) 映射，还有一种范围分桶的方式：</p>
<p><img src="/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-Bucket2.png" alt="../_images/Alg.21.排序算法-Bucket2.png"></p>
<h2 id="计数排序-vs-桶排序"><a href="#计数排序-vs-桶排序" class="headerlink" title="计数排序 vs 桶排序"></a>计数排序 vs 桶排序</h2><p>二者都是<strong>非比较排序</strong>，时间复杂度几乎能达到 O(n)，计数排序可以看做一种特殊的桶排序，其映射函数 <code>f(i) = i</code></p>
<p>如果是<strong>基于比较的排序</strong>，最好时间复杂度 = O(nlogn)</p>
<h1 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h1><p>比如这样一个数列排序: <code>342 ，58， 576， 356</code>, 以下描述演示了具体的排序过程</p>
<p>第一次排序(个位):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">5 7 6</span><br><span class="line">3 5 6</span><br><span class="line">0 5 8</span><br></pre></td></tr></table></figure>
<p>第二次排序(十位):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">3 5 6</span><br><span class="line">0 5 8</span><br><span class="line">5 7 6</span><br></pre></td></tr></table></figure>
<p>第三次排序(百位):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 5 8</span><br><span class="line">3 4 2</span><br><span class="line">3 5 6</span><br><span class="line">5 7 6</span><br></pre></td></tr></table></figure></p>
<p>结果: <code>58 342 356 576</code></p>
<p>基数排序的时间复杂度是 O(k<em>n)，其中 n 是待排序元素个数，k 是数字的位数，它的复杂度理论上要低于 O(n</em>logn)，但是如果考虑到实际上 k 也和 n 存在关系，那就不是这样了。就以排序 n 个不同的整数为例，每一位都有 0-9 这 10 个不同的数字，所以 10 的 k 次方必须大于等于 n，所以 k≥log10n。所以按照这个角度来说，它的时间复杂度还是在 O(n*logn)。</p>
<h1 id="外部排序-External-Sort"><a href="#外部排序-External-Sort" class="headerlink" title="外部排序(External Sort)"></a>外部排序(External Sort)</h1><p>上面介绍了很多排序算法，插入排序、归并排序等等，这些算法都属于内部排序算法，即排序的整个过程只是在内存中完成。而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（硬盘），这时就需要用到本章介绍的外部排序算法来解决。  </p>
<p>外部排序算法由两个阶段构成：  </p>
<ol>
<li>按照内存大小，将大文件分成若干长度为 L的子文件（L应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；</li>
<li>对得到的顺段进行合并，直至得到整个有序的文件为止。</li>
</ol>
<p>例如，有一个含有 10000 个记录的文件，但是内存的可使用容量仅为 1000 个记录，毫无疑问需要使用外部排序算法，具体分为两步：  </p>
<ul>
<li>将整个文件其等分为 10 个临时文件（每个文件中含有 1000 个记录），然后将这 10 个文件依次进入内存，采取适当的内存排序算法对其中的记录进行排序，将得到的有序文件（初始归并段）移至外存。</li>
<li>对得到的 10 个初始归并段进行如图的两两归并，直至得到一个完整的有序文件。</li>
</ul>
<p><img src="/images/Two-Way-Merge.png" alt="../_images/Two-Way-Merge.png"></p>
<p>上面两两归并的方式成为 2 路归并，即每次都由 m 个归并段得到 ⌈m/2⌉ 个归并段</p>
<blockquote>
<p>[!notice]<br>注意：在实际归并的过程中，由于内存容量的限制不能满足同时将 2 个归并段全部完整的读入内存进行归并，只能不断地取 2 个归并段中的每一小部分进行归并，通过不断地读数据和向外存写数据，直至 2 个归并段完成归并变为 1 个大的有序文件。</p>
</blockquote>
<p>对于外部排序算法来说，影响整体排序效率的因素主要取决于<strong>读写外存的次数</strong>，即访问外存的次数越多，算法花费的时间就越多，效率就越低。而访问外存的次数同<strong>归并的次数</strong>成正比：</p>
<p><img src="/images/Five-Way-Merge.png" alt="../_images/Five-Way-Merge.png"></p>
<p>对比图 1 和图 2可以看出，增加归并路数 k 可以减少归并的次数，从而减少外存读写的次数。</p>
<p>一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为 = $\log_k m$</p>
<h1 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h1><table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间</th>
<th>最坏情况</th>
<th>额外存储</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>n^2</td>
<td>n^2</td>
<td>1</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>n^2</td>
<td>n^2</td>
<td>1</td>
</tr>
<tr>
<td>快速排序</td>
<td>nlogn</td>
<td>n^2</td>
<td>logn</td>
</tr>
<tr>
<td>归并排序</td>
<td>nlogn</td>
<td>nlogn</td>
<td>n</td>
</tr>
<tr>
<td>堆排序</td>
<td>nlogn</td>
<td>nlogn</td>
<td>1</td>
</tr>
<tr>
<td>希尔(n/2步长)</td>
<td>nlogn</td>
<td>nlogn</td>
<td>1</td>
</tr>
</tbody>
</table>
<ol>
<li>从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。</li>
<li>上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</li>
<li>从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择</li>
</ol>
<hr>
<p>在前面的介绍和分析中我们提到了冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。后面我们又分析了<strong>基于分治递归思想</strong>的归并排序还有计数排序、桶排序、基数排序三种线性排序。<br>我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。</p>
<p>排序算法的各自的使用场景和适用场合：<br><img src="/images/Alg.21.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2023-05-10-2.png" alt="../_images/Alg.21.排序算法-2023-05-10-2.png"></p>
<p>　　1. 从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在 n 较大时归并排序使用时间较少，但使用辅助空间较多。</p>
<p>　　2. 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</p>
<p>　　3. 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。</p>
<p>　　4. 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。</p>
<p>　　5. 上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。</p>
<p>➤ <strong>排序算法的稳定性：</strong><br><code>稳定排序</code>能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。<br>基数排序就是这样，先按低位排序，逐次按高位排序，那么，低位相同的数据元素其先后位置顺序即使在高位也相同时是不会改变的</p>
<hr>
<ul>
<li><a href="http://www.raychase.net/1814" target="_blank" rel="noopener">排序算法一览（上）：交换类、选择类和插入类排序</a></li>
<li><a href="http://www.raychase.net/1876" target="_blank" rel="noopener">排序算法一览（下）：归并类、分布类和混合类排序</a></li>
<li><a href="https://www.cnblogs.com/wxisme/p/5243631.html" target="_blank" rel="noopener">面试中的排序算法总结</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/排序算法/" rel="tag"># 排序算法</a>
          
            <a href="/tags/快速排序/" rel="tag"># 快速排序</a>
          
            <a href="/tags/希尔排序/" rel="tag"># 希尔排序</a>
          
            <a href="/tags/归并排序/" rel="tag"># 归并排序</a>
          
            <a href="/tags/堆排序/" rel="tag"># 堆排序</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/About/About-Scriptorium/" rel="next" title="About-Scriptorium">
                <i class="fa fa-chevron-left"></i> About-Scriptorium
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/19.Algorithm/Alg.LeetcodeEtudes/" rel="prev" title="Alg.LeetcodeEtudes">
                Alg.LeetcodeEtudes <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">503</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">422</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#索引"><span class="nav-text">索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#交换排序"><span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序-Bubble-Sort"><span class="nav-text">冒泡排序(Bubble Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快排-Quick-Sort"><span class="nav-text">快排(Quick Sort)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#插入排序"><span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序-Insertion-Sort"><span class="nav-text">插入排序(Insertion Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序-Shell-Sort"><span class="nav-text">希尔排序(Shell Sort)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#选择排序"><span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序-Selection-Sort"><span class="nav-text">选择排序(Selection Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序-Heap-Sort"><span class="nav-text">堆排序(Heap Sort)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#归并排序-Merge-Sort"><span class="nav-text">归并排序(Merge Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#快排-vs-归并排序"><span class="nav-text">快排 vs 归并排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计数排序-Counting-Sort"><span class="nav-text">计数排序(Counting Sort)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#桶排序-Bucket-Sort"><span class="nav-text">桶排序(Bucket Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序-vs-桶排序"><span class="nav-text">计数排序 vs 桶排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基数排序-Radix-Sort"><span class="nav-text">基数排序(Radix Sort)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#外部排序-External-Sort"><span class="nav-text">外部排序(External Sort)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法的比较"><span class="nav-text">排序算法的比较</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/19.Algorithm/Alg.21.排序算法/';
          this.page.identifier = '19.Algorithm/Alg.21.排序算法/';
          this.page.title = 'Alg.21.常用排序算法';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
