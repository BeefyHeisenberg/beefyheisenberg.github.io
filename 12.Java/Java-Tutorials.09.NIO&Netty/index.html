<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Java," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="@toc:  NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存） NIO 高性能的实现（异步非阻塞 I/O + 堆外内存） 网络编程中两种高性能 I/O 设计模式（多路复用）：Reactor 和 Proactor  从 BIO 到 NIO BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputSt">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Tutorials-09-NIO &amp; Netty">
<meta property="og:url" content="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO&Netty/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="@toc:  NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存） NIO 高性能的实现（异步非阻塞 I/O + 堆外内存） 网络编程中两种高性能 I/O 设计模式（多路复用）：Reactor 和 Proactor  从 BIO 到 NIO BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputSt">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Java-Tutorials.09.NIO&Netty-2023-05-12-1.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/Reactor-Single-Thread.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/Reactor-Work-Thread-Pool.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/Reactor-Multiple-Thread.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Java-Tutorials.09.NIO&Netty-2023-05-04-1.png">
<meta property="og:updated_time" content="2023-05-19T02:43:31.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Tutorials-09-NIO &amp; Netty">
<meta name="twitter:description" content="@toc:  NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存） NIO 高性能的实现（异步非阻塞 I/O + 堆外内存） 网络编程中两种高性能 I/O 设计模式（多路复用）：Reactor 和 Proactor  从 BIO 到 NIO BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputSt">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/Java-Tutorials.09.NIO&Netty-2023-05-12-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO&Netty/"/>





  <title>Java Tutorials-09-NIO & Netty | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO&Netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Tutorials-09-NIO & Netty</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/12-Java/" itemprop="url" rel="index">
                    <span itemprop="name">12.Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,123
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>@toc:</p>
<ul>
<li>NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存）</li>
<li>NIO 高性能的实现（异步非阻塞 I/O + 堆外内存）</li>
<li>网络编程中两种高性能 I/O 设计模式（多路复用）：Reactor 和 Proactor</li>
</ul>
<h1 id="从-BIO-到-NIO"><a href="#从-BIO-到-NIO" class="headerlink" title="从 BIO 到 NIO"></a>从 BIO 到 NIO</h1><blockquote>
<p>BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。<br>Java NIO 是 java 1.4 之后新出的一套 IO 接口，这里的的新是相对于原有标准的 Java IO 和 Java Networking 接口。NIO 提供了一种完全不同的操作方式。<br>NIO（Non-blocking I/O）是一种同步非阻塞的 I/O 模型，也是 I/O 多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O 处理问题的有效方式。</p>
</blockquote>
<h1 id="NIO-包介绍"><a href="#NIO-包介绍" class="headerlink" title="NIO 包介绍"></a>NIO 包介绍</h1><p>Java Non-blocking I/O 主要有三大核心部分：<code>Channel</code> (通道)，<code>Buffer</code> (缓冲区), <code>Selector</code>；<br>除此之外，Java NIO 还包括了新的文件/目录的操作: <code>Path</code> 和 <code>Files</code>。</p>
<ol>
<li>java.nio.channels 包：<ul>
<li><code>java.nio.channels.ServerSocketChannel</code></li>
<li><code>java.nio.channels.SocketChannel</code></li>
<li><code>java.nio.channels.FileChannel</code></li>
</ul>
</li>
<li><code>java.nio.channels.SocketChannel.Selector</code> 类</li>
<li>java.nio.Buff 接口：<ul>
<li><code>java.nio.ByteBuffer</code>: 最基本的字符 buff, 从 <code>Channel</code> (ServerSocketChannel, FileChannel 等)读取出的内容放在 <code>ByteBuffer</code> 里, 或者通过 <code>Channel.write</code> 把 ByteBuffer 内容写入 Channel;</li>
<li><code>DirectByteBuffer</code>: JVM 堆外分配；</li>
<li><code>java.nio.MappedByteBuffer</code>: MappedBuffer 是通过内存文件映射将文件中的内容直接映射到堆外内存中，其本质也是一个 DirectBuffer；</li>
<li><code>HeapByteBuffer</code>: JVM 堆内分配；</li>
</ul>
</li>
<li>java.nio.file 包：<ul>
<li><code>java.nio.file.Path</code>: Path 的实例指代一个目录或文件</li>
<li><code>java.nio.file.Paths</code>: Path 的工厂类, 用于获取 Path 实例</li>
<li><code>java.nio.file.Files</code>: 提供对 <code>Path</code> 的操作</li>
</ul>
</li>
</ol>
<p>▶ BIO 和 NIO 的对比变化如下:</p>
<ul>
<li>(1) BIO 流 vs NIO 管道:<ul>
<li>Java BIO 的各种流的读写都是阻塞操作。这意味着一个线程一旦调用了 read(),write()方法但系统缓冲区没数据可读，那么该线程会进入阻塞状态（Blocked）。</li>
<li>NIO 读写都是非阻塞的, NIO 基于 Channel(管道)和 Buffer(缓冲区)进行操作：数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Channel 可以是文件也可以是 Socket；</li>
</ul>
</li>
<li>(2) NIO 里新增了 Selector，用于监听多个 Channel 的事件，当 Channel 产生可读写事件后, 用 ByteBuffer 读取数据。<br>Selector 允许一个单一线程监听多个 Channel 输入。我们可以注册多个 Channel 到 Selector 上，然后然后用一个线程来挑出一个处于可读或者可写状态的 Channel。Selector 机制使得单线程管理过个 Channel 变得容易。</li>
<li>(3) NIO 的提供了 <code>Path</code> 和 <code>Files</code> 来取代 io 包中的 <code>File</code>, <code>Path</code> 的实例指代一个目录或文件，<code>Files</code> 则提供了对目录或文件的基本操作（exists, copy, move, delete）</li>
</ul>
<h2 id="NIO-ByteBuffer"><a href="#NIO-ByteBuffer" class="headerlink" title="NIO ByteBuffer"></a>NIO ByteBuffer</h2><p>ByteBuffer (参考官方文档 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/Buffer.html" target="_blank" rel="noopener">Buffer (Java Platform SE 8 )</a> )的属性、方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用Buffer读写数据一般遵循以下四个步骤：</span><br><span class="line"></span><br><span class="line">1.  写入数据到Buffer</span><br><span class="line">2.  调用flip()方法</span><br><span class="line">3.  从Buffer中读取数据</span><br><span class="line">4.  调用clear()方法或者compact()方法，准备再次写入</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ByteBuffer.allocate(int)</code>: 创建 buff 并初始化大小</li>
<li><code>put(byte)</code>, <code>put(byte[])</code>: 向 buff 存储数据</li>
<li><p><code>get()</code>, 返回 position 位置的一个 byte</p>
</li>
<li><p>属性 capacity &gt;= limit &gt;= position &gt;= mark</p>
<ul>
<li><code>capacity</code>: 指定数组大小, Buffer 创建后就不可改变;</li>
<li><code>position</code>: 下一个要读或要写的位置, 初始值 0, 每次写入 or 读取一个字节 position++</li>
<li><code>limit</code>: 缓冲区的终点, 不可操作 limit 后面的元素, <ul>
<li>buffer 刚创建还未写入数据时, limit 初始值等于 capacity,</li>
<li>开始写数据, position ++</li>
<li>开始读数据, 调用 flip()方法后 limit=position, 然后 position=0, 意思是 buff 可读取的范围是 position~limit</li>
</ul>
</li>
<li><code>mark</code>: 初始值-1, 备忘位置, 参见 mark()/reset()方法</li>
</ul>
</li>
<li><p><code>flip()</code>: 向 Buffer 写完数据, 开始读数据前要调用一次, 把 position 的值赋给 limit, 然后 position=0, 然后可以调用 get()从 position 读出字节, 读的上限是在 limit 处;</p>
</li>
<li><code>clear()</code>: limit 置为 capacity, position 置为 0, mark 置为-1,  这时可以写 buffer 了;</li>
<li><code>compact()</code>: 清除读过的数据, 将所有未读的数据拷贝到 buffer 起始处, position 指向未读的末尾, limit 置为 capacity, 又可以再次对 buffer 进行写入了;</li>
<li><code>rewind()</code>, position=0, mark=-1, 不改变 limit 的值, 可以再读一遍[0~limit]的字节</li>
<li><code>mark()</code>:  调用后, 使 mark=position,  使用mark()来记录当前 position</li>
<li><code>reset()</code>: 调用后, 使 position=mark, 使用 reset()让 position 置为 mark 的值, 一次 reset()对应一次 mark()</li>
<li><code>equals()</code>: 比较两个 buff 剩余未读的字节数, 比较剩余的每一个字节</li>
<li><code>compareTo()</code>: ..</li>
</ul>
<p><img src="/images/Java-Tutorials.09.NIO&amp;Netty-2023-05-12-1.png" alt="../_images/Java-Tutorials.09.NIO&amp;Netty-2023-05-12-1.png"><br>图来自 <a href="https://www.baeldung.com/java-bytebuffer" target="_blank" rel="noopener">https://www.baeldung.com/java-bytebuffer</a></p>
<blockquote>
<p>ByteBuffer 内部是由一个数组实现的, 所以 capacity 理论最大值受 <code>MAX_Integer</code> 和 <code>-Xmx</code> 限制</p>
</blockquote>
<h2 id="NIO-Channel"><a href="#NIO-Channel" class="headerlink" title="NIO Channel"></a>NIO Channel</h2><p>@todo</p>
<h2 id="NIO-Selector"><a href="#NIO-Selector" class="headerlink" title="NIO Selector"></a>NIO Selector</h2><p>@todo</p>
<h2 id="Files-amp-Path"><a href="#Files-amp-Path" class="headerlink" title="Files &amp; Path"></a>Files &amp; Path</h2><p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioPathAndFiles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    Path path = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> pathExists =</span><br><span class="line">        Files.exists(path,</span><br><span class="line">            <span class="keyword">new</span> LinkOption[]&#123; LinkOption.NOFOLLOW_LINKS&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目录</span></span><br><span class="line">    Path path2 = Paths.get(<span class="string">"data/subdir"</span>);</span><br><span class="line">    Files.createDirectory(path2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"~/text.txt"</span>);</span><br><span class="line">    <span class="comment">//通过bufferedReader读取</span></span><br><span class="line">    BufferedReader bufferedReader = Files.newBufferedReader(path, StandardCharsets.UTF_8);<span class="comment">//文件编码</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String tempString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((tempString = bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sb = sb.append(tempString);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    <span class="comment">//通过Files方法readAllLines</span></span><br><span class="line">    List&lt;String&gt; strings = Files.readAllLines(path);</span><br><span class="line">    strings.forEach(s -&gt; System.out.print(s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pulic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"/text"</span>);</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    Files.write(path, <span class="string">"Hello JDK7!"</span>.getBytes(), StandardOpenOption.APPEND);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NIO-网络读写"><a href="#NIO-网络读写" class="headerlink" title="NIO 网络读写"></a>NIO 网络读写</h2><p>API 说明:</p>
<ul>
<li>服务端:<ul>
<li><code>ServerSocketChannel.open()</code> : 创建一个 server socket channel 实例, 相当于传统 Socket 的 <code>ServerSocket</code></li>
<li><code>ServerSocketChannel.socket().bind(SocketAddress local)</code> : 绑定端口</li>
<li><code>ServerSocketChannel.configureBlocking(false)</code>: 把 server socket channel 设置为 <strong>非阻塞</strong> 的情况下, <code>accept()/read()/write()</code> 会立刻返回;</li>
<li><code>ServerSocketChannel.accept()</code>: 阻塞, 并在有客户端成功连接时返回一个 <code>SocketChannel</code> 实例</li>
<li><code>ServerSocketChannel.register(Selector, EVENT)</code>: 为 server channel 注册监听的事件</li>
</ul>
</li>
<li>Selector:<ul>
<li><code>Selector.open()</code>: 创建一个 selector 实例</li>
<li><code>Selector.select()</code>: 开始监听并阻塞</li>
</ul>
</li>
<li>客户端:<ul>
<li><code>SocketChannel.configureBlocking(false)</code>: 把 socket channel 设置为非阻塞, 读写会立刻返回</li>
<li><code>SocketChannel.write(ByteBuffer)</code>: 写方法</li>
<li><code>SocketChannel.read(ByteBuffer)</code>: 读方法, 返回值是读取的字节数</li>
</ul>
</li>
</ul>
<p>用 NIO API 实现简单的 Socket Server（用 <code>Selector</code> 实现多路复用, 用 <code>Channel.configureBlocking(false)</code> 设置为非阻塞 I/O）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer echoBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ServerSocketChannel实例, 并绑定端口</span></span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channel 绑定 Selector, 并注册 Read</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">SelectionKey regKey = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">  <span class="comment">// 在这里阻塞</span></span><br><span class="line">  <span class="keyword">int</span> num = selector.select();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行到这里表示有事件产生</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">      SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">          <span class="comment">// 取出服务端SocketChannel</span></span><br><span class="line">          ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">          <span class="comment">// 接受请求, 返回客户端SocketChannel</span></span><br><span class="line">          SocketChannel sc = serverSocketChannel.accept();</span><br><span class="line">          <span class="comment">// 客户端SocketChannel设置NoneBlock</span></span><br><span class="line">          sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 客户端SocketChannel也添加进</span></span><br><span class="line">          SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          <span class="comment">// 不要忘记删除</span></span><br><span class="line">          it.remove();</span><br><span class="line">          System.out.println(<span class="string">"Got connection from "</span> + sc);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;</span><br><span class="line">          <span class="comment">// 取出可读的channel</span></span><br><span class="line">          SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理数据</span></span><br><span class="line">          <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              echoBuffer.clear();</span><br><span class="line">              <span class="keyword">int</span> r = sc.read(echoBuffer);</span><br><span class="line">              <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">              echoBuffer.flip();</span><br><span class="line">              sc.write(echoBuffer);</span><br><span class="line">              bytesEchoed += r;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">"Echoed "</span> + bytesEchoed + <span class="string">" from "</span> + sc);</span><br><span class="line">          it.remove();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结: NIO 的 Socket 多路复用如下:</p>
<ul>
<li>创建服务端 socketChannel</li>
<li>创建 Selector</li>
<li>服务端 socketChannel 在 Selector 上注册 ACCEPT 事件</li>
<li>While 循环<ul>
<li>selector.select() 阻塞, 如果 Selector 上有事件发生, 退出阻塞</li>
<li>selector 取出所有事件集合, 并遍历</li>
<li>如果有 ACCEPT 事件, 服务端 socketChannel 去 accept 这个请求, 创建客户端 socketChannel, 并在 Selector 上注册该 channel 的 READ 事件</li>
<li>如果有 READ 事件, 读对应的客户端 socketChannel</li>
</ul>
</li>
</ul>
<h3 id="与传统-Socket-比较"><a href="#与传统-Socket-比较" class="headerlink" title="与传统 Socket 比较"></a>与传统 Socket 比较</h3><p>从上面的代码可以看到,</p>
<ul>
<li>传统的 Java Socket(BIO, 阻塞 IO), 等同于 <code>java.net + java.io</code>, 使用的”Socket 句柄”是 <code>java.net.ServerSocket</code> (服务端 socket)和 <code>java.net.Socket</code> (客户端 socket), 通过 <code>Socket</code> 获取 InputStream/OutpubtStream 进行读/写.</li>
<li>NIO Socket 使用的”socket 句柄”是 <code>java.nio.channels</code> 包下面的 <code>ServerSocketChannel</code> 和 <code>SocketChannel</code>, SocketChannel 的读写是通过 <code>java.nio.ByteBuffer</code></li>
<li>前者 IO 方法是阻塞的, 后者 IO 方法是非阻塞 // ?</li>
</ul>
<h4 id="多线程-BIO-缺陷"><a href="#多线程-BIO-缺陷" class="headerlink" title="多线程-BIO 缺陷"></a>多线程-BIO 缺陷</h4><ul>
<li>线程的创建和销毁成本很高</li>
<li>线程本身占用较大内存，像 Java 的线程栈，一般至少分配 512 K～1 M 的空间，如果系统中的线程数过千…</li>
<li>线程的切换成本是很高</li>
<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或 CPU 核心数，高并发下会使系统负载压力过大</li>
</ul>
<blockquote>
<p>BIO(阻塞 IO)模型，之所以需要多线程，是因为在进行 I/O 操作的时候，一是没有办法知道到底能不能写、能不能读，只能阻塞等待。<br>NIO 的读写函数可以立刻返回，这就给了我们不开线程利用 CPU 的最好机会：如果一个连接不能读写（socket.read()返回 0 或者 socket.write()返回 0），我们可以把这件事记下来，记录的方式通常是在 Selector 上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。<br>NIO 由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的 I/O 操作都是纯 CPU 操作，没有必要开启多线程。<br>单线程处理 I/O 的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。</p>
</blockquote>
<p>以上参考: <a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a> @ref</p>
<h2 id="NIO-大文件读写"><a href="#NIO-大文件读写" class="headerlink" title="NIO 大文件读写"></a>NIO 大文件读写</h2><p>大文件读写几种方案:</p>
<ul>
<li>传统 IO 读取方式:<ul>
<li>字节方式读取: FileInputStream VS BufferedInputStream</li>
<li>字符方式读取: BufferedReader</li>
</ul>
</li>
<li>NIO 读取:<ul>
<li>FileChannel + ByteBuffer</li>
<li>MappedByteBuffer(内存映射)</li>
</ul>
</li>
</ul>
<p>测试结论参考:  <a href="https://blog.csdn.net/yiifaa/article/details/78141622" target="_blank" rel="noopener">JAVA NIO(六)：读取10G的文件其实很容易 - CSDN博客</a> @ref</p>
<h3 id="传统-NIO-读取"><a href="#传统-NIO-读取" class="headerlink" title="传统 NIO 读取:"></a>传统 NIO 读取:</h3><p><code>java.io.RandomAccessFile</code> 提供了文件随机读写,<br>下面的代码是使用 nio 中的 <code>FileChannel</code> 和 <code>ByteBuffer</code> 从 <code>RandomAccessFile</code> 中读取:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel(); <span class="comment">// 1 获取channel</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((read = fileChannel.read(buffer)) &gt; <span class="number">0</span>) &#123; <span class="comment">// 2 读channel到ByteBuffer</span></span><br><span class="line">    buffer.flip(); <span class="comment">// 3 开始读之前flip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲器读入数组, 省略处理过程...</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[read];</span><br><span class="line">    buffer.get(bytes); <span class="comment">// 4</span></span><br><span class="line">    buffer.clear();  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">fileChannel.close();</span><br><span class="line">randomAccessFile.close();</span><br></pre></td></tr></table></figure>
<h3 id="使用内存映射"><a href="#使用内存映射" class="headerlink" title="使用内存映射:"></a>使用内存映射:</h3><p>nio.FileChannel 还提供了内存映射的方式读取文件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"><span class="keyword">long</span> length = randomAccessFile.length();</span><br><span class="line"><span class="comment">// 整个文件映射到内存:</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mappedByteBuffer.hasRemaining()) &#123;</span><br><span class="line">    mappedByteBuffer.get(); <span class="comment">//读取1字节</span></span><br><span class="line">    sum ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Close file &amp; channel</span></span><br></pre></td></tr></table></figure>
<h3 id="内存映射读取的优劣"><a href="#内存映射读取的优劣" class="headerlink" title="内存映射读取的优劣"></a>内存映射读取的优劣</h3><ul>
<li>内存映射方式的读取速度更快<ul>
<li>read()是系统调用, 首先将文件从硬盘拷贝到内核空间的一个缓冲区, 再将这些数据拷贝到用户空间, 实际上进行了两次数据拷贝.</li>
<li>map()也是系统调用, 但没有进行数据拷贝, 当缺页中断发生时, 直接将文件从硬盘拷贝到用户空间, 只进行了一次数据拷贝.</li>
</ul>
</li>
<li>MappedByteBuffer 使用虚拟内存, 因此分配(map)的内存大小不受 JVM 的-Xmx 参数限制, 但是也是有大小限制的;</li>
<li>如果当文件超出1.5G 限制时, 可以通过 position 参数重新 <code>map(mode, position, size)</code> 文件后面的内容;</li>
<li>MappedByteBuffer 在处理大文件时的确性能很高, 但也存在一些问题, 如内存占用/文件关闭不确定, 被其打开的文件只有在垃圾回收的才会被关闭, 而且这个时间点是不确定的。javadoc 中也提到：”A mapped byte buffer and the file mapping that it represents remain* valid until the buffer itself is garbage-collected.”</li>
</ul>
<p>参考: <a href="http://blog.jobbole.com/104880/" target="_blank" rel="noopener">深入浅出 MappedByteBuffer</a> v</p>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>堆外内存就是把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。<br>堆外内存默认是和 <code>-Xmx</code> 默认一样大，也可以使用 <code>-XX:MaxDirectMemorySize</code> 指定堆外内存大小</p>
<h3 id="堆内-vs-堆外"><a href="#堆内-vs-堆外" class="headerlink" title="堆内 vs 堆外"></a>堆内 vs 堆外</h3><ul>
<li><strong>堆外内存</strong>减少了堆内内存的垃圾回收, 减少 STW 停顿;</li>
<li>使用 Java 的 <strong>堆内内存</strong> 进行 IO 操作, 会比 C Native 的程序多一次内存拷贝。为什么呢？</li>
</ul>
<blockquote>
<p>Java 的 IO 底层也是调用了 C Native 的 <code>read()/write()</code> 函数, 这些函数需要传入 <code>void *</code> 类型的内存地址, 并且这个内存地址指向的内容不能被改变, 否则 <code>read()/write()</code> 操作的内存就错了;<br>有些 GC 回收器会整理内存, Java 对象在内存的地址会被改变,<br>所以使用堆内内存进行 IO 操作, 需要先把堆内内容 copy 到 JVM 堆外的连续内存, 然后传递给 C 的 <code>read()/write()</code>, 这就多了一次内存拷贝;<br>JVM 规范没有要求 <code>byte[]</code> 一定是物理连续的, 但是 C 里用 <code>malloc()</code> 分配的内存是连续的;</p>
</blockquote>
<h3 id="How-to-创建堆外内存"><a href="#How-to-创建堆外内存" class="headerlink" title="How to 创建堆外内存"></a>How to 创建堆外内存</h3><p>三种方式创建堆外内存：</p>
<ol>
<li><p>使用 NIO 提供的分配方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(1024); // 返回的是堆内的 HeapByteBuffer</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocateDirect(1024);  // 返回的是直接堆外的 DirectByteBuffer</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 NIO 提供的堆外内存相关的类：<code>DirectByteBuffer</code>，<code>MappedByteBuffer</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DirectByteBuffer</span><br><span class="line">DirectByteBuffer dbf = new DirectByteBuffer(1024);</span><br><span class="line"></span><br><span class="line">// MappedByteBuffer可以通过FileChannel实例获取, 用于文件内存映射</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用 unsafe:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();</span><br><span class="line">long pointer = unsafe.allocateMemory(1024);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>DirectByteBuffer 该类本身还是位于 Java 内存模型的堆中。<br>而 DirectByteBuffer 构造器中调用 <code>unsafe.allocateMemory(size)</code> 是个一个 native 方法，这个方法分配的是堆外内存，通过 C 的 malloc 来进行分配的。并不属于 JVM 内存。</p>
</blockquote>
<h3 id="堆外内存释放"><a href="#堆外内存释放" class="headerlink" title="堆外内存释放"></a>堆外内存释放</h3><ul>
<li>通过堆内对象触发 GC, 堆内对象和指向的堆外内存一并被回收;</li>
<li>通过 Unsafe 回收;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeDirectMemoryExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> address = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FreeDirectMemoryExample</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		address = unsafe.allocateMemory(size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.finalize();</span><br><span class="line">		unsafe.freeMemory(address);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆外内存-GC"><a href="#堆外内存-GC" class="headerlink" title="堆外内存 GC"></a>堆外内存 GC</h3><p>如果堆外内存容量超过了 <code>-XX:MaxDirectMemorySize</code> 会发生 <code>OutOfMemoryError: Direct buffer memory</code>，<br>如果 GC 回收了 DirectBuffer 对象，那么 DirectBuffer 对象指向的堆外内存，会在 GC 的后期被回收，<br>如果 Java 程序使用的堆内内存（Heap）占用率不高但是却大量使用 DirectBuffer 分配堆外内存，<br>这种情况下不会因为堆内内存触发 Full GC 也就无法自动释放堆外内存，<br>所以通常需要调用 <code>System.gc()</code> 来强制回收堆外内存（但是线上环境不建议这样触发 Full GC），这种情况下一定确保不能启用了 <code>-XX:+DisableExplicitGC</code> 导致 <code>System.gc()</code> 被禁用。</p>
<blockquote>
<p><code>System.gc()</code> 会建议 JVM 进行 Full GC, 对新生代的老生代都会进行内存回收，这样会比较彻底地回收 DirectByteBuffer 对象以及他们关联的堆外内存.<br>DirectByteBuffer 对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象.<br>JVM 发生 YGC（Young gc 很频繁, 会 STW, 但是 Copy GC 算法的 STW 极短）的时候会将新生代里的不可达的 DirectByteBuffer 对象及其堆外内存回收了，但是无法对 Old Gen 里的 DirectByteBuffer 对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题。( 并且堆外内存多用于生命期中等或较长的对象 )<br>如果有大量的 DirectByteBuffer 对象移到了 Old Gen，但是又一直没有做 Old Gen 的 CMS GC 或者 Gull GC，那么物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为 heap 明明剩余的内存还很多。</p>
</blockquote>
<h2 id="本章参考"><a href="#本章参考" class="headerlink" title="本章参考"></a>本章参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门</a></li>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a></li>
<li><a href="https://yq.aliyun.com/articles/2371" target="_blank" rel="noopener">理解Java NIO-博客-云栖社区-阿里云</a></li>
</ul>
<h1 id="NIO-高性能是如何实现的"><a href="#NIO-高性能是如何实现的" class="headerlink" title="NIO 高性能是如何实现的"></a>NIO 高性能是如何实现的</h1><p>（1）使用异步非阻塞实现高效的单线程轮询，避免阻塞式 IO 开多线程的方式。// NIO 由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（Selector），剩余的 I/O 操作都是纯 CPU 操作，没有必要开启多线程。并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p>
<ul>
<li><p>NIO 的读写函数可以立刻返回（用 <code>Channel.configureBlocking(false)</code> 设置该通道为非阻塞），如果一个连接不能读写（<code>socket.read()</code> 返回 0 或者 <code>socket.write()</code> 返回 0），我们可以把这件事记下来，记录的方式通常是在 Selector 上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</p>
</li>
<li><p>Java 的 <code>Selector</code> ：同一个 channel 的 select 不能被并发的调用。因此，如果有多个 I/O 线程，必须保证：一个 socket 只能属于一个 IoThread，而一个 IoThread 可以管理多个 socket。</p>
</li>
</ul>
<p>（2）使用 DirectBuffer 减少 IO 时数据拷贝次数：</p>
<ul>
<li><p>使用堆内内存的时候，比如我们要完成一个从文件中读数据到堆内内存的操作，调用 <code>FileChannelImpl.read(HeapByteBuffer)</code> 实际上 File IO 会将数据读到堆外内存中，然后堆外内存再将这部分堆外数据拷贝到堆内内存。// 为什么 Java IO 会多一次内存拷贝? 因为系统调用 read &amp; write 函数的参数 buf 必须指向不变的内存地址，Java 的堆内内存在 GC 过程中（带有 compact 的 GC）地址会被改变；</p>
</li>
<li><p>如果直接使用堆外内存，如 <code>DirectByteBuffer</code>，这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，程序通过 JNI, 直接将这部分的内存数据通过 <code>read()/write()</code> 到堆外内存中。</p>
</li>
</ul>
<p>➤ 比较传统 IO</p>
<ul>
<li>NIO 提供了直接内存的 ByteBuffer, 相比堆内内存, 在 read/write 时使用直接内存可以减少一次内存拷贝 // 但 DirectByteBuffer 创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能</li>
<li>NIO 多了非阻塞 IO + 多路复用 Selector（epoll 实现），Selector 可以使用一个线程即可管理大量 IO 连接的读写事件，对比 BIO （connection pre thread），节省了线程调度和切换的开销，更节省大量线程带来的内存消耗，</li>
</ul>
<h1 id="Reactor-三种常见线程模型"><a href="#Reactor-三种常见线程模型" class="headerlink" title="Reactor 三种常见线程模型"></a>Reactor 三种常见线程模型</h1><p>➤ 三种 Reactor 线程模型:</p>
<ul>
<li>单 Reactor</li>
<li>单 Reactor + 多线程</li>
<li>主从 Reactor + 多线程</li>
</ul>
<p>➤ Reactor &amp; Proactor IO 模型中，涉及到的角色:</p>
<ul>
<li><strong>Demultiplexer</strong>: 多路复用器, select or epoll 的抽象, 产生 IO 事件</li>
<li><strong>Dispatcher</strong>: 分发器, 将多路复用器产生的事件进行分发</li>
<li><strong>Acceptor</strong>: accept 事件处理器(函数)</li>
<li><strong>IOHandler</strong>: IO 事件处理器(函数)</li>
</ul>
<blockquote>
<p>@ref: <a href="https://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reactor_pattern</a></p>
</blockquote>
<h3 id="单-Reactor-模型"><a href="#单-Reactor-模型" class="headerlink" title="单 Reactor 模型"></a>单 Reactor 模型</h3><p>一个 Reactor Thread,  负责处理全部 I/O 事件(accept, read, send), 以及业务代码(decode, compute, encode)</p>
<ul>
<li>在一个 Reactor Thread 里, select 监听 accept/read/write 事件, 事件由 Dispatcher 进行分发:<ul>
<li>有 accept 事件, Dispatcher 分发给 Acceptor 进行握手/鉴权等处理;</li>
<li>有 read/write 事件, Dispatcher 分发给 IOHandler: 进行 read → decode → compute → encode → send ;</li>
</ul>
</li>
<li>缺点: 当某个 Handler 阻塞时，会导致其他客户端的 handler 和 accpetor 都得不到执行，无法做到高性能，只适用于业务处理非常快速的场景<br><img src="/images/java/Reactor-Single-Thread.png" alt=""></li>
</ul>
<h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor +多线程"></a>单 Reactor +多线程</h3><p>一个 Reactor Thread, 负责处理全部 I/O 事件(accept, read, send), 但业务代码交给线程池处理..</p>
<ul>
<li>Reactor Thread 里, select 监听 accept/read/write 事件, 事件由 Dispatcher 进行分发:<ul>
<li>有 accept 事件, 处理同单线程模型，Reactor 线程直接调用 acceptor 函数;</li>
<li>有 read 事件, Dispatcher 分发给 IOHandler 处理 (函数调用, 仍在 Reactor 线程里), 也就是在 Reactor 线程里进行非阻塞 read;</li>
<li>从 Worker Thread Pool 取出一个 Worker, 对读到的数据进行 decode → compute → encode 处理流程;</li>
<li>Worker 的结果交还给 Reactor Thread, 由 Reactor Thread 进行 send;</li>
</ul>
</li>
<li>比较单线程模型, 多线程 Reactor 模型仍在主线程里处理读/写操作, 不再处理业务代码, 业务代码交给线程池执行;</li>
<li>缺点: Reactor Thread 仍然负责全部的 accept/read/write 的处理, 如果在 Reactor Thread 进行有大量读写事件, 同时大量连接事件(在 accept 时进行鉴权等), 这时候仍会有单线程的瓶颈</li>
</ul>
<p><img src="/images/java/Reactor-Work-Thread-Pool.png" alt=""></p>
<h3 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor + 多线程"></a>主从 Reactor + 多线程</h3><p>不再是一个 Reactor Thread, 有 Main Reactor &amp; Sub Reactor 两个线程, 分别处理 accept 事件 &amp; IO 事件, 业务代码交给线程池处理</p>
<ul>
<li><strong>Main Reactor Thread</strong> 的 Selector 负责监听 accept 事件, 交给 Acceptor 处理;<ul>
<li>Acceptor 接受请求之后创建新的 SocketChannel, 并处理鉴权/握手等;</li>
<li>完成上一步处理的 socket, 从 Main Reactor Thread 的 Selector 移除, 并注册到 Sub Reactor Thread 的 Selector 上;</li>
</ul>
</li>
<li><strong>Sub Reactor Thread</strong> 的 Selector 负责监听这些 socket 的 IO （read）事件, 并调用 IOHandler 进行非阻塞 read;<ul>
<li>从 Worker Thread Pool 取出一个 Worker, 对读到的数据进行 decode → compute → encode 处理流程;</li>
<li>Worker 的结果交还给 Reactor Thread, 由 Reactor Thread 进行 send;</li>
</ul>
</li>
</ul>
<p><img src="/images/java/Reactor-Multiple-Thread.png" alt=""></p>
<hr>
<p>@ref: [[../_attachments/Scalable IO in Java - Doug Lea.pdf]]</p>
<h1 id="Netty-实现多线程-Reactor"><a href="#Netty-实现多线程-Reactor" class="headerlink" title="Netty 实现多线程 Reactor"></a>Netty 实现多线程 Reactor</h1><p>➤ Netty 中重要的 API 类:</p>
<ul>
<li><p><strong>NioEventLoop</strong>:  是 Netty 的 Reactor 线程</p>
<ul>
<li>继承自 SingleThreadEventExecutor, 只有一个线程的线程池</li>
<li>每个 NioEventLoop 都有一个 Selector(封装了 epoll), 可以用来监听 accept/r/w 事件</li>
</ul>
</li>
<li><p>NioEventLoop 的职责：</p>
<pre><code>1.  作为服务端 Acceptor 线程，负责处理客户端的请求接入；
2.  作为客户端 Connecor 线程，负责注册监听连接操作位，用于判断异步连接结果；
3.  作为 IO 线程，监听网络读操作位，负责从 SocketChannel 中读取报文；
4.  作为 IO 线程，负责向 SocketChannel 写入报文发送给对方，如果发生写半包，会自动注册监听写事件，用于后续继续发送半包数据，直到数据全部发送完成；
5.  作为定时任务线程，可以执行定时任务，例如链路空闲检测和发送心跳消息等；
6.  作为线程执行器可以执行普通的任务线程（Runnable）。
</code></pre></li>
</ul>
<ul>
<li><p><strong>NioEventLoopGroup</strong>: 一个 NioEventLoopGroup 管理多个 NioEventLoop, 构造函数可以指定管理 NioEventLoop 的个数, 如果没有设置，默认取 -Dio.netty.eventLoopThreads，如果该系统参数也没有指定，则为可用的 CPU 内核数 × 2。</p>
</li>
<li><p><strong>Channel</strong>（NioServerSocketChannel）：类似 NIO 中的 channel，对 socket 的封装，包括 connect、bind、read、write，此外 Nio 的 Channel 还包括一个 ChannelPipeline 成员；</p>
</li>
<li><p><strong>ChannelPipeline</strong>：该 Channel 上的读写操作，都会走到这个 ChannelPipeline 中，pipeline 上可以添加（事件，ChannelHandler），当 channel 上完成 register、active、read、readComplete 等事件时，会触发 pipeline 中的相应的 ChannelHandler；如同名字一样，<strong>pipeline 串行执行这些 Handler</strong>；</p>
</li>
</ul>
<p>EventLoop 串行执行 pipeline 上的 Handler：<br><img src="/images/Java-Tutorials.09.NIO&amp;Netty-2023-05-04-1.png" alt="../_images/Java-Tutorials.09.NIO&amp;Netty-2023-05-04-1.png"></p>
<p>➤ 用 Netty 实现多线程 Reactor(伪码)，这里使用的是<strong>主从 Reactor + 多线程模型</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); </span><br><span class="line"></span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// 创建netty 服务器</span></span><br><span class="line"></span><br><span class="line">bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>) <span class="comment">// TCP参数</span></span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)  <span class="comment">// TCP参数</span></span><br><span class="line">        .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ServerHandlerInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline p = ch.pipeline();</span><br><span class="line">                <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                p.addLast(serverHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the server:</span></span><br><span class="line">ChannelFuture f = b.bind(PORT).sync();</span><br></pre></td></tr></table></figure>
<ul>
<li>Netty Server 创建两个 <code>NioEventLoopGroup</code>: <strong>bossGroup</strong>（main Reactor） 和 <strong>workerGroup</strong>（sub Reactor）;</li>
</ul>
<ul>
<li>bossGroup 线程组通常只有一个 <code>EventLoop</code> 线程(Boss 线程), 这个线程作为 <strong>Main Reactor Thread</strong>, 负责 select 监听端口的 accept 事件并进行后续处理(创建 SocketChannel.. );</li>
</ul>
<ul>
<li>boss 的 <code>EventLoop</code> 线程会把创建的 SocketChannel, 顺序分发给 workerGroup 线程组中的每一个 Worker 线程(类似轮询);</li>
</ul>
<ul>
<li>workerGroup 线程组, 通常包含 cpu core 数量的 1-2倍个 <code>EventLoop</code> 线程(Worker 线程), 这些 Worker 线程作为 <strong>Sub Reactor Threads</strong>, Worker 线程内使用 Selector 监听 SocketChannel 的读写事件; </li>
</ul>
<ul>
<li>childHandler 是传入了一个 ChannelInitializer，这是当有新的客户端连接到达时会回调的一个方法。我们给这个新的 channel 的 pipeline 上添加了一个处理器 serverHandler，当收到数据的时候会执行该 handler</li>
</ul>
<p>@ref: </p>
<ul>
<li><a href="https://www.infoq.cn/article/netty-threading-model" target="_blank" rel="noopener">Netty系列之Netty线程模型 - InfoQ</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247483737&amp;idx=1&amp;sn=7ef3afbb54289c6e839eed724bb8a9d6" target="_blank" rel="noopener">聊聊Netty那些事儿之从内核角度看IO模型</a></li>
<li><a href="https://mp.weixin.qq.com/s/DS52g3bibU9kNH75UFxGqA" target="_blank" rel="noopener">剖析Netty内部网络实现原理</a></li>
<li><a href="https://www.cnblogs.com/binlovetech/p/16444271.html" target="_blank" rel="noopener">一文聊透 Netty 核心引擎 Reactor 的运转架构 - bin的技术小屋 - 博客园</a></li>
</ul>
<h1 id="Java-对-AIO-的支持"><a href="#Java-对-AIO-的支持" class="headerlink" title="Java 对 AIO 的支持"></a>Java 对 AIO 的支持</h1><p>AIO(asynchronous I/O): 异步 IO, <code>java.nio.channels</code>包做了支持, 包括: <code>AsynchronousSocketChannel</code> /  <code>AsynchronousServerSocketChannel</code> / <code>AsynchronousFileChannel</code></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/12.Java/Java-Tutorials.08.网络编程API/" rel="next" title="Java Tutorials-08-网络编程API">
                <i class="fa fa-chevron-left"></i> Java Tutorials-08-网络编程API
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/12.Java/Java-并发.06c.JUC-Fork&Join/" rel="prev" title="Java-并发.06c.JUC-执行器-Fork/Join框架">
                Java-并发.06c.JUC-执行器-Fork/Join框架 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">462</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">403</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从-BIO-到-NIO"><span class="nav-text">从 BIO 到 NIO</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO-包介绍"><span class="nav-text">NIO 包介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-ByteBuffer"><span class="nav-text">NIO ByteBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-Channel"><span class="nav-text">NIO Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-Selector"><span class="nav-text">NIO Selector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Files-amp-Path"><span class="nav-text">Files &amp; Path</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-网络读写"><span class="nav-text">NIO 网络读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与传统-Socket-比较"><span class="nav-text">与传统 Socket 比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程-BIO-缺陷"><span class="nav-text">多线程-BIO 缺陷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-大文件读写"><span class="nav-text">NIO 大文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统-NIO-读取"><span class="nav-text">传统 NIO 读取:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用内存映射"><span class="nav-text">使用内存映射:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射读取的优劣"><span class="nav-text">内存映射读取的优劣</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆外内存"><span class="nav-text">堆外内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆内-vs-堆外"><span class="nav-text">堆内 vs 堆外</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-创建堆外内存"><span class="nav-text">How to 创建堆外内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆外内存释放"><span class="nav-text">堆外内存释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆外内存-GC"><span class="nav-text">堆外内存 GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章参考"><span class="nav-text">本章参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO-高性能是如何实现的"><span class="nav-text">NIO 高性能是如何实现的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reactor-三种常见线程模型"><span class="nav-text">Reactor 三种常见线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单-Reactor-模型"><span class="nav-text">单 Reactor 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单-Reactor-多线程"><span class="nav-text">单 Reactor +多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从-Reactor-多线程"><span class="nav-text">主从 Reactor + 多线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty-实现多线程-Reactor"><span class="nav-text">Netty 实现多线程 Reactor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-对-AIO-的支持"><span class="nav-text">Java 对 AIO 的支持</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO&Netty/';
          this.page.identifier = '12.Java/Java-Tutorials.09.NIO&Netty/';
          this.page.title = 'Java Tutorials-09-NIO & Netty';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
