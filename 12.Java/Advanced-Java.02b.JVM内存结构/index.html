<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="JVM," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="JDK6 时期 如上图, JDK6 时代的 JVM 内存分为下面几个部分:  堆区(Heap Space): 这部分被所有线程共享(除了 #TLAB ), 包括: 年轻代: eden:s0:s1 的默认比例是 8:1:1,  可见 eden 区大部分对象都是要被回收的; 老年代: 老年代:年轻代 的比例默认是 2:1 , 也就是说默认情况下堆区的 2/3 都属于老年代,   栈区(Stack Sp">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="Advanced Java-02b-JVM运行时内存结构">
<meta property="og:url" content="https://beefyheisenberg.github.io/12.Java/Advanced-Java.02b.JVM内存结构/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="JDK6 时期 如上图, JDK6 时代的 JVM 内存分为下面几个部分:  堆区(Heap Space): 这部分被所有线程共享(除了 #TLAB ), 包括: 年轻代: eden:s0:s1 的默认比例是 8:1:1,  可见 eden 区大部分对象都是要被回收的; 老年代: 老年代:年轻代 的比例默认是 2:1 , 也就是说默认情况下堆区的 2/3 都属于老年代,   栈区(Stack Sp">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/JVM-Memory-Model-Generation.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Advanced-Java.02b.JVM-YoungGen-s0-s1.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Advanced-Java.02b.JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-2023-05-27-1.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Advanced-Java.02b.JVM-TLAB-Pointer.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Advanced-Java.02b.JVM-Stack-model.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/jvm-gensize-experience-point.png">
<meta property="og:updated_time" content="2023-06-18T14:37:20.411Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Advanced Java-02b-JVM运行时内存结构">
<meta name="twitter:description" content="JDK6 时期 如上图, JDK6 时代的 JVM 内存分为下面几个部分:  堆区(Heap Space): 这部分被所有线程共享(除了 #TLAB ), 包括: 年轻代: eden:s0:s1 的默认比例是 8:1:1,  可见 eden 区大部分对象都是要被回收的; 老年代: 老年代:年轻代 的比例默认是 2:1 , 也就是说默认情况下堆区的 2/3 都属于老年代,   栈区(Stack Sp">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/java/JVM-Memory-Model-Generation.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/12.Java/Advanced-Java.02b.JVM内存结构/"/>





  <title>Advanced Java-02b-JVM运行时内存结构 | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/12.Java/Advanced-Java.02b.JVM内存结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Advanced Java-02b-JVM运行时内存结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/12-Java/" itemprop="url" rel="index">
                    <span itemprop="name">12.Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,863
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JDK6-时期"><a href="#JDK6-时期" class="headerlink" title="JDK6 时期"></a>JDK6 时期</h1><p><img src="/images/java/JVM-Memory-Model-Generation.png" alt="JVM Runtime Memory Area"></p>
<p>如上图, JDK6 时代的 JVM 内存分为下面几个部分:</p>
<ul>
<li>堆区(Heap Space): 这部分被所有线程共享(除了 #TLAB ), 包括:<ul>
<li>年轻代: <code>eden:s0:s1</code> 的默认比例是 <code>8:1:1</code>,  可见 eden 区大部分对象都是要被回收的;</li>
<li>老年代: <code>老年代:年轻代</code> 的比例默认是 <code>2:1</code> , 也就是说默认情况下堆区的 2/3 都属于老年代,</li>
</ul>
</li>
<li>栈区(Stack Space): 每个线程独有, 包括: PC, Stack, Native Stack</li>
<li>方法区(Method Area)</li>
</ul>
<blockquote>
<p>JVM 标准定义的内存区域为 Heap/Stack Space/Medhod Area; 分代的名称（年轻代/老年代/永久代）是 HotSpot 中定义的, 并不是 JVM 标准中定义的, 注意区分 @doubt</p>
</blockquote>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><ul>
<li>这块区域被同一 JVM 实例的所有线程共享(除了 TLAB),  new 在堆创建对象.</li>
<li>堆的大小由 <code>-Xms</code> ~ <code>-Xmx</code> 指定: <code>-Xmx2048m -Xms2048m</code><ul>
<li><code>-Xmx</code> 堆的最大值默认是内存的 1/4;</li>
<li><code>-Xms</code> 堆的最小值;</li>
</ul>
</li>
</ul>
<h3 id="YoungGen-新生代"><a href="#YoungGen-新生代" class="headerlink" title="YoungGen(新生代)"></a>YoungGen(新生代)</h3><p>大小由参数 <code>-XX:NewSize</code> ~ <code>-XX:MaxNewSize</code> (jdk 1.3)指定, jdk1.4之后统一成一个参数 <code>-Xmn512m</code></p>
<p>新生代又被分为三个区域:</p>
<ul>
<li>Eden: 新创建的对象被分配在这里;</li>
<li>To Survivor、From Survivor:  发生 Young GC 时, 有用的对象从 <code>Eden</code> 区域和 <code>From Survivor</code> 区域移动到 → <code>To Survivor</code> , Eden 和 From 被清空, 同时 From 和 To 交换角色 ;</li>
</ul>
<p><img src="/images/Advanced-Java.02b.JVM-YoungGen-s0-s1.png" alt="../_images/Advanced-Java.02b.JVM-YoungGen-s0-s1.png"></p>
<blockquote>
<p>命令 jstat 的返回中, To/From Survivor 被标注为 S0/S1</p>
</blockquote>
<h4 id="Eden-区的-TLAB"><a href="#Eden-区的-TLAB" class="headerlink" title="Eden 区的 TLAB"></a>Eden 区的 TLAB</h4><p>在Eden区，每个线程都有一块自己的TLAB（Thread Local Allocate Buffer），线程创建的对象优先在自己的TLAB中分配，其他的线程仍可以访问这些对象，但是无法在其他线程的TLAB中分配内存。</p>
<p>为什么需要为每个线程单独分配TLAB？</p>
<ul>
<li>内存分配要涉及到“空闲内存管理”，即把空闲的内存块管理起来，分配内存时从空闲块中取，一般的连续空闲内存管理使用：指针碰撞+空闲列表<ul>
<li>bump-the-pointer：在连续的内存块上，指针之前表示已用区域，指针之后表示未用，分配内存时移动指针即可，但是对于前面已分配过的内存，可能因为释放导致空洞，指针碰撞法无法管理这部分空洞</li>
<li>free-list：对于指针碰撞法的补充，指针前面出现的空洞，用链表管理起来</li>
</ul>
</li>
<li>实际分配时，在free-list 和 撞针寻找空闲的内存，这里通常使用 first-fit的方式寻找</li>
<li>多个进程都需要申请内存，就需要对 pointer &amp; free-list进行加锁，导致性能下降</li>
</ul>
<p>【图】使用 list 管理不连续的空闲块：<br><img src="/images/Advanced-Java.02b.JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-2023-05-27-1.png" alt="../_images/Advanced-Java.02b.JVM内存结构-2023-05-27-1.png"></p>
<p>@link：pointer &amp; free-list 的空闲管理，比较物理内存的伙伴系统 &amp; Slab内存池</p>
<blockquote>
<p>其实“bump-the-pointer”翻译为指针加法更合适，而不是“指针碰撞”<br>我猜测会有留言问为什么不把 bump the pointer 翻译成指针碰撞。这里先解释一下，在英语中我们通常省略了 bump up the pointer 中的 up。在这个上下文中 bump 的含义应为“提高”。另外一个例子是当我们发布软件的新版本时，也会说 bump the version number。</p>
</blockquote>
<p><strong>线程向 TLAB 申请内存</strong>也是用““bump-the-pointer”：线程维护了两个指针（实际可能更多，但重要的就2个指针），end-ptr 指向 TLAB 末尾，free-ptr 指向“已分配”的后面，线程向 TLAB 申请内存只需向后移动 free-ptr</p>
<p><img src="/images/Advanced-Java.02b.JVM-TLAB-Pointer.png" alt="../_images/Advanced-Java.02b.JVM-TLAB-Pointer.png"></p>
<p><strong>TLAB的创建、释放</strong>：</p>
<ul>
<li>TLAB在 线程初始化时创建，在经历一次GC后会释放TLAB，在GC过程中TLAB中的<strong>可达对象</strong>被放入Survivor Space，TLAB的内存区域也被释放给Eden 管理；</li>
<li>在GC完之后，线程尝试分配对象时，再次创建新的TLAB；</li>
<li>如果一次 new 的内存块的大小，大于当前 TLAB 剩余空间，此时还需要判断剩余空间是否大于<strong>refill_waste</strong>（最大可浪费）：<ul>
<li>如果大于 refill_waste：在堆内存分配</li>
<li>如果小于 refill_waste：TLAB 被退回给 Eden，线程不再使用这块 TLAB 分配，而是申请新的 TLAB</li>
<li>通过 refill_waste，减少重新申请 TLAB 的频次</li>
</ul>
</li>
</ul>
<p>TLAB参数：</p>
<ul>
<li><code>-XX:-ResizeTLAB</code>: 关闭 TLAB的 resize，默认是开的，会根据线程分配历史动态调整TLAB的大小</li>
<li><code>-XX:TLABRefillWasteFraction=64</code> 最大可浪费 TLAB的 1/64</li>
</ul>
<p>@ref:</p>
<ul>
<li><a href="https://juejin.cn/post/6925217498723778568#heading-7" target="_blank" rel="noopener">全网最硬核 JVM TLAB 分析 - 掘金</a></li>
<li><a href="https://www.jianshu.com/p/cd85098cca39" target="_blank" rel="noopener">JVM源码分析之线程局部缓存TLAB - 简书</a></li>
</ul>
<h3 id="OldGen-老年代"><a href="#OldGen-老年代" class="headerlink" title="OldGen(老年代)"></a>OldGen(老年代)</h3><ul>
<li>也叫 Tenured(晋升代), 在 GC 里被称为老年代(Old Generation)</li>
<li>没有参数可以指定大小, 但可以通过 <code>Heap-新生代</code> 计算出来</li>
</ul>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>当每个新线程出现时，都会获得自己的 PC Register、Java Stack、以及 Native Method Stack</p>
<p><strong>（1）Program Counter Register</strong>:<br> 计数器, 记录当前线程执行 Java 字节码的行号;</p>
<p> 这里是 JVM 中唯一没有规定任何 OutOfMemoryError 的区域;</p>
<p><strong>（2）Java Stack</strong>:<br> 即每个线程执行时的 “Java 栈”，区别于 Native, 每个线程的栈由一个个栈帧（Frame）构成，线程中每次有方法调用时，会创建一个 Frame 并压入 Java Stack，方法调用结束时 Frame 被弹出；</p>
<p> 这里存储线程的 Java 方法（再次强调不包括 Native method 的）调用的状态，包括其局部变量、调用它的参数、返回值和中间计算。</p>
<p> Java 的方法结束有两种方式：</p>
<ul>
<li>return</li>
<li><p>抛出异常 </p>
<p>该区域会抛出 StackOverflowError 和 OutOfMemoryError</p>
</li>
</ul>
<p><strong>（3）Native Method Stack</strong>:<br> 除了上面的栈, 每个线程都有自己的 Native 方法执行栈， Java Stack 是线程执行字节码的栈, Native Stack 是线程执行 Native 代码的栈) ；</p>
<p> 该区域会抛出 StackOverflowError 和 OutOfMemoryError；</p>
<p><img src="/images/Advanced-Java.02b.JVM-Stack-model.png" alt="../_images/Advanced-Java.02b.JVM-Stack-model.png"></p>
<p>上图显示了正在执行三个线程的虚拟机实例的快照：线程 1 和 2 正在执行 Java Method。线程三是执行 Native Method。</p>
<p>Stack 显示为向下增长。每个线程的 Java Stack 的“栈顶”显示在图的底部。<br>对于当前正在执行 Java Method 的线程，pc 寄存器指示要执行的下一条指令。<br>由于线程 3 当前正在执行 Native Method，因此其 pc 寄存器（以深灰色显示的内容）的内容未定义。</p>
<blockquote>
<p>线程栈大小由参数 <code>-Xss</code> 指定, 默认 1m, 在 tomcat 这种多线程 web 服务器上, 保持 1m 或者更小可以处理更多的并发请求<br>Stack 和 Native Stack 都会抛出 StackOverFlowError 和 OutOfMemoryError 两种错误,</p>
<blockquote>
<p>StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。<br>OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。</p>
</blockquote>
</blockquote>
<h2 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h2><ul>
<li><p>方法区与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
</li>
<li><p>在 HotSpot 虚拟机中方法区也常被称为 “永久代”。也仅仅是 HotSpot VM 这么做，对于其他的虚拟机（如 Oracle JRockit、IBM J9 等）来说是不存在永久代的概念的。HotSpot 虚拟机设计团队用“永久代”来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Heap 一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。</p>
</li>
<li><p>在 HotSpot VM, <strong>永久代也是有 GC 的, 时机与老年代相同</strong>（再次提醒 <strong>永久代不属于堆</strong>）</p>
</li>
<li><p>HotSpot VM 的永久代大小由 <code>-XX:PermSize</code> ~ <code>-XX:MaxPermSize</code> 指定, 一般服务器设置为:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MaxPermSize=500m</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>JDK 1.6 时期，HotSpot 的永久代包括:</p>
<ol>
<li>Runtime Constant Pool, <strong>运行时常量池</strong></li>
<li>String Pool: <strong>字符串常量池</strong>, 以”Hello”字面量方式创建的字符串会存储在这里. 详见 「字符串在内存中的存储」</li>
</ol>
<p>如果运行时有大量的类产生，可能会导致方法区被填满直至溢出。报出 java.lang.OutOfMemoryError: PermGen space，常见的应用场景如：</p>
<ul>
<li>Spring 和 ORM 框架使用 CGLib 操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的 Class 可以加载入内存。</li>
<li>大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）。</li>
<li>基于 OSGi 的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）。</li>
</ul>
<h1 id="JDK7-时期"><a href="#JDK7-时期" class="headerlink" title="JDK7 时期"></a>JDK7 时期</h1><p>String Pool （字符串常量池）被从 PermGen 里移除了, 这部分字符串对象放在了 Heap 里, 并且可以通过 <code>-XX:StringTableSize</code> 指定其大小，这部分的变化参考 [[#字符串在内存中的存储]]</p>
<p>此外 JDK7 的内存模型基本和 6 一样;</p>
<h1 id="•JDK6-7-的-VM-参数总结"><a href="#•JDK6-7-的-VM-参数总结" class="headerlink" title="•JDK6~7 的 VM 参数总结"></a>•JDK6~7 的 VM 参数总结</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             &lt;JVM 6 &amp; 7 Memory options&gt;</span><br><span class="line">+-----------------+-----------------+--------------</span><br><span class="line">|     PC          |                 |</span><br><span class="line">|-----------------|-----------------+-------------</span><br><span class="line">|    Stack &amp;      |                 |</span><br><span class="line">|  Native Stack   |                 |  -Xss</span><br><span class="line">+-----------------+-----------------+---------------</span><br><span class="line">|   Method Area   |  String Pool &amp;  |</span><br><span class="line">|   (PermGen)     |    Runtime-     | -XX:MaxPermSize</span><br><span class="line">|                 |  Constant Pool  | -XX:PermSize</span><br><span class="line">+-----------------+-----------------+-------+-------+---</span><br><span class="line">|    OldGen       |                 |       |       |</span><br><span class="line">|  (TenuredGen)   |                 |       | -Xmx  |</span><br><span class="line">+-----------------+-----------------+-------+       |</span><br><span class="line">|                 |  To Survivor    |       |       | Heap</span><br><span class="line">|    YoungGen     |-----------------| -Xmn  |       |</span><br><span class="line">|                 |  From Survivor  |       | -Xms  |</span><br><span class="line">|                 |-----------------|       |       |</span><br><span class="line">|                 |     Eden        |       |       |</span><br><span class="line">+-----------------+-----------------+-------+-------+---</span><br></pre></td></tr></table></figure>
<h1 id="JDK8-时期-MetaSpace"><a href="#JDK8-时期-MetaSpace" class="headerlink" title="JDK8 时期(MetaSpace)"></a>JDK8 时期(MetaSpace)</h1><p>在 HotSpot JDK7以及更早的版本里, 永久代最大大小由 <code>-XX:MaxPermSize</code> 指定, 一旦超过这个大小就不能再扩展, 假如加载的类过多会导致 Medhod Area 过大而导致 OOM,</p>
<p>HotSpot JDK8 <strong>移除</strong> 了 JDK7 的 PermGen(永久代), 类的元信息被移到了 MetaSpace(元空间), 这块内存放在 Native memory 当中, 不再属于 JVM 线程内的内存区.<br>interned 的 String、类的 static 成员在堆区 <a href="https://stackoverflow.com/questions/8387989/where-are-static-methods-and-static-variables-stored-in-java" target="_blank" rel="noopener">jvm - Where are static methods and static variables stored in Java? - Stack Overflow</a></p>
<blockquote>
<p>JDK7 移除了 PermGen 的「字符串常量池」;<br>JDK8 移除了整个 PermGen, 类的元信息被放在 MateSpace;</p>
</blockquote>
<p>更多关于 MetaSpace -&gt; <a href="/12.Java/Advanced-Java.02b1.MetaSpace解析/" title="Advanced-Java.02b1.MetaSpace解析">Advanced-Java.02b1.MetaSpace解析</a></p>
<h1 id="JVM-分代设置大小建议"><a href="#JVM-分代设置大小建议" class="headerlink" title="JVM 分代设置大小建议"></a>JVM 分代设置大小建议</h1><ul>
<li>堆区的默认值最大 size 是256MB, 永久代默认最大 size 是64MB, <code>堆:永久代</code> 大约是是 <code>4:1</code> （Test @ JDK6 + Windows 32 bit）</li>
<li>每个分代大小比例(经验值): <code>Eden : Survivor0 : Survivor1 : OldGen : PermGen = 8 : 1 : 1 : 20 : 5</code></li>
<li>每个分代具体设置多大, 还可以根据 <strong>JVM 活跃数据</strong> 的大小进行估算:</li>
</ul>
<blockquote>
<p>活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是 Full GC 后堆中老年代占用空间的大小。可以通过 GC 日志中 Full GC 之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取 GC 数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下</p>
</blockquote>
<p><img src="/images/java/jvm-gensize-experience-point.png" alt="JVM_GenSize_Experience_Point"></p>
<p>例如，根据 GC 日志获得老年代的活跃数据大小为 300M，那么各分区大小可以设为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总堆：1200MB = 300MB × 4</span><br><span class="line">新生代：450MB = 300MB × 1.5</span><br><span class="line">老年代： 750MB = 1200MB - 450MB</span><br></pre></td></tr></table></figure>
<h1 id="变量在JVM内存中的存储"><a href="#变量在JVM内存中的存储" class="headerlink" title="变量在JVM内存中的存储"></a>变量在JVM内存中的存储</h1><p>不同方式创建的变量 &amp; 常量，在 JVM 存储的位置：</p>
<p><strong>Stack（栈区）</strong>：</p>
<ul>
<li>局部变量，保存在每个方法的栈帧中的“局部变量表”中</li>
<li>如果局部变量是类引用，引用本身也在局部变量表，引用指向的 object 在Heap</li>
</ul>
<p><strong>Heap（堆区）</strong>:</p>
<ul>
<li>每个 Object 对应的 Class Object</li>
<li>Object 的普通成员变量（除 static、final 之外的）</li>
<li>Object 的 static 成员：在堆</li>
<li>Object 的 final 成员：<ul>
<li>基本类型的 final（int、double）：在 Metaspace 的常量池</li>
<li>引用类型的 final：</li>
</ul>
</li>
<li>字符串常量(字面量): 字符串常量池在 JDK7 之后移到了堆区</li>
</ul>
<p><a href="https://www.baeldung.com/jvm-static-storage" target="_blank" rel="noopener">JVM Storage for Static Members | Baeldung</a>：</p>
<blockquote>
<p>Before Java 8, <strong>PermGen stores static members</strong> like static methods and static variables. Additionally, PermGen also stores interned strings.<br>As we’ve already discussed, <a href="https://www.baeldung.com/java-permgen-metaspace" target="_blank" rel="noopener">PermGen space is replaced with Metaspace in Java 8</a>, resulting in a change for memory allocation of the static members.<br>Since Java 8, Metaspace only stores the class metadata, and <strong>heap memory keeps the static members</strong>. Furthermore, the heap memory also provides storage for interned strings.</p>
</blockquote>
<p><strong>MateSpace</strong>:<br>这部分存储的内容参考 <a href="/12.Java/Advanced-Java.02b1.MetaSpace解析/" title="Advanced-Java.02b1.MetaSpace解析">Advanced-Java.02b1.MetaSpace解析</a></p>
<blockquote>
<p>对象在内存中的结构 @ref <a href="/12.Java/Advanced-Java.05.对象内存结构/" title="Advanced-Java.05.对象内存结构">Advanced-Java.05.对象内存结构</a></p>
</blockquote>
<h1 id="字符串在JVM内存中的存储"><a href="#字符串在JVM内存中的存储" class="headerlink" title="字符串在JVM内存中的存储"></a>字符串在JVM内存中的存储</h1><p>1.6之前的不管了，只看1.7及之后的：</p>
<ul>
<li>双引号创建的 <code>String s = &quot;hello&quot;</code>，存储在堆中，但是”hello”会被放入 Sring Pool</li>
<li><code>String s = new String(&quot;hello&quot;)</code> 涉及到两个 string 对象：构造方法创建的存储在 Heap，另一个双引号创建的在 String Pool；</li>
</ul>
<h2 id="String-Pool-与-String-intern"><a href="#String-Pool-与-String-intern" class="headerlink" title="String Pool 与 String.intern()"></a>String Pool 与 String.intern()</h2><p><del>Java 并不要求常量只在编译期产生, 并非只有 class 文件常量池的内容才能进入方法区的”运行时常量池”,<br>运行期间可以添加常量进入常量池, 比如 <code>String.intern()</code> 方法</del>;</p>
<p>intern() 的作用是将该字符串驻留在 String Pool 中，如果 String Pool 中已存在当前字符串，就会直接返回当前字符串引用. 如果常量池中没有此字符串, 会将此字符串放入 Pool 中后再返回；<br>但要注意：</p>
<ul>
<li>String Pool 中保存的是地址, 指向 Heap 中的 String 对象；</li>
<li>String Pool 是 C++实现的 HashTable，也就是 HashTable 对象是在 vm 的 Native 内存，而不是在 Heap，但指向的 String 在 Heap；</li>
<li>JDK7之后的 String Pool 是一个固定大小的 HashTable（通过 vm 参数 <code>-XX:StringTableSize</code> 指定大小，默认1009），因为 HashTable 大小固定，一旦 intern 的字符串数量过多，会导致链表过长，intern 性能下降，</li>
<li>这时 HashTable 也会 rehash，但不会扩容，而是重新生成 hash 的 seed 减少碰撞。但因为没有扩容，所以对于非常满的 HashTable，rehash 后效果不大；</li>
</ul>
<p>JDK7之后 String Pool 的实现在 <code>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">oop StringTable::intern(Handle string_or_null, jchar* name, <span class="keyword">int</span> len, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = java_lang_String::hash_string(name, len);</span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);</span><br><span class="line">  oop <span class="built_in">string</span> = the_table()-&gt;lookup(index, name, len, hashValue);</span><br><span class="line">  <span class="comment">// Found</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">string</span> != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// Otherwise, add to symbol to table</span></span><br><span class="line">  <span class="keyword">return</span> the_table()-&gt;basic_add(index, string_or_null, name, len, hashValue, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做的是 lookup 和 basic_add ，如果 hashTable 冲突严重导致链表过长，lookup 耗时也会增加；</p>
<p>➤ intern 使用场景：</p>
<ul>
<li>如果产生很多相同的字符串，intern 可以减少 string 对象的内存占用，但响应的增加了 intern 的耗时——主要是在 HashTable 的查找上</li>
<li><p>对于大量但重复的字符串，可以使用 intern 放入 String pool，并使用 intern 获取  ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String symbol = <span class="keyword">new</span> String(character).intern();</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了 Java 代码中可以调用，VM 的 C++代码也可以调用 intern 向 String Pool 中插入数据，例如 <code>Thread.currentThread().getStackTrace()</code>，获取类名和方法名是通过 intern 获取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">oop classname = StringTable::intern((<span class="keyword">char</span>*) str, CHECK_0);  </span><br><span class="line">oop methodname = StringTable::intern(method-&gt;name(), CHECK_0);  </span><br><span class="line">oop filename = StringTable::intern(source, CHECK_0);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>➤ intern 使用建议：</p>
<ul>
<li>如果创建的重复字符串很多，intern 可以减少内存使用</li>
<li>String Pool 大小由 vm 参数指定，不可动态修改，也不会扩容，是根据自身需要调整 <code>StringTableSize</code>，代码中使用 intern 的要能确认所需 String pool 的容量范围</li>
</ul>
<p>➤ GC 和 intern 的问题：</p>
<ul>
<li>YGC 时需要扫描 String Pool，防止其中的在 YoungGen 分配的 string 对象被回收<ul>
<li>@doubt：在 String Pool 中的 string 如果晋升 or 内存地址发生变化，需要同步修改 String Pool?</li>
<li>@doubt: oldGC 是不是也需要扫描 String Pool？</li>
</ul>
</li>
<li>既然 YGC 是需要扫描 String Pool 的，那么过于庞大的 String Pool 也会影响 YGC 时间</li>
</ul>
<p>@ref:</p>
<ul>
<li><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">深入解析String#intern - 美团技术团队</a></li>
<li><a href="http://lovestblog.cn/blog/2016/11/06/string-intern/" target="_blank" rel="noopener">JVM源码分析之String.intern()导致的YGC不断变长 - 你假笨</a></li>
</ul>
<h2 id="JDK6-7-8-的-String-Pool"><a href="#JDK6-7-8-的-String-Pool" class="headerlink" title="JDK6,7,8 的 String Pool"></a>JDK6,7,8 的 String Pool</h2><ol>
<li>JDK6: GermGen 的大小在64位机器上一般为96MB, 由 <code>-XX:MaxPermSize</code> 指定, String Pool(主要是个 C++描述的 StringTable)的大小默认是 1009(StringTable “桶”的大小), 且这个大小不能扩展, StringTable 的实现原理类似 HashMap, hash 值相同的会放进同一个桶的链表里. 如果太多调用了 <code>String.intern()</code>, 会导致这个 StringTable 性能下降.</li>
<li>JDK7: String Pool 从 PermGen 移到 Heap, 并且增加了 <code>-XX:StringTableSize</code> 参数可以配置 String Pool 的大小, <code>-XX:StringTableSize=1000003</code>.</li>
<li>JDK8: String Pool 与7相比没有太大变化, <code>-XX:StringTableSize</code> 默认是 60013, 可以用-XX:+PrintFlagsFinal 获取当前你使用的值是多少.</li>
</ol>
<blockquote>
<p>以上参考自：<a href="http://java-performance.info/string-intern-in-java-6-7-8/" target="_blank" rel="noopener">String.intern in Java 6, 7 and 8 - string pooling  - Java Performance Tuning Guide</a> @ref</p>
</blockquote>
<p>下面代码运行结果是 ?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>); <span class="comment">// 两个对象, 字面量"1" &amp; new 创建的str</span></span><br><span class="line">s.intern();</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line"><span class="comment">//s3.intern();</span></span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>
<p>先说答案: 在 JDK6 下结果是 “false false”, 在 JDK8 下是 “false, true”.</p>
<p>没有在 JDK8 上验证, 但我觉得 7 和 8 在 String Pool 上改动不大, 8 仅仅是把 Method Area 移动到了 Native Memory 中 –被叫做 Metespace(元空间)的区域.<br>因为看不到 HotSpot 的 native 层源码, 所以只能看 OpenJDK 的, 但是不保证 OpenJDK 与 HotSpot 实现一样 @todo 有时间一定要看了才能解惑.</p>
<blockquote>
<p>public String intern()<br>Returns a canonical representation for the string object.<br>A pool of strings, initially empty, is maintained privately by the class String.<br>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.</p>
</blockquote>
<p>从 JDK6 到 JDK7 的 String Pool 和 <code>intern</code> 方法的改变都比较大(String Pool 从 PermGen 移动到了 Heap, <code>String.intern()</code> 改变见下面的分析)</p>
<p><strong>in JDK6:</strong></p>
<ul>
<li><code>String s = new String(&quot;Hello&quot;)</code> 会创建两个字符串对象, 一个在 String Pool 里的字面值, 一个是 Heap 里的对象.</li>
<li><code>intern()</code> 方法首先在 String Pool 里查找是否有 equals 的字符串, 如果没有则在 String Pool 创建一个字面量字符串, 并返回其引用. 已经存在的话返回在 String Pool 里的引用.</li>
</ul>
<blockquote>
<ul>
<li><code>String s = new String(&quot;1&quot;)</code>, s 创建后, String Pool 和 Heap 各创建一个”1”, s 指向的是 Heap 里的对象;</li>
<li><code>String s2 = &quot;1&quot;</code>, s2 指向的是 String Pool 里的字面值;</li>
<li><code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)</code>  这时”11”在内存里只有 Heap 里的一个, s3 指向这个 Heap 里的对象,</li>
<li><code>s3.intern</code> 之后 String Pool 里也创建一个”11”;</li>
<li><code>String s4 = &quot;11&quot;</code> s4 指向的是 String Pool 里的对象</li>
</ul>
</blockquote>
<p><strong>in JDK7:</strong></p>
<ul>
<li><code>String s = new String(&quot;Hello&quot;)</code> 的行为跟 6 一样;</li>
<li><code>str.intern()</code> 执行后, 如果再 String Pool 里没有到 equals 的字符串, 就不再在 String Pool 里创建对象了, 而是直接把 Heap 里的对象引用放进来. // 这也是 6-&gt;7 的 String 的一个重要改变, 减少重复的字符串创建, 也更节省内存.</li>
</ul>
<blockquote>
<ul>
<li><code>String s = new String(&quot;1&quot;)</code>, s 创建后, String Pool 和 Heap 各创建一个”1”, s 指向的是 Heap 里的对象;</li>
<li><code>s.intern()</code> 检查 String Pool 里已经存在”1”的字面值了, 什么都不做;</li>
<li><code>String s2 = &quot;1&quot;</code>, s2 指向的是 String Pool 里的字面值, 故 <code>s == s2</code> 输出 false；</li>
<li><code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)</code>  这时”11”在内存里只有 Heap 里的一个, s3 指向这个 Heap 里的对象,</li>
<li><code>s3.intern()</code> 在 String Pool 里找不到”11”, 但是不再创建新的, 而是直接把 s3 的引用复制进 String Pool,</li>
<li><code>String s4 = &quot;11&quot;</code> 这种方式创建是指明在 String Pool 里创建, 但是 String Pool 里已经存在一个”11”的引用了, 那么 s4 直接指向这个引用. 所以 s3 和 s4 指向的都是 Heap 里的”11”, 故 <code>s3== s4</code> 输出 true；</li>
</ul>
</blockquote>
<h1 id="•内存分区可能抛出的错误"><a href="#•内存分区可能抛出的错误" class="headerlink" title="•内存分区可能抛出的错误"></a>•内存分区可能抛出的错误</h1><ul>
<li>Stack : <code>StackOverflowError</code> &amp; <code>OutOfMemoryError</code></li>
<li>Heap: <code>OutOfMemoryError</code></li>
<li>Method: <code>OutOfMemoryError: PermGen space</code>  (1.8 之前)</li>
<li>MetaSpace: <code>OutOfMemoryError: Metaspace</code> (1.8+):</li>
</ul>
<p>@ref： <a href="https://juejin.cn/post/6882579270439272461#heading-7" target="_blank" rel="noopener">JVM相关 - StackOverflowError 与 OutOfMemoryError - 掘金</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/12.Java/Advanced-Java.02a.JVM简介/" rel="next" title="Advanced Java-02a-JVM简介">
                <i class="fa fa-chevron-left"></i> Advanced Java-02a-JVM简介
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/12.Java/Advanced-Java.02b1.MetaSpace解析/" rel="prev" title="Advanced-Java.02b1.MetaSpace解析">
                Advanced-Java.02b1.MetaSpace解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">467</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">407</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK6-时期"><span class="nav-text">JDK6 时期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap"><span class="nav-text">Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#YoungGen-新生代"><span class="nav-text">YoungGen(新生代)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Eden-区的-TLAB"><span class="nav-text">Eden 区的 TLAB</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OldGen-老年代"><span class="nav-text">OldGen(老年代)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack"><span class="nav-text">Stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-Area"><span class="nav-text">Method Area</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK7-时期"><span class="nav-text">JDK7 时期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#•JDK6-7-的-VM-参数总结"><span class="nav-text">•JDK6~7 的 VM 参数总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK8-时期-MetaSpace"><span class="nav-text">JDK8 时期(MetaSpace)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-分代设置大小建议"><span class="nav-text">JVM 分代设置大小建议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量在JVM内存中的存储"><span class="nav-text">变量在JVM内存中的存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串在JVM内存中的存储"><span class="nav-text">字符串在JVM内存中的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String-Pool-与-String-intern"><span class="nav-text">String Pool 与 String.intern()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK6-7-8-的-String-Pool"><span class="nav-text">JDK6,7,8 的 String Pool</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#•内存分区可能抛出的错误"><span class="nav-text">•内存分区可能抛出的错误</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/12.Java/Advanced-Java.02b.JVM内存结构/';
          this.page.identifier = '12.Java/Advanced-Java.02b.JVM内存结构/';
          this.page.title = 'Advanced Java-02b-JVM运行时内存结构';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
