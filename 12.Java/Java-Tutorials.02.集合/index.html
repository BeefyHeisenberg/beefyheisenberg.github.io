<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Java基础," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="集合类继承关系Java核心类库提供了两大类容器, Collection(集合)和Map, 其中Collection接口又派生出List, Queue, Set三种接口:  容器顶层接口Collection/Map以及主要实现类 &amp;amp; 继承关系: java.util.Collection [I]    java.util.List [I]        ArrayList        Lin">
<meta name="keywords" content="Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Tutorials-02-集合">
<meta property="og:url" content="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.02.集合/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="集合类继承关系Java核心类库提供了两大类容器, Collection(集合)和Map, 其中Collection接口又派生出List, Queue, Set三种接口:  容器顶层接口Collection/Map以及主要实现类 &amp;amp; 继承关系: java.util.Collection [I]    java.util.List [I]        ArrayList        Lin">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/java-collection-hierarchy.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/java_collection_vs_collections.jpeg">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/hashmap-load-factor-poisson-distribution.png">
<meta property="og:updated_time" content="2022-10-11T11:56:58.743Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Tutorials-02-集合">
<meta name="twitter:description" content="集合类继承关系Java核心类库提供了两大类容器, Collection(集合)和Map, 其中Collection接口又派生出List, Queue, Set三种接口:  容器顶层接口Collection/Map以及主要实现类 &amp;amp; 继承关系: java.util.Collection [I]    java.util.List [I]        ArrayList        Lin">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/java/java-collection-hierarchy.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.02.集合/"/>





  <title>Java Tutorials-02-集合 | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.02.集合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Tutorials-02-集合</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/12-Java/" itemprop="url" rel="index">
                    <span itemprop="name">12.Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,911
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="集合类继承关系"><a href="#集合类继承关系" class="headerlink" title="集合类继承关系"></a>集合类继承关系</h1><p>Java核心类库提供了两大类容器, Collection(集合)和Map, 其中Collection接口又派生出List, Queue, Set三种接口:</p>
<p><img src="/images/java/java-collection-hierarchy.gif" alt="Hierarchy of Collection"></p>
<p>容器顶层接口Collection/Map以及主要实现类 &amp; 继承关系:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.Collection [I]</span><br><span class="line">    java.util.List [I]</span><br><span class="line">        ArrayList</span><br><span class="line">        LinkedList*</span><br><span class="line">        Vector</span><br><span class="line">            Stack</span><br><span class="line">    java.util.Queue [I]</span><br><span class="line">        LinkedList*</span><br><span class="line">        PriorityQueue</span><br><span class="line">    java.util.Deque [I]</span><br><span class="line">        LinkedList</span><br><span class="line">    java.util.Set [I]</span><br><span class="line">        TreeSet*</span><br><span class="line">        HashSet*</span><br><span class="line">            LinkedHashSet</span><br><span class="line">java.util.Map [I]</span><br><span class="line">        TreeMap*</span><br><span class="line">        HashMap*</span><br><span class="line">            LinkedHashMap</span><br></pre></td></tr></table></figure>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>Collection接口方法:</p>
<ul>
<li><code>add()</code>: ArrayList和LinkedList都是append to end</li>
<li><code>remove(Object)</code>:  遍历整个并equals判断是否相等, 然后删除</li>
<li><code>contains(Object)</code>: 都是O(N)遍历</li>
<li><code>containsAll(Collection&lt;?&gt; c):</code> 不是测试是否包含连续的集合, 比如String.indexOf那样</li>
<li><code>size()</code>:</li>
<li><code>toArray()</code>: 生成数组</li>
<li><code>iterator()</code>: 返回迭代器Iterator<e>, 它具有next()方法, 用于每次返回一个元素, 直到循环器中元素穷尽:</e></li>
<li>从Object继承的<code>equals()</code>, <code>hashCode()</code>等…</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List接口常用方法:</p>
<ul>
<li><code>add(int index, E element)</code>:<br>Inserts the specified element at the specified position in this list (optional operation).</li>
<li><code>addAll(Collection&lt;? extends E&gt; c)</code>:<br>Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection’s iterator (optional operation).</li>
<li><code>contains(Object o)</code>:<br>Returns true if this list contains the specified element.</li>
<li><code>containsAll(Collection&lt;?&gt; c)</code>:<br>Returns true if this list contains all of the elements of the specified collection.</li>
<li><code>retainAll(Collection&lt;?&gt; c)</code>:<br>Retains only the elements in this list that are contained in the specified collection (optional operation).</li>
<li><code>sort(Comparator&lt;? super E&gt; c)</code>:<br>Sorts this list according to the order induced by the specified Comparator.</li>
<li><code>subList(int fromIndex, int toIndex)</code>:<br>Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive.</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList内部是<code>Object[]</code>数组实现, 数组初始大小10, 每次扩展为原大小的 1.5倍, 随机访问性能好, 插入/删除代价较大, iterator是整数封装.<br>ArrayList实现了List接口:</p>
<ul>
<li><code>iterator()</code>, <code>listIterator()</code>, <code>listIterator(index)</code></li>
<li><code>add(E)</code>, <code>add(index,E)</code>, <code>addAll(Collection)</code></li>
<li><code>remove(E)</code>, <code>remove(index)</code>, <code>removeAll(Collection)</code></li>
<li><code>set(index,E)</code></li>
<li><code>sort(Comparator&lt;? super E&gt; c)</code>: 实际调用了<code>Arrays.sort()</code></li>
<li><code>subList(start,end)</code>: 返回的并不是ArrayList ,而是ArrayList的一个视图, 对于SubList的所有操作最终会反映到原列表上。</li>
<li><code>retainAll(Collection)</code> 保留ArrayList中和Collection中共有的元素(但会改变ArrayList, 没有在Collection中的元素会从ArrayList里删除)</li>
<li><code>Object[] toArray()</code>: 对该方法返回的数组, 进行操作（增删改查）都不会影响原集合的数据（ArrayList中elementData）</li>
<li>使用工具类<code>Arrays</code>的 <code>asList()</code>方法把数组转换成集合后, 不能使用该集合的<code>add</code>/<code>remove</code>/<code>clear</code>方法, 否则抛出 <code>UnsupportedOperationException</code> 异常。<blockquote>
<p>说明: <code>asList()</code> 的返回对象是一个 Arrays 内部类,并没有实现集合的修改方法。<code>Arrays.asList()</code> 体现的是适配器模式,只是转换接口,后台的数据仍是数组。</p>
</blockquote>
</li>
</ul>
<p>➤ 扩容:</p>
<ul>
<li><code>ArrayList()</code> 创建的数组大小是0, 第一次add()的时候会把数组扩容到<code>DEFAULT_CAPACITY</code>, 也就是10,</li>
<li>每次调用<code>add()</code>的时候都会检查一下添加后的数组大小是否比当前的数组大, 如果是则扩大到 1.5倍原数组的大小. <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> // 为什么是x1.5倍?<ul>
<li>所以ArrayList(默认构造函数)每次扩容的大小是: 0, 10, 15, 22, 33, 49 …</li>
<li>如果在构造ArrayList时就指定了初始大小为N, 则扩容大小是, N, 1.5N …</li>
</ul>
</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>链表实现, 随机访问性能差, 插入/删除较快, iterator是引用封装.<br>LinkedList同时实现了List, Queue, Deque接口:</p>
<ul>
<li><code>add(E)</code>, <code>add(index,E)</code>, <code>addAll(Collection)</code></li>
<li><code>poll()</code>, <code>offer(E)</code> … 所有Queue接口的方法</li>
<li><code>addFirst(E)</code>, <code>addLast(E)</code>, <code>offerFirst(E)</code>, <code>offerLast(E)</code> … 所有Deque接口的方法</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>类似ArrayList, Object[]数组实现, 包括的方法参考ArrayList, synchronized同步 @弃用</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><code>push()</code>入栈, <code>pop()</code>弹出栈顶部元素, <code>peek()</code>获取栈顶但不弹出顶部元素,<br>Stack实际就是对Vector包装了一层, 所以也是synchronized同步</p>
<h2 id="Queue-amp-Deque"><a href="#Queue-amp-Deque" class="headerlink" title="Queue &amp; Deque"></a>Queue &amp; Deque</h2><h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h3><ul>
<li><code>offer</code> , <code>add</code>: 添加元素到队列尾部.<br>当队列满时, offer返回false, add抛出异常.</li>
<li><code>poll</code> , <code>remove</code>: 返回队列头部的元素, 并移除出这个元素.<br>当队列为空时, poll返回false, remove抛出异常.</li>
<li><code>peek</code> , <code>element</code>: 返回队列头部的元素但不移除它.<br>当队列空时, peek返回false, element抛出异常.</li>
</ul>
<h3 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h3><ul>
<li><code>offerFirst</code>, <code>offerLast</code> : 添加元素到队列, 失败返false</li>
<li><code>addFirst</code>, <code>addLast</code> :    添加元素到队列, 失败抛异常</li>
<li><code>pollFirst</code>, <code>poolLast</code> :  返回并移出元素, 失败返false</li>
<li><code>removeFirst</code>, <code>removeLast</code> : 返回并移出元素, 失败抛异常</li>
<li><code>peekFirst</code>, <code>peekLast</code> :     返回但不移出, 失败返false</li>
<li><code>elementFirst</code>, <code>elementLast</code> : 返回但不移出, 失败抛异常</li>
</ul>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><ul>
<li><code>LinkedList</code>: 双向链表, 同时实现了Deque和Queue接口, 它是唯一一个允许放入null的Queue；</li>
<li><code>ArrayDeque</code>: 以循环数组实现的双向Queue，默认初始大小是16，每次扩容double。<br>普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有指向队头/队尾两个下标值.<br>从队列取出元素时，表示队头下标值++；<br>向队列插入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组0位置。<br>如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</li>
</ul>
<p><strong>带优先级的队列</strong> :</p>
<ul>
<li><p><code>PriorityQueue</code>: 用二叉堆实现的优先级队列。出队列的顺序不是按照FIFO的顺序, 而是按照插入元素来排序。插入的元素必须实现Comparable, 或者在PriorityQueue构造器传入Comparator,<br>优先级队列是无界的，但是有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。<br>优先级队列不允许 null 元素。</p>
<blockquote>
<p>二叉堆 @ref: <a href="https://blog.csdn.net/lcore/article/details/9100073" target="_blank" rel="noopener">数据结构之优先队列–二叉堆(Java实现) - LCore的专栏 - CSDN博客</a></p>
</blockquote>
</li>
</ul>
<p><strong>线程安全的阻塞/非阻塞队列</strong>, 详见<a href="#线程安全的队列">线程安全的队列</a> :</p>
<ul>
<li>阻塞：<code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>LinkedBlockingDeque</code>；</li>
<li>非阻塞： <code>ConcurrentLinkedQueue</code> / <code>ConcurrentLinkedDeque</code>；</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是不能包含重复的元素的集合, Set接口常用方法:</p>
<ul>
<li><code>add(E e)</code></li>
<li><code>addAll(Collection&lt;? extends E&gt; c)</code></li>
<li><code>contains(Object o)</code></li>
<li><code>containsAll(Collection&lt;?&gt; c)</code></li>
<li><code>retainAll(Collection&lt;?&gt; c)</code></li>
<li><code>toArray()</code></li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 是一个没有重复元素的集合. 元素并没有以某种特定顺序来存放,<br>HashSet内部实现是使用了HashMap的<code>transient HashMap&lt;E,Object&gt; map</code>, <code>add(E)</code>方法实际调用的是<code>hashMap.put(e,PRESENT)</code></p>
<blockquote>
<p>@ref: <a href="http://wangkuiwu.github.io/2012/02/16/collection-16-hashset/" target="_blank" rel="noopener">Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet 可以按照插入顺序对元素进行遍历.<br>LinkedHashSet 继承了 HashSet, 内部是基于 LinkedHashMap 来实现的. 可以在LinkedHashSet构造器看出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet是基于TreeMap实现的.<br>TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序. 这取决于使用的构造方法.<br>TreeSet的add、remove 和 contains方法的时间复杂度是O(logn).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Item t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        return 0; 相等</span></span><br><span class="line"><span class="comment">        return 1; this大</span></span><br><span class="line"><span class="comment">        return -1; 比较的更大</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.val &gt; t.val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.val &lt; t.val) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Teacher&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;Item&gt;();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">3</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">1</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Item(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//遍历输出:</span></span><br><span class="line">        Iterator itTSet = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(itTSet.hasNext())</span><br><span class="line">            System.out.print(itTSet.next() + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@ref: <a href="http://wangkuiwu.github.io/2012/02/17/collection-17-treeset/" target="_blank" rel="noopener">Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator: 迭代器"></a>Iterator: 迭代器</h1><ul>
<li>Iterator接口的方法<ul>
<li><code>hasNext</code>: 返回true或false</li>
<li><code>next</code>: 迭代器后移一次之后, 回迭代器前面的元素</li>
<li><code>remove</code>: 删除上次next()返回的, 所以新创建迭代器之后, 必须先next一次才能remove. 一次remove之前必须有一次next, 不能连续调用remove;</li>
<li><code>add</code>: Iterator接口没有add, 但ArrayList和LinkedList的内部Itr都实现了add. 在当前迭代器之前插入. 如果创建了迭代器后立刻add, 则是插入到首位.</li>
</ul>
</li>
<li>ArrayList的Iterator:<ul>
<li>属性<code>int cursor</code>和<code>int lastRet</code>分别用来记录”下次next方法要返回的元素位置” 和”上次next方法返回的”, 初始值分别是0和-1;</li>
<li>创建迭代器:<ul>
<li>方法1: ArrayList.iterator()</li>
<li>方法2: ArrayList.listIterator(), 返回的迭代器有<code>add(Ele)</code>方法用于插入新元素;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="How-to-iterate-collection"><a href="#How-to-iterate-collection" class="headerlink" title="How to iterate collection"></a>How to iterate collection</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; itr = collection.iterator(); i.hasNext();) &#123;</span><br><span class="line">    System.out.print(itr.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="集合泛型算法"><a href="#集合泛型算法" class="headerlink" title="集合泛型算法"></a>集合泛型算法</h1><p><strong>Collection &amp; Collections &amp; Arrays:</strong></p>
<ul>
<li><code>java.util.Collection&lt;E&gt;</code> 是一个泛型接口;</li>
<li><code>java.util.Collections</code> 是一个集合工具类, 提供一些操作集合的通用方法;</li>
<li><code>java.utils.Arrays</code> 是一个集合工具类, 提供操作数组的通用方法, 例如merge, sort等;</li>
<li><code>java.lang.reflect.Array</code> 类提供了数组的反射方法;</li>
</ul>
<p>图-Collection类 vs Collections类:<br><img src="/images/java/java_collection_vs_collections.jpeg" alt="Collection vs Collections"></p>
<h2 id="排序操作（主要针对List接口相关）"><a href="#排序操作（主要针对List接口相关）" class="headerlink" title="排序操作（主要针对List接口相关）"></a>排序操作（主要针对List接口相关）</h2><ul>
<li><code>reverse(List list)</code>：反转指定List集合中元素的顺序</li>
<li><code>rotate(List list, int distance)</code>：将所有元素向右移位指定长度, 如果distance等于size那么结果不变</li>
<li><code>shuffle(List list)</code>：对List中的元素进行随机排序（洗牌）</li>
<li><code>sort(List list)</code>：对List里的元素根据自然升序排序</li>
<li><code>sort(List list, Comparator c)</code>：自定义比较器进行排序</li>
<li><code>swap(List list, int i, int j)</code>：将指定List集合中i处元素和j出元素进行交换</li>
</ul>
<blockquote>
<p>如果要使用Collections.sort, 则要求集合内存放的类型必须实现Comparable接口</p>
</blockquote>
<h2 id="查找和替换（主要针对Collection接口相关）"><a href="#查找和替换（主要针对Collection接口相关）" class="headerlink" title="查找和替换（主要针对Collection接口相关）"></a>查找和替换（主要针对Collection接口相关）</h2><ul>
<li><code>binarySearch(List list, Object key)</code>：使用二分搜索法, 以获得指定对象在List中的索引, 前提是集合已经排序</li>
<li><code>fill(List list, Object obj)</code>：使用指定对象填充</li>
<li><code>frequency(Collection Object o)</code>：返回指定集合中指定对象出现的次数</li>
<li><code>max(Collection coll)</code>：返回最大元素</li>
<li><code>max(Collection coll, Comparator comp)</code>：根据自定义比较器, 返回最大元素</li>
<li><code>min(Collection coll)</code>：返回最小元素</li>
<li><code>min(Collection coll, Comparator comp)</code>：根据自定义比较器, 返回最小元素</li>
<li><code>replaceAll(List list, Object old, Object new)</code>：替换</li>
</ul>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map不是继承Collection接口, 也没有继承Iterable接口, Map接口提供的方法:</p>
<ul>
<li><code>put(k,v)</code>, <code>get(k)</code>, <code>containsKey(k)</code>, <code>containsValue(v)</code></li>
<li><code>remove(k)</code>, <code>replace(k,v1,v2)</code></li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>HashMap 是一个散列表, 它存储的内容是键值对(key-value)映射.</li>
<li>HashMap 继承于AbstractMap, 实现了 Map、Cloneable、java.io.Serializable接口.</li>
<li>HashMap 的实现不是同步的, 这意味着它不是线程安全的. 它的 key、value都可以为null. 此外, HashMap中的映射不是有序的.</li>
</ul>
<p>HashMap 的实例有两个参数影响其性能: “初始容量” 和 “加载因子”. 容量 是哈希表中桶的数量, 初始容量 只是哈希表在创建时的容量.<br>加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度.<br>当哈希表中的条目数超出了加载因子与当前容量的乘积时, 则要对该哈希表进行 rehash 操作（即重建内部数据结构）, 从而哈希表将具有大约两倍的桶数.</p>
<p>通常, 默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷.<br>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子, 以便最大限度地减少 rehash 操作次数. 如果一个Map的初始容量大于”最大条目数”乘以加载因子, 则不会发生 rehash 操作.</p>
<h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>HashMap几个重要成员:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node[] table;     // 桶</span><br><span class="line">float loadFactor; // 负载因子</span><br><span class="line">int threshold;    // 等于table.length x loadFactor,  所能容纳的key-value对极限</span><br><span class="line">int modCount;     // 记录HashMap内部结构发生变化的次数</span><br><span class="line">int size;         // HashMap当前容纳键值对的数量</span><br></pre></td></tr></table></figure>
<p><code>put(Key, Val)</code>函数大致的实现为:</p>
<ul>
<li>计算<code>Key</code>的hashCode, 创建新的Node对象 <code>new Node(hash, key, value, null)</code> // node存储了hashCode, Key, Val</li>
<li>然后再计算<code>Key</code>在桶里的index （index等于<code>table.length-1 &amp; hash</code>）;</li>
<li>如果没碰撞(table[index] == null), 把node直接放到table数组里: <code>table[index]=node</code>；</li>
<li>如果碰撞了(table[index] != null), 则判断<code>table[i]</code>的首个元素的key是否hashCode相同 &amp;&amp; key equals 为真;<ul>
<li>是, 是则覆盖掉旧的value;</li>
<li>否, 插入到<code>table[i]</code>的链表里, 所以链表里保存是”Key的hashCode相同, 但Key不equal的元素”;</li>
</ul>
</li>
<li>如果碰撞导致链表过长(大于等于<code>TREEIFY_THRESHOLD</code>, 8), 就把这条链表转换成红黑树；</li>
<li><p>如果map内的元素总数超过<code>table.length x loadFactor</code>, 就要resize（扩容）</p>
<blockquote>
<p>上面提到了 <code>table[index]</code>在哈希冲突时候, 会把 table[index] 处理成链表, 当链表过长的时候, 链表的遍历性能是O(n), 很差, 所以<br>当链表长度&gt;=8时, 转成查找效率更高的红黑树;</p>
</blockquote>
</li>
</ul>
<p><code>get(k)</code>函数的实现: 这里省略了部分步骤, 只看当 <code>table[i]</code> 是链表 or 红黑树的情况:<br>遍历链表or树, 判断Key是否equal, 如果是, 返回该节点;</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>table[]数组double, 把所有元素re-hash放到扩容后的table[]中.</p>
<blockquote>
<p>在HashMap中, 哈希桶数组table的长度length大小必须为2的n次方(一定是合数), 这是一种非常规的设计, 常规的设计是把桶的大小设计为素数. 相对来说素数导致冲突的概率要小于合数,<br>HashMap采用这种非常规设计, 主要是为了在取模和扩容时做优化, 同时为了减少冲突, HashMap定位哈希桶索引位置时, 也加入了高位参与运算的过程.</p>
</blockquote>
<p>@ref: <a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap -</a></p>
<h3 id="解决哈希表冲突"><a href="#解决哈希表冲突" class="headerlink" title="解决哈希表冲突"></a>解决哈希表冲突</h3><ul>
<li>开放定址法: $ Hi = (Hash(Key) + di) % N $ 其中 i = 1,2,3…N-1(k&lt;=N-1), 根据di的取值, 开放定址法分为<ul>
<li>线性探测法: $ di = 1,2,3… $</li>
<li>平方探测法: $ di = i^2  $  @Uncertain</li>
<li>随机探测法: di随机数</li>
<li>开放定址法的优劣: 节省空间, 删除麻烦</li>
</ul>
</li>
<li>再哈希法:</li>
<li>链地址法: (HashMap使用此方法), 需要额外存储空间</li>
</ul>
<h3 id="为什么是0-75"><a href="#为什么是0-75" class="headerlink" title="为什么是0.75?"></a>为什么是0.75?</h3><p>从前面可知, 新添加进来的 Key-Value, 通过<code>key.hashCode</code>计算地址存放, 发现当前位置已经有元素, 则称为元素的碰撞, 需要重新计算或者其他方式放置该元素.<br>HashMap为了避免碰撞采取的优化策略, 简单的说, 原本可以放100个数据的空间, 当放到80个的时候, 根据经验, 接下去冲突的可能性会更加高. 因此就自动增加空间来减小冲突可能性.<br>数组大小与碰撞几率服从泊松分布, 根据经验在0.75处几率最小.</p>
<p><img src="/images/java/hashmap-load-factor-poisson-distribution.png" alt="HashMap_Load_Factor_Poisson_Distribution"></p>
<ul>
<li>@ref <a href="https://zhuanlan.zhihu.com/p/149687607" target="_blank" rel="noopener">面试官：为什么 HashMap 的加载因子是0.75？ - 知乎</a></li>
<li>@ref <a href="https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noopener">泊松分布和指数分布：10分钟教程 - 阮一峰的网络日志</a></li>
</ul>
<h3 id="Set视图"><a href="#Set视图" class="headerlink" title="Set视图"></a>Set视图</h3><p>获取HashMap的Set视图: <code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>, 返回类型是<code>EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</code>, EntrySet的方法:</p>
<ul>
<li>size(), 直接返回HashMap的size</li>
<li>forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action)</li>
</ul>
<blockquote>
<p><a href="http://wangkuiwu.github.io/2012/02/10/collection-10-hashmap/" target="_blank" rel="noopener">Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul>
<li>LinkedHashMap 继承自 HashMap, 它能保证遍历元素时, 输出的顺序和输入时的顺序相同.</li>
<li>LinkedHashMap 不仅实现HashMap的开散列哈希表（数组+链表）, 还维护着一个运行于所有键值对的双向链接列表. 此列表定义了迭代的顺序, 该迭代顺序包括插入顺序和访问顺序两种, 默认是插入顺序；可以通过设置 accessOrder为 true, 把迭代顺序设置为访问顺序.</li>
<li>LinkedHashMap 重写了父类的 HashMap 的get方法: 在调用父类的 getEntry() 方法取得查找的元素之后, 再判断排序模式 accessOrder是否为true, 如果是, 那么就把最新访问的元素添加到双向链表的表头, 并从原来的位置删除（可以用来实现LRU）. 因为链表的插入和删除操作都是常量级的时间复杂度, 所以不会带来性能损失.</li>
<li>LinkedHashMap 在保留 HashMap 的查找效率的同时, 保持元素输出的顺序和输入时的顺序相同, 并提供了元素的LRU访问.</li>
</ul>
<blockquote>
<p>参考: <a href="https://blog.csdn.net/u014313009/article/details/24520851" target="_blank" rel="noopener">LinkedHashMap内部实现</a> @ref</p>
</blockquote>
<h3 id="LinkedHashMap-amp-HashMap代码比较"><a href="#LinkedHashMap-amp-HashMap代码比较" class="headerlink" title="LinkedHashMap &amp; HashMap代码比较"></a>LinkedHashMap &amp; HashMap代码比较</h3><ul>
<li>LinkedHashMap 继承自 HashMap;</li>
<li>HashMap的桶数组 <code>HashMap.Node&lt;K,V&gt; table[]</code>, HashMap.Node&lt;K,V&gt;继承自Map.Entry&lt;K,V&gt;;</li>
<li>LinkedHashMap的<code>Entry</code>继承自<code>HashMap.Node&lt;K,V&gt;</code>, （与<code>HashMap.Node</code>相比）增加了before/after两个引用做双向链表</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap 是一个有序的key-value集合, TreeMap 根据Key的自然顺序进行排序, 或者根据TreeMap构造器提供的 Comparator进行排序.<br>内部是基于红黑树（Red-Black tree）的 NavigableMap实现.<br>TreeMap的基本操作 <code>containsKey</code>、<code>get</code>、<code>put</code> 和 <code>remove</code> 的时间复杂度是 <strong>log(n)</strong>.</p>
<ul>
<li>TreeMap 是一个有序的key-value集合, 它是通过红黑树实现的.</li>
<li>TreeMap 继承于AbstractMap, 所以它是一个Map, 即一个key-value集合.</li>
<li>TreeMap 实现了NavigableMap接口, <code>descendingKeySet()</code>方法返回一个与原顺序相反的值的一个Set集合, 其实是指向同一块内存区域, 在该视图上的任何修改都会影响到原始的数据.</li>
<li>TreeMap 实现了Cloneable接口, 意味着它能被克隆.</li>
<li>TreeMap 实现了java.io.Serializable接口, 意味着它支持序列化.</li>
</ul>
<blockquote>
<p><a href="http://wangkuiwu.github.io/2012/02/12/collection-12-treemap/" target="_blank" rel="noopener">Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例</a></p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>TreeMap的特点: 1 插入的元素可以按Key的自然顺序遍历, 2 像HashMap一样近似O(1)的查找复杂度;<br>二叉堆满足1, 但是不满足2,<br>红黑树的中序遍历可以满足1, 同时红黑树的查找复杂度(参考BST)是<code>O(logN)</code></p>
<ul>
<li><code>put</code>: 如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。</li>
<li><code>get</code>: log(n)</li>
<li>顺序遍历: 中序遍历</li>
</ul>
<h3 id="为什么采用红黑树"><a href="#为什么采用红黑树" class="headerlink" title="为什么采用红黑树"></a>为什么采用红黑树</h3><p>排序二叉树虽然可以快速检索, 但在最坏的情况下: 如果插入的节点集本身就是有序的（比如由小到大排列, 或是由大到小排列）,<br>那么最后得到的排序二叉树将变成链表: 所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）.<br>在这种情况下, 排序二叉树就变成了普通链表, 其检索效率就会很差.<br>为了改变排序二叉树存在的不足, Rudolf Bayer 与 1972 年发明了另一种改进后的排序二叉树: 红黑树, 他将这种排序二叉树称为”对称二叉 B 树”, 而红黑树这个名字则由 Leo J. Guibas 和 Robert Sedgewick 于 1978 年首次提出.</p>
<blockquote>
<p>参考: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">教你透彻了解红黑树</a> @ref</p>
</blockquote>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul>
<li>HashTable的方法都是采用了<code>synchronized</code>同步.</li>
<li>高并发场景下不推荐使用HashTable, 应该使用<code>java.util.concurrent.ConcurrentHashMap</code>替代.</li>
</ul>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>这种Map通常用在数据缓存中.它将键存储在WeakReference中, 就是说, 如果没有强引用指向键对象的话, 这些键就可以被垃圾回收线程回收</p>
<h2 id="关于Map-Entry"><a href="#关于Map-Entry" class="headerlink" title="关于Map.Entry"></a>关于Map.Entry</h2><p>HashMap有一个该类型的属性: <code>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</code>,<br>该属性在调用<code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>方法内被初始化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EntrySet</code>类是HashMap的一个static内部类, 定义了<code>forEach</code>方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="How-to-iterate-map"><a href="#How-to-iterate-map" class="headerlink" title="How to iterate map"></a>How to iterate map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// entry.getKey()</span></span><br><span class="line">    <span class="comment">// entry.getValue()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">//map.get(key);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">Iterator it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)it.next();</span><br><span class="line">    <span class="comment">// entry.getKey(), entry.getValue()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java基础/" rel="tag"># Java基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/12.Java/Java-Tutorials.01.基础/" rel="next" title="Java Tutorials-01-基础">
                <i class="fa fa-chevron-left"></i> Java Tutorials-01-基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/12.Java/Java-Tutorials.03.反射/" rel="prev" title="Java Tutorials-03-反射">
                Java Tutorials-03-反射 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">402</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">327</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#集合类继承关系"><span class="nav-text">集合类继承关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Collection接口"><span class="nav-text">Collection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList"><span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList"><span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector"><span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack"><span class="nav-text">Stack</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-amp-Deque"><span class="nav-text">Queue &amp; Deque</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue接口"><span class="nav-text">Queue接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deque接口"><span class="nav-text">Deque接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现类"><span class="nav-text">实现类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet"><span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet"><span class="nav-text">LinkedHashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet"><span class="nav-text">TreeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Iterator-迭代器"><span class="nav-text">Iterator: 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-iterate-collection"><span class="nav-text">How to iterate collection</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合泛型算法"><span class="nav-text">集合泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序操作（主要针对List接口相关）"><span class="nav-text">排序操作（主要针对List接口相关）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找和替换（主要针对Collection接口相关）"><span class="nav-text">查找和替换（主要针对Collection接口相关）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map接口"><span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部实现"><span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩容"><span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决哈希表冲突"><span class="nav-text">解决哈希表冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么是0-75"><span class="nav-text">为什么是0.75?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set视图"><span class="nav-text">Set视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedHashMap"><span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap-amp-HashMap代码比较"><span class="nav-text">LinkedHashMap &amp; HashMap代码比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么采用红黑树"><span class="nav-text">为什么采用红黑树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashTable"><span class="nav-text">HashTable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakHashMap"><span class="nav-text">WeakHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Map-Entry"><span class="nav-text">关于Map.Entry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-iterate-map"><span class="nav-text">How to iterate map</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/12.Java/Java-Tutorials.02.集合/';
          this.page.identifier = '12.Java/Java-Tutorials.02.集合/';
          this.page.title = 'Java Tutorials-02-集合';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
