<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Java基础," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="@toc:  NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存） NIO高性能的实现（异步非阻塞I/O + 堆外内存） 网络编程中两种高性能I/O设计模式（多路复用）：Reactor 和 Proactor  从BIO到NIO BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取">
<meta name="keywords" content="Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Tutorials-09-NIO">
<meta property="og:url" content="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="@toc:  NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存） NIO高性能的实现（异步非阻塞I/O + 堆外内存） 网络编程中两种高性能I/O设计模式（多路复用）：Reactor 和 Proactor  从BIO到NIO BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/Reactor-Single-Thread.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/Reactor-Work-Thread-Pool.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/Reactor-Multiple-Thread.png">
<meta property="og:updated_time" content="2022-10-13T09:25:55.939Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Tutorials-09-NIO">
<meta name="twitter:description" content="@toc:  NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存） NIO高性能的实现（异步非阻塞I/O + 堆外内存） 网络编程中两种高性能I/O设计模式（多路复用）：Reactor 和 Proactor  从BIO到NIO BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/java/Reactor-Single-Thread.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO/"/>





  <title>Java Tutorials-09-NIO | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Tutorials-09-NIO</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/12-Java/" itemprop="url" rel="index">
                    <span itemprop="name">12.Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,489
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>@toc:</p>
<ul>
<li>NIO API（Channel/Buffer/Selector, 网络/文件/堆外内存）</li>
<li>NIO高性能的实现（异步非阻塞I/O + 堆外内存）</li>
<li>网络编程中两种高性能I/O设计模式（多路复用）：Reactor 和 Proactor</li>
</ul>
<h1 id="从BIO到NIO"><a href="#从BIO到NIO" class="headerlink" title="从BIO到NIO"></a>从BIO到NIO</h1><blockquote>
<p>BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。<br>Java NIO是java 1.4之后新出的一套IO接口，这里的的新是相对于原有标准的Java IO和Java Networking接口。NIO提供了一种完全不同的操作方式。<br>NIO（Non-blocking I/O）是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p>
</blockquote>
<h1 id="NIO包介绍"><a href="#NIO包介绍" class="headerlink" title="NIO包介绍"></a>NIO包介绍</h1><p>Java Non-blocking I/O主要有三大核心部分：<code>Channel</code>(通道)，<code>Buffer</code>(缓冲区), <code>Selector</code>；<br>除此之外，Java NIO还包括了新的文件/目录的操作: <code>Path</code>和<code>Files</code>。</p>
<ol>
<li>java.nio.channels 包：<ul>
<li><code>java.nio.channels.ServerSocketChannel</code></li>
<li><code>java.nio.channels.SocketChannel</code></li>
<li><code>java.nio.channels.FileChannel</code></li>
</ul>
</li>
<li><code>java.nio.channels.SocketChannel.Selector</code> 类</li>
<li>java.nio.Buff 接口：<ul>
<li><code>java.nio.ByteBuffer</code>: 最基本的字符buff, 从<code>Channel</code>(ServerSocketChannel, FileChannel等)读取出的内容放在<code>ByteBuffer</code>里, 或者通过<code>Channel.write</code>把ByteBuffer内容写入Channel;</li>
<li><code>java.nio.MappedByteBuffer</code>: FileChannel通道打开的文件映射到内存, 通过<code>MappedByteBuffer</code>来操作;</li>
</ul>
</li>
<li>java.nio.file 包：<ul>
<li><code>java.nio.file.Path</code>: Path的实例指代一个目录或文件</li>
<li><code>java.nio.file.Paths</code>: Path的工厂类, 用于获取Path实例</li>
<li><code>java.nio.file.Files</code>: 提供对<code>Path</code>的操作</li>
</ul>
</li>
</ol>
<p>▶ BIO和NIO的对比变化如下:</p>
<ul>
<li>(1) BIO流 vs NIO管道:<ul>
<li>Java BIO的各种流的读写都是阻塞操作。这意味着一个线程一旦调用了read(),write()方法但系统缓冲区没数据可读，那么该线程会进入阻塞状态（Blocked）。</li>
<li>NIO读写都是非阻塞的, NIO基于Channel(管道)和Buffer(缓冲区)进行操作：数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Channel可以是文件也可以是Socket；</li>
</ul>
</li>
<li>(2) NIO里新增了Selector，用于监听多个Channel的事件，当Channel产生可读写事件后, 用ByteBuffer读取数据。<br>Selector允许一个单一线程监听多个Channel输入。我们可以注册多个Channel到Selector上，然后然后用一个线程来挑出一个处于可读或者可写状态的Channel。Selector机制使得单线程管理过个Channel变得容易。</li>
<li>(3) NIO的提供了<code>Path</code>和<code>Files</code>来取代io包中的<code>File</code>, <code>Path</code>的实例指代一个目录或文件，<code>Files</code>则提供了对目录或文件的基本操作（exists, copy, move, delete）</li>
</ul>
<h2 id="NIO-ByteBuffer"><a href="#NIO-ByteBuffer" class="headerlink" title="NIO ByteBuffer"></a>NIO ByteBuffer</h2><p>ByteBuffer的属性、方法:</p>
<ul>
<li>属性 capacity &gt;= limit &gt;= position &gt;= mark<ul>
<li><code>capacity</code>: 指定数组大小, Buffer创建后就不可改变;</li>
<li><code>limit</code>: 最大可以读的到位置, 初始值等于capacity, 调用flip()方法后limit=position</li>
<li><code>position</code>: 当前的读写位置, 初始值0, 每次写入一个字节position+1, 每次读都是从position++位置读一个字节</li>
<li><code>mark</code>: 初始值-1, 备忘位置, 参加mark()/reset()方法</li>
</ul>
</li>
<li><code>ByteBuffer.allocate(int)</code>: 创建buff并初始化大小</li>
<li><code>put(byte)</code>, <code>put(byte[])</code>: 向buff存储数据</li>
<li><code>get()</code>, 返回position位置的一个byte</li>
<li><code>flip()</code>, 向Buffer写完数据开始读数据前要调用一次, 把position的值赋给limit, 然后position=0, 然后可以调用get()从position读出字节;</li>
<li><code>rewind()</code>, position=0, mark=-1, 不改变limit的值, 可以再读一遍[0~limit]的字节</li>
<li><code>mark()</code>: mark=position, 调用mark()来记录当前position</li>
<li><code>reset()</code>: position=mark, 调用reset()让position置为mark的值, 一次reset()对应一次mark()</li>
<li><code>clear()</code>: limit,position,mark置为初始值;</li>
<li><code>compact()</code>: 清除未读的数据, 将所有未读的数据拷贝到buffer起始处</li>
<li><code>equals()</code>: 比较两个buff剩余未读的字节数, 比较剩余的每一个字节</li>
<li><code>compareTo()</code>: ..</li>
</ul>
<blockquote>
<p>ByteBuffer内部是由一个数组实现的, 所以capacity理论最大值受<code>MAX_Integer</code>和<code>-Xmx</code>限制</p>
</blockquote>
<h2 id="NIO-Channel"><a href="#NIO-Channel" class="headerlink" title="NIO Channel"></a>NIO Channel</h2><p>@todo</p>
<h2 id="NIO-Selector"><a href="#NIO-Selector" class="headerlink" title="NIO Selector"></a>NIO Selector</h2><p>@todo</p>
<h2 id="Files-amp-Path"><a href="#Files-amp-Path" class="headerlink" title="Files &amp; Path"></a>Files &amp; Path</h2><p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioPathAndFiles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    Path path = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> pathExists =</span><br><span class="line">        Files.exists(path,</span><br><span class="line">            <span class="keyword">new</span> LinkOption[]&#123; LinkOption.NOFOLLOW_LINKS&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目录</span></span><br><span class="line">    Path path2 = Paths.get(<span class="string">"data/subdir"</span>);</span><br><span class="line">    Files.createDirectory(path2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"~/text.txt"</span>);</span><br><span class="line">    <span class="comment">//通过bufferedReader读取</span></span><br><span class="line">    BufferedReader bufferedReader = Files.newBufferedReader(path, StandardCharsets.UTF_8);<span class="comment">//文件编码</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String tempString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((tempString = bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sb = sb.append(tempString);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb);</span><br><span class="line">    <span class="comment">//通过Files方法readAllLines</span></span><br><span class="line">    List&lt;String&gt; strings = Files.readAllLines(path);</span><br><span class="line">    strings.forEach(s -&gt; System.out.print(s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pulic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">"/text"</span>);</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    Files.write(path, <span class="string">"Hello JDK7!"</span>.getBytes(), StandardOpenOption.APPEND);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NIO网络读写"><a href="#NIO网络读写" class="headerlink" title="NIO网络读写"></a>NIO网络读写</h2><p>API说明:</p>
<ul>
<li>服务端:<ul>
<li><code>ServerSocketChannel.open()</code> : 创建一个server socket channel实例, 相当于传统Socket的<code>ServerSocket</code></li>
<li><code>ServerSocketChannel.socket().bind(SocketAddress local)</code> : 绑定端口</li>
<li><code>ServerSocketChannel.configureBlocking(false)</code>: 把server socket channel设置为 <strong>非阻塞</strong> 的情况下, <code>accept()/read()/write()</code>会立刻返回;</li>
<li><code>ServerSocketChannel.accept()</code>: 阻塞, 并在有客户端成功连接时返回一个<code>SocketChannel</code>实例</li>
<li><code>ServerSocketChannel.register(Selector, EVENT)</code>: 为server channel注册监听的事件</li>
</ul>
</li>
<li>Selector:<ul>
<li><code>Selector.open()</code>: 创建一个selector实例</li>
<li><code>Selector.select()</code>: 开始监听并阻塞</li>
</ul>
</li>
<li>客户端:<ul>
<li><code>SocketChannel.configureBlocking(false)</code>: 把socket channel设置为非阻塞, 读写会立刻返回</li>
<li><code>SocketChannel.write(ByteBuffer)</code>: 写方法</li>
<li><code>SocketChannel.read(ByteBuffer)</code>: 读方法, 返回值是读取的字节数</li>
</ul>
</li>
</ul>
<p>用NIO API实现简单的Socket Server（用<code>Selector</code>实现多路复用, 用<code>Channel.configureBlocking(false)</code>设置为非阻塞I/O）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer echoBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ServerSocketChannel实例, 并绑定端口</span></span><br><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channel 绑定 Selector, 并注册 Read</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">SelectionKey regKey = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">  <span class="comment">// 在这里阻塞</span></span><br><span class="line">  <span class="keyword">int</span> num = selector.select();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行到这里表示有事件产生</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">      SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">          <span class="comment">// 取出服务端SocketChannel</span></span><br><span class="line">          ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">          <span class="comment">// 接受请求, 返回客户端SocketChannel</span></span><br><span class="line">          SocketChannel sc = serverSocketChannel.accept();</span><br><span class="line">          <span class="comment">// 客户端SocketChannel设置NoneBlock</span></span><br><span class="line">          sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 客户端SocketChannel也添加进</span></span><br><span class="line">          SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          <span class="comment">// 不要忘记删除</span></span><br><span class="line">          it.remove();</span><br><span class="line">          System.out.println(<span class="string">"Got connection from "</span> + sc);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((selectionKey.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;</span><br><span class="line">          <span class="comment">// 取出可读的channel</span></span><br><span class="line">          SocketChannel sc = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理数据</span></span><br><span class="line">          <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              echoBuffer.clear();</span><br><span class="line">              <span class="keyword">int</span> r = sc.read(echoBuffer);</span><br><span class="line">              <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">              echoBuffer.flip();</span><br><span class="line">              sc.write(echoBuffer);</span><br><span class="line">              bytesEchoed += r;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">"Echoed "</span> + bytesEchoed + <span class="string">" from "</span> + sc);</span><br><span class="line">          it.remove();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结: NIO 的Socket 多路复用如下:</p>
<ul>
<li>创建服务端 socketChannel</li>
<li>创建 Selector</li>
<li>服务端 socketChannel 在 Selector上注册 ACCEPT事件</li>
<li>While循环<ul>
<li>selector.select() 阻塞, 如果 Selector上有事件发生, 退出阻塞</li>
<li>selector取出所有事件集合, 并遍历</li>
<li>如果有 ACCEPT 事件, 服务端 socketChannel去accept这个请求, 创建 客户端 socketChannel, 并在Selector上注册该 channel的 READ事件</li>
<li>如果有 READ 事件, 读对应的 客户端 socketChannel</li>
</ul>
</li>
</ul>
<h3 id="与传统Socket比较"><a href="#与传统Socket比较" class="headerlink" title="与传统Socket比较"></a>与传统Socket比较</h3><p>从上面的代码可以看到,</p>
<ul>
<li>传统的Java Socket(BIO, 阻塞IO), 等同于<code>java.net + java.io</code>, 使用的”Socket句柄”是<code>java.net.ServerSocket</code>(服务端socket)和<code>java.net.Socket</code>(客户端socket), 通过<code>Socket</code>获取InputStream/OutpubtStream进行读/写.</li>
<li>NIO Socket使用的”socket句柄”是<code>java.nio.channels</code>包下面的<code>ServerSocketChannel</code>和<code>SocketChannel</code>, SocketChannel的读写是通过<code>java.nio.ByteBuffer</code></li>
<li>前者IO方法是阻塞的, 后者IO方法是非阻塞 // ?</li>
</ul>
<h4 id="多线程-BIO缺陷"><a href="#多线程-BIO缺陷" class="headerlink" title="多线程-BIO缺陷"></a>多线程-BIO缺陷</h4><ul>
<li>线程的创建和销毁成本很高</li>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千…</li>
<li>线程的切换成本是很高</li>
<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，高并发下会使系统负载压力过大</li>
</ul>
<blockquote>
<p>BIO(阻塞IO)模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能阻塞等待。<br>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。<br>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。<br>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。</p>
</blockquote>
<p>以上参考: <a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a> @ref</p>
<h2 id="NIO大文件读写"><a href="#NIO大文件读写" class="headerlink" title="NIO大文件读写"></a>NIO大文件读写</h2><p>大文件读写几种方案:</p>
<ul>
<li>传统IO读取方式:<ul>
<li>字节方式读取: FileInputStream VS BufferedInputStream</li>
<li>字符方式读取: BufferedReader</li>
</ul>
</li>
<li>NIO读取:<ul>
<li>FileChannel + ByteBuffer</li>
<li>MappedByteBuffer(内存映射)</li>
</ul>
</li>
</ul>
<p>测试结论参考:  <a href="https://blog.csdn.net/yiifaa/article/details/78141622" target="_blank" rel="noopener">JAVA NIO(六)：读取10G的文件其实很容易 - CSDN博客</a> @ref</p>
<h3 id="传统NIO读取"><a href="#传统NIO读取" class="headerlink" title="传统NIO读取:"></a>传统NIO读取:</h3><p><code>java.io.RandomAccessFile</code>提供了文件随机读写,<br>下面的代码是使用nio中的<code>FileChannel</code>和<code>ByteBuffer</code> 从<code>RandomAccessFile</code>中读取:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel(); <span class="comment">// 1 获取channel</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(BUF_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((read = fileChannel.read(buffer)) &gt; <span class="number">0</span>) &#123; <span class="comment">// 2 读channel到ByteBuffer</span></span><br><span class="line">    buffer.flip(); <span class="comment">// 3 开始读之前flip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲器读入数组, 省略处理过程...</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[read];</span><br><span class="line">    buffer.get(bytes); <span class="comment">// 4</span></span><br><span class="line">    buffer.clear();  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">fileChannel.close();</span><br><span class="line">randomAccessFile.close();</span><br></pre></td></tr></table></figure>
<h3 id="使用内存映射"><a href="#使用内存映射" class="headerlink" title="使用内存映射:"></a>使用内存映射:</h3><p>nio.FileChannel还提供了内存映射的方式读取文件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(filePath), <span class="string">"r"</span>);</span><br><span class="line">FileChannel fileChannel = randomAccessFile.getChannel();</span><br><span class="line"><span class="keyword">long</span> length = randomAccessFile.length();</span><br><span class="line"><span class="comment">// 整个文件映射到内存:</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mappedByteBuffer.hasRemaining()) &#123;</span><br><span class="line">    mappedByteBuffer.get(); <span class="comment">//读取1字节</span></span><br><span class="line">    sum ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Close file &amp; channel</span></span><br></pre></td></tr></table></figure>
<h3 id="内存映射读取的优劣"><a href="#内存映射读取的优劣" class="headerlink" title="内存映射读取的优劣"></a>内存映射读取的优劣</h3><ul>
<li>内存映射方式的读取速度更快<ul>
<li>read()是系统调用, 首先将文件从硬盘拷贝到内核空间的一个缓冲区, 再将这些数据拷贝到用户空间, 实际上进行了两次数据拷贝.</li>
<li>map()也是系统调用, 但没有进行数据拷贝, 当缺页中断发生时, 直接将文件从硬盘拷贝到用户空间, 只进行了一次数据拷贝.</li>
</ul>
</li>
<li>MappedByteBuffer使用虚拟内存, 因此分配(map)的内存大小不受JVM的-Xmx参数限制, 但是也是有大小限制的;</li>
<li>如果当文件超出1.5G限制时, 可以通过position参数重新<code>map(mode, position, size)</code>文件后面的内容;</li>
<li>MappedByteBuffer在处理大文件时的确性能很高, 但也存在一些问题, 如内存占用/文件关闭不确定, 被其打开的文件只有在垃圾回收的才会被关闭, 而且这个时间点是不确定的。javadoc中也提到：”A mapped byte buffer and the file mapping that it represents remain* valid until the buffer itself is garbage-collected.”</li>
</ul>
<p>参考: <a href="http://blog.jobbole.com/104880/" target="_blank" rel="noopener">深入浅出 MappedByteBuffer</a> v</p>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。<br>堆外内存默认是和<code>-Xmx</code>默认一样大，也可以使用<code>-XX:MaxDirectMemorySize</code>指定堆外内存大小</p>
<h3 id="堆内-vs-堆外"><a href="#堆内-vs-堆外" class="headerlink" title="堆内 vs 堆外"></a>堆内 vs 堆外</h3><ul>
<li><strong>堆外内存</strong>减少了堆内内存的垃圾回收, 减少STW停顿;</li>
<li>使用Java的 <strong>堆内内存</strong> 进行IO操作, 会比C Native的程序多一次内存拷贝。为什么呢？</li>
</ul>
<blockquote>
<p>Java的IO底层也是调用了C Native的<code>read()/write()</code>函数, 这些函数需要传入<code>void *</code>类型的内存地址, 并且这个内存地址指向的内容不能被改变, 否则<code>read()/write()</code>操作的内存就错了;<br>有些GC回收器会整理内存, Java对象在内存的地址会被改变,<br>所以使用堆内内存进行IO操作, 需要先把堆内内容copy到JVM堆外的连续内存, 然后传递给C的<code>read()/write()</code>, 这就多了一次内存拷贝;<br>JVM规范没有要求<code>byte[]</code>一定是物理连续的, 但是C里用<code>malloc()</code>分配的内存是连续的;</p>
</blockquote>
<h3 id="How-to创建堆外内存"><a href="#How-to创建堆外内存" class="headerlink" title="How to创建堆外内存"></a>How to创建堆外内存</h3><p>三种方式创建堆外内存：Auto</p>
<ol>
<li><p>使用NIO提供的分配方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(1024); // 返回的是HeapByteBuffer</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocateDirect(1024);  // 返回的是DirectByteBuffer</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用NIO提供的堆外内存相关的类：<code>DirectByteBuffer</code>，<code>MappedByteBuffer</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// DirectByteBuffer</span><br><span class="line">DirectByteBuffer dbf = new DirectByteBuffer(1024);</span><br><span class="line"></span><br><span class="line">// MappedByteBuffer可以通过FileChannel实例获取, 用于文件内存映射</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用unsafe:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();</span><br><span class="line">long pointer = unsafe.allocateMemory(1024);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>DirectByteBuffer该类本身还是位于Java内存模型的堆中。<br>而DirectByteBuffer构造器中调用<code>unsafe.allocateMemory(size)</code>是个一个native方法，这个方法分配的是堆外内存，通过C的malloc来进行分配的。并不属于JVM内存。</p>
</blockquote>
<h3 id="堆外内存释放"><a href="#堆外内存释放" class="headerlink" title="堆外内存释放"></a>堆外内存释放</h3><ul>
<li>通过堆内对象触发GC, 堆内对象和指向的堆外内存一并被回收;</li>
<li>通过Unsafe回收;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeDirectMemoryExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> address = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FreeDirectMemoryExample</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		address = unsafe.allocateMemory(size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.finalize();</span><br><span class="line">		unsafe.freeMemory(address);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆外内存GC"><a href="#堆外内存GC" class="headerlink" title="堆外内存GC"></a>堆外内存GC</h3><p>如果堆外内存容量超过了<code>-XX:MaxDirectMemorySize</code> 会发生<code>OutOfMemoryError: Direct buffer memory</code>，<br>如果GC 回收了 DirectBuffer 对象，那么 DirectBuffer 对象指向的堆外内存，会在GC的后期被回收，<br>如果Java程序使用的堆内内存（Heap）占用率不高但是却大量使用DirectBuffer分配堆外内存，<br>这种情况下不会因为堆内内存触发 Full GC也就无法自动释放堆外内存，<br>所以通常需要调用 <code>System.gc()</code> 来强制回收 堆外内存（但是线上环境不建议这样触发Full GC），这种情况下一定确保不能启用了 <code>-XX:+DisableExplicitGC</code> 导致 <code>System.gc()</code>被禁用。</p>
<blockquote>
<p><code>System.gc()</code>会建议JVM进行Full GC, 对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存.<br>DirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象.<br>JVM 发生 YGC（Young gc很频繁, 会STW, 但是Copy GC算法的STW极短）的时候会将新生代里的不可达的 DirectByteBuffer 对象及其堆外内存回收了，但是无法对Old Gen里的 DirectByteBuffer 对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题。( 并且堆外内存多用于生命期中等或较长的对象 )<br>如果有大量的 DirectByteBuffer 对象移到了Old Gen，但是又一直没有做Old Gen 的CMS GC或者Gull GC，那么物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多。</p>
</blockquote>
<h2 id="本章参考"><a href="#本章参考" class="headerlink" title="本章参考"></a>本章参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门</a></li>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析 -</a></li>
<li><a href="https://yq.aliyun.com/articles/2371" target="_blank" rel="noopener">理解Java NIO-博客-云栖社区-阿里云</a></li>
</ul>
<h1 id="NIO高性能是如何实现的"><a href="#NIO高性能是如何实现的" class="headerlink" title="NIO高性能是如何实现的"></a>NIO高性能是如何实现的</h1><ol>
<li>使用异步非阻塞实现高效的单线程轮询，避免阻塞式IO开多线程的方式。// NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（Selector），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。<ul>
<li>NIO的读写函数可以立刻返回（用<code>Channel.configureBlocking(false)</code>设置该通道为非阻塞），如果一个连接不能读写（<code>socket.read()</code>返回0或者<code>socket.write()</code>返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</li>
<li>Java的<code>Selector</code>对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</li>
</ul>
</li>
<li>使用DirectBuffer减少IO时数据拷贝次数：<ul>
<li>使用堆内内存的时候，比如我们要完成一个从文件中读数据到堆内内存的操作，调用<code>FileChannelImpl.read(HeapByteBuffer)</code>实际上File IO会将数据读到堆外内存中，然后堆外内存再将这部分堆外数据拷贝到堆内内存。// 为什么Java IO会多一次内存拷贝?</li>
<li>如果直接使用堆外内存，如<code>DirectByteBuffer</code>，这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，程序通过JNI, 直接将这部分的内存数据通过<code>read()/write()</code>到堆外内存中。</li>
</ul>
</li>
</ol>
<p>➤ 比较传统IO</p>
<ul>
<li>NIO提供了直接内存的 ByteBuffer, 相比堆内内存, 在read/write时使用直接内存可以减少一次内存拷贝 // 但DirectByteBuffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能</li>
<li>NIO多了非阻塞IO + 多路复用Selector</li>
<li>非阻塞IO意味着不必再用多线程的方式, 节省了线程调度和切换的开销(以及线程内存的开销)</li>
<li>Selector可以使用一个线程即可管理大量IO连接的读写事件.</li>
<li>BIO的”每个连接一个线程”, 比较Netty的多线程, 区别是?</li>
</ul>
<h1 id="NIO-amp-Reactor"><a href="#NIO-amp-Reactor" class="headerlink" title="NIO &amp; Reactor"></a>NIO &amp; Reactor</h1><h2 id="Proactor-vs-Proactor"><a href="#Proactor-vs-Proactor" class="headerlink" title="Proactor vs Proactor"></a>Proactor vs Proactor</h2><p>[[../21.Operating-System/Linux.21.IO#高性能I/O设计模式]]</p>
<h2 id="Reactor三种常见线程模型"><a href="#Reactor三种常见线程模型" class="headerlink" title="Reactor三种常见线程模型"></a>Reactor三种常见线程模型</h2><p>➤ 三种Reactor线程模型:</p>
<ul>
<li>单线程 Reactor模型</li>
<li>多线程 Reactor模型</li>
<li>主从线程 Reactor模型</li>
</ul>
<p>➤ Reactor &amp; Proactor IO模型的角色:</p>
<ul>
<li>Demultiplexer: 多路复用器, select or epoll 的抽象, 产生IO事件</li>
<li>Dispatcher: 分发器, 将多路复用器产生的事件进行分发</li>
<li>Acceptor: accept事件处理器(函数)</li>
<li>IOHandler: IO事件处理器(函数)</li>
</ul>
<blockquote>
<p>@ref: <a href="https://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reactor_pattern</a></p>
</blockquote>
<p>➤ 单线程 Reactor 模型: 一个 Reactor Thread,  负责处理全部 I/O事件(accept, read, send), 以及业务代码(decode, compute, encode)</p>
<ul>
<li>在一个 Reactor Thread 里, select 监听 accept/read/write事件, 事件由 Dispatcher 进行分发:<ul>
<li>有accept事件, Dispatcher 分发给 Acceptor 进行握手/鉴权等处理;</li>
<li>有read/write事件, Dispatcher 分发给 IOHandler: 进行 read → decode → compute → encode → send ;</li>
</ul>
</li>
<li>缺点: 当某个Handler阻塞时，会导致其他客户端的handler和accpetor都得不到执行，无法做到高性能，只适用于业务处理非常快速的场景<br><img src="/images/java/Reactor-Single-Thread.png" alt=""></li>
</ul>
<p>➤ 线程池 Reactor 模型: 一个 Reactor Thread, 负责处理全部 I/O事件(accept, read, send), 但业务代码交给线程池处理..</p>
<ul>
<li>Reactor Thread 里, select 监听 accept/read/write事件, 事件由 Dispatcher 进行分发:<ul>
<li>有accept事件, 处理同单线程模型;</li>
<li>有read事件, Dispatcher 分发给 IOHandler处理 (函数调用, 仍在 Reactor线程里), 也就是在Reactor线程里进行非阻塞read;</li>
<li>从Worker Thread Pool 取出一个Worker, 对读到的数据进行 decode → compute → encode 处理流程;</li>
<li>Worker的结果交还给 Reactor Thread, 由 Reactor Thread 进行send;</li>
</ul>
</li>
<li>比较单线程模型, 多线程Reactor模型仍在主线程里处理读/写操作, 不再处理业务代码, 业务代码交给线程池执行;</li>
<li>缺点: Reactor Thread 仍然负责全部的accept/read/write的处理, 如果在 Reactor Thread 进行有大量读写事件, 同时大量连接事件(在accept时进行鉴权等), 这时候仍会有单线程的瓶颈</li>
</ul>
<p><img src="/images/java/Reactor-Work-Thread-Pool.png" alt=""></p>
<p>➤ 主从多线程 Reactor 模型: 不再是一个 Reactor Thread, 有 Main Reactor &amp; Sub Reactor 两个线程, 分别处理 accept事件 &amp; IO事件, 业务代码交给线程池处理</p>
<ul>
<li>有多个 Reactor Thread (main and sub), 每个 Reactor Thread 有自己的 Selector;</li>
<li><strong>Main Reactor Thread</strong> 的 Selector负责监听 accept 事件, 交给 Acceptor 处理;</li>
<li>Acceptor 接受请求之后创建新的 SocketChannel, 并处理鉴权/握手等;</li>
<li>完成上一步处理的 SocketChannel, 从 Main Reactor Thread 的 Selector移除, 并注册到 Sub Reactor Thread 的 Selector上;</li>
<li><strong>Sub Reactor Thread</strong> 的 Selector监听 SocketChannel的 read事件, 并调用 IOHandler进行非阻塞 read;</li>
<li>Worker Thread Pool 处理 decode → compute → encode 流程 …</li>
</ul>
<p><img src="/images/java/Reactor-Multiple-Thread.png" alt=""></p>
<blockquote>
<p>@ref: Scalable IO in Java - Doug Lea, State University of New York at Oswego [[../_attachments/Scalable IO in Java - Doug Lea.pdf]]</p>
</blockquote>
<h2 id="Netty-实现多线程-Reactor"><a href="#Netty-实现多线程-Reactor" class="headerlink" title="Netty 实现多线程 Reactor"></a>Netty 实现多线程 Reactor</h2><p>▶ Netty中重要的 API类:</p>
<ul>
<li>NioEventLoop:<ul>
<li>继承自 SingleThreadEventExecutor, 只有一个线程的线程池</li>
<li>每个 NioEventLoop 都有一个 Selector, 可以用来监听 accept/r/w事件</li>
</ul>
</li>
<li>NioEventLoopGroup: 一个NioEventLoopGroup 管理多个 NioEventLoop, 构造函数可以指定管理 NioEventLoop的个数, 如果没有设置，默认取 -Dio.netty.eventLoopThreads，如果该系统参数也没有指定，则为可用的 CPU 内核数 × 2。</li>
</ul>
<p>▶ 用 Netty 实现多线程 Reactor:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ServerHandlerInitializer());</span><br></pre></td></tr></table></figure>
<ul>
<li>Netty Server 创建两个 <code>NioEventLoopGroup</code>: bossGroup 和 workerGroup;</li>
<li>bossGroup线程组 通常只有一个 <code>EventLoop</code>线程(Boss线程), 这个线程作为 <strong>Main Reactor Thread</strong>, 负责 select监听端口的 accept事件并进行后续处理(创建SocketChannel.. );</li>
<li>workerGroup线程组, 通常包含 cpu core数量的 1-2倍个<code>EventLoop</code>线程(Worker线程), 这些 Worker线程作为 <strong>Sub Reactor Threads</strong>;</li>
<li>Boss线程把创建的 SocketChannel, 顺序分发给 workerGroup线程组中的每一个 Worker线程(类似轮询);</li>
<li>Worker线程的 Selector监听 SocketChannel的 read事件, 如果有 read事件, 交给 Handler链处理(链式顺序执行 ChannelHandler); // 代码中的 <code>socketChannel.pipline().addLast(ChannelHandler)</code></li>
<li>ChannelHandler建议: 如果业务代码非常简单且耗时可控, 业务代码可以在 ChannelHandler直接执行. 如果否, 则投递到业务线程池中处理. 「不要把 Netty Server 当作业务容器，对于大多数复杂的业务产品，仍然需要集成或者开发自己的业务容器，做好和 Netty 的架构分层」</li>
</ul>
<blockquote>
<p>@ref <a href="https://www.infoq.cn/article/netty-threading-model" target="_blank" rel="noopener">Netty系列之Netty线程模型 - InfoQ</a></p>
</blockquote>
<h1 id="Java对AIO的支持"><a href="#Java对AIO的支持" class="headerlink" title="Java对AIO的支持"></a>Java对AIO的支持</h1><p>AIO(asynchronous I/O): 异步IO, <code>java.nio.channels</code>包做了支持, 包括: <code>AsynchronousSocketChannel</code> /  <code>AsynchronousServerSocketChannel</code> / <code>AsynchronousFileChannel</code></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java基础/" rel="tag"># Java基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/12.Java/Java-Tutorials.08.网络编程/" rel="next" title="Java Tutorials-08-网络编程">
                <i class="fa fa-chevron-left"></i> Java Tutorials-08-网络编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/12.Java/Java-Tutorials.10.注解/" rel="prev" title="Java Tutorials-10-注解">
                Java Tutorials-10-注解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">403</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">328</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从BIO到NIO"><span class="nav-text">从BIO到NIO</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO包介绍"><span class="nav-text">NIO包介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-ByteBuffer"><span class="nav-text">NIO ByteBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-Channel"><span class="nav-text">NIO Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO-Selector"><span class="nav-text">NIO Selector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Files-amp-Path"><span class="nav-text">Files &amp; Path</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO网络读写"><span class="nav-text">NIO网络读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与传统Socket比较"><span class="nav-text">与传统Socket比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程-BIO缺陷"><span class="nav-text">多线程-BIO缺陷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO大文件读写"><span class="nav-text">NIO大文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统NIO读取"><span class="nav-text">传统NIO读取:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用内存映射"><span class="nav-text">使用内存映射:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射读取的优劣"><span class="nav-text">内存映射读取的优劣</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆外内存"><span class="nav-text">堆外内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆内-vs-堆外"><span class="nav-text">堆内 vs 堆外</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to创建堆外内存"><span class="nav-text">How to创建堆外内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆外内存释放"><span class="nav-text">堆外内存释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆外内存GC"><span class="nav-text">堆外内存GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章参考"><span class="nav-text">本章参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO高性能是如何实现的"><span class="nav-text">NIO高性能是如何实现的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO-amp-Reactor"><span class="nav-text">NIO &amp; Reactor</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Proactor-vs-Proactor"><span class="nav-text">Proactor vs Proactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor三种常见线程模型"><span class="nav-text">Reactor三种常见线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty-实现多线程-Reactor"><span class="nav-text">Netty 实现多线程 Reactor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java对AIO的支持"><span class="nav-text">Java对AIO的支持</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/12.Java/Java-Tutorials.09.NIO/';
          this.page.identifier = '12.Java/Java-Tutorials.09.NIO/';
          this.page.title = 'Java Tutorials-09-NIO';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
