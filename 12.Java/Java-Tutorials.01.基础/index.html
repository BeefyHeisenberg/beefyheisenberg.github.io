<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xaHWbGrH27PtIRsHQwRbAzWeQmtdbVP8Sj8IoFGMFhA" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/safari-pinned-tab.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/site.webmanifest">


  <meta name="msapplication-config" content="/browserconfig.xml" />



  <meta name="keywords" content="Java," />





  <link rel="alternate" href="/atom.xml" title="扔掉笔记 ᐛ" type="application/atom+xml" />






<meta name="description" content="数据类型基本数据类型Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),Java没有bit类型, 但可以使用BitSet类代替.  byte: 1字节, 范围-128~127 short: 2字节, 范围-32768~32767, 为什么最小是-">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Tutorials-01-基础">
<meta property="og:url" content="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.01.基础/index.html">
<meta property="og:site_name" content="扔掉笔记 ᐛ">
<meta property="og:description" content="数据类型基本数据类型Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),Java没有bit类型, 但可以使用BitSet类代替.  byte: 1字节, 范围-128~127 short: 2字节, 范围-32768~32767, 为什么最小是-">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/java_exception.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/Java-Tutorials.01.try-finally-bytecode-example.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/exception-tostring.png">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/java_lang_package.gif">
<meta property="og:image" content="https://beefyheisenberg.github.io/images/java/java_util_package.gif">
<meta property="og:updated_time" content="2023-09-18T11:37:34.175Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Tutorials-01-基础">
<meta name="twitter:description" content="数据类型基本数据类型Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),Java没有bit类型, 但可以使用BitSet类代替.  byte: 1字节, 范围-128~127 short: 2字节, 范围-32768~32767, 为什么最小是-">
<meta name="twitter:image" content="https://beefyheisenberg.github.io/images/java/java_exception.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.01.基础/"/>





  <title>Java Tutorials-01-基础 | 扔掉笔记 ᐛ</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">扔掉笔记 ᐛ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">dropNotes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      


    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://beefyheisenberg.github.io/12.Java/Java-Tutorials.01.基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="beefyheisenberg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/hexo_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="扔掉笔记 ᐛ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Tutorials-01-基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/12-Java/" itemprop="url" rel="index">
                    <span itemprop="name">12.Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,836
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java的基本类型有: char(2字节), byte(1字节), short(2字节), int(4字节), long(8字节), float(4字节), double(8字节), boolean(-),<br>Java没有bit类型, 但可以使用<code>BitSet</code>类代替.</p>
<ul>
<li>byte: 1字节, 范围-128~127</li>
<li>short: 2字节, 范围-32768~32767, 为什么最小是-32768 ?</li>
<li>int/long: <code>100L</code>表示long类型, 0x/0/0b前缀分别表示16/8/2进制<ul>
<li>如果<code>long l = 3600 * 24 * 30 * 1000</code>，1000后面不加L，右边会按int计算并产生溢出</li>
</ul>
</li>
<li>float/double: 3.14F表示float类型, 3.14和3.14D都表示double</li>
<li>char: 单引号, ‘\u2122’或’A’</li>
</ul>
<h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><p>浮点数(基本类型)之间是否相等不能用==来比较，浮点数(包装数据类型)不能用 equals 来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例1:</span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">1.0F</span> - <span class="number">0.9F</span>; <span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">  <span class="comment">// 预期进入此代码块，执行其它业务逻辑 // 但事实上 a==b 的结果为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例2:</span></span><br><span class="line">Float x = Float.valueOf(a);</span><br><span class="line">Float y = Float.valueOf(b);</span><br><span class="line"><span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line">  <span class="comment">// 预期进入此代码块，执行其它业务逻辑</span></span><br><span class="line">  <span class="comment">// 但事实上 equals 的结果为 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例:</span></span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9F</span> - <span class="number">0.8F</span>; <span class="keyword">float</span> diff = <span class="number">1e-6F</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line">  System.out.println(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitSet bits = <span class="keyword">new</span> BitSet(<span class="number">16</span>); <span class="comment">// 初始大小对性能的影响</span></span><br><span class="line">bits.set(index, <span class="keyword">true</span>);</span><br><span class="line">bits.get(index)</span><br></pre></td></tr></table></figure>
<h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><h3 id="包装器API"><a href="#包装器API" class="headerlink" title="包装器API"></a>包装器API</h3><p>基本类型对应包装器为 Character, Byte, Short, Integer, Long, Float, Double, 包装器与基本类型互转:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer ii = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i = ii.intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Integer 可以直接与int比较 */</span></span><br><span class="line"><span class="keyword">if</span>(ii == i) &#123;</span><br><span class="line">  <span class="comment">// yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String &lt;-&gt; int</span></span><br><span class="line">String s = String.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i2 = Integer.parseInt(<span class="string">"1011"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坑</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> Long(<span class="number">1</span>).equals(<span class="number">1</span>)) &#123;</span><br><span class="line">  printf(<span class="string">"true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面并没有打印出True, 因为`equals(obj)`方法自动把int的1装箱为"Integer"类型,</span></span><br><span class="line"><span class="comment">在equals里第一步check类型就返回false了:(</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Integer 的相等比较：</p>
<ul>
<li>如果比较 2 个 Integer 的值，需要用 <code>equals</code> 而不是 <code>==</code></li>
</ul>
<p>Float 的相等比较：</p>
<ul>
<li>计算 abs(f1 - f2) ，然后与一个极小 diff 比较</li>
</ul>
<p><strong>Integer 和 Long 不同类型慎用 equals</strong>！详见 Long.equals 的解析</p>
<p>Double类的一些方法:</p>
<ul>
<li><code>Double.compareTo(Double)</code> : 大于小于直接比较, =的判断是把double转成一个LongBit? Native方法, 需要看一下浮点数的内存</li>
<li><code>isNaN()</code> 返回true表示不是正常数字, 比如除以0, 负数的平方根. 代码里如何得到一个NaN?</li>
</ul>
<h3 id="装箱拆箱的实现"><a href="#装箱拆箱的实现" class="headerlink" title="装箱拆箱的实现"></a>装箱拆箱的实现</h3><p>▶ 何时发生装箱/拆箱:</p>
<ul>
<li>什么是自动装箱: int → Integer, 实际调用 <code>Integer.valueOf(int)</code></li>
<li>什么时候发生自动装箱:<ul>
<li>创建对象: <code>Integer i = 3</code></li>
<li>方法参数传递: <code>void method(Integer i)</code></li>
</ul>
</li>
<li>什么是自动拆箱: Integer → int, 实际调用 <code>integer.intValue()</code></li>
<li>什么时候发生自动拆箱:<ul>
<li>加法: <code>integer1 + integer2</code>, 先拆箱转换为int …</li>
<li>需要注意的是<code>if (integer3 == integer1 + integer2)</code>, 首先右边1和2拆箱为int, 变成<code>if (integer3 == int)</code>, 这时不是发生(int→integer)装箱, 而是继续拆箱, 最终比较的是<code>if (int == int)</code></li>
</ul>
</li>
</ul>
<p>▶ Integer/Long自动装箱 <code>valueOf(x)</code>的实现</p>
<ul>
<li>Integer/Long 的 <code>valueOf(i)</code> 使用了享元模式, 在 <code>static</code> 代码块中预先创建了范围 <code>-128~127</code> 的对象, 缓存在数组型的 Cache（<code>Integer[] cache</code>）里;</li>
<li>当调用<code>valueOf(i)</code>的时候，先判断i的范围是否是-128~127，如果是则直接从cache里返回对象，减少类的创建;</li>
<li>下面创建Integer的效率, 前者可能更高: <code>Integer i = 3</code> , <code>Integer i = new Integer(3)</code>; 为什么?</li>
<li>Float/Double的<code>valueOf(f)</code>没有使用享元模式;</li>
</ul>
<p>▶ 代码example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long l1 = Long.valueOf(<span class="number">128</span>);</span><br><span class="line">Long l2 = Long.valueOf(<span class="number">128</span>);</span><br><span class="line">System.out.println(<span class="string">"l1==l2 "</span> + (l1==l2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Long l3 = Long.valueOf(<span class="number">127</span>);</span><br><span class="line">Long l4 = Long.valueOf(<span class="number">127</span>);</span><br><span class="line">System.out.println(<span class="string">"l3==l4 "</span> + (l3==l4));</span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1==i2 "</span> + (i1==i2));</span><br><span class="line">System.out.println(<span class="string">"i1==i2+i3 "</span> + (i1==i2+i3));</span><br></pre></td></tr></table></figure>
<p>输出: false, true, false, true</p>
<blockquote>
<p>@ref <a href="https://www.jianshu.com/p/0ce2279c5691" target="_blank" rel="noopener">Java 自动装箱与拆箱的实现原理 - 简书</a></p>
</blockquote>
<h3 id="慎用-Long-equals"><a href="#慎用-Long-equals" class="headerlink" title="慎用 Long.equals()"></a>慎用 Long.equals()</h3><p>以下代码会输出false:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Long(<span class="number">1</span>).equals(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>原因是，<code>Long.equals(Object)</code>，进入equals是会对整形参数1进行一次装箱，i被包装成<code>Integer(1)</code>，<br>和其他类的equals行为一样，<code>Long.equals(Integer(1))</code>会先判断输入参数的类型<code>if (obj instanceof Long)</code>，这里就返回false了。</p>
<p>所以用Long的正确条例是，<code>Long</code>的方法传参数都用明确的long型：<code>new Long(1L)</code>, <code>longObj.equals(1L)</code>。</p>
<h3 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger, BigDecimal"></a>BigInteger, BigDecimal</h3><p>Java还提供了两个用于大数运算的类: <code>BigInteger</code>(任意大整数)和<code>BigDecimal</code>(任意大小的带小数点的数字). 常用方法: <code>add()</code>, <code>subtract()</code>, <code>multiply()</code>, <code>divide()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger big1 = <span class="keyword">new</span> BigInteger(<span class="string">"99"</span>);</span><br><span class="line">BigInteger big2 = BigInteger.valueOf(<span class="number">99</span>);</span><br><span class="line">BigInteger big3 = big1.add(big2).multiply(big2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BigDecimal 的等值比较应使用 compareTo()方法，而不是 equals()方法。 说明:equals()方法会比较值和精度(1.0 与 1.00 返回结果为 false)，而 compareTo()则会忽略精度。</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>Java中数组本质上也是对象, 拥有所有Object的方法, 不同于int/double等基本类型.<ul>
<li>Java 对象在内存里前几个字节是”对象头”, 非数组对象的的对象头占用2字节, 数组对象的对象头占用3字节, 多的1字节用来存储对象长度</li>
<li>数组可以通过属性 <code>length</code> 获取长度, 遍历数组: <code>for(int i = 0; i &lt; array.length; i++)</code></li>
</ul>
</li>
<li>数组创建后会记住元素类型和大小, 所以:<ul>
<li><code>A[]</code> 类型的数组可以强转换为 <code>Object[]</code>, 但不能反过来执行;</li>
<li>用 <code>new A[1]</code> 方式创建的数组, 只能向内存储 <code>A</code> 类型或者 <code>A的派生类</code> 的对象, 试图存入其他类型对象会抛 ArrayStoreException;</li>
<li>数组创建后不再能改变长度;</li>
</ul>
</li>
</ul>
<p>▶ 数组如果作为形参 or 返回值, 可以使用<code>Object</code>, 而不是用<code>Object[]</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射方式创建新数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">copyOfGenericArray</span><span class="params">(Object src, <span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> newLength&gt;<span class="number">0</span> : <span class="string">"assert length failed"</span>;</span><br><span class="line">  <span class="keyword">if</span>(!src.getClass().isArray()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Class clz = src.getClass().getComponentType();</span><br><span class="line">  Object newArray = Array.newInstance(clz, newLength);</span><br><span class="line">  <span class="keyword">int</span> length = Array.getLength(src);</span><br><span class="line">  System.arraycopy(src, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>▶ 数组与list互转:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list -&gt; array</span></span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">Object[] objArray = list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array -&gt; list</span></span><br><span class="line">List&lt;Object&gt; newList = Arrays.asList(objArray);</span><br></pre></td></tr></table></figure>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Java核心类库有两个Arrays类:</p>
<ul>
<li><code>java.lang.reflect.Array</code>: 提供了数组的反射相关方法;</li>
<li><code>java.utils.Arrays</code>: 类似Collections类, 提供了merge/sort等方法</li>
</ul>
<p>示例代码: 用反射创建数组, 拷贝数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.reflect.Array创建数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = (<span class="keyword">int</span>[])Array.newInstance(<span class="keyword">int</span>.class,length)  <span class="comment">// &lt;Core Java&gt; P207</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝数组</span></span><br><span class="line">System.arraycopy(src[], srcPos, dest[], destPos, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用java.utils.Arrays拷贝:</span></span><br><span class="line">Object[] newArr = Arrays.copyOf(Obj[], length)</span><br><span class="line"><span class="comment">// Arrays工具类还提供了sort, binarySearch, asList()</span></span><br><span class="line"></span><br><span class="line">Entry[] entries = <span class="keyword">new</span> Entry[<span class="number">1</span>];</span><br><span class="line">Object[] objs = (Object[])entries; <span class="comment">// 向上转型数组ok</span></span><br></pre></td></tr></table></figure>
<h4 id="java-util-Arrays"><a href="#java-util-Arrays" class="headerlink" title="java.util.Arrays"></a>java.util.Arrays</h4><p><code>java.util.Arrays</code> 包含了许多处理数组的实用方法：</p>
<ul>
<li><p><code>asList</code>: 将一个数组(变长参数的语法糖实现就是数组)转变成一个List（确切的来说是 <code>ArrayList</code>），注意这个List是定长的，企图添加或者删除数据都会报错（<code>java.lang.UnsupportedOperationException</code>）.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 下面这种用法是错误的:</span></span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sort</code>: 对数组进行排序。适合byte,char,double,float,int,long,short等基本类型，还有Object类型（实现了Comparable接口），如果提供了比较器Comparator也可以适用于泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span>; <span class="comment">// 需要类实现Comparable接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span>; <span class="comment">// 带比较器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>binarySearch</code>: 通过二分查找法对已排序（譬如经过Arrays.sort排序，且按照升序进行排序。如果数组没有经过排序，那么检索结果未知）的数组进行查找。适合byte,char,double,float,int,long,short等基本类型，还有Object类型和泛型</p>
</li>
<li><code>copyOf</code>: 数组拷贝，并返回新数组，底层采用System.arrayCopy（native方法）实现。</li>
<li><code>copyOfRange</code>: 数组拷贝，指定一定的范围，<code>String str2[] = Arrays.copyOfRange(arr,1,3)</code>;</li>
<li><code>equals</code>和<code>deepEquals</code>:<ul>
<li>equals：判断两个数组的每一个对应的元素是否equals</li>
<li>deepEquals：主要针对一个数组中的元素还是数组的情况</li>
</ul>
</li>
<li><code>toString</code>和<code>deepToString</code> : 参考<code>equals</code>和<code>deepEquals</code></li>
<li><code>hashCode</code>和<code>deepHashCode</code> :<ul>
<li>hashCode：计算一个数组的hashCode. 每个元素的<code>element.hashCode()</code>都要参与计算</li>
</ul>
</li>
<li><code>fill</code>: 给数组赋值。填充数组。<code>Arrays.fill(intArr, 1);</code></li>
</ul>
<h4 id="Java-lang-reflect-Array"><a href="#Java-lang-reflect-Array" class="headerlink" title="Java.lang.reflect.Array"></a>Java.lang.reflect.Array</h4><p>施工中</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li>Java在SE5中才添加了emum特性, 在定义一个enum时会自动创建<code>toString()</code>和<code>value()</code>方法(均是static方法), enum还支持类似Objec的私有属性,和构造;<ul>
<li>enum 类型不支持<code>public</code>和<code>protected</code>修饰符的构造方法, 因此构造函数一定要是<code>private</code>或 <code>friendly</code>的. 也正因为如此, 所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的.</li>
<li>枚举可以出现在switch语句中, 若要判断两个枚举类型常量的值是否相等, 使用<code>==</code>, 或<code>equals()</code>都可以. 前者更好因为可以可以判断null的情况</li>
<li>比较两个枚举类型常量的值的大小要使用<code>compareTo()</code>方法.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个基本的枚举:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> COLOR &#123;</span><br><span class="line">  RED(<span class="number">1</span>),</span><br><span class="line">  GREEN(<span class="number">2</span>) <span class="comment">// GREEN后面没有分号哟...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个带属性和构造器的枚举:</span></span><br><span class="line"><span class="keyword">public</span> emum ApiUrl &#123;</span><br><span class="line">    REGIST(<span class="string">"http://changyan.com/api/open/reg"</span>,<span class="number">1</span>),</span><br><span class="line">    LOGIN(<span class="string">"http://changyan.com/api/open/validate"</span>,<span class="number">2</span>),</span><br><span class="line">    SSO(<span class="string">"http://changyan.com/api/open/set-cookie"</span>,<span class="number">3</span>); <span class="comment">// 分号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 私有的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ApiUrl</span><span class="params">(String url, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">// 私有的构造器!!!</span></span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getUrl</span><span class="params">()</span> </span>&#123; ...&#125; <span class="comment">// Getter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index + <span class="string">"_"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ApiUrl apiUrl = ApiUrl.REGIST; <span class="comment">// 初始化枚举变量</span></span><br><span class="line">System.out.print(ApiUrl.REGIST.toString());</span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li><strong>类实例的赋值</strong>操作 <code>a=b</code> 实际是把 b 这个”对象引用”指向了 a 的指向的对象, 如果 b 原来的对象的引用数为0, 在一定条件下会被 JVM 销毁.</li>
<li>对于基本数据类型, <code>==</code>判断的是值, 而不是”是否指向同一个引用”;</li>
<li>用<code>==</code>比较Object, 如果a和b是否指向的是同一块内存则为true</li>
<li>判断两个字符串的内容是否相同不能用<code>if(str1==str2)</code>, 要用<code>str1.equals(str2)</code>方法.</li>
<li>大部分jdk中的类实现了<code>Object.equals(Object)</code>这个方法(判断两值是否相等), 但是对于某些自定义的类要留意其<code>equals</code>方法, 因为<code>Object.equals</code>默认行为是比较引用的<code>this==obj</code>;</li>
</ul>
<blockquote>
<p>hashCode和equals更多参考: (五)面向对象</p>
</blockquote>
<h2 id="左右结合"><a href="#左右结合" class="headerlink" title="左右结合"></a>左右结合</h2><p>Java中赋值<code>=</code>, 单目运算<code>++</code>等, 条件运算符<code>?:</code>是右结合, 其他都是左结合,<br>比如<code>x=y=z</code>, 相当于<code>x=(y=z)</code></p>
<h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><ul>
<li>左移&lt;&lt; : 丢弃最高位(符号位同样丢弃), 0补最低位. 当byte和short左移时, 自动升级为int型.<ul>
<li>数学意义: 左移n位相等于乘以2^n</li>
</ul>
</li>
<li>右移&gt;&gt; : 高位补充符号位, 正数右移补充0, 负数右移补充1, 当byte和short右移时, 自动升级为int型.<ul>
<li>数学意义:  右移n位相当于除以2^n</li>
</ul>
</li>
<li>无符号右移&gt;&gt;&gt; : 无论正负, 高位补充0<ul>
<li>无符号右移只是对32位和64位的值有意义</li>
</ul>
</li>
</ul>
<p>关于补码/反码参考脚注<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<h2 id="java-lang-Math"><a href="#java-lang-Math" class="headerlink" title="java.lang.Math"></a>java.lang.Math</h2><ul>
<li>abs: <code>return v&gt;0?v:-v;</code></li>
<li>sqrt: native</li>
<li>pow: native</li>
</ul>
<h1 id="控制流程和语句"><a href="#控制流程和语句" class="headerlink" title="控制流程和语句"></a>控制流程和语句</h1><ul>
<li>Java的<code>if</code>, <code>for</code>, <code>while</code>, <code>do-while</code>, <code>if...else if</code>和C++完全一样, 此外Java还多了foreach:  <code>for(int i : integerArray) {...}</code></li>
<li><code>switch</code>语句支持String类型和<code>enum</code>类型</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Java 的参数传递为 <code>值传递</code>. 也就是说, 当我们传递一个参数时, 方法内将获得实参的一个拷贝.</p>
<ul>
<li><p>基本类型(int/char 等)的参数传递, 方法内获得是一个拷贝. Java 方法对变量的修改不会影响到原变量.</p>
</li>
<li><p>对象变量在 java 中实际是一个引用（可以理解为 C++的内存地址）, 对象变量作为参数传递, 函数内获得一个引用地址的拷贝.</p>
<ul>
<li>在函数内修改这个对象变量的值, 不会影响到函数外, 因为函数内修改的只是这个拷贝.</li>
<li>在函数内修改这个对象变量的成员, 会影响到函数外的对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>@ref： <a href="https://segmentfault.com/a/1190000016773324" target="_blank" rel="noopener">这一次，彻底解决Java的值传递和引用传递 - 个人文章 - SegmentFault 思否</a></p>
</blockquote>
<h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><p>Java对普通类型的变量 or 引用类型的变量, 都无法简单通过<code>=</code>赋值实现 Swap,</p>
<p>折中的做法有: 1)使用数组, 2)作为成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void swap1(int[] data, int a, int b) &#123;</span><br><span class="line">      int t = data[a];</span><br><span class="line">      data[a] = data[b];</span><br><span class="line">      data[b] = t;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void swap2(int a, int b) &#123;</span><br><span class="line">       this.a = b;</span><br><span class="line">       this.b = a;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h2><p>Java也支持变参函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//第一种形式</span></span><br><span class="line">    foreach(String arg : args) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para, String... args)</span> </span>&#123; <span class="comment">//第二种形式</span></span><br><span class="line">    <span class="comment">// 遍历方法同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><p>Java 中的 <code>final</code> 关键字和 C++中的 <code>const</code> 关键字一样, 都表示不可改变.</p>
<p>final 关键字可以修饰:</p>
<ul>
<li>成员: 表示常量, 也可以在 final 成员定义时不给初值, 在构造方法里赋初值;</li>
<li>形参: 表示这个参数引用指向的内容不能被改变.</li>
<li>方法: 表示这个方法不能在派生类中被”覆写”(Override), 但可以被继承使用. 类中所有 private 方法都被隐式的声明为 final 的.</li>
<li>类: 表示这个类不能被继承, final 类中所有的方法也被隐式声明为 final 的, 设计类时候, 如果这个类不需要有子类, 类的实现细节不允许改变, 并且确信这个类不会载被扩展, 那么就设计为 final 类. final 和 abstract 这两个关键字是反相关的, final 类就不可能是 abstract 的</li>
<li>C++的 const 类成员和 Java 的 final 类属性: 在 C/Java 的类中, 都支持 <code>public final int ee = 1</code> 这样的声明+赋初值的方式, 也支持先声明再初值的方式(这种情况下, 都需要在构造函数里初值). 这样的设计的好处是可以做到一个类中 final 域在不同的对象有不同的值.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List Loans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"home loan"</span>);  <span class="comment">//valid</span></span><br><span class="line">list.add(<span class="string">"personal loan"</span>); <span class="comment">//valid</span></span><br><span class="line">loans = <span class="keyword">new</span> Vector();  <span class="comment">//not valid</span></span><br></pre></td></tr></table></figure>
<p>下面总结了一些使用 final 关键字的好处:</p>
<ul>
<li>final 关键字提高了性能, JVM 和 Java 应用都会缓存 final 变量. @doubt</li>
<li>final 变量可以安全的在多线程环境下进行共享, 而不需要额外的同步开销.  </li>
<li>使用 final 关键字, JVM 会对方法/变量及类进行优化.</li>
</ul>
<blockquote>
<p>摘自《Java 编程思想》第四版第 143 页：<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final 方法进行这些优化了。“</p>
</blockquote>
<h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>使用 static 块初始化 final 的 Map:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; myMap;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; aMap = ....;</span><br><span class="line">        aMap.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">        aMap.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        myMap = Collections.unmodifiableMap(aMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回顾 C++的 const:  可以修饰函数(修饰返回值 or 修饰形参 or 修饰类的函数成员),</p>
<blockquote>
<p>const int<em> ptr; // ptr 指向的内容无法修改<br>int</em> const ptr; // 指针 ptr 本身的值无法被修改<br>修饰形参: void func(const int *ptr);<br>修饰返回值: const &amp;aaa func(void); //<br>修饰类的函数成员: void func(int, int) const; // 函数内不能修改类成员的值</p>
</blockquote>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="Object的一些默认方法"><a href="#Object的一些默认方法" class="headerlink" title="Object的一些默认方法"></a>Object的一些默认方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">int</span> hash = obj.hashCode(); <span class="comment">// navive方法, 返回内存地址, 但String.hashCode不是这样</span></span><br><span class="line"><span class="keyword">boolean</span> b = obj.equals(obj); <span class="comment">// return obj==this;</span></span><br><span class="line">Class cl = obj.getClass(); <span class="comment">// navive方法</span></span><br><span class="line">Class cl2 = Object.class; <span class="comment">// 通过 类名.class获取class实例</span></span><br><span class="line">Object newObject = obj.clone(); <span class="comment">// error ! clone是protected native方法</span></span><br></pre></td></tr></table></figure>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>Object的equals方法默认是比较引用地址. equals方法的特点:</p>
<ul>
<li>自反性: a.eq(a)==true</li>
<li>对称性: if a.eq(b)==true, then b.eq(a)==true</li>
<li>传递性: a-&gt;b, b-&gt;c, a-&gt;c</li>
</ul>
<p>所以伪码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if super.equals==false false</span><br><span class="line">if this==obj true</span><br><span class="line">if obj==null false</span><br><span class="line">if class!=obj.class false</span><br><span class="line">if [!obj instanceof this] false</span><br><span class="line">其他的属性比较...</span><br></pre></td></tr></table></figure>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p><code>hashCode()</code>返回int类型, 返回值可以看成是对象的”消息摘要”</p>
<p>Object 默认的 hasCode()返回的并不是内存地址, hasCode()内部调用了 native 方法, 不同的 JVM 实现可能不一样, OpenJDK 的实现如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mark = monitor-&gt;header();</span><br><span class="line"></span><br><span class="line">hash = mark-&gt;hash();</span><br><span class="line">if (hash == 0) &#123;</span><br><span class="line">  hash = get_next_hash(Self, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果第一次hashCode, 则通过<code>get_next_hash</code> 重新获取一个随机值, 并保存在对象头</p>
<blockquote>
<p>生成 hash 的最终函数 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp#l555" target="_blank" rel="noopener">get_next_hash</a>，这个函数提供了 6 种生成 hash 值的方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. A randomly generated number.</span><br><span class="line">1. A function of memory address of the object.</span><br><span class="line">2. A hardcoded 1 (used for sensitivity testing.)</span><br><span class="line">3. A sequence.</span><br><span class="line">4. The memory address of the object, cast to int.</span><br><span class="line">5. Thread state combined with xorshift (https://en.wikipedia.org/wiki/Xorshift)</span><br></pre></td></tr></table></figure>
<p>那么默认用哪一个呢？根据 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/globals.hpp#l1127" target="_blank" rel="noopener">globals.hpp</a>，OpenJDK8默认采用第五种方法。而 <a href="http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/5b9a416a5632/src/share/vm/runtime/globals.hpp#l1100" target="_blank" rel="noopener">OpenJDK7</a> 和 <a href="http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/5cec449cc409/src/share/vm/runtime/globals.hpp#l1128" target="_blank" rel="noopener">OpenJDK6</a> 都是使用第一种方法，即 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/os.cpp#l814" target="_blank" rel="noopener">随机数生成器</a>。</p>
<p>@ref: <a href="https://cloud.tencent.com/developer/article/1622192" target="_blank" rel="noopener">java默认的hashcode方法到底得到的是什么？ - 云+社区 - 腾讯云</a></p>
<h3 id="equals-vs-hashCode"><a href="#equals-vs-hashCode" class="headerlink" title="equals() vs hashCode()"></a>equals() vs hashCode()</h3><ul>
<li>如果重新了equals方法, 就必须重写hashCode方法, 以便可以将对象插入到HashMap中(摘自Java核心技术卷1, 为什么?)</li>
<li>如果两个对象equals, 那么hashCode一定相同, 如果两个对象hashCode相同, 但不一定equals, 为什么?</li>
<li>equals要依次比较每个属性的值, hashCode是对”需要比较的属性”求散列, 所以如果哈希方法不够好出现碰撞, hashCode相同但是每个属性不equals</li>
<li>因为HashMap插入时用Key的hashCode作为数组的下标, 所以hashCode返回必须是正int</li>
<li>好的hashCode方法应该对”需要比较的每个属性”充分散列</li>
</ul>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>Object.clone默认是浅拷贝;</p>
<h4 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h4><p><code>Cloneable</code>和<code>Serializable</code> 一样都是标记型接口，它们内部都没有方法和属性，<code>implements Cloneable</code>表示该对象能被克隆，能使用<code>Object.clone()</code>方法。<br>如果没有<code>implements Cloneable</code>的类调用<code>Object.clone()</code>方法就会抛出 <strong>CloneNotSupportedException</strong></p>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Example类的 <code>clone()</code>默认调用了 <code>Object.clone()</code>, 这是一个Native方法, 默认是 <strong>浅克隆（shallow clone）</strong></p>
<blockquote>
<p>浅拷贝（浅克隆）复制出来的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。<br>深拷贝（深克隆）复制出来的所有变量都含有与原来的对象相同的值，那些引用其他对象的变量将指向复制出来的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
</blockquote>
<p>如何实现 deep clone:<br>clone方法里要对每个引用类型的成员都调用一次 <code>clone()</code>, 例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Wheel wheel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Car car = (Car)<span class="keyword">super</span>.clone();</span><br><span class="line">        car.wheel = (Wheel)<span class="keyword">this</span>.wheel.clone();</span><br><span class="line">        <span class="keyword">return</span> car</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用Serializable实现深克隆（deep clone）:</strong></p>
<p>略</p>
<h3 id="安全的类型转换"><a href="#安全的类型转换" class="headerlink" title="安全的类型转换"></a>安全的类型转换</h3><ul>
<li>向上转型:  <code>List&lt;Object&gt; list = new ArrayList&lt;Object&gt;()</code>;</li>
<li>向下转型: <code>ChildA child = (obj instanceof ChildA ? (ChildA)obj : null);</code></li>
</ul>
<blockquote>
<p>instanceof关键字用于判断一个引用类型变量所指向的对象是否是一个类（或接口、抽象类、父类）的实例。</p>
</blockquote>
<h2 id="构造和销毁"><a href="#构造和销毁" class="headerlink" title="构造和销毁"></a>构造和销毁</h2><p>构造器(constructor):<br>Java的构造器实际上是一个static函数, 因为在没有实例化之前就可以调用构造, 但是一般来说, static方法里不能使用<code>this</code>关键字, 因为<code>this</code>的含义是指向类实例本身的一个引用(C++的this是指向类实例自身的指针), 但是构造器这个特殊的static方法里却可以使用<code>this</code>关键字.</p>
<h3 id="继承和构造顺序"><a href="#继承和构造顺序" class="headerlink" title="继承和构造顺序"></a>继承和构造顺序</h3><p>派生类被实例化时, 总是先调用<code>super()</code>, 即基类的默认构造方法. 在派生类的构造函数中, 也可以使用<code>super(args...)</code>调用指定的基类构造方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"parent"</span>); <span class="comment">// 通过super调用基类的"非默认构造器"</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"child"</span>); <span class="comment">// 通过this调用Override的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h3><p>如果一个类没有定义<em>任何</em>构造方法, 那么编译器会为这个类自动生成一个不带参数的<code>默认构造方法</code>,</p>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ul>
<li>Java允许在类中定义一个<code>finalize()</code>方法, 这个方法里可以做什么? JVM何时调用这个方法?</li>
<li>Efftive Java中提到<code>finalize()</code>方法可用作”守卫方法”, 比如socket在这里做最后的关闭检查:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">protect <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  close();</span><br><span class="line">  <span class="keyword">super</span>.finalize(); <span class="comment">// 不要忘记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ul>
<li>在调用Java的方法时, 会隐式的将”指向自身的引用”作为方法的第一个参数<code>function(this, param)</code>, C++的this是”指向类实例自身”的指针;</li>
<li>static方法的第一个参数则是null.</li>
</ul>
<h2 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h2><ul>
<li>没有任何权限修饰, 默认是包内可见, friendly的;</li>
<li>访问权限 public &gt; protected &gt; friendly &gt; private<ul>
<li>protected: 包可见, 子类可见;</li>
<li>friendly: 包可见, 子类不可见 (没有这个关键字, 什么都不加默认是friendly);</li>
<li>private: 只对该类型可见;</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>Java不支持多重继承class, 但支持多重继承interface. 思考一个问题:</li>
</ul>
<blockquote>
<p>“有两个类B1和B2继承自A. 假设B1和B2都继承了A的方法并各自进行了覆盖, 编写了自己的实现. 假设C通过多重继承继承了B1和B2, 那么C应该同时继承B1和B2的重载方法, 那么它应该继承哪个的呢？是B1的还是B2的呢？”</p>
</blockquote>
<p>C++中经常会掉入这个陷阱, 虽然它也提出了替代的方法来解决这个问题. 我们在Java中就不会出现这个问题. 就算两个接口拥有同样的方法, 实现的类只会有一个方法, 这个方法由实现的类编写. 动态的加载类会让多重继承的实现变得困难.</p>
<blockquote>
<p>因为在C++没有Interface, 在C++中使用”虚拟继承”解决上面的问题:</p>
<ol>
<li>B1和B2去虚拟继承A: <code>class B1 : public virtual A</code> ,<code>class B2 : public virtual A</code></li>
<li>C多重继承B1和B2: <code>class C : public B1, public B2</code> ;</li>
</ol>
</blockquote>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><ul>
<li>含有抽象方法(abstract function)的类是抽象类(abstract class).</li>
<li>任何子类都必须实现抽象类的抽象方法, 或者自身也声明为抽象类;</li>
</ul>
<p>抽象类<code>public abstract class A</code>, 和接口的异同:</p>
<ul>
<li>抽象类和接口都能有自己的属性成员, 不同的是接口中的成员属性都是static和final的, 因此比较合适的做法是在interface里放置一些常量.</li>
<li>抽象类里还可以定义自己的方法实现, 并能被派生类继承, 但接口不能含有任何方法实现.</li>
</ul>
<h2 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态(polymorphism)"></a>多态(polymorphism)</h2><p>多态的含义就是一个方法多种实现, 分静态和动态, 在同一个类中实现多态是通过<code>函数重载</code> -Overload, 在继承中实现多态是通过<code>运行时绑定</code>.</p>
<ul>
<li>在Java的继承中, 除了static和final方法(private也是final的)之外, 其他的方法都是<code>运行时绑定</code>的,</li>
<li>类的属性成员并不在多态的讨论范围内, “多态”仅仅指方法的多态. 比如基类和派生类都有field属性, 那么在派生类实例中, 将包含两个field, 通过<code>基类.field</code>也只能访问基类的field, 因为 <strong>属性没有多态</strong>.</li>
<li>类的构造方法不具备多态性, 因为类的构造器默认是static属性的, 对比C++的构造也不具备多态性(C++通过虚函数实现), 原因是构造期间尚未生成虚函数表.</li>
<li>在派生类中, 覆写(Override)基类的私有方法不会编译报错, 但不会照期望的执行, 结论就是: 只有非private方法才可以被派生类覆写(Override).</li>
</ul>
<p>Java 的运行时绑定，是通过 Klass 对象的 vtable 实现的 @ref: <a href="/12.Java/Advanced-Java.02b1.MetaSpace解析/" title="Advanced-Java.02b1.MetaSpace解析">Advanced-Java.02b1.MetaSpace解析</a></p>
<h3 id="Java-和-C-实现多态的对比"><a href="#Java-和-C-实现多态的对比" class="headerlink" title="Java 和 C++实现多态的对比"></a>Java 和 C++实现多态的对比</h3><table>
<thead>
<tr>
<th>C++</th>
<th>Java</th>
</tr>
</thead>
<tbody>
<tr>
<td>virtual func</td>
<td>普通方法</td>
</tr>
<tr>
<td>virtual f()=0</td>
<td>abstract func()</td>
</tr>
<tr>
<td>abstract class</td>
<td>interface</td>
</tr>
</tbody>
</table>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>@todo</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="一般内部类"><a href="#一般内部类" class="headerlink" title="一般内部类"></a>一般内部类</h3><ul>
<li>外部类不一定有内部类实例, 但内部类一定有对应的外部类,</li>
<li>内部类的成员不能是static, 也不能有static代码块(但内部类可以是static的, 嵌套类)</li>
<li>外部类和内部类可以 <strong>互相访问</strong> 所有成员(包括private);<ul>
<li>外部类可以访问内部类的一切成员, 无论这个内部类是 public 还是 private 的, 无论内部类的成员是 public 还是 private 的, 外部类通过 <code>内部类实例.成员名</code> 访问内部类的成员;</li>
<li>内部类可以访问外部类的一切成员, 包括外部类的 private 成员, 访问方式是 <code>外部类类名.this.func()</code>, 或者也可以”直接调用”外部类的成员.</li>
</ul>
</li>
<li>在编译成功后, 会出现这样两个class文件: <code>Outer.class</code>和<code>Outer$Inner.class</code>;</li>
</ul>
<p>定义一个内部类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * public可有可无, 默认public的内部类是包内可见, friendly</span></span><br><span class="line"><span class="comment">   * 内部类可以单独继承一个抽象类或实现一个接口 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      show(); <span class="comment">// 可以这样调用外部类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外部类如何访问内部类"><a href="#外部类如何访问内部类" class="headerlink" title="外部类如何访问内部类"></a>外部类如何访问内部类</h4><ul>
<li>内部类访问外部类属性: <code>println(OutterClass.this.propertyName);</code></li>
<li>外部类访问内部类属性: <code>println(inner.propertyName)</code> // 必须先创建内部类实例inner</li>
<li>在拥有外部类对象之前, 是不可能创建内部类对象的, 换句话说, 其他人只能通过外部类对象才能访问内部类:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outter.Inner in = <span class="keyword">new</span> Outter.Inner(); <span class="comment">// ERROR! 要先创建外部类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的创建内部类对象:</span></span><br><span class="line">Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner in = out.getInner(); <span class="comment">// 在getter里返回Inner对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种创建方式:</span></span><br><span class="line">Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner in = out.new Inner(); <span class="comment">// obj.new语法</span></span><br></pre></td></tr></table></figure>
<h4 id="其他类如何访问内部类"><a href="#其他类如何访问内部类" class="headerlink" title="其他类如何访问内部类"></a>其他类如何访问内部类</h4><ul>
<li>public的内部类 的public成员是包可见;</li>
<li>public的内部类 的private成员包不可见, 仅对外部类可见;</li>
<li>当Inner是private时, 其他类不能通过<code>Outter.Inner in = out.getInner()</code>或者<code>Outter.Inner in = out.new Inner</code>的方式创建Inner对象, 因为Inner类就是private的;<br>但是, 如果private的Inner继承自一个Base类, 这个Base类又是包可见（Public）的, 那么可以通过<code>Base base = out.getInner()</code>的方式创建内部类对象, 换句话说, 这个Base是内部类的一个对外接口, 只能通过这个对外接口访问private的内部类;</li>
</ul>
<p>以上参考: <a href="http://zhangjunhd.blog.51cto.com/113473/65624/" target="_blank" rel="noopener">探讨Java内部类的可见性;</a> @ref</p>
<h3 id="内部类的必要性"><a href="#内部类的必要性" class="headerlink" title="内部类的必要性?"></a>内部类的必要性?</h3><ol>
<li>Java不允许多重继承, 使用内部类可以”继承”外部类的方法, 并且内部类可以独立的继承自另一个抽象类或者接口.</li>
<li>把实现细节放在内部类, 相当于是对外隐藏细节, 封装.</li>
<li>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现, 所以无论外围类是否已经继承了某个（接口的）实现, 对于内部类都没有影响[Think in Java]</li>
</ol>
<h3 id="局部内部类-amp-匿名类"><a href="#局部内部类-amp-匿名类" class="headerlink" title="局部内部类 &amp; 匿名类"></a>局部内部类 &amp; 匿名类</h3><ul>
<li>匿名类首先要有一个Interface or 基类;</li>
<li>匿名类没有名字, 也<strong>没有构造方法</strong>, 没有访问修饰符;</li>
<li>匿名类可以访问外部的变量, 但是<strong>创建匿名类的方法参数是final的</strong>;</li>
</ul>
<p>定义一个匿名类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匿名类要有一个接口或基类 */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pool <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 传入匿名类的参数要声明为final的 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pool() &#123;</span><br><span class="line">        <span class="keyword">int</span> number = num++;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;    <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UI中大量使用的事件callback:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="嵌套内部类"><a href="#嵌套内部类" class="headerlink" title="嵌套内部类"></a>嵌套内部类</h3><ul>
<li>static的内部类被称为<strong>嵌套类</strong>, 嵌套内部类不需要由外部类创建, 也就没有隐藏的外部类引用</li>
<li>不能调用非 static 的外部类成员, 即不能访问 <code>Outter.this.property</code>;</li>
<li>外部类初始化的时候, 不会触发嵌套内部类的初始化.</li>
</ul>
<blockquote>
<p>静态内部类的初始化的时机：<br>初始化时会初始化 static 成员变量,  执行 static 代码块, JVM 会把这些操作放在一个叫 <code>clint</code> 的方法中执行</p>
</blockquote>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>String是一个特殊的类, 不需要构造函数就可以创建实例<code>String s = &quot;hello world&quot;</code>;</li>
<li>String的<code>char[]</code>是final static的, 只有一份拷贝.一旦String被创建, 字符串的内容就不可改变了 // Question: 当new一个String时, 是如何判断字符串池里是否已经有相同字符串的?</li>
<li>字符串的比较不能使用<code>==</code>: <code>==</code>仍然比较的是引用, 而应该使用<code>String.equals()</code></li>
</ul>
<h2 id="String一些方法和实现"><a href="#String一些方法和实现" class="headerlink" title="String一些方法和实现"></a>String一些方法和实现</h2><ul>
<li><code>bool contains(String str)</code> : 判断参数s是否被包含在字符串中，并返回一个布尔类型的值</li>
<li><code>int indexOf(String str, int fromIndex)</code> :</li>
<li><code>String substring(int beginIndex, int endIndex)</code> : 该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。</li>
<li><code>int compareTo(String anotherString)</code> : 该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。</li>
<li><code>boolean equals(Object anotherObject)</code> : 比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。<ul>
<li>比较引用是否相等</li>
<li>要比较的对象是否 <code>instanceof String</code></li>
<li>比较数组的长度 &amp; 依次比较每个char</li>
</ul>
</li>
<li><code>String concat(String str)</code> : 将参数中的字符串str连接到当前字符串的后面, 生成一个新字符串返回</li>
<li><code>String replace(char oldChar, char newChar)</code> : 用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。</li>
<li><code>String replaceAll(String regex, String replacement)</code> : 该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。</li>
</ul>
<h2 id="String-不可被继承"><a href="#String-不可被继承" class="headerlink" title="String 不可被继承"></a>String 不可被继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure>
<h2 id="比较StringBuffer"><a href="#比较StringBuffer" class="headerlink" title="比较StringBuffer"></a>比较StringBuffer</h2><ul>
<li>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。两者的<code>char []</code> 不是final的, 可以修改;</li>
<li>StringBuffer线程安全, 所有方法都是synchronized的;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 比较 `String concat(String)`, `+`, 以及 StringBuffer 效率*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认StringBuilder的char[]初始长度是16</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  <span class="number">1000</span>; i++)  &#123;</span><br><span class="line">  sb.append(<span class="string">" "</span>);</span><br><span class="line">  <span class="comment">// 可以看到sb.append的实现, 每次拷贝要扩容char[], 所以StringBuilder(len)设置好初始值</span></span><br><span class="line">  <span class="comment">// 拼接字符串使用sb.append()的代价最小, 因为不用频繁创建Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">// concat的实现&gt;</span></span><br><span class="line"><span class="comment">/* 计算拼接后的长度len, 创建一个char[len]</span></span><br><span class="line"><span class="comment"> * 拷贝str2的cha[] 到上面创建的数组</span></span><br><span class="line"><span class="comment"> * 调用String(char[]) 生成了新的String对象</span></span><br><span class="line"><span class="comment"> * 所以, 每次对String改变都会导致创建新的对象, 性能差异在这里</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">str.concat(<span class="string">" "</span>).concat(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器会把下面的string + 的操作转为StringBuild, 但生成1000次StringBuilder实例, 操作符+效率差在这里</span></span><br><span class="line">String str2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  <span class="number">1000</span>; i++)  &#123;</span><br><span class="line">  str2 = str2 + <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String-char-byte的互转"><a href="#String-char-byte的互转" class="headerlink" title="String,char,byte的互转"></a>String,char,byte的互转</h2><ul>
<li>String是由<code>char[]</code>存储数据, char是unicode, 用16bit(2字节)的数值表示一个char: <code>char c = &#39;\u554a&#39;;</code></li>
<li>String和char都可以用<code>\u0000</code>这种方式初始化.</li>
<li>byte是字节, String/char转为byte[]时, 不能确定byte[]的长度, 视转换用哪种编码(GBK/UTF-8)而定.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String string = <span class="string">"\u0048\u0069"</span>; <span class="comment">// Unicode对应的字符串是"Hi"</span></span><br><span class="line"><span class="keyword">char</span>[] chars = string.toCharArray();</span><br><span class="line">System.out.printf(<span class="string">"str_len= %d, arr_len= %d"</span>, string.length(), chars.length); <span class="comment">// 输出2 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串指定位置的Unicode值:</span></span><br><span class="line"><span class="keyword">int</span> index = s.offsetByCodePoints(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(index + <span class="string">":"</span> + s.codePointAt(index)); <span class="comment">// 输出72</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"嘿H1"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b1 = str.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] b2 = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line"><span class="comment">// str, b1, b2, c的length分别是?</span></span><br></pre></td></tr></table></figure>
<p>unicode编码只指定了编码值, gbk和utf8定义了如何存储编码值.</p>
<ul>
<li>一个char存储的是16位的unicode, 范围0~0xFFFF(65535), 超过这个范围的汉字, 比如”𩄀”, 要用两个char也就是4字节表示.</li>
<li>如果unicode用gbk编码, 一个中文3字节, 一个英文1字节;</li>
<li>如果unicode用utf-8编码, 中文2字节, 英文一字节;</li>
<li>所以上面的输出分别是3, 5, 6, 3;</li>
</ul>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="String-amp-StringBuffer"><a href="#String-amp-StringBuffer" class="headerlink" title="String &amp; StringBuffer"></a>String &amp; StringBuffer</h2><p>见 <a href="#字符串">字符串</a></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>见 <a href="#数据类型">数据类型</a></p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>@todo</p>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><ul>
<li>SimpleDateFormat 不是线程安全的</li>
<li>JDK8 的 DateTimeFormatter 线程安全</li>
</ul>
<blockquote>
<p>使用 DateTimeFormatter 替换 SimpleDateFormat: <a href="https://zhuanlan.zhihu.com/p/51695220" target="_blank" rel="noopener">你真的会使用SimpleDateFormat吗？ - 知乎</a></p>
</blockquote>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>图-Java异常类的层次结构:<br><img src="/images/java/java_exception.png" alt="Java Exception"></p>
<h2 id="Error-amp-Exception"><a href="#Error-amp-Exception" class="headerlink" title="Error &amp; Exception"></a>Error &amp; Exception</h2><p>在 Java 语言规范中，所有异常都是 Throwable 类或者其子类的实例。Throwable 有两大直接子类。第一个是 Error，涵盖程序不应捕获的异常。当程序触发 Error 时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。第二子类则是 Exception，涵盖程序可能需要捕获并且处理的异常。</p>
<ul>
<li><strong>Error</strong> 是程序无法处理的, 内存不足或JVM的错误, 比如 <code>OutOfMemoryError</code>, <code>ThreadDeath</code></li>
<li><strong>Exception</strong> 可由程序处理, 又分为”CheckedException”(受捡异常, 上图粉红色), 和”UncheckedException”(不受检异常, 上图蓝色)<ul>
<li>前者是程序需要捕获并处理的异常(比如打开文件错误, 网络超时等待), 需要throws-try-catch语句显式的捕获;</li>
<li>后者是代码错误, 比如数组越界, 这种不需要明确throws, 如果throws了也不强制代码必须catch, 其实Error也能算是不受检异常;</li>
</ul>
</li>
</ul>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Throwable</span><br><span class="line">    Error: 也算是&quot;不受检&quot;</span><br><span class="line">      OutOfMemoryError</span><br><span class="line">      StackOverflowError</span><br><span class="line">      ThreadDeath</span><br><span class="line">    Exception:</span><br><span class="line">      UserDefinedException: 用户自定义异常继承者Exception</span><br><span class="line">      ClassNotFoundException: 调用Class.forName时</span><br><span class="line">      InstantiationException: 调用Class.NewInstance时</span><br><span class="line">      IOException: 有一大堆派生自IOException的异常...</span><br><span class="line">      EOFException: 意外遇到文件或流的末尾，如果是网络IO，可能是另一端非正常关闭连接</span><br><span class="line">      ConnectException: connection refused connect.</span><br><span class="line">      BindException: address already in use</span><br><span class="line">      RuntimeException: (不受检异常)</span><br><span class="line">        NullPointerException: 最著名的不受检异常</span><br><span class="line">        IndexOutOfBoundsException: 数组越界</span><br><span class="line">        IllegalArgumentException: 调用方法时参数异常</span><br><span class="line">        IllegalAccessException: 方法对类没有访问权限</span><br><span class="line">        ArithmeticException: 数学算数异常</span><br><span class="line">        ArrayStoreException: 试图向数组存入不支持的类型</span><br><span class="line">        ClassCastException: 调用Class.cast(Object)时</span><br><span class="line">        NotSerializableException: 尝试对没有声明 Serializable接口的类进行序列化</span><br></pre></td></tr></table></figure>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>如果该异常被 catch 代码块捕获，finally 代码块则在 catch 代码块之后运行。<br>在某些不幸的情况下，catch 代码块也触发了异常，那么 finally 代码块同样会运行，并会抛出 catch 代码块触发的异常。<br>在某些极端不幸的情况下，finally 代码块也触发了异常，那么只好中断当前 finally 代码块的执行，并往外抛异常。</p>
<h2 id="try-catch-finally中的-return"><a href="#try-catch-finally中的-return" class="headerlink" title="try-catch-finally中的 return"></a>try-catch-finally中的 return</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x返回多少? 会打印出什么?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testTryCatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ++x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：返回 2</p>
<p>如果在 try-catch-finally 3个位置分别插入 return ，代码会如何执行？<br>需要先明白一些概念：</p>
<ul>
<li>每个 java 方法执行时都会创建一个栈帧，栈帧中比较重要的数据结构有：操作数栈、局部变量表<ul>
<li>局部变量表：可以认为是一个数组，里面存储了方法内出现的所有局部变量</li>
<li>操作数栈：存放的是运行时的指令，也是栈结构，运行的指令依次进栈，运行完后 pop</li>
</ul>
</li>
<li>编译过程中，如果一个方法里有 finally，为了保证它一定被执行，会在任何可能的代码执行路径的出口处，增加一段 finally 代码块，例如 try 的出口处增加 finally 块，catch 的出口处增加 finally 块.. 如果不知道这一点，那么看字节码会有疑惑，为什么会出现很多重复的字节码？</li>
</ul>
<blockquote>
<p>扩展阅读：</p>
<ul>
<li><a href="https://time.geekbang.org/column/article/12134" target="_blank" rel="noopener">06 | JVM是如何处理异常的？</a></li>
<li>JVM 运行时数据区: 局部变量表 &amp; 操作数栈  <a href="https://developer.aliyun.com/article/825859" target="_blank" rel="noopener">https://developer.aliyun.com/article/825859</a></li>
</ul>
</blockquote>
<p>如果 try 语句里有 return，那么代码的行为如下（见《Java Virtual Machine Specification》的 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5" target="_blank" rel="noopener">Chapter 4. The class File Format</a> 中，「 Exceptions and finally」）：</p>
<blockquote>
<p>If the try clause executes a return, the compiled code does the following:</p>
<ol>
<li>Saves the return value (if any) in a local variable.</li>
<li>Executes a jsr to the code for the finally clause.</li>
<li>Upon return from the finally clause, returns the value saved in the local variable.</li>
</ol>
</blockquote>
<p>意思是：</p>
<blockquote>
<p>如果 try 语句里有 return，那么代码的行为如下：<br>1.如果有返回值，就把返回值保存到局部变量中<br>2.执行jsr指令跳到finally语句里执行<br>3.执行完finally语句后，返回之前保存在局部变量表里的值</p>
</blockquote>
<p>那么字节码是如何实现上面的标准描述呢？</p>
<ol>
<li>为了保证 finally 一定被执行，所以会在 try 块的出口处，也增加 finally 代码块字节码</li>
<li>字节码对于返回值的处理是这样的，如果要把 a 这个局部变量作为返回值，那么 <code>return a</code> 这个 java 代码，翻译为字节码是：<code>iload_1</code> 然后 <code>ireturn</code>, 解释，把局部变量 a 加载到操作数栈，然后调用 ireturn 返回之。这里的 iload_1是返回局部变量表中1的位置（假定变量 a 在局部变量表位置1）</li>
<li>明白了对于返回值的处理，再看字节码就会清楚一些：</li>
</ol>
<p><img src="/images/Java-Tutorials.01.try-finally-bytecode-example.png" alt="../_images/Java-Tutorials.01.try-finally-bytecode-example.png"></p>
<ul>
<li>0-2，是 try 中的++</li>
<li>5-6是 finally 的++，注意这里++完，<code>istore_2</code>把 x 保存在了本地变量表2的位置</li>
<li>10-11 是 return 之前 <code>iload_2</code> 是将本地变量表位置2的数据，放入操作数栈，然后 <code>ireturn</code> 返回</li>
</ul>
<blockquote>
<p>转自: <a href="https://www.cnblogs.com/averey/p/4379646.html?spm=a2c6h.12873639.article-detail.14.505b5272dyUZoJ" target="_blank" rel="noopener">“你真的了解try{ return }finally{}中的return？</a></p>
</blockquote>
<h2 id="getMessage-vs-toString"><a href="#getMessage-vs-toString" class="headerlink" title="getMessage vs toString"></a>getMessage vs toString</h2><p><img src="/images/java/exception-tostring.png" alt="Exception_toString"></p>
<p>如代码所示,<br><code>e.toString()</code> 获取的信息包括异常类型和异常详细消息，而<code>e.getMessage()</code>只是获取了异常的详细消息字符串,<br>所以推荐在Catch中使用<code>e.toString()</code></p>
<h2 id="常见异常及解释"><a href="#常见异常及解释" class="headerlink" title="常见异常及解释"></a>常见异常及解释</h2><blockquote>
<p><a href="http://www.importnew.com/16725.html" target="_blank" rel="noopener">Java常见异常及解释 - ImportNew</a></p>
</blockquote>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><ul>
<li>表达式<code>assert 表达式:错误消息</code> 比如<code>assert x&gt;y : &quot;断言失败!&quot;</code></li>
<li>如何开启关闭断言? 单点为某个类开启断言? <code>java -ea Xxx</code> , <code>java -ea:MyClass Xxx</code></li>
</ul>
<h1 id="Native-Method"><a href="#Native-Method" class="headerlink" title="Native Method"></a>Native Method</h1><h2 id="实现一个Native方法"><a href="#实现一个Native方法" class="headerlink" title="实现一个Native方法:"></a>实现一个Native方法:</h2><ol>
<li><p>声明java native method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CJNativeInterfaceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">input</span><span class="params">(String prompt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"./libJniTest.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CJNativeInterfaceDemo jniDemo = <span class="keyword">new</span> CJNativeInterfaceDemo();</span><br><span class="line">        jniDemo.input(<span class="string">"JNI Test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成c++头文件</p>
<ul>
<li><code>javac CJNativeInterfaceDemo.java</code> 生成.class文件</li>
<li><code>javah -jni CJNativeInterfaceDemo</code> 生成.h文件</li>
</ul>
</li>
<li><p>实现C++函数并编译成动态库<code>gcc  -I/usr/lib/jvm/java-7-openjdk-i386/include/ CJNativeInterfaceDemo.c -shared -o libJniTest.so</code></p>
</li>
</ol>
<hr>
<h1 id="附录-JDK常用类"><a href="#附录-JDK常用类" class="headerlink" title="附录:JDK常用类"></a>附录:JDK常用类</h1><h2 id="java-lang📦继承关系图"><a href="#java-lang📦继承关系图" class="headerlink" title="java.lang📦继承关系图"></a>java.lang📦继承关系图</h2><p><img src="/images/java/java_lang_package.gif" alt="java.lang"></p>
<h2 id="java-util📦继承关系图"><a href="#java-util📦继承关系图" class="headerlink" title="java.util📦继承关系图"></a>java.util📦继承关系图</h2><p><img src="/images/java/java_util_package.gif" alt="java.util"></p>
<h1 id="附录-补码-反码"><a href="#附录-补码-反码" class="headerlink" title="附录:补码,反码"></a>附录:补码,反码</h1><blockquote>
<p>反码: 正数的反码是本身, 负数的反码=符号位不变, 其他位取反<br>补码: 正数的补码是本身, 负数的补码=符号位不变, 其他位取反, 再加1<br>看几组补码-真值: “1111 1111”=-1,  “1000 0010”=-126,  “1000 001”=-127, “1000 0000”=-128<br>不要用计算补码的方式去”算”-128的补码, 1000 0000 是定义的.</p>
</blockquote>
<p>参考:</p>
<ul>
<li>@ref <a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">原码, 反码, 补码 详解</a></li>
<li>@ref <a href="https://www.douban.com/note/223507364/" target="_blank" rel="noopener">原码、反码和补码</a></li>
</ul>
<h2 id="取余-amp-取模"><a href="#取余-amp-取模" class="headerlink" title="取余 &amp; 取模"></a>取余 &amp; 取模</h2><ul>
<li>取余：<code>x%y</code></li>
<li>取模：<code>Math.floorMod(x, y)</code></li>
</ul>
<p>取余和取模的区别 =》 [[../19.Algorithm/Alg.数学基础]] 的「取余 &amp; 取模」</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li><code>&amp;</code> 符号位</li>
<li><code>|</code> 符号位</li>
<li><code>~</code> 符号位</li>
<li><code>^</code> 符号位</li>
<li><code>&lt;&lt;</code> 左移: 丢弃最高位(符号位同样丢弃), 0补最低位. 当byte和short左移时, 自动升级为int型.<ul>
<li>数学意义: 左移n位相等于乘以2^n</li>
</ul>
</li>
<li><code>&gt;&gt;</code> 右移: 高位补充符号位, 正数右移补充0, 负数右移补充1, 当byte和short右移时, 自动升级为int型.<ul>
<li>数学意义:  右移n位相当于除以2^n</li>
</ul>
</li>
<li><code>&gt;&gt;&gt;</code> 无符号右移: 无论正负, 高位补充0<ul>
<li>无符号右移运算符&gt;&gt;&gt; 只是对32位和64位的值有意义</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/12.Java/Advanced-Java.08.编译/" rel="next" title="Advanced Java-08-编译">
                <i class="fa fa-chevron-left"></i> Advanced Java-08-编译
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/12.Java/Java-Tutorials.02.集合(Collection)/" rel="prev" title="Java Tutorials-02-集合">
                Java Tutorials-02-集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/hexo_avatar.png"
                alt="beefyheisenberg" />
            
              <p class="site-author-name" itemprop="name">beefyheisenberg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">482</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">414</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/_kongyang/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型"><span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮点数的比较"><span class="nav-text">浮点数的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BitSet"><span class="nav-text">BitSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装器"><span class="nav-text">包装器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#包装器API"><span class="nav-text">包装器API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装箱拆箱的实现"><span class="nav-text">装箱拆箱的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#慎用-Long-equals"><span class="nav-text">慎用 Long.equals()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigInteger-BigDecimal"><span class="nav-text">BigInteger, BigDecimal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays"><span class="nav-text">Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-util-Arrays"><span class="nav-text">java.util.Arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-lang-reflect-Array"><span class="nav-text">Java.lang.reflect.Array</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-text">枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#左右结合"><span class="nav-text">左右结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位移运算"><span class="nav-text">位移运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang-Math"><span class="nav-text">java.lang.Math</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制流程和语句"><span class="nav-text">控制流程和语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法"><span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Swap"><span class="nav-text">Swap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变参函数"><span class="nav-text">变参函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final-关键字"><span class="nav-text">final 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static-关键字"><span class="nav-text">static 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object的一些默认方法"><span class="nav-text">Object的一些默认方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#equals"><span class="nav-text">equals()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode"><span class="nav-text">hashCode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals-vs-hashCode"><span class="nav-text">equals() vs hashCode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clone"><span class="nav-text">clone()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cloneable接口"><span class="nav-text">Cloneable接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全的类型转换"><span class="nav-text">安全的类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造和销毁"><span class="nav-text">构造和销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承和构造顺序"><span class="nav-text">继承和构造顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认构造方法"><span class="nav-text">默认构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#销毁"><span class="nav-text">销毁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this关键字"><span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控制权限"><span class="nav-text">访问控制权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类和接口"><span class="nav-text">抽象类和接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态-polymorphism"><span class="nav-text">多态(polymorphism)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-和-C-实现多态的对比"><span class="nav-text">Java 和 C++实现多态的对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一般内部类"><span class="nav-text">一般内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部类如何访问内部类"><span class="nav-text">外部类如何访问内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他类如何访问内部类"><span class="nav-text">其他类如何访问内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类的必要性"><span class="nav-text">内部类的必要性?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部内部类-amp-匿名类"><span class="nav-text">局部内部类 &amp; 匿名类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套内部类"><span class="nav-text">嵌套内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String一些方法和实现"><span class="nav-text">String一些方法和实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-不可被继承"><span class="nav-text">String 不可被继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较StringBuffer"><span class="nav-text">比较StringBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-char-byte的互转"><span class="nav-text">String,char,byte的互转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用类"><span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String-amp-StringBuffer"><span class="nav-text">String &amp; StringBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装类"><span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math类"><span class="nav-text">Math类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期类"><span class="nav-text">日期类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常处理"><span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-amp-Exception"><span class="nav-text">Error &amp; Exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承关系"><span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-catch"><span class="nav-text">try-catch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-catch-finally中的-return"><span class="nav-text">try-catch-finally中的 return</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getMessage-vs-toString"><span class="nav-text">getMessage vs toString</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见异常及解释"><span class="nav-text">常见异常及解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#断言"><span class="nav-text">断言</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Native-Method"><span class="nav-text">Native Method</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个Native方法"><span class="nav-text">实现一个Native方法:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录-JDK常用类"><span class="nav-text">附录:JDK常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang📦继承关系图"><span class="nav-text">java.lang📦继承关系图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-util📦继承关系图"><span class="nav-text">java.util📦继承关系图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录-补码-反码"><span class="nav-text">附录:补码,反码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#取余-amp-取模"><span class="nav-text">取余 &amp; 取模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算符"><span class="nav-text">位运算符</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">beefyheisenberg</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://beefyheisenberg.github.io/12.Java/Java-Tutorials.01.基础/';
          this.page.identifier = '12.Java/Java-Tutorials.01.基础/';
          this.page.title = 'Java Tutorials-01-基础';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dropnotes-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
